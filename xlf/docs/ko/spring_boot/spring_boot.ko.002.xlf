<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="spring_boot">
    <body>
      <group id="spring_boot">
        <trans-unit id="afc98e0ccc015d6df0f863d3463366136c81e1d1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DatabaseClient&lt;/code&gt; bean is auto-configured, and you can &lt;code&gt;@Autowire&lt;/code&gt; it directly into your own beans, as shown in the following example:</source>
          <target state="translated">A &lt;code&gt;DatabaseClient&lt;/code&gt; bean is auto-configured, and you can &lt;code&gt;@Autowire&lt;/code&gt; it directly into your own beans, as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="5b50c3a0ebb5449844eaa7fb7a94b241c52e3758" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;DefaultAuthenticationEventPublisher&lt;/code&gt; for publishing authentication events.</source>
          <target state="translated">A &lt;code&gt;DefaultAuthenticationEventPublisher&lt;/code&gt; for publishing authentication events.</target>
        </trans-unit>
        <trans-unit id="ea65e70a215813ebf00501e1246e23e6d8d74852" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;GitProperties&lt;/code&gt; bean is auto-configured if a &lt;code&gt;git.properties&lt;/code&gt; file is available at the root of the classpath. See &quot;&lt;a href=&quot;howto#howto-git-info&quot;&gt;Generate git information&lt;/a&gt;&quot; for more details.</source>
          <target state="translated">A &lt;code&gt;GitProperties&lt;/code&gt; bean is auto-configured if a &lt;code&gt;git.properties&lt;/code&gt; file is available at the root of the classpath. See &quot;&lt;a href=&quot;howto#howto-git-info&quot;&gt;Generate git information&lt;/a&gt;&quot; for more details.</target>
        </trans-unit>
        <trans-unit id="28d1a4e5b505d81f950e76c4fd7acd5a1c162a13" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;HealthContributor&lt;/code&gt; can either be a &lt;code&gt;HealthIndicator&lt;/code&gt; or a &lt;code&gt;CompositeHealthContributor&lt;/code&gt;. A &lt;code&gt;HealthIndicator&lt;/code&gt; provides actual health information, including a &lt;code&gt;Status&lt;/code&gt;. A &lt;code&gt;CompositeHealthContributor&lt;/code&gt; provides a composite of other &lt;code&gt;HealthContributors&lt;/code&gt;. Taken together, contributors form a tree structure to represent the overall system health.</source>
          <target state="translated">A &lt;code&gt;HealthContributor&lt;/code&gt; can either be a &lt;code&gt;HealthIndicator&lt;/code&gt; or a &lt;code&gt;CompositeHealthContributor&lt;/code&gt; . A &lt;code&gt;HealthIndicator&lt;/code&gt; provides actual health information, including a &lt;code&gt;Status&lt;/code&gt; . A &lt;code&gt;CompositeHealthContributor&lt;/code&gt; provides a composite of other &lt;code&gt;HealthContributors&lt;/code&gt; . Taken together, contributors form a tree structure to represent the overall system health.</target>
        </trans-unit>
        <trans-unit id="afd9ed01dfbdc3ea88f99a22b65f500b90a047fb" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RandomValuePropertySource&lt;/code&gt; that has properties only in &lt;code&gt;random.*&lt;/code&gt;.</source>
          <target state="translated">A &lt;code&gt;RandomValuePropertySource&lt;/code&gt; that has properties only in &lt;code&gt;random.*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63395dbe23370e7329a1e807d93a3bad07ae97de" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;Servlet&lt;/code&gt; can be exposed as an endpoint by implementing a class annotated with &lt;code&gt;@ServletEndpoint&lt;/code&gt; that also implements &lt;code&gt;Supplier&amp;lt;EndpointServlet&amp;gt;&lt;/code&gt;. Servlet endpoints provide deeper integration with the Servlet container but at the expense of portability. They are intended to be used to expose an existing &lt;code&gt;Servlet&lt;/code&gt; as an endpoint. For new endpoints, the &lt;code&gt;@Endpoint&lt;/code&gt; and &lt;code&gt;@WebEndpoint&lt;/code&gt; annotations should be preferred whenever possible.</source>
          <target state="translated">A &lt;code&gt;Servlet&lt;/code&gt; can be exposed as an endpoint by implementing a class annotated with &lt;code&gt;@ServletEndpoint&lt;/code&gt; that also implements &lt;code&gt;Supplier&amp;lt;EndpointServlet&amp;gt;&lt;/code&gt; . Servlet endpoints provide deeper integration with the Servlet container but at the expense of portability. They are intended to be used to expose an existing &lt;code&gt;Servlet&lt;/code&gt; as an endpoint. For new endpoints, the &lt;code&gt;@Endpoint&lt;/code&gt; and &lt;code&gt;@WebEndpoint&lt;/code&gt; annotations should be preferred whenever possible.</target>
        </trans-unit>
        <trans-unit id="693d8d32311d70e5702332d2279ddb193277954d" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SpringApplication&lt;/code&gt; attempts to create the right type of &lt;code&gt;ApplicationContext&lt;/code&gt; on your behalf. The algorithm used to determine a &lt;code&gt;WebApplicationType&lt;/code&gt; is the following:</source>
          <target state="translated">A &lt;code&gt;SpringApplication&lt;/code&gt; attempts to create the right type of &lt;code&gt;ApplicationContext&lt;/code&gt; on your behalf. The algorithm used to determine a &lt;code&gt;WebApplicationType&lt;/code&gt; is the following:</target>
        </trans-unit>
        <trans-unit id="70fa761136f2c9b94e2063cad13a68cd0aa201d1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SpringApplication&lt;/code&gt; has &lt;code&gt;ApplicationListeners&lt;/code&gt; and &lt;code&gt;ApplicationContextInitializers&lt;/code&gt; that are used to apply customizations to the context or environment. Spring Boot loads a number of such customizations for use internally from &lt;code&gt;META-INF/spring.factories&lt;/code&gt;. There is more than one way to register additional customizations:</source>
          <target state="translated">A &lt;code&gt;SpringApplication&lt;/code&gt; has &lt;code&gt;ApplicationListeners&lt;/code&gt; and &lt;code&gt;ApplicationContextInitializers&lt;/code&gt; that are used to apply customizations to the context or environment. Spring Boot loads a number of such customizations for use internally from &lt;code&gt;META-INF/spring.factories&lt;/code&gt; . There is more than one way to register additional customizations:</target>
        </trans-unit>
        <trans-unit id="3baf8af5a8abf66bce0ee446ed4516510188527e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;SpringApplication&lt;/code&gt; has bean properties (mainly setters), so you can use its Java API as you create the application to modify its behavior. Alternatively, you can externalize the configuration by setting properties in &lt;code&gt;spring.main.*&lt;/code&gt;. For example, in &lt;code&gt;application.properties&lt;/code&gt;, you might have the following settings:</source>
          <target state="translated">A &lt;code&gt;SpringApplication&lt;/code&gt; has bean properties (mainly setters), so you can use its Java API as you create the application to modify its behavior. Alternatively, you can externalize the configuration by setting properties in &lt;code&gt;spring.main.*&lt;/code&gt; . For example, in &lt;code&gt;application.properties&lt;/code&gt; , you might have the following settings:</target>
        </trans-unit>
        <trans-unit id="0ff3ffb7747dce2aea86d29721d0fea6db525725" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ThreadPoolTaskScheduler&lt;/code&gt; can also be auto-configured if need to be associated to scheduled task execution (&lt;code&gt;@EnableScheduling&lt;/code&gt;). The thread pool uses one thread by default and those settings can be fine-tuned using the &lt;code&gt;spring.task.scheduling&lt;/code&gt; namespace.</source>
          <target state="translated">A &lt;code&gt;ThreadPoolTaskScheduler&lt;/code&gt; can also be auto-configured if need to be associated to scheduled task execution ( &lt;code&gt;@EnableScheduling&lt;/code&gt; ). The thread pool uses one thread by default and those settings can be fine-tuned using the &lt;code&gt;spring.task.scheduling&lt;/code&gt; namespace.</target>
        </trans-unit>
        <trans-unit id="4b8ca7c74fd58685775b8b174ec8a72af97095ff" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;UserDetailsService&lt;/code&gt; (or &lt;code&gt;ReactiveUserDetailsService&lt;/code&gt; in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html&quot;&gt;&lt;code&gt;SecurityProperties.User&lt;/code&gt;&lt;/a&gt; for the properties of the user).</source>
          <target state="translated">A &lt;code&gt;UserDetailsService&lt;/code&gt; (or &lt;code&gt;ReactiveUserDetailsService&lt;/code&gt; in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html&quot;&gt; &lt;code&gt;SecurityProperties.User&lt;/code&gt; &lt;/a&gt; for the properties of the user).</target>
        </trans-unit>
        <trans-unit id="025e31ba85088979102ce54a194430334f43f921" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;ViewResolver&lt;/code&gt; is a core component of Spring MVC, translating view names in &lt;code&gt;@Controller&lt;/code&gt; to actual &lt;code&gt;View&lt;/code&gt; implementations. Note that &lt;code&gt;ViewResolvers&lt;/code&gt; are mainly used in UI applications, rather than REST-style services (a &lt;code&gt;View&lt;/code&gt; is not used to render a &lt;code&gt;@ResponseBody&lt;/code&gt;). There are many implementations of &lt;code&gt;ViewResolver&lt;/code&gt; to choose from, and Spring on its own is not opinionated about which ones you should use. Spring Boot, on the other hand, installs one or two for you, depending on what it finds on the classpath and in the application context. The &lt;code&gt;DispatcherServlet&lt;/code&gt; uses all the resolvers it finds in the application context, trying each one in turn until it gets a result. If you add your own, you have to be aware of the order and in which position your resolver is added.</source>
          <target state="translated">A &lt;code&gt;ViewResolver&lt;/code&gt; is a core component of Spring MVC, translating view names in &lt;code&gt;@Controller&lt;/code&gt; to actual &lt;code&gt;View&lt;/code&gt; implementations. Note that &lt;code&gt;ViewResolvers&lt;/code&gt; are mainly used in UI applications, rather than REST-style services (a &lt;code&gt;View&lt;/code&gt; is not used to render a &lt;code&gt;@ResponseBody&lt;/code&gt; ). There are many implementations of &lt;code&gt;ViewResolver&lt;/code&gt; to choose from, and Spring on its own is not opinionated about which ones you should use. Spring Boot, on the other hand, installs one or two for you, depending on what it finds on the classpath and in the application context. The &lt;code&gt;DispatcherServlet&lt;/code&gt; uses all the resolvers it finds in the application context, trying each one in turn until it gets a result. If you add your own, you have to be aware of the order and in which position your resolver is added.</target>
        </trans-unit>
        <trans-unit id="0a21f13b831fc29041c9099831d3ed0b4c0716e4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;WebServerInitializedEvent&lt;/code&gt; is sent after the &lt;code&gt;WebServer&lt;/code&gt; is ready. &lt;code&gt;ServletWebServerInitializedEvent&lt;/code&gt; and &lt;code&gt;ReactiveWebServerInitializedEvent&lt;/code&gt; are the servlet and reactive variants respectively.</source>
          <target state="translated">A &lt;code&gt;WebServerInitializedEvent&lt;/code&gt; is sent after the &lt;code&gt;WebServer&lt;/code&gt; is ready. &lt;code&gt;ServletWebServerInitializedEvent&lt;/code&gt; and &lt;code&gt;ReactiveWebServerInitializedEvent&lt;/code&gt; are the servlet and reactive variants respectively.</target>
        </trans-unit>
        <trans-unit id="0ff9d6cc591cb4ab917da6efaa9345c77c4f09c2" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;com.github.benmanes.caffeine.cache.Caffeine&lt;/code&gt; bean is defined</source>
          <target state="translated">A &lt;code&gt;com.github.benmanes.caffeine.cache.Caffeine&lt;/code&gt; bean is defined</target>
        </trans-unit>
        <trans-unit id="af27c8f224645c2a506c00119ca2561a8fa512a7" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;com.github.benmanes.caffeine.cache.CaffeineSpec&lt;/code&gt; bean is defined</source>
          <target state="translated">A &lt;code&gt;com.github.benmanes.caffeine.cache.CaffeineSpec&lt;/code&gt; bean is defined</target>
        </trans-unit>
        <trans-unit id="8fb4443fa1084e8f02d635bd7aab1d36c6cc6bc1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;hazelcast-client.xml&lt;/code&gt; in the working directory or at the root of the classpath.</source>
          <target state="translated">A &lt;code&gt;hazelcast-client.xml&lt;/code&gt; in the working directory or at the root of the classpath.</target>
        </trans-unit>
        <trans-unit id="b858e477479ffab79868fd5396a2e43e720576a1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;hazelcast-client.yaml&lt;/code&gt; in the working directory or at the root of the classpath.</source>
          <target state="translated">A &lt;code&gt;hazelcast-client.yaml&lt;/code&gt; in the working directory or at the root of the classpath.</target>
        </trans-unit>
        <trans-unit id="a073f34c2ddffe116a0803a7f92ffb1d97765c38" translate="yes" xml:space="preserve">
          <source>A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL</source>
          <target state="translated">A Geospatial Messenger with Kotlin, Spring Boot and PostgreSQL</target>
        </trans-unit>
        <trans-unit id="38fc76946efac28194e0c8bbf558a8abec09a1a5" translate="yes" xml:space="preserve">
          <source>A Spring Boot application can be started as a Windows service by using &lt;a href=&quot;https://github.com/kohsuke/winsw&quot;&gt;&lt;code&gt;winsw&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">A Spring Boot application can be started as a Windows service by using &lt;a href=&quot;https://github.com/kohsuke/winsw&quot;&gt; &lt;code&gt;winsw&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="964b58cf84e2d96fb3eae03f12268decfee802f3" translate="yes" xml:space="preserve">
          <source>A Spring Boot application is a Spring &lt;code&gt;ApplicationContext&lt;/code&gt;, so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context.</source>
          <target state="translated">A Spring Boot application is a Spring &lt;code&gt;ApplicationContext&lt;/code&gt; , so nothing very special has to be done to test it beyond what you would normally do with a vanilla Spring context.</target>
        </trans-unit>
        <trans-unit id="5889409ef42bb6fe0983de391f11d251fd5fae08" translate="yes" xml:space="preserve">
          <source>A cache spec defined by &lt;code&gt;spring.cache.caffeine.spec&lt;/code&gt;</source>
          <target state="translated">A cache spec defined by &lt;code&gt;spring.cache.caffeine.spec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5f57371a3bf33a4774aad99a540db2b982d792d1" translate="yes" xml:space="preserve">
          <source>A configuration file defined by the &lt;code&gt;spring.hazelcast.config&lt;/code&gt; property.</source>
          <target state="translated">A configuration file defined by the &lt;code&gt;spring.hazelcast.config&lt;/code&gt; property.</target>
        </trans-unit>
        <trans-unit id="41e9ce16950a8c0525763b0d211713d2016af2c3" translate="yes" xml:space="preserve">
          <source>A controller class to enable timings on every request handler in the controller.</source>
          <target state="translated">A controller class to enable timings on every request handler in the controller.</target>
        </trans-unit>
        <trans-unit id="ff0bf4607772ac1dfb44104a7b1074ff025f77f4" translate="yes" xml:space="preserve">
          <source>A custom &lt;code&gt;ChainedKafkaTransactionManager&lt;/code&gt; must be marked &lt;code&gt;@Primary&lt;/code&gt; as it usually references the auto-configured &lt;code&gt;KafkaTransactionManager&lt;/code&gt; bean.</source>
          <target state="translated">A custom &lt;code&gt;ChainedKafkaTransactionManager&lt;/code&gt; must be marked &lt;code&gt;@Primary&lt;/code&gt; as it usually references the auto-configured &lt;code&gt;KafkaTransactionManager&lt;/code&gt; bean.</target>
        </trans-unit>
        <trans-unit id="bb6137b34a062332687edeec0a53506849387560" translate="yes" xml:space="preserve">
          <source>A downside of lazy initialization is that it can delay the discovery of a problem with the application. If a misconfigured bean is initialized lazily, a failure will no longer occur during startup and the problem will only become apparent when the bean is initialized. Care must also be taken to ensure that the JVM has sufficient memory to accommodate all of the application&amp;rsquo;s beans and not just those that are initialized during startup. For these reasons, lazy initialization is not enabled by default and it is recommended that fine-tuning of the JVM&amp;rsquo;s heap size is done before enabling lazy initialization.</source>
          <target state="translated">A downside of lazy initialization is that it can delay the discovery of a problem with the application. If a misconfigured bean is initialized lazily, a failure will no longer occur during startup and the problem will only become apparent when the bean is initialized. Care must also be taken to ensure that the JVM has sufficient memory to accommodate all of the application&amp;rsquo;s beans and not just those that are initialized during startup. For these reasons, lazy initialization is not enabled by default and it is recommended that fine-tuning of the JVM&amp;rsquo;s heap size is done before enabling lazy initialization.</target>
        </trans-unit>
        <trans-unit id="daac783037d19c69c33088b77ff3060337c9c8cd" translate="yes" xml:space="preserve">
          <source>A few test utility classes that are generally useful when testing your application are packaged as part of &lt;code&gt;spring-boot&lt;/code&gt;.</source>
          <target state="translated">A few test utility classes that are generally useful when testing your application are packaged as part of &lt;code&gt;spring-boot&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f726fb1c798d61ff7b0ea8605435c045bf512c7" translate="yes" xml:space="preserve">
          <source>A list of providers as defined by the &lt;code&gt;ValueProvider&lt;/code&gt; object (described later in this document). Each entry defines the name of the provider and its parameters, if any.</source>
          <target state="translated">A list of providers as defined by the &lt;code&gt;ValueProvider&lt;/code&gt; object (described later in this document). Each entry defines the name of the provider and its parameters, if any.</target>
        </trans-unit>
        <trans-unit id="199d89b08e07989d7c159363551421feab76465f" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataCassandraTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataCassandraTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7a4a4d3aacaaf04788b158d060663faf8c259de5" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataJpaTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataJpaTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="527fc23f73aa702e2210e32dbc618e1132898bb4" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataLdapTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataLdapTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="347489d34cc6aca9259c4082fc3302bbbfa86157" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataMongoTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@DataMongoTest&lt;/code&gt; 에 의해 활성화되는 자동 구성 설정 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43f1807649589058989d3ae26dd87315278aee5e" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataNeo4jTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@DataNeo4jTest&lt;/code&gt; 의해 활성화되는 자동 구성 설정 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88eb8c8df9838ceb90d1f06419068957291cbea7" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@DataRedisTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@DataRedisTest&lt;/code&gt; 에 의해 활성화 된 자동 구성 설정 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea56934bd0306e1f3eca5221014c33acdb191bcc" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@RestClientTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@RestClientTest&lt;/code&gt; 에 의해 활성화되는 자동 구성 설정 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f53606e691924e687d085302b8785f3d9999e078" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@WebMvcTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@WebMvcTest&lt;/code&gt; 로 활성화 된 자동 구성 설정 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dd4d3750e61f56d6a28fdcd77745c3a0605bfbb" translate="yes" xml:space="preserve">
          <source>A list of the auto-configuration settings that are enabled by &lt;code&gt;@WebServiceClientTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@WebServiceClientTest&lt;/code&gt; 에서 활성화 한 자동 구성 설정 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eca198d8e8bd2587277e7f41e7b0850f334575ae" translate="yes" xml:space="preserve">
          <source>A list of the auto-configurations that are enabled by &lt;code&gt;@DataJdbcTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@DataJdbcTest&lt;/code&gt; 에 의해 활성화되는 자동 구성 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="704d9e22351d03ba5a1bc009b0cf961006808536" translate="yes" xml:space="preserve">
          <source>A list of the auto-configurations that are enabled by &lt;code&gt;@JdbcTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@JdbcTest&lt;/code&gt; 에 의해 활성화 된 자동 구성 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b391bdc2de0e485269a1e87e507edc054d75995" translate="yes" xml:space="preserve">
          <source>A list of the auto-configurations that are enabled by &lt;code&gt;@JooqTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@JooqTest&lt;/code&gt; 에 의해 활성화되는 자동 구성 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="50568a035f76bff02e2a942f9b087af66b728117" translate="yes" xml:space="preserve">
          <source>A list of the auto-configurations that are enabled by &lt;code&gt;@JsonTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@JsonTest&lt;/code&gt; 에 의해 활성화되는 자동 구성 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fb61fb1d4964bcb25d5aae01e75b2fb1b396f5e" translate="yes" xml:space="preserve">
          <source>A list of the auto-configurations that are enabled by &lt;code&gt;@WebFluxTest&lt;/code&gt; can be &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;found in the appendix&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@WebFluxTest&lt;/code&gt; 에 의해 활성화되는 자동 구성 목록은 &lt;a href=&quot;appendix-test-auto-configuration#test-auto-configuration&quot;&gt;부록에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9db06c977a53f2bc880eec4a207de30d292e4a9" translate="yes" xml:space="preserve">
          <source>A list of valid values as defined by the &lt;code&gt;ValueHint&lt;/code&gt; object (described in the next table). Each entry defines the value and may have a description.</source>
          <target state="translated">&lt;code&gt;ValueHint&lt;/code&gt; 개체에 정의 된 유효한 값 목록 (다음 표에 설명 됨). 각 항목은 값을 정의하며 설명이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="179a7351523136bdbad08f8b8c88e6ac9297079b" translate="yes" xml:space="preserve">
          <source>A method to enable for an individual endpoint. This is not necessary if you have it on the class, but can be used to further customize the timer for this particular endpoint.</source>
          <target state="translated">개별 엔드 포인트를 활성화하는 방법입니다. 클래스에있는 경우에는 필요하지 않지만이 특정 끝점에 대한 타이머를 추가로 사용자 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12d6050f63f371b61347b5d1baa012708eeba490" translate="yes" xml:space="preserve">
          <source>A method with &lt;code&gt;longTask = true&lt;/code&gt; to enable a long task timer for the method. Long task timers require a separate metric name, and can be stacked with a short task timer.</source>
          <target state="translated">와 방법 &lt;code&gt;longTask = true&lt;/code&gt; 방법에 대한 긴 작업이 타이머를 활성화합니다. 긴 작업 타이머에는 별도의 메트릭 이름이 필요하며 짧은 작업 타이머와 함께 누적 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5740bfc3ca839ec4d566d531412402393094df9c" translate="yes" xml:space="preserve">
          <source>A more readable format where the value and the unit are coupled (e.g. &lt;code&gt;10MB&lt;/code&gt; means 10 megabytes)</source>
          <target state="translated">값과 단위가 결합 된 더 읽기 쉬운 형식 (예 : &lt;code&gt;10MB&lt;/code&gt; 는 10MB를 의미 함)</target>
        </trans-unit>
        <trans-unit id="57ae906cb1c8921f803ef1e63f001ae057598cae" translate="yes" xml:space="preserve">
          <source>A more readable format where the value and the unit are coupled (e.g. &lt;code&gt;10s&lt;/code&gt; means 10 seconds)</source>
          <target state="translated">값과 단위가 결합 된 더 읽기 쉬운 형식 (예 : &lt;code&gt;10s&lt;/code&gt; 는 10 초를 의미 함)</target>
        </trans-unit>
        <trans-unit id="5ae81030e9e23db7142e6f35cb10be1192a2a768" translate="yes" xml:space="preserve">
          <source>A number of questions often arise when people use Spring Batch from within a Spring Boot application. This section addresses those questions.</source>
          <target state="translated">사람들이 Spring Boot 애플리케이션 내에서 Spring Batch를 사용할 때 많은 질문이 자주 발생합니다. 이 섹션에서는 이러한 질문을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="10f8247fdc64626d234c2e418669456b873d2fd8" translate="yes" xml:space="preserve">
          <source>A profile expression that must match for the document to be active.</source>
          <target state="translated">문서가 활성화되기 위해 일치해야하는 프로필 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="ddf7d388adb608604e7a12ffcfb3c1f2ce50aa3f" translate="yes" xml:space="preserve">
          <source>A regular &lt;code&gt;long&lt;/code&gt; representation (using bytes as the default unit unless a &lt;code&gt;@DataSizeUnit&lt;/code&gt; has been specified)</source>
          <target state="translated">일반 &lt;code&gt;long&lt;/code&gt; 표현 ( &lt;code&gt;@DataSizeUnit&lt;/code&gt; 이 지정 되지 않은 경우 기본 단위로 바이트 사용 )</target>
        </trans-unit>
        <trans-unit id="f24335210c1d220b6e9cb1f1d93e8b35be236271" translate="yes" xml:space="preserve">
          <source>A regular &lt;code&gt;long&lt;/code&gt; representation (using milliseconds as the default unit unless a &lt;code&gt;@DurationUnit&lt;/code&gt; has been specified)</source>
          <target state="translated">일반 &lt;code&gt;long&lt;/code&gt; 표현 ( &lt;code&gt;@DurationUnit&lt;/code&gt; 이 지정 되지 않은 경우 기본 단위로 밀리 초 사용 )</target>
        </trans-unit>
        <trans-unit id="67078ea03b27576a4e04f7add3643572c7deacce" translate="yes" xml:space="preserve">
          <source>A relying party registration represents a paired configuration between an Identity Provider, IDP, and a Service Provider, SP. You can register multiple relying parties under the &lt;code&gt;spring.security.saml2.relyingparty&lt;/code&gt; prefix, as shown in the following example:</source>
          <target state="translated">신뢰 당사자 등록은 아이덴티티 공급자 IDP와 서비스 공급자 SP 간의 쌍을 이루는 구성을 나타냅니다. 다음 예제와 같이 &lt;code&gt;spring.security.saml2.relyingparty&lt;/code&gt; 접두사 아래에 여러 신뢰 당사자를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0df9ef96a67f6f7c0b139a6f8f82cc056ca179a3" translate="yes" xml:space="preserve">
          <source>A request predicate is automatically generated for each operation on a web-exposed endpoint.</source>
          <target state="translated">웹 노출 엔드 포인트의 각 작업에 대해 요청 조건자가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6501030c11eac956717450e8e09ab9bfc250a598" translate="yes" xml:space="preserve">
          <source>A running application with the Actuator features has a &lt;code&gt;configprops&lt;/code&gt; endpoint that shows all the bound and bindable properties available through &lt;code&gt;@ConfigurationProperties&lt;/code&gt;.</source>
          <target state="translated">Actuator 기능이있는 실행중인 애플리케이션에는 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 를 통해 사용할 수있는 모든 바인딩 및 바인딩 가능한 속성을 보여주는 &lt;code&gt;configprops&lt;/code&gt; 끝 점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4a35e690d0201c2879e6af79c7fbfc2ea1d6d4c" translate="yes" xml:space="preserve">
          <source>A running remote client might resemble the following listing:</source>
          <target state="translated">실행중인 원격 클라이언트는 다음 목록과 유사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="266a6b8af97388db43502b230a99fb3c59a87ebb" translate="yes" xml:space="preserve">
          <source>A shared secret required to establish a connection (required to enable remote support).</source>
          <target state="translated">연결을 설정하는 데 필요한 공유 암호 (원격 지원을 활성화하는 데 필요).</target>
        </trans-unit>
        <trans-unit id="b58dc63c7fa36a6a4b55c23ec4b06be31fc7c17c" translate="yes" xml:space="preserve">
          <source>A short description of the group that can be displayed to users. If no description is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">사용자에게 표시 할 수있는 그룹에 대한 간단한 설명입니다. 설명이없는 경우 생략 할 수 있습니다. 설명은 간결한 요약을 제공하는 첫 번째 줄과 함께 짧은 단락으로 작성하는 것이 좋습니다. 설명의 마지막 줄은 마침표 ( &lt;code&gt;.&lt;/code&gt; )로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="9727bdf3ad0ddb7544e0d6a7fbc789990dd22846" translate="yes" xml:space="preserve">
          <source>A short description of the property that can be displayed to users. If no description is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">사용자에게 표시 할 수있는 속성에 대한 간단한 설명입니다. 설명이없는 경우 생략 할 수 있습니다. 설명은 간결한 요약을 제공하는 첫 번째 줄과 함께 짧은 단락으로 작성하는 것이 좋습니다. 설명의 마지막 줄은 마침표 ( &lt;code&gt;.&lt;/code&gt; )로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="1dfb369585789fa5597de628b974c8338307e49e" translate="yes" xml:space="preserve">
          <source>A short description of the reason why the property was deprecated. If no reason is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">속성이 더 이상 사용되지 않는 이유에 대한 간단한 설명입니다. 사유가없는 경우 생략 할 수 있습니다. 설명은 간결한 요약을 제공하는 첫 번째 줄과 함께 짧은 단락으로 작성하는 것이 좋습니다. 설명의 마지막 줄은 마침표 ( &lt;code&gt;.&lt;/code&gt; )로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="3499d52e627fdb211b940ea0b9098fd7a39ee0aa" translate="yes" xml:space="preserve">
          <source>A short description of the value that can be displayed to users. If no description is available, it may be omitted. It is recommended that descriptions be short paragraphs, with the first line providing a concise summary. The last line in the description should end with a period (&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">사용자에게 표시 할 수있는 값에 대한 간단한 설명입니다. 설명이없는 경우 생략 할 수 있습니다. 설명은 간결한 요약을 제공하는 첫 번째 줄과 함께 짧은 단락으로 작성하는 것이 좋습니다. 설명의 마지막 줄은 마침표 ( &lt;code&gt;.&lt;/code&gt; )로 끝나야 합니다.</target>
        </trans-unit>
        <trans-unit id="bb264f9ba0042a79d004ab753d79fd204da9ad0e" translate="yes" xml:space="preserve">
          <source>A simpler format where the value and the unit pairs are coupled (e.g. &lt;code&gt;1y3d&lt;/code&gt; means 1 year and 3 days)</source>
          <target state="translated">값과 단위 쌍이 결합 된 더 간단한 형식 (예 : &lt;code&gt;1y3d&lt;/code&gt; 는 1 년 3 일을 의미 함)</target>
        </trans-unit>
        <trans-unit id="5e2658537d0b49b128d34b3f23b99a5adb49e53b" translate="yes" xml:space="preserve">
          <source>A single file contains a complete set of properties (usually written as YAML).</source>
          <target state="translated">단일 파일에는 전체 속성 집합 (일반적으로 YAML로 작성 됨)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2e330fb1be7347875da1709b840ab75b03128b54" translate="yes" xml:space="preserve">
          <source>A slice or &lt;code&gt;@AutoConfigure&amp;hellip;​&lt;/code&gt; annotation can be customized this way as long as it is meta-annotated with &lt;code&gt;@ImportAutoConfiguration&lt;/code&gt;.</source>
          <target state="translated">슬라이스가 나 &lt;code&gt;@AutoConfigure&amp;hellip;​&lt;/code&gt; 주석이 오래가 메타 주석과만큼이 방법을 사용자 정의 할 수 있습니다 &lt;code&gt;@ImportAutoConfiguration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1715dd2ebdb8b91054242dd0cfaab2e0c9b56c1" translate="yes" xml:space="preserve">
          <source>A typical &lt;code&gt;build.xml&lt;/code&gt; looks like the following example:</source>
          <target state="translated">일반적인 &lt;code&gt;build.xml&lt;/code&gt; 은 다음 예제와 같습니다.</target>
        </trans-unit>
        <trans-unit id="54ab25e3e2d2f74a7a4818f5b3bcaaefebb6535a" translate="yes" xml:space="preserve">
          <source>A typical Spring Boot fat jar can be converted into a Docker image by adding just a few lines to a Dockerfile that can be used to build the image. However, there are various downsides to copying and running the fat jar as is in the docker image. There&amp;rsquo;s always a certain amount of overhead when running a fat jar without unpacking it, and in a containerized environment this can be noticeable. The other issue is that putting your application&amp;rsquo;s code and all its dependencies in one layer in the Docker image is sub-optimal. Since you probably recompile your code more often than you upgrade the version of Spring Boot you use, it&amp;rsquo;s often better to separate things a bit more. If you put jar files in the layer before your application classes, Docker often only needs to change the very bottom layer and can pick others up from its cache.</source>
          <target state="translated">일반적인 Spring Boot fat jar는 이미지를 빌드하는 데 사용할 수있는 Dockerfile에 몇 줄만 추가하여 Docker 이미지로 변환 할 수 있습니다. 그러나 docker 이미지에서와 같이 fat jar를 복사하고 실행하는 데는 여러 가지 단점이 있습니다. 포장을 풀지 않고 뚱뚱한 병을 실행할 때 항상 일정량의 오버 헤드가 있으며, 컨테이너화 된 환경에서는 이것이 눈에 띄게 나타날 수 있습니다. 또 다른 문제는 애플리케이션의 코드와 모든 종속성을 Docker 이미지의 한 계층에 배치하는 것이 차선책이라는 것입니다. 사용하는 Spring Boot 버전을 업그레이드하는 것보다 코드를 더 자주 재 컴파일 할 수 있으므로 좀 더 분리하는 것이 좋습니다. 애플리케이션 클래스보다 먼저 계층에 jar 파일을 넣는 경우 Docker는 종종 맨 아래 계층 만 변경하면되고 캐시에서 다른 계층을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae17b180de694ac10ad3d5de0b2ac64cc6559ba8" translate="yes" xml:space="preserve">
          <source>A typical Spring Boot starter contains code to auto-configure and customize the infrastructure of a given technology, let&amp;rsquo;s call that &quot;acme&quot;. To make it easily extensible, a number of configuration keys in a dedicated namespace can be exposed to the environment. Finally, a single &quot;starter&quot; dependency is provided to help users get started as easily as possible.</source>
          <target state="translated">일반적인 Spring Boot 스타터에는 주어진 기술의 인프라를 자동 구성하고 사용자 정의하는 코드가 포함되어 있습니다.이를 &quot;acme&quot;라고합시다. 쉽게 확장 할 수 있도록 전용 네임 스페이스의 여러 구성 키를 환경에 노출 할 수 있습니다. 마지막으로 사용자가 가능한 한 쉽게 시작할 수 있도록 단일 &quot;스타터&quot;종속성이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="11199f67bb0ca1a681eacd4b98e63d1335965ea6" translate="yes" xml:space="preserve">
          <source>A typical Spring Security configuration might look something like the following example:</source>
          <target state="translated">일반적인 Spring Security 구성은 다음 예제와 유사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5b08696a5be3af1ed9758fdf71a9729aab0a1a7" translate="yes" xml:space="preserve">
          <source>A typical custom &lt;code&gt;logback.xml&lt;/code&gt; file would look something like this:</source>
          <target state="translated">일반적인 사용자 정의 &lt;code&gt;logback.xml&lt;/code&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="649cbd6e9677d85995620831ffbb3cb27a1dde01" translate="yes" xml:space="preserve">
          <source>A typical example of a layers index would be:</source>
          <target state="translated">레이어 인덱스의 일반적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1623b709cd2465d31d5ba7b4c54461e7e6b372a" translate="yes" xml:space="preserve">
          <source>A typical initializer for WebLogic should resemble the following example:</source>
          <target state="translated">WebLogic의 일반적인 이니셜 라이저는 다음 예제와 유사해야합니다.</target>
        </trans-unit>
        <trans-unit id="891f93c1499c33a5c20cf0854c37442e4dd472d5" translate="yes" xml:space="preserve">
          <source>A valid value for the element to which the hint refers. If the type of the property is an array, it can also be an array of value(s). This attribute is mandatory.</source>
          <target state="translated">힌트가 참조하는 요소의 유효한 값입니다. 속성의 유형이 배열이면 값의 배열 일 수도 있습니다. 이 속성은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="e764e5d60584f18d625b565a598d06ec95e23145" translate="yes" xml:space="preserve">
          <source>A value set this way is replaced by the System property or environment variable setting but not by the &lt;code&gt;SpringApplicationBuilder.profiles()&lt;/code&gt; method. Thus, the latter Java API can be used to augment the profiles without changing the defaults.</source>
          <target state="translated">이 방법으로 설정된 값은 System 속성 또는 환경 변수 설정으로 대체되지만 &lt;code&gt;SpringApplicationBuilder.profiles()&lt;/code&gt; 메서드가 아닙니다 . 따라서 후자의 Java API를 사용하여 기본값을 변경하지 않고 프로필을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d49c039ee59dc5f1f77e1d92c69bf09e2fdfdb5" translate="yes" xml:space="preserve">
          <source>A wildcard location must contain only one &lt;code&gt;*&lt;/code&gt; and end with &lt;code&gt;*/&lt;/code&gt; for search locations that are directories or &lt;code&gt;*/&amp;lt;filename&amp;gt;&lt;/code&gt; for search locations that are files. Locations with wildcards are sorted alphabetically based on the absolute path of the file names.</source>
          <target state="translated">와일드 카드 위치는 &lt;code&gt;*&lt;/code&gt; 하나만 포함 하고 디렉토리 인 검색 위치의 경우 &lt;code&gt;*/&lt;/code&gt; 로 끝나고 &lt;code&gt;*/&amp;lt;filename&amp;gt;&lt;/code&gt; 검색 위치의 경우 * / &amp;lt;filename&amp;gt;으로 끝나야 합니다. 와일드 카드가있는 위치는 파일 이름의 절대 경로를 기준으로 알파벳순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="12230f84d345103bbf4c6305c8a61726b85f3ff3" translate="yes" xml:space="preserve">
          <source>A zip64-format jar file cannot be made fully executable. Attempting to do so will result in a jar file that is reported as corrupt when executed directly or with &lt;code&gt;java -jar&lt;/code&gt;. A standard-format jar file that contains one or more zip64-format nested jars can be fully executable.</source>
          <target state="translated">zip64 형식 jar 파일은 완전히 실행 가능하게 만들 수 없습니다. 그렇게하려고하면 직접 실행하거나 &lt;code&gt;java -jar&lt;/code&gt; 을 사용 하여 실행할 때 손상된 것으로보고되는 jar 파일이 생성됩니다 . 하나 이상의 zip64 형식 중첩 jar가 포함 된 표준 형식 jar 파일은 완전히 실행 가능할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="9eb27f67653442638718045025f489179462df8c" translate="yes" xml:space="preserve">
          <source>API token used when publishing metrics directly to the Wavefront API host.</source>
          <target state="translated">지표를 Wavefront API 호스트에 직접 게시 할 때 사용되는 API 토큰입니다.</target>
        </trans-unit>
        <trans-unit id="95f5962aa767fce77db582be9e2420535b08ccf3" translate="yes" xml:space="preserve">
          <source>AWS Cloud Formation</source>
          <target state="translated">AWS 클라우드 형성</target>
        </trans-unit>
        <trans-unit id="b66fdc551894c3b1192f2c54101b00560e1fe25b" translate="yes" xml:space="preserve">
          <source>AWS Code Deploy</source>
          <target state="translated">AWS 코드 배포</target>
        </trans-unit>
        <trans-unit id="6d53f9865f3214d3da5f80464d341916ee0222aa" translate="yes" xml:space="preserve">
          <source>AWS Container Registry</source>
          <target state="translated">AWS Container Registry</target>
        </trans-unit>
        <trans-unit id="48aa91135b362651b911b70d23391396c4094057" translate="yes" xml:space="preserve">
          <source>AWS Elastic Beanstalk</source>
          <target state="translated">AWS Elastic Beanstalk</target>
        </trans-unit>
        <trans-unit id="5c6b5faf33493853139e5f2a39d6fd69696bce73" translate="yes" xml:space="preserve">
          <source>AWS OPS Works</source>
          <target state="translated">AWS OPS 작동</target>
        </trans-unit>
        <trans-unit id="75a55f5b248e12210f519f4e395eb8fb1ea93689" translate="yes" xml:space="preserve">
          <source>About the Documentation, Getting Help, First Steps, and more.</source>
          <target state="translated">문서 정보, 도움말 얻기, 첫 번째 단계 등.</target>
        </trans-unit>
        <trans-unit id="75ff47a064e8ec228cf781d95ff8091f2ffa0a7a" translate="yes" xml:space="preserve">
          <source>Absolutely no code generation and no requirement for XML configuration.</source>
          <target state="translated">코드 생성이 전혀없고 XML 구성이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00862e4675c4b69f4e173f365b6337a8ff0e6264" translate="yes" xml:space="preserve">
          <source>Access logging for Undertow can be configured in a similar fashion, as shown in the following example:</source>
          <target state="translated">Undertow에 대한 액세스 로깅은 다음 예와 같이 유사한 방식으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e2187b6f80a4f33dd9f8ca2ed14d2b66ef0a30" translate="yes" xml:space="preserve">
          <source>Access logs can be configured for Tomcat, Undertow, and Jetty through their respective namespaces.</source>
          <target state="translated">액세스 로그는 각각의 네임 스페이스를 통해 Tomcat, Undertow 및 Jetty에 대해 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23fdaed317c271fcbd396342a8797c73a6820024" translate="yes" xml:space="preserve">
          <source>Access rules and the use of multiple Spring Security components such as OAuth 2 Client and Resource Server can be configured by adding a custom &lt;code&gt;SecurityWebFilterChain&lt;/code&gt; bean. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. &lt;code&gt;EndpointRequest&lt;/code&gt; can be used to create a &lt;code&gt;ServerWebExchangeMatcher&lt;/code&gt; that is based on the &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; property.</source>
          <target state="translated">사용자 지정 &lt;code&gt;SecurityWebFilterChain&lt;/code&gt; 빈 을 추가하여 액세스 규칙 및 OAuth 2 클라이언트 및 리소스 서버와 같은 여러 Spring Security 구성 요소의 사용을 구성 할 수 있습니다 . Spring Boot는 액추에이터 엔드 포인트 및 정적 리소스에 대한 액세스 규칙을 재정의하는 데 사용할 수있는 편리한 메서드를 제공합니다. &lt;code&gt;EndpointRequest&lt;/code&gt; 를 사용 하여 &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; 속성을 기반으로 하는 &lt;code&gt;ServerWebExchangeMatcher&lt;/code&gt; 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfac6e3a360343385d9075d69f85c79748c090bd" translate="yes" xml:space="preserve">
          <source>Access rules can be overridden by adding a custom &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt;. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. &lt;code&gt;EndpointRequest&lt;/code&gt; can be used to create a &lt;code&gt;RequestMatcher&lt;/code&gt; that is based on the &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; property. &lt;code&gt;PathRequest&lt;/code&gt; can be used to create a &lt;code&gt;RequestMatcher&lt;/code&gt; for resources in commonly used locations.</source>
          <target state="translated">사용자 지정 &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; 를 추가하여 액세스 규칙을 재정의 할 수 있습니다 . Spring Boot는 액추에이터 엔드 포인트 및 정적 리소스에 대한 액세스 규칙을 재정의하는 데 사용할 수있는 편리한 메서드를 제공합니다. &lt;code&gt;EndpointRequest&lt;/code&gt; 를 사용 하여 &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; 속성을 기반으로 하는 &lt;code&gt;RequestMatcher&lt;/code&gt; 를 만들 수 있습니다 . &lt;code&gt;PathRequest&lt;/code&gt; 를 사용하여 일반적으로 사용되는 위치의 리소스에 대한 &lt;code&gt;RequestMatcher&lt;/code&gt; 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c9efa7dbc2d938ca9b71a5f6dafec4d5293216" translate="yes" xml:space="preserve">
          <source>Acknowledge mode of container.</source>
          <target state="translated">컨테이너 모드를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b2bd5b8ab0ecf65f74fc30394a13b65ddcd17546" translate="yes" xml:space="preserve">
          <source>Acknowledge mode of the container. By default, the listener is transacted with automatic acknowledgment.</source>
          <target state="translated">컨테이너의 승인 모드. 기본적으로 리스너는 자동 승인으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e364904962550a04e24e2d71bb90a96c250adb11" translate="yes" xml:space="preserve">
          <source>Acquisition of new connections will be attempted for at most configured timeout.</source>
          <target state="translated">새 연결 획득은 최대 구성된 시간 초과 동안 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="b9d3621863a2dfb9cbdd3604afb7bdb7373e31b2" translate="yes" xml:space="preserve">
          <source>Activation</source>
          <target state="translated">Activation</target>
        </trans-unit>
        <trans-unit id="e793675c105c5a8109b1691f3e2c5179f272ca0e" translate="yes" xml:space="preserve">
          <source>Active profiles</source>
          <target state="translated">활성 프로필</target>
        </trans-unit>
        <trans-unit id="5806f119cd727b5f7debb0f3e6dd29988ea2b167" translate="yes" xml:space="preserve">
          <source>ActiveMQ configuration is controlled by external configuration properties in &lt;code&gt;spring.activemq.*&lt;/code&gt;. For example, you might declare the following section in &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">ActiveMQ 구성은 &lt;code&gt;spring.activemq.*&lt;/code&gt; 의 외부 구성 속성에 의해 제어됩니다 . 예를 들어 &lt;code&gt;application.properties&lt;/code&gt; 에서 다음 섹션을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42aba5149d5b5818f740bb8190b22f4402e464d6" translate="yes" xml:space="preserve">
          <source>Actuator configures the &quot;liveness&quot; and &quot;readiness&quot; probes as Health Groups; this means that all the &lt;a href=&quot;#production-ready-health-groups&quot;&gt;Health Groups features&lt;/a&gt; are available for them. You can, for example, configure additional Health Indicators:</source>
          <target state="translated">Actuator는 &quot;활성&quot;및 &quot;준비&quot;프로브를 상태 그룹으로 구성합니다. 이는 모든 &lt;a href=&quot;#production-ready-health-groups&quot;&gt;건강 그룹 기능&lt;/a&gt; 을 사용할 수 있음을 의미합니다. 예를 들어 추가 상태 표시기를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e10e8d08e6c184939525c34a3be81c206d9a97b" translate="yes" xml:space="preserve">
          <source>Actuator endpoints let you monitor and interact with your application. Spring Boot includes a number of built-in endpoints and lets you add your own. For example, the &lt;code&gt;health&lt;/code&gt; endpoint provides basic application health information.</source>
          <target state="translated">액추에이터 엔드 포인트를 사용하면 애플리케이션을 모니터링하고 상호 작용할 수 있습니다. Spring Boot에는 여러 가지 기본 제공 엔드 포인트가 포함되어 있으며 직접 추가 할 수 있습니다. 예를 들어 &lt;code&gt;health&lt;/code&gt; 엔드 포인트는 기본 애플리케이션 상태 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6eb588e53dce2e71efb2b6c226e2549a6559e038" translate="yes" xml:space="preserve">
          <source>Actuator is supported natively with Spring MVC, Spring WebFlux, and Jersey. If both Jersey and Spring MVC are available, Spring MVC will be used.</source>
          <target state="translated">Actuator는 기본적으로 Spring MVC, Spring WebFlux 및 Jersey에서 지원됩니다. Jersey와 Spring MVC를 모두 사용할 수있는 경우 Spring MVC가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fe55a8407f887c84f7a3bdd953b64176dc77256" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;https://myapp.cfapps.io&lt;/code&gt; to the &lt;code&gt;Program arguments&lt;/code&gt; (or whatever your remote URL is).</source>
          <target state="translated">&lt;code&gt;Program arguments&lt;/code&gt; (또는 원격 URL이 무엇이든)에 &lt;code&gt;https://myapp.cfapps.io&lt;/code&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="2b065a98d88002f564ab073ae90725af3dffeabd" translate="yes" xml:space="preserve">
          <source>Add @EnableAspectJAutoProxy.</source>
          <target state="translated">@EnableAspectJAutoProxy를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5a66eddae0ecaff421cd985b2520bf60de88d1d0" translate="yes" xml:space="preserve">
          <source>Add Servlets, Filters, and Listeners by Using Classpath Scanning</source>
          <target state="translated">클래스 경로 스캔을 사용하여 서블릿, 필터 및 리스너 추가</target>
        </trans-unit>
        <trans-unit id="a32e43f13354c557bcd7256ca8bb70ab4f0e43d6" translate="yes" xml:space="preserve">
          <source>Add a Servlet, Filter, or Listener by Using a Spring Bean</source>
          <target state="translated">Spring Bean을 사용하여 서블릿, 필터 또는 리스너 추가</target>
        </trans-unit>
        <trans-unit id="3a8632208a27fba7346f1004acab364f4f10b67b" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;UndertowBuilderCustomizer&lt;/code&gt; to the &lt;code&gt;UndertowServletWebServerFactory&lt;/code&gt; and add a listener to the &lt;code&gt;Builder&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">추가 &lt;code&gt;UndertowBuilderCustomizer&lt;/code&gt; 을 받는 &lt;code&gt;UndertowServletWebServerFactory&lt;/code&gt; 과에 리스너를 추가 &lt;code&gt;Builder&lt;/code&gt; 다음 예제와 같이 :</target>
        </trans-unit>
        <trans-unit id="9ca9c6c89278f599759b9218a810cc4dcf2096c6" translate="yes" xml:space="preserve">
          <source>Add the &quot;X-Application-Context&quot; HTTP header in each response.</source>
          <target state="translated">각 응답에 &quot;X-Application-Context&quot;HTTP 헤더를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="df221a1648e8cdc6a98f864947ada1271f9358af" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;provided&lt;/code&gt; (embedded container) dependencies in a nested &lt;code&gt;BOOT-INF/lib&lt;/code&gt; directory for a jar or &lt;code&gt;WEB-INF/lib-provided&lt;/code&gt; for a war. Remember &lt;strong&gt;not&lt;/strong&gt; to compress the entries in the archive.</source>
          <target state="translated">jar의 경우 중첩 된 &lt;code&gt;BOOT-INF/lib&lt;/code&gt; 디렉토리 또는 전쟁의 &lt;code&gt;WEB-INF/lib-provided&lt;/code&gt; 에 &lt;code&gt;provided&lt;/code&gt; (내장 된 컨테이너) 종속성을 추가하십시오 . 기억 &lt;strong&gt;하지&lt;/strong&gt; 아카이브의 항목을 압축 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="902ebb0b120bb65d4f7f3e4dfaab21f0df2844c0" translate="yes" xml:space="preserve">
          <source>Add the &lt;code&gt;spring-boot-loader&lt;/code&gt; classes at the root of the archive (so that the &lt;code&gt;Main-Class&lt;/code&gt; is available).</source>
          <target state="translated">아카이브의 루트에 &lt;code&gt;spring-boot-loader&lt;/code&gt; 클래스를 추가하십시오 ( &lt;code&gt;Main-Class&lt;/code&gt; 를 사용할 수 있도록).</target>
        </trans-unit>
        <trans-unit id="857a9a516d82166bcb16e9ee02ca26536976e445" translate="yes" xml:space="preserve">
          <source>Add the runtime dependencies in a nested &lt;code&gt;BOOT-INF/lib&lt;/code&gt; directory for a jar or &lt;code&gt;WEB-INF/lib&lt;/code&gt; for a war. Remember &lt;strong&gt;not&lt;/strong&gt; to compress the entries in the archive.</source>
          <target state="translated">jar의 경우 중첩 된 &lt;code&gt;BOOT-INF/lib&lt;/code&gt; 디렉토리 에, 전쟁의 경우 &lt;code&gt;WEB-INF/lib&lt;/code&gt; 에 런타임 종속성을 추가하십시오 . 기억 &lt;strong&gt;하지&lt;/strong&gt; 아카이브의 항목을 압축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51f17b79b17b073263e50237b9109d0a2eda29ae" translate="yes" xml:space="preserve">
          <source>Adding both &lt;code&gt;spring-boot-starter-web&lt;/code&gt; and &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux. This behavior has been chosen because many Spring developers add &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; to their Spring MVC application to use the reactive &lt;code&gt;WebClient&lt;/code&gt;. You can still enforce your choice by setting the chosen application type to &lt;code&gt;SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)&lt;/code&gt;.</source>
          <target state="translated">애플리케이션에 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 및 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 모듈을 모두 추가하면 Spring Boot가 WebFlux가 아닌 Spring MVC를 자동 구성합니다. 이 동작은 많은 Spring 개발자 가 반응 형 &lt;code&gt;WebClient&lt;/code&gt; 를 사용하기 위해 Spring MVC 애플리케이션에 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 를 추가하기 때문에 선택되었습니다 . 선택한 애플리케이션 유형을 &lt;code&gt;SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)&lt;/code&gt; 로 설정하여 선택을 강제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e691fd2623c953a5c010cd2992ab3daf177b97f" translate="yes" xml:space="preserve">
          <source>Additional &lt;code&gt;HealthIndicators&lt;/code&gt; are available but not enabled by default:</source>
          <target state="translated">추가 &lt;code&gt;HealthIndicators&lt;/code&gt; 를 사용할 수 있지만 기본적으로 활성화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c933b5792bc22a2a3b77383f6fd99188aa7ac43" translate="yes" xml:space="preserve">
          <source>Additional JAAS options.</source>
          <target state="translated">추가 JAAS 옵션.</target>
        </trans-unit>
        <trans-unit id="5d12c5620ee6970385bc00e2429259db935bd246" translate="yes" xml:space="preserve">
          <source>Additional JavaMail Session properties.</source>
          <target state="translated">추가 JavaMail 세션 등록 정보.</target>
        </trans-unit>
        <trans-unit id="4504a299a66e30134066fcabc21df7f9ac19f3fd" translate="yes" xml:space="preserve">
          <source>Additional Kafka properties used to configure the streams.</source>
          <target state="translated">스트림을 구성하는 데 사용되는 추가 Kafka 속성입니다.</target>
        </trans-unit>
        <trans-unit id="862f92263cdc995021caed22450db2dd84cb01d2" translate="yes" xml:space="preserve">
          <source>Additional Quartz Scheduler properties.</source>
          <target state="translated">추가 Quartz Scheduler 속성.</target>
        </trans-unit>
        <trans-unit id="8dfce623f55042371d079f3caf89368129e11bf5" translate="yes" xml:space="preserve">
          <source>Additional R2DBC options.</source>
          <target state="translated">추가 R2DBC 옵션.</target>
        </trans-unit>
        <trans-unit id="b61906085a1876e19de23f3bd0f0b1455f159287" translate="yes" xml:space="preserve">
          <source>Additional admin-specific properties used to configure the client.</source>
          <target state="translated">클라이언트를 구성하는 데 사용되는 추가 관리자 관련 속성입니다.</target>
        </trans-unit>
        <trans-unit id="db24d8bfcc3ce0c4e8b7167ecdecafaaa4812874" translate="yes" xml:space="preserve">
          <source>Additional connection pools can always be configured manually. If you define your own &lt;code&gt;DataSource&lt;/code&gt; bean, auto-configuration does not occur.</source>
          <target state="translated">추가 연결 풀은 항상 수동으로 구성 할 수 있습니다. 자체 &lt;code&gt;DataSource&lt;/code&gt; Bean 을 정의하면 자동 구성이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10be4e2fbb5b4543fd07a5a869ee5c448b56316e" translate="yes" xml:space="preserve">
          <source>Additional consumer-specific properties used to configure the client.</source>
          <target state="translated">클라이언트를 구성하는 데 사용되는 추가 소비자 별 속성입니다.</target>
        </trans-unit>
        <trans-unit id="69b1da28a362ff3cc31896d50d9bcb09617a8f9b" translate="yes" xml:space="preserve">
          <source>Additional information about CSRF protection can be found in the &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.4.1/reference/html5/#csrf&quot;&gt;Spring Security Reference Guide&lt;/a&gt;.</source>
          <target state="translated">CSRF 보호에 대한 추가 정보는 &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.4.1/reference/html5/#csrf&quot;&gt;Spring Security Reference Guide&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c687e90c5831d641e11996cdca494f4c018a443a" translate="yes" xml:space="preserve">
          <source>Additional native properties to set on the JPA provider.</source>
          <target state="translated">JPA 공급자에 설정할 추가 기본 속성입니다.</target>
        </trans-unit>
        <trans-unit id="928dba6bd7e6dd77b6227014d7d677f98585e169" translate="yes" xml:space="preserve">
          <source>Additional paths to watch for changes.</source>
          <target state="translated">변경 사항을 감시 할 추가 경로.</target>
        </trans-unit>
        <trans-unit id="ea1c607125b1acf8772e4874485d0de4afdb8ae0" translate="yes" xml:space="preserve">
          <source>Additional patterns that should be excluded from triggering a full restart.</source>
          <target state="translated">전체 재시작 트리거에서 제외되어야하는 추가 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="a2e1fc32d20c6f69735a4ab5ae2e918f93d808d3" translate="yes" xml:space="preserve">
          <source>Additional producer-specific properties used to configure the client.</source>
          <target state="translated">클라이언트를 구성하는 데 사용되는 추가 생산자 별 속성입니다.</target>
        </trans-unit>
        <trans-unit id="1059f8a3cb3c7805bf00f79097737ee6c696db92" translate="yes" xml:space="preserve">
          <source>Additional properties, common to producers and consumers, used to configure the client.</source>
          <target state="translated">클라이언트를 구성하는 데 사용되는 생산자와 소비자에 공통적 인 추가 속성입니다.</target>
        </trans-unit>
        <trans-unit id="bd9e563b313845ea62bd2c3de830cadc190a5509" translate="yes" xml:space="preserve">
          <source>Additional static properties to append to all ObjectNames of MBeans representing Endpoints.</source>
          <target state="translated">끝점을 나타내는 MBean의 모든 ObjectName에 추가 할 추가 정적 속성입니다.</target>
        </trans-unit>
        <trans-unit id="9935e376ca033d187447a31c21e41ac73f66a275" translate="yes" xml:space="preserve">
          <source>Additionally, if Spring Security is present, you would need to add custom security configuration that allows unauthenticated access to the endpoints as shown in the following example:</source>
          <target state="translated">또한 Spring Security가있는 경우 다음 예제와 같이 엔드 포인트에 대한 인증되지 않은 액세스를 허용하는 사용자 지정 보안 구성을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2271910d0f4c214bbe1dcbcb73e1aa4c84c82837" translate="yes" xml:space="preserve">
          <source>Additionally, you can use &lt;code&gt;@SpyBean&lt;/code&gt; to wrap any existing bean with a Mockito &lt;code&gt;spy&lt;/code&gt;. See the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/test/mock/mockito/SpyBean.html&quot;&gt;Javadoc&lt;/a&gt; for full details.</source>
          <target state="translated">또한 &lt;code&gt;@SpyBean&lt;/code&gt; 을 사용 하여 기존 빈을 Mockito &lt;code&gt;spy&lt;/code&gt; 로 래핑 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/test/mock/mockito/SpyBean.html&quot;&gt;Javadoc&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5b74aee9443d1bf9f74b91a30d73475627dc1765" translate="yes" xml:space="preserve">
          <source>Again, the same properties are applicable for both servlet and reactive applications.</source>
          <target state="translated">다시 말하지만, 동일한 속성이 서블릿 및 반응 애플리케이션 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8fbf9471afefcf79adff9e2d4cc44fe329a49985" translate="yes" xml:space="preserve">
          <source>Alias that identifies the key in the key store.</source>
          <target state="translated">키 저장소에서 키를 식별하는 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="74e82e1092bcb00dbfb8ab2f07fb3f9688c2762c" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;@JsonComponent&lt;/code&gt; beans in the &lt;code&gt;ApplicationContext&lt;/code&gt; are automatically registered with Jackson. Because &lt;code&gt;@JsonComponent&lt;/code&gt; is meta-annotated with &lt;code&gt;@Component&lt;/code&gt;, the usual component-scanning rules apply.</source>
          <target state="translated">&lt;code&gt;ApplicationContext&lt;/code&gt; 의 모든 &lt;code&gt;@JsonComponent&lt;/code&gt; 빈 은 자동으로 Jackson에 등록됩니다. &lt;code&gt;@JsonComponent&lt;/code&gt; 는 &lt;code&gt;@Component&lt;/code&gt; 로 메타 주석이 달려 있기 때문에 일반적인 구성 요소 스캔 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="a9a5dae378fdf45b0147fd781aacfc0aa76e82e0" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;META-INF/spring-devtools.properties&lt;/code&gt; from the classpath are loaded. You can package files inside your project, or in the libraries that the project consumes.</source>
          <target state="translated">클래스 경로의 모든 &lt;code&gt;META-INF/spring-devtools.properties&lt;/code&gt; 가로 드됩니다. 프로젝트 내부 또는 프로젝트가 사용하는 라이브러리에서 파일을 패키징 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec8423fe040f50fe832c4a0058a615199c08fd98" translate="yes" xml:space="preserve">
          <source>All &lt;strong&gt;official&lt;/strong&gt; starters follow a similar naming pattern; &lt;code&gt;spring-boot-starter-*&lt;/code&gt;, where &lt;code&gt;*&lt;/code&gt; is a particular type of application. This naming structure is intended to help when you need to find a starter. The Maven integration in many IDEs lets you search dependencies by name. For example, with the appropriate Eclipse or STS plugin installed, you can press &lt;code&gt;ctrl-space&lt;/code&gt; in the POM editor and type &amp;ldquo;spring-boot-starter&amp;rdquo; for a complete list.</source>
          <target state="translated">모든 &lt;strong&gt;공식&lt;/strong&gt; 스타터는 비슷한 이름 지정 패턴을 따릅니다. &lt;code&gt;spring-boot-starter-*&lt;/code&gt; , 여기서 &lt;code&gt;*&lt;/code&gt; 는 특정 유형의 애플리케이션입니다. 이 이름 지정 구조는 스타터를 찾아야 할 때 도움을주기위한 것입니다. 많은 IDE의 Maven 통합을 통해 이름으로 종속성을 검색 할 수 있습니다. 예를 들어 적절한 Eclipse 또는 STS 플러그인이 설치된 상태 에서 POM 편집기에서 &lt;code&gt;ctrl-space&lt;/code&gt; 를 누르고 전체 목록을 보려면 &quot;spring-boot-starter&quot;를 입력 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b8cf39af1b3f3a8e2102e491fdbd682344e87d4" translate="yes" xml:space="preserve">
          <source>All Cloud Foundry properties are prefixed with &lt;code&gt;vcap&lt;/code&gt;. You can use &lt;code&gt;vcap&lt;/code&gt; properties to access application information (such as the public URL of the application) and service information (such as database credentials). See the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html&quot;&gt;&amp;lsquo;CloudFoundryVcapEnvironmentPostProcessor&amp;rsquo;&lt;/a&gt; Javadoc for complete details.</source>
          <target state="translated">모든 Cloud Foundry 속성에는 &lt;code&gt;vcap&lt;/code&gt; 접두사가 붙 습니다 . &lt;code&gt;vcap&lt;/code&gt; 속성을 사용 하여 애플리케이션 정보 (예 : 애플리케이션의 공용 URL) 및 서비스 정보 (예 : 데이터베이스 자격 증명)에 액세스 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/cloud/CloudFoundryVcapEnvironmentPostProcessor.html&quot;&gt;'CloudFoundryVcapEnvironmentPostProcessor'Javadoc을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="65873ae022095528fb3e6e75269dffdb5d556289" translate="yes" xml:space="preserve">
          <source>All of Spring Boot is open source, including the documentation. If you find problems with the docs or if you want to improve them, please &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0&quot;&gt;get involved&lt;/a&gt;.</source>
          <target state="translated">문서를 포함한 모든 Spring Boot는 오픈 소스입니다. 문서에서 문제를 발견하거나 개선하고 싶다면 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0&quot;&gt;참여하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7d98027ba4a1506fdcca500d43e75b66315489d" translate="yes" xml:space="preserve">
          <source>All of these should be amenable to translation, but each might require slightly different techniques.</source>
          <target state="translated">이들 모두는 번역이 가능해야하지만 각각 약간 다른 기술이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e16140b3d5591756ea466628715759b74bfffd4c" translate="yes" xml:space="preserve">
          <source>All property keys must be unique. As long as a property starts with &lt;code&gt;restart.include.&lt;/code&gt; or &lt;code&gt;restart.exclude.&lt;/code&gt; it is considered.</source>
          <target state="translated">모든 속성 키는 고유해야합니다. 속성이 &lt;code&gt;restart.include.&lt;/code&gt; 시작하는 한 . 또는 &lt;code&gt;restart.exclude.&lt;/code&gt; 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="bcdd7e39a9a6371f96a59ae60c3b6635a592976d" translate="yes" xml:space="preserve">
          <source>All the registered endpoints should be &lt;code&gt;@Components&lt;/code&gt; with HTTP resource annotations (&lt;code&gt;@GET&lt;/code&gt; and others), as shown in the following example:</source>
          <target state="translated">등록 된 모든 엔드 포인트는 다음 예와 같이 HTTP 리소스 주석 ( &lt;code&gt;@GET&lt;/code&gt; 및 기타) 이있는 &lt;code&gt;@Components&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="65496d8ed95b8e2924b5c3e2755ec30a05f32afd" translate="yes" xml:space="preserve">
          <source>All the supported logging systems can consult System properties when parsing their configuration files. See the default configurations in &lt;code&gt;spring-boot.jar&lt;/code&gt; for examples:</source>
          <target state="translated">지원되는 모든 로깅 시스템은 구성 파일을 구문 분석 할 때 시스템 속성을 참조 할 수 있습니다. 예제 는 &lt;code&gt;spring-boot.jar&lt;/code&gt; 의 기본 구성을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5eee98321046b8075f93003e21cc330687312a20" translate="yes" xml:space="preserve">
          <source>All the supported logging systems can have the logger levels set in the Spring &lt;code&gt;Environment&lt;/code&gt; (for example, in &lt;code&gt;application.properties&lt;/code&gt;) by using &lt;code&gt;logging.level.&amp;lt;logger-name&amp;gt;=&amp;lt;level&amp;gt;&lt;/code&gt; where &lt;code&gt;level&lt;/code&gt; is one of TRACE, DEBUG, INFO, WARN, ERROR, FATAL, or OFF. The &lt;code&gt;root&lt;/code&gt; logger can be configured by using &lt;code&gt;logging.level.root&lt;/code&gt;.</source>
          <target state="translated">지원되는 모든 로깅 시스템은 &lt;code&gt;logging.level.&amp;lt;logger-name&amp;gt;=&amp;lt;level&amp;gt;&lt;/code&gt; 을 사용하여 Spring &lt;code&gt;Environment&lt;/code&gt; (예 : &lt;code&gt;application.properties&lt;/code&gt; ) 에서 설정된 로거 레벨을 가질 수 있습니다 . 여기서 &lt;code&gt;level&lt;/code&gt; 은 TRACE, DEBUG, INFO, WARN, ERROR, FATAL 또는 OFF. &lt;code&gt;root&lt;/code&gt; 로거를 사용하여 구성 할 수 있습니다 &lt;code&gt;logging.level.root&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="3caf316179e992e817ab19609292f06a2d803549" translate="yes" xml:space="preserve">
          <source>Allow caching null values.</source>
          <target state="translated">null 값 캐싱을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="4ceaebbdcbca0e2c6fb82d819e1a80df66ebaba6" translate="yes" xml:space="preserve">
          <source>Allows retrieval and deletion of user sessions from a Spring Session-backed session store. Requires a Servlet-based web application using Spring Session.</source>
          <target state="translated">Spring Session 지원 세션 저장소에서 사용자 세션을 검색하고 삭제할 수 있습니다. Spring Session을 사용하는 Servlet 기반 웹 애플리케이션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="bd29f76ccc52f1e5c94174a0f12d1548010c129f" translate="yes" xml:space="preserve">
          <source>Also, Hikari-specific metrics are exposed with a &lt;code&gt;hikaricp&lt;/code&gt; prefix. Each metric is tagged by the name of the Pool (can be controlled with &lt;code&gt;spring.datasource.name&lt;/code&gt;).</source>
          <target state="translated">또한 Hikari 관련 메트릭은 &lt;code&gt;hikaricp&lt;/code&gt; 접두사 로 노출됩니다 . 각 측정 항목은 풀의 이름으로 태그가 지정됩니다 ( &lt;code&gt;spring.datasource.name&lt;/code&gt; 으로 제어 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="a977619ba0242f4ee0f341511bd057695c5ae26b" translate="yes" xml:space="preserve">
          <source>Also, if an application is using Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/&quot;&gt;autoscaling&lt;/a&gt; it may react differently to applications being taken out of the load-balancer, depending on its autoscaler configuration.</source>
          <target state="translated">또한 애플리케이션이 Kubernetes &lt;a href=&quot;https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/&quot;&gt;자동 확장을&lt;/a&gt; 사용하는 경우 자동 확장 처리 구성에 따라 부하 분산기에서 제거되는 애플리케이션에 다르게 반응 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="819f30db7affda51e9e84c9a7fa6ed3671379e55" translate="yes" xml:space="preserve">
          <source>Also, the &lt;code&gt;ExitCodeGenerator&lt;/code&gt; interface may be implemented by exceptions. When such an exception is encountered, Spring Boot returns the exit code provided by the implemented &lt;code&gt;getExitCode()&lt;/code&gt; method.</source>
          <target state="translated">또한 &lt;code&gt;ExitCodeGenerator&lt;/code&gt; 인터페이스는 예외에 의해 구현 될 수 있습니다. 이러한 예외가 발생하면 Spring Boot는 구현 된 &lt;code&gt;getExitCode()&lt;/code&gt; 메서드 에서 제공하는 종료 코드를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="cf7ac52a5dadc20ebbca955efafa9ca5fe674211" translate="yes" xml:space="preserve">
          <source>Alternatively, App Engine Flex requires you to create an &lt;code&gt;app.yaml&lt;/code&gt; file to describe the resources your app requires. Normally, you put this file in &lt;code&gt;src/main/appengine&lt;/code&gt;, and it should resemble the following file:</source>
          <target state="translated">또는 App Engine Flex에서는 앱에 필요한 리소스를 설명 하기 위해 &lt;code&gt;app.yaml&lt;/code&gt; 파일을 만들어야 합니다. 일반적으로이 파일을 &lt;code&gt;src/main/appengine&lt;/code&gt; 에 저장하면 다음 파일과 유사해야합니다.</target>
        </trans-unit>
        <trans-unit id="f766b8686dc4faa2291f760db496a93f00f0bf1e" translate="yes" xml:space="preserve">
          <source>Alternatively, additional auto-configurations can be added for any use of a slice annotation by registering them in &lt;code&gt;META-INF/spring.factories&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">또는 다음 예제와 같이 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 에 등록하여 슬라이스 주석을 사용하기 위해 추가 자동 구성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86f2728767a98a4e95dbcb8df71228aae9f817ab" translate="yes" xml:space="preserve">
          <source>Alternatively, an RSocket TCP or websocket server is started as an independent, embedded server. Besides the dependency requirements, the only required configuration is to define a port for that server:</source>
          <target state="translated">또는 RSocket TCP 또는 웹 소켓 서버가 독립적 인 내장 서버로 시작됩니다. 종속성 요구 사항 외에도 필요한 유일한 구성은 해당 서버에 대한 포트를 정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c194665d2eb577843b5c9b7337c05979900a9cc" translate="yes" xml:space="preserve">
          <source>Alternatively, both the main server and the management server can use SSL but with different key stores, as follows:</source>
          <target state="translated">또는 주 서버와 관리 서버 모두 SSL을 사용할 수 있지만 다음과 같이 다른 키 저장소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="449a77a038d72ba6a394daaad269d739b9bb84f2" translate="yes" xml:space="preserve">
          <source>Alternatively, if you use the &lt;code&gt;@SpringBootTest&lt;/code&gt; annotation with &lt;code&gt;WebEnvironment.RANDOM_PORT&lt;/code&gt; or &lt;code&gt;WebEnvironment.DEFINED_PORT&lt;/code&gt;, you can inject a fully configured &lt;code&gt;TestRestTemplate&lt;/code&gt; and start using it. If necessary, additional customizations can be applied through the &lt;code&gt;RestTemplateBuilder&lt;/code&gt; bean. Any URLs that do not specify a host and port automatically connect to the embedded server, as shown in the following example:</source>
          <target state="translated">또는 &lt;code&gt;WebEnvironment.RANDOM_PORT&lt;/code&gt; 또는 &lt;code&gt;WebEnvironment.DEFINED_PORT&lt;/code&gt; 와 함께 &lt;code&gt;@SpringBootTest&lt;/code&gt; 주석 을 사용 하는 경우 완전히 구성된 &lt;code&gt;TestRestTemplate&lt;/code&gt; 을 삽입하고 사용을 시작할 수 있습니다. 필요한 경우 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 빈을 통해 추가 사용자 정의를 적용 할 수 있습니다 . 호스트 및 포트를 지정하지 않는 모든 URL은 다음 예와 같이 자동으로 내장 서버에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="ddcff10ca00af70d6a0ba57e8576271a2b281606" translate="yes" xml:space="preserve">
          <source>Alternatively, rather than open all suffix patterns, it&amp;rsquo;s more secure to only support registered suffix patterns:</source>
          <target state="translated">또는 모든 접미사 패턴을 여는 대신 등록 된 접미사 패턴 만 지원하는 것이 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="91354e09a3470cef11b970c216b55273f5e88452" translate="yes" xml:space="preserve">
          <source>Alternatively, running in an IDE (especially with debugging on) is a good way to do development (all modern IDEs allow reloading of static resources and usually also allow hot-swapping of Java class changes).</source>
          <target state="translated">또는 IDE에서 실행하는 것이 (특히 디버깅이 켜진 상태에서) 개발을 수행하는 좋은 방법입니다 (모든 최신 IDE는 정적 리소스를 다시로드 할 수 있으며 일반적으로 Java 클래스 변경 사항의 핫스왑도 허용합니다).</target>
        </trans-unit>
        <trans-unit id="5c6c10b88faed085147a159305a4a01770f78ac3" translate="yes" xml:space="preserve">
          <source>Alternatively, you can configure a &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#webtestclient-tests&quot;&gt;&lt;code&gt;WebTestClient&lt;/code&gt;&lt;/a&gt; as shown in the following example:</source>
          <target state="translated">또는 다음 예제와 같이 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#webtestclient-tests&quot;&gt; &lt;code&gt;WebTestClient&lt;/code&gt; &lt;/a&gt; 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c58ec2dab98748c62a48d1f000d370177ca7be7d" translate="yes" xml:space="preserve">
          <source>Alternatively, you can configure either &lt;a href=&quot;#howto-execute-flyway-database-migrations-on-startup&quot;&gt;Flyway&lt;/a&gt; or &lt;a href=&quot;#howto-execute-liquibase-database-migrations-on-startup&quot;&gt;Liquibase&lt;/a&gt; to configure a &lt;code&gt;DataSource&lt;/code&gt; for you for the duration of the migration. Both these libraries offer properties to set the &lt;code&gt;url&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; of the database to migrate.</source>
          <target state="translated">또는 &lt;a href=&quot;#howto-execute-flyway-database-migrations-on-startup&quot;&gt;Flyway&lt;/a&gt; 또는 &lt;a href=&quot;#howto-execute-liquibase-database-migrations-on-startup&quot;&gt;Liquibase&lt;/a&gt; 를 구성 하여 마이그레이션 기간 동안 &lt;code&gt;DataSource&lt;/code&gt; 를 구성 할 수 있습니다 . 두 라이브러리 모두 마이그레이션 할 데이터베이스 의 &lt;code&gt;url&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 를 설정하는 속성을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c08675fdff064b3474e3d1574827026f36ec7597" translate="yes" xml:space="preserve">
          <source>Alternatively, you can configure the following bean:</source>
          <target state="translated">또는 다음 Bean을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="137d95f91c226ed1520a7ea0597a30a04488dabc" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define your own &lt;code&gt;JwtDecoder&lt;/code&gt; bean for servlet applications or a &lt;code&gt;ReactiveJwtDecoder&lt;/code&gt; for reactive applications.</source>
          <target state="translated">또는 서블릿 애플리케이션에 대해 고유 한 &lt;code&gt;JwtDecoder&lt;/code&gt; Bean을 정의 하거나 반응 애플리케이션에 대해 &lt;code&gt;ReactiveJwtDecoder&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6346145344f3aa973220116ba0c6939c646967ac" translate="yes" xml:space="preserve">
          <source>Alternatively, you can define your own &lt;code&gt;OpaqueTokenIntrospector&lt;/code&gt; bean for servlet applications or a &lt;code&gt;ReactiveOpaqueTokenIntrospector&lt;/code&gt; for reactive applications.</source>
          <target state="translated">또는 서블릿 애플리케이션에 대해 고유 한 &lt;code&gt;OpaqueTokenIntrospector&lt;/code&gt; 빈을 정의 하거나 반응 애플리케이션에 대해 &lt;code&gt;ReactiveOpaqueTokenIntrospector&lt;/code&gt; 를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe3c681a05ce0cb8860dd7b1dd1f921b26d3947a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can enable a &amp;ldquo;trace&amp;rdquo; mode by starting your application with a &lt;code&gt;--trace&lt;/code&gt; flag (or &lt;code&gt;trace=true&lt;/code&gt; in your &lt;code&gt;application.properties&lt;/code&gt;). Doing so enables trace logging for a selection of core loggers (embedded container, Hibernate schema generation, and the whole Spring portfolio).</source>
          <target state="translated">또는 &lt;code&gt;--trace&lt;/code&gt; 플래그 (또는 &lt;code&gt;application.properties&lt;/code&gt; 의 &lt;code&gt;trace=true&lt;/code&gt; ) 로 애플리케이션을 시작하여 &quot;추적&quot;모드를 활성화 할 수 있습니다 . 이렇게하면 선택한 핵심 로거 (내장 된 컨테이너, Hibernate 스키마 생성 및 전체 Spring 포트폴리오)에 대한 추적 로깅이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6518152a153a0e58575bf65f685e77cc28518acd" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify connection details using discrete properties. For example, you might declare the following settings in your &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">또는 불연속 속성을 사용하여 연결 세부 정보를 지정할 수 있습니다. 예를 들어 &lt;code&gt;application.properties&lt;/code&gt; 에서 다음 설정을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a4dea4e406268faf242fa039eebaa6c0f003b9a" translate="yes" xml:space="preserve">
          <source>Alternatively, you can specify the color or style that should be used by providing it as an option to the conversion. For example, to make the text yellow, use the following setting:</source>
          <target state="translated">또는 변환 옵션으로 제공하여 사용해야하는 색상 또는 스타일을 지정할 수 있습니다. 예를 들어 텍스트를 노란색으로 만들려면 다음 설정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="10244dc1b8cb9553b00a27c981a842dc2833e00a" translate="yes" xml:space="preserve">
          <source>Alternatively, you could configure the same connection using the &lt;code&gt;addresses&lt;/code&gt; attribute:</source>
          <target state="translated">또는 &lt;code&gt;addresses&lt;/code&gt; 속성을 사용하여 동일한 연결을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb013fc8f09513caaa8f79190fb4a30169a84a52" translate="yes" xml:space="preserve">
          <source>Alternatively, you may use a Wavefront sidecar or an internal proxy set up in your environment that forwards metrics data to the Wavefront API host:</source>
          <target state="translated">또는 메트릭 데이터를 Wavefront API 호스트로 전달하는 Wavefront 사이드카 또는 환경에 설정된 내부 프록시를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e690a9076558697c6a063766a37804ca29efde5" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;null&lt;/code&gt; values from the JSON will be added to the resulting property source, the &lt;code&gt;PropertySourcesPropertyResolver&lt;/code&gt; treats &lt;code&gt;null&lt;/code&gt; properties as missing values. This means that the JSON cannot override properties from lower order property sources with a &lt;code&gt;null&lt;/code&gt; value.</source>
          <target state="translated">JSON의 &lt;code&gt;null&lt;/code&gt; 값이 결과 속성 소스에 추가 되지만 &lt;code&gt;PropertySourcesPropertyResolver&lt;/code&gt; 는 &lt;code&gt;null&lt;/code&gt; 속성을 누락 된 값으로 처리 합니다. 즉, JSON은 &lt;code&gt;null&lt;/code&gt; 값 이있는 하위 속성 소스의 속성을 재정의 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ab88f5113721a67ea7c495b42c081d6535f316" translate="yes" xml:space="preserve">
          <source>Although Java does not allow one to express null-safety in its type system, Spring Framework, Spring Data, and Reactor now provide null-safety of their API via tooling-friendly annotations. By default, types from Java APIs used in Kotlin are recognized as &lt;a href=&quot;https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types&quot;&gt;platform types&lt;/a&gt; for which null-checks are relaxed. &lt;a href=&quot;https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support&quot;&gt;Kotlin&amp;rsquo;s support for JSR 305 annotations&lt;/a&gt; combined with nullability annotations provide null-safety for the related Spring API in Kotlin.</source>
          <target state="translated">Java는 유형 시스템에서 널 안전성을 표현하는 것을 허용하지 않지만 Spring Framework, Spring Data 및 Reactor는 이제 도구 친화적 인 주석을 통해 API의 널 안전성을 제공합니다. 기본적으로 Kotlin에서 사용되는 Java API의 &lt;a href=&quot;https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types&quot;&gt;유형&lt;/a&gt; 은 null 검사가 완화 된 플랫폼 유형 으로 인식됩니다 . null 허용 여부 주석과 결합 된 &lt;a href=&quot;https://kotlinlang.org/docs/reference/java-interop.html#jsr-305-support&quot;&gt;JSR 305 주석에 대한 Kotlin의 지원은 Kotlin의&lt;/a&gt; 관련 Spring API에 대해 null-safety를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5922f28b26dbbb1f1617030ef276c3026a68bda3" translate="yes" xml:space="preserve">
          <source>Although there is not much code here, quite a lot is going on. We step through the important parts in the next few sections.</source>
          <target state="translated">여기에는 코드가 많지는 않지만 많은 일이 진행되고 있습니다. 다음 몇 섹션에서 중요한 부분을 단계별로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f5674b7af5bf90aed875a78ba560d521abd74a99" translate="yes" xml:space="preserve">
          <source>Although you &lt;em&gt;could&lt;/em&gt; copy Spring Boot jars, we generally recommend that you use a build tool that supports dependency management (such as Maven or Gradle).</source>
          <target state="translated">Spring Boot jar를 복사 할 &lt;em&gt;수&lt;/em&gt; 있지만 일반적으로 종속성 관리를 지원하는 빌드 도구 (예 : Maven 또는 Gradle)를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eca1bc10b3b7f8d67cec82c793c8b3622220c008" translate="yes" xml:space="preserve">
          <source>Always responds with &lt;code&gt;UP&lt;/code&gt;.</source>
          <target state="translated">항상 &lt;code&gt;UP&lt;/code&gt; 로 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="cfef1c0892b980ae9ba635b55d791ec142df9e14" translate="yes" xml:space="preserve">
          <source>Amazon Web Services offers multiple ways to install Spring Boot-based applications, either as traditional web applications (war) or as executable jar files with an embedded web server. The options include:</source>
          <target state="translated">Amazon Web Services는 기존 웹 애플리케이션 (war) 또는 내장 웹 서버가있는 실행 가능한 jar 파일로 Spring Boot 기반 애플리케이션을 설치하는 여러 방법을 제공합니다. 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a0846b4e62f9817ccf24e519a996ee902172044" translate="yes" xml:space="preserve">
          <source>Amount of quiet time required without any classpath changes before a restart is triggered.</source>
          <target state="translated">재시작이 트리거되기 전에 클래스 경로 변경없이 필요한 조용한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="156ad72ad206b924a7138aa1c60bc27ae617a087" translate="yes" xml:space="preserve">
          <source>Amount of time a connection can sit idle without processing a request, before it is closed by the server.</source>
          <target state="translated">연결이 서버에 의해 닫히기 전에 요청을 처리하지 않고 유휴 상태로있을 수있는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="66db6b0b42dcceadda191885c0acd43c71e72784" translate="yes" xml:space="preserve">
          <source>Amount of time before asynchronous request handling times out. If this value is not set, the default timeout of the underlying implementation is used.</source>
          <target state="translated">비동기 요청 처리 시간이 초과되기 전까지의 시간입니다. 이 값이 설정되지 않은 경우 기본 구현의 기본 제한 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6aedd4dfff28a04ab62c78e3e50082beaa1ab051" translate="yes" xml:space="preserve">
          <source>Amount of time the connector will wait, after accepting a connection, for the request URI line to be presented.</source>
          <target state="translated">연결을 수락 한 후 요청 URI 행이 표시 될 때까지 커넥터가 대기하는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="8cd2aef44cca8ffa321809e51e24c9060aa70d31" translate="yes" xml:space="preserve">
          <source>Amount of time to wait between polling for classpath changes.</source>
          <target state="translated">클래스 경로 변경을 폴링하는 사이에 대기하는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="0cf45f239d1e6dcc39fcc7abe848f1f524da5295" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationContext&lt;/code&gt; in an XML file can be added through an &lt;code&gt;@ImportResource&lt;/code&gt; in your &lt;code&gt;Application&lt;/code&gt;. Alternatively, cases where annotation configuration is heavily used already can be recreated in a few lines as &lt;code&gt;@Bean&lt;/code&gt; definitions.</source>
          <target state="translated">&lt;code&gt;ApplicationContext&lt;/code&gt; 는 XML 파일에서은을 통해 추가 할 수 있습니다 &lt;code&gt;@ImportResource&lt;/code&gt; 귀하의 &lt;code&gt;Application&lt;/code&gt; . 또는 어노테이션 구성이 이미 많이 사용 된 경우 &lt;code&gt;@Bean&lt;/code&gt; 정의 로 몇 줄로 다시 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3f22099accde3d853798a76f5d22d0ca94b36bf" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationContextInitializedEvent&lt;/code&gt; is sent when the &lt;code&gt;ApplicationContext&lt;/code&gt; is prepared and ApplicationContextInitializers have been called but before any bean definitions are loaded.</source>
          <target state="translated">&lt;code&gt;ApplicationContextInitializedEvent&lt;/code&gt; 는 때 전송 &lt;code&gt;ApplicationContext&lt;/code&gt; 준비하고 ApplicationContextInitializers가 호출되었지만 어떤 bean 정의가로드되기 전에.</target>
        </trans-unit>
        <trans-unit id="35308437231226d1945ae2d3587f0acd62106a51" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationEnvironmentPreparedEvent&lt;/code&gt; is sent when the &lt;code&gt;Environment&lt;/code&gt; to be used in the context is known but before the context is created.</source>
          <target state="translated">&lt;code&gt;ApplicationEnvironmentPreparedEvent&lt;/code&gt; 는 때 전송 &lt;code&gt;Environment&lt;/code&gt; 알려진 상황에서 사용할 수 있지만 컨텍스트가 생성되기 전에.</target>
        </trans-unit>
        <trans-unit id="d85447f0fbd9609546ea9b1c254affdbcacf60b8" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationFailedEvent&lt;/code&gt; is sent if there is an exception on startup.</source>
          <target state="translated">&lt;code&gt;ApplicationFailedEvent&lt;/code&gt; 은 시작에 예외가있을 경우 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="819275b0be456d54b78e0b40715cc1df8836b91a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationPreparedEvent&lt;/code&gt; is sent just before the refresh is started but after bean definitions have been loaded.</source>
          <target state="translated">&lt;code&gt;ApplicationPreparedEvent&lt;/code&gt; 는 새로 고침이 시작되기 전에 바로 전송되지만 빈 정의가로드 된 후.</target>
        </trans-unit>
        <trans-unit id="aacf023d1ab5d93153a796b073fc8632ebf1b69a" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationReadyEvent&lt;/code&gt; is sent after any &lt;a href=&quot;#boot-features-command-line-runner&quot;&gt;application and command-line runners&lt;/a&gt; have been called.</source>
          <target state="translated">&lt;code&gt;ApplicationReadyEvent&lt;/code&gt; 은 어떤 후 전송 &lt;a href=&quot;#boot-features-command-line-runner&quot;&gt;응용 프로그램 및 명령 줄 선수가&lt;/a&gt; 부름을 받았다.</target>
        </trans-unit>
        <trans-unit id="796effa5af98df9c270e27a1225c2d7b339c94fc" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationStartedEvent&lt;/code&gt; is sent after the context has been refreshed but before any application and command-line runners have been called.</source>
          <target state="translated">&lt;code&gt;ApplicationStartedEvent&lt;/code&gt; 는 문맥이 갱신 된 후 전송하지만, 모든 응용 프로그램 및 명령 줄 주자가 호출되기 전에.</target>
        </trans-unit>
        <trans-unit id="42c10259657d6b62cf302d1d315350cfc707e226" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;ApplicationStartingEvent&lt;/code&gt; is sent at the start of a run but before any processing, except for the registration of listeners and initializers.</source>
          <target state="translated">&lt;code&gt;ApplicationStartingEvent&lt;/code&gt; 은 실행의 시작에 전송 있지만 처리하기 전에, 청취자와 초기화의 등록을 제외한다.</target>
        </trans-unit>
        <trans-unit id="a2f942ab2e1747322dae376099235c9a1b47a76c" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AvailabilityChangeEvent&lt;/code&gt; is sent right after with &lt;code&gt;LivenessState.CORRECT&lt;/code&gt; to indicate that the application is considered as live.</source>
          <target state="translated">&lt;code&gt;AvailabilityChangeEvent&lt;/code&gt; 가 와 후 바로 전송됩니다 &lt;code&gt;LivenessState.CORRECT&lt;/code&gt; 응용 프로그램이 라이브로 간주되는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d61241c9df3f86a4113358c0c5ec793fe467c939" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;AvailabilityChangeEvent&lt;/code&gt; is sent right after with &lt;code&gt;ReadinessState.ACCEPTING_TRAFFIC&lt;/code&gt; to indicate that the application is ready to service requests.</source>
          <target state="translated">&lt;code&gt;AvailabilityChangeEvent&lt;/code&gt; 가 와 후 바로 전송됩니다 &lt;code&gt;ReadinessState.ACCEPTING_TRAFFIC&lt;/code&gt; 응용 프로그램이 서비스 요청에 대한 준비가되어 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c237deca6fd6189691b85f915410f93d54916ca4" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;InternalResourceViewResolver&lt;/code&gt; named &amp;lsquo;defaultViewResolver&amp;rsquo;. This one locates physical resources that can be rendered by using the &lt;code&gt;DefaultServlet&lt;/code&gt; (including static resources and JSP pages, if you use those). It applies a prefix and a suffix to the view name and then looks for a physical resource with that path in the servlet context (the defaults are both empty but are accessible for external configuration through &lt;code&gt;spring.mvc.view.prefix&lt;/code&gt; and &lt;code&gt;spring.mvc.view.suffix&lt;/code&gt;). You can override it by providing a bean of the same type.</source>
          <target state="translated">&lt;code&gt;InternalResourceViewResolver&lt;/code&gt; 'defaultViewResolver'를 불렀다. 이것은 &lt;code&gt;DefaultServlet&lt;/code&gt; (정적 자원 및 JSP 페이지를 사용하는 경우 포함) 을 사용하여 렌더링 할 수있는 물리적 자원을 찾습니다 . 뷰 이름에 접두사와 접미사를 적용한 다음 서블릿 컨텍스트에서 해당 경로가있는 물리적 리소스를 찾습니다 (기본값은 모두 비어 있지만 &lt;code&gt;spring.mvc.view.prefix&lt;/code&gt; 및 &lt;code&gt;spring.mvc.view.suffix&lt;/code&gt; 통해 외부 구성에 액세스 할 수 있습니다 . view.suffix ). 동일한 유형의 Bean을 제공하여이를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d4cfe8389a53a6582e46f387fcc34fdeb0843a2" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;LdapContextSource&lt;/code&gt; is auto-configured based on these settings. If a &lt;code&gt;DirContextAuthenticationStrategy&lt;/code&gt; bean is available, it is associated to the auto-configured &lt;code&gt;LdapContextSource&lt;/code&gt;. If you need to customize it, for instance to use a &lt;code&gt;PooledContextSource&lt;/code&gt;, you can still inject the auto-configured &lt;code&gt;LdapContextSource&lt;/code&gt;. Make sure to flag your customized &lt;code&gt;ContextSource&lt;/code&gt; as &lt;code&gt;@Primary&lt;/code&gt; so that the auto-configured &lt;code&gt;LdapTemplate&lt;/code&gt; uses it.</source>
          <target state="translated">&lt;code&gt;LdapContextSource&lt;/code&gt; 는 이러한 설정에 따라 자동으로 구성됩니다. 경우 &lt;code&gt;DirContextAuthenticationStrategy&lt;/code&gt; 의 콩을 사용할 수, 그것은 자동 구성에 연관되어 &lt;code&gt;LdapContextSource&lt;/code&gt; . 예를 들어 &lt;code&gt;PooledContextSource&lt;/code&gt; 를 사용하기 위해 사용자 정의해야하는 경우 자동 구성된 &lt;code&gt;LdapContextSource&lt;/code&gt; 를 삽입 할 수 있습니다 . 자동 구성된 &lt;code&gt;LdapTemplate&lt;/code&gt; 에서 사용 하도록 사용자 지정된 &lt;code&gt;ContextSource&lt;/code&gt; 를 &lt;code&gt;@Primary&lt;/code&gt; 로 플래그 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="8ab0d1c18c5ce1a8da1b16a81e92b1f3bbd04f80" translate="yes" xml:space="preserve">
          <source>An HTTP range request can be used to request part of an HTTP resource. When using Spring MVC or Spring Web Flux, operations that return a &lt;code&gt;org.springframework.core.io.Resource&lt;/code&gt; automatically support range requests.</source>
          <target state="translated">HTTP 범위 요청을 사용하여 HTTP 리소스의 일부를 요청할 수 있습니다. Spring MVC 또는 Spring Web Flux를 사용할 때 &lt;code&gt;org.springframework.core.io.Resource&lt;/code&gt; 를 반환하는 작업은 자동으로 범위 요청을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d8c44053d488f3228979d42f6e31e92a7fe806c7" translate="yes" xml:space="preserve">
          <source>An SQL database can be initialized in different ways depending on what your stack is. Of course, you can also do it manually, provided the database is a separate process. It is recommended to use a single mechanism for schema generation.</source>
          <target state="translated">SQL 데이터베이스는 스택이 무엇인지에 따라 다른 방식으로 초기화 될 수 있습니다. 물론 데이터베이스가 별도의 프로세스 인 경우 수동으로 수행 할 수도 있습니다. 스키마 생성을 위해 단일 메커니즘을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ce4a61a34df9522349f1fd1d6b0a21e4d7f9050d" translate="yes" xml:space="preserve">
          <source>An actuator is a manufacturing term that refers to a mechanical device for moving or controlling something. Actuators can generate a large amount of motion from a small change.</source>
          <target state="translated">액추에이터는 무언가를 움직이거나 제어하기위한 기계 장치를 가리키는 제조 용어입니다. 액추에이터는 작은 변화로 많은 양의 모션을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00ada2403e1174ab693fb3aa3ae13511faefd4b9" translate="yes" xml:space="preserve">
          <source>An application is considered ready as soon as application and command-line runners have been called, see &lt;a href=&quot;#boot-features-application-events-and-listeners&quot;&gt;Spring Boot application lifecycle and related Application Events&lt;/a&gt;.</source>
          <target state="translated">애플리케이션은 애플리케이션 및 명령 줄 실행기가 호출 되 자마자 준비된 것으로 간주됩니다. &lt;a href=&quot;#boot-features-application-events-and-listeners&quot;&gt;Spring Boot 애플리케이션 수명주기 및 관련 애플리케이션 이벤트를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="792a92fe2932932f02186f79c4f7d856b085c08c" translate="yes" xml:space="preserve">
          <source>An auto-configuration can be affected by many factors: user configuration (&lt;code&gt;@Bean&lt;/code&gt; definition and &lt;code&gt;Environment&lt;/code&gt; customization), condition evaluation (presence of a particular library), and others. Concretely, each test should create a well defined &lt;code&gt;ApplicationContext&lt;/code&gt; that represents a combination of those customizations. &lt;code&gt;ApplicationContextRunner&lt;/code&gt; provides a great way to achieve that.</source>
          <target state="translated">자동 구성은 사용자 구성 ( &lt;code&gt;@Bean&lt;/code&gt; 정의 및 &lt;code&gt;Environment&lt;/code&gt; 사용자 정의), 조건 평가 (특정 라이브러리의 존재) 등 여러 요인의 영향을받을 수 있습니다 . 구체적으로 각 테스트는 이러한 사용자 지정의 조합을 나타내는 잘 정의 된 &lt;code&gt;ApplicationContext&lt;/code&gt; 를 만들어야합니다 . &lt;code&gt;ApplicationContextRunner&lt;/code&gt; 는이를 달성 할 수있는 훌륭한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="44cedd2576eba38b25c9f15bacd404da2f5ea971" translate="yes" xml:space="preserve">
          <source>An important aspect of the Kubernetes Probes support is its consistency with the application lifecycle. Spring Boot publishes &lt;a href=&quot;spring-boot-features#boot-features-application-events-and-listeners&quot;&gt;Application Events during startup and shutdown&lt;/a&gt;.</source>
          <target state="translated">Kubernetes 프로브 지원의 중요한 측면은 애플리케이션 수명주기와의 일관성입니다. Spring Boot는 &lt;a href=&quot;spring-boot-features#boot-features-application-events-and-listeners&quot;&gt;시작 및 종료 중에 애플리케이션 이벤트를&lt;/a&gt; 게시 합니다.</target>
        </trans-unit>
        <trans-unit id="dccdfa8a335aa144f20db77ab460facf938fbf0b" translate="yes" xml:space="preserve">
          <source>An operation on a web endpoint or a web-specific endpoint extension can receive the current &lt;code&gt;java.security.Principal&lt;/code&gt; or &lt;code&gt;org.springframework.boot.actuate.endpoint.SecurityContext&lt;/code&gt; as a method parameter. The former is typically used in conjunction with &lt;code&gt;@Nullable&lt;/code&gt; to provide different behavior for authenticated and unauthenticated users. The latter is typically used to perform authorization checks using its &lt;code&gt;isUserInRole(String)&lt;/code&gt; method.</source>
          <target state="translated">웹 엔드 포인트 또는 웹 특정 엔드 포인트 확장에 대한 작업은 현재 &lt;code&gt;java.security.Principal&lt;/code&gt; 또는 &lt;code&gt;org.springframework.boot.actuate.endpoint.SecurityContext&lt;/code&gt; 를 메소드 매개 변수로 수신 할 수 있습니다 . 전자는 일반적으로 &lt;code&gt;@Nullable&lt;/code&gt; 과 함께 사용되어 인증 된 사용자와 인증되지 않은 사용자에게 서로 다른 동작을 제공합니다. 후자는 일반적으로 &lt;code&gt;isUserInRole(String)&lt;/code&gt; 메서드를 사용하여 권한 확인을 수행하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="383ad719814c98f9fd193b7267b323e918d73f78" translate="yes" xml:space="preserve">
          <source>An regular &lt;code&gt;int&lt;/code&gt; representation (using days as the default unit unless a &lt;code&gt;@PeriodUnit&lt;/code&gt; has been specified)</source>
          <target state="translated">일반 &lt;code&gt;int&lt;/code&gt; 표현 ( &lt;code&gt;@PeriodUnit&lt;/code&gt; 이 지정 되지 않은 경우 기본 단위로 일 사용 )</target>
        </trans-unit>
        <trans-unit id="81fef88f7151b8d643818f2267aa6d76ae94f344" translate="yes" xml:space="preserve">
          <source>And the following example shows one way to set up the starters in Gradle:</source>
          <target state="translated">다음 예제는 Gradle에서 스타터를 설정하는 한 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c1f98019e272d82ac5eee3c60091efe0db206cfb" translate="yes" xml:space="preserve">
          <source>Another source of confusion is classpath scanning. Assume that, while you structured your code in a sensible way, you need to scan an additional package. Your application may resemble the following code:</source>
          <target state="translated">또 다른 혼동의 원인은 클래스 경로 스캔입니다. 합리적인 방식으로 코드를 구성하는 동안 추가 패키지를 스캔해야한다고 가정합니다. 애플리케이션은 다음 코드와 유사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8619381857513024eb4961c179e0f17ea04ce818" translate="yes" xml:space="preserve">
          <source>Another useful feature of the &lt;code&gt;info&lt;/code&gt; endpoint is its ability to publish information about the state of your &lt;code&gt;git&lt;/code&gt; source code repository when the project was built. If a &lt;code&gt;GitProperties&lt;/code&gt; bean is available, the &lt;code&gt;git.branch&lt;/code&gt;, &lt;code&gt;git.commit.id&lt;/code&gt;, and &lt;code&gt;git.commit.time&lt;/code&gt; properties are exposed.</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 엔드 포인트 의 또 다른 유용한 기능은 프로젝트가 빌드되었을 때 &lt;code&gt;git&lt;/code&gt; 소스 코드 저장소 의 상태에 대한 정보를 게시하는 기능 입니다. 경우 &lt;code&gt;GitProperties&lt;/code&gt; 의 콩을 사용할 수는 &lt;code&gt;git.branch&lt;/code&gt; , &lt;code&gt;git.commit.id&lt;/code&gt; 및 &lt;code&gt;git.commit.time&lt;/code&gt; 의 속성이 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="02cc2a69720bd8bf1661deb23018e16470c069da" translate="yes" xml:space="preserve">
          <source>Ant</source>
          <target state="translated">Ant</target>
        </trans-unit>
        <trans-unit id="a401853051fa74b3ecf9bfb2664f2754a3faa477" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;HttpMessageConverter&lt;/code&gt; bean that is present in the context is added to the list of converters. You can also override default converters in the same way.</source>
          <target state="translated">컨텍스트에있는 모든 &lt;code&gt;HttpMessageConverter&lt;/code&gt; Bean이 변환기 목록에 추가됩니다. 동일한 방식으로 기본 변환기를 재정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed37d320c5033d03ec308b53ffbbfdca5a4ce085" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;Servlet&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, or servlet &lt;code&gt;*Listener&lt;/code&gt; instance that is a Spring bean is registered with the embedded container. This can be particularly convenient if you want to refer to a value from your &lt;code&gt;application.properties&lt;/code&gt; during configuration.</source>
          <target state="translated">모든 &lt;code&gt;Servlet&lt;/code&gt; , &lt;code&gt;Filter&lt;/code&gt; , 또는 서블릿 &lt;code&gt;*Listener&lt;/code&gt; Spring 빈입니다 인스턴스가 포함 된 컨테이너에 등록됩니다. 구성 중에 &lt;code&gt;application.properties&lt;/code&gt; 의 값을 참조하려는 경우 특히 편리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="4c1cdd8fa317e6b79e96ea43846837cec3355f68" translate="yes" xml:space="preserve">
          <source>Any &lt;code&gt;java.lang.Enum&lt;/code&gt;: Lists the possible values for the property. (We recommend defining the property with the &lt;code&gt;Enum&lt;/code&gt; type, as no further hint should be required for the IDE to auto-complete the values)</source>
          <target state="translated">모든 &lt;code&gt;java.lang.Enum&lt;/code&gt; : 속성의 가능한 값을 나열합니다. ( IDE가 값을 자동 완성하는 데 추가 힌트가 필요하지 않으므로 &lt;code&gt;Enum&lt;/code&gt; 유형으로 속성을 정의하는 것이 좋습니다. )</target>
        </trans-unit>
        <trans-unit id="97decb1d9664cf0136c81fed9708b0bd5475167d" translate="yes" xml:space="preserve">
          <source>Any JavaBean property defined with the &lt;code&gt;another&lt;/code&gt; prefix is mapped onto that &lt;code&gt;AnotherComponent&lt;/code&gt; bean in manner similar to the preceding &lt;code&gt;AcmeProperties&lt;/code&gt; example.</source>
          <target state="translated">&lt;code&gt;another&lt;/code&gt; 접두어로 정의 된 JavaBean 속성 은 앞의 &lt;code&gt;AcmeProperties&lt;/code&gt; 예제 와 유사한 방식으로 &lt;code&gt;AnotherComponent&lt;/code&gt; 빈에 매핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="980538348e8baa97e81268e0defa6af0ae22b2f1" translate="yes" xml:space="preserve">
          <source>Any Spring &lt;code&gt;@RestController&lt;/code&gt; in a Spring Boot application should render JSON response by default as long as Jackson2 is on the classpath, as shown in the following example:</source>
          <target state="translated">모든 봄 &lt;code&gt;@RestController&lt;/code&gt; 는 다음 예와 같이 Jackson2는, 클래스 패스에 같은 봄 부팅 응용 프로그램에서 긴 기본적으로 JSON 응답을 렌더링한다 :</target>
        </trans-unit>
        <trans-unit id="3f5d48a3b578979d22ade982ecefad1bd3b03a85" translate="yes" xml:space="preserve">
          <source>Any additional parameter that the provider supports (check the documentation of the provider for more details).</source>
          <target state="translated">공급자가 지원하는 추가 매개 변수 (자세한 내용은 공급자의 설명서를 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="61e30c029f6ef74d5c4ed9d2c26530f3102e86db" translate="yes" xml:space="preserve">
          <source>Any beans of type &lt;code&gt;com.fasterxml.jackson.databind.Module&lt;/code&gt; are automatically registered with the auto-configured &lt;code&gt;Jackson2ObjectMapperBuilder&lt;/code&gt; and are applied to any &lt;code&gt;ObjectMapper&lt;/code&gt; instances that it creates. This provides a global mechanism for contributing custom modules when you add new features to your application.</source>
          <target state="translated">&lt;code&gt;com.fasterxml.jackson.databind.Module&lt;/code&gt; 유형의 모든 bean 은 자동 구성된 &lt;code&gt;Jackson2ObjectMapperBuilder&lt;/code&gt; 에 자동으로 등록되고 생성 되는 모든 &lt;code&gt;ObjectMapper&lt;/code&gt; 인스턴스에 적용됩니다 . 이는 애플리케이션에 새 기능을 추가 할 때 사용자 정의 모듈을 제공하기위한 글로벌 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7408c1c09257cba54a0ef9455c0285b59d9a7316" translate="yes" xml:space="preserve">
          <source>Any classes annotated with &lt;code&gt;@Entity&lt;/code&gt;, &lt;code&gt;@Embeddable&lt;/code&gt;, or &lt;code&gt;@MappedSuperclass&lt;/code&gt; are considered. A typical entity class resembles the following example:</source>
          <target state="translated">&lt;code&gt;@Entity&lt;/code&gt; , &lt;code&gt;@Embeddable&lt;/code&gt; 또는 &lt;code&gt;@MappedSuperclass&lt;/code&gt; 로 주석이 달린 모든 클래스 가 고려됩니다. 일반적인 엔티티 클래스는 다음 예제와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="61c0c2b50b6874956ef13b46d8922375df78841f" translate="yes" xml:space="preserve">
          <source>Any compliant JCache (JSR-107) implementation</source>
          <target state="translated">모든 호환 JCache (JSR-107) 구현</target>
        </trans-unit>
        <trans-unit id="5024b8dd9634f1675ebe39ecf8fbc1c0381d5954" translate="yes" xml:space="preserve">
          <source>Any profiles activated in &lt;code&gt;.spring-boot-devtools.properties&lt;/code&gt; will not affect the loading of &lt;a href=&quot;spring-boot-features#boot-features-external-config-files-profile-specific&quot;&gt;profile-specific configuration files&lt;/a&gt;. Profile specific filenames (of the form &lt;code&gt;spring-boot-devtools-&amp;lt;profile&amp;gt;.properties&lt;/code&gt;) and &lt;code&gt;spring.config.activate.on-profile&lt;/code&gt; documents in both YAML and Properties files are not supported.</source>
          <target state="translated">&lt;code&gt;.spring-boot-devtools.properties&lt;/code&gt; 에서 활성화 된 모든 프로필 은 &lt;a href=&quot;spring-boot-features#boot-features-external-config-files-profile-specific&quot;&gt;프로필 별 구성 파일&lt;/a&gt; 의로드에 영향을주지 않습니다 . 프로파일 특정 파일 이름 ( &lt;code&gt;spring-boot-devtools-&amp;lt;profile&amp;gt;.properties&lt;/code&gt; 형식 ) 및 YAML 및 특성 파일 모두에서 &lt;code&gt;spring.config.activate.on-profile&lt;/code&gt; 문서는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9bd8af60d1a9f9171864567d51ae5b67d1a9f363" translate="yes" xml:space="preserve">
          <source>Any properties added to these file apply to &lt;em&gt;all&lt;/em&gt; Spring Boot applications on your machine that use devtools. For example, to configure restart to always use a &lt;a href=&quot;#using-boot-devtools-restart-triggerfile&quot;&gt;trigger file&lt;/a&gt;, you would add the following property to your &lt;code&gt;spring-boot-devtools&lt;/code&gt; file:</source>
          <target state="translated">이 파일에 추가 된 모든 속성은 devtools를 사용하는 머신의 &lt;em&gt;모든&lt;/em&gt; Spring Boot 애플리케이션에 적용됩니다 . 예를 들어, 항상 &lt;a href=&quot;#using-boot-devtools-restart-triggerfile&quot;&gt;트리거 파일을&lt;/a&gt; 사용하도록 restart를 구성하려면 &lt;code&gt;spring-boot-devtools&lt;/code&gt; 파일에 다음 속성을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="5096458a933b3e9a0a74cc545292c9239d326ab6" translate="yes" xml:space="preserve">
          <source>Any update to the file will trigger a check, but restart only actually occurs if Devtools has detected it has something to do.</source>
          <target state="translated">파일에 대한 모든 업데이트는 검사를 트리거하지만 실제로 재시작은 Devtools가 할 일이 있음을 감지 한 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95f6ceb046e96e9b383a16a6cdf2e8713f5c10e1" translate="yes" xml:space="preserve">
          <source>App Engine Standard requires you to use WAR packaging. Follow &lt;a href=&quot;https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/appengine-java8/springboot-helloworld/README.md&quot;&gt;these steps&lt;/a&gt; to deploy App Engine Standard application to Google Cloud.</source>
          <target state="translated">App Engine Standard에서는 WAR 패키징을 사용해야합니다. &lt;a href=&quot;https://github.com/GoogleCloudPlatform/java-docs-samples/tree/master/appengine-java8/springboot-helloworld/README.md&quot;&gt;다음 단계&lt;/a&gt; 에 따라 App Engine Standard 애플리케이션을 Google Cloud에 배포하세요.</target>
        </trans-unit>
        <trans-unit id="3cce5da3318c16cca4bc2dc80aa113d3bc4d1d7b" translate="yes" xml:space="preserve">
          <source>AppOptics</source>
          <target state="translated">AppOptics</target>
        </trans-unit>
        <trans-unit id="4ce97b47e7724b37d9f133723f5472c18ae50c4b" translate="yes" xml:space="preserve">
          <source>AppOptics API token.</source>
          <target state="translated">AppOptics API 토큰.</target>
        </trans-unit>
        <trans-unit id="1433dea65cc75495b574960d696977fabcc90a97" translate="yes" xml:space="preserve">
          <source>Append to log.</source>
          <target state="translated">로그에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="310efe41643f5cc89440741df972c1147eb711bf" translate="yes" xml:space="preserve">
          <source>Appender pattern for log date format.</source>
          <target state="translated">로그 날짜 형식의 Appender 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="b6ab72570bb697f6a55129e969e1c0b075c8df63" translate="yes" xml:space="preserve">
          <source>Appender pattern for log date format. Supported only with the default Logback setup.</source>
          <target state="translated">로그 날짜 형식의 Appender 패턴입니다. 기본 Logback 설정에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="46d788050c85b6ea368c3eb65752839ebbbc8a22" translate="yes" xml:space="preserve">
          <source>Appender pattern for log level. Supported only with the default Logback setup.</source>
          <target state="translated">로그 수준에 대한 Appender 패턴입니다. 기본 Logback 설정에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d60c2bfca8cfd17175b2322cdde0e784e477893f" translate="yes" xml:space="preserve">
          <source>Appender pattern for output to a file. Supported only with the default Logback setup.</source>
          <target state="translated">파일에 출력하기위한 Appender 패턴입니다. 기본 Logback 설정에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4c346667aa6aec3c6cb240a0d6b57cf2500a6c1e" translate="yes" xml:space="preserve">
          <source>Appender pattern for output to the console. Supported only with the default Logback setup.</source>
          <target state="translated">콘솔에 출력하기위한 Appender 패턴입니다. 기본 Logback 설정에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5b65483c9cecd9fa72e1970942ddc35ff2e860ac" translate="yes" xml:space="preserve">
          <source>Appendix application properties</source>
          <target state="translated">부록 응용 프로그램 속성</target>
        </trans-unit>
        <trans-unit id="a9a41c7ea94ea30afbc954ebf852cf6e8ef34c53" translate="yes" xml:space="preserve">
          <source>Appendix auto configuration classes</source>
          <target state="translated">부록 자동 구성 클래스</target>
        </trans-unit>
        <trans-unit id="5fb89c299bdaa3fc574e5b49dea1452651b59285" translate="yes" xml:space="preserve">
          <source>Appendix configuration metadata</source>
          <target state="translated">부록 구성 메타 데이터</target>
        </trans-unit>
        <trans-unit id="ad3748e507426b37f5ac7e4f41a1c887576a261e" translate="yes" xml:space="preserve">
          <source>Appendix dependency versions</source>
          <target state="translated">부록 종속성 버전</target>
        </trans-unit>
        <trans-unit id="96c57a760a359cebfa7062a1a5de473d880d6041" translate="yes" xml:space="preserve">
          <source>Appendix executable jar format</source>
          <target state="translated">부록 실행 가능한 jar 형식</target>
        </trans-unit>
        <trans-unit id="420fa56f93617aaf73118775c9f9c1a6ca59db46" translate="yes" xml:space="preserve">
          <source>Appendix test auto configuration</source>
          <target state="translated">부록 테스트 자동 구성</target>
        </trans-unit>
        <trans-unit id="e38bc7820a49f683041025ca0b1306817f6b80af" translate="yes" xml:space="preserve">
          <source>Application Development, Configuration, Embedded Servers, Data Access, and many more.</source>
          <target state="translated">애플리케이션 개발, 구성, 임베디드 서버, 데이터 액세스 등.</target>
        </trans-unit>
        <trans-unit id="3252c8dd86809c12991ca3ce9c641976809cb4ca" translate="yes" xml:space="preserve">
          <source>Application Properties</source>
          <target state="translated">응용 프로그램 속성</target>
        </trans-unit>
        <trans-unit id="a1536e47ce01571a8cf191d070a03d2e47763a1d" translate="yes" xml:space="preserve">
          <source>Application classes should be placed in a nested &lt;code&gt;BOOT-INF/classes&lt;/code&gt; directory. Dependencies should be placed in a nested &lt;code&gt;BOOT-INF/lib&lt;/code&gt; directory.</source>
          <target state="translated">애플리케이션 클래스는 중첩 된 &lt;code&gt;BOOT-INF/classes&lt;/code&gt; 디렉토리에 있어야합니다 . 종속성은 중첩 된 &lt;code&gt;BOOT-INF/lib&lt;/code&gt; 디렉토리에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="083568119644192870752ffe7fc1969279da3fdd" translate="yes" xml:space="preserve">
          <source>Application components can retrieve the current availability state at any time, by injecting the &lt;code&gt;ApplicationAvailability&lt;/code&gt; interface and calling methods on it. More often, applications will want to listen to state updates or update the state of the application.</source>
          <target state="translated">애플리케이션 구성 요소는 &lt;code&gt;ApplicationAvailability&lt;/code&gt; 인터페이스 를 삽입하고 여기에 메서드를 호출 하여 언제든지 현재 가용성 상태를 검색 할 수 있습니다 . 더 자주 애플리케이션은 상태 업데이트를 수신하거나 애플리케이션의 상태를 업데이트하려고합니다.</target>
        </trans-unit>
        <trans-unit id="008ce5a17a85312c92e14c7b2b0c0a59196e2e4b" translate="yes" xml:space="preserve">
          <source>Application events are sent by using Spring Framework&amp;rsquo;s event publishing mechanism. Part of this mechanism ensures that an event published to the listeners in a child context is also published to the listeners in any ancestor contexts. As a result of this, if your application uses a hierarchy of &lt;code&gt;SpringApplication&lt;/code&gt; instances, a listener may receive multiple instances of the same type of application event.</source>
          <target state="translated">애플리케이션 이벤트는 Spring Framework의 이벤트 게시 메커니즘을 사용하여 전송됩니다. 이 메커니즘의 일부는 하위 컨텍스트의 리스너에 게시 된 이벤트가 모든 상위 컨텍스트의 리스너에도 게시되도록합니다. 그 결과 애플리케이션이 &lt;code&gt;SpringApplication&lt;/code&gt; 인스턴스 의 계층 구조를 사용하는 경우 리스너는 동일한 유형의 애플리케이션 이벤트의 여러 인스턴스를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e03c7321220c2b16ec1dfec700f0d1fde434d0" translate="yes" xml:space="preserve">
          <source>Application events are sent in the following order, as your application runs:</source>
          <target state="translated">애플리케이션이 실행될 때 애플리케이션 이벤트는 다음 순서로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="84334dff975603618eaa8981a49aad9eebb2990c" translate="yes" xml:space="preserve">
          <source>Application information exposes various information collected from all &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java&quot;&gt;&lt;code&gt;InfoContributor&lt;/code&gt;&lt;/a&gt; beans defined in your &lt;code&gt;ApplicationContext&lt;/code&gt;. Spring Boot includes a number of auto-configured &lt;code&gt;InfoContributor&lt;/code&gt; beans, and you can write your own.</source>
          <target state="translated">응용 프로그램 정보는 모든로부터 수집 된 다양한 정보 노출 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java&quot;&gt; &lt;code&gt;InfoContributor&lt;/code&gt; 의&lt;/a&gt; 당신에 정의 된 콩 &lt;code&gt;ApplicationContext&lt;/code&gt; . Spring Boot에는 자동 구성되는 여러 &lt;code&gt;InfoContributor&lt;/code&gt; Bean이 포함되어 있으며 직접 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf171227ff1428401819ab3800da2acc36ae658c" translate="yes" xml:space="preserve">
          <source>Application name.</source>
          <target state="translated">응용 프로그램 이름.</target>
        </trans-unit>
        <trans-unit id="d762af80efe2e32154fc05c9774fb8a0f7b3b165" translate="yes" xml:space="preserve">
          <source>Application properties</source>
          <target state="translated">응용 프로그램 속성</target>
        </trans-unit>
        <trans-unit id="55d767b96724fd2a9af8dc15039b884b7a6310e8" translate="yes" xml:space="preserve">
          <source>Application properties may import further config data from other locations using the &lt;code&gt;spring.config.import&lt;/code&gt; property. Imports are processed as they are discovered, and are treated as an additional documents inserted immediately below the one that declares the import.</source>
          <target state="translated">응용 프로그램 속성은 &lt;code&gt;spring.config.import&lt;/code&gt; 속성을 사용하여 다른 위치에서 추가 구성 데이터를 가져올 수 있습니다. 가져 오기는 검색된대로 처리되며 가져 오기를 선언하는 문서 바로 아래에 삽입 된 추가 문서로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fb33f6ac5c613a0c0e0abe2a199936b39522535c" translate="yes" xml:space="preserve">
          <source>Application shutdown phase</source>
          <target state="translated">애플리케이션 종료 단계</target>
        </trans-unit>
        <trans-unit id="3cffe65545abe506f6625314e60e111b03bda56d" translate="yes" xml:space="preserve">
          <source>Application startup phase</source>
          <target state="translated">애플리케이션 시작 단계</target>
        </trans-unit>
        <trans-unit id="f638df42412294394f75f2c765076a4f808666cf" translate="yes" xml:space="preserve">
          <source>Applications can fall into more than one category:</source>
          <target state="translated">응용 프로그램은 둘 이상의 범주에 속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d16ea541bcc4bdbf06414b2cfeab7ae51137197" translate="yes" xml:space="preserve">
          <source>Applications deployed on Kubernetes can provide information about their internal state with &lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes&quot;&gt;Container Probes&lt;/a&gt;. Depending on &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&quot;&gt;your Kubernetes configuration&lt;/a&gt;, the kubelet will call those probes and react to the result.</source>
          <target state="translated">Kubernetes에 배포 된 애플리케이션은 &lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes&quot;&gt;Container Probes를&lt;/a&gt; 통해 내부 상태에 대한 정보를 제공 할 수 있습니다 . 에 따라 &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&quot;&gt;귀하는 Kubernetes 구성&lt;/a&gt; 의 kubelet 그 프로브를 호출하고 그 결과에 반응한다.</target>
        </trans-unit>
        <trans-unit id="163e24e17004fd46028810d77ad707c0f624d214" translate="yes" xml:space="preserve">
          <source>Applications that are not already Spring applications might be convertible to Spring Boot applications, and the previously mentioned guidance may help. However, you may yet encounter problems. In that case, we suggest &lt;a href=&quot;https://stackoverflow.com/questions/tagged/spring-boot&quot;&gt;asking questions on Stack Overflow with a tag of &lt;code&gt;spring-boot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아직 Spring 애플리케이션이 아닌 애플리케이션은 Spring Boot 애플리케이션으로 변환 할 수 있으며 앞서 언급 한 지침이 도움이 될 수 있습니다. 그러나 아직 문제가 발생할 수 있습니다. 이 경우 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/spring-boot&quot;&gt; &lt;code&gt;spring-boot&lt;/code&gt; &lt;/a&gt; 태그를 사용하여 Stack Overflow에 질문하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4cdb4b06cf0d0530c068c0f1171bf58f8b2e3681" translate="yes" xml:space="preserve">
          <source>Applications that use &lt;code&gt;spring-boot-devtools&lt;/code&gt; automatically restart whenever files on the classpath change. This can be a useful feature when working in an IDE, as it gives a very fast feedback loop for code changes. By default, any entry on the classpath that points to a directory is monitored for changes. Note that certain resources, such as static assets and view templates, &lt;a href=&quot;#using-boot-devtools-restart-exclude&quot;&gt;do not need to restart the application&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;spring-boot-devtools&lt;/code&gt; 를 사용하는 애플리케이션 은 클래스 경로의 파일이 변경 될 때마다 자동으로 다시 시작됩니다. 코드 변경에 대한 매우 빠른 피드백 루프를 제공하므로 IDE에서 작업 할 때 유용한 기능이 될 수 있습니다. 기본적으로 디렉토리를 가리키는 클래스 경로의 모든 항목은 변경 사항을 모니터링합니다. 정적 자산 및보기 템플릿과 같은 특정 리소스 &lt;a href=&quot;#using-boot-devtools-restart-exclude&quot;&gt;는 애플리케이션을 다시 시작할 필요가 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1059c81aca8ce78d75e312142ef5d5851030956" translate="yes" xml:space="preserve">
          <source>Applications with a &lt;code&gt;web.xml&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;web.xml&lt;/code&gt; 을 사용하는 애플리케이션 .</target>
        </trans-unit>
        <trans-unit id="c617e161c40c7370ff2744d917e3bd5124a2bebb" translate="yes" xml:space="preserve">
          <source>Applications with a context hierarchy.</source>
          <target state="translated">컨텍스트 계층이있는 애플리케이션.</target>
        </trans-unit>
        <trans-unit id="2db8bf51876c964ca2dd8861269a3f172f933e69" translate="yes" xml:space="preserve">
          <source>Applications without a context hierarchy.</source>
          <target state="translated">컨텍스트 계층이없는 애플리케이션.</target>
        </trans-unit>
        <trans-unit id="1bdb2640a6fcc74052ead339c66dbfbb7b1ae2d1" translate="yes" xml:space="preserve">
          <source>Arbitrary properties to add to the info endpoint.</source>
          <target state="translated">정보 끝점에 추가 할 임의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="1220c8b28eaaf92a3e181a7a35327288434a8f91" translate="yes" xml:space="preserve">
          <source>Architecture guide</source>
          <target state="translated">아키텍처 가이드</target>
        </trans-unit>
        <trans-unit id="857b6e76f7c49e9d744eb8ebb007dac12c197a23" translate="yes" xml:space="preserve">
          <source>Armed with this information, we can load specific nested entries by seeking to the appropriate part of the outer jar. We do not need to unpack the archive, and we do not need to read all entry data into memory.</source>
          <target state="translated">이 정보로 무장하면 외부 jar의 적절한 부분을 찾아 특정 중첩 항목을로드 할 수 있습니다. 아카이브의 압축을 풀 필요가 없으며 모든 항목 데이터를 메모리로 읽을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fd6c936ddb1bcfc5c85c015b4e1a1b7ed717ce8" translate="yes" xml:space="preserve">
          <source>Artemis broker host.</source>
          <target state="translated">Artemis 브로커 호스트.</target>
        </trans-unit>
        <trans-unit id="d4304d965113e5f5c2bde30b2ab8628d50332126" translate="yes" xml:space="preserve">
          <source>Artemis broker port.</source>
          <target state="translated">Artemis 브로커 포트.</target>
        </trans-unit>
        <trans-unit id="40dedb1a715fd0a95b0a9f18009f8e5f38c2cb2f" translate="yes" xml:space="preserve">
          <source>Artemis configuration is controlled by external configuration properties in &lt;code&gt;spring.artemis.*&lt;/code&gt;. For example, you might declare the following section in &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">Artemis 구성은 &lt;code&gt;spring.artemis.*&lt;/code&gt; 의 외부 구성 속성에 의해 제어됩니다 . 예를 들어 &lt;code&gt;application.properties&lt;/code&gt; 에서 다음 섹션을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f6fea8a64c6ee0af1591256a67937300ff52cee" translate="yes" xml:space="preserve">
          <source>Artemis deployment mode, auto-detected by default.</source>
          <target state="translated">Artemis 배포 모드, 기본적으로 자동 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="ca6ffa48cad2f78f624d816a2099332f808de3ce" translate="yes" xml:space="preserve">
          <source>Artifact ID</source>
          <target state="translated">아티팩트 ID</target>
        </trans-unit>
        <trans-unit id="121b6ddbd288a8dcc9ac840013b397400621c161" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#howto-add-a-servlet-filter-or-listener-as-spring-bean&quot;&gt;described earlier&lt;/a&gt;, any &lt;code&gt;Servlet&lt;/code&gt; or &lt;code&gt;Filter&lt;/code&gt; beans are registered with the servlet container automatically. To disable registration of a particular &lt;code&gt;Filter&lt;/code&gt; or &lt;code&gt;Servlet&lt;/code&gt; bean, create a registration bean for it and mark it as disabled, as shown in the following example:</source>
          <target state="translated">앞에서 &lt;a href=&quot;#howto-add-a-servlet-filter-or-listener-as-spring-bean&quot;&gt;설명한 것처럼&lt;/a&gt; 모든 &lt;code&gt;Servlet&lt;/code&gt; 또는 &lt;code&gt;Filter&lt;/code&gt; 빈은 서블릿 컨테이너에 자동으로 등록됩니다. 특정 &lt;code&gt;Filter&lt;/code&gt; 또는 &lt;code&gt;Servlet&lt;/code&gt; 빈의 등록을 비활성화하려면 다음 예제와 같이 등록 빈을 만들고 비활성화 된 것으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="f15605bff5aa26c8bc5bee68daa223a54d0f7c1a" translate="yes" xml:space="preserve">
          <source>As DevTools monitors classpath resources, the only way to trigger a restart is to update the classpath. The way in which you cause the classpath to be updated depends on the IDE that you are using. In Eclipse, saving a modified file causes the classpath to be updated and triggers a restart. In IntelliJ IDEA, building the project (&lt;code&gt;Build +&amp;rarr;+ Build Project&lt;/code&gt;) has the same effect.</source>
          <target state="translated">DevTools가 클래스 경로 리소스를 모니터링하므로 다시 시작을 트리거하는 유일한 방법은 클래스 경로를 업데이트하는 것입니다. 클래스 경로를 업데이트하는 방법은 사용중인 IDE에 따라 다릅니다. Eclipse에서 수정 된 파일을 저장하면 클래스 경로가 업데이트되고 재시작이 트리거됩니다. IntelliJ IDEA에서 프로젝트 &lt;code&gt;Build +&amp;rarr;+ Build Project&lt;/code&gt; ( Build + &amp;rarr; + Build Project )는 동일한 효과를냅니다.</target>
        </trans-unit>
        <trans-unit id="0393a01cdc54095169e0466f769e33dbd84c6692" translate="yes" xml:space="preserve">
          <source>As a last resort, you can also declare your own &lt;code&gt;WebServerFactory&lt;/code&gt; component, which will override the one provided by Spring Boot. In this case, you can&amp;rsquo;t rely on configuration properties in the &lt;code&gt;server&lt;/code&gt; namespace anymore.</source>
          <target state="translated">최후의 수단 으로 Spring Boot에서 제공하는 구성 요소를 재정의하는 자체 &lt;code&gt;WebServerFactory&lt;/code&gt; 구성 요소를 선언 할 수도 있습니다 . 이 경우 더 이상 &lt;code&gt;server&lt;/code&gt; 네임 스페이스의 구성 속성에 의존 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="917ec02ced2d855aee38484b6a4927f8ba7cf616" translate="yes" xml:space="preserve">
          <source>As a rule of thumb, you should name a combined module after the starter. For example, assume that you are creating a starter for &quot;acme&quot; and that you name the auto-configure module &lt;code&gt;acme-spring-boot&lt;/code&gt; and the starter &lt;code&gt;acme-spring-boot-starter&lt;/code&gt;. If you only have one module that combines the two, name it &lt;code&gt;acme-spring-boot-starter&lt;/code&gt;.</source>
          <target state="translated">경험에 따라 결합 된 모듈의 이름은 스타터 뒤에 지정해야합니다. 예를 들어 &quot;acme&quot;에 대한 스타터를 만들고 자동 구성 모듈의 이름을 &lt;code&gt;acme-spring-boot&lt;/code&gt; 및 스타터 &lt;code&gt;acme-spring-boot-starter&lt;/code&gt; 로 지정한다고 가정합니다 . 둘을 결합하는 모듈이 하나만있는 경우 이름을 &lt;code&gt;acme-spring-boot-starter&lt;/code&gt; 로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="af69f8fb8454928cba9006019b11ea3ddd316dfd" translate="yes" xml:space="preserve">
          <source>As a server, you can get injected with an &lt;code&gt;RSocketRequester&lt;/code&gt; instance on any handler method of an RSocket &lt;code&gt;@Controller&lt;/code&gt;. As a client, you need to configure and establish an RSocket connection first. Spring Boot auto-configures an &lt;code&gt;RSocketRequester.Builder&lt;/code&gt; for such cases with the expected codecs.</source>
          <target state="translated">서버로서 RSocket &lt;code&gt;@Controller&lt;/code&gt; 의 모든 핸들러 메서드에 &lt;code&gt;RSocketRequester&lt;/code&gt; 인스턴스를 주입 할 수 있습니다 . 클라이언트는 먼저 RSocket 연결을 구성하고 설정해야합니다. Spring Boot 는 예상 코덱으로 이러한 경우에 &lt;code&gt;RSocketRequester.Builder&lt;/code&gt; 를 자동 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="984be7eed8dc2057b73a4618cc0cfd42ad346849" translate="yes" xml:space="preserve">
          <source>As an alternative to environment variables, many cloud platforms now allow you to map configuration into mounted data volumes. For example, Kubernetes can volume mount both &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap&quot;&gt;&lt;code&gt;ConfigMaps&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod&quot;&gt;&lt;code&gt;Secrets&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경 변수의 대안으로 이제 많은 클라우드 플랫폼을 사용하여 마운트 된 데이터 볼륨에 구성을 매핑 할 수 있습니다. 예를 들어 Kubernetes는 &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#populate-a-volume-with-data-stored-in-a-configmap&quot;&gt; &lt;code&gt;ConfigMaps&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://kubernetes.io/docs/concepts/configuration/secret/#using-secrets-as-files-from-a-pod&quot;&gt; &lt;code&gt;Secrets&lt;/code&gt; &lt;/a&gt; 모두를 볼륨 마운트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="827a9e137d7e1b2d8bf51dc3ce44e09e26be4f91" translate="yes" xml:space="preserve">
          <source>As an example, consider the following &lt;code&gt;@ConfigurationProperties&lt;/code&gt; class:</source>
          <target state="translated">예를 들어 다음 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 클래스를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="4871d04412861d09971fddf6d9e713fa73d94b52" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s imagine that Kubernetes has mounted the following volume:</source>
          <target state="translated">예를 들어 Kubernetes가 다음 볼륨을 마운트했다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1e3a994a63e6905ee1958d65b6994349f8b423dd" translate="yes" xml:space="preserve">
          <source>As before, to exit the application, press &lt;code&gt;ctrl-c&lt;/code&gt;.</source>
          <target state="translated">이전과 마찬가지로 응용 프로그램을 종료하려면 &lt;code&gt;ctrl-c&lt;/code&gt; 를 누릅니다 .</target>
        </trans-unit>
        <trans-unit id="39d4bdbbbd6bad161283369553f84d1b898f63c1" translate="yes" xml:space="preserve">
          <source>As described earlier in the &lt;a href=&quot;#using-spring-boot-restart-vs-reload&quot;&gt;Restart vs Reload&lt;/a&gt; section, restart functionality is implemented by using two classloaders. For most applications, this approach works well. However, it can sometimes cause classloading issues.</source>
          <target state="translated">&lt;a href=&quot;#using-spring-boot-restart-vs-reload&quot;&gt;다시 시작과 다시로드&lt;/a&gt; 섹션 의 앞부분에서 설명한대로 다시 시작 기능은 두 개의 클래스 로더를 사용하여 구현됩니다. 대부분의 애플리케이션에서이 접근 방식은 잘 작동합니다. 그러나 때때로 클래스 로딩 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5439fdd04e81880616fe69459936ff786a4d06" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;spring-boot-features#boot-features-resttemplate-customization&quot;&gt;spring-boot-features.html&lt;/a&gt;, you can use a &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; with &lt;code&gt;RestTemplateBuilder&lt;/code&gt; to build a customized &lt;code&gt;RestTemplate&lt;/code&gt;. This is the recommended approach for creating a &lt;code&gt;RestTemplate&lt;/code&gt; configured to use a proxy.</source>
          <target state="translated">에서 설명한 바와 같이 &lt;a href=&quot;spring-boot-features#boot-features-resttemplate-customization&quot;&gt;스프링 부팅 features.html 주요&lt;/a&gt; , 당신은 사용할 수 있습니다 &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; 을 함께 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 사용자 정의 구축 &lt;code&gt;RestTemplate&lt;/code&gt; 을 . 프록시를 사용하도록 구성된 &lt;code&gt;RestTemplate&lt;/code&gt; 을 만드는 데 권장되는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="813c2e9e2f6c10d8dd8bbc0e4bac0902f3468f2d" translate="yes" xml:space="preserve">
          <source>As described in the official &lt;a href=&quot;https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html&quot;&gt;Elastic Beanstalk Java guide&lt;/a&gt;, there are two main options to deploy a Java application. You can either use the &amp;ldquo;Tomcat Platform&amp;rdquo; or the &amp;ldquo;Java SE platform&amp;rdquo;.</source>
          <target state="translated">공식 &lt;a href=&quot;https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/create_deploy_Java.html&quot;&gt;Elastic Beanstalk Java 가이드에&lt;/a&gt; 설명 된대로 Java 애플리케이션을 배포하는 두 가지 주요 옵션이 있습니다. &quot;Tomcat 플랫폼&quot;또는 &quot;Java SE 플랫폼&quot;을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="045489019cb2e737a7de583e460b2bc4dda0e67d" translate="yes" xml:space="preserve">
          <source>As explained in the &amp;ldquo;&lt;a href=&quot;spring-boot-features#boot-features-custom-starter&quot;&gt;Creating Your Own Starter&lt;/a&gt;&amp;rdquo; section, third party starters should not start with &lt;code&gt;spring-boot&lt;/code&gt;, as it is reserved for official Spring Boot artifacts. Rather, a third-party starter typically starts with the name of the project. For example, a third-party starter project called &lt;code&gt;thirdpartyproject&lt;/code&gt; would typically be named &lt;code&gt;thirdpartyproject-spring-boot-starter&lt;/code&gt;.</source>
          <target state="translated">&amp;ldquo; &lt;a href=&quot;spring-boot-features#boot-features-custom-starter&quot;&gt;Creating Your Own Starter&lt;/a&gt; &amp;rdquo;섹션 에서 설명했듯이 써드 파티 스타터는 공식 Spring Boot 아티팩트 용으로 예약되어 있으므로 &lt;code&gt;spring-boot&lt;/code&gt; 로 시작해서는 안됩니다 . 오히려 타사 스타터는 일반적으로 프로젝트 이름으로 시작합니다. 예를 들어 &lt;code&gt;thirdpartyproject&lt;/code&gt; 라는 타사 시작 프로젝트의 이름 은 일반적으로 &lt;code&gt;thirdpartyproject-spring-boot-starter&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="66b4a60817e424af5fa3e3278e6a5b303d322f61" translate="yes" xml:space="preserve">
          <source>As for the &amp;ldquo;readiness&amp;rdquo; Probe, the choice of checking external systems must be made carefully by the application developers, i.e. Spring Boot does not include any additional health checks in the readiness probe. If the &lt;a href=&quot;spring-boot-features#boot-features-application-availability-readiness-state&quot;&gt;Readiness State of an application instance&lt;/a&gt; is unready, Kubernetes will not route traffic to that instance. Some external systems might not be shared by application instances, in which case they could quite naturally be included in a readiness probe. Other external systems might not be essential to the application (the application could have circuit breakers and fallbacks), in which case they definitely should not be included. Unfortunately, an external system that is shared by all application instances is common, and you have to make a judgement call: include it in the readiness probe and expect that the application is taken out of service when the external service is down, or leave it out and deal with failures higher up the stack, e.g. using a circuit breaker in the caller.</source>
          <target state="translated">&quot;준비&quot;프로브의 경우 외부 시스템 검사는 애플리케이션 개발자가 신중하게 선택해야합니다. 즉, Spring Boot는 준비 상태 프로브에 추가 상태 검사를 포함하지 않습니다. &lt;a href=&quot;spring-boot-features#boot-features-application-availability-readiness-state&quot;&gt;애플리케이션 인스턴스&lt;/a&gt; 의 준비 상태준비되지 않은 경우 Kubernetes는 해당 인스턴스로 트래픽을 라우팅하지 않습니다. 일부 외부 시스템은 애플리케이션 인스턴스에서 공유되지 않을 수 있으며,이 경우 준비 상태 프로브에 자연스럽게 포함될 수 있습니다. 다른 외부 시스템은 애플리케이션에 필수적이지 않을 수 있습니다 (애플리케이션에 회로 차단기 및 폴 백이있을 수 있음).이 경우 반드시 포함해서는 안됩니다. 안타깝게도 모든 애플리케이션 인스턴스가 공유하는 외부 시스템은 일반적이며 판단을 내려야합니다. 준비 상태 프로브에 포함하고 외부 서비스가 다운되었을 때 애플리케이션이 서비스에서 제외 될 것으로 예상하거나 그대로 둡니다. 호출자에서 회로 차단기를 사용하는 등 스택 상위의 오류를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="bbe7a78b0ff73ef18a372290c737ce19434dc3b7" translate="yes" xml:space="preserve">
          <source>As in normal MVC usage, any &lt;code&gt;WebMvcConfigurer&lt;/code&gt; beans that you provide can also contribute converters by overriding the &lt;code&gt;configureMessageConverters&lt;/code&gt; method. However, unlike with normal MVC, you can supply only additional converters that you need (because Spring Boot uses the same mechanism to contribute its defaults). Finally, if you opt out of the Spring Boot default MVC configuration by providing your own &lt;code&gt;@EnableWebMvc&lt;/code&gt; configuration, you can take control completely and do everything manually by using &lt;code&gt;getMessageConverters&lt;/code&gt; from &lt;code&gt;WebMvcConfigurationSupport&lt;/code&gt;.</source>
          <target state="translated">일반적인 MVC 사용에서와 같이 사용자가 제공하는 모든 &lt;code&gt;WebMvcConfigurer&lt;/code&gt; Bean은 &lt;code&gt;configureMessageConverters&lt;/code&gt; 메소드 를 대체하여 변환기에 기여할 수도 있습니다 . 그러나 일반 MVC와 달리 필요한 추가 변환기 만 제공 할 수 있습니다 (Spring Boot는 동일한 메커니즘을 사용하여 기본값을 제공하기 때문입니다). 마지막으로 자신의 &lt;code&gt;@EnableWebMvc&lt;/code&gt; 구성 을 제공하여 Spring Boot 기본 MVC 구성을 옵트 아웃 하면 &lt;code&gt;WebMvcConfigurationSupport&lt;/code&gt; 의 &lt;code&gt;getMessageConverters&lt;/code&gt; 를 사용하여 완전히 제어하고 모든 작업을 수동으로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30083d8fea40c8e13dcc1fb46ee2c9be00c46575" translate="yes" xml:space="preserve">
          <source>As long as &lt;code&gt;MyThing&lt;/code&gt; can be serialized by Jackson2 (true for a normal POJO or Groovy object), then &lt;code&gt;&lt;a href=&quot;http://localhost:8080/thing&quot;&gt;localhost:8080/thing&lt;/a&gt;&lt;/code&gt; serves a JSON representation of it by default. Note that, in a browser, you might sometimes see XML responses, because browsers tend to send accept headers that prefer XML.</source>
          <target state="translated">만큼 &lt;code&gt;MyThing&lt;/code&gt; 은 다음 (일반 POJO 나 그루비 객체에 대한 사실) Jackson2에 의해 직렬화 할 수있는 &lt;code&gt;&lt;a href=&quot;http://localhost:8080/thing&quot;&gt;localhost:8080/thing&lt;/a&gt;&lt;/code&gt; 기본적으로 그것의 JSON 표현을 제공합니다. 브라우저는 XML을 선호하는 수락 헤더를 보내는 경향이 있기 때문에 브라우저에서 때때로 XML 응답을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5981866d4c175772111d5f655a235df115936269" translate="yes" xml:space="preserve">
          <source>As long as forking is enabled, you can also start your application by using the supported build plugins (Maven and Gradle), since DevTools needs an isolated application classloader to operate properly. By default, the Gradle and Maven plugins fork the application process.</source>
          <target state="translated">분기가 활성화되어있는 한 지원되는 빌드 플러그인 (Maven 및 Gradle)을 사용하여 애플리케이션을 시작할 수도 있습니다. DevTools가 제대로 작동하려면 격리 된 애플리케이션 클래스 로더가 필요하기 때문입니다. 기본적으로 Gradle 및 Maven 플러그인은 애플리케이션 프로세스를 분기합니다.</target>
        </trans-unit>
        <trans-unit id="cc42dd60bc579e8095789af8778f490322138b57" translate="yes" xml:space="preserve">
          <source>As of Spring Boot 2.3, support for Bitronix has been deprecated and will be removed in a future release.</source>
          <target state="translated">Spring Boot 2.3부터 Bitronix에 대한 지원은 더 이상 사용되지 않으며 향후 릴리스에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f07ee9dece8cff1d8c21176d835bdfcf3a974fe1" translate="yes" xml:space="preserve">
          <source>As of Spring Framework 5.3, Spring MVC supports several implementation strategies for matching request paths to Controller handlers. It was previously only supporting the &lt;code&gt;AntPathMatcher&lt;/code&gt; strategy, but it now also offers &lt;code&gt;PathPatternParser&lt;/code&gt;. Spring Boot now provides a configuration property to choose and opt in the new strategy:</source>
          <target state="translated">Spring Framework 5.3부터 Spring MVC는 요청 경로를 Controller 핸들러에 일치시키기위한 여러 구현 전략을 지원합니다. 이전에는 &lt;code&gt;AntPathMatcher&lt;/code&gt; 전략 만 지원 했지만 이제는 &lt;code&gt;PathPatternParser&lt;/code&gt; 도 제공합니다 . 이제 Spring Boot는 새 전략을 선택하고 선택할 수있는 구성 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0765c8c782bb5be84f7daac22c4d9a459ec89022" translate="yes" xml:space="preserve">
          <source>As of Undertow 1.4.0+, HTTP/2 is supported without any additional requirement on JDK8.</source>
          <target state="translated">Undertow 1.4.0+부터는 JDK8에 대한 추가 요구 사항없이 HTTP / 2가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="88ba618ea2b28f929ea9e98a6dccfcfe7012e742" translate="yes" xml:space="preserve">
          <source>As of version 4.2, Spring MVC &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-cors&quot;&gt;supports CORS&lt;/a&gt;. Using &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-cors-controller&quot;&gt;controller method CORS configuration&lt;/a&gt; with &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html&quot;&gt;&lt;code&gt;@CrossOrigin&lt;/code&gt;&lt;/a&gt; annotations in your Spring Boot application does not require any specific configuration. &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-cors-global&quot;&gt;Global CORS configuration&lt;/a&gt; can be defined by registering a &lt;code&gt;WebMvcConfigurer&lt;/code&gt; bean with a customized &lt;code&gt;addCorsMappings(CorsRegistry)&lt;/code&gt; method, as shown in the following example:</source>
          <target state="translated">4.2 버전부터 Spring MVC &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-cors&quot;&gt;는 CORS를 지원합니다&lt;/a&gt; . Spring Boot 애플리케이션에서 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html&quot;&gt; &lt;code&gt;@CrossOrigin&lt;/code&gt; &lt;/a&gt; 어노테이션 과 함께 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-cors-controller&quot;&gt;컨트롤러 메소드 CORS 구성&lt;/a&gt; 을 사용하면 특정 구성이 필요하지 않습니다. 다음 예제와 같이 사용자 정의 된 &lt;code&gt;addCorsMappings(CorsRegistry)&lt;/code&gt; 메소드 로 &lt;code&gt;WebMvcConfigurer&lt;/code&gt; Bean을 등록하여 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-cors-global&quot;&gt;글로벌 CORS 구성&lt;/a&gt; 을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b0079ffa849a69cd6832613ab08ce7d17f7efba" translate="yes" xml:space="preserve">
          <source>As the test context framework caches context, JMX is disabled by default to prevent identical components to register on the same domain. If such test needs access to an &lt;code&gt;MBeanServer&lt;/code&gt;, consider marking it dirty as well:</source>
          <target state="translated">테스트 컨텍스트 프레임 워크가 컨텍스트를 캐시하므로 동일한 구성 요소가 동일한 도메인에 등록되지 않도록 기본적으로 JMX가 비활성화됩니다. 이러한 테스트가 &lt;code&gt;MBeanServer&lt;/code&gt; 에 액세스해야하는 경우 더티 표시도 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4b713931a7e26e8236d575c149c46468099cdea1" translate="yes" xml:space="preserve">
          <source>As this bean is requested very early during the application lifecycle, make sure to limit the dependencies that your &lt;code&gt;ConversionService&lt;/code&gt; is using. Typically, any dependency that you require may not be fully initialized at creation time. You may want to rename your custom &lt;code&gt;ConversionService&lt;/code&gt; if it is not required for configuration keys coercion and only rely on custom converters qualified with &lt;code&gt;@ConfigurationPropertiesBinding&lt;/code&gt;.</source>
          <target state="translated">이 Bean은 애플리케이션 라이프 사이클 동안 매우 일찍 요청되므로 &lt;code&gt;ConversionService&lt;/code&gt; 가 사용 하는 종속성을 제한해야합니다 . 일반적으로 필요한 종속성은 생성시 완전히 초기화되지 않을 수 있습니다. 구성 키 강제 변환에 필요하지 않고 &lt;code&gt;@ConfigurationPropertiesBinding&lt;/code&gt; 으로 정규화 된 사용자 지정 변환기에만 의존하는 경우 사용자 지정 &lt;code&gt;ConversionService&lt;/code&gt; 이름을 바꿀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0421fc652f1ce0ec471210abe922daa52fb94d61" translate="yes" xml:space="preserve">
          <source>As this is a new feature, IDE vendors must catch up with how it works. Adoption times naturally vary.</source>
          <target state="translated">이것은 새로운 기능이므로 IDE 공급 업체는 작동 방식을 따라 잡아야합니다. 입양 시간은 당연히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="593b9109e550d972ff0b0831fa7400b8ad108615" translate="yes" xml:space="preserve">
          <source>As we &lt;a href=&quot;#boot-features-testing-spring-boot-applications-detecting-config&quot;&gt;have seen earlier&lt;/a&gt;, &lt;code&gt;@TestConfiguration&lt;/code&gt; can be used on an inner class of a test to customize the primary configuration. When placed on a top-level class, &lt;code&gt;@TestConfiguration&lt;/code&gt; indicates that classes in &lt;code&gt;src/test/java&lt;/code&gt; should not be picked up by scanning. You can then import that class explicitly where it is required, as shown in the following example:</source>
          <target state="translated">우리가 &lt;a href=&quot;#boot-features-testing-spring-boot-applications-detecting-config&quot;&gt;이전에 본&lt;/a&gt; , &lt;code&gt;@TestConfiguration&lt;/code&gt; 는 기본 구성을 사용자 정의 테스트의 내부 클래스에서 사용할 수 있습니다. 최상위 클래스에 배치 될 때 &lt;code&gt;@TestConfiguration&lt;/code&gt; 은 &lt;code&gt;src/test/java&lt;/code&gt; 의 클래스 가 스캔으로 선택되지 않아야 함을 나타냅니다 . 그런 다음 다음 예제와 같이 필요한 위치에 해당 클래스를 명시 적으로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62cce2224d9fa51b043fcff0f5f75c36cdddc001" translate="yes" xml:space="preserve">
          <source>As well as &lt;code&gt;application&lt;/code&gt; property files, Spring Boot will also attempt to load profile-specific files using the naming convention &lt;code&gt;application-{profile}&lt;/code&gt;. For example, if your application activates a profile named &lt;code&gt;prod&lt;/code&gt; and uses YAML files, then both &lt;code&gt;application.yml&lt;/code&gt; and &lt;code&gt;application-prod.yml&lt;/code&gt; will be considered.</source>
          <target state="translated">&lt;code&gt;application&lt;/code&gt; 속성 파일 과 마찬가지로 Spring Boot는 이름 지정 규칙 &lt;code&gt;application-{profile}&lt;/code&gt; 을 사용하여 프로필 특정 파일을로드하려고 시도합니다 . 예를 들어 애플리케이션이 &lt;code&gt;prod&lt;/code&gt; 라는 프로필을 활성화하고 YAML 파일을 사용하는 경우 &lt;code&gt;application.yml&lt;/code&gt; 과 &lt;code&gt;application-prod.yml&lt;/code&gt; 이 모두 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="458f059ba47e47aecd15fa4eda3d00e91aa7f208" translate="yes" xml:space="preserve">
          <source>As well as REST web services, you can also use Spring MVC to serve dynamic HTML content. Spring MVC supports a variety of templating technologies, including Thymeleaf, FreeMarker, and JSPs. Also, many other templating engines include their own Spring MVC integrations.</source>
          <target state="translated">REST 웹 서비스뿐만 아니라 Spring MVC를 사용하여 동적 HTML 콘텐츠를 제공 할 수도 있습니다. Spring MVC는 Thymeleaf, FreeMarker 및 JSP를 포함한 다양한 템플릿 기술을 지원합니다. 또한 다른 많은 템플릿 엔진에는 자체 Spring MVC 통합이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a48df9a6debdfcdab555148442c1bd244b06e049" translate="yes" xml:space="preserve">
          <source>As well as REST web services, you can also use Spring WebFlux to serve dynamic HTML content. Spring WebFlux supports a variety of templating technologies, including Thymeleaf, FreeMarker, and Mustache.</source>
          <target state="translated">REST 웹 서비스뿐만 아니라 Spring WebFlux를 사용하여 동적 HTML 콘텐츠를 제공 할 수도 있습니다. Spring WebFlux는 Thymeleaf, FreeMarker 및 Mustache를 포함한 다양한 템플릿 기술을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c533f22f9da011d71825a90fee56cd98c11ff961" translate="yes" xml:space="preserve">
          <source>As well as using &lt;code&gt;@ConfigurationProperties&lt;/code&gt; to annotate a class, you can also use it on public &lt;code&gt;@Bean&lt;/code&gt; methods. Doing so can be particularly useful when you want to bind properties to third-party components that are outside of your control.</source>
          <target state="translated">&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 를 사용하여 클래스에 주석을 추가 할 뿐만 아니라 공용 &lt;code&gt;@Bean&lt;/code&gt; 메서드 에서도 사용할 수 있습니다 . 이렇게하면 컨트롤 외부에있는 타사 구성 요소에 속성을 바인딩하려는 경우 특히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0071112c52de244af06951cd9ec0691409c0520" translate="yes" xml:space="preserve">
          <source>As with standard &lt;code&gt;@Configuration&lt;/code&gt; classes, the order in which auto-configuration classes are applied only affects the order in which their beans are defined. The order in which those beans are subsequently created is unaffected and is determined by each bean&amp;rsquo;s dependencies and any &lt;code&gt;@DependsOn&lt;/code&gt; relationships.</source>
          <target state="translated">표준 &lt;code&gt;@Configuration&lt;/code&gt; 클래스 와 마찬가지로 자동 구성 클래스가 적용되는 순서는 해당 Bean이 정의 된 순서에만 영향을줍니다. 이러한 Bean이 이후에 생성되는 순서는 영향을받지 않으며 각 Bean의 종속성 및 &lt;code&gt;@DependsOn&lt;/code&gt; 관계에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd16663355804f7f15d9216994923da8f26688c" translate="yes" xml:space="preserve">
          <source>Ask a question. We monitor &lt;a href=&quot;https://stackoverflow.com&quot;&gt;stackoverflow.com&lt;/a&gt; for questions tagged with &lt;a href=&quot;https://stackoverflow.com/tags/spring-boot&quot;&gt;&lt;code&gt;spring-boot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">질문하십시오. &lt;a href=&quot;https://stackoverflow.com/tags/spring-boot&quot;&gt; &lt;code&gt;spring-boot&lt;/code&gt; &lt;/a&gt; 태그가 붙은 질문에 대해 &lt;a href=&quot;https://stackoverflow.com&quot;&gt;stackoverflow.com&lt;/a&gt; 을 모니터링 합니다.</target>
        </trans-unit>
        <trans-unit id="643fd69106187ec86d17effd86b594cfbdba5c54" translate="yes" xml:space="preserve">
          <source>Associates a provider, to attach a well defined semantic to a property, so that a tool can discover the list of potential values based on the project&amp;rsquo;s context.</source>
          <target state="translated">공급자를 연결하여 잘 정의 된 의미 체계를 속성에 연결하여 도구가 프로젝트의 컨텍스트를 기반으로 잠재적 값 목록을 검색 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="3969b8d5b675f04d096df1dcd7ad2328744d54f2" translate="yes" xml:space="preserve">
          <source>Assume a &lt;code&gt;sample.contexts&lt;/code&gt; maps magic &lt;code&gt;String&lt;/code&gt; values to an integer, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;sample.contexts&lt;/code&gt; 가 매직 &lt;code&gt;String&lt;/code&gt; 값을 정수로 매핑 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="dc3bf9bf5e59f661ba531c5af3b4144e15336515" translate="yes" xml:space="preserve">
          <source>Assume that you are using Spring Batch and you rely on the auto-configuration for it. You could define your &lt;code&gt;@SpringBootApplication&lt;/code&gt; as follows:</source>
          <target state="translated">Spring Batch를 사용하고 있으며 자동 구성에 의존한다고 가정하십시오. &lt;code&gt;@SpringBootApplication&lt;/code&gt; 을 다음과 같이 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e63aad1cea867b5113165d97c58098b539e6b72" translate="yes" xml:space="preserve">
          <source>Assuming that you have a Spring Boot application installed in &lt;code&gt;/var/myapp&lt;/code&gt;, to install a Spring Boot application as a &lt;code&gt;systemd&lt;/code&gt; service, create a script named &lt;code&gt;myapp.service&lt;/code&gt; and place it in &lt;code&gt;/etc/systemd/system&lt;/code&gt; directory. The following script offers an example:</source>
          <target state="translated">당신이 봄 부팅 응용 프로그램이 설치되어 있다고 가정 &lt;code&gt;/var/myapp&lt;/code&gt; , A와 같은 봄 부팅 응용 프로그램을 설치하는 &lt;code&gt;systemd&lt;/code&gt; 이라는 스크립트를 생성, 서비스를 &lt;code&gt;myapp.service&lt;/code&gt; 을 과에 배치 &lt;code&gt;/etc/systemd/system&lt;/code&gt; 디렉토리. 다음 스크립트는 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="40776d2a53e1908b72c31a4903419e762af2189c" translate="yes" xml:space="preserve">
          <source>Assuming that you have a Spring Boot application installed in &lt;code&gt;/var/myapp&lt;/code&gt;, to install a Spring Boot application as an &lt;code&gt;init.d&lt;/code&gt; service, create a symlink, as follows:</source>
          <target state="translated">&lt;code&gt;/var/myapp&lt;/code&gt; 에 Spring Boot 애플리케이션이 설치되어 있다고 가정 하고 Spring Boot 애플리케이션을 &lt;code&gt;init.d&lt;/code&gt; 서비스 로 설치하려면 다음과 같이 심볼릭 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="05dbee51e6ccc6b71bb2fff98a699d85e7cd5a5b" translate="yes" xml:space="preserve">
          <source>Assuming that your &lt;code&gt;FancyDataSource&lt;/code&gt; has regular JavaBean properties for the URL, the username, and the pool size, these settings are bound automatically before the &lt;code&gt;DataSource&lt;/code&gt; is made available to other components. The regular &lt;a href=&quot;#howto-initialize-a-database-using-spring-jdbc&quot;&gt;database initialization&lt;/a&gt; also happens (so the relevant sub-set of &lt;code&gt;spring.datasource.*&lt;/code&gt; can still be used with your custom configuration).</source>
          <target state="translated">&lt;code&gt;FancyDataSource&lt;/code&gt; 에 URL, 사용자 이름 및 풀 크기에 대한 일반 JavaBean 속성이 있다고 가정하면 이러한 설정은 다른 구성 요소 에서 &lt;code&gt;DataSource&lt;/code&gt; 를 사용할 수 있기 전에 자동으로 바인딩됩니다 . 일반 &lt;a href=&quot;#howto-initialize-a-database-using-spring-jdbc&quot;&gt;데이터베이스 초기화&lt;/a&gt; 도 발생합니다 (따라서 &lt;code&gt;spring.datasource.*&lt;/code&gt; 의 관련 하위 집합은 사용자 지정 구성과 함께 계속 사용할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="e4ebfd36433c4eb864b24a98968580fbebb2ba41" translate="yes" xml:space="preserve">
          <source>Assuming the above &lt;code&gt;Dockerfile&lt;/code&gt; is in the current directory, your docker image can be built with &lt;code&gt;docker build .&lt;/code&gt;, or optionally specifying the path to your application jar, as shown in the following example:</source>
          <target state="translated">위의 &lt;code&gt;Dockerfile&lt;/code&gt; 이 현재 디렉터리에 있다고 가정하면 &lt;code&gt;docker build .&lt;/code&gt; 하여 docker 이미지를 빌드 할 수 있습니다 . 또는 선택적으로 다음 예제와 같이 애플리케이션 jar의 경로를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="844d277b792a3eaa9177fe91c3705e886041c392" translate="yes" xml:space="preserve">
          <source>Assuming you use Maven, you could rewrite the preceding example as follows:</source>
          <target state="translated">Maven을 사용한다고 가정하면 이전 예제를 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="709b2718984782131f13e19749c380f17b23d43f" translate="yes" xml:space="preserve">
          <source>At least the url should be provided. Information specified in the URL takes precedence over individual properties, i.e. &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;username&lt;/code&gt;, &lt;code&gt;password&lt;/code&gt; and pooling options.</source>
          <target state="translated">최소한 URL을 제공해야합니다. URL에 지정된 정보는 개별 속성 (예 : &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;username&lt;/code&gt; , &lt;code&gt;password&lt;/code&gt; 및 풀링 옵션) 보다 우선 합니다 .</target>
        </trans-unit>
        <trans-unit id="0fbeebb45b7389ad76d6ae3e8f014010d6e824ec" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;boxfuse&lt;/code&gt; creates an image for your application, uploads it, and configures and starts the necessary resources on AWS, resulting in output similar to the following example:</source>
          <target state="translated">이 시점에서 &lt;code&gt;boxfuse&lt;/code&gt; 는 애플리케이션에 대한 이미지를 생성하고 업로드하고 AWS에서 필요한 리소스를 구성 및 시작하여 다음 예제와 유사한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7890b23cf9c7aa6d09e60257495a013e2715a2c2" translate="yes" xml:space="preserve">
          <source>At this point, &lt;code&gt;cf&lt;/code&gt; starts uploading your application, producing output similar to the following example:</source>
          <target state="translated">이 시점에서 &lt;code&gt;cf&lt;/code&gt; 는 애플리케이션 업로드를 시작하여 다음 예제와 유사한 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="17313126c59e0fb6ea0c5c4ace2518f07d7f78b2" translate="yes" xml:space="preserve">
          <source>At this point, you could import the project into an IDE (most modern Java IDEs include built-in support for Maven). For simplicity, we continue to use a plain text editor for this example.</source>
          <target state="translated">이 시점에서 프로젝트를 IDE로 가져올 수 있습니다 (대부분의 최신 Java IDE에는 Maven에 대한 기본 지원이 포함됨). 간단하게하기 위해이 예제에서는 일반 텍스트 편집기를 계속 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b1c3eca885cdcacf79e6b6b0c4eef03601a694c2" translate="yes" xml:space="preserve">
          <source>At this point, your application should work. Since you used the &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; POM, you have a useful &lt;code&gt;run&lt;/code&gt; goal that you can use to start the application. Type &lt;code&gt;mvn spring-boot:run&lt;/code&gt; from the root project directory to start the application. You should see output similar to the following:</source>
          <target state="translated">이 시점에서 애플리케이션이 작동합니다. &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; POM 을 사용했기 때문에 애플리케이션을 시작하는 데 사용할 수 있는 유용한 &lt;code&gt;run&lt;/code&gt; 목표가 있습니다. 입력 &lt;code&gt;mvn spring-boot:run&lt;/code&gt; 응용 프로그램을 시작 루트 프로젝트 디렉토리에서. 다음과 유사한 출력이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8bd28d90f59e9ecb428ffecb287d3a0a056fa5c1" translate="yes" xml:space="preserve">
          <source>Atlas</source>
          <target state="translated">Atlas</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="cb5cc8e2ad78882026ea4054f5bcf86b043d26db" translate="yes" xml:space="preserve">
          <source>Auditing</source>
          <target state="translated">Auditing</target>
        </trans-unit>
        <trans-unit id="f9b7b62d373bae321e7d44e2162d272c94ac42e6" translate="yes" xml:space="preserve">
          <source>Auditing can be enabled by providing a bean of type &lt;code&gt;AuditEventRepository&lt;/code&gt; in your application&amp;rsquo;s configuration. For convenience, Spring Boot offers an &lt;code&gt;InMemoryAuditEventRepository&lt;/code&gt;. &lt;code&gt;InMemoryAuditEventRepository&lt;/code&gt; has limited capabilities and we recommend using it only for development environments. For production environments, consider creating your own alternative &lt;code&gt;AuditEventRepository&lt;/code&gt; implementation.</source>
          <target state="translated">애플리케이션 구성에 &lt;code&gt;AuditEventRepository&lt;/code&gt; 유형의 Bean을 제공하여 감사를 활성화 할 수 있습니다 . 편의를 위해 Spring Boot는 &lt;code&gt;InMemoryAuditEventRepository&lt;/code&gt; 를 제공합니다 . &lt;code&gt;InMemoryAuditEventRepository&lt;/code&gt; 는 기능이 제한되어 있으므로 개발 환경에만 사용하는 것이 좋습니다. 프로덕션 환경의 경우 고유 한 대체 &lt;code&gt;AuditEventRepository&lt;/code&gt; 구현을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f1f703c2a580b439ba7bcd9001266fd4f1ffd911" translate="yes" xml:space="preserve">
          <source>Authentication database name.</source>
          <target state="translated">인증 데이터베이스 이름.</target>
        </trans-unit>
        <trans-unit id="1b98519b654704e688117fd846fa040e98af03ce" translate="yes" xml:space="preserve">
          <source>Auto-completes the available Spring profile names in the project.</source>
          <target state="translated">프로젝트에서 사용 가능한 Spring 프로필 이름을 자동 완성합니다.</target>
        </trans-unit>
        <trans-unit id="04f0491b2e3736119f44abc1db4445bd3be0b4d3" translate="yes" xml:space="preserve">
          <source>Auto-completes the available bean names in the current project. Usually constrained by a base class that is specified by the &lt;code&gt;target&lt;/code&gt; parameter.</source>
          <target state="translated">현재 프로젝트에서 사용 가능한 빈 이름을 자동 완성합니다. 일반적으로 &lt;code&gt;target&lt;/code&gt; 매개 변수에 지정된 기본 클래스에 의해 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="38f0360083ace8333ad44550d14663515eab648a" translate="yes" xml:space="preserve">
          <source>Auto-completes the classes available in the project. Usually constrained by a base class that is specified by the &lt;code&gt;target&lt;/code&gt; parameter.</source>
          <target state="translated">프로젝트에서 사용할 수있는 클래스를 자동 완성합니다. 일반적으로 &lt;code&gt;target&lt;/code&gt; 매개 변수에 지정된 기본 클래스에 의해 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1dd53c82bb57c09c34a9b7f6f876e363ac83e80" translate="yes" xml:space="preserve">
          <source>Auto-completes valid logger names and &lt;a href=&quot;spring-boot-features#boot-features-custom-log-groups&quot;&gt;logger groups&lt;/a&gt;. Typically, package and class names available in the current project can be auto-completed as well as defined groups.</source>
          <target state="translated">유효한 로거 이름 및 &lt;a href=&quot;spring-boot-features#boot-features-custom-log-groups&quot;&gt;로거 그룹을&lt;/a&gt; 자동 완성합니다 . 일반적으로 현재 프로젝트에서 사용 가능한 패키지 및 클래스 이름은 정의 된 그룹뿐 아니라 자동 완성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91b2f0281d4dd5d6b8a07feefd56ee23ce993c51" translate="yes" xml:space="preserve">
          <source>Auto-configuration</source>
          <target state="translated">Auto-configuration</target>
        </trans-unit>
        <trans-unit id="8f6cae0aa17ef6cf6eda1cfa43fb41fe15f37f38" translate="yes" xml:space="preserve">
          <source>Auto-configuration Classes</source>
          <target state="translated">자동 구성 클래스</target>
        </trans-unit>
        <trans-unit id="b190e61a7f3faf0d01388be0365708ac0ba34918" translate="yes" xml:space="preserve">
          <source>Auto-configuration can be associated to a &amp;ldquo;starter&amp;rdquo; that provides the auto-configuration code as well as the typical libraries that you would use with it. We first cover what you need to know to build your own auto-configuration and then we move on to the &lt;a href=&quot;#boot-features-custom-starter&quot;&gt;typical steps required to create a custom starter&lt;/a&gt;.</source>
          <target state="translated">자동 구성은 자동 구성 코드와 함께 사용할 일반적인 라이브러리를 제공하는 &quot;스타터&quot;와 연관 될 수 있습니다. 먼저 자체 자동 구성을 구축하기 위해 알아야 할 &lt;a href=&quot;#boot-features-custom-starter&quot;&gt;사항을 다룬 다음 사용자 지정 스타터를 생성하는 데 필요한 일반적인 단계&lt;/a&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="5539b1811770027eadb24a940943efb020d441db" translate="yes" xml:space="preserve">
          <source>Auto-configuration classes provided by Spring Boot.</source>
          <target state="translated">Spring Boot에서 제공하는 자동 구성 클래스.</target>
        </trans-unit>
        <trans-unit id="2cf7e4905b49f4c98a54f6cf23c4883a12fba02a" translate="yes" xml:space="preserve">
          <source>Auto-configuration classes to exclude.</source>
          <target state="translated">제외 할 자동 구성 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="8a35d27231fd7855b2d522a1288669cee4e7a12f" translate="yes" xml:space="preserve">
          <source>Auto-configuration enables the instrumentation of all available &lt;code&gt;Cache&lt;/code&gt;s on startup with metrics prefixed with &lt;code&gt;cache&lt;/code&gt;. Cache instrumentation is standardized for a basic set of metrics. Additional, cache-specific metrics are also available.</source>
          <target state="translated">자동 구성을 사용하면 시작시 &lt;code&gt;cache&lt;/code&gt; 접두사가 붙은 메트릭을 사용하여 사용 가능한 모든 &lt;code&gt;Cache&lt;/code&gt; 계측 할 수 있습니다 . 캐시 계측은 기본 메트릭 집합에 대해 표준화됩니다. 추가 캐시 관련 메트릭도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb51e64d3f5ccc9a269747ab8001d37cc26dc5b" translate="yes" xml:space="preserve">
          <source>Auto-configuration enables the instrumentation of all available &lt;code&gt;DataSource&lt;/code&gt; objects with metrics prefixed with &lt;code&gt;jdbc.connections&lt;/code&gt;. Data source instrumentation results in gauges representing the currently active, idle, maximum allowed, and minimum allowed connections in the pool.</source>
          <target state="translated">자동 구성을 사용하면 메트릭 접두사가 &lt;code&gt;jdbc.connections&lt;/code&gt; 인 사용 가능한 모든 &lt;code&gt;DataSource&lt;/code&gt; 개체를 계측 할 수 있습니다 . 데이터 소스 계측은 풀에서 현재 활성, 유휴, 최대 허용 및 최소 허용 연결을 나타내는 게이지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b38e8e859492342c603c0430237f2849dc78cf6e" translate="yes" xml:space="preserve">
          <source>Auto-configuration enables the instrumentation of all available Hibernate &lt;code&gt;EntityManagerFactory&lt;/code&gt; instances that have statistics enabled with a metric named &lt;code&gt;hibernate&lt;/code&gt;.</source>
          <target state="translated">자동 구성은 &lt;code&gt;hibernate&lt;/code&gt; 라는 메트릭으로 통계가 활성화 된 모든 사용 가능한 Hibernate &lt;code&gt;EntityManagerFactory&lt;/code&gt; 인스턴스 의 계측을 활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="3443af706912e4a5085661a5113058d2721d3c09" translate="yes" xml:space="preserve">
          <source>Auto-configuration enables the instrumentation of all requests handled by WebFlux controllers and functional handlers.</source>
          <target state="translated">자동 구성을 사용하면 WebFlux 컨트롤러 및 기능 핸들러에서 처리하는 모든 요청을 계측 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a66ca5eab2abe14aa8f1b4e6dec7ba2c47396469" translate="yes" xml:space="preserve">
          <source>Auto-configuration enables the instrumentation of requests handled by Spring MVC. When &lt;code&gt;management.metrics.web.server.request.autotime.enabled&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this instrumentation occurs for all requests. Alternatively, when set to &lt;code&gt;false&lt;/code&gt;, you can enable instrumentation by adding &lt;code&gt;@Timed&lt;/code&gt; to a request-handling method:</source>
          <target state="translated">자동 구성은 Spring MVC가 처리하는 요청의 계측을 가능하게합니다. 때 &lt;code&gt;management.metrics.web.server.request.autotime.enabled&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; ,이 장비는 모든 요청에 대해 발생합니다. 또는 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 요청 처리 메서드에 &lt;code&gt;@Timed&lt;/code&gt; 를 추가하여 계측을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4308803db56fa75a7a8858e1e9f3138c3f8cc76" translate="yes" xml:space="preserve">
          <source>Auto-configuration for Gson is provided. When Gson is on the classpath a &lt;code&gt;Gson&lt;/code&gt; bean is automatically configured. Several &lt;code&gt;spring.gson.*&lt;/code&gt; configuration properties are provided for customizing the configuration. To take more control, one or more &lt;code&gt;GsonBuilderCustomizer&lt;/code&gt; beans can be used.</source>
          <target state="translated">Gson에 대한 자동 구성이 제공됩니다. GSON 클래스 경로에 때 &lt;code&gt;Gson&lt;/code&gt; 콩이 자동으로 구성됩니다. 구성을 사용자 정의하기 위해 몇 가지 &lt;code&gt;spring.gson.*&lt;/code&gt; 구성 속성이 제공됩니다. 더 많은 제어를 위해 하나 이상의 &lt;code&gt;GsonBuilderCustomizer&lt;/code&gt; 빈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef93a40e01bb4cef4f7a467b353075ee1a52a58f" translate="yes" xml:space="preserve">
          <source>Auto-configuration for JSON-B is provided. When the JSON-B API and an implementation are on the classpath a &lt;code&gt;Jsonb&lt;/code&gt; bean will be automatically configured. The preferred JSON-B implementation is Apache Johnzon for which dependency management is provided.</source>
          <target state="translated">JSON-B에 대한 자동 구성이 제공됩니다. JSON-B API와 구현이 클래스 경로에 &lt;code&gt;Jsonb&lt;/code&gt; 빈이 자동으로 구성됩니다. 선호되는 JSON-B 구현은 종속성 관리가 제공되는 Apache Johnzon입니다.</target>
        </trans-unit>
        <trans-unit id="bd283dba4c4e0a05ccde7444adf542613f03d3a9" translate="yes" xml:space="preserve">
          <source>Auto-configuration for Jackson is provided and Jackson is part of &lt;code&gt;spring-boot-starter-json&lt;/code&gt;. When Jackson is on the classpath an &lt;code&gt;ObjectMapper&lt;/code&gt; bean is automatically configured. Several configuration properties are provided for &lt;a href=&quot;howto#howto-customize-the-jackson-objectmapper&quot;&gt;customizing the configuration of the &lt;code&gt;ObjectMapper&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Jackson에 대한 자동 구성이 제공되고 Jackson은 &lt;code&gt;spring-boot-starter-json&lt;/code&gt; 의 일부입니다 . Jackson이 클래스 경로에 있으면 &lt;code&gt;ObjectMapper&lt;/code&gt; 빈이 자동으로 구성됩니다. &lt;a href=&quot;howto#howto-customize-the-jackson-objectmapper&quot;&gt; &lt;code&gt;ObjectMapper&lt;/code&gt; &lt;/a&gt; 의 구성 을 사용자 정의하기 위해 여러 구성 특성이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f4716e779b53a7ed4fd6d2382229ea49564f68f" translate="yes" xml:space="preserve">
          <source>Auto-configuration is designed to work well with &amp;ldquo;Starters&amp;rdquo;, but the two concepts are not directly tied. You are free to pick and choose jar dependencies outside of the starters. Spring Boot still does its best to auto-configure your application.</source>
          <target state="translated">자동 구성은 &quot;스타터&quot;와 잘 작동하도록 설계되었지만 두 개념이 직접적으로 연결되어 있지는 않습니다. 스타터 외부에서 jar 종속성을 자유롭게 선택하고 선택할 수 있습니다. Spring Boot는 여전히 애플리케이션을 자동 구성하기 위해 최선을 다합니다.</target>
        </trans-unit>
        <trans-unit id="1123f4cb18a2321d13bf4a403abb300fd78820f7" translate="yes" xml:space="preserve">
          <source>Auto-configuration is non-invasive. At any point, you can start to define your own configuration to replace specific parts of the auto-configuration. For example, if you add your own &lt;code&gt;DataSource&lt;/code&gt; bean, the default embedded database support backs away.</source>
          <target state="translated">자동 구성은 비 침습적입니다. 언제든지 자동 구성의 특정 부분을 대체하기 위해 고유 한 구성을 정의 할 수 있습니다. 예를 들어, 고유 한 &lt;code&gt;DataSource&lt;/code&gt; bean 을 추가 하면 기본 임베디드 데이터베이스 지원이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="23b10b2f58a518936c537f7af1a9896d6231e509" translate="yes" xml:space="preserve">
          <source>Auto-configuration will enable the instrumentation of all available RabbitMQ connection factories with a metric named &lt;code&gt;rabbitmq&lt;/code&gt;.</source>
          <target state="translated">자동 구성은 &lt;code&gt;rabbitmq&lt;/code&gt; 라는 메트릭을 사용하여 사용 가능한 모든 RabbitMQ 연결 팩토리의 계측을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="d3d150131dc5d9e9735675268e707e3d1ae71432" translate="yes" xml:space="preserve">
          <source>Auto-configuration will register a &lt;code&gt;MicrometerConsumerListener&lt;/code&gt; and &lt;code&gt;MicrometerProducerListener&lt;/code&gt; for the auto-configured consumer factory and producer factory respectively. For more details refer to &lt;a href=&quot;https://docs.spring.io/spring-kafka/docs/2.6.3/reference/html/#micrometer-native&quot;&gt;Micrometer Native Metrics&lt;/a&gt; section of the Spring Kafka documentation.</source>
          <target state="translated">자동 구성은 자동 구성된 소비자 팩토리와 생산자 팩토리에 대해 각각 &lt;code&gt;MicrometerConsumerListener&lt;/code&gt; 및 &lt;code&gt;MicrometerProducerListener&lt;/code&gt; 를 등록합니다 . 자세한 내용 은 Spring Kafka 문서의 &lt;a href=&quot;https://docs.spring.io/spring-kafka/docs/2.6.3/reference/html/#micrometer-native&quot;&gt;Micrometer Native Metrics&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a912098a469bbdd9c294c8b66335b5dc996ccf23" translate="yes" xml:space="preserve">
          <source>Auto-configurations must be loaded that way &lt;em&gt;only&lt;/em&gt;. Make sure that they are defined in a specific package space and that they are never the target of component scanning. Furthermore, auto-configuration classes should not enable component scanning to find additional components. Specific &lt;code&gt;@Import&lt;/code&gt;s should be used instead.</source>
          <target state="translated">자동 구성은 이러한 방식으로 &lt;em&gt;만&lt;/em&gt; 로드되어야합니다 . 특정 패키지 공간에 정의되어 있고 구성 요소 스캔의 대상이 아닌지 확인하십시오. 또한 자동 구성 클래스는 추가 구성 요소를 찾기 위해 구성 요소 스캔을 활성화해서는 안됩니다. 대신 특정 &lt;code&gt;@Import&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="815b3348d4d1c55b94ea5240e36bd1add8584dc6" translate="yes" xml:space="preserve">
          <source>Auto-configured Spring REST Docs Tests with Mock MVC</source>
          <target state="translated">Mock MVC로 자동 구성된 Spring REST 문서 테스트</target>
        </trans-unit>
        <trans-unit id="1664d55deb8edeb0532e6baeccbbbc3f314762b1" translate="yes" xml:space="preserve">
          <source>Auto-configured Spring REST Docs Tests with REST Assured</source>
          <target state="translated">REST Assured로 자동 구성된 Spring REST 문서 테스트</target>
        </trans-unit>
        <trans-unit id="56c5d119c3d49977afb25b51e208d75148adfe6b" translate="yes" xml:space="preserve">
          <source>Auto-configured Spring REST Docs Tests with WebTestClient</source>
          <target state="translated">WebTestClient로 자동 구성된 Spring REST 문서 테스트</target>
        </trans-unit>
        <trans-unit id="eecc946b442c9e68e6477557a8c25f7e1c0f9383" translate="yes" xml:space="preserve">
          <source>Automatic Restart</source>
          <target state="translated">자동 재시작</target>
        </trans-unit>
        <trans-unit id="22bbaadf03551679ca9edbc8cf7a5eac294a5d81" translate="yes" xml:space="preserve">
          <source>Automatic registration of &lt;code&gt;Converter&lt;/code&gt;, &lt;code&gt;GenericConverter&lt;/code&gt;, and &lt;code&gt;Formatter&lt;/code&gt; beans.</source>
          <target state="translated">&lt;code&gt;Converter&lt;/code&gt; , &lt;code&gt;GenericConverter&lt;/code&gt; 및 &lt;code&gt;Formatter&lt;/code&gt; Bean 의 자동 등록 .</target>
        </trans-unit>
        <trans-unit id="85d6004d9bbe955ef9c54d4939a6ac9efdea9a43" translate="yes" xml:space="preserve">
          <source>Automatic registration of &lt;code&gt;MessageCodesResolver&lt;/code&gt; (covered &lt;a href=&quot;#boot-features-spring-message-codes&quot;&gt;later in this document&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;MessageCodesResolver&lt;/code&gt; 의 자동 등록 ( &lt;a href=&quot;#boot-features-spring-message-codes&quot;&gt;이 문서의 뒷부분에서&lt;/a&gt; 다룹니다 ).</target>
        </trans-unit>
        <trans-unit id="2de1ec1461f7a0d5673d4f9d2ebcaac007982ea5" translate="yes" xml:space="preserve">
          <source>Automatic restart works very well when used with LiveReload. &lt;a href=&quot;#using-boot-devtools-livereload&quot;&gt;See the LiveReload section&lt;/a&gt; for details. If you use JRebel, automatic restarts are disabled in favor of dynamic class reloading. Other devtools features (such as LiveReload and property overrides) can still be used.</source>
          <target state="translated">자동 재시작은 LiveReload와 함께 사용할 때 매우 잘 작동합니다. &lt;a href=&quot;#using-boot-devtools-livereload&quot;&gt;자세한 내용은 LiveReload 섹션&lt;/a&gt; 을 참조하십시오. JRebel을 사용하는 경우 동적 클래스 다시로드를 위해 자동 다시 시작이 비활성화됩니다. 다른 devtools 기능 (예 : LiveReload 및 속성 재정의)은 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08e93f6c8aa0733a400ee6040da8dc58dbb3c2c4" translate="yes" xml:space="preserve">
          <source>Automatic use of a &lt;code&gt;ConfigurableWebBindingInitializer&lt;/code&gt; bean (covered &lt;a href=&quot;#boot-features-spring-mvc-web-binding-initializer&quot;&gt;later in this document&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;ConfigurableWebBindingInitializer&lt;/code&gt; 빈 의 자동 사용 ( &lt;a href=&quot;#boot-features-spring-mvc-web-binding-initializer&quot;&gt;이 문서의 뒷부분에서&lt;/a&gt; 다룹니다 ).</target>
        </trans-unit>
        <trans-unit id="a3b7dd559ad88d4ee8494711c8cce5b3e4c390a3" translate="yes" xml:space="preserve">
          <source>Automatically create views and indexes. Use the meta-data provided by &quot;@ViewIndexed&quot;, &quot;@N1qlPrimaryIndexed&quot; and &quot;@N1qlSecondaryIndexed&quot;.</source>
          <target state="translated">뷰와 인덱스를 자동으로 생성합니다. &quot;@ViewIndexed&quot;, &quot;@ N1qlPrimaryIndexed&quot;및 &quot;@ N1qlSecondaryIndexed&quot;에서 제공하는 메타 데이터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8488641ae812e28320669b6ea415880241c1ff53" translate="yes" xml:space="preserve">
          <source>Awesome Kotlin</source>
          <target state="translated">멋진 Kotlin</target>
        </trans-unit>
        <trans-unit id="5f89848735ad6e2fdd8ba29d716b1f47ffa2a9ea" translate="yes" xml:space="preserve">
          <source>Banner file encoding.</source>
          <target state="translated">배너 파일 ​​인코딩.</target>
        </trans-unit>
        <trans-unit id="31782cae8097039ea1b403183cfa7a0a88273965" translate="yes" xml:space="preserve">
          <source>Banner image file location (jpg or png can also be used).</source>
          <target state="translated">배너 이미지 파일 위치 (jpg 또는 png도 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="1c26340dde7bf356e9b658625c2258bf6f043fa8" translate="yes" xml:space="preserve">
          <source>Banner text resource location.</source>
          <target state="translated">배너 텍스트 리소스 위치.</target>
        </trans-unit>
        <trans-unit id="3945491933dfbbcd2009ff0bf055a14877d81be7" translate="yes" xml:space="preserve">
          <source>Base URL for the Pushgateway.</source>
          <target state="translated">Pushgateway의 기본 URL입니다.</target>
        </trans-unit>
        <trans-unit id="c5350caa8e4529c1cdbf89fd3e81fc6c65491cbe" translate="yes" xml:space="preserve">
          <source>Base path for Web endpoints. Relative to the servlet context path (server.servlet.context-path) or WebFlux base path (spring.webflux.base-path) when the management server is sharing the main server port. Relative to the management server base path (management.server.base-path) when a separate management server port (management.server.port) is configured.</source>
          <target state="translated">웹 엔드 포인트의 기본 경로. 관리 서버가 주 서버 포트를 공유 할 때 서블릿 컨텍스트 경로 (server.servlet.context-path) 또는 WebFlux 기본 경로 (spring.webflux.base-path)에 상대적입니다. 별도의 관리 서버 포트 (management.server.port)가 구성된 경우 관리 서버 기본 경로 (management.server.base-path)를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="e3698f62ddabf26cf11c6881cb30681c29ce28a1" translate="yes" xml:space="preserve">
          <source>Base path for all web handlers.</source>
          <target state="translated">모든 웹 핸들러의 기본 경로입니다.</target>
        </trans-unit>
        <trans-unit id="a489762e669575a11144614aaf3fc0d67a035cd0" translate="yes" xml:space="preserve">
          <source>Base path to be used by Spring Data REST to expose repository resources.</source>
          <target state="translated">저장소 리소스를 노출하기 위해 SpringData REST에서 사용할 기본 경로입니다.</target>
        </trans-unit>
        <trans-unit id="fe3a2c74cdef708c63fafd6e59b6fb1cb9131590" translate="yes" xml:space="preserve">
          <source>Base suffix from which all operations should originate.</source>
          <target state="translated">모든 작업이 시작되어야하는 기본 접미사입니다.</target>
        </trans-unit>
        <trans-unit id="275e347ec4e370f684d3ffb9ed9dec290ee42bcd" translate="yes" xml:space="preserve">
          <source>Base time unit used to report durations.</source>
          <target state="translated">기간을보고하는 데 사용되는 기본 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="741f7eccdfc7d43f516af01e3b5d464eee56323f" translate="yes" xml:space="preserve">
          <source>Base time unit used to report rates.</source>
          <target state="translated">요금을보고하는 데 사용되는 기본 시간 단위입니다.</target>
        </trans-unit>
        <trans-unit id="c5352d8272425394a73a72c6d262d35bc196a742" translate="yes" xml:space="preserve">
          <source>Batch size, expressed as the number of physical messages, to be used by the container.</source>
          <target state="translated">컨테이너에서 사용할 배치 크기 (물리적 메시지 수로 표시됨).</target>
        </trans-unit>
        <trans-unit id="27c80edec7c4415d2f457ff7d0ad0ec904588cef" translate="yes" xml:space="preserve">
          <source>Be opinionated out of the box but get out of the way quickly as requirements start to diverge from the defaults.</source>
          <target state="translated">틀에서 벗어난 의견을 가지고 있지만 요구 사항이 기본값에서 벗어나기 시작하면 신속하게 벗어나십시오.</target>
        </trans-unit>
        <trans-unit id="2df9d75a4eab753b0623b5046da3e404ca0c006e" translate="yes" xml:space="preserve">
          <source>Bean Conditions</source>
          <target state="translated">콩 상태</target>
        </trans-unit>
        <trans-unit id="8d95aa116cc038cf04f6da968e2c6e5c65554c59" translate="yes" xml:space="preserve">
          <source>Beans and Dependency Injection</source>
          <target state="translated">빈과 의존성 주입</target>
        </trans-unit>
        <trans-unit id="b4bec0d62ea9fcf0ed7f2ff089591207ffb43431" translate="yes" xml:space="preserve">
          <source>Beans of the following types are automatically picked up and associated with the &lt;code&gt;Scheduler&lt;/code&gt;:</source>
          <target state="translated">다음 유형의 Bean이 자동으로 선택되고 &lt;code&gt;Scheduler&lt;/code&gt; 와 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="3a54f34126f8e27362a3f102bc2129909b281b11" translate="yes" xml:space="preserve">
          <source>Because Spring WebFlux does not strictly depend on the Servlet API and applications are deployed by default on an embedded Reactor Netty server, War deployment is not supported for WebFlux applications.</source>
          <target state="translated">Spring WebFlux는 Servlet API에 엄격하게 의존하지 않고 애플리케이션이 기본적으로 내장 된 Reactor Netty 서버에 배치되기 때문에 WebFlux 애플리케이션에 대해서는 War 배치가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="773efa42ab5e06d62545fa905da3d611b61f70c4" translate="yes" xml:space="preserve">
          <source>Because endpoints are technology agnostic, only simple types can be specified in the method signature. In particular declaring a single parameter with a &lt;code&gt;CustomData&lt;/code&gt; type defining a &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; properties is not supported.</source>
          <target state="translated">끝점은 기술에 구애받지 않기 때문에 메서드 서명에는 단순한 유형 만 지정할 수 있습니다. 특히 &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;counter&lt;/code&gt; 속성을 정의하는 &lt;code&gt;CustomData&lt;/code&gt; 유형 으로 단일 매개 변수를 선언하는 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e839a035e132a47439a8b6103f66d12cd171fe40" translate="yes" xml:space="preserve">
          <source>Because the remote client is using the same classpath as the real application it can directly read application properties. This is how the &lt;code&gt;spring.devtools.remote.secret&lt;/code&gt; property is read and passed to the server for authentication.</source>
          <target state="translated">원격 클라이언트는 실제 애플리케이션과 동일한 클래스 경로를 사용하기 때문에 애플리케이션 속성을 직접 읽을 수 있습니다. 이것이 &lt;code&gt;spring.devtools.remote.secret&lt;/code&gt; 속성을 읽고 인증을 위해 서버에 전달 하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="3f913bf62b3f985edea248e4fceb166b77bad345" translate="yes" xml:space="preserve">
          <source>Because the standard &lt;code&gt;logback.xml&lt;/code&gt; configuration file is loaded too early, you cannot use extensions in it. You need to either use &lt;code&gt;logback-spring.xml&lt;/code&gt; or define a &lt;code&gt;logging.config&lt;/code&gt; property.</source>
          <target state="translated">표준 &lt;code&gt;logback.xml&lt;/code&gt; 구성 파일이 너무 일찍로드 되기 때문에 확장자를 사용할 수 없습니다. 당신도 사용 할 필요가 &lt;code&gt;logback-spring.xml&lt;/code&gt; 또는 정의 &lt;code&gt;logging.config&lt;/code&gt; 의 속성을.</target>
        </trans-unit>
        <trans-unit id="d869a29d72c274dcedac7cf41432fc4fb53aaa4c" translate="yes" xml:space="preserve">
          <source>Because this class is the source configuration for the test, any slice test actually tries to start Spring Batch, which is definitely not what you want to do. A recommended approach is to move that area-specific configuration to a separate &lt;code&gt;@Configuration&lt;/code&gt; class at the same level as your application, as shown in the following example:</source>
          <target state="translated">이 클래스는 테스트의 소스 구성이기 때문에 모든 슬라이스 테스트는 실제로 Spring Batch를 시작하려고 시도합니다. 이는 확실히 원하는 작업이 아닙니다. 권장되는 접근 방식은 다음 예제와 같이 해당 영역 별 구성을 애플리케이션과 동일한 수준 의 별도 &lt;code&gt;@Configuration&lt;/code&gt; 클래스 로 이동하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e4676e1b6bd6e243e47d3d0415abf19e2d6704d1" translate="yes" xml:space="preserve">
          <source>Because you need more information about web requests while developing Spring MVC and Spring WebFlux applications, developer tools will enable &lt;code&gt;DEBUG&lt;/code&gt; logging for the &lt;code&gt;web&lt;/code&gt; logging group. This will give you information about the incoming request, which handler is processing it, the response outcome, etc. If you wish to log all request details (including potentially sensitive information), you can turn on the &lt;code&gt;spring.mvc.log-request-details&lt;/code&gt; or &lt;code&gt;spring.codec.log-request-details&lt;/code&gt; configuration properties.</source>
          <target state="translated">Spring MVC 및 Spring WebFlux 애플리케이션을 개발하는 동안 웹 요청에 대한 더 많은 정보가 필요하기 때문에 개발자 도구는 &lt;code&gt;web&lt;/code&gt; 로깅 그룹에 대한 &lt;code&gt;DEBUG&lt;/code&gt; 로깅을 활성화 합니다. 이렇게하면 수신 요청, 처리중인 처리기, 응답 결과 등에 대한 정보가 제공됩니다. 모든 요청 세부 정보 (잠재적으로 민감한 정보 포함)를 기록하려면 &lt;code&gt;spring.mvc.log-request-details&lt;/code&gt; 켤 수 있습니다. details 또는 &lt;code&gt;spring.codec.log-request-details&lt;/code&gt; 구성 속성.</target>
        </trans-unit>
        <trans-unit id="fdd1cdc169c9bb710d93eebea94606850398223d" translate="yes" xml:space="preserve">
          <source>Because your custom configuration chooses to go with Hikari, &lt;code&gt;app.datasource.type&lt;/code&gt; has no effect. In practice, the builder is initialized with whatever value you might set there and then overridden by the call to &lt;code&gt;.type()&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 구성이 Hikari와 함께 사용하도록 선택하기 때문에 &lt;code&gt;app.datasource.type&lt;/code&gt; 은 효과가 없습니다. 실제로 빌더는 설정 한 값으로 초기화 된 다음 &lt;code&gt;.type()&lt;/code&gt; 에 대한 호출로 재정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="c160995800039e207e14bbab812a8e3cc1b19347" translate="yes" xml:space="preserve">
          <source>Before setting the &lt;code&gt;management.endpoints.web.exposure.include&lt;/code&gt;, ensure that the exposed actuators do not contain sensitive information and/or are secured by placing them behind a firewall or by something like Spring Security.</source>
          <target state="translated">&lt;code&gt;management.endpoints.web.exposure.include&lt;/code&gt; 를 설정하기 전에 노출 된 액추에이터에 민감한 정보가 포함되지 않았는지 확인하고 / 또는 방화벽 뒤에 배치하거나 Spring Security와 같은 방식으로 보안을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8dea278918cd0054b40e6acb1f38504cf70a9ae" translate="yes" xml:space="preserve">
          <source>Before we begin, open a terminal and run the following commands to ensure that you have valid versions of Java and Maven installed:</source>
          <target state="translated">시작하기 전에 터미널을 열고 다음 명령을 실행하여 유효한 Java 및 Maven 버전이 설치되어 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3708040638bf55732ce85de9a753af5edf425f84" translate="yes" xml:space="preserve">
          <source>Binding Maps</source>
          <target state="translated">바인딩 맵</target>
        </trans-unit>
        <trans-unit id="e1bdbd17575e0bcf4f565426b29f654d8e2b30a3" translate="yes" xml:space="preserve">
          <source>Binding from Environment Variables</source>
          <target state="translated">환경 변수에서 바인딩</target>
        </trans-unit>
        <trans-unit id="d57bea00c6b65d2363ee3a768d1e1575b5e91024" translate="yes" xml:space="preserve">
          <source>Bit depth to use for ANSI colors. Supported values are 4 (16 color) or 8 (256 color).</source>
          <target state="translated">ANSI 색상에 사용할 비트 심도입니다. 지원되는 값은 4 (16 색) 또는 8 (256 색)입니다.</target>
        </trans-unit>
        <trans-unit id="66a4c027317badac28701ceed7c491c8a230c1b6" translate="yes" xml:space="preserve">
          <source>Blocking period before throwing an exception if the pool is still full.</source>
          <target state="translated">풀이 여전히 꽉 찬 경우 예외가 발생하기 전에 차단 기간입니다.</target>
        </trans-unit>
        <trans-unit id="5e62711deb29edb2eb8b4f61155e1ac089cd4f42" translate="yes" xml:space="preserve">
          <source>Boolean flag to indicate that all properties should be added to System properties. It defaults to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">모든 속성이 시스템 속성에 추가되어야 함을 나타내는 부울 플래그입니다. 기본값은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40108501819953ced874e7a2b46c9dd3f8ffa3f8" translate="yes" xml:space="preserve">
          <source>Boot Applications</source>
          <target state="translated">부팅 응용 프로그램</target>
        </trans-unit>
        <trans-unit id="f083d4d09557d56f0d3057d552444fda0ae4d189" translate="yes" xml:space="preserve">
          <source>Bootstrap mode for JPA repositories.</source>
          <target state="translated">JPA 저장 소용 부트 스트랩 모드.</target>
        </trans-unit>
        <trans-unit id="fdfbbe239ddad582b7d345b2f7000e63f1e0ba80" translate="yes" xml:space="preserve">
          <source>Both Maven and Gradle allow generating a &lt;code&gt;git.properties&lt;/code&gt; file containing information about the state of your &lt;code&gt;git&lt;/code&gt; source code repository when the project was built.</source>
          <target state="translated">Maven과 Gradle 모두 프로젝트가 빌드되었을 때 &lt;code&gt;git&lt;/code&gt; 소스 코드 저장소 의 상태에 대한 정보가 포함 된 &lt;code&gt;git.properties&lt;/code&gt; 파일을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="588de1825ee7110dafdffe4073e8da137cf9ef4b" translate="yes" xml:space="preserve">
          <source>Both a &lt;code&gt;TaskExecutorBuilder&lt;/code&gt; bean and a &lt;code&gt;TaskSchedulerBuilder&lt;/code&gt; bean are made available in the context if a custom executor or scheduler needs to be created.</source>
          <target state="translated">둘 다를 &lt;code&gt;TaskExecutorBuilder&lt;/code&gt; 의 콩과 &lt;code&gt;TaskSchedulerBuilder&lt;/code&gt; 의 사용자 정의 실행기 또는 스케줄러의 요구가 생성 될 경우 빈은 상황에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="067bc2e07fad5ae6f99a87357c0915d733c1fa87" translate="yes" xml:space="preserve">
          <source>Both data sources are also bound for advanced customizations. For instance, you could configure them as follows:</source>
          <target state="translated">두 데이터 원본 모두 고급 사용자 지정을 위해 바인딩됩니다. 예를 들어 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eabfd68ad72d6c19ab21554b8abfee2248d04ce2" translate="yes" xml:space="preserve">
          <source>Both the Maven plugin and the Gradle plugin allow generating build information containing the coordinates, name, and version of the project. The plugins can also be configured to add additional properties through configuration. When such a file is present, Spring Boot auto-configures a &lt;code&gt;BuildProperties&lt;/code&gt; bean.</source>
          <target state="translated">Maven 플러그인과 Gradle 플러그인 모두 프로젝트의 좌표, 이름 및 버전을 포함하는 빌드 정보를 생성 할 수 있습니다. 구성을 통해 추가 속성을 추가하도록 플러그인을 구성 할 수도 있습니다. 이러한 파일이 있으면 Spring Boot는 &lt;code&gt;BuildProperties&lt;/code&gt; 빈을 자동 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="23f0b4d7a03c05a4090ef2684d8e1ce2f4b2e373" translate="yes" xml:space="preserve">
          <source>Browse for the &lt;code&gt;my-app&lt;/code&gt; project.</source>
          <target state="translated">을 찾아 &lt;code&gt;my-app&lt;/code&gt; 프로젝트.</target>
        </trans-unit>
        <trans-unit id="5e4bada1d5b9e2b2808ddcb4ffe26da9d9969b1c" translate="yes" xml:space="preserve">
          <source>Bucket connect timeout.</source>
          <target state="translated">버킷 연결 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="06b1a48833c9047bfbe82074654b5b9ae8b4ac7a" translate="yes" xml:space="preserve">
          <source>Bucket disconnect timeout.</source>
          <target state="translated">버킷 연결 해제 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="69b54f866ff4d2203674f78f15ff24d1a670a0fb" translate="yes" xml:space="preserve">
          <source>Build Systems, Structuring Your Code, Configuration, Spring Beans and Dependency Injection, DevTools, and more.</source>
          <target state="translated">시스템 구축, 코드 구조화, 구성, Spring Bean 및 종속성 주입, DevTools 등.</target>
        </trans-unit>
        <trans-unit id="df8a913bb9a1136b0819c59f5810ead7a2c433a2" translate="yes" xml:space="preserve">
          <source>Build Tool</source>
          <target state="translated">빌드 도구</target>
        </trans-unit>
        <trans-unit id="12cdf6031fb89f015ada923a4f38051c6746bd38" translate="yes" xml:space="preserve">
          <source>Build Tool Plugins</source>
          <target state="translated">빌드 도구 플러그인</target>
        </trans-unit>
        <trans-unit id="2d0e5800bcfce36746ddd3e7ff011132a5d3f6d9" translate="yes" xml:space="preserve">
          <source>Build plugins automatically move the &lt;code&gt;Main-Class&lt;/code&gt; attribute to &lt;code&gt;Start-Class&lt;/code&gt; when the fat jar is built. If you use that, specify the name of the class to launch by using the &lt;code&gt;Main-Class&lt;/code&gt; attribute and leaving out &lt;code&gt;Start-Class&lt;/code&gt;.</source>
          <target state="translated">빌드 플러그인 은 fat jar가 빌드 될 때 &lt;code&gt;Main-Class&lt;/code&gt; 속성을 &lt;code&gt;Start-Class&lt;/code&gt; 로 자동 이동합니다 . 이를 사용하는 경우 &lt;code&gt;Main-Class&lt;/code&gt; 속성을 사용하고 &lt;code&gt;Start-Class&lt;/code&gt; 는 제외 하여 시작할 클래스 이름을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ba7b78f8c321b3ac2f6a84ccc06f6ecc3c907a6" translate="yes" xml:space="preserve">
          <source>Build tool plugins</source>
          <target state="translated">빌드 도구 플러그인</target>
        </trans-unit>
        <trans-unit id="cc815236eef110c573e3d32cdeaf87f9843fb554" translate="yes" xml:space="preserve">
          <source>By Extending Configuration</source>
          <target state="translated">구성 확장</target>
        </trans-unit>
        <trans-unit id="9b6dcf01b5c52f05e10c98247737117b92361a6a" translate="yes" xml:space="preserve">
          <source>By default an Elastic Beanstalk environment is load balanced. The load balancer has a significant cost. To avoid that cost, set the environment type to &amp;ldquo;Single instance&amp;rdquo;, as described in &lt;a href=&quot;https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity&quot;&gt;the Amazon documentation&lt;/a&gt;. You can also create single instance environments by using the CLI and the following command:</source>
          <target state="translated">기본적으로 Elastic Beanstalk 환경은로드 밸런싱됩니다. 로드 밸런서에는 상당한 비용이 있습니다. 이러한 비용을 방지하려면 &lt;a href=&quot;https://docs.aws.amazon.com/elasticbeanstalk/latest/dg/environments-create-wizard.html#environments-create-wizard-capacity&quot;&gt;Amazon 설명서에&lt;/a&gt; 설명 된대로 환경 유형을 &quot;단일 인스턴스&quot;로 설정하십시오 . CLI 및 다음 명령을 사용하여 단일 인스턴스 환경을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f922cb00664a3de0a688cf163ffc59c07e4a16d" translate="yes" xml:space="preserve">
          <source>By default groups will inherit the same &lt;code&gt;StatusAggregator&lt;/code&gt; and &lt;code&gt;HttpCodeStatusMapper&lt;/code&gt; settings as the system health, however, these can also be defined on a per-group basis. It&amp;rsquo;s also possible to override the &lt;code&gt;show-details&lt;/code&gt; and &lt;code&gt;roles&lt;/code&gt; properties if required:</source>
          <target state="translated">기본적으로 그룹은 시스템 상태 와 동일한 &lt;code&gt;StatusAggregator&lt;/code&gt; 및 &lt;code&gt;HttpCodeStatusMapper&lt;/code&gt; 설정을 상속 하지만 이러한 설정은 그룹별로 정의 할 수도 있습니다. 필요한 경우 &lt;code&gt;show-details&lt;/code&gt; 및 &lt;code&gt;roles&lt;/code&gt; 속성 을 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e8eac4c822862df3e148505c7ec4cb4746eecdb" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;@SpringBootTest&lt;/code&gt; does not start the server. If you have web endpoints that you want to test against this mock environment, you can additionally configure &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#spring-mvc-test-framework&quot;&gt;&lt;code&gt;MockMvc&lt;/code&gt;&lt;/a&gt; as shown in the following example:</source>
          <target state="translated">기본적으로 &lt;code&gt;@SpringBootTest&lt;/code&gt; 는 서버를 시작하지 않습니다. 이 모의 환경에 대해 테스트하려는 웹 엔드 포인트가 있는 경우 다음 예제와 같이 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#spring-mvc-test-framework&quot;&gt; &lt;code&gt;MockMvc&lt;/code&gt; &lt;/a&gt; 를 추가로 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab6c358cf807c790b878b809f245ac4cca6268d4" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;@SpringBootTest&lt;/code&gt; will not start a server. You can use the &lt;code&gt;webEnvironment&lt;/code&gt; attribute of &lt;code&gt;@SpringBootTest&lt;/code&gt; to further refine how your tests run:</source>
          <target state="translated">기본적으로 &lt;code&gt;@SpringBootTest&lt;/code&gt; 는 서버를 시작하지 않습니다. 당신은 사용할 수 &lt;code&gt;webEnvironment&lt;/code&gt; 의 의 속성 &lt;code&gt;@SpringBootTest&lt;/code&gt; 을 하여 테스트를 실행하는 방법을 더 구체화 :</target>
        </trans-unit>
        <trans-unit id="00fcb36f29ef5faadac143849aecf9dd7e93011d" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;INFO&lt;/code&gt; logging messages are shown, including some relevant startup details, such as the user that launched the application. If you need a log level other than &lt;code&gt;INFO&lt;/code&gt;, you can set it, as described in &lt;a href=&quot;#boot-features-custom-log-levels&quot;&gt;Log Levels&lt;/a&gt;. The application version is determined using the implementation version from the main application class&amp;rsquo;s package. Startup information logging can be turned off by setting &lt;code&gt;spring.main.log-startup-info&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This will also turn off logging of the application&amp;rsquo;s active profiles.</source>
          <target state="translated">기본적으로 응용 프로그램을 시작한 사용자와 같은 관련 시작 세부 정보를 포함하여 &lt;code&gt;INFO&lt;/code&gt; 로깅 메시지가 표시됩니다. &lt;code&gt;INFO&lt;/code&gt; 이외의 로그 수준이 필요한 경우 로그 수준에 설명 된대로 설정할 &lt;a href=&quot;#boot-features-custom-log-levels&quot;&gt;수&lt;/a&gt; 있습니다. 애플리케이션 버전은 기본 애플리케이션 클래스의 패키지에서 구현 버전을 사용하여 결정됩니다. &lt;code&gt;spring.main.log-startup-info&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 시작 정보 로깅을 끌 수 있습니다 . 이렇게하면 응용 프로그램의 활성 프로필 로깅도 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="43e3e0f96a82dbf052d84c5dc658a5a620c0a3e9" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;SpringApplication&lt;/code&gt; converts any command line option arguments (that is, arguments starting with &lt;code&gt;--&lt;/code&gt;, such as &lt;code&gt;--server.port=9000&lt;/code&gt;) to a &lt;code&gt;property&lt;/code&gt; and adds them to the Spring &lt;code&gt;Environment&lt;/code&gt;. As mentioned previously, command line properties always take precedence over file based property sources.</source>
          <target state="translated">기본적으로 &lt;code&gt;SpringApplication&lt;/code&gt; 은 모든 명령 줄 옵션 인수 (즉, &lt;code&gt;--server.port=9000&lt;/code&gt; 과 같이 &lt;code&gt;--&lt;/code&gt; 시작하는 인수 )를 &lt;code&gt;property&lt;/code&gt; 하고이를 Spring &lt;code&gt;Environment&lt;/code&gt; 추가합니다 . 앞에서 언급했듯이 명령 줄 속성은 항상 파일 기반 속성 소스보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="85e0e21fb8bfacddbcfb6691acd122bfbd9ab232" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;WebServiceTemplateBuilder&lt;/code&gt; detects a suitable HTTP-based &lt;code&gt;WebServiceMessageSender&lt;/code&gt; using the available HTTP client libraries on the classpath. You can also customize read and connection timeouts as follows:</source>
          <target state="translated">기본적으로 &lt;code&gt;WebServiceTemplateBuilder&lt;/code&gt; 는 클래스 경로에서 사용 가능한 HTTP 클라이언트 라이브러리를 사용하여 적절한 HTTP 기반 &lt;code&gt;WebServiceMessageSender&lt;/code&gt; 를 감지합니다 . 다음과 같이 읽기 및 연결 시간 제한을 사용자 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a0d7a20d5aa4d6a06b7126d8b5d51b8a93ea40b" translate="yes" xml:space="preserve">
          <source>By default, ActiveMQ creates a destination if it does not yet exist so that destinations are resolved against their provided names.</source>
          <target state="translated">기본적으로 ActiveMQ는 대상이 아직 존재하지 않는 경우 대상을 생성하여 제공된 이름에 대해 대상을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5d8a23b04f3d08e8f3efef5b6143d7efe1acc806" translate="yes" xml:space="preserve">
          <source>By default, Atomikos transaction logs are written to a &lt;code&gt;transaction-logs&lt;/code&gt; directory in your application&amp;rsquo;s home directory (the directory in which your application jar file resides). You can customize the location of this directory by setting a &lt;code&gt;spring.jta.log-dir&lt;/code&gt; property in your &lt;code&gt;application.properties&lt;/code&gt; file. Properties starting with &lt;code&gt;spring.jta.atomikos.properties&lt;/code&gt; can also be used to customize the Atomikos &lt;code&gt;UserTransactionServiceImp&lt;/code&gt;. See the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html&quot;&gt;&lt;code&gt;AtomikosProperties&lt;/code&gt; Javadoc&lt;/a&gt; for complete details.</source>
          <target state="translated">기본적으로 Atomikos 트랜잭션 로그는 애플리케이션의 홈 디렉토리 (애플리케이션 jar 파일이있는 디렉토리)의 &lt;code&gt;transaction-logs&lt;/code&gt; 디렉토리에 기록 됩니다. &lt;code&gt;application.properties&lt;/code&gt; 파일 에서 &lt;code&gt;spring.jta.log-dir&lt;/code&gt; 속성 을 설정하여이 디렉토리의 위치를 ​​사용자 정의 할 수 있습니다 . &lt;code&gt;spring.jta.atomikos.properties&lt;/code&gt; 로 시작하는 속성 은 Atomikos &lt;code&gt;UserTransactionServiceImp&lt;/code&gt; 를 사용자 정의하는 데 사용할 수도 있습니다 . 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/jta/atomikos/AtomikosProperties.html&quot;&gt; &lt;code&gt;AtomikosProperties&lt;/code&gt; &lt;/a&gt; Javadoc 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="08be2ac2bd93a712071652f98e6be10472f189ee" translate="yes" xml:space="preserve">
          <source>By default, Bitronix transaction log files (&lt;code&gt;part1.btm&lt;/code&gt; and &lt;code&gt;part2.btm&lt;/code&gt;) are written to a &lt;code&gt;transaction-logs&lt;/code&gt; directory in your application home directory. You can customize the location of this directory by setting the &lt;code&gt;spring.jta.log-dir&lt;/code&gt; property. Properties starting with &lt;code&gt;spring.jta.bitronix.properties&lt;/code&gt; are also bound to the &lt;code&gt;bitronix.tm.Configuration&lt;/code&gt; bean, allowing for complete customization. See the &lt;a href=&quot;https://github.com/bitronix/btm/wiki/Transaction-manager-configuration&quot;&gt;Bitronix documentation&lt;/a&gt; for details.</source>
          <target state="translated">기본적으로 Bitronix 트랜잭션 로그 파일 ( &lt;code&gt;part1.btm&lt;/code&gt; 및 &lt;code&gt;part2.btm&lt;/code&gt; )은 애플리케이션 홈 디렉토리 의 &lt;code&gt;transaction-logs&lt;/code&gt; 디렉토리에 기록 됩니다. &lt;code&gt;spring.jta.log-dir&lt;/code&gt; 속성 을 설정하여이 디렉토리의 위치를 ​​사용자 정의 할 수 있습니다 . &lt;code&gt;spring.jta.bitronix.properties&lt;/code&gt; 로 시작하는 특성 도 &lt;code&gt;bitronix.tm.Configuration&lt;/code&gt; Bean에 바인딩되어 완전한 사용자 정의가 가능합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/bitronix/btm/wiki/Transaction-manager-configuration&quot;&gt;Bitronix 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7903b7d29fad347f275d1b6b055b251601baf7a3" translate="yes" xml:space="preserve">
          <source>By default, Boxfuse activates a Spring profile named &lt;code&gt;boxfuse&lt;/code&gt; on startup. If your executable jar or war contains an &lt;a href=&quot;https://boxfuse.com/docs/payloads/springboot.html#configuration&quot;&gt;&lt;code&gt;application-boxfuse.properties&lt;/code&gt;&lt;/a&gt; file, Boxfuse bases its configuration on the properties it contains.</source>
          <target state="translated">기본적으로 &lt;code&gt;boxfuse&lt;/code&gt; 는 시작시 boxfuse 라는 이름의 Spring 프로필을 활성화합니다 . 실행 가능한 jar 또는 war에 &lt;a href=&quot;https://boxfuse.com/docs/payloads/springboot.html#configuration&quot;&gt; &lt;code&gt;application-boxfuse.properties&lt;/code&gt; &lt;/a&gt; 파일 이 포함 된 경우 Boxfuse는 포함 된 속성을 기반으로 구성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1a153da6eb67c351b47d825bf44daf70864dd8e6" translate="yes" xml:space="preserve">
          <source>By default, Data JDBC tests are transactional and roll back at the end of each test. See the &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;relevant section&lt;/a&gt; in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole test class as &lt;a href=&quot;#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test&quot;&gt;shown in the JDBC example&lt;/a&gt;.</source>
          <target state="translated">기본적으로 데이터 JDBC 테스트는 트랜잭션이며 각 테스트가 끝날 때 롤백됩니다. 자세한 내용은 Spring Framework 참조 문서 의 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;관련 섹션&lt;/a&gt; 을 참조하십시오. 원하는 것이 아닌 경우 &lt;a href=&quot;#boot-features-testing-spring-boot-applications-testing-autoconfigured-jdbc-test&quot;&gt;JDBC 예제에 표시된&lt;/a&gt; 대로 테스트 또는 전체 테스트 클래스에 대해 트랜잭션 관리를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2934c735bcd854517916350aa5ceb9f1544dc92f" translate="yes" xml:space="preserve">
          <source>By default, Data Neo4j tests are transactional and roll back at the end of each test. See the &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;relevant section&lt;/a&gt; in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:</source>
          <target state="translated">기본적으로 Data Neo4j 테스트는 트랜잭션이며 각 테스트가 끝날 때 롤백됩니다. 자세한 내용은 Spring Framework 참조 문서 의 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;관련 섹션&lt;/a&gt; 을 참조하십시오. 원하는 것이 아닌 경우 다음과 같이 테스트 또는 전체 클래스에 대해 트랜잭션 관리를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a4674b94ccb0ac673294ec9f620a5854c2cbbe0" translate="yes" xml:space="preserve">
          <source>By default, Elastic Beanstalk uploads sources and compiles them in AWS. However, it is best to upload the binaries instead. To do so, add lines similar to the following to your &lt;code&gt;.elasticbeanstalk/config.yml&lt;/code&gt; file:</source>
          <target state="translated">기본적으로 Elastic Beanstalk는 소스를 업로드하고 AWS에서 컴파일합니다. 그러나 대신 바이너리를 업로드하는 것이 가장 좋습니다. 이렇게하려면 &lt;code&gt;.elasticbeanstalk/config.yml&lt;/code&gt; 파일에 다음과 유사한 줄을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="aa8f0ea99136b1f0c78c0da02897ceb8ba47f1ee" translate="yes" xml:space="preserve">
          <source>By default, Flyway autowires the (&lt;code&gt;@Primary&lt;/code&gt;) &lt;code&gt;DataSource&lt;/code&gt; in your context and uses that for migrations. If you like to use a different &lt;code&gt;DataSource&lt;/code&gt;, you can create one and mark its &lt;code&gt;@Bean&lt;/code&gt; as &lt;code&gt;@FlywayDataSource&lt;/code&gt;. If you do so and want two data sources, remember to create another one and mark it as &lt;code&gt;@Primary&lt;/code&gt;. Alternatively, you can use Flyway&amp;rsquo;s native &lt;code&gt;DataSource&lt;/code&gt; by setting &lt;code&gt;spring.flyway.[url,user,password]&lt;/code&gt; in external properties. Setting either &lt;code&gt;spring.flyway.url&lt;/code&gt; or &lt;code&gt;spring.flyway.user&lt;/code&gt; is sufficient to cause Flyway to use its own &lt;code&gt;DataSource&lt;/code&gt;. If any of the three properties has not been set, the value of its equivalent &lt;code&gt;spring.datasource&lt;/code&gt; property will be used.</source>
          <target state="translated">기본적으로 Flyway 는 컨텍스트에서 ( &lt;code&gt;@Primary&lt;/code&gt; ) &lt;code&gt;DataSource&lt;/code&gt; 를 자동 연결하고 마이그레이션에 사용합니다. 다른 &lt;code&gt;DataSource&lt;/code&gt; 를 사용하려면 하나를 만들고 &lt;code&gt;@Bean&lt;/code&gt; 을 &lt;code&gt;@FlywayDataSource&lt;/code&gt; 로 표시 할 수 있습니다 . 그렇게하고 두 개의 데이터 소스를 원하는 경우 다른 소스를 만들고 &lt;code&gt;@Primary&lt;/code&gt; 로 표시해야합니다 . 또는 외부 속성에서 &lt;code&gt;spring.flyway.[url,user,password]&lt;/code&gt; 를 설정 하여 Flyway의 기본 &lt;code&gt;DataSource&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;spring.flyway.url&lt;/code&gt; 또는 &lt;code&gt;spring.flyway.user&lt;/code&gt; 를 설정 하면 Flyway가 자체 &lt;code&gt;DataSource&lt;/code&gt; 를 사용하도록 할 수 있습니다.. 세 가지 속성 중 하나라도 설정되지 않은 경우 해당하는 &lt;code&gt;spring.datasource&lt;/code&gt; 속성 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa7aabf9d69c5c4e7d6933fbffe5914daec6bddc" translate="yes" xml:space="preserve">
          <source>By default, JDBC tests are transactional and roll back at the end of each test. See the &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;relevant section&lt;/a&gt; in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class, as follows:</source>
          <target state="translated">기본적으로 JDBC 테스트는 트랜잭션이며 각 테스트가 끝날 때 롤백됩니다. 자세한 내용은 Spring Framework 참조 문서 의 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;관련 섹션&lt;/a&gt; 을 참조하십시오. 원하는 것이 아닌 경우 다음과 같이 테스트 또는 전체 클래스에 대해 트랜잭션 관리를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e38229ee0acb32bfbfa6c383a4d961147cbfc71" translate="yes" xml:space="preserve">
          <source>By default, JPA databases are automatically created &lt;strong&gt;only&lt;/strong&gt; if you use an embedded database (H2, HSQL, or Derby). You can explicitly configure JPA settings by using &lt;code&gt;spring.jpa.*&lt;/code&gt; properties. For example, to create and drop tables you can add the following line to your &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">기본적으로 JPA 데이터베이스는 임베디드 데이터베이스 (H2, HSQL 또는 Derby)를 사용하는 경우 &lt;strong&gt;에만&lt;/strong&gt; 자동으로 작성 &lt;strong&gt;됩니다&lt;/strong&gt; . &lt;code&gt;spring.jpa.*&lt;/code&gt; 속성 을 사용하여 JPA 설정을 명시 적으로 구성 할 수 있습니다 . 예를 들어 테이블을 만들고 삭제하려면 &lt;code&gt;application.properties&lt;/code&gt; 에 다음 줄을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="375ba836c2e0ebad63ed0b5e96b57231828b81a9" translate="yes" xml:space="preserve">
          <source>By default, Jersey is set up as a Servlet in a &lt;code&gt;@Bean&lt;/code&gt; of type &lt;code&gt;ServletRegistrationBean&lt;/code&gt; named &lt;code&gt;jerseyServletRegistration&lt;/code&gt;. By default, the servlet is initialized lazily, but you can customize that behavior by setting &lt;code&gt;spring.jersey.servlet.load-on-startup&lt;/code&gt;. You can disable or override that bean by creating one of your own with the same name. You can also use a filter instead of a servlet by setting &lt;code&gt;spring.jersey.type=filter&lt;/code&gt; (in which case, the &lt;code&gt;@Bean&lt;/code&gt; to replace or override is &lt;code&gt;jerseyFilterRegistration&lt;/code&gt;). The filter has an &lt;code&gt;@Order&lt;/code&gt;, which you can set with &lt;code&gt;spring.jersey.filter.order&lt;/code&gt;. Both the servlet and the filter registrations can be given init parameters by using &lt;code&gt;spring.jersey.init.*&lt;/code&gt; to specify a map of properties.</source>
          <target state="translated">기본적으로 Jersey는 &lt;code&gt;jerseyServletRegistration&lt;/code&gt; 이라는 &lt;code&gt;ServletRegistrationBean&lt;/code&gt; 유형 의 &lt;code&gt;@Bean&lt;/code&gt; 에서 Servlet으로 설정됩니다 . 기본적으로 서블릿은 느리게 초기화되지만 &lt;code&gt;spring.jersey.servlet.load-on-startup&lt;/code&gt; 을 설정하여 해당 동작을 사용자 지정할 수 있습니다 . 동일한 이름으로 고유 한 Bean을 작성하여 해당 Bean을 비활성화하거나 대체 할 수 있습니다. &lt;code&gt;spring.jersey.type=filter&lt;/code&gt; 를 설정하여 서블릿 대신 필터를 사용할 수도 있습니다 (이 경우 대체하거나 재정의 할 &lt;code&gt;@Bean&lt;/code&gt; 은 &lt;code&gt;jerseyFilterRegistration&lt;/code&gt; 입니다 ). 필터에는 &lt;code&gt;spring.jersey.filter.order&lt;/code&gt; 로 설정할 수 있는 &lt;code&gt;@Order&lt;/code&gt; 가 있습니다.. 서블릿과 필터 등록 모두 &lt;code&gt;spring.jersey.init.*&lt;/code&gt; 를 사용하여 속성 맵을 지정 하여 초기화 매개 변수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6557035a2ea639cc9f3a877fbf18bab5461f8bb" translate="yes" xml:space="preserve">
          <source>By default, Jersey server metrics are tagged with the following information:</source>
          <target state="translated">기본적으로 Jersey 서버 메트릭은 다음 정보로 태그가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="6fc240fe3169879a7e2fb9302f7fdca6e16f92af" translate="yes" xml:space="preserve">
          <source>By default, Liquibase autowires the (&lt;code&gt;@Primary&lt;/code&gt;) &lt;code&gt;DataSource&lt;/code&gt; in your context and uses that for migrations. If you need to use a different &lt;code&gt;DataSource&lt;/code&gt;, you can create one and mark its &lt;code&gt;@Bean&lt;/code&gt; as &lt;code&gt;@LiquibaseDataSource&lt;/code&gt;. If you do so and you want two data sources, remember to create another one and mark it as &lt;code&gt;@Primary&lt;/code&gt;. Alternatively, you can use Liquibase&amp;rsquo;s native &lt;code&gt;DataSource&lt;/code&gt; by setting &lt;code&gt;spring.liquibase.[driver-class-name,url,user,password]&lt;/code&gt; in external properties. Setting either &lt;code&gt;spring.liquibase.url&lt;/code&gt; or &lt;code&gt;spring.liquibase.user&lt;/code&gt; is sufficient to cause Liquibase to use its own &lt;code&gt;DataSource&lt;/code&gt;. If any of the three properties has not been set, the value of its equivalent &lt;code&gt;spring.datasource&lt;/code&gt; property will be used.</source>
          <target state="translated">기본적으로 Liquibase 는 컨텍스트에서 ( &lt;code&gt;@Primary&lt;/code&gt; ) &lt;code&gt;DataSource&lt;/code&gt; 를 자동 연결하고 마이그레이션에 사용합니다. 다른 &lt;code&gt;DataSource&lt;/code&gt; 를 사용해야하는 경우 하나를 만들고 &lt;code&gt;@Bean&lt;/code&gt; 을 &lt;code&gt;@LiquibaseDataSource&lt;/code&gt; 로 표시 할 수 있습니다 . 그렇게하고 두 개의 데이터 소스를 원하는 경우 다른 소스를 만들고 &lt;code&gt;@Primary&lt;/code&gt; 로 표시해야합니다 . 또는 외부 속성에서 &lt;code&gt;spring.liquibase.[driver-class-name,url,user,password]&lt;/code&gt; 를 설정 하여 Liquibase의 기본 &lt;code&gt;DataSource&lt;/code&gt; 를 사용할 수 있습니다 . &lt;code&gt;spring.liquibase.url&lt;/code&gt; 또는 &lt;code&gt;spring.liquibase.user&lt;/code&gt; 를 설정하면 Liquibase 가 자체적으로 &lt;code&gt;DataSource&lt;/code&gt; . 세 가지 속성 중 하나라도 설정되지 않은 경우 해당하는 &lt;code&gt;spring.datasource&lt;/code&gt; 속성 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="555f4a87cde124caf0813e955848b36e827b85d4" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot configures the physical naming strategy with &lt;code&gt;SpringPhysicalNamingStrategy&lt;/code&gt;. This implementation provides the same table structure as Hibernate 4: all dots are replaced by underscores and camel casing is replaced by underscores as well. Additionally, by default, all table names are generated in lower case. For example, a &lt;code&gt;TelephoneNumber&lt;/code&gt; entity is mapped to the &lt;code&gt;telephone_number&lt;/code&gt; table. If your schema requires mixed-case identifiers, define a custom &lt;code&gt;SpringPhysicalNamingStrategy&lt;/code&gt; bean, as shown in the following example:</source>
          <target state="translated">기본적으로 Spring Boot는 &lt;code&gt;SpringPhysicalNamingStrategy&lt;/code&gt; 를 사용하여 물리적 이름 지정 전략을 구성합니다 . 이 구현은 Hibernate 4와 동일한 테이블 구조를 제공합니다. 모든 점은 밑줄로 대체되고 낙타 대소 문자도 밑줄로 대체됩니다. 또한 기본적으로 모든 테이블 이름은 소문자로 생성됩니다. 예를 들어 &lt;code&gt;TelephoneNumber&lt;/code&gt; 엔터티는 &lt;code&gt;telephone_number&lt;/code&gt; 테이블에 매핑됩니다 . 스키마에 대소 문자가 혼합 된 식별자가 필요한 경우 다음 예제에 표시된대로 사용자 정의 &lt;code&gt;SpringPhysicalNamingStrategy&lt;/code&gt; Bean을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="b532c212458742093d4ed1313fc291a422708040" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot does not add other Health Indicators to these groups.</source>
          <target state="translated">기본적으로 Spring Boot는 이러한 그룹에 다른 상태 표시기를 추가하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="93fa523167cdbae61b64be7aaa1d816ec43929ae" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot enables the fail-fast feature of the Spring JDBC initializer. This means that, if the scripts cause exceptions, the application fails to start. You can tune that behavior by setting &lt;code&gt;spring.datasource.continue-on-error&lt;/code&gt;.</source>
          <target state="translated">기본적으로 Spring Boot는 Spring JDBC 이니셜 라이저의 fail-fast 기능을 활성화합니다. 즉, 스크립트로 인해 예외가 발생하면 응용 프로그램이 시작되지 않습니다. &lt;code&gt;spring.datasource.continue-on-error&lt;/code&gt; 를 설정하여 해당 동작을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6634304947a8d75344fe83c68d841ae3f7be9459" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot includes &lt;code&gt;config/*/&lt;/code&gt; in the default search locations. The means that all subdirectories of the &lt;code&gt;/config&lt;/code&gt; directory outside of your jar will be searched.</source>
          <target state="translated">기본적으로 Spring Boot는 기본 검색 위치에 &lt;code&gt;config/*/&lt;/code&gt; 를 포함합니다. 이는 jar 외부의 &lt;code&gt;/config&lt;/code&gt; 디렉토리 의 모든 하위 디렉토리가 검색된다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="d5d087fd6940ce1dfff8c5a6043d6d172ab585de" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot logs only to the console and does not write log files. If you want to write log files in addition to the console output, you need to set a &lt;code&gt;logging.file.name&lt;/code&gt; or &lt;code&gt;logging.file.path&lt;/code&gt; property (for example, in your &lt;code&gt;application.properties&lt;/code&gt;).</source>
          <target state="translated">기본적으로 Spring Boot는 콘솔에만 로깅하고 로그 파일을 작성하지 않습니다. 콘솔 출력과 함께 로그 파일을 작성하려면 &lt;code&gt;logging.file.name&lt;/code&gt; 또는 &lt;code&gt;logging.file.path&lt;/code&gt; 속성 을 설정해야 합니다 (예 : &lt;code&gt;application.properties&lt;/code&gt; 에서 ).</target>
        </trans-unit>
        <trans-unit id="b129912d36a2fed70108db2941ba4170ec85b9b6" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot provides an &lt;code&gt;/error&lt;/code&gt; mapping that handles all errors in a sensible way, and it is registered as a &amp;ldquo;global&amp;rdquo; error page in the servlet container. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a &amp;ldquo;whitelabel&amp;rdquo; error view that renders the same data in HTML format (to customize it, add a &lt;code&gt;View&lt;/code&gt; that resolves to &lt;code&gt;error&lt;/code&gt;). To replace the default behavior completely, you can implement &lt;code&gt;ErrorController&lt;/code&gt; and register a bean definition of that type or add a bean of type &lt;code&gt;ErrorAttributes&lt;/code&gt; to use the existing mechanism but replace the contents.</source>
          <target state="translated">기본적으로 Spring Boot는 모든 오류를 합리적인 방식으로 처리 하는 &lt;code&gt;/error&lt;/code&gt; 매핑을 제공하며 서블릿 컨테이너에 &quot;글로벌&quot;오류 페이지로 등록됩니다. 컴퓨터 클라이언트의 경우 오류, HTTP 상태 및 예외 메시지에 대한 세부 정보가 포함 된 JSON 응답을 생성합니다. 브라우저 클라이언트의 경우 동일한 데이터를 HTML 형식으로 렌더링하는 &quot;whitelabel&quot;오류보기가 있습니다 (사용자 정의 하려면 &lt;code&gt;error&lt;/code&gt; 해결 되는 &lt;code&gt;View&lt;/code&gt; 를 추가하십시오 ). 기본 동작을 완전히 바꾸려면 &lt;code&gt;ErrorController&lt;/code&gt; 를 구현 하고 해당 유형의 빈 정의를 등록하거나 &lt;code&gt;ErrorAttributes&lt;/code&gt; 유형의 빈을 추가 하여 기존 메커니즘을 사용하지만 내용을 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df5d1ea902a10b69666621b1d00b57e62713e401" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot provides metadata for all supported data sources; you can add additional &lt;code&gt;DataSourcePoolMetadataProvider&lt;/code&gt; beans if your favorite data source isn&amp;rsquo;t supported out of the box. See &lt;code&gt;DataSourcePoolMetadataProvidersConfiguration&lt;/code&gt; for examples.</source>
          <target state="translated">기본적으로 Spring Boot는 지원되는 모든 데이터 소스에 대한 메타 데이터를 제공합니다. 선호하는 데이터 소스가 기본적으로 지원되지 않는 경우 추가 &lt;code&gt;DataSourcePoolMetadataProvider&lt;/code&gt; 빈을 추가 할 수 있습니다 . 예제는 &lt;code&gt;DataSourcePoolMetadataProvidersConfiguration&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3908a5145b6210401fe0cf36796b7c17bf17c9fb" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot puts &lt;code&gt;WebDriver&lt;/code&gt; beans in a special &amp;ldquo;scope&amp;rdquo; to ensure that the driver exits after each test and that a new instance is injected. If you do not want this behavior, you can add &lt;code&gt;@Scope(&quot;singleton&quot;)&lt;/code&gt; to your &lt;code&gt;WebDriver&lt;/code&gt;&lt;code&gt;@Bean&lt;/code&gt; definition.</source>
          <target state="translated">기본적으로 Spring Boot는 &lt;code&gt;WebDriver&lt;/code&gt; Bean을 특수 &quot;범위&quot;에 배치하여 각 테스트 후 드라이버가 종료되고 새 인스턴스가 삽입되도록합니다. 이 동작을 원하지 않으면 &lt;code&gt;WebDriver&lt;/code&gt; &lt;code&gt;@Bean&lt;/code&gt; 정의 에 &lt;code&gt;@Scope(&quot;singleton&quot;)&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49e538bccc11d3ce859be26139fc57ae59383b2e" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot registers a &lt;code&gt;BeanContainer&lt;/code&gt; implementation that uses the &lt;code&gt;BeanFactory&lt;/code&gt; so that converters and entity listeners can use regular dependency injection.</source>
          <target state="translated">기본적으로 Spring Boot 는 &lt;code&gt;BeanFactory&lt;/code&gt; 를 사용 하는 &lt;code&gt;BeanContainer&lt;/code&gt; 구현을 등록하여 변환기와 엔티티 리스너가 일반 종속성 주입을 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="7b72a14f4fade56c4c61db994be3e80b33ae7162" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot serves static content from a directory called &lt;code&gt;/static&lt;/code&gt; (or &lt;code&gt;/public&lt;/code&gt; or &lt;code&gt;/resources&lt;/code&gt; or &lt;code&gt;/META-INF/resources&lt;/code&gt;) in the classpath or from the root of the &lt;code&gt;ServletContext&lt;/code&gt;. It uses the &lt;code&gt;ResourceHttpRequestHandler&lt;/code&gt; from Spring MVC so that you can modify that behavior by adding your own &lt;code&gt;WebMvcConfigurer&lt;/code&gt; and overriding the &lt;code&gt;addResourceHandlers&lt;/code&gt; method.</source>
          <target state="translated">기본적으로 Spring Boot는 클래스 경로의 &lt;code&gt;/static&lt;/code&gt; (또는 &lt;code&gt;/public&lt;/code&gt; 또는 &lt;code&gt;/resources&lt;/code&gt; 또는 &lt;code&gt;/META-INF/resources&lt;/code&gt; ) 이라는 디렉토리 또는 &lt;code&gt;ServletContext&lt;/code&gt; 의 루트에서 정적 콘텐츠를 제공합니다 . Spring MVC 의 &lt;code&gt;ResourceHttpRequestHandler&lt;/code&gt; 를 사용 하므로 &lt;code&gt;WebMvcConfigurer&lt;/code&gt; 를 추가 하고 &lt;code&gt;addResourceHandlers&lt;/code&gt; 메소드를 재정 의하여 해당 동작을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="224b9e3edef4d4ebcb1bc3bb579d3a17e7f02522" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot serves static content from a directory called &lt;code&gt;/static&lt;/code&gt; (or &lt;code&gt;/public&lt;/code&gt; or &lt;code&gt;/resources&lt;/code&gt; or &lt;code&gt;/META-INF/resources&lt;/code&gt;) in the classpath. It uses the &lt;code&gt;ResourceWebHandler&lt;/code&gt; from Spring WebFlux so that you can modify that behavior by adding your own &lt;code&gt;WebFluxConfigurer&lt;/code&gt; and overriding the &lt;code&gt;addResourceHandlers&lt;/code&gt; method.</source>
          <target state="translated">기본적으로 Spring Boot는 클래스 경로의 &lt;code&gt;/static&lt;/code&gt; (또는 &lt;code&gt;/public&lt;/code&gt; 또는 &lt;code&gt;/resources&lt;/code&gt; 또는 &lt;code&gt;/META-INF/resources&lt;/code&gt; ) 이라는 디렉토리에서 정적 콘텐츠를 제공합니다 . Spring WebFlux 의 &lt;code&gt;ResourceWebHandler&lt;/code&gt; 를 사용 하므로 자신의 &lt;code&gt;WebFluxConfigurer&lt;/code&gt; 를 추가 하고 &lt;code&gt;addResourceHandlers&lt;/code&gt; 메소드를 재정 의하여 해당 동작을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee11a083f41bf05675971defcb58c75b40042c06" translate="yes" xml:space="preserve">
          <source>By default, Spring Boot will auto-configure and register a &lt;code&gt;ReactiveElasticsearchClient&lt;/code&gt; bean that targets &lt;code&gt;&lt;a href=&quot;http://localhost:9200&quot;&gt;localhost:9200&lt;/a&gt;&lt;/code&gt;. You can further tune how it is configured, as shown in the following example:</source>
          <target state="translated">기본적으로 Spring Boot는 &lt;code&gt;&lt;a href=&quot;http://localhost:9200&quot;&gt;localhost:9200&lt;/a&gt;&lt;/code&gt; 을 대상으로 하는 &lt;code&gt;ReactiveElasticsearchClient&lt;/code&gt; 빈을 자동 구성하고 등록합니다 . 다음 예와 같이 구성 방법을 추가로 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8011894b73e553a952365ec13f28d1192af2caff" translate="yes" xml:space="preserve">
          <source>By default, Spring MVC-related metrics are tagged with the following information:</source>
          <target state="translated">기본적으로 Spring MVC 관련 메트릭은 다음 정보로 태그가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a071e4e34cfe690ca7d9c23304e4b695d32c37b1" translate="yes" xml:space="preserve">
          <source>By default, Spring Security&amp;rsquo;s &lt;code&gt;OAuth2LoginAuthenticationFilter&lt;/code&gt; only processes URLs matching &lt;code&gt;/login/oauth2/code/*&lt;/code&gt;. If you want to customize the &lt;code&gt;redirect-uri&lt;/code&gt; to use a different pattern, you need to provide configuration to process that custom pattern. For example, for servlet applications, you can add your own &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; that resembles the following:</source>
          <target state="translated">기본적으로 Spring Security의 &lt;code&gt;OAuth2LoginAuthenticationFilter&lt;/code&gt; 는 &lt;code&gt;/login/oauth2/code/*&lt;/code&gt; 와 일치하는 URL 만 처리합니다 . 다른 패턴을 사용 하도록 &lt;code&gt;redirect-uri&lt;/code&gt; 를 사용자 지정하려면 해당 사용자 지정 패턴을 처리하기위한 구성을 제공해야합니다. 예를 들어, 서블릿 애플리케이션의 경우 다음과 유사한 &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12eba20cb7cdd381fc192bb795a85ddd17551b99" translate="yes" xml:space="preserve">
          <source>By default, WebFlux-related metrics are tagged with the following information:</source>
          <target state="translated">기본적으로 WebFlux 관련 메트릭은 다음 정보로 태그가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="30ea05b878e7283a72555d0f609f23c0cce7d613" translate="yes" xml:space="preserve">
          <source>By default, a &lt;code&gt;CachingConnectionFactory&lt;/code&gt; wraps the native &lt;code&gt;ConnectionFactory&lt;/code&gt; with sensible settings that you can control by external configuration properties in &lt;code&gt;spring.jms.*&lt;/code&gt;:</source>
          <target state="translated">기본적으로 &lt;code&gt;CachingConnectionFactory&lt;/code&gt; 는 &lt;code&gt;spring.jms.*&lt;/code&gt; 의 외부 구성 속성으로 제어 할 수있는 합리적인 설정으로 네이티브 &lt;code&gt;ConnectionFactory&lt;/code&gt; 를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="c00209d03de7d41f07681b12765dc6ac8c809ec0" translate="yes" xml:space="preserve">
          <source>By default, a key prefix is added so that, if two separate caches use the same key, Redis does not have overlapping keys and cannot return invalid values. We strongly recommend keeping this setting enabled if you create your own &lt;code&gt;RedisCacheManager&lt;/code&gt;.</source>
          <target state="translated">기본적으로 두 개의 개별 캐시가 동일한 키를 사용하는 경우 Redis에는 겹치는 키가 없으며 잘못된 값을 반환 할 수 없도록 키 접두사가 추가됩니다. 자체 &lt;code&gt;RedisCacheManager&lt;/code&gt; 를 생성하는 경우이 설정을 활성화 된 상태로 유지하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="8cfbc4757fa4f13c819e0154b1a25cf18513fa4c" translate="yes" xml:space="preserve">
          <source>By default, a standard schema is used to validate &lt;code&gt;LDIF&lt;/code&gt; files. You can turn off validation altogether by setting the &lt;code&gt;spring.ldap.embedded.validation.enabled&lt;/code&gt; property. If you have custom attributes, you can use &lt;code&gt;spring.ldap.embedded.validation.schema&lt;/code&gt; to define your custom attribute types or object classes.</source>
          <target state="translated">기본적으로 표준 스키마는 &lt;code&gt;LDIF&lt;/code&gt; 파일의 유효성을 검사하는 데 사용됩니다 . &lt;code&gt;spring.ldap.embedded.validation.enabled&lt;/code&gt; 속성 을 설정하여 유효성 검사를 모두 끌 수 있습니다 . 사용자 정의 속성이있는 경우 &lt;code&gt;spring.ldap.embedded.validation.schema&lt;/code&gt; 를 사용하여 사용자 정의 속성 유형 또는 객체 클래스를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ac562e0abd6d3edc6d521786f6d6d7db3fd27d" translate="yes" xml:space="preserve">
          <source>By default, all content is served from the root of your application (&lt;code&gt;/&lt;/code&gt;). If you would rather map to a different path, you can configure one as follows:</source>
          <target state="translated">기본적으로 모든 콘텐츠는 애플리케이션의 루트 ( &lt;code&gt;/&lt;/code&gt; )에서 제공됩니다. 다른 경로로 매핑하려는 경우 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a61adef6ef247a70dc10d1025fd526af53bda18" translate="yes" xml:space="preserve">
          <source>By default, all endpoints except for &lt;code&gt;shutdown&lt;/code&gt; are enabled. To configure the enablement of an endpoint, use its &lt;code&gt;management.endpoint.&amp;lt;id&amp;gt;.enabled&lt;/code&gt; property. The following example enables the &lt;code&gt;shutdown&lt;/code&gt; endpoint:</source>
          <target state="translated">기본적으로 &lt;code&gt;shutdown&lt;/code&gt; 제외한 모든 엔드 포인트 가 활성화됩니다. 끝점 활성화를 구성하려면 해당 &lt;code&gt;management.endpoint.&amp;lt;id&amp;gt;.enabled&lt;/code&gt; 속성을 사용합니다. 다음 예제는 &lt;code&gt;shutdown&lt;/code&gt; 엔드 포인트 를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="09f159313b764af0fec41a0ea3bbef6a5e099ddd" translate="yes" xml:space="preserve">
          <source>By default, an in-memory &lt;code&gt;JobStore&lt;/code&gt; is used. However, it is possible to configure a JDBC-based store if a &lt;code&gt;DataSource&lt;/code&gt; bean is available in your application and if the &lt;code&gt;spring.quartz.job-store-type&lt;/code&gt; property is configured accordingly, as shown in the following example:</source>
          <target state="translated">기본적으로 메모리 내 &lt;code&gt;JobStore&lt;/code&gt; 가 사용됩니다. 그러나 다음 예제와 같이 애플리케이션에서 &lt;code&gt;DataSource&lt;/code&gt; Bean을 사용할 수 있고 &lt;code&gt;spring.quartz.job-store-type&lt;/code&gt; 속성이 적절 하게 구성된 경우 JDBC 기반 저장소를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="873f4dcb0d2838297e44bb4d905261f07bc53bcf" translate="yes" xml:space="preserve">
          <source>By default, any open project in your IDE is loaded with the &amp;ldquo;restart&amp;rdquo; classloader, and any regular &lt;code&gt;.jar&lt;/code&gt; file is loaded with the &amp;ldquo;base&amp;rdquo; classloader. If you work on a multi-module project, and not every module is imported into your IDE, you may need to customize things. To do so, you can create a &lt;code&gt;META-INF/spring-devtools.properties&lt;/code&gt; file.</source>
          <target state="translated">기본적으로 IDE에서 열려있는 모든 프로젝트는 &quot;다시 시작&quot;클래스 로더 로로드되고 일반 &lt;code&gt;.jar&lt;/code&gt; 파일은 &quot;기본&quot;클래스 로더로로드됩니다. 다중 모듈 프로젝트에서 작업하고 모든 모듈을 IDE로 가져 오지 않는 경우 항목을 사용자 정의해야 할 수 있습니다. 이를 위해 &lt;code&gt;META-INF/spring-devtools.properties&lt;/code&gt; 파일을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e2f3bcf8ccbc1e1f5214711439d5164768fdea5" translate="yes" xml:space="preserve">
          <source>By default, batch applications require a &lt;code&gt;DataSource&lt;/code&gt; to store job details. Spring Batch expects a single &lt;code&gt;DataSource&lt;/code&gt; by default. To have it use a &lt;code&gt;DataSource&lt;/code&gt; other than the application&amp;rsquo;s main &lt;code&gt;DataSource&lt;/code&gt;, declare a &lt;code&gt;DataSource&lt;/code&gt; bean, annotating its &lt;code&gt;@Bean&lt;/code&gt; method with &lt;code&gt;@BatchDataSource&lt;/code&gt;. If you do so and want two data sources, remember to mark the other one &lt;code&gt;@Primary&lt;/code&gt;. To take greater control, implement &lt;code&gt;BatchConfigurer&lt;/code&gt;. See &lt;a href=&quot;https://docs.spring.io/spring-batch/docs/4.3.0/api/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html&quot;&gt;The Javadoc of &lt;code&gt;@EnableBatchProcessing&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">기본적으로 배치 애플리케이션에는 작업 세부 정보를 저장하기 위해 &lt;code&gt;DataSource&lt;/code&gt; 가 필요합니다 . Spring Batch는 기본적으로 단일 &lt;code&gt;DataSource&lt;/code&gt; 를 예상합니다 . 애플리케이션의 기본 &lt;code&gt;DataSource&lt;/code&gt; 이외의 &lt;code&gt;DataSource&lt;/code&gt; 를 사용하려면 &lt;code&gt;DataSource&lt;/code&gt; Bean을 선언 하고 &lt;code&gt;@Bean&lt;/code&gt; 메소드에 &lt;code&gt;@BatchDataSource&lt;/code&gt; 주석 을 추가 합니다. 그렇게하고 두 개의 데이터 소스를 원하는 경우 다른 하나는 &lt;code&gt;@Primary&lt;/code&gt; 로 표시해야합니다 . 더 잘 제어하려면 &lt;code&gt;BatchConfigurer&lt;/code&gt; 를 구현 하십시오 . 자세한 내용 &lt;a href=&quot;https://docs.spring.io/spring-batch/docs/4.3.0/api/org/springframework/batch/core/configuration/annotation/EnableBatchProcessing.html&quot;&gt;은 &lt;/a&gt; &lt;code&gt;@EnableBatchProcessing&lt;/code&gt; 의 Javadoc 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="71104b06885eec956863bbacfd1a1fe0cfdb5692" translate="yes" xml:space="preserve">
          <source>By default, data JPA tests are transactional and roll back at the end of each test. See the &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;relevant section&lt;/a&gt; in the Spring Framework Reference Documentation for more details. If that is not what you want, you can disable transaction management for a test or for the whole class as follows:</source>
          <target state="translated">기본적으로 데이터 JPA 테스트는 트랜잭션이며 각 테스트가 끝날 때 롤백됩니다. 자세한 내용은 Spring Framework 참조 문서 의 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/testing.html#testcontext-tx-enabling-transactions&quot;&gt;관련 섹션&lt;/a&gt; 을 참조하십시오. 원하는 것이 아닌 경우 다음과 같이 테스트 또는 전체 클래스에 대해 트랜잭션 관리를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f4a619f28eebb07fc378362723e7bb05a7647e" translate="yes" xml:space="preserve">
          <source>By default, each time your application restarts, a report showing the condition evaluation delta is logged. The report shows the changes to your application&amp;rsquo;s auto-configuration as you make changes such as adding or removing beans and setting configuration properties.</source>
          <target state="translated">기본적으로 애플리케이션이 다시 시작될 때마다 조건 평가 델타를 보여주는 보고서가 기록됩니다. 보고서는 Bean 추가 또는 제거 및 구성 속성 설정과 같은 변경을 수행 할 때 애플리케이션의 자동 구성에 대한 변경 사항을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="4b631e02a18884b5d58b512685b4b7deda3fc5da" translate="yes" xml:space="preserve">
          <source>By default, if a Micrometer &lt;code&gt;meterRegistry&lt;/code&gt; bean is present, Spring Integration metrics will be managed by Micrometer. If you wish to use legacy Spring Integration metrics, add a &lt;code&gt;DefaultMetricsFactory&lt;/code&gt; bean to the application context.</source>
          <target state="translated">기본적으로 Micrometer &lt;code&gt;meterRegistry&lt;/code&gt; 빈이 있으면 Spring Integration 메트릭은 Micrometer에서 관리합니다. 레거시 Spring Integration 메트릭을 사용 하려면 애플리케이션 컨텍스트에 &lt;code&gt;DefaultMetricsFactory&lt;/code&gt; 빈을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3c3c676272ca1eb2a1da50bdc55b94d3d22185f" translate="yes" xml:space="preserve">
          <source>By default, if retries are disabled and the listener throws an exception, the delivery is retried indefinitely. You can modify this behavior in two ways: Set the &lt;code&gt;defaultRequeueRejected&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; so that zero re-deliveries are attempted or throw an &lt;code&gt;AmqpRejectAndDontRequeueException&lt;/code&gt; to signal the message should be rejected. The latter is the mechanism used when retries are enabled and the maximum number of delivery attempts is reached.</source>
          <target state="translated">기본적으로 재 시도가 비활성화되고 리스너에서 예외가 발생하면 전달이 무기한 재 시도됩니다. 이 동작을 두 가지 방법으로 수정할 수 있습니다. &lt;code&gt;defaultRequeueRejected&lt;/code&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 재전송이 시도되지 &lt;code&gt;AmqpRejectAndDontRequeueException&lt;/code&gt; 하거나 AmqpRejectAndDontRequeueException 을 발생시켜 메시지가 거부되어야 함을 알립니다 . 후자는 재 시도가 활성화되고 최대 배달 시도 횟수에 도달 할 때 사용되는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="3886fbab08cebedea34aebf5d5ae090d731ceef5" translate="yes" xml:space="preserve">
          <source>By default, if the context contains only a single Servlet, it is mapped to &lt;code&gt;/&lt;/code&gt;. In the case of multiple servlet beans, the bean name is used as a path prefix. Filters map to &lt;code&gt;/*&lt;/code&gt;.</source>
          <target state="translated">기본적으로 컨텍스트에 단일 서블릿 만 포함 된 경우 &lt;code&gt;/&lt;/code&gt; 에 매핑됩니다 . 다중 서블릿 Bean의 경우 Bean 이름이 경로 접 두부로 사용됩니다. 필터는 &lt;code&gt;/*&lt;/code&gt; 에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="8100dac891b7e0bf6796f8afebab77510115e157" translate="yes" xml:space="preserve">
          <source>By default, if you use the &amp;ldquo;Starters&amp;rdquo;, Logback is used for logging. Appropriate Logback routing is also included to ensure that dependent libraries that use Java Util Logging, Commons Logging, Log4J, or SLF4J all work correctly.</source>
          <target state="translated">기본적으로 &quot;스타터&quot;를 사용하는 경우 로그 백이 로깅에 사용됩니다. Java Util Logging, Commons Logging, Log4J 또는 SLF4J를 사용하는 종속 라이브러리가 모두 올바르게 작동하는지 확인하기 위해 적절한 Logback 라우팅도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="32794dd34f8dbc5b227bf1eeb0a2b93da5b147e1" translate="yes" xml:space="preserve">
          <source>By default, it executes &lt;strong&gt;all&lt;/strong&gt;&lt;code&gt;Jobs&lt;/code&gt; in the application context on startup (see &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherApplicationRunner.java&quot;&gt;&lt;code&gt;JobLauncherApplicationRunner&lt;/code&gt;&lt;/a&gt; for details). You can narrow down to a specific job or jobs by specifying &lt;code&gt;spring.batch.job.names&lt;/code&gt; (which takes a comma-separated list of job name patterns).</source>
          <target state="translated">기본적 으로 시작시 애플리케이션 컨텍스트의 &lt;strong&gt;모든 &lt;/strong&gt; &lt;code&gt;Jobs&lt;/code&gt; 을 실행 &lt;strong&gt;합니다&lt;/strong&gt; (자세한 내용은 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/batch/JobLauncherApplicationRunner.java&quot;&gt; &lt;code&gt;JobLauncherApplicationRunner&lt;/code&gt; &lt;/a&gt; 참조). &lt;code&gt;spring.batch.job.names&lt;/code&gt; (쉼표로 구분 된 작업 이름 패턴 목록 사용)를 지정하여 특정 작업으로 좁힐 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8cf2aa32ac9f0b7c420b2aecea8bbaeec8296458" translate="yes" xml:space="preserve">
          <source>By default, jobs created by configuration will not overwrite already registered jobs that have been read from a persistent job store. To enable overwriting existing job definitions set the &lt;code&gt;spring.quartz.overwrite-existing-jobs&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 구성에 의해 생성 된 작업은 영구 작업 저장소에서 읽은 이미 등록 된 작업을 덮어 쓰지 않습니다. 기존 작업 정의 덮어 쓰기를 활성화하려면 &lt;code&gt;spring.quartz.overwrite-existing-jobs&lt;/code&gt; 속성을 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffbccdcb163132d170503d304f2c4ababf17839a" translate="yes" xml:space="preserve">
          <source>By default, logs are redirected to &lt;code&gt;System.err&lt;/code&gt;. For more details, see &lt;a href=&quot;https://www.eclipse.org/jetty/documentation/9.4.34.v20201102/configuring-jetty-request-logs.html&quot;&gt;the Jetty documentation&lt;/a&gt;.</source>
          <target state="translated">기본적으로 로그는 &lt;code&gt;System.err&lt;/code&gt; 로 리디렉션됩니다 . 자세한 내용 &lt;a href=&quot;https://www.eclipse.org/jetty/documentation/9.4.34.v20201102/configuring-jetty-request-logs.html&quot;&gt;은 Jetty 문서를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="aa8ea194456f07db16ad34a1ec570a37357f5893" translate="yes" xml:space="preserve">
          <source>By default, metadata about the running application as well as service connection information is exposed to the application as environment variables (for example: &lt;code&gt;$VCAP_SERVICES&lt;/code&gt;). This architecture decision is due to Cloud Foundry&amp;rsquo;s polyglot (any language and platform can be supported as a buildpack) nature. Process-scoped environment variables are language agnostic.</source>
          <target state="translated">기본적으로 실행중인 애플리케이션에 대한 메타 데이터와 서비스 연결 정보는 애플리케이션에 환경 변수 (예 : &lt;code&gt;$VCAP_SERVICES&lt;/code&gt; ) 로 노출됩니다 . 이 아키텍처 결정은 Cloud Foundry의 다중 언어 (모든 언어 및 플랫폼이 빌드 팩으로 지원 될 수 있음) 특성 때문입니다. 프로세스 범위 환경 변수는 언어에 구애받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d81c216cf96b67dea7f99ce5803042cf2dac621a" translate="yes" xml:space="preserve">
          <source>By default, metrics are exported to &lt;a href=&quot;https://micrometer.io/docs/registry/atlas&quot;&gt;Atlas&lt;/a&gt; running on your local machine. The location of the &lt;a href=&quot;https://github.com/Netflix/atlas&quot;&gt;Atlas server&lt;/a&gt; to use can be provided using:</source>
          <target state="translated">기본적으로 메트릭은 로컬 컴퓨터에서 실행 되는 &lt;a href=&quot;https://micrometer.io/docs/registry/atlas&quot;&gt;Atlas&lt;/a&gt; 로 내보내집니다 . 사용할 &lt;a href=&quot;https://github.com/Netflix/atlas&quot;&gt;Atlas 서버&lt;/a&gt; 의 위치는 다음 을 사용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17808114fa0555271c13495a676e85316f482971" translate="yes" xml:space="preserve">
          <source>By default, metrics are exported to &lt;a href=&quot;https://micrometer.io/docs/registry/elastic&quot;&gt;Elastic&lt;/a&gt; running on your local machine. The location of the Elastic server to use can be provided using the following property:</source>
          <target state="translated">기본적으로 메트릭은 로컬 머신에서 실행 되는 &lt;a href=&quot;https://micrometer.io/docs/registry/elastic&quot;&gt;Elastic&lt;/a&gt; 으로 내보내집니다 . 사용할 Elastic 서버의 위치는 다음 속성을 사용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53535cb0db39572965ff8ff4c673bb8d43867d90" translate="yes" xml:space="preserve">
          <source>By default, metrics are exported to &lt;a href=&quot;https://micrometer.io/docs/registry/ganglia&quot;&gt;Ganglia&lt;/a&gt; running on your local machine. The &lt;a href=&quot;http://ganglia.sourceforge.net&quot;&gt;Ganglia server&lt;/a&gt; host and port to use can be provided using:</source>
          <target state="translated">기본적으로 메트릭은 로컬 컴퓨터에서 실행 되는 &lt;a href=&quot;https://micrometer.io/docs/registry/ganglia&quot;&gt;Ganglia&lt;/a&gt; 로 내보내집니다 . &lt;a href=&quot;http://ganglia.sourceforge.net&quot;&gt;신경절 서버&lt;/a&gt; 사용에 호스트 및 포트를 사용하여 제공 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c5931abc16032f78ce4c52d3f448c59412abb4f8" translate="yes" xml:space="preserve">
          <source>By default, metrics are exported to &lt;a href=&quot;https://micrometer.io/docs/registry/graphite&quot;&gt;Graphite&lt;/a&gt; running on your local machine. The &lt;a href=&quot;https://graphiteapp.org&quot;&gt;Graphite server&lt;/a&gt; host and port to use can be provided using:</source>
          <target state="translated">기본적으로 메트릭은 로컬 컴퓨터에서 실행 되는 &lt;a href=&quot;https://micrometer.io/docs/registry/graphite&quot;&gt;Graphite&lt;/a&gt; 로 내보내집니다 . &lt;a href=&quot;https://graphiteapp.org&quot;&gt;흑연 서버&lt;/a&gt; 사용에 호스트 및 포트를 사용하여 제공 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="efb4c5b65e2a2e2b4bbb3ce6238bf162d4bdad6e" translate="yes" xml:space="preserve">
          <source>By default, metrics are exported to &lt;a href=&quot;https://micrometer.io/docs/registry/influx&quot;&gt;Influx&lt;/a&gt; running on your local machine. The location of the &lt;a href=&quot;https://www.influxdata.com&quot;&gt;Influx server&lt;/a&gt; to use can be provided using:</source>
          <target state="translated">기본적으로 메트릭은 로컬 컴퓨터에서 실행 되는 &lt;a href=&quot;https://micrometer.io/docs/registry/influx&quot;&gt;Influx&lt;/a&gt; 로 내보내집니다 . 사용할 &lt;a href=&quot;https://www.influxdata.com&quot;&gt;Influx 서버&lt;/a&gt; 의 위치는 다음 을 사용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe3048cfaf4bf5e7517b57415a5d864bf7b3c648" translate="yes" xml:space="preserve">
          <source>By default, metrics are exported to &lt;a href=&quot;https://micrometer.io/docs/registry/kairos&quot;&gt;KairosDB&lt;/a&gt; running on your local machine. The location of the &lt;a href=&quot;https://kairosdb.github.io/&quot;&gt;KairosDB server&lt;/a&gt; to use can be provided using:</source>
          <target state="translated">기본적으로 메트릭은 로컬 머신에서 실행 되는 &lt;a href=&quot;https://micrometer.io/docs/registry/kairos&quot;&gt;KairosDB&lt;/a&gt; 로 내보내집니다 . 사용할 &lt;a href=&quot;https://kairosdb.github.io/&quot;&gt;KairosDB 서버&lt;/a&gt; 의 위치는 다음 을 사용하여 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3946e048c4508140aaf98be7cc4abc9e1b7f00b" translate="yes" xml:space="preserve">
          <source>By default, metrics are generated with the name &lt;code&gt;http.server.requests&lt;/code&gt;. You can customize the name by setting the &lt;code&gt;management.metrics.web.server.request.metric-name&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 메트릭은 &lt;code&gt;http.server.requests&lt;/code&gt; 라는 이름으로 생성됩니다 . &lt;code&gt;management.metrics.web.server.request.metric-name&lt;/code&gt; 속성 을 설정하여 이름을 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="44d2a78a7de9f7968d91aa5f95b2088b5fc3a33f" translate="yes" xml:space="preserve">
          <source>By default, metrics are generated with the name, &lt;code&gt;http.client.requests&lt;/code&gt;. The name can be customized by setting the &lt;code&gt;management.metrics.web.client.request.metric-name&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 메트릭은 &lt;code&gt;http.client.requests&lt;/code&gt; 라는 이름으로 생성됩니다 . &lt;code&gt;management.metrics.web.client.request.metric-name&lt;/code&gt; 속성 을 설정하여 이름을 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30b2e262a904a3b624a9e63d8f7b8e0b28ca6675" translate="yes" xml:space="preserve">
          <source>By default, metrics are generated with the name, &lt;code&gt;http.server.requests&lt;/code&gt;. The name can be customized by setting the &lt;code&gt;management.metrics.web.server.request.metric-name&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 메트릭은 &lt;code&gt;http.server.requests&lt;/code&gt; 라는 이름으로 생성됩니다 . &lt;code&gt;management.metrics.web.server.request.metric-name&lt;/code&gt; 속성 을 설정하여 이름을 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f59632da80bf4d55045fca39384c588f9c59e7d6" translate="yes" xml:space="preserve">
          <source>By default, metrics are published via REST calls but it is also possible to use the Java Agent API if you have it on the classpath:</source>
          <target state="translated">기본적으로 메트릭은 REST 호출을 통해 게시되지만 클래스 경로에있는 경우 Java Agent API를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab15e5b1d54cacdd5d1a168f3a982fce2401e28" translate="yes" xml:space="preserve">
          <source>By default, metrics generated by an instrumented client are tagged with the following information:</source>
          <target state="translated">기본적으로 계측 된 클라이언트에서 생성 된 메트릭은 다음 정보로 태그가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="b90beae1ba9618c44cbba3f37de241accc8d5f6d" translate="yes" xml:space="preserve">
          <source>By default, properties from different sources are added to the Spring &lt;code&gt;Environment&lt;/code&gt; in a defined order (see &amp;ldquo;&lt;a href=&quot;spring-boot-features#boot-features-external-config&quot;&gt;spring-boot-features.html&lt;/a&gt;&amp;rdquo; in the &amp;lsquo;Spring Boot features&amp;rsquo; section for the exact order).</source>
          <target state="translated">기본적으로 다른 소스의 속성 이 정의 된 순서로 Spring &lt;code&gt;Environment&lt;/code&gt; 에 추가됩니다 ( 정확한 순서는 'Spring Boot features'섹션의 &amp;ldquo; &lt;a href=&quot;spring-boot-features#boot-features-external-config&quot;&gt;spring-boot-features.html&lt;/a&gt; &amp;rdquo; 참조 ).</target>
        </trans-unit>
        <trans-unit id="424ef4472a5ca46f3e51efd8050a5e7d323a1051" translate="yes" xml:space="preserve">
          <source>By default, resources are mapped on &lt;code&gt;/**&lt;/code&gt;, but you can tune that by setting the &lt;code&gt;spring.webflux.static-path-pattern&lt;/code&gt; property. For instance, relocating all resources to &lt;code&gt;/resources/**&lt;/code&gt; can be achieved as follows:</source>
          <target state="translated">기본적으로 리소스는 &lt;code&gt;/**&lt;/code&gt; 에 매핑 되지만 &lt;code&gt;spring.webflux.static-path-pattern&lt;/code&gt; 속성 을 설정하여 조정할 수 있습니다 . 예를 들어 모든 리소스를 &lt;code&gt;/resources/**&lt;/code&gt; 로 재배치 는 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef526aef19cb17faf41c991791c5a5369b8b385" translate="yes" xml:space="preserve">
          <source>By default, resources are mapped on &lt;code&gt;/**&lt;/code&gt;, but you can tune that with the &lt;code&gt;spring.mvc.static-path-pattern&lt;/code&gt; property. For instance, relocating all resources to &lt;code&gt;/resources/**&lt;/code&gt; can be achieved as follows:</source>
          <target state="translated">기본적으로 리소스는 &lt;code&gt;/**&lt;/code&gt; 에 매핑 되지만 &lt;code&gt;spring.mvc.static-path-pattern&lt;/code&gt; 속성 을 사용하여 조정할 수 있습니다 . 예를 들어 모든 리소스를 &lt;code&gt;/resources/**&lt;/code&gt; 로 재배치 는 다음과 같이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cda828c94262b10d5fc4f2447f6ba39c04262674" translate="yes" xml:space="preserve">
          <source>By default, responses are compressed only if their content type is one of the following:</source>
          <target state="translated">기본적으로 응답은 컨텐츠 유형이 다음 중 하나 인 경우에만 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="77a799ddfe0149eac37c85cf9b7b619f499fe923" translate="yes" xml:space="preserve">
          <source>By default, responses must be at least 2048 bytes in length for compression to be performed. You can configure this behavior by setting the &lt;code&gt;server.compression.min-response-size&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 압축을 수행하려면 응답 길이가 2048 바이트 이상이어야합니다. &lt;code&gt;server.compression.min-response-size&lt;/code&gt; 속성 을 설정하여이 동작을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="613e86710c2b9fc9128d99abde5e225de9ba9c79" translate="yes" xml:space="preserve">
          <source>By default, the AppOptics registry pushes metrics to &lt;code&gt;&lt;a href=&quot;https://api.appoptics.com/v1/measurements&quot;&gt;api.appoptics.com/v1/measurements&lt;/a&gt;&lt;/code&gt; periodically. To export metrics to SaaS &lt;a href=&quot;https://micrometer.io/docs/registry/appOptics&quot;&gt;AppOptics&lt;/a&gt;, your API token must be provided:</source>
          <target state="translated">기본적으로 AppOptics 레지스트리는 메트릭을 &lt;code&gt;&lt;a href=&quot;https://api.appoptics.com/v1/measurements&quot;&gt;api.appoptics.com/v1/measurements&lt;/a&gt;&lt;/code&gt; 에 주기적으로 푸시 합니다. 측정 항목을 SaaS &lt;a href=&quot;https://micrometer.io/docs/registry/appOptics&quot;&gt;AppOptics로&lt;/a&gt; 내보내 려면 API 토큰을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="0ac523fb22adbfe5e02d10f28658eddd3508cf69" translate="yes" xml:space="preserve">
          <source>By default, the CLI uses the dependency management declared in &lt;code&gt;spring-boot-dependencies&lt;/code&gt; when resolving &lt;code&gt;@Grab&lt;/code&gt; dependencies. Additional dependency management, which overrides the default dependency management, can be configured by using the &lt;code&gt;@DependencyManagementBom&lt;/code&gt; annotation. The annotation&amp;rsquo;s value should specify the coordinates (&lt;code&gt;groupId:artifactId:version&lt;/code&gt;) of one or more Maven BOMs.</source>
          <target state="translated">기본적으로 CLI는 &lt;code&gt;@Grab&lt;/code&gt; 종속성을 해결할 때 &lt;code&gt;spring-boot-dependencies&lt;/code&gt; 에 선언 된 종속성 관리를 사용합니다 . 기본 종속성 관리를 재정의하는 추가 종속성 관리는 &lt;code&gt;@DependencyManagementBom&lt;/code&gt; 주석 을 사용하여 구성 할 수 있습니다 . 주석의 값은 하나 이상의 Maven BOM 의 좌표 ( &lt;code&gt;groupId:artifactId:version&lt;/code&gt; )를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f3c4c5e3b571578f96aa8ef50c78f6843e77e99" translate="yes" xml:space="preserve">
          <source>By default, the DDL execution (or validation) is deferred until the &lt;code&gt;ApplicationContext&lt;/code&gt; has started. There is also a &lt;code&gt;spring.jpa.generate-ddl&lt;/code&gt; flag, but it is not used if Hibernate auto-configuration is active, because the &lt;code&gt;ddl-auto&lt;/code&gt; settings are more fine-grained.</source>
          <target state="translated">기본적으로 DDL 실행 (또는 유효성 검사)은 &lt;code&gt;ApplicationContext&lt;/code&gt; 가 시작될 때까지 연기 됩니다. 거기에 또한 &lt;code&gt;spring.jpa.generate-ddl&lt;/code&gt; 플래그는하지만, 최대 절전 모드 자동 설정이 활성화되면 있기 때문에, 사용하지 않을 &lt;code&gt;ddl-auto&lt;/code&gt; 설정이 더 세분화된다.</target>
        </trans-unit>
        <trans-unit id="9c813b81bfde51388a2c99eb393ca9a81c77ef5a" translate="yes" xml:space="preserve">
          <source>By default, the Humio registry pushes metrics to &lt;a href=&quot;https://cloud.humio.com&quot;&gt;cloud.humio.com&lt;/a&gt; periodically. To export metrics to SaaS &lt;a href=&quot;https://micrometer.io/docs/registry/humio&quot;&gt;Humio&lt;/a&gt;, your API token must be provided:</source>
          <target state="translated">기본적으로 Humio 레지스트리는 주기적으로 &lt;a href=&quot;https://cloud.humio.com&quot;&gt;cloud.humio.com에&lt;/a&gt; 메트릭을 푸시 합니다. 측정 항목을 SaaS &lt;a href=&quot;https://micrometer.io/docs/registry/humio&quot;&gt;Humio로&lt;/a&gt; 내보내 려면 API 토큰을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="276d27aaefc21edb5aac948db91279768fdbd965" translate="yes" xml:space="preserve">
          <source>By default, the Spring Boot starter (&lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt;) uses &lt;a href=&quot;https://github.com/lettuce-io/lettuce-core/&quot;&gt;Lettuce&lt;/a&gt;. You need to exclude that dependency and include the &lt;a href=&quot;https://github.com/xetorthio/jedis/&quot;&gt;Jedis&lt;/a&gt; one instead. Spring Boot manages both of these dependencies so you can switch to Jedis without specifying a version.</source>
          <target state="translated">기본적으로 Spring Boot 스타터 ( &lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt; )는 &lt;a href=&quot;https://github.com/lettuce-io/lettuce-core/&quot;&gt;Lettuce를&lt;/a&gt; 사용합니다 . 해당 종속성을 제외하고 대신 &lt;a href=&quot;https://github.com/xetorthio/jedis/&quot;&gt;Jedis를&lt;/a&gt; 포함해야합니다 . Spring Boot는 이러한 종속성을 모두 관리하므로 버전을 지정하지 않고도 Jedis로 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e850a49985666baede5fd93e302202f7d00550ef" translate="yes" xml:space="preserve">
          <source>By default, the console is available at &lt;code&gt;/h2-console&lt;/code&gt;. You can customize the console&amp;rsquo;s path by using the &lt;code&gt;spring.h2.console.path&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 콘솔은 &lt;code&gt;/h2-console&lt;/code&gt; 에서 사용할 수 있습니다 . &lt;code&gt;spring.h2.console.path&lt;/code&gt; 속성 을 사용하여 콘솔의 경로를 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ca82f879eba3bc20af1cbd488c290566720c58a" translate="yes" xml:space="preserve">
          <source>By default, the database is detected and initialized by using the standard scripts provided with the Quartz library. These scripts drop existing tables, deleting all triggers on every restart. It is also possible to provide a custom script by setting the &lt;code&gt;spring.quartz.jdbc.schema&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 데이터베이스는 Quartz 라이브러리와 함께 제공되는 표준 스크립트를 사용하여 감지되고 초기화됩니다. 이러한 스크립트는 기존 테이블을 삭제하고 다시 시작할 때마다 모든 트리거를 삭제합니다. &lt;code&gt;spring.quartz.jdbc.schema&lt;/code&gt; 속성 을 설정하여 사용자 지정 스크립트를 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="755dc142a9e09913a28fafa4a89a50cd08703792" translate="yes" xml:space="preserve">
          <source>By default, the default factory is transactional. If you run in an infrastructure where a &lt;code&gt;JtaTransactionManager&lt;/code&gt; is present, it is associated to the listener container by default. If not, the &lt;code&gt;sessionTransacted&lt;/code&gt; flag is enabled. In that latter scenario, you can associate your local data store transaction to the processing of an incoming message by adding &lt;code&gt;@Transactional&lt;/code&gt; on your listener method (or a delegate thereof). This ensures that the incoming message is acknowledged, once the local transaction has completed. This also includes sending response messages that have been performed on the same JMS session.</source>
          <target state="translated">기본적으로 기본 팩토리는 트랜잭션입니다. &lt;code&gt;JtaTransactionManager&lt;/code&gt; 가 있는 인프라에서 실행하는 경우 기본적으로 리스너 컨테이너에 연결됩니다. 그렇지 않은 경우 &lt;code&gt;sessionTransacted&lt;/code&gt; 플래그가 활성화됩니다. 후자의 시나리오에서는 리스너 메서드 (또는 그 대리자)에 &lt;code&gt;@Transactional&lt;/code&gt; 을 추가하여 로컬 데이터 저장소 트랜잭션을 수신 메시지 처리에 연결할 수 있습니다 . 이렇게하면 로컬 트랜잭션이 완료되면 수신 메시지가 승인됩니다. 여기에는 동일한 JMS 세션에서 수행 된 응답 메시지 전송도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6b8243d1f965b150f880f5fff4bc938e05b617af" translate="yes" xml:space="preserve">
          <source>By default, the embedded Tomcat used by Spring Boot does not support &quot;Version 0&quot; of the Cookie format, so you may see the following error:</source>
          <target state="translated">기본적으로 Spring Boot에서 사용하는 임베디드 Tomcat은 쿠키 형식의 &quot;버전 0&quot;을 지원하지 않으므로 다음 오류가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb3244b5debcea832bc739fe7abbba0cd0c15168" translate="yes" xml:space="preserve">
          <source>By default, the final system health is derived by a &lt;code&gt;StatusAggregator&lt;/code&gt; which sorts the statuses from each &lt;code&gt;HealthIndicator&lt;/code&gt; based on an ordered list of statuses. The first status in the sorted list is used as the overall health status. If no &lt;code&gt;HealthIndicator&lt;/code&gt; returns a status that is known to the &lt;code&gt;StatusAggregator&lt;/code&gt;, an &lt;code&gt;UNKNOWN&lt;/code&gt; status is used.</source>
          <target state="translated">기본적으로 최종 시스템 상태는 정렬 된 상태 목록에 따라 각 &lt;code&gt;HealthIndicator&lt;/code&gt; 의 상태를 정렬 하는 &lt;code&gt;StatusAggregator&lt;/code&gt; 에 의해 파생 됩니다. 정렬 된 목록의 첫 번째 상태가 전체 상태로 사용됩니다. 어떤 경우 &lt;code&gt;HealthIndicator&lt;/code&gt; 가 받는 알려진 상태 반환 &lt;code&gt;StatusAggregator&lt;/code&gt; 를 , &lt;code&gt;UNKNOWN&lt;/code&gt; 의 상태가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7866c030a3a444314a2409a6b7e51ce8e152a8d" translate="yes" xml:space="preserve">
          <source>By default, the master change log is read from &lt;code&gt;db/changelog/db.changelog-master.yaml&lt;/code&gt;, but you can change the location by setting &lt;code&gt;spring.liquibase.change-log&lt;/code&gt;. In addition to YAML, Liquibase also supports JSON, XML, and SQL change log formats.</source>
          <target state="translated">기본적으로 마스터 변경 로그는 &lt;code&gt;db/changelog/db.changelog-master.yaml&lt;/code&gt; 에서 읽지 만 &lt;code&gt;spring.liquibase.change-log&lt;/code&gt; 를 설정하여 위치를 변경할 수 있습니다 . YAML 외에도 Liquibase는 JSON, XML 및 SQL 변경 로그 형식도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="afcf3a99e5c88204170963824b4a15ad4f9ed468" translate="yes" xml:space="preserve">
          <source>By default, the security verification for &lt;code&gt;/cloudfoundryapplication&lt;/code&gt; endpoints makes SSL calls to various Cloud Foundry services. If your Cloud Foundry UAA or Cloud Controller services use self-signed certificates, you need to set the following property:</source>
          <target state="translated">기본적으로 &lt;code&gt;/cloudfoundryapplication&lt;/code&gt; 끝점에 대한 보안 확인은 다양한 Cloud Foundry 서비스에 대한 SSL 호출을 수행합니다. Cloud Foundry UAA 또는 Cloud Controller 서비스가 자체 서명 된 인증서를 사용하는 경우 다음 특성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dc3d95e0af64bbeec0a50b296cca8d3995fab7e" translate="yes" xml:space="preserve">
          <source>By default, the server starts on a random port and triggers the regular LDAP support. There is no need to specify a &lt;code&gt;spring.ldap.urls&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 서버는 임의의 포트에서 시작하고 일반 LDAP 지원을 트리거합니다. &lt;code&gt;spring.ldap.urls&lt;/code&gt; 속성 을 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7b61b3e1b4f2a6ed790b02fd492c40e70eabc823" translate="yes" xml:space="preserve">
          <source>By default, the streams managed by the &lt;code&gt;StreamBuilder&lt;/code&gt; object it creates are started automatically. You can customize this behaviour using the &lt;code&gt;spring.kafka.streams.auto-startup&lt;/code&gt; property.</source>
          <target state="translated">기본적으로 생성 된 &lt;code&gt;StreamBuilder&lt;/code&gt; 개체에서 관리하는 스트림 은 자동으로 시작됩니다. &lt;code&gt;spring.kafka.streams.auto-startup&lt;/code&gt; 속성을 사용하여이 동작을 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2177350e9dc31a95a137bac7595539528ed5a32e" translate="yes" xml:space="preserve">
          <source>By default, these writers are not activated, but you can enable:</source>
          <target state="translated">기본적으로 이러한 작성기는 활성화되지 않지만 다음을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a7357338d2b8285399a6f976d2cc23c65f0b546" translate="yes" xml:space="preserve">
          <source>By default, those resources will be also shared with the Reactor Netty and Jetty clients for optimal performances, given:</source>
          <target state="translated">기본적으로 이러한 리소스는 최적의 성능을 위해 Reactor Netty 및 Jetty 클라이언트와 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="8aa8bba048edf2d24e2a417af704dc26a7699490" translate="yes" xml:space="preserve">
          <source>By default, when a specified config data location does not exist, Spring Boot will throw a &lt;code&gt;ConfigDataLocationNotFoundException&lt;/code&gt; and your application will not start.</source>
          <target state="translated">기본적으로 지정된 구성 데이터 위치가 존재하지 않으면 Spring Boot는 &lt;code&gt;ConfigDataLocationNotFoundException&lt;/code&gt; 을 발생 시키고 애플리케이션이 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a3488e039dd1f83db97670cbe88aa6bab13a8d6" translate="yes" xml:space="preserve">
          <source>CGLib proxies, such as those created for scoped beans, declare the proxied methods as &lt;code&gt;final&lt;/code&gt;. This stops Mockito from functioning correctly as it cannot mock or spy on &lt;code&gt;final&lt;/code&gt; methods in its default configuration. If you want to mock or spy on such a bean, configure Mockito to use its inline mock maker by adding &lt;code&gt;org.mockito:mockito-inline&lt;/code&gt; to your application&amp;rsquo;s test dependencies. This allows Mockito to mock and spy on &lt;code&gt;final&lt;/code&gt; methods.</source>
          <target state="translated">범위가 지정된 Bean에 대해 생성 된 것과 같은 CGLib 프록시는 프록시 된 메서드를 &lt;code&gt;final&lt;/code&gt; 로 선언합니다 . 이것은 Mockito 가 기본 구성에서 &lt;code&gt;final&lt;/code&gt; 메서드를 모의하거나 감시 할 수 없기 때문에 올바르게 작동하지 못하게 합니다. 그러한 빈을 모의하거나 감시하려면 애플리케이션의 테스트 종속성에 &lt;code&gt;org.mockito:mockito-inline&lt;/code&gt; 을 추가하여 인라인 모의 제작자를 사용하도록 Mockito를 구성 하십시오. 이를 통해 Mockito는 &lt;code&gt;final&lt;/code&gt; 방법 을 모의하고 감시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c81bbf934b1774254e5f73e715a94357444a6dcd" translate="yes" xml:space="preserve">
          <source>CORS support is disabled by default and is only enabled once the &lt;code&gt;management.endpoints.web.cors.allowed-origins&lt;/code&gt; property has been set. The following configuration permits &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; calls from the &lt;code&gt;example.com&lt;/code&gt; domain:</source>
          <target state="translated">CORS 지원은 기본적으로 비활성화되어 있으며 &lt;code&gt;management.endpoints.web.cors.allowed-origins&lt;/code&gt; 속성이 설정된 후에 만 활성화 됩니다. 다음 구성 은 &lt;code&gt;example.com&lt;/code&gt; 도메인 에서 &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;POST&lt;/code&gt; 호출을 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="aaaee74feef5d1586dd7e24caa440e2fa9b37139" translate="yes" xml:space="preserve">
          <source>CPU metrics</source>
          <target state="translated">CPU 메트릭</target>
        </trans-unit>
        <trans-unit id="3e071861573efa2404fb54383675a866ae130f83" translate="yes" xml:space="preserve">
          <source>Cache options are usually configured by settings in your &lt;code&gt;application.properties&lt;/code&gt; file. For example, Thymeleaf offers the &lt;code&gt;spring.thymeleaf.cache&lt;/code&gt; property. Rather than needing to set these properties manually, the &lt;code&gt;spring-boot-devtools&lt;/code&gt; module automatically applies sensible development-time configuration.</source>
          <target state="translated">캐시 옵션은 일반적으로 &lt;code&gt;application.properties&lt;/code&gt; 파일의 설정에 의해 구성됩니다 . 예를 들어, Thymeleaf는 &lt;code&gt;spring.thymeleaf.cache&lt;/code&gt; 속성을 제공합니다 . 이러한 속성을 수동으로 설정할 필요없이 &lt;code&gt;spring-boot-devtools&lt;/code&gt; 모듈은 자동으로 합리적인 개발 시간 구성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="385aea4ea65f973fbc946baccbba2409dbaea5f2" translate="yes" xml:space="preserve">
          <source>Cache period for the resources served by the resource handler. If a duration suffix is not specified, seconds will be used. Can be overridden by the 'spring.web.resources.cache.cachecontrol' properties.</source>
          <target state="translated">리소스 처리기가 제공하는 리소스의 캐시 기간입니다. 기간 접미사가 지정되지 않은 경우 초가 사용됩니다. 'spring.web.resources.cache.cachecontrol'속성으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb49c6559bc51e6424b46cf53f19c9a24fa36fc5" translate="yes" xml:space="preserve">
          <source>Cache type. By default, auto-detected according to the environment.</source>
          <target state="translated">캐시 유형. 기본적으로 환경에 따라 자동 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="baf41f651e0cc569c55bae1b15f9750c1cddeb48" translate="yes" xml:space="preserve">
          <source>Caches can be created on startup by setting the &lt;code&gt;spring.cache.cache-names&lt;/code&gt; property. If a custom &lt;code&gt;ConfigurationBuilder&lt;/code&gt; bean is defined, it is used to customize the caches.</source>
          <target state="translated">시작시 &lt;code&gt;spring.cache.cache-names&lt;/code&gt; 속성 을 설정하여 캐시를 생성 할 수 있습니다 . 사용자 정의 &lt;code&gt;ConfigurationBuilder&lt;/code&gt; Bean이 정의 된 경우 캐시를 사용자 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d697acd6725f6650ecdd65576dcc87a6e737e960" translate="yes" xml:space="preserve">
          <source>Caches can be created on startup by setting the &lt;code&gt;spring.cache.cache-names&lt;/code&gt; property. If a custom &lt;code&gt;javax.cache.configuration.Configuration&lt;/code&gt; bean is defined, it is used to customize them.</source>
          <target state="translated">시작시 &lt;code&gt;spring.cache.cache-names&lt;/code&gt; 속성 을 설정하여 캐시를 생성 할 수 있습니다 . 사용자 정의 &lt;code&gt;javax.cache.configuration.Configuration&lt;/code&gt; Bean이 정의 된 경우이를 사용자 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27568fa85ded4d249c45ddbb15be2b7cdfa9f70d" translate="yes" xml:space="preserve">
          <source>Caching abstraction.</source>
          <target state="translated">캐싱 추상화.</target>
        </trans-unit>
        <trans-unit id="22859fa3d4076d7a55f9ca6b2c7659d499f52440" translate="yes" xml:space="preserve">
          <source>Caffeine</source>
          <target state="translated">Caffeine</target>
        </trans-unit>
        <trans-unit id="0a4da02492bc2728078047a577c1c1bec582d46f" translate="yes" xml:space="preserve">
          <source>Camel case, kebab case, or underscore notation</source>
          <target state="translated">카멜 케이스, 케밥 케이스 또는 밑줄 표기법</target>
        </trans-unit>
        <trans-unit id="a9fcfe4de5332ce5662c25c5d7b43a84844238f8" translate="yes" xml:space="preserve">
          <source>Can be used to short-circuit the &lt;code&gt;main&lt;/code&gt; class search</source>
          <target state="translated">&lt;code&gt;main&lt;/code&gt; 클래스 검색 을 단락시키는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ee0fb890728d6a8e7b0a788754c25afcbf502e" translate="yes" xml:space="preserve">
          <source>Care should be taken to ensure that your operating system is configured so that it will not delete the jars that have been unpacked to the temporary directory while the application is still running.</source>
          <target state="translated">응용 프로그램이 계속 실행되는 동안 임시 디렉토리에 압축 해제 된 jar를 삭제하지 않도록 운영 체제가 구성되었는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="533a38eeeef68b2a6dff0543d2d23fed7b8f462e" translate="yes" xml:space="preserve">
          <source>Cassandra</source>
          <target state="translated">Cassandra</target>
        </trans-unit>
        <trans-unit id="972004d9f7435cff4aa0b1f691eae8f7ee94576d" translate="yes" xml:space="preserve">
          <source>Certain resources do not necessarily need to trigger a restart when they are changed. For example, Thymeleaf templates can be edited in-place. By default, changing resources in &lt;code&gt;/META-INF/maven&lt;/code&gt;, &lt;code&gt;/META-INF/resources&lt;/code&gt;, &lt;code&gt;/resources&lt;/code&gt;, &lt;code&gt;/static&lt;/code&gt;, &lt;code&gt;/public&lt;/code&gt;, or &lt;code&gt;/templates&lt;/code&gt; does not trigger a restart but does trigger a &lt;a href=&quot;#using-boot-devtools-livereload&quot;&gt;live reload&lt;/a&gt;. If you want to customize these exclusions, you can use the &lt;code&gt;spring.devtools.restart.exclude&lt;/code&gt; property. For example, to exclude only &lt;code&gt;/static&lt;/code&gt; and &lt;code&gt;/public&lt;/code&gt; you would set the following property:</source>
          <target state="translated">특정 리소스가 변경 될 때 반드시 다시 시작을 트리거 할 필요는 없습니다. 예를 들어, Thymeleaf 템플릿은 제자리에서 편집 할 수 있습니다. 기본적으로 &lt;code&gt;/META-INF/maven&lt;/code&gt; , &lt;code&gt;/META-INF/resources&lt;/code&gt; , &lt;code&gt;/resources&lt;/code&gt; , &lt;code&gt;/static&lt;/code&gt; , &lt;code&gt;/public&lt;/code&gt; 또는 &lt;code&gt;/templates&lt;/code&gt; 에서 리소스를 변경 하면 다시 시작이 트리거되지 않지만 &lt;a href=&quot;#using-boot-devtools-livereload&quot;&gt;라이브 다시로드&lt;/a&gt; 가 트리거 됩니다. 이러한 제외를 사용자 정의하려면 &lt;code&gt;spring.devtools.restart.exclude&lt;/code&gt; 속성을 사용할 수 있습니다 . 예를 들어 &lt;code&gt;/static&lt;/code&gt; 및 &lt;code&gt;/public&lt;/code&gt; 만 제외 하려면 다음 속성을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a32a10c512a9b90c4c151a26cbfa7ca44b5f01d5" translate="yes" xml:space="preserve">
          <source>Change log configuration path.</source>
          <target state="translated">로그 구성 경로를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="0e3bffab48ee8cf222b228b1a2901c9263aff558" translate="yes" xml:space="preserve">
          <source>Change log parameters.</source>
          <target state="translated">로그 매개 변수를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ca8ebc507aecbcabcd583f3008b4b9a860180449" translate="yes" xml:space="preserve">
          <source>Character encoding to use to decode the URI.</source>
          <target state="translated">URI를 디코딩하는 데 사용할 문자 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="65e1109f5eef67a88e81d53b45625626156dd462" translate="yes" xml:space="preserve">
          <source>Character set used by the log file. Default to the system default character set.</source>
          <target state="translated">로그 파일에서 사용하는 문자 세트입니다. 기본값은 시스템 기본 문자 집합입니다.</target>
        </trans-unit>
        <trans-unit id="72e750a5d5f3f788fbeb2a8f92efa083692581c7" translate="yes" xml:space="preserve">
          <source>Charset to use for console output.</source>
          <target state="translated">콘솔 출력에 사용할 문자 집합입니다.</target>
        </trans-unit>
        <trans-unit id="96c0ba46632190498fbfb0f0425d41c95f53878d" translate="yes" xml:space="preserve">
          <source>Charset to use for file output.</source>
          <target state="translated">파일 출력에 사용할 문자 집합입니다.</target>
        </trans-unit>
        <trans-unit id="9eab9dc6a5b4b9f4e8ff500f5bc14e4bed8bfdf6" translate="yes" xml:space="preserve">
          <source>Charset used to decode URLs.</source>
          <target state="translated">URL을 디코딩하는 데 사용되는 문자 집합입니다.</target>
        </trans-unit>
        <trans-unit id="f5eb086078f001408fba7741b865a1ac619ea90d" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;deployment#cloud-deployment-kubernetes-container-lifecycle&quot;&gt;Kubernetes container lifecycle section&lt;/a&gt; for more information about Kubernetes deployment.</source>
          <target state="translated">Kubernetes 배포에 대한 자세한 내용은 Kubernetes &lt;a href=&quot;deployment#cloud-deployment-kubernetes-container-lifecycle&quot;&gt;컨테이너 수명주기 섹션&lt;/a&gt; 을 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="603a24eb404c8452a342eb9bcbbeb045de036afa" translate="yes" xml:space="preserve">
          <source>Check out the &lt;a href=&quot;https://www.cloudfoundry.org/&quot;&gt;Cloud Foundry&lt;/a&gt;, &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku&lt;/a&gt;, &lt;a href=&quot;https://www.openshift.com&quot;&gt;OpenShift&lt;/a&gt;, and &lt;a href=&quot;https://boxfuse.com&quot;&gt;Boxfuse&lt;/a&gt; web sites for more information about the kinds of features that a PaaS can offer. These are just four of the most popular Java PaaS providers. Since Spring Boot is so amenable to cloud-based deployment, you can freely consider other providers as well.</source>
          <target state="translated">아웃 확인 &lt;a href=&quot;https://www.cloudfoundry.org/&quot;&gt;클라우드 파운드리&lt;/a&gt; , &lt;a href=&quot;https://www.heroku.com/&quot;&gt;Heroku가&lt;/a&gt; , &lt;a href=&quot;https://www.openshift.com&quot;&gt;OpenShift&lt;/a&gt; 및 &lt;a href=&quot;https://boxfuse.com&quot;&gt;Boxfuse의&lt;/a&gt; PaaS를 제공 할 수있는 기능의 종류에 대한 자세한 내용은 웹 사이트를. 이들은 가장 인기있는 Java PaaS 공급자 중 4 개에 불과합니다. Spring Boot는 클라우드 기반 배포에 매우 적합하므로 다른 공급자도 자유롭게 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d739a4bda54fd00bc40971f9ad7c5c62e119e34" translate="yes" xml:space="preserve">
          <source>Check the &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/integration.html#cache&quot;&gt;relevant section&lt;/a&gt; of the Spring Framework reference for more details.</source>
          <target state="translated">자세한 내용은 Spring Framework 참조 의 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/integration.html#cache&quot;&gt;관련 섹션&lt;/a&gt; 을 확인 하십시오.</target>
        </trans-unit>
        <trans-unit id="07549036e64c17a3aaa1a8c74091de62d62c9127" translate="yes" xml:space="preserve">
          <source>Check the &lt;code&gt;spring.couchbase.env.*&lt;/code&gt; properties for more details. To take more control, one or more &lt;code&gt;ClusterEnvironmentBuilderCustomizer&lt;/code&gt; beans can be used.</source>
          <target state="translated">자세한 내용 은 &lt;code&gt;spring.couchbase.env.*&lt;/code&gt; 속성을 확인하십시오. 더 많은 제어를 위해 하나 이상의 &lt;code&gt;ClusterEnvironmentBuilderCustomizer&lt;/code&gt; Bean을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fd4ad1d109c048aaaab4ce1ac3c0bec4daeafc7" translate="yes" xml:space="preserve">
          <source>Checks for low disk space.</source>
          <target state="translated">디스크 공간이 부족한지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7a2385529edd5500b433bb3eea19712e0e9d20c0" translate="yes" xml:space="preserve">
          <source>Checks that a Cassandra database is up.</source>
          <target state="translated">Cassandra 데이터베이스가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c80e769ca40f670ad3292ee88a98940c1b33b422" translate="yes" xml:space="preserve">
          <source>Checks that a Couchbase cluster is up.</source>
          <target state="translated">Couchbase 클러스터가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="96aee82a494ab604a7ef9ee68257393f852f6e5d" translate="yes" xml:space="preserve">
          <source>Checks that a Hazelcast server is up.</source>
          <target state="translated">Hazelcast 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d04567bed2354b88d78e857944d04a30e2d484aa" translate="yes" xml:space="preserve">
          <source>Checks that a JMS broker is up.</source>
          <target state="translated">JMS 브로커가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dcd958012d31ecc04a5a6d2cf01c2c5cde675606" translate="yes" xml:space="preserve">
          <source>Checks that a Mongo database is up.</source>
          <target state="translated">Mongo 데이터베이스가 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="032f74372a2dfafd1b8462a3b071f26df8ab3f00" translate="yes" xml:space="preserve">
          <source>Checks that a Neo4j database is up.</source>
          <target state="translated">Neo4j 데이터베이스가 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e392d35b12287d692f49bddd68d8b76396d5d9fd" translate="yes" xml:space="preserve">
          <source>Checks that a Rabbit server is up.</source>
          <target state="translated">Rabbit 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="8fb26360159503c3c7f3f3f0de029e2815935c46" translate="yes" xml:space="preserve">
          <source>Checks that a Redis server is up.</source>
          <target state="translated">Redis 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0119935d8f164213e5cc42bebdaf9a5d75487725" translate="yes" xml:space="preserve">
          <source>Checks that a Solr server is up.</source>
          <target state="translated">Solr 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="af619c571706edb2dc046b05eb164c98d57c0984" translate="yes" xml:space="preserve">
          <source>Checks that a connection to &lt;code&gt;DataSource&lt;/code&gt; can be obtained.</source>
          <target state="translated">&lt;code&gt;DataSource&lt;/code&gt; 에 대한 연결을 얻을 수 있는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a1c0de2a3c4fae9adefdf631e304db12178e3df5" translate="yes" xml:space="preserve">
          <source>Checks that a mail server is up.</source>
          <target state="translated">메일 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6918183fddc79afa75053a32152533c41262bc89" translate="yes" xml:space="preserve">
          <source>Checks that an Elasticsearch cluster is up.</source>
          <target state="translated">Elasticsearch 클러스터가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dcd5b68ec2ae1c98763f8369b9cdaccc5c91fccf" translate="yes" xml:space="preserve">
          <source>Checks that an InfluxDB server is up.</source>
          <target state="translated">InfluxDB 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1403570530fdf1ad6ed1e533cc752ff3d496232e" translate="yes" xml:space="preserve">
          <source>Checks that an LDAP server is up.</source>
          <target state="translated">LDAP 서버가 작동 중인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="edefa9af97f9e0a86ea0794bbc3f488b13925399" translate="yes" xml:space="preserve">
          <source>Choice of strategy for matching request paths against registered mappings.</source>
          <target state="translated">등록 된 매핑에 대해 요청 경로를 일치시키기위한 전략 선택.</target>
        </trans-unit>
        <trans-unit id="a99d6c836754d30da946aa51c8a234d49f01bbec" translate="yes" xml:space="preserve">
          <source>Class Conditions</source>
          <target state="translated">수업 조건</target>
        </trans-unit>
        <trans-unit id="7a52ce9a28b8241dccfef7eec3f246e0fdf546ae" translate="yes" xml:space="preserve">
          <source>Class name of the servlet to use for JSPs. If registered is true and this class * is on the classpath then it will be registered.</source>
          <target state="translated">JSP에 사용할 서블릿의 클래스 이름입니다. 등록이 참이고이 클래스 *가 클래스 경로에 있으면 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="a77e5afacf2b793048da48a7a7e094b72a32876a" translate="yes" xml:space="preserve">
          <source>Cleanup the application&amp;rsquo;s local state directory on shutdown.</source>
          <target state="translated">종료시 응용 프로그램의 로컬 상태 디렉터리를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="2da26b7840099bde197b23222dcc5ff62dfd85d1" translate="yes" xml:space="preserve">
          <source>Cleanup the application&amp;rsquo;s local state directory on startup.</source>
          <target state="translated">시작시 응용 프로그램의 로컬 상태 디렉터리를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="d45519daddd79b9c41dc9befc4f7f809a9a0ecec" translate="yes" xml:space="preserve">
          <source>Client authentication mode. Requires a trust store.</source>
          <target state="translated">클라이언트 인증 모드. 신뢰 저장소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="56dd1c1b166cc7abc34d514f7d3653b3d73f9d5a" translate="yes" xml:space="preserve">
          <source>Client id used to authenticate with the token introspection endpoint.</source>
          <target state="translated">토큰 내부 검사 끝점으로 인증하는 데 사용되는 클라이언트 ID입니다.</target>
        </trans-unit>
        <trans-unit id="054aa61452fe7a75181f67d4739c3e50f4a0f937" translate="yes" xml:space="preserve">
          <source>Client name to be set on connections with CLIENT SETNAME.</source>
          <target state="translated">CLIENT SETNAME과의 연결에 설정할 클라이언트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="765741378d9decc0496ab0f56b703372e30791e6" translate="yes" xml:space="preserve">
          <source>Client provider type to use.</source>
          <target state="translated">사용할 클라이언트 공급자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="71ff83346ea785c693205bbc6d357ba1735cf63a" translate="yes" xml:space="preserve">
          <source>Client secret used to authenticate with the token introspection endpoint.</source>
          <target state="translated">토큰 내부 검사 끝점으로 인증하는 데 사용되는 클라이언트 암호입니다.</target>
        </trans-unit>
        <trans-unit id="a5e5c42257f38dd11494db49d578d0f45e506171" translate="yes" xml:space="preserve">
          <source>Cloud Deployment</source>
          <target state="translated">클라우드 배포</target>
        </trans-unit>
        <trans-unit id="9a2988f65d96777955574b3cf4c46f8861a3f947" translate="yes" xml:space="preserve">
          <source>Cloud Foundry provides default buildpacks that come into play if no other buildpack is specified. The Cloud Foundry &lt;a href=&quot;https://github.com/cloudfoundry/java-buildpack&quot;&gt;Java buildpack&lt;/a&gt; has excellent support for Spring applications, including Spring Boot. You can deploy stand-alone executable jar applications as well as traditional &lt;code&gt;.war&lt;/code&gt; packaged applications.</source>
          <target state="translated">Cloud Foundry는 다른 빌드 팩이 지정되지 않은 경우 작동하는 기본 빌드 팩을 제공합니다. Cloud Foundry &lt;a href=&quot;https://github.com/cloudfoundry/java-buildpack&quot;&gt;Java 빌드 팩&lt;/a&gt; 은 Spring Boot를 포함한 Spring 애플리케이션에 대한 탁월한 지원을 제공합니다. 독립형 실행 가능 jar 응용 프로그램과 기존 &lt;code&gt;.war&lt;/code&gt; 패키지 응용 프로그램을 배포 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e6836c49fd9d1693184822e0be23705eaa4c2f2a" translate="yes" xml:space="preserve">
          <source>Cluster node addresses in the form 'host:port', or a simple 'host' to use the configured port.</source>
          <target state="translated">'host : port'형식의 클러스터 노드 주소 또는 구성된 포트를 사용하는 간단한 'host'.</target>
        </trans-unit>
        <trans-unit id="f700e2f15cb7ce04a0674b5cda78f371bd75d791" translate="yes" xml:space="preserve">
          <source>Cluster password.</source>
          <target state="translated">클러스터 비밀번호.</target>
        </trans-unit>
        <trans-unit id="dde32136e1cbd4e2610b53fd4c4072c74668c91b" translate="yes" xml:space="preserve">
          <source>Cluster password. Randomly generated on startup by default.</source>
          <target state="translated">클러스터 비밀번호. 기본적으로 시작시 무작위로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="25f37900d59b16ca208a255b83ad3bb97b0ffb9d" translate="yes" xml:space="preserve">
          <source>Cluster topology refresh period.</source>
          <target state="translated">클러스터 토폴로지 새로 고침 기간.</target>
        </trans-unit>
        <trans-unit id="531fe66a4c77a3d7210edf8360022f3663e3717d" translate="yes" xml:space="preserve">
          <source>Cluster username.</source>
          <target state="translated">클러스터 사용자 이름.</target>
        </trans-unit>
        <trans-unit id="9d6b5f970ace9ba53ad9e45c0384561f1183fe5b" translate="yes" xml:space="preserve">
          <source>Code Structure</source>
          <target state="translated">코드 구조</target>
        </trans-unit>
        <trans-unit id="a52b7d8b564a097776aadda8ffec91578be7da83" translate="yes" xml:space="preserve">
          <source>Collection name used to store sessions.</source>
          <target state="translated">세션을 저장하는 데 사용되는 컬렉션 이름입니다.</target>
        </trans-unit>
        <trans-unit id="765898bb5640292f5cd2ea90765033bdce6d37ee" translate="yes" xml:space="preserve">
          <source>Collections and arrays can be accessed either through an index (typically with YAML) or by using a single comma-separated value (properties). In the latter case, a setter is mandatory. We recommend to always add a setter for such types. If you initialize a collection, make sure it is not immutable (as in the preceding example).</source>
          <target state="translated">컬렉션 및 배열은 인덱스 (일반적으로 YAML 사용)를 통해 또는 단일 쉼표로 구분 된 값 (속성)을 사용하여 액세스 할 수 있습니다. 후자의 경우 setter가 필수입니다. 이러한 유형에 대해서는 항상 setter를 추가하는 것이 좋습니다. 컬렉션을 초기화하는 경우 이전 예제에서와 같이 변경할 수 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1d0c8304baedcf8e3a78982c2e7c0b04622bf2a0" translate="yes" xml:space="preserve">
          <source>Color</source>
          <target state="translated">Color</target>
        </trans-unit>
        <trans-unit id="cab20ecdbeddaba6dff8f9f4d5b0931d2093fff8" translate="yes" xml:space="preserve">
          <source>Color coding is configured by using the &lt;code&gt;%clr&lt;/code&gt; conversion word. In its simplest form, the converter colors the output according to the log level, as shown in the following example:</source>
          <target state="translated">색 구분은 &lt;code&gt;%clr&lt;/code&gt; 변환 단어를 사용하여 구성됩니다 . 가장 간단한 형식으로 변환기는 다음 예와 같이 로그 수준에 따라 출력의 색상을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="da0ec87e4c8fa5ef26d1c9d8574905e647bd7be7" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Applies to all components unless overridden.</source>
          <target state="translated">Kafka 클러스터에 대한 초기 연결을 설정하는 데 사용할 호스트 : 포트 쌍의 쉼표로 구분 된 목록입니다. 재정의하지 않는 한 모든 구성 요소에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9be6b15f7a40aada7adb3b8ba65018a0599eed4" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for consumers.</source>
          <target state="translated">Kafka 클러스터에 대한 초기 연결을 설정하는 데 사용할 호스트 : 포트 쌍의 쉼표로 구분 된 목록입니다. 소비자의 경우 전역 속성을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="cbac66a513b02ad2cfd4887fb74efe952cef07fe" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for producers.</source>
          <target state="translated">Kafka 클러스터에 대한 초기 연결을 설정하는 데 사용할 호스트 : 포트 쌍의 쉼표로 구분 된 목록입니다. 생산자의 전역 속성을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="1e919cedacc699a6755060b436b143162d1ade80" translate="yes" xml:space="preserve">
          <source>Comma-delimited list of host:port pairs to use for establishing the initial connections to the Kafka cluster. Overrides the global property, for streams.</source>
          <target state="translated">Kafka 클러스터에 대한 초기 연결을 설정하는 데 사용할 호스트 : 포트 쌍의 쉼표로 구분 된 목록입니다. 스트림에 대한 전역 속성을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="cee08fa3a80ca1a9eb3046cc92286a5724817c62" translate="yes" xml:space="preserve">
          <source>Comma-separated Classpath, such as &lt;code&gt;lib,${HOME}/app/lib&lt;/code&gt;. Earlier entries take precedence, like a regular &lt;code&gt;-classpath&lt;/code&gt; on the &lt;code&gt;javac&lt;/code&gt; command line.</source>
          <target state="translated">&lt;code&gt;lib,${HOME}/app/lib&lt;/code&gt; 와 같이 쉼표로 구분 된 클래스 경로 입니다. 이전 항목은 정기적처럼, 우선 &lt;code&gt;-classpath&lt;/code&gt; 온 &lt;code&gt;javac&lt;/code&gt; 의의 명령 행.</target>
        </trans-unit>
        <trans-unit id="9e67352a88bd6ab90174d6ef1830907ab799ba6a" translate="yes" xml:space="preserve">
          <source>Comma-separated list of &quot;host:port&quot; pairs to bootstrap from. This represents an &quot;initial&quot; list of cluster nodes and is required to have at least one entry.</source>
          <target state="translated">부트 스트랩 할 &quot;host : port&quot;쌍의 쉼표로 구분 된 목록입니다. 이것은 클러스터 노드의 &quot;초기&quot;목록을 나타내며 하나 이상의 항목이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="08da31eb2619fd918fa77ccc27e7ad8ac22914d8" translate="yes" xml:space="preserve">
          <source>Comma-separated list of &quot;host:port&quot; pairs.</source>
          <target state="translated">&quot;host : port&quot;쌍의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="57df15f0fec4d056473fec5d623673715f4ce9dd" translate="yes" xml:space="preserve">
          <source>Comma-separated list of MIME types that should be compressed.</source>
          <target state="translated">압축해야하는 MIME 유형의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="13a10d5b8b5b78e7d33a5ed01e58536bdd7be86a" translate="yes" xml:space="preserve">
          <source>Comma-separated list of active profiles. Can be overridden by a command line switch.</source>
          <target state="translated">쉼표로 구분 된 활성 프로필 목록입니다. 명령 줄 스위치로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="795b277e6cec330464684acd8046ddf4e6f6da4a" translate="yes" xml:space="preserve">
          <source>Comma-separated list of additional patterns that match jars to ignore for TLD scanning. The special '?' and '*' characters can be used in the pattern to match one and only one character and zero or more characters respectively.</source>
          <target state="translated">TLD 스캔을 위해 무시할 jar와 일치하는 추가 패턴의 쉼표로 구분 된 목록입니다. 특별한 '?' 및 '*'문자를 패턴에 사용하여 각각 하나의 문자와 0 개 이상의 문자를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88df32c9fcb429c55d9227ea8bc4ac53dbadf4b8" translate="yes" xml:space="preserve">
          <source>Comma-separated list of additional unencoded characters that should be allowed in URI paths. Only &quot;&amp;lt; &amp;gt; [ \ ] ^ ` { | }&quot; are allowed.</source>
          <target state="translated">URI 경로에 허용되어야하는 인코딩되지 않은 추가 문자의 쉼표로 구분 된 목록입니다. &quot;&amp;lt;&amp;gt; [\] ^`{|}&quot;만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="0975fa8c4ca83f0a7c1252cf9039482205aaa400" translate="yes" xml:space="preserve">
          <source>Comma-separated list of additional unencoded characters that should be allowed in URI query strings. Only &quot;&amp;lt; &amp;gt; [ \ ] ^ ` { | }&quot; are allowed.</source>
          <target state="translated">URI 쿼리 문자열에서 허용되어야하는 인코딩되지 않은 추가 문자의 쉼표로 구분 된 목록입니다. &quot;&amp;lt;&amp;gt; [\] ^`{|}&quot;만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5b8c10d343b93c1db83b117025f48654727988a" translate="yes" xml:space="preserve">
          <source>Comma-separated list of addresses to which the client should connect. When set, the host and port are ignored.</source>
          <target state="translated">클라이언트가 연결해야하는 쉼표로 구분 된 주소 목록입니다. 설정되면 호스트와 포트가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d7a7587034b469b15846abf308d8a8b7fc905b6e" translate="yes" xml:space="preserve">
          <source>Comma-separated list of basenames (essentially a fully-qualified classpath location), each following the ResourceBundle convention with relaxed support for slash based locations. If it doesn't contain a package qualifier (such as &quot;org.mypackage&quot;), it will be resolved from the classpath root.</source>
          <target state="translated">쉼표로 구분 된 기본 이름 목록 (본질적으로 정규화 된 클래스 경로 위치), 각각 슬래시 기반 위치에 대한 완화 된 지원과 함께 ResourceBundle 규칙을 따릅니다. 패키지 한정자 (예 : &quot;org.mypackage&quot;)가 포함되지 않은 경우 클래스 경로 루트에서 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="3db996ef1e960c279665c250e6e87e0b14e61edb" translate="yes" xml:space="preserve">
          <source>Comma-separated list of cache names to create if supported by the underlying cache manager. Usually, this disables the ability to create additional caches on-the-fly.</source>
          <target state="translated">기본 캐시 관리자에서 지원하는 경우 작성할 쉼표로 구분 된 캐시 이름 목록입니다. 일반적으로 이렇게하면 즉시 추가 캐시를 만드는 기능이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b9b3a776647c0d34e0cf405b0afe4129e0b052d7" translate="yes" xml:space="preserve">
          <source>Comma-separated list of features to enable. Uses the defaults of the configured version by default.</source>
          <target state="translated">활성화 할 기능의 쉼표로 구분 된 목록입니다. 기본적으로 구성된 버전의 기본값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="12f51c5c19adb2d938f3f9ef19c1906001910e24" translate="yes" xml:space="preserve">
          <source>Comma-separated list of headers to allow in a request. '*' allows all headers.</source>
          <target state="translated">요청에서 허용 할 쉼표로 구분 된 헤더 목록입니다. '*'는 모든 헤더를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b6b5a2956f7470e50e08285a248f8542647f89a7" translate="yes" xml:space="preserve">
          <source>Comma-separated list of headers to include in a response.</source>
          <target state="translated">응답에 포함 할 쉼표로 구분 된 헤더 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d908fb9853e451ae69d3d3b62c25450833603593" translate="yes" xml:space="preserve">
          <source>Comma-separated list of health statuses in order of severity.</source>
          <target state="translated">심각도 순서대로 쉼표로 구분 된 상태 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8e734db178bf35c1f75930228fae84b1f782d31b" translate="yes" xml:space="preserve">
          <source>Comma-separated list of job names to execute on startup (for instance, `job1,job2`). By default, all Jobs found in the context are executed.</source>
          <target state="translated">시작시 실행할 작업 이름의 쉼표로 구분 된 목록 (예 :`job1, job2`)입니다. 기본적으로 컨텍스트에서 찾은 모든 작업이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="76dcbcbfaee9de62bde8da795c79d92cee97dc97" translate="yes" xml:space="preserve">
          <source>Comma-separated list of locations of WSDLs and accompanying XSDs to be exposed as beans.</source>
          <target state="translated">Bean으로 노출 될 WSDL 및 동반 XSD 위치의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9098cb84b354d7de4231adce7707cf38c17bfce5" translate="yes" xml:space="preserve">
          <source>Comma-separated list of methods to allow. '*' allows all methods. When not set, defaults to GET.</source>
          <target state="translated">허용 할 메서드의 쉼표로 구분 된 목록입니다. '*'는 모든 방법을 허용합니다. 설정되지 않은 경우 기본값은 GET입니다.</target>
        </trans-unit>
        <trans-unit id="3a16052fddc32853e760474b3d7854981c2c6b87" translate="yes" xml:space="preserve">
          <source>Comma-separated list of origins to allow. '*' allows all origins. When not set, CORS support is disabled.</source>
          <target state="translated">허용 할 쉼표로 구분 된 출처 목록입니다. '*'는 모든 출처를 허용합니다. 설정하지 않으면 CORS 지원이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="6a88566cbbffacb5f415ae80c4ead9ddada07285" translate="yes" xml:space="preserve">
          <source>Comma-separated list of patterns to apply to the content Version Strategy.</source>
          <target state="translated">콘텐츠 버전 전략에 적용 할 쉼표로 구분 된 패턴 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f7db94fe331ef151b5084a28adf3e3d67ca88eb9" translate="yes" xml:space="preserve">
          <source>Comma-separated list of patterns to apply to the fixed Version Strategy.</source>
          <target state="translated">고정 버전 전략에 적용 할 쉼표로 구분 된 패턴 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9b9808343be7c08c2b308137c51c6977efbcc691" translate="yes" xml:space="preserve">
          <source>Comma-separated list of queues to create on startup.</source>
          <target state="translated">시작시 생성 할 쉼표로 구분 된 큐 목록입니다.</target>
        </trans-unit>
        <trans-unit id="76e0f2ad86f1b1b1ccaf30c8a615f26a3e91da36" translate="yes" xml:space="preserve">
          <source>Comma-separated list of runtime contexts to use.</source>
          <target state="translated">사용할 런타임 컨텍스트의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="92f848245770862afb358be28ce710779e53e809" translate="yes" xml:space="preserve">
          <source>Comma-separated list of runtime labels to use.</source>
          <target state="translated">사용할 런타임 레이블의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9d50911783c28b862d78bc22ff3f6527d25fb7d9" translate="yes" xml:space="preserve">
          <source>Comma-separated list of specific packages to trust (when not trusting all packages).</source>
          <target state="translated">신뢰할 수있는 특정 패키지의 쉼표로 구분 된 목록 (모든 패키지를 신뢰하지 않는 경우).</target>
        </trans-unit>
        <trans-unit id="37b890cdb3b537ad26bfdb9aa78bbd44f8268c7a" translate="yes" xml:space="preserve">
          <source>Comma-separated list of template paths.</source>
          <target state="translated">쉼표로 구분 된 템플릿 경로 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1e5d54f43eb63a5fcf38c4ec3f0272671251786c" translate="yes" xml:space="preserve">
          <source>Comma-separated list of the Elasticsearch endpoints to connect to.</source>
          <target state="translated">연결할 Elasticsearch 엔드 포인트의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="70c0933f02426de181e345a3cac9fb2bd5d3e424" translate="yes" xml:space="preserve">
          <source>Comma-separated list of the Elasticsearch instances to use.</source>
          <target state="translated">사용할 Elasticsearch 인스턴스의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4b1812c624b183fb9b97d5e814e50afc7f1a2bb8" translate="yes" xml:space="preserve">
          <source>Comma-separated list of topics to create on startup.</source>
          <target state="translated">시작할 때 만들 항목의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="8d3720bd9688afd2b217f961c2c35585cb915678" translate="yes" xml:space="preserve">
          <source>Comma-separated list of user agents for which responses should not be compressed.</source>
          <target state="translated">응답을 압축하지 않아야하는 사용자 에이전트의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ba0eb553f8da75cc8ff2e3a66a821e14e093dd89" translate="yes" xml:space="preserve">
          <source>Comma-separated list of view names (patterns allowed) that can be resolved.</source>
          <target state="translated">확인할 수있는 쉼표로 구분 된보기 이름 (패턴 허용) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6a43bd5ae11abebbac1675e3da42a1c32f6eebfb" translate="yes" xml:space="preserve">
          <source>Comma-separated list of view names (patterns allowed) that should be excluded from resolution.</source>
          <target state="translated">확인에서 제외되어야하는 쉼표로 구분 된보기 이름 (패턴 허용) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1de7d6d9163f0a4a6eac67ecd2c69bf6ce702bd3" translate="yes" xml:space="preserve">
          <source>Comma-separated list of view names (patterns allowed) that should be executed in FULL mode even if a max chunk size is set.</source>
          <target state="translated">최대 청크 크기가 설정되어 있어도 FULL 모드에서 실행해야하는 쉼표로 구분 된보기 이름 (패턴 허용) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4de0e2cde505dcc4bb2cfffb1eae28a8720431f7" translate="yes" xml:space="preserve">
          <source>Comma-separated list of view names (patterns allowed) that should be the only ones executed in CHUNKED mode when a max chunk size is set.</source>
          <target state="translated">최대 청크 크기가 설정되어있을 때 CHUNKED 모드에서 실행되는 유일한 뷰 이름 (패턴 허용)의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="f779370fd0ebdedacebfd4aa52dd2624412d990b" translate="yes" xml:space="preserve">
          <source>Command line arguments.</source>
          <target state="translated">명령 줄 인수.</target>
        </trans-unit>
        <trans-unit id="3778412a5b52822958dd392f9b13ea26b5c93deb" translate="yes" xml:space="preserve">
          <source>Comment for the session cookie.</source>
          <target state="translated">세션 쿠키에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="bb76c750132fc396a6177d362fbcd25630d3b01d" translate="yes" xml:space="preserve">
          <source>Common Application properties</source>
          <target state="translated">일반적인 응용 프로그램 속성</target>
        </trans-unit>
        <trans-unit id="5d01f5305b09f1e2e4f5f90d4c08c25769bf47c2" translate="yes" xml:space="preserve">
          <source>Common application properties that can be used to configure your application.</source>
          <target state="translated">애플리케이션을 구성하는 데 사용할 수있는 공통 애플리케이션 속성입니다.</target>
        </trans-unit>
        <trans-unit id="18b2370374c1ef5da167e40eea4aef99938e56b3" translate="yes" xml:space="preserve">
          <source>Common server settings include:</source>
          <target state="translated">일반적인 서버 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2bf5206db21392859b999102549b4f59c9ca7b13" translate="yes" xml:space="preserve">
          <source>Common servlet container settings can be configured by using Spring &lt;code&gt;Environment&lt;/code&gt; properties. Usually, you would define the properties in your &lt;code&gt;application.properties&lt;/code&gt; or &lt;code&gt;application.yaml&lt;/code&gt; file.</source>
          <target state="translated">공통 서블릿 컨테이너 설정은 Spring &lt;code&gt;Environment&lt;/code&gt; 속성 을 사용하여 구성 할 수 있습니다 . 일반적으로 &lt;code&gt;application.properties&lt;/code&gt; 또는 &lt;code&gt;application.yaml&lt;/code&gt; 파일 에서 속성을 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="9d3565f560a7f50e2a04ec5edc4642a5227fb62f" translate="yes" xml:space="preserve">
          <source>Common tags are generally used for dimensional drill-down on the operating environment like host, instance, region, stack, etc. Commons tags are applied to all meters and can be configured as shown in the following example:</source>
          <target state="translated">공통 태그는 일반적으로 호스트, 인스턴스, 지역, 스택 등과 같은 운영 환경에서 차원 드릴 다운에 사용됩니다. 공통 태그는 모든 미터에 적용되며 다음 예와 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f32f65a4d76ef706ec95e9cd419733922aaa5af1" translate="yes" xml:space="preserve">
          <source>Common tags that are applied to every meter.</source>
          <target state="translated">모든 미터에 적용되는 공통 태그.</target>
        </trans-unit>
        <trans-unit id="5227e2b333b182820a105b24addbaa7a53e8d7bb" translate="yes" xml:space="preserve">
          <source>Commons DBCP2 specific settings bound to an instance of DBCP2's BasicDataSource</source>
          <target state="translated">DBCP2의 BasicDataSource 인스턴스에 바인드 된 Commons DBCP2 특정 설정</target>
        </trans-unit>
        <trans-unit id="3faaee8ad905672227933c79a3f478c5df201324" translate="yes" xml:space="preserve">
          <source>Compression supported by the Cassandra binary protocol.</source>
          <target state="translated">Cassandra 바이너리 프로토콜에서 지원하는 압축.</target>
        </trans-unit>
        <trans-unit id="4c84eb4fb6a308a6ed43fb82edbf51254c7e1d84" translate="yes" xml:space="preserve">
          <source>Compression type for all data generated by the producer.</source>
          <target state="translated">생산자가 생성 한 모든 데이터의 압축 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8af329a3546af8ca95a5d488691a53e1b46a5775" translate="yes" xml:space="preserve">
          <source>Computed non-aggregable percentiles to publish.</source>
          <target state="translated">게시 할 집계 할 수없는 백분위 수를 계산했습니다.</target>
        </trans-unit>
        <trans-unit id="a7772eecc64e30259d7ac28131f4f1be766873f2" translate="yes" xml:space="preserve">
          <source>Concretely, a custom starter can contain the following:</source>
          <target state="translated">구체적으로 커스텀 스타터에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a54a7ebd920c29fff64ba2d5428cd91b13d3e669" translate="yes" xml:space="preserve">
          <source>Config data (such as &lt;code&gt;application.properties&lt;/code&gt; files)</source>
          <target state="translated">구성 데이터 (예 : &lt;code&gt;application.properties&lt;/code&gt; 파일)</target>
        </trans-unit>
        <trans-unit id="f4dce69868bc7fcd2b209ee8a9ef077e5a4ce583" translate="yes" xml:space="preserve">
          <source>Config data files are considered in the following order:</source>
          <target state="translated">구성 데이터 파일은 다음 순서로 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="f1a79f65ec1a8ed54f5c07b7f344a1b151036e71" translate="yes" xml:space="preserve">
          <source>Config file locations that replace the defaults.</source>
          <target state="translated">기본값을 대체하는 구성 파일 위치.</target>
        </trans-unit>
        <trans-unit id="9dc80578f7a0a9bcb1d5879bf0bb00b38e1382e1" translate="yes" xml:space="preserve">
          <source>Config file locations used in addition to the defaults.</source>
          <target state="translated">기본값 외에 사용되는 구성 파일 위치입니다.</target>
        </trans-unit>
        <trans-unit id="283f99719e244586d5f5d4c0022275f8a1df400b" translate="yes" xml:space="preserve">
          <source>Config file name.</source>
          <target state="translated">구성 파일 이름.</target>
        </trans-unit>
        <trans-unit id="96eab012efd1a6748f8c232ffae299723d95ccdf" translate="yes" xml:space="preserve">
          <source>Configuration Class</source>
          <target state="translated">구성 클래스</target>
        </trans-unit>
        <trans-unit id="c07561232d3f8e0dc4a58aea9a9cc544972aa5dd" translate="yes" xml:space="preserve">
          <source>Configuration Metadata</source>
          <target state="translated">구성 메타 데이터</target>
        </trans-unit>
        <trans-unit id="7ff39198b6b34dc3de99bf5f3bede2bc6c65fa46" translate="yes" xml:space="preserve">
          <source>Configuration metadata files are located inside jars under &lt;code&gt;META-INF/spring-configuration-metadata.json&lt;/code&gt;. They use a JSON format with items categorized under either &amp;ldquo;groups&amp;rdquo; or &amp;ldquo;properties&amp;rdquo; and additional values hints categorized under &quot;hints&quot;, as shown in the following example:</source>
          <target state="translated">구성 메타 데이터 파일은 &lt;code&gt;META-INF/spring-configuration-metadata.json&lt;/code&gt; 아래의 jar 안에 있습니다 . 다음 예제와 같이 &quot;그룹&quot;또는 &quot;속성&quot;으로 분류 된 항목과 &quot;힌트&quot;로 분류 된 추가 값 힌트가 포함 된 JSON 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7dd9aa81501afbedb7983e5ee3e462402c48a1d7" translate="yes" xml:space="preserve">
          <source>Configuration tree values can be bound to both string &lt;code&gt;String&lt;/code&gt; and &lt;code&gt;byte[]&lt;/code&gt; types depending on the contents expected.</source>
          <target state="translated">구성 트리 값은 예상되는 내용에 따라 문자열 &lt;code&gt;String&lt;/code&gt; 및 &lt;code&gt;byte[]&lt;/code&gt; 유형 모두에 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="60aaef8a0f348e17d510f01f8de93c15c981a31f" translate="yes" xml:space="preserve">
          <source>Configure a property name on the &lt;code&gt;@EmbeddedKafka&lt;/code&gt; annotation:</source>
          <target state="translated">&lt;code&gt;@EmbeddedKafka&lt;/code&gt; 주석 에서 속성 이름을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="b3358b4d4fd103aa292d14727a1e14302c00bb91" translate="yes" xml:space="preserve">
          <source>Configures the ANSI output.</source>
          <target state="translated">ANSI 출력을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="42305eb2c4d9ecbc3916054a1813ba3d9eb65ab0" translate="yes" xml:space="preserve">
          <source>Configuring codecs for &lt;code&gt;HttpMessageReader&lt;/code&gt; and &lt;code&gt;HttpMessageWriter&lt;/code&gt; instances (described &lt;a href=&quot;#boot-features-webflux-httpcodecs&quot;&gt;later in this document&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;HttpMessageReader&lt;/code&gt; 및 &lt;code&gt;HttpMessageWriter&lt;/code&gt; 인스턴스 용 코덱 구성 ( &lt;a href=&quot;#boot-features-webflux-httpcodecs&quot;&gt;이 문서의 뒷부분에서&lt;/a&gt; 설명 )</target>
        </trans-unit>
        <trans-unit id="d3699e50efeb4e731f1769c42091fee642ed4437" translate="yes" xml:space="preserve">
          <source>Configuring the &lt;code&gt;DispatcherServlet&lt;/code&gt; yourself is unusual but if you really need to do it, a &lt;code&gt;@Bean&lt;/code&gt; of type &lt;code&gt;DispatcherServletPath&lt;/code&gt; must be provided as well to provide the path of your custom &lt;code&gt;DispatcherServlet&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DispatcherServlet&lt;/code&gt; 을 직접 구성하는 것은 드문 일이지만 실제로 수행해야하는 경우 사용자 정의 &lt;code&gt;DispatcherServlet&lt;/code&gt; 의 경로를 제공하기 위해 &lt;code&gt;DispatcherServletPath&lt;/code&gt; 유형 의 &lt;code&gt;@Bean&lt;/code&gt; 도 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f66bb70c416d06a1607fca278f007138506119b2" translate="yes" xml:space="preserve">
          <source>Congratulations! The application is now live!</source>
          <target state="translated">축하합니다! 이제 응용 프로그램이 활성화되었습니다!</target>
        </trans-unit>
        <trans-unit id="e6fb82df3af4c9f42b226dc08476092163effdf7" translate="yes" xml:space="preserve">
          <source>Connection URL. Overrides host, port, and password. User is ignored. Example: redis://user:password@example.com:6379</source>
          <target state="translated">연결 URL. 호스트, 포트 및 암호를 무시합니다. 사용자는 무시됩니다. 예 : redis : // user : password@example.com : 6379</target>
        </trans-unit>
        <trans-unit id="8cb155c39beb6ec79ef439475547816e1cb8efa5" translate="yes" xml:space="preserve">
          <source>Connection factory JNDI name. When set, takes precedence to others connection factory auto-configurations.</source>
          <target state="translated">연결 팩토리 JNDI 이름입니다. 설정되면 다른 연결 팩토리 자동 구성보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="a5c8d1d7a0d6ae95e88f44fb9fbb558e7a40042d" translate="yes" xml:space="preserve">
          <source>Connection factory cache mode.</source>
          <target state="translated">연결 팩토리 캐시 모드.</target>
        </trans-unit>
        <trans-unit id="0239c5f874296f884b22514c45e19116fcdfa925" translate="yes" xml:space="preserve">
          <source>Connection idle timeout.</source>
          <target state="translated">연결 유휴 시간 초과.</target>
        </trans-unit>
        <trans-unit id="c87c22db413c55cd324b852af34bf521b4dcf7ef" translate="yes" xml:space="preserve">
          <source>Connection string used to locate the Couchbase cluster.</source>
          <target state="translated">Couchbase 클러스터를 찾는 데 사용되는 연결 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="14cc570342f5c222b99bf098152695f377476cd7" translate="yes" xml:space="preserve">
          <source>Connection timeout for requests to this backend.</source>
          <target state="translated">이 백엔드에 대한 요청의 연결 제한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="6fc0d3002d1d61f94c15a83ac6daafa27bdce32a" translate="yes" xml:space="preserve">
          <source>Connection timeout of the Netty channel.</source>
          <target state="translated">Netty 채널의 연결 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="8aad134578861bda47f8aab9226db95c68ddef62" translate="yes" xml:space="preserve">
          <source>Connection timeout.</source>
          <target state="translated">접속 시간 초과.</target>
        </trans-unit>
        <trans-unit id="b9c7503ac00935612233645d15dc183cc04749c2" translate="yes" xml:space="preserve">
          <source>Connection timeout. Set it to zero to wait forever.</source>
          <target state="translated">접속 시간 초과. 영원히 기다리려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fa5c1804d7a304d633fa30e8499848b32afe469e" translate="yes" xml:space="preserve">
          <source>Consider the following configuration:</source>
          <target state="translated">다음 구성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d7f69e049d11cfea430a186ac01ffac1bca0cfc8" translate="yes" xml:space="preserve">
          <source>Consider the following example:</source>
          <target state="translated">다음 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="187f7abef3f987130d4014962a4b3529c88af6ff" translate="yes" xml:space="preserve">
          <source>Console only logging.</source>
          <target state="translated">콘솔 전용 로깅.</target>
        </trans-unit>
        <trans-unit id="9442fa17ab7ed262fd07b261eff648dd9b1bd47b" translate="yes" xml:space="preserve">
          <source>Consumes</source>
          <target state="translated">Consumes</target>
        </trans-unit>
        <trans-unit id="4560298d5bdfa4819fa013666b18762371d4b4c7" translate="yes" xml:space="preserve">
          <source>Content type to use as a default when none is specified.</source>
          <target state="translated">지정되지 않은 경우 기본값으로 사용할 콘텐츠 유형입니다.</target>
        </trans-unit>
        <trans-unit id="aa28ec75f0a9bed3e53d209b009a7484c0ff4bd8" translate="yes" xml:space="preserve">
          <source>Content-Type value written to HTTP responses.</source>
          <target state="translated">HTTP 응답에 기록 된 Content-Type 값입니다.</target>
        </trans-unit>
        <trans-unit id="e664ea60c272543452cd42b69b9f04ee94cb4c0b" translate="yes" xml:space="preserve">
          <source>Content-Type value.</source>
          <target state="translated">Content-Type 값.</target>
        </trans-unit>
        <trans-unit id="e5900c559b40f9634cf809a7f35455cc9f0dcb2b" translate="yes" xml:space="preserve">
          <source>Context path of the application.</source>
          <target state="translated">애플리케이션의 컨텍스트 경로입니다.</target>
        </trans-unit>
        <trans-unit id="6cdbb386fcec104eb2aab3688142412d727e8d96" translate="yes" xml:space="preserve">
          <source>Context path used to handle the remote connection.</source>
          <target state="translated">원격 연결을 처리하는 데 사용되는 컨텍스트 경로입니다.</target>
        </trans-unit>
        <trans-unit id="8fae269cb92350596d68e161a4ce2ffc2ecaee87" translate="yes" xml:space="preserve">
          <source>Continuation timeout for RPC calls in channels. Set it to zero to wait forever.</source>
          <target state="translated">채널의 RPC 호출에 대한 연속 시간 초과. 영원히 기다리려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="2b49bd184660b0eb6241d24713dbe53663313c47" translate="yes" xml:space="preserve">
          <source>Control flag for login configuration.</source>
          <target state="translated">로그인 구성을위한 제어 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="f0a0f9f2da39e87d721f7ce4b17fe15dfe9f6912" translate="yes" xml:space="preserve">
          <source>Controls the inclusion of properties during serialization. Configured with one of the values in Jackson's JsonInclude.Include enumeration.</source>
          <target state="translated">직렬화 중 속성 포함을 제어합니다. Jackson의 JsonInclude.Include 열거에있는 값 중 하나로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b56426edbe57dd4ed73972685d71074d89e069" translate="yes" xml:space="preserve">
          <source>Conversion word used when logging exceptions.</source>
          <target state="translated">예외를 로깅 할 때 사용되는 변환 단어입니다.</target>
        </trans-unit>
        <trans-unit id="822126bfb5238a961bf385930cc2bbca839c9eab" translate="yes" xml:space="preserve">
          <source>Convert to uppercase.</source>
          <target state="translated">대문자로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="18f2d527e702f04d61ecbacdc15be60d928e7ea4" translate="yes" xml:space="preserve">
          <source>Converting Data Sizes</source>
          <target state="translated">데이터 크기 변환</target>
        </trans-unit>
        <trans-unit id="4d36a479595918d519ceca170c3e18c2d1ed137e" translate="yes" xml:space="preserve">
          <source>Converting durations</source>
          <target state="translated">기간 변환</target>
        </trans-unit>
        <trans-unit id="b12fcfb7ad016c98007a04cd36e8da73a63bd941" translate="yes" xml:space="preserve">
          <source>Converting periods</source>
          <target state="translated">기간 변환</target>
        </trans-unit>
        <trans-unit id="5efcc51019780bfdab94906bb0bf45479bc7823b" translate="yes" xml:space="preserve">
          <source>Cookies are ignored (so the template is stateless).</source>
          <target state="translated">쿠키는 무시됩니다 (따라서 템플릿은 상태 비 저장입니다).</target>
        </trans-unit>
        <trans-unit id="51ffe1f1a71b8bc6ee609ed893650cbc7c2a2273" translate="yes" xml:space="preserve">
          <source>Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.</source>
          <target state="translated">이 문서의 사본은 귀하가 직접 사용하고 다른 사람에게 배포하기 위해 만들어 질 수 있습니다. 단, 해당 사본에 대해 요금을 부과하지 않고 각 사본에이 저작권 고지가 인쇄로 배포 되든 전자적으로 배포 되든 상관없이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="910fde5ff8d87e7f4514556213806ae6522b4c78" translate="yes" xml:space="preserve">
          <source>Copyright &amp;copy; 2002&amp;ndash;2020 Pivotal, Inc. All Rights Reserved.</source>
          <target state="translated">저작권 &amp;copy; 2002&amp;ndash;2020 Pivotal, Inc. 모든 권리 보유.</target>
        </trans-unit>
        <trans-unit id="6699171cb1cc0506ca513189ebf32cca05c777e1" translate="yes" xml:space="preserve">
          <source>Core number of threads.</source>
          <target state="translated">스레드의 코어 수.</target>
        </trans-unit>
        <trans-unit id="d526ef7ad280021fb17d69c8ea6807dc0b2ba68e" translate="yes" xml:space="preserve">
          <source>Core starter, including auto-configuration support, logging and YAML</source>
          <target state="translated">자동 구성 지원, 로깅 및 YAML을 포함한 핵심 스타터</target>
        </trans-unit>
        <trans-unit id="9304cdd066efa64f78387e9cc9240a70527271bc" translate="yes" xml:space="preserve">
          <source>Couchbase</source>
          <target state="translated">Couchbase</target>
        </trans-unit>
        <trans-unit id="245c54ff773d1f46a8e7f15ba5571211b6f1d7ce" translate="yes" xml:space="preserve">
          <source>Counting mode.</source>
          <target state="translated">계산 모드.</target>
        </trans-unit>
        <trans-unit id="cde666089dc8b94534654d558d815eda1fc7a2d3" translate="yes" xml:space="preserve">
          <source>Create a file called &lt;code&gt;application.yml&lt;/code&gt; and put it in the root of your classpath. Then add &lt;code&gt;snakeyaml&lt;/code&gt; to your dependencies (Maven coordinates &lt;code&gt;org.yaml:snakeyaml&lt;/code&gt;, already included if you use the &lt;code&gt;spring-boot-starter&lt;/code&gt;). A YAML file is parsed to a Java &lt;code&gt;Map&amp;lt;String,Object&amp;gt;&lt;/code&gt; (like a JSON object), and Spring Boot flattens the map so that it is one level deep and has period-separated keys, as many people are used to with &lt;code&gt;Properties&lt;/code&gt; files in Java.</source>
          <target state="translated">&lt;code&gt;application.yml&lt;/code&gt; 이라는 파일을 만들고 클래스 경로의 루트에 넣습니다. 그런 다음 종속 항목 에 &lt;code&gt;snakeyaml&lt;/code&gt; 을 추가 하십시오 ( &lt;code&gt;spring-boot-starter&lt;/code&gt; 를 사용하는 경우 이미 포함되어있는 Maven 좌표 &lt;code&gt;org.yaml:snakeyaml&lt;/code&gt; ). YAML 파일은 Java &lt;code&gt;Map&amp;lt;String,Object&amp;gt;&lt;/code&gt; (JSON 객체와 같은 )로 구문 분석 되고 Spring Boot는 맵을 평면화하여 많은 사람들이 &lt;code&gt;Properties&lt;/code&gt; 파일에 익숙해 지므로 한 수준 깊이가되고 마침표로 구분 된 키를 갖습니다. 자바에서.</target>
        </trans-unit>
        <trans-unit id="c317b6610a2a762d003462b6974b6bc1bc56531e" translate="yes" xml:space="preserve">
          <source>Create a new &lt;code&gt;Java Application&lt;/code&gt; &amp;ldquo;launch configuration&amp;rdquo;.</source>
          <target state="translated">새 &lt;code&gt;Java Application&lt;/code&gt; &quot;시작 구성&quot;을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="689ce8a243b818c3d398aaa608bf7440a97b3048" translate="yes" xml:space="preserve">
          <source>Creating a custom &lt;code&gt;error.jsp&lt;/code&gt; page does not override the default view for &lt;a href=&quot;#boot-features-error-handling&quot;&gt;error handling&lt;/a&gt;. &lt;a href=&quot;#boot-features-error-handling-custom-error-pages&quot;&gt;Custom error pages&lt;/a&gt; should be used instead.</source>
          <target state="translated">사용자 정의 &lt;code&gt;error.jsp&lt;/code&gt; 페이지를 생성 해도 &lt;a href=&quot;#boot-features-error-handling&quot;&gt;오류 처리를&lt;/a&gt; 위한 기본보기가 재정의되지 않습니다 . 대신 &lt;a href=&quot;#boot-features-error-handling-custom-error-pages&quot;&gt;사용자 지정 오류 페이지를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b9da7ea530068779ff9d27f3b38206270a8d6abb" translate="yes" xml:space="preserve">
          <source>Credentials password.</source>
          <target state="translated">자격 증명 암호.</target>
        </trans-unit>
        <trans-unit id="8af3baf9b4554b13aa0109cc402a4bae7837b30a" translate="yes" xml:space="preserve">
          <source>Credentials username.</source>
          <target state="translated">자격 증명 사용자 이름.</target>
        </trans-unit>
        <trans-unit id="56f93fa4129d507ae58aa648e4653d1e6ba4ae14" translate="yes" xml:space="preserve">
          <source>Cron expression for expired session cleanup job.</source>
          <target state="translated">만료 된 세션 정리 작업에 대한 Cron 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="a81cf7757742eaf9f0864294dbcf9e7309a791ff" translate="yes" xml:space="preserve">
          <source>Currently, Spring Security does not provide support for implementing an OAuth 2.0 Authorization Server. However, this functionality is available from the &lt;a href=&quot;https://spring.io/projects/spring-security-oauth&quot;&gt;Spring Security OAuth&lt;/a&gt; project, which will eventually be superseded by Spring Security completely. Until then, you can use the &lt;code&gt;spring-security-oauth2-autoconfigure&lt;/code&gt; module to easily set up an OAuth 2.0 authorization server; see its &lt;a href=&quot;https://docs.spring.io/spring-security-oauth2-boot/&quot;&gt;documentation&lt;/a&gt; for instructions.</source>
          <target state="translated">현재 Spring Security는 OAuth 2.0 Authorization Server 구현을 지원하지 않습니다. 그러나이 기능은 &lt;a href=&quot;https://spring.io/projects/spring-security-oauth&quot;&gt;Spring Security OAuth&lt;/a&gt; 프로젝트 에서 사용할 수 있으며 결국 Spring Security로 완전히 대체됩니다. 그때까지는 &lt;code&gt;spring-security-oauth2-autoconfigure&lt;/code&gt; 모듈을 사용하여 OAuth 2.0 인증 서버를 쉽게 설정할 수 있습니다. 지침 은 &lt;a href=&quot;https://docs.spring.io/spring-security-oauth2-boot/&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8394a6d089573458fed901e2364c860b5809ed9b" translate="yes" xml:space="preserve">
          <source>Custom Error Pages</source>
          <target state="translated">사용자 정의 오류 페이지</target>
        </trans-unit>
        <trans-unit id="9e21be22a3254b4156b2e56b573050add0cefc03" translate="yes" xml:space="preserve">
          <source>Custom error pages</source>
          <target state="translated">맞춤 오류 페이지</target>
        </trans-unit>
        <trans-unit id="e2342f2ece8702ff63f42391500f9acc8e63bbca" translate="yes" xml:space="preserve">
          <source>Custom log format, see org.eclipse.jetty.server.CustomRequestLog. If defined, overrides the &quot;format&quot; configuration key.</source>
          <target state="translated">사용자 정의 로그 형식은 org.eclipse.jetty.server.CustomRequestLog를 참조하십시오. 정의 된 경우 &quot;형식&quot;구성 키를 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="d7f0ac9e007291a6ccc21d036f4711505ad9d0b1" translate="yes" xml:space="preserve">
          <source>Customization</source>
          <target state="translated">Customization</target>
        </trans-unit>
        <trans-unit id="1de21cdc83750604be2cd4ceb6f6c1ee3e0c8749" translate="yes" xml:space="preserve">
          <source>Customizing ConfigurableServletWebServerFactory Directly</source>
          <target state="translated">ConfigurableServletWebServerFactory 직접 사용자 정의</target>
        </trans-unit>
        <trans-unit id="9713d3a816b22d1a53b66ea4b7ddb426b3ddebe7" translate="yes" xml:space="preserve">
          <source>Customizing a Script When It Runs</source>
          <target state="translated">스크립트 실행시 사용자 지정</target>
        </trans-unit>
        <trans-unit id="dc995d4569de1763614f1fbcb0a6f612a150f4c2" translate="yes" xml:space="preserve">
          <source>Customizing the Start Script when It Is Written</source>
          <target state="translated">작성시 시작 스크립트 사용자 정의</target>
        </trans-unit>
        <trans-unit id="76c5d386e2d405ece07a9301c2ac759b5fd40a09" translate="yes" xml:space="preserve">
          <source>Cutting edge &lt;a href=&quot;https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/&quot;&gt;snapshot distributions&lt;/a&gt; are also available.</source>
          <target state="translated">최첨단 &lt;a href=&quot;https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/&quot;&gt;스냅 샷 배포&lt;/a&gt; 도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="7fc379d2b4951ff15f6f932b1ebeada837983855" translate="yes" xml:space="preserve">
          <source>DDL mode. This is actually a shortcut for the &quot;hibernate.hbm2ddl.auto&quot; property. Defaults to &quot;create-drop&quot; when using an embedded database and no schema manager was detected. Otherwise, defaults to &quot;none&quot;.</source>
          <target state="translated">DDL 모드. 이것은 실제로 &quot;hibernate.hbm2ddl.auto&quot;속성의 바로 가기입니다. 임베디드 데이터베이스를 사용하고 스키마 관리자가 감지되지 않은 경우 기본값은 &quot;create-drop&quot;입니다. 그렇지 않으면 기본값은 &quot;없음&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="30e504c829201f1e519376dfee2e0e399c82484c" translate="yes" xml:space="preserve">
          <source>DOWN</source>
          <target state="translated">DOWN</target>
        </trans-unit>
        <trans-unit id="b826585fe52d0222ab6633ffbb4132cd6bc57aa0" translate="yes" xml:space="preserve">
          <source>Data (DML) script resource references.</source>
          <target state="translated">데이터 (DML) 스크립트 리소스 참조.</target>
        </trans-unit>
        <trans-unit id="c50657c6144d614c227941c8bd58c434ac144f09" translate="yes" xml:space="preserve">
          <source>Data JPA tests may also inject a &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java&quot;&gt;&lt;code&gt;TestEntityManager&lt;/code&gt;&lt;/a&gt; bean, which provides an alternative to the standard JPA &lt;code&gt;EntityManager&lt;/code&gt; that is specifically designed for tests. If you want to use &lt;code&gt;TestEntityManager&lt;/code&gt; outside of &lt;code&gt;@DataJpaTest&lt;/code&gt; instances, you can also use the &lt;code&gt;@AutoConfigureTestEntityManager&lt;/code&gt; annotation. A &lt;code&gt;JdbcTemplate&lt;/code&gt; is also available if you need that. The following example shows the &lt;code&gt;@DataJpaTest&lt;/code&gt; annotation in use:</source>
          <target state="translated">데이터 JPA 테스트는 테스트 용으로 특별히 설계된 표준 JPA &lt;code&gt;EntityManager&lt;/code&gt; 의 대안을 제공하는 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-test-autoconfigure/src/main/java/org/springframework/boot/test/autoconfigure/orm/jpa/TestEntityManager.java&quot;&gt; &lt;code&gt;TestEntityManager&lt;/code&gt; &lt;/a&gt; 빈을 삽입 할 수도 있습니다 . 당신이 사용하려는 경우 &lt;code&gt;TestEntityManager&lt;/code&gt; 의 외부 &lt;code&gt;@DataJpaTest&lt;/code&gt; 인스턴스를, 당신은 또한 사용할 수 있습니다 &lt;code&gt;@AutoConfigureTestEntityManager&lt;/code&gt; 의 주석을. &lt;code&gt;JdbcTemplate&lt;/code&gt; 와는 당신이 필요한 경우도 있습니다. 다음 예제는 사용중인 &lt;code&gt;@DataJpaTest&lt;/code&gt; 주석을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="0ca4cc16d0eb862f10b1442cced8ca8a20d4d7c6" translate="yes" xml:space="preserve">
          <source>DataSource configuration is controlled by external configuration properties in &lt;code&gt;spring.datasource.*&lt;/code&gt;. For example, you might declare the following section in &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">DataSource 구성은 &lt;code&gt;spring.datasource.*&lt;/code&gt; 의 외부 구성 속성에 의해 제어됩니다 . 예를 들어 &lt;code&gt;application.properties&lt;/code&gt; 에서 다음 섹션을 선언 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ec7d2e0a53d2b0c8fc64a0de5a12e71aef35266" translate="yes" xml:space="preserve">
          <source>Database index used by the connection factory.</source>
          <target state="translated">연결 팩토리에서 사용하는 데이터베이스 색인입니다.</target>
        </trans-unit>
        <trans-unit id="06a2b537fffc43308c0f401c19c34d5f1c9c2916" translate="yes" xml:space="preserve">
          <source>Database name to use. By default, the server decides the default database to use.</source>
          <target state="translated">사용할 데이터베이스 이름입니다. 기본적으로 서버는 사용할 기본 데이터베이스를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="1f87f07a18246fe9fb50dbb65b249b4631a44dae" translate="yes" xml:space="preserve">
          <source>Database name.</source>
          <target state="translated">데이터베이스 이름.</target>
        </trans-unit>
        <trans-unit id="4b662ffec6ba933e6498153410ce81d4dbe9595a" translate="yes" xml:space="preserve">
          <source>Database name. Set if no name is specified in the url. Default to &quot;testdb&quot; when using an embedded database.</source>
          <target state="translated">데이터베이스 이름. URL에 이름이 지정되지 않은 경우 설정됩니다. 내장 데이터베이스를 사용하는 경우 기본값은 &quot;testdb&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="1df57b8260a234362bf66de71680fd2d63a534c4" translate="yes" xml:space="preserve">
          <source>Database schema initialization mode.</source>
          <target state="translated">데이터베이스 스키마 초기화 모드.</target>
        </trans-unit>
        <trans-unit id="2ff845b55e83e02121a907ce55e8873223d56cc1" translate="yes" xml:space="preserve">
          <source>Datacenter that is considered &quot;local&quot;. Contact points should be from this datacenter.</source>
          <target state="translated">&quot;로컬&quot;로 간주되는 데이터 센터. 연락처는이 데이터 센터에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="bd7c7997c03f050abbce4899b359441c7d3e4366" translate="yes" xml:space="preserve">
          <source>Datadog</source>
          <target state="translated">Datadog</target>
        </trans-unit>
        <trans-unit id="0ad655a942592d4da7221b011cf042f67d0d3a08" translate="yes" xml:space="preserve">
          <source>Datadog API key.</source>
          <target state="translated">Datadog API 키.</target>
        </trans-unit>
        <trans-unit id="d03a5e2609b58b2317b6f6f5c554d25b075bd70f" translate="yes" xml:space="preserve">
          <source>Datadog application key. Not strictly required, but improves the Datadog experience by sending meter descriptions, types, and base units to Datadog.</source>
          <target state="translated">Datadog 애플리케이션 키. 꼭 필요한 것은 아니지만 미터 설명, 유형 및 기본 단위를 Datadog에 전송하여 Datadog 경험을 개선합니다.</target>
        </trans-unit>
        <trans-unit id="45d5b36a3e5606d5a096fcd7b7d4c09f850cf147" translate="yes" xml:space="preserve">
          <source>Datadog registry pushes metrics to &lt;a href=&quot;https://www.datadoghq.com&quot;&gt;datadoghq&lt;/a&gt; periodically. To export metrics to &lt;a href=&quot;https://micrometer.io/docs/registry/datadog&quot;&gt;Datadog&lt;/a&gt;, your API key must be provided:</source>
          <target state="translated">Datadog 레지스트리는 메트릭을 &lt;a href=&quot;https://www.datadoghq.com&quot;&gt;datadoghq에&lt;/a&gt; 주기적으로 푸시 합니다. 측정 항목을 &lt;a href=&quot;https://micrometer.io/docs/registry/datadog&quot;&gt;Datadog로&lt;/a&gt; 내보내 려면 API 키를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea765ba0cbd3c174d4e0ace2634d9b0ae2fe10c8" translate="yes" xml:space="preserve">
          <source>Date and Time: Millisecond precision and easily sortable.</source>
          <target state="translated">날짜 및 시간 : 밀리 초 정밀도 및 쉽게 정렬 가능.</target>
        </trans-unit>
        <trans-unit id="b7cb6a37813a04837c68f130fffcb29bafbca38e" translate="yes" xml:space="preserve">
          <source>Date format string or a fully-qualified date format class name. For instance, `yyyy-MM-dd HH:mm:ss`.</source>
          <target state="translated">날짜 형식 문자열 또는 완전한 날짜 형식 클래스 이름입니다. 예 :`yyyy-MM-dd HH : mm : ss`.</target>
        </trans-unit>
        <trans-unit id="c8e1c12159214386878015dd34d7d2ae31876cef" translate="yes" xml:space="preserve">
          <source>Date format to place in log file name.</source>
          <target state="translated">로그 파일 이름에 넣을 날짜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9db75a470b03b0df0fe6e98d4c4bbc61fcd27305" translate="yes" xml:space="preserve">
          <source>Date format to place in the log file name.</source>
          <target state="translated">로그 파일 이름에 넣을 날짜 형식입니다.</target>
        </trans-unit>
        <trans-unit id="132d86e50b862dfe58aa69f220c08329b7f7d760" translate="yes" xml:space="preserve">
          <source>Date format to use, for example `dd/MM/yyyy`.</source>
          <target state="translated">사용할 날짜 형식 (예 :`dd / MM / yyyy`).</target>
        </trans-unit>
        <trans-unit id="593a4067d57472bed5dcb0cb50efc027c50017e0" translate="yes" xml:space="preserve">
          <source>Date-time format to use, for example `yyyy-MM-dd HH:mm:ss`.</source>
          <target state="translated">사용할 날짜-시간 형식입니다 (예 :`yyyy-MM-dd HH : mm : ss`).</target>
        </trans-unit>
        <trans-unit id="9368ee44836dc95da2a6c7f5146467536209242e" translate="yes" xml:space="preserve">
          <source>Declaratively, for all applications, by adding a &lt;code&gt;META-INF/spring.factories&lt;/code&gt; and packaging a jar file that the applications all use as a library.</source>
          <target state="translated">선언적으로 모든 애플리케이션에 대해 &lt;code&gt;META-INF/spring.factories&lt;/code&gt; 를 추가 하고 애플리케이션이 모두 라이브러리로 사용하는 jar 파일을 패키징합니다.</target>
        </trans-unit>
        <trans-unit id="ee79c008d20d3bf9ec511a4c5708d58543fbe1cb" translate="yes" xml:space="preserve">
          <source>Declaratively, per application, by setting the &lt;code&gt;context.initializer.classes&lt;/code&gt; or &lt;code&gt;context.listener.classes&lt;/code&gt; properties.</source>
          <target state="translated">선언적으로 애플리케이션별로 &lt;code&gt;context.initializer.classes&lt;/code&gt; 또는 &lt;code&gt;context.listener.classes&lt;/code&gt; 속성 을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="cd4cd1ca5275a14d5d4ac6b6b01fc2e0fb93661a" translate="yes" xml:space="preserve">
          <source>Default MimeMessage encoding.</source>
          <target state="translated">기본 MimeMessage 인코딩.</target>
        </trans-unit>
        <trans-unit id="7078198f7cae420890a1abe183a812a6a35f8ed6" translate="yes" xml:space="preserve">
          <source>Default Value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="8d9d79b1ec67137f4a3ef84b36d36d16efda361d" translate="yes" xml:space="preserve">
          <source>Default arguments for the main method (space separated).</source>
          <target state="translated">기본 메소드에 대한 기본 인수 (공백으로 구분).</target>
        </trans-unit>
        <trans-unit id="8248cc351c36934f6d7f14afff21cbe015f977b1" translate="yes" xml:space="preserve">
          <source>Default auto-commit mode for local transactions.</source>
          <target state="translated">로컬 트랜잭션에 대한 기본 자동 커밋 모드입니다.</target>
        </trans-unit>
        <trans-unit id="7740928fdc32aa0e4ebea3d05b11579de77bcaaa" translate="yes" xml:space="preserve">
          <source>Default batch size. A small batch size will make batching less common and may reduce throughput (a batch size of zero disables batching entirely).</source>
          <target state="translated">기본 배치 크기. 배치 크기가 작 으면 일괄 처리가 덜 일반적이고 처리량이 줄어들 수 있습니다 (배치 크기가 0이면 일괄 처리가 완전히 비활성화 됨).</target>
        </trans-unit>
        <trans-unit id="9edb00cc3a01b75a38f4810ac41c98f3544f2564" translate="yes" xml:space="preserve">
          <source>Default cursor holdability for connections.</source>
          <target state="translated">연결에 대한 기본 커서 유지 기능.</target>
        </trans-unit>
        <trans-unit id="1a93ead6476072bf7c580966ff5321ab0f769a69" translate="yes" xml:space="preserve">
          <source>Default database schema.</source>
          <target state="translated">기본 데이터베이스 스키마.</target>
        </trans-unit>
        <trans-unit id="0492c7fdfde5b32e2d645ff6217d5bad39801bcf" translate="yes" xml:space="preserve">
          <source>Default destination to use on send and receive operations that do not have a destination parameter.</source>
          <target state="translated">대상 매개 변수가없는 송신 및 수신 작업에 사용할 기본 대상입니다.</target>
        </trans-unit>
        <trans-unit id="20d8c69bb406990b2562804c2d51b1e73d615844" translate="yes" xml:space="preserve">
          <source>Default isolation level for connections.</source>
          <target state="translated">연결에 대한 기본 격리 수준입니다.</target>
        </trans-unit>
        <trans-unit id="8ba4a2f9e2dc6e2f0603fd5370fd1ba22812aa26" translate="yes" xml:space="preserve">
          <source>Default isolation level of connections provided by the pool.</source>
          <target state="translated">풀에서 제공하는 연결의 기본 격리 수준입니다.</target>
        </trans-unit>
        <trans-unit id="4ae61c56d0107350c5343d0f0577bf9bd1ff856e" translate="yes" xml:space="preserve">
          <source>Default page size.</source>
          <target state="translated">기본 페이지 크기.</target>
        </trans-unit>
        <trans-unit id="6fa20db1310e31138314f34b6150a1e2e42e35ab" translate="yes" xml:space="preserve">
          <source>Default properties (specified by setting &lt;code&gt;SpringApplication.setDefaultProperties&lt;/code&gt;).</source>
          <target state="translated">기본 속성 ( &lt;code&gt;SpringApplication.setDefaultProperties&lt;/code&gt; 를 설정하여 지정됨 ).</target>
        </trans-unit>
        <trans-unit id="b39619da180b0d433d4da14204a3d7363cd030e6" translate="yes" xml:space="preserve">
          <source>Default schema name managed by Flyway (case-sensitive).</source>
          <target state="translated">Flyway에서 관리하는 기본 스키마 이름 (대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="d70c06445cf3a66c0a423b10f4eddfc1a901bca6" translate="yes" xml:space="preserve">
          <source>Default size of pages.</source>
          <target state="translated">페이지의 기본 크기.</target>
        </trans-unit>
        <trans-unit id="30aa8a78de748d9121c63599c21b9a3d3ac83cbb" translate="yes" xml:space="preserve">
          <source>Default timeout for JTA transactions.</source>
          <target state="translated">JTA 트랜잭션에 대한 기본 제한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="3fd5023a5dc095e0dd1f42efa33230112b602121" translate="yes" xml:space="preserve">
          <source>Default topic to which messages are sent.</source>
          <target state="translated">메시지가 전송되는 기본 주제입니다.</target>
        </trans-unit>
        <trans-unit id="63355a7aec619aa92328459266f08c5a97a76d68" translate="yes" xml:space="preserve">
          <source>Default transaction timeout. If a duration suffix is not specified, seconds will be used.</source>
          <target state="translated">기본 트랜잭션 제한 시간. 기간 접미사가 지정되지 않은 경우 초가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dcba856531beb34408e01a9fcb0a3df282a6d6e5" translate="yes" xml:space="preserve">
          <source>Default user name.</source>
          <target state="translated">기본 사용자 이름.</target>
        </trans-unit>
        <trans-unit id="bdffe654f8554300a98d2acefcbbf1d894339b2b" translate="yes" xml:space="preserve">
          <source>Default value</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="318adc4a6d57fbf624d887a844daa16ad936a879" translate="yes" xml:space="preserve">
          <source>Default value for &lt;code&gt;LOG_FILENAME&lt;/code&gt;. Only valid for an &lt;code&gt;init.d&lt;/code&gt; service</source>
          <target state="translated">&lt;code&gt;LOG_FILENAME&lt;/code&gt; 의 기본값 입니다. &lt;code&gt;init.d&lt;/code&gt; 서비스 에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="a7196db4594b481a2bc977b0f5759d967e4b9e7f" translate="yes" xml:space="preserve">
          <source>Default value for &lt;code&gt;LOG_FOLDER&lt;/code&gt;. Only valid for an &lt;code&gt;init.d&lt;/code&gt; service</source>
          <target state="translated">&lt;code&gt;LOG_FOLDER&lt;/code&gt; 의 기본값 입니다. &lt;code&gt;init.d&lt;/code&gt; 서비스 에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d194e7422d9d40d12ba2678005be4dd0b393f3f0" translate="yes" xml:space="preserve">
          <source>Default value for &lt;code&gt;PID_FOLDER&lt;/code&gt;. Only valid for an &lt;code&gt;init.d&lt;/code&gt; service</source>
          <target state="translated">&lt;code&gt;PID_FOLDER&lt;/code&gt; 의 기본값 입니다. &lt;code&gt;init.d&lt;/code&gt; 서비스 에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="c418e126d6a9a6bb53886da878735b56c2044eb1" translate="yes" xml:space="preserve">
          <source>Default value for &lt;code&gt;STOP_WAIT_TIME&lt;/code&gt; in seconds. Only valid for an &lt;code&gt;init.d&lt;/code&gt; service</source>
          <target state="translated">&lt;code&gt;STOP_WAIT_TIME&lt;/code&gt; 의 기본값 ( 초)입니다. &lt;code&gt;init.d&lt;/code&gt; 서비스 에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="0096938c8367ed904ab9c33ff1fe38f924b76181" translate="yes" xml:space="preserve">
          <source>Default value for the name of the PID file in &lt;code&gt;PID_FOLDER&lt;/code&gt;. Only valid for an &lt;code&gt;init.d&lt;/code&gt; service</source>
          <target state="translated">&lt;code&gt;PID_FOLDER&lt;/code&gt; 의 PID 파일 이름에 대한 기본값 입니다. &lt;code&gt;init.d&lt;/code&gt; 서비스 에만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b503cdc5b1832cf1ecc5c60b379b275c10374e4c" translate="yes" xml:space="preserve">
          <source>Default values can be specified using &lt;code&gt;@DefaultValue&lt;/code&gt; and the same conversion service will be applied to coerce the &lt;code&gt;String&lt;/code&gt; value to the target type of a missing property. By default, if no properties are bound to &lt;code&gt;Security&lt;/code&gt;, the &lt;code&gt;AcmeProperties&lt;/code&gt; instance will contain a &lt;code&gt;null&lt;/code&gt; value for &lt;code&gt;security&lt;/code&gt;. If you wish you return a non-null instance of &lt;code&gt;Security&lt;/code&gt; even when no properties are bound to it, you can use an empty &lt;code&gt;@DefaultValue&lt;/code&gt; annotation to do so:</source>
          <target state="translated">&lt;code&gt;@DefaultValue&lt;/code&gt; 를 사용하여 기본값을 지정할 수 있으며 &lt;code&gt;String&lt;/code&gt; 값을 누락 된 속성의 대상 유형으로 강제 변환하는 데 동일한 변환 서비스가 적용됩니다 . 어떤 속성에 바인딩되지 않은 경우 기본적으로 &lt;code&gt;Security&lt;/code&gt; 의 &lt;code&gt;AcmeProperties&lt;/code&gt; 의 인스턴스가 포함됩니다 &lt;code&gt;null&lt;/code&gt; 가치 &lt;code&gt;security&lt;/code&gt; . 속성이 바인딩되지 않은 경우에도 null이 아닌 &lt;code&gt;Security&lt;/code&gt; 인스턴스를 반환 하려면 빈 &lt;code&gt;@DefaultValue&lt;/code&gt; 주석을 사용 하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f75f6cfa5347de59568fc71e6d119ecba80d8d69" translate="yes" xml:space="preserve">
          <source>Define how the locale should be resolved.</source>
          <target state="translated">로케일 해석 방법을 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="46a37fb3e5d3ac624fdbfea0246214c33c249fe4" translate="yes" xml:space="preserve">
          <source>Definition of Actuator</source>
          <target state="translated">액추에이터의 정의</target>
        </trans-unit>
        <trans-unit id="b504e91a64056b489f2d8300e1dc3ad883fef357" translate="yes" xml:space="preserve">
          <source>Delay after which recovery can cleanup pending ('orphaned') log entries.</source>
          <target state="translated">복구가 보류중인 ( '분리 된') 로그 항목을 정리할 수있는 지연 시간입니다.</target>
        </trans-unit>
        <trans-unit id="636b134700e8f790978e6538a024693772710447" translate="yes" xml:space="preserve">
          <source>Delay after which the scheduler is started once initialization completes. Setting this property makes sense if no jobs should be run before the entire application has started up.</source>
          <target state="translated">초기화가 완료되면 스케줄러가 시작되기까지 지연됩니다. 전체 응용 프로그램이 시작되기 전에 작업을 실행하지 않아야하는 경우이 속성을 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8e8a8caf436c4b51c900feb239fda9c04592d77" translate="yes" xml:space="preserve">
          <source>Delay between retry attempts.</source>
          <target state="translated">재시도 사이의 지연.</target>
        </trans-unit>
        <trans-unit id="3d174e36c367a6fa91560562f932988d21a5a05e" translate="yes" xml:space="preserve">
          <source>Delay between the invocation of backgroundProcess methods. If a duration suffix is not specified, seconds will be used.</source>
          <target state="translated">backgroundProcess 메소드 호출 사이의 지연. 기간 접미사가 지정되지 않은 경우 초가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0eabb6604f6ea766f5e0e0ef31ac20f32766c8c1" translate="yes" xml:space="preserve">
          <source>Delay between two recovery scans.</source>
          <target state="translated">두 복구 스캔 사이의 지연.</target>
        </trans-unit>
        <trans-unit id="cb140e2ba9c3589b9921a392db8584004258c377" translate="yes" xml:space="preserve">
          <source>Delimiter to be used between the qualifier and the actual page number and size properties.</source>
          <target state="translated">한정자와 실제 페이지 번호 및 크기 속성 사이에 사용할 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="667168b639179442a41d1aab1d7eacaa9d94b9f0" translate="yes" xml:space="preserve">
          <source>Delivery delay to use for send calls.</source>
          <target state="translated">전화를 보내는 데 사용할 배달 지연입니다.</target>
        </trans-unit>
        <trans-unit id="b1ef28cdaca7b69502a4966d03ae7cd8aae86140" translate="yes" xml:space="preserve">
          <source>Delivery mode. Enables QoS (Quality of Service) when set.</source>
          <target state="translated">배달 모드. 설정된 경우 QoS (서비스 품질)를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="0562f32dc56f5c702810cbe010068ddd38dbd69a" translate="yes" xml:space="preserve">
          <source>Dependencies</source>
          <target state="translated">Dependencies</target>
        </trans-unit>
        <trans-unit id="a05b6cc9f654592a4951aac91a70f7960638df36" translate="yes" xml:space="preserve">
          <source>Dependencies should be placed in a nested &lt;code&gt;WEB-INF/lib&lt;/code&gt; directory. Any dependencies that are required when running embedded but are not required when deploying to a traditional web container should be placed in &lt;code&gt;WEB-INF/lib-provided&lt;/code&gt;.</source>
          <target state="translated">종속성은 중첩 된 &lt;code&gt;WEB-INF/lib&lt;/code&gt; 디렉토리에 있어야합니다 . 임베디드 실행시 필요하지만 기존 웹 컨테이너에 배치 할 때 필요하지 않은 모든 종속성은 &lt;code&gt;WEB-INF/lib-provided&lt;/code&gt; 에 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="12968ebbcff93f7be3f84e6ee6bd62b560891918" translate="yes" xml:space="preserve">
          <source>Dependency Versions</source>
          <target state="translated">종속성 버전</target>
        </trans-unit>
        <trans-unit id="fd11d3886390ba655075ec276649e660fa3005f4" translate="yes" xml:space="preserve">
          <source>Dependency versions</source>
          <target state="translated">종속성 버전</target>
        </trans-unit>
        <trans-unit id="04e432619ecd4ae93877053084d6c669eb914efe" translate="yes" xml:space="preserve">
          <source>Depending on how you run your application, your IDE may order the classpath differently. Running your application in the IDE from its main method results in a different ordering than when you run your application by using Maven or Gradle or from its packaged jar. This can cause Spring Boot to fail to find the expected template. If you have this problem, you can reorder the classpath in the IDE to place the module&amp;rsquo;s classes and resources first.</source>
          <target state="translated">애플리케이션을 실행하는 방법에 따라 IDE에서 클래스 경로를 다르게 정렬 할 수 있습니다. 메인 메서드에서 IDE에서 애플리케이션을 실행하면 Maven 또는 Gradle을 사용하거나 패키지 된 jar를 사용하여 애플리케이션을 실행할 때와 다른 순서가 발생합니다. 이로 인해 Spring Boot가 예상 템플릿을 찾지 못할 수 있습니다. 이 문제가있는 경우 IDE에서 클래스 경로를 재정렬하여 모듈의 클래스와 리소스를 먼저 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df05ae7508254daa31b9e1b44527b7cd22dd6c8e" translate="yes" xml:space="preserve">
          <source>Depending on the complexity of your application, you may either have a single &lt;code&gt;@Configuration&lt;/code&gt; class for your customizations or one class per domain area. The latter approach lets you enable it in one of your tests, if necessary, with the &lt;code&gt;@Import&lt;/code&gt; annotation.</source>
          <target state="translated">애플리케이션의 복잡성에 따라 사용자 정의를위한 단일 &lt;code&gt;@Configuration&lt;/code&gt; 클래스 또는 도메인 영역 당 하나의 클래스가있을 수 있습니다. 후자의 접근 방식을 사용하면 필요한 경우 &lt;code&gt;@Import&lt;/code&gt; 주석 을 사용하여 테스트 중 하나에서 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="23578781d5af305a8fef175bf0e6bd78a55e6723" translate="yes" xml:space="preserve">
          <source>Depending on the listener type, a &lt;code&gt;RecordMessageConverter&lt;/code&gt; or &lt;code&gt;BatchMessageConverter&lt;/code&gt; bean is associated to the default factory. If only a &lt;code&gt;RecordMessageConverter&lt;/code&gt; bean is present for a batch listener, it is wrapped in a &lt;code&gt;BatchMessageConverter&lt;/code&gt;.</source>
          <target state="translated">리스너 유형에 따라 &lt;code&gt;RecordMessageConverter&lt;/code&gt; 또는 &lt;code&gt;BatchMessageConverter&lt;/code&gt; Bean이 기본 팩토리에 연관됩니다. 단지 경우 &lt;code&gt;RecordMessageConverter&lt;/code&gt; 의 콩이 배치 수신기의 존재, 그것은에 싸여 &lt;code&gt;BatchMessageConverter&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f19a17dddf4027295f1f9b0224c869bb5d012921" translate="yes" xml:space="preserve">
          <source>Depending on your logging system, the following files are loaded:</source>
          <target state="translated">로깅 시스템에 따라 다음 파일이로드됩니다.</target>
        </trans-unit>
        <trans-unit id="4c33053f1211cd49899c3d05ab6290f9169b833e" translate="yes" xml:space="preserve">
          <source>Deploying Spring Boot Applications</source>
          <target state="translated">Spring Boot 애플리케이션 배포</target>
        </trans-unit>
        <trans-unit id="eaea3c4796f083406268f237ea090af82e11e371" translate="yes" xml:space="preserve">
          <source>Deploying to the Cloud, Installing as a Unix application.</source>
          <target state="translated">클라우드에 배포, Unix 애플리케이션으로 설치.</target>
        </trans-unit>
        <trans-unit id="327a55f82dc6818877a68e37b722bb7f2360b633" translate="yes" xml:space="preserve">
          <source>Deployment</source>
          <target state="translated">Deployment</target>
        </trans-unit>
        <trans-unit id="66bb12951e7ca5cb554a9728924da50f3effa1ba" translate="yes" xml:space="preserve">
          <source>Deprecation</source>
          <target state="translated">Deprecation</target>
        </trans-unit>
        <trans-unit id="7aeb5abbf2faad908d9b44e00bc9a8d67148341c" translate="yes" xml:space="preserve">
          <source>Deprecation can also be specified declaratively in code by adding the &lt;code&gt;@DeprecatedConfigurationProperty&lt;/code&gt; annotation to the getter exposing the deprecated property. For instance, assume that the &lt;code&gt;app.acme.target&lt;/code&gt; property was confusing and was renamed to &lt;code&gt;app.acme.name&lt;/code&gt;. The following example shows how to handle that situation:</source>
          <target state="translated">deprecated 속성을 노출하는 getter에 &lt;code&gt;@DeprecatedConfigurationProperty&lt;/code&gt; 주석을 추가하여 코드 에서 deprecation을 선언적으로 지정할 수도 있습니다 . 예를 들어 &lt;code&gt;app.acme.target&lt;/code&gt; 속성이 혼란스럽고 이름이 &lt;code&gt;app.acme.name&lt;/code&gt; 으로 변경 되었다고 가정합니다 . 다음 예는 이러한 상황을 처리하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="06623cc9d60571ea34b3f8ea525c2935cef1eb04" translate="yes" xml:space="preserve">
          <source>Describes the list of potential values for a property.</source>
          <target state="translated">속성의 잠재적 인 값 목록을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="ce41a27135bc977f35755b1db46e34fe17cf1e0e" translate="yes" xml:space="preserve">
          <source>Description to tag an existing schema with when applying a baseline.</source>
          <target state="translated">기준선을 적용 할 때 기존 스키마에 태그를 지정하는 설명입니다.</target>
        </trans-unit>
        <trans-unit id="5fea1e634922f68fffd6ec440862662a193e6e8b" translate="yes" xml:space="preserve">
          <source>Deserializer class for keys.</source>
          <target state="translated">키에 대한 Deserializer 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0779afcc6b94b3fe8869d61609e110ed7c566e12" translate="yes" xml:space="preserve">
          <source>Deserializer class for values.</source>
          <target state="translated">값에 대한 Deserializer 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="49deb6981c228523086c1acf67d75e4a49c5cb51" translate="yes" xml:space="preserve">
          <source>Details are never shown.</source>
          <target state="translated">세부 사항은 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d35724d90813324c1d6a198c2d5a3a2cc56ca327" translate="yes" xml:space="preserve">
          <source>Details are only shown to authorized users. Authorized roles can be configured using &lt;code&gt;management.endpoint.health.roles&lt;/code&gt;.</source>
          <target state="translated">세부 정보는 승인 된 사용자에게만 표시됩니다. 인증 된 역할은 &lt;code&gt;management.endpoint.health.roles&lt;/code&gt; 를 사용하여 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7dd716257351a548786d6f860a21a8c5080bbb16" translate="yes" xml:space="preserve">
          <source>Details are shown to all users.</source>
          <target state="translated">모든 사용자에게 세부 정보가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fffe437b0bc6c0e5b6331f997f0a992bde18b13c" translate="yes" xml:space="preserve">
          <source>Details of the dependencies that are managed by Spring Boot.</source>
          <target state="translated">Spring Boot에서 관리하는 종속성에 대한 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6b87909c7ce7f7de8e4c31d5ebb62fdfed585d9b" translate="yes" xml:space="preserve">
          <source>Detect start-class</source>
          <target state="translated">시작 클래스 감지</target>
        </trans-unit>
        <trans-unit id="00a94308b5e2caa5518b6c42c684558f70841f76" translate="yes" xml:space="preserve">
          <source>DevTools needs to customize the &lt;code&gt;ResourceLoader&lt;/code&gt; used by the &lt;code&gt;ApplicationContext&lt;/code&gt;. If your application provides one already, it is going to be wrapped. Direct override of the &lt;code&gt;getResource&lt;/code&gt; method on the &lt;code&gt;ApplicationContext&lt;/code&gt; is not supported.</source>
          <target state="translated">DevTools 는 &lt;code&gt;ApplicationContext&lt;/code&gt; 에서 사용 하는 &lt;code&gt;ResourceLoader&lt;/code&gt; 를 사용자 정의해야합니다 . 응용 프로그램에서 이미 제공하는 경우 래핑됩니다. &lt;code&gt;ApplicationContext&lt;/code&gt; 에서 &lt;code&gt;getResource&lt;/code&gt; 메소드 의 직접 대체는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="196addc044b6999224e2974eeeb5558b4bce504f" translate="yes" xml:space="preserve">
          <source>DevTools relies on the application context&amp;rsquo;s shutdown hook to close it during a restart. It does not work correctly if you have disabled the shutdown hook (&lt;code&gt;SpringApplication.setRegisterShutdownHook(false)&lt;/code&gt;).</source>
          <target state="translated">DevTools는 애플리케이션 컨텍스트의 종료 후크를 사용하여 다시 시작하는 동안 닫습니다. 종료 후크 ( &lt;code&gt;SpringApplication.setRegisterShutdownHook(false)&lt;/code&gt; )를 비활성화 한 경우 제대로 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2312cfd5bf79d42d05749e56cbee339e2d6d0f06" translate="yes" xml:space="preserve">
          <source>Developer tools are automatically disabled when running a fully packaged application. If your application is launched from &lt;code&gt;java -jar&lt;/code&gt; or if it is started from a special classloader, then it is considered a &amp;ldquo;production application&amp;rdquo;. You can control this behavior by using the &lt;code&gt;spring.devtools.restart.enabled&lt;/code&gt; system property. To enable devtools, irrespective of the classloader used to launch your application, set the &lt;code&gt;-Dspring.devtools.restart.enabled=true&lt;/code&gt; system property. This must not be done in a production environment where running devtools is a security risk. To disable devtools, exclude the dependency or set the &lt;code&gt;-Dspring.devtools.restart.enabled=false&lt;/code&gt; system property.</source>
          <target state="translated">완전히 패키징 된 애플리케이션을 실행하면 개발자 도구가 자동으로 비활성화됩니다. 응용 프로그램이 &lt;code&gt;java -jar&lt;/code&gt; 에서 시작되거나 특수 클래스 로더에서 시작된 경우 &quot;프로덕션 응용 프로그램&quot;으로 간주됩니다. &lt;code&gt;spring.devtools.restart.enabled&lt;/code&gt; 시스템 속성 을 사용하여이 동작을 제어 할 수 있습니다 . 애플리케이션을 시작하는 데 사용 된 클래스 로더에 관계없이 devtools를 활성화하려면 &lt;code&gt;-Dspring.devtools.restart.enabled=true&lt;/code&gt; 시스템 속성을 설정합니다 . devtools를 실행하는 것이 보안 위험이있는 프로덕션 환경에서는이 작업을 수행해서는 안됩니다. devtools를 비활성화하려면 종속성을 제외하거나 &lt;code&gt;-Dspring.devtools.restart.enabled=false&lt;/code&gt; 시스템 속성을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="aa8b67adf46e6bab7b544fcccdb596b0c36a37e0" translate="yes" xml:space="preserve">
          <source>Developers can customize the &lt;code&gt;RSocketStrategies&lt;/code&gt; component by creating beans that implement the &lt;code&gt;RSocketStrategiesCustomizer&lt;/code&gt; interface. Note that their &lt;code&gt;@Order&lt;/code&gt; is important, as it determines the order of codecs.</source>
          <target state="translated">개발자는 &lt;code&gt;RSocketStrategiesCustomizer&lt;/code&gt; 인터페이스 를 구현하는 Bean을 생성 하여 &lt;code&gt;RSocketStrategies&lt;/code&gt; 구성 요소를 사용자 정의 할 수 있습니다 . 자신 있습니다 &lt;code&gt;@Order&lt;/code&gt; 가 이 코덱의 순서를 결정으로 중요하다.</target>
        </trans-unit>
        <trans-unit id="6c2249e2a5d98b9bfac7ef8093c313db69d584be" translate="yes" xml:space="preserve">
          <source>Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom &lt;code&gt;ReactorResourceFactory&lt;/code&gt; or &lt;code&gt;JettyResourceFactory&lt;/code&gt; bean - this will be applied to both clients and servers.</source>
          <target state="translated">개발자는 사용자 지정 &lt;code&gt;ReactorResourceFactory&lt;/code&gt; 또는 &lt;code&gt;JettyResourceFactory&lt;/code&gt; 빈 을 제공하여 Jetty 및 Reactor Netty의 리소스 구성을 재정의 할 수 있습니다 . 이는 클라이언트와 서버 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b206ed48adf1bdb4e39e227c100b8abdcd5629ac" translate="yes" xml:space="preserve">
          <source>Developing Spring Boot applications with Kotlin</source>
          <target state="translated">Kotlin으로 Spring Boot 애플리케이션 개발</target>
        </trans-unit>
        <trans-unit id="dbc59f4291a92a7dccf3ff0d08b3e59ec8880086" translate="yes" xml:space="preserve">
          <source>Devtools global settings properties</source>
          <target state="translated">Devtools 전역 설정 속성</target>
        </trans-unit>
        <trans-unit id="c50c653c4c7c67d75d7db72ea1ea14f64402c132" translate="yes" xml:space="preserve">
          <source>Directories loaded using a wildcard are sorted alphabetically. If you need a different order, then you should list each location as a separate import</source>
          <target state="translated">와일드 카드를 사용하여로드 된 디렉토리는 알파벳순으로 정렬됩니다. 다른 주문이 필요한 경우 각 위치를 별도의 가져 오기로 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="a225784c4e3fb642c547060c37fa4334bca7462a" translate="yes" xml:space="preserve">
          <source>Directory in which log files are created. Can be absolute or relative to the Tomcat base dir.</source>
          <target state="translated">로그 파일이 생성되는 디렉토리입니다. Tomcat 기본 디렉토리에 대해 절대적이거나 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="233653a81286f899ccbd69cf6b4f8e6c916432fe" translate="yes" xml:space="preserve">
          <source>Directory in which the log files should be stored. Defaults to the current working directory.</source>
          <target state="translated">로그 파일을 저장해야하는 디렉토리입니다. 기본값은 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="fc6d499ac2991f89be01ed8d682ddd5d235d103d" translate="yes" xml:space="preserve">
          <source>Directory location for the state store.</source>
          <target state="translated">상태 저장소의 디렉터리 위치입니다.</target>
        </trans-unit>
        <trans-unit id="dd74baf183e5f1e5dedcd060cf9f4e32f55a6918" translate="yes" xml:space="preserve">
          <source>Directory used for data storage.</source>
          <target state="translated">데이터 저장에 사용되는 디렉터리입니다.</target>
        </trans-unit>
        <trans-unit id="35fa85394d5564697424518371421e70030e00b5" translate="yes" xml:space="preserve">
          <source>Directory used to store session data.</source>
          <target state="translated">세션 데이터를 저장하는 데 사용되는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="989983b684a5944027ac8c4abaa3a7e7ed7ac0a5" translate="yes" xml:space="preserve">
          <source>Disable Registration of a Servlet or Filter</source>
          <target state="translated">서블릿 또는 필터 등록 비활성화</target>
        </trans-unit>
        <trans-unit id="b61ae655f73587b1150a321c3a91140e8fb351b4" translate="yes" xml:space="preserve">
          <source>Disabled endpoints are removed entirely from the application context. If you want to change only the technologies over which an endpoint is exposed, use the &lt;a href=&quot;#production-ready-endpoints-exposing-endpoints&quot;&gt;&lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; properties&lt;/a&gt; instead.</source>
          <target state="translated">비활성화 된 끝점은 응용 프로그램 컨텍스트에서 완전히 제거됩니다. 엔드 포인트가 노출되는 기술 만 변경하려면 대신 &lt;a href=&quot;#production-ready-endpoints-exposing-endpoints&quot;&gt; &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 속성을&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="78f64477efb074ba394c9fcb501e6b41df31e48b" translate="yes" xml:space="preserve">
          <source>Display name of the application.</source>
          <target state="translated">응용 프로그램의 표시 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a9820423ad30bb67c9eb2dac8b9101ef6e26921d" translate="yes" xml:space="preserve">
          <source>Displays HTTP trace information (by default, the last 100 HTTP request-response exchanges). Requires an &lt;code&gt;HttpTraceRepository&lt;/code&gt; bean.</source>
          <target state="translated">HTTP 추적 정보를 표시합니다 (기본적으로 마지막 100 개의 HTTP 요청-응답 교환). &lt;code&gt;HttpTraceRepository&lt;/code&gt; Bean이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="783799d4011b1aa4933c5ca9971ac150d806400d" translate="yes" xml:space="preserve">
          <source>Displays a collated list of all &lt;code&gt;@ConfigurationProperties&lt;/code&gt;.</source>
          <target state="translated">모든 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 의 조합 목록을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="7616cd0ad64136c165239bb79259f0283bf70d96" translate="yes" xml:space="preserve">
          <source>Displays a collated list of all &lt;code&gt;@RequestMapping&lt;/code&gt; paths.</source>
          <target state="translated">모든 &lt;code&gt;@RequestMapping&lt;/code&gt; 경로 의 조합 된 목록을 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="344ffddb399987562f6d94d84874283ffc44dde1" translate="yes" xml:space="preserve">
          <source>Displays a complete list of all the Spring beans in your application.</source>
          <target state="translated">애플리케이션에있는 모든 Spring Bean의 전체 목록을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b05c95bd1cb7866a5ffdefff1a5503276eca63ee" translate="yes" xml:space="preserve">
          <source>Displays arbitrary application info.</source>
          <target state="translated">임의의 응용 프로그램 정보를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="987ea698d2195a700999d83f907a6e449cc2f62e" translate="yes" xml:space="preserve">
          <source>Displays the scheduled tasks in your application.</source>
          <target state="translated">애플리케이션에서 예약 된 작업을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4a68c11b585f8c75a48c245ecd268086018e6cc9" translate="yes" xml:space="preserve">
          <source>Do not make assumptions about the project in which your starter is added. If the library you are auto-configuring typically requires other starters, mention them as well. Providing a proper set of &lt;em&gt;default&lt;/em&gt; dependencies may be hard if the number of optional dependencies is high, as you should avoid including dependencies that are unnecessary for a typical usage of the library. In other words, you should not include optional dependencies.</source>
          <target state="translated">스타터가 추가 된 프로젝트에 대해 가정하지 마십시오. 자동 구성하는 라이브러리에 일반적으로 다른 스타터가 필요한 경우 해당 라이브러리도 언급하십시오. 일반적인 라이브러리 사용에 불필요한 종속성을 포함하지 않아야하므로 선택적 종속성의 수가 많으면 적절한 &lt;em&gt;기본&lt;/em&gt; 종속성 집합을 제공하기 어려울 수 있습니다. 즉, 선택적 종속성을 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="27a1d22a2fc12b010d9c119da1d1f88d184e6008" translate="yes" xml:space="preserve">
          <source>Do not provide the default value in the description unless it has to be determined at runtime.</source>
          <target state="translated">런타임에 결정해야하는 경우가 아니면 설명에 기본값을 제공하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fee4b1d4b175afe84fa111347ad4054b6c67d3d0" translate="yes" xml:space="preserve">
          <source>Do not start the description by &quot;The&quot; or &quot;A&quot;.</source>
          <target state="translated">&quot;The&quot;또는 &quot;A&quot;로 설명을 시작하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0fd9c2389a41ae0942a93a2e39f1e99c8fac898d" translate="yes" xml:space="preserve">
          <source>Do not use the &lt;code&gt;src/main/webapp&lt;/code&gt; directory if your application is packaged as a jar. Although this directory is a common standard, it works &lt;strong&gt;only&lt;/strong&gt; with war packaging, and it is silently ignored by most build tools if you generate a jar.</source>
          <target state="translated">애플리케이션이 jar로 패키지 된 경우 &lt;code&gt;src/main/webapp&lt;/code&gt; 디렉토리를 사용하지 마십시오 . 이 디렉토리는 공통 표준이지만 war 패키징 &lt;strong&gt;에서만&lt;/strong&gt; 작동 하며 jar를 생성하면 대부분의 빌드 도구에서 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="6362292c75570ba8258d25e90926221efc377d8f" translate="yes" xml:space="preserve">
          <source>Dockerfiles are just one way to build docker images. Another way to build docker images is directly from your Maven or Gradle plugin, using buildpacks. If you&amp;rsquo;ve ever used an application platform such as Cloud Foundry or Heroku then you&amp;rsquo;ve probably used a buildpack. Buildpacks are the part of the platform that takes your application and converts it into something that the platform can actually run. For example, Cloud Foundry&amp;rsquo;s Java buildpack will notice that you&amp;rsquo;re pushing a &lt;code&gt;.jar&lt;/code&gt; file and automatically add a relevant JRE.</source>
          <target state="translated">Dockerfile은 Docker 이미지를 빌드하는 한 가지 방법 일뿐입니다. Docker 이미지를 빌드하는 또 다른 방법은 빌드 팩을 사용하여 Maven 또는 Gradle 플러그인에서 직접 만드는 것입니다. Cloud Foundry 또는 Heroku와 같은 애플리케이션 플랫폼을 사용한 적이 있다면 아마도 빌드 팩을 사용했을 것입니다. 빌드 팩은 애플리케이션을 가져와 플랫폼이 실제로 실행할 수있는 것으로 변환하는 플랫폼의 일부입니다. 예를 들어 Cloud Foundry의 Java 빌드 팩은 &lt;code&gt;.jar&lt;/code&gt; 파일을 푸시하고 있음을 인식하고 관련 JRE를 자동으로 추가합니다.</target>
        </trans-unit>
        <trans-unit id="aa580521ae580181d40da1e17e274b75df1b0157" translate="yes" xml:space="preserve">
          <source>Documentation Overview</source>
          <target state="translated">문서 개요</target>
        </trans-unit>
        <trans-unit id="0b58dce28d76507864509cde036a4ce2e22d6604" translate="yes" xml:space="preserve">
          <source>Documentation overview</source>
          <target state="translated">문서 개요</target>
        </trans-unit>
        <trans-unit id="12d24b7a16aa26e5b98815c7def4f6ddf1f4d782" translate="yes" xml:space="preserve">
          <source>Doing so effectively overrides the default component scan directive with the side effect of scanning those two packages regardless of the slice that you chose. For instance, a &lt;code&gt;@DataJpaTest&lt;/code&gt; seems to suddenly scan components and user configurations of your application. Again, moving the custom directive to a separate class is a good way to fix this issue.</source>
          <target state="translated">이렇게하면 선택한 슬라이스에 관계없이 두 패키지를 스캔하는 부작용이있는 기본 구성 요소 스캔 지시문이 효과적으로 무시됩니다. 예를 들어 &lt;code&gt;@DataJpaTest&lt;/code&gt; 는 갑자기 응용 프로그램의 구성 요소와 사용자 구성을 스캔 하는 것 같습니다. 다시 말하지만 사용자 지정 지시문을 별도의 클래스로 이동하는 것이이 문제를 해결하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7dc8c02700ea7e29761b21926c963e73d6bdc062" translate="yes" xml:space="preserve">
          <source>Domain for the session cookie.</source>
          <target state="translated">세션 쿠키의 도메인입니다.</target>
        </trans-unit>
        <trans-unit id="0f7c4d77638e8313fe97df2a0d66d894e7c7a9e3" translate="yes" xml:space="preserve">
          <source>Duration between the first and second attempt to deliver a message.</source>
          <target state="translated">첫 번째와 두 번째 메시지 전달 시도 사이의 기간입니다.</target>
        </trans-unit>
        <trans-unit id="734347b515788fcd48bdf195aea19e876fca2860" translate="yes" xml:space="preserve">
          <source>Duration to wait to obtain a channel if the cache size has been reached. If 0, always create a new channel.</source>
          <target state="translated">캐시 크기에 도달 한 경우 채널을 얻기 위해 대기하는 기간입니다. 0이면 항상 새 채널을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0ca70499f20be34e72df967ffb3e1d1aa00eccc9" translate="yes" xml:space="preserve">
          <source>During the application startup, the &lt;code&gt;SpringApplication&lt;/code&gt; and the &lt;code&gt;ApplicationContext&lt;/code&gt; perform many tasks related to the application lifecycle, the beans lifecycle or even processing application events. With &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html&quot;&gt;ApplicationStartup`&lt;/a&gt;, Spring Framework &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/core.html#context-functionality-startup&quot;&gt;allows you track the application startup sequence with `StartupStep`s&lt;/a&gt;. This data can be collected for profiling purposes, or just to have a better understanding of an application startup process.</source>
          <target state="translated">애플리케이션 시작 중에 &lt;code&gt;SpringApplication&lt;/code&gt; 및 &lt;code&gt;ApplicationContext&lt;/code&gt; 는 애플리케이션 라이프 사이클, Bean 라이프 사이클 또는 애플리케이션 이벤트 처리와 관련된 많은 작업을 수행합니다. 로 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/javadoc-api/org/springframework/core/metrics/ApplicationStartup.html&quot;&gt;ApplicationStartup`&lt;/a&gt; , 스프링 프레임 워크는 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/core.html#context-functionality-startup&quot;&gt;당신이`StartupStep`s와 응용 프로그램의 시작 순서를 추적 할 수 있습니다&lt;/a&gt; . 이 데이터는 프로파일 링 목적으로 수집되거나 응용 프로그램 시작 프로세스를 더 잘 이해하기 위해 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="caaeabbb953e8a6b7c8e4e482d70976863af3545" translate="yes" xml:space="preserve">
          <source>Dynatrace</source>
          <target state="translated">Dynatrace</target>
        </trans-unit>
        <trans-unit id="60de451d729d353650e2c8d6052a630f59835016" translate="yes" xml:space="preserve">
          <source>Dynatrace authentication token.</source>
          <target state="translated">Dynatrace 인증 토큰.</target>
        </trans-unit>
        <trans-unit id="69f78690e43b1dad2a2f993c7ffa2b76315a3ac1" translate="yes" xml:space="preserve">
          <source>Dynatrace registry pushes metrics to the configured URI periodically. To export metrics to &lt;a href=&quot;https://micrometer.io/docs/registry/dynatrace&quot;&gt;Dynatrace&lt;/a&gt;, your API token, device ID, and URI must be provided:</source>
          <target state="translated">Dynatrace 레지스트리는 정기적으로 구성된 URI에 메트릭을 푸시합니다. 측정 항목을 &lt;a href=&quot;https://micrometer.io/docs/registry/dynatrace&quot;&gt;Dynatrace로&lt;/a&gt; 내보내 려면 API 토큰, 기기 ID 및 URI를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="487b40f99019d657055b043a8f6d90554a2c256d" translate="yes" xml:space="preserve">
          <source>Each &amp;ldquo;property&amp;rdquo; is a configuration item that the user specifies with a given value. For example, &lt;code&gt;server.port&lt;/code&gt; and &lt;code&gt;server.address&lt;/code&gt; might be specified in &lt;code&gt;application.properties&lt;/code&gt;, as follows:</source>
          <target state="translated">각 &quot;속성&quot;은 사용자가 지정된 값으로 지정하는 구성 항목입니다. 예를 들어 &lt;code&gt;server.port&lt;/code&gt; 및 &lt;code&gt;server.address&lt;/code&gt; 는 다음과 같이 &lt;code&gt;application.properties&lt;/code&gt; 에 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="36bf6c2e2ce5c075ba8c48f645a6d95b8a0553ad" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;SpringApplication&lt;/code&gt; registers a shutdown hook with the JVM to ensure that the &lt;code&gt;ApplicationContext&lt;/code&gt; closes gracefully on exit. All the standard Spring lifecycle callbacks (such as the &lt;code&gt;DisposableBean&lt;/code&gt; interface or the &lt;code&gt;@PreDestroy&lt;/code&gt; annotation) can be used.</source>
          <target state="translated">각 &lt;code&gt;SpringApplication&lt;/code&gt; 은 종료시 &lt;code&gt;ApplicationContext&lt;/code&gt; 가 정상적으로 닫히 도록 JVM에 종료 후크를 등록합니다 . 모든 표준 Spring 라이프 사이클 콜백 (예 : &lt;code&gt;DisposableBean&lt;/code&gt; 인터페이스 또는 &lt;code&gt;@PreDestroy&lt;/code&gt; 어노테이션)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc25d6be65e1ffdf22b073474db506c92190544e" translate="yes" xml:space="preserve">
          <source>Each Spring Boot release is designed and tested against this specific set of third-party dependencies. Overriding versions may cause compatibility issues.</source>
          <target state="translated">각 Spring Boot 릴리스는이 특정 타사 종속성 세트에 대해 설계되고 테스트되었습니다. 버전을 재정의하면 호환성 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd56968b360cbbd18eb7bf5a53ea83175714b17f" translate="yes" xml:space="preserve">
          <source>Each Spring Boot web application includes an embedded web server. This feature leads to a number of how-to questions, including how to change the embedded server and how to configure the embedded server. This section answers those questions.</source>
          <target state="translated">각 Spring Boot 웹 애플리케이션에는 임베디드 웹 서버가 포함됩니다. 이 기능은 임베디드 서버를 변경하는 방법 및 임베디드 서버를 구성하는 방법을 포함하여 여러 방법에 대한 질문으로 이어집니다. 이 섹션은 이러한 질문에 대한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="0882a704cf90eabcf4266e3ec8253de36e62d62c" translate="yes" xml:space="preserve">
          <source>Each has different features and pricing models. In this document, we describe to approach using AWS Elastic Beanstalk.</source>
          <target state="translated">각각 다른 기능과 가격 모델이 있습니다. 이 문서에서는 AWS Elastic Beanstalk를 사용하여 접근하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="024bb994ca488a43758bca9522acbf184a148d9d" translate="yes" xml:space="preserve">
          <source>Each individual endpoint can be &lt;a href=&quot;#production-ready-endpoints-enabling-endpoints&quot;&gt;enabled or disabled&lt;/a&gt; and &lt;a href=&quot;#production-ready-endpoints-exposing-endpoints&quot;&gt;exposed (made remotely accessible) over HTTP or JMX&lt;/a&gt;. An endpoint is considered to be available when it is both enabled and exposed. The built-in endpoints will only be auto-configured when they are available. Most applications choose exposure via HTTP, where the ID of the endpoint along with a prefix of &lt;code&gt;/actuator&lt;/code&gt; is mapped to a URL. For example, by default, the &lt;code&gt;health&lt;/code&gt; endpoint is mapped to &lt;code&gt;/actuator/health&lt;/code&gt;.</source>
          <target state="translated">각 개별 엔드 포인트는 &lt;a href=&quot;#production-ready-endpoints-exposing-endpoints&quot;&gt;HTTP 또는 JMX를 통해 &lt;/a&gt;&lt;a href=&quot;#production-ready-endpoints-enabling-endpoints&quot;&gt;활성화 또는 비활성화&lt;/a&gt; 및 노출 (원격 액세스 가능) 할 수 있습니다 . 엔드 포인트는 활성화되고 노출 될 때 사용할 수있는 것으로 간주됩니다. 기본 제공 엔드 포인트는 사용 가능한 경우에만 자동 구성됩니다. 대부분의 응용 프로그램은 HTTP를 통해 노출을 선택합니다. 여기서 &lt;code&gt;/actuator&lt;/code&gt; 접두사와 함께 끝점의 ID가 URL에 매핑됩니다. 예를 들어 기본적으로 &lt;code&gt;health&lt;/code&gt; 엔드 포인트는 &lt;code&gt;/actuator/health&lt;/code&gt; 에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="b53c901ac1fc643e74418e8ee634cb6eb4f1c7d3" translate="yes" xml:space="preserve">
          <source>Each release of Spring Boot is associated with a base version of the Spring Framework. We &lt;strong&gt;highly&lt;/strong&gt; recommend that you not specify its version.</source>
          <target state="translated">Spring Boot의 각 릴리스는 Spring Framework의 기본 버전과 연관됩니다. 우리는 &lt;strong&gt;매우&lt;/strong&gt; 당신은 그것의 버전을 지정하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="de57090ba06d3ccfec8a7aaed5c5996c4e879ec0" translate="yes" xml:space="preserve">
          <source>Each release of Spring Boot provides a curated list of dependencies that it supports. In practice, you do not need to provide a version for any of these dependencies in your build configuration, as Spring Boot manages that for you. When you upgrade Spring Boot itself, these dependencies are upgraded as well in a consistent way.</source>
          <target state="translated">Spring Boot의 각 릴리스는 지원하는 선별 된 종속성 목록을 제공합니다. 실제로 Spring Boot에서 관리하므로 빌드 구성에서 이러한 종속성에 대한 버전을 제공 할 필요가 없습니다. Spring Boot 자체를 업그레이드하면 이러한 종속성도 일관된 방식으로 업그레이드됩니다.</target>
        </trans-unit>
        <trans-unit id="72ff319a57871fd66f629ce4c31fb3f0fe2de487" translate="yes" xml:space="preserve">
          <source>Each root property in the JSON request body can be mapped to a parameter of the endpoint. Consider the following JSON request body:</source>
          <target state="translated">JSON 요청 본문의 각 루트 속성은 끝점의 매개 변수에 매핑 될 수 있습니다. 다음 JSON 요청 본문을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1d0a9574eb0ae236dc212103234668c255d327c2" translate="yes" xml:space="preserve">
          <source>Each slice provides one or more &lt;code&gt;@AutoConfigure&amp;hellip;​&lt;/code&gt; annotations that namely defines the auto-configurations that should be included as part of a slice. Additional auto-configurations can be added on a test-by-test basis by creating a custom &lt;code&gt;@AutoConfigure&amp;hellip;​&lt;/code&gt; annotation or by adding &lt;code&gt;@ImportAutoConfiguration&lt;/code&gt; to the test as shown in the following example:</source>
          <target state="translated">각 조각은 하나 이상의 제공 &lt;code&gt;@AutoConfigure&amp;hellip;​&lt;/code&gt; 즉 조각의 한 부분으로 포함되어야하는 자동 구성을 정의하는 주석. 추가 자동 구성은 사용자 정의를 작성하여 시험에 의한 시험으로 추가 할 수 있습니다 &lt;code&gt;@AutoConfigure&amp;hellip;​&lt;/code&gt; 주석 또는 추가하여 &lt;code&gt;@ImportAutoConfiguration&lt;/code&gt; 를 다음 예와 같이 시험 :</target>
        </trans-unit>
        <trans-unit id="74a73a3cecd592b2b3d756b422b350ac01738584" translate="yes" xml:space="preserve">
          <source>Each slice restricts component scan to appropriate components and loads a very restricted set of auto-configuration classes. If you need to exclude one of them, most &lt;code&gt;@&amp;hellip;​Test&lt;/code&gt; annotations provide an &lt;code&gt;excludeAutoConfiguration&lt;/code&gt; attribute. Alternatively, you can use &lt;code&gt;@ImportAutoConfiguration#exclude&lt;/code&gt;.</source>
          <target state="translated">각 슬라이스는 구성 요소 스캔을 적절한 구성 요소로 제한하고 매우 제한된 자동 구성 클래스 집합을로드합니다. 그중 하나를 제외해야하는 경우 대부분의 &lt;code&gt;@&amp;hellip;​Test&lt;/code&gt; 주석은 &lt;code&gt;excludeAutoConfiguration&lt;/code&gt; 속성을 제공 합니다. 또는 &lt;code&gt;@ImportAutoConfiguration#exclude&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0485aaa58533b1a5f20bdc51c9f820bc56b4d9" translate="yes" xml:space="preserve">
          <source>Each store has specific additional settings. For instance, it is possible to customize the name of the table for the JDBC store, as shown in the following example:</source>
          <target state="translated">각 상점에는 특정 추가 설정이 있습니다. 예를 들어 다음 예와 같이 JDBC 저장소의 테이블 이름을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22a6c4bbe10d2eebababb90132eddb253bd98294" translate="yes" xml:space="preserve">
          <source>Each test can use the runner to represent a particular use case. For instance, the sample below invokes a user configuration (&lt;code&gt;UserConfiguration&lt;/code&gt;) and checks that the auto-configuration backs off properly. Invoking &lt;code&gt;run&lt;/code&gt; provides a callback context that can be used with &lt;code&gt;AssertJ&lt;/code&gt;.</source>
          <target state="translated">각 테스트는 실행기를 사용하여 특정 사용 사례를 나타낼 수 있습니다. 예를 들어 아래 샘플은 사용자 구성 ( &lt;code&gt;UserConfiguration&lt;/code&gt; )을 호출 하고 자동 구성이 제대로 백 오프되는지 확인합니다. &lt;code&gt;run&lt;/code&gt; 호출하면 &lt;code&gt;AssertJ&lt;/code&gt; 와 함께 사용할 수있는 콜백 컨텍스트가 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="94d4c5139b9b3302234022e3af4d0e81221ce67d" translate="yes" xml:space="preserve">
          <source>EhCache 2</source>
          <target state="translated">EhCache 2</target>
        </trans-unit>
        <trans-unit id="27847cec5b4925fa95b8045ccadba6240742336c" translate="yes" xml:space="preserve">
          <source>EhCache 2.x</source>
          <target state="translated">EhCache 2.x</target>
        </trans-unit>
        <trans-unit id="19cd1797656bfb231dd4aa8aaf3bae33135688e7" translate="yes" xml:space="preserve">
          <source>Either way, your starter must reference the core Spring Boot starter (&lt;code&gt;spring-boot-starter&lt;/code&gt;) directly or indirectly (i.e. no need to add it if your starter relies on another starter). If a project is created with only your custom starter, Spring Boot&amp;rsquo;s core features will be honoured by the presence of the core starter.</source>
          <target state="translated">어느 쪽이든, 스타터는 핵심 Spring Boot 스타터 ( &lt;code&gt;spring-boot-starter&lt;/code&gt; )를 직접 또는 간접적으로 참조해야합니다 (즉, 스타터가 다른 스타터에 의존하는 경우 추가 할 필요가 없음). 커스텀 스타터로만 프로젝트가 생성되는 경우 Spring Boot의 핵심 기능은 코어 스타터의 존재로 인정됩니다.</target>
        </trans-unit>
        <trans-unit id="296abb15d702ea5d538395a2f9337c6040f0c3e3" translate="yes" xml:space="preserve">
          <source>Elastic</source>
          <target state="translated">Elastic</target>
        </trans-unit>
        <trans-unit id="85bb5d88d7f7c89b76d36dfc3c4155f873032a5e" translate="yes" xml:space="preserve">
          <source>Elasticsearch</source>
          <target state="translated">Elasticsearch</target>
        </trans-unit>
        <trans-unit id="1a0bf38af44b3a7e9b1b286fe90b2ca54340cc27" translate="yes" xml:space="preserve">
          <source>Elasticsearch ships &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html&quot;&gt;two different REST clients&lt;/a&gt; that you can use to query a cluster: the &quot;Low Level&quot; client and the &quot;High Level&quot; client. Spring Boot provides support for the &quot;High Level&quot; client, which ships with &lt;code&gt;org.elasticsearch.client:elasticsearch-rest-high-level-client&lt;/code&gt;.</source>
          <target state="translated">Elasticsearch 는 클러스터를 쿼리하는 데 사용할 수있는 &lt;a href=&quot;https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/index.html&quot;&gt;두 가지 REST 클라이언트 인&lt;/a&gt; &quot;Low Level&quot;클라이언트와 &quot;High Level&quot;클라이언트를 제공합니다. Spring Boot는 &lt;code&gt;org.elasticsearch.client:elasticsearch-rest-high-level-client&lt;/code&gt; 와 함께 제공되는 &quot;High Level&quot;클라이언트에 대한 지원을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="49fa9fd831096c82ab950bc7aa0a0a7ef8a10998" translate="yes" xml:space="preserve">
          <source>Element</source>
          <target state="translated">Element</target>
        </trans-unit>
        <trans-unit id="54d9b4aa17dfd099f8778a28256680c9e857929f" translate="yes" xml:space="preserve">
          <source>Embedded Containers</source>
          <target state="translated">임베디드 컨테이너</target>
        </trans-unit>
        <trans-unit id="178eb89c65491c47b3bc4b8488261e6587464a00" translate="yes" xml:space="preserve">
          <source>Embedded LDAP password.</source>
          <target state="translated">내장 된 LDAP 비밀번호.</target>
        </trans-unit>
        <trans-unit id="e663fbe67e960b4816bcf34c3f2dc44badd62c79" translate="yes" xml:space="preserve">
          <source>Embedded LDAP port.</source>
          <target state="translated">내장 된 LDAP 포트.</target>
        </trans-unit>
        <trans-unit id="3178f04fdf229294a1ca7040e2316b48d504ee1e" translate="yes" xml:space="preserve">
          <source>Embedded LDAP username.</source>
          <target state="translated">내장 된 LDAP 사용자 이름.</target>
        </trans-unit>
        <trans-unit id="e22f22ac3a79abee8b8ff0059ab749a721686450" translate="yes" xml:space="preserve">
          <source>Embedded Tomcat&amp;rsquo;s MBean registry is disabled by default. This minimizes Tomcat&amp;rsquo;s memory footprint. If you want to use Tomcat&amp;rsquo;s MBeans, for example so that they can be used to expose metrics via Micrometer, you must use the &lt;code&gt;server.tomcat.mbeanregistry.enabled&lt;/code&gt; property to do so, as shown in the following example:</source>
          <target state="translated">임베디드 Tomcat의 MBean 레지스트리는 기본적으로 비활성화되어 있습니다. 이것은 Tomcat의 메모리 공간을 최소화합니다. 예를 들어 Tomcat의 MBean을 사용하여 Micrometer를 통해 메트릭을 노출하는 데 사용할 수 있도록하려면 다음 예제와 같이 &lt;code&gt;server.tomcat.mbeanregistry.enabled&lt;/code&gt; 속성을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4dd079f31695ccd243bae307e0e60b295513e46c" translate="yes" xml:space="preserve">
          <source>Embedded servlet containers do not directly execute the Servlet 3.0+ &lt;code&gt;javax.servlet.ServletContainerInitializer&lt;/code&gt; interface or Spring&amp;rsquo;s &lt;code&gt;org.springframework.web.WebApplicationInitializer&lt;/code&gt; interface. This is an intentional design decision intended to reduce the risk that third party libraries designed to run inside a war may break Spring Boot applications.</source>
          <target state="translated">임베디드 서블릿 컨테이너는 Servlet 3.0+ &lt;code&gt;javax.servlet.ServletContainerInitializer&lt;/code&gt; 인터페이스 또는 Spring의 &lt;code&gt;org.springframework.web.WebApplicationInitializer&lt;/code&gt; 인터페이스를 직접 실행하지 않습니다 . 이것은 전쟁 내에서 실행되도록 설계된 타사 라이브러리가 Spring Boot 애플리케이션을 손상시킬 수있는 위험을 줄이기위한 의도적 인 설계 결정입니다.</target>
        </trans-unit>
        <trans-unit id="0cb526923402db66e067a33d3ef8e2fa94bb8959" translate="yes" xml:space="preserve">
          <source>Enable SSL support.</source>
          <target state="translated">SSL 지원을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="f76eeaf39f51c1c42bcdcbf175a9b01963ee023c" translate="yes" xml:space="preserve">
          <source>Enable access log.</source>
          <target state="translated">액세스 로그를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="773636133688457bddf43b8d629b0d39c59df7c7" translate="yes" xml:space="preserve">
          <source>Enable debug logs.</source>
          <target state="translated">디버그 로그를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="eae8575d4ce36b1c5a96e1be2ae6aec6ed46ed22" translate="yes" xml:space="preserve">
          <source>Enable publishing via a Prometheus Pushgateway.</source>
          <target state="translated">Prometheus Pushgateway를 통해 게시를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="33c4fd806c5367a866f3c49dac7a746471ace9b3" translate="yes" xml:space="preserve">
          <source>Enable the SpringEL compiler in SpringEL expressions.</source>
          <target state="translated">SpringEL 표현식에서 SpringEL 컴파일러를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c4d70ab1fa40483a7d264e9eb8a9b693040df173" translate="yes" xml:space="preserve">
          <source>Enable trace logs.</source>
          <target state="translated">추적 로그를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="bbb3d9db9ba3fd9f28efc218582602e274f02054" translate="yes" xml:space="preserve">
          <source>Enabled SSL protocols.</source>
          <target state="translated">SSL 프로토콜을 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="2bdd31b842ab953f10cda73a60afc8fc99eed91e" translate="yes" xml:space="preserve">
          <source>Enabling Kafka Streams means that the application id and bootstrap servers must be set. The former can be configured using &lt;code&gt;spring.kafka.streams.application-id&lt;/code&gt;, defaulting to &lt;code&gt;spring.application.name&lt;/code&gt; if not set. The latter can be set globally or specifically overridden only for streams.</source>
          <target state="translated">Kafka Streams를 활성화한다는 것은 애플리케이션 ID 및 부트 스트랩 서버를 설정해야 함을 의미합니다. 전자는 &lt;code&gt;spring.kafka.streams.application-id&lt;/code&gt; 를 사용하여 구성 할 수 있으며 설정 되지 않은 경우 기본값은 &lt;code&gt;spring.application.name&lt;/code&gt; 입니다. 후자는 전체적으로 설정하거나 스트림에 대해서만 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a513f5929bfabf6e72cf2ec8756ebd80069f908e" translate="yes" xml:space="preserve">
          <source>Encoding of SQL migrations.</source>
          <target state="translated">SQL 마이그레이션의 인코딩.</target>
        </trans-unit>
        <trans-unit id="da55a85012e77b4cda620c1cd192a8e11b521f86" translate="yes" xml:space="preserve">
          <source>Endpoint IDs that should be excluded or '*' for all.</source>
          <target state="translated">제외해야하는 끝점 ID 또는 모두에 대해 '*'.</target>
        </trans-unit>
        <trans-unit id="34f7599847cc87b0dfbc0434707f867d8fba67b3" translate="yes" xml:space="preserve">
          <source>Endpoint IDs that should be included or '*' for all.</source>
          <target state="translated">포함되어야하는 끝점 ID 또는 모두에 대해 '*'.</target>
        </trans-unit>
        <trans-unit id="90a3bf8ecb216823110a52e0f6e19dc4f64ebeba" translate="yes" xml:space="preserve">
          <source>Endpoints JMX domain name. Fallback to 'spring.jmx.default-domain' if set.</source>
          <target state="translated">Endpoints JMX 도메인 이름. 설정된 경우 'spring.jmx.default-domain'으로 대체합니다.</target>
        </trans-unit>
        <trans-unit id="2d506aa947ea19c4d70aff17eb92c7a09e6b2c32" translate="yes" xml:space="preserve">
          <source>Endpoints automatically cache responses to read operations that do not take any parameters. To configure the amount of time for which an endpoint will cache a response, use its &lt;code&gt;cache.time-to-live&lt;/code&gt; property. The following example sets the time-to-live of the &lt;code&gt;beans&lt;/code&gt; endpoint&amp;rsquo;s cache to 10 seconds:</source>
          <target state="translated">엔드 포인트는 매개 변수를 사용하지 않는 읽기 작업에 대한 응답을 자동으로 캐시합니다. 엔드 포인트가 응답을 캐시하는 시간을 구성하려면 &lt;code&gt;cache.time-to-live&lt;/code&gt; 속성을 사용하십시오. 다음 예제는 &lt;code&gt;beans&lt;/code&gt; 엔드 포인트 캐시의 수명 을 10 초로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="772bb62721b3b1bea8828a87772aa20a09b7a184" translate="yes" xml:space="preserve">
          <source>Ensuring that all your main endpoints are only available over HTTPS is an important chore for any application. If you use Tomcat as a servlet container, then Spring Boot adds Tomcat&amp;rsquo;s own &lt;code&gt;RemoteIpValve&lt;/code&gt; automatically if it detects some environment settings, and you should be able to rely on the &lt;code&gt;HttpServletRequest&lt;/code&gt; to report whether it is secure or not (even downstream of a proxy server that handles the real SSL termination). The standard behavior is determined by the presence or absence of certain request headers (&lt;code&gt;x-forwarded-for&lt;/code&gt; and &lt;code&gt;x-forwarded-proto&lt;/code&gt;), whose names are conventional, so it should work with most front-end proxies. You can switch on the valve by adding some entries to &lt;code&gt;application.properties&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">모든 주요 엔드 포인트를 HTTPS를 통해서만 사용할 수 있도록하는 것은 모든 애플리케이션에서 중요한 일입니다. Tomcat을 서블릿 컨테이너로 사용하는 경우 Spring Boot는 일부 환경 설정을 감지하면 Tomcat의 자체 &lt;code&gt;RemoteIpValve&lt;/code&gt; 를 자동으로 추가 하고 &lt;code&gt;HttpServletRequest&lt;/code&gt; 에 의존하여 보안 여부를보고 할 수 있어야합니다 (프록시 서버의 다운 스트림에서도 실제 SSL 종료를 처리합니다.) 표준 동작은 이름이 일반적인 특정 요청 헤더 ( &lt;code&gt;x-forwarded-for&lt;/code&gt; 및 &lt;code&gt;x-forwarded-proto&lt;/code&gt; ) 의 존재 여부에 따라 결정 되므로 대부분의 프런트 엔드 프록시에서 작동해야합니다. &lt;code&gt;application.properties&lt;/code&gt; 에 일부 항목을 추가하여 밸브를 켤 수 있습니다., 다음 예와 같이 :</target>
        </trans-unit>
        <trans-unit id="a276834f3ddef270e2e2a383aa172cddd5f9d0cc" translate="yes" xml:space="preserve">
          <source>Entry expiration. By default the entries never expire.</source>
          <target state="translated">항목 만료. 기본적으로 항목은 만료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa10f7def669bbb7c61a19654561e6db19234cf8" translate="yes" xml:space="preserve">
          <source>Entry expiration. By default the entries never expire. Note that this value is ultimately converted to seconds.</source>
          <target state="translated">항목 만료. 기본적으로 항목은 만료되지 않습니다. 이 값은 궁극적으로 초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="20588ae8e5c269292d35f9dfffa8f2eb3fd3c259" translate="yes" xml:space="preserve">
          <source>Enum</source>
          <target state="translated">Enum</target>
        </trans-unit>
        <trans-unit id="ec072bba7befaa68af710fe3549eb0491d7badd1" translate="yes" xml:space="preserve">
          <source>Environment Variables</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="1fd9ebabc73d44769bebe3309979c884ce26c72d" translate="yes" xml:space="preserve">
          <source>Environment variable</source>
          <target state="translated">환경 변수</target>
        </trans-unit>
        <trans-unit id="b120e412cefecf05219b172c4626c24c4049858f" translate="yes" xml:space="preserve">
          <source>Environment variables and system properties often have restrictions that mean some property names cannot be used. To help with this, Spring Boot allows you to encode a block of properties into a single JSON structure.</source>
          <target state="translated">환경 변수 및 시스템 속성에는 종종 일부 속성 이름을 사용할 수 없다는 제한이 있습니다. 이를 돕기 위해 Spring Boot를 사용하면 속성 블록을 단일 JSON 구조로 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29757846179f1e29ecccd4f1df50df997cd4c3f9" translate="yes" xml:space="preserve">
          <source>Environment variables can also be used when binding to object lists. To bind to a &lt;code&gt;List&lt;/code&gt;, the element number should be surrounded with underscores in the variable name.</source>
          <target state="translated">환경 변수는 개체 목록에 바인딩 할 때도 사용할 수 있습니다. &lt;code&gt;List&lt;/code&gt; 에 바인딩하려면 변수 이름에서 요소 번호를 밑줄로 묶어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a50abd62e9ec4d3f4982969e24ecb94e547e6e71" translate="yes" xml:space="preserve">
          <source>Environment variables do not always make for the easiest API, so Spring Boot automatically extracts them and flattens the data into properties that can be accessed through Spring&amp;rsquo;s &lt;code&gt;Environment&lt;/code&gt; abstraction, as shown in the following example:</source>
          <target state="translated">환경 변수가 항상 가장 쉬운 API를 만드는 것은 아니기 때문에 Spring Boot는 자동으로이를 추출하고 다음 예제와 같이 Spring의 &lt;code&gt;Environment&lt;/code&gt; 추상화를 통해 액세스 할 수있는 속성으로 데이터를 평면화합니다 .</target>
        </trans-unit>
        <trans-unit id="49be7086260391d1a496c2fcd57933a6be3aaae8" translate="yes" xml:space="preserve">
          <source>Error handling in a war deployment</source>
          <target state="translated">전쟁 배치시 오류 처리</target>
        </trans-unit>
        <trans-unit id="ddd2d090e72c81d18ef7c976c8efdb345bf54ad6" translate="yes" xml:space="preserve">
          <source>Error management: Location of the error page (&lt;code&gt;server.error.path&lt;/code&gt;) and so on.</source>
          <target state="translated">오류 관리 : 오류 페이지 ( &lt;code&gt;server.error.path&lt;/code&gt; ) 의 위치 등입니다 .</target>
        </trans-unit>
        <trans-unit id="6ef3071e87beffdcb8621ec6dc293a99bae72a8a" translate="yes" xml:space="preserve">
          <source>Even if the default &lt;code&gt;EntityManagerFactory&lt;/code&gt; works fine, you need to define a new one, otherwise the presence of the second bean of that type switches off the default. You can use the &lt;code&gt;EntityManagerBuilder&lt;/code&gt; provided by Spring Boot to help you to create one. Alternatively, you can use the &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; directly from Spring ORM, as shown in the following example:</source>
          <target state="translated">기본 &lt;code&gt;EntityManagerFactory&lt;/code&gt; 가 제대로 작동 하더라도 새 항목을 정의해야합니다. 그렇지 않으면 해당 유형의 두 번째 Bean이 있으면 기본값이 해제됩니다. Spring Boot에서 제공 하는 &lt;code&gt;EntityManagerBuilder&lt;/code&gt; 를 사용하여 만들 수 있습니다. 또는 다음 예제와 같이 Spring ORM에서 직접 &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="259a026dfefedcc7d7cdaeacabf12ab96ca02faa" translate="yes" xml:space="preserve">
          <source>Even though auto-configuration classes are &lt;code&gt;public&lt;/code&gt;, the only aspect of the class that is considered public API is the name of the class which can be used for disabling the auto-configuration. The actual contents of those classes, such as nested configuration classes or bean methods are for internal use only and we do not recommend using those directly.</source>
          <target state="translated">자동 구성 클래스가 &lt;code&gt;public&lt;/code&gt; 이지만 공용 API로 간주되는 클래스의 유일한 측면은 자동 구성을 비활성화하는 데 사용할 수있는 클래스의 이름입니다. 중첩 된 구성 클래스 또는 빈 메서드와 같은 이러한 클래스의 실제 내용은 내부 전용이며 직접 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4e863c9ae41366806c00d49b9f1902687cf67c5a" translate="yes" xml:space="preserve">
          <source>Event listeners should not run potentially lengthy tasks as they execute in the same thread by default. Consider using &lt;a href=&quot;#boot-features-command-line-runner&quot;&gt;application and command-line runners&lt;/a&gt; instead.</source>
          <target state="translated">이벤트 리스너는 기본적으로 동일한 스레드에서 실행되므로 잠재적으로 긴 작업을 실행해서는 안됩니다. 사용을 고려 &lt;a href=&quot;#boot-features-command-line-runner&quot;&gt;응용 프로그램 및 명령 줄 주자를&lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="41504b7a926fddb8b0d723fece66caaf5671a01f" translate="yes" xml:space="preserve">
          <source>Executable Jars</source>
          <target state="translated">실행 가능한 항아리</target>
        </trans-unit>
        <trans-unit id="c95d2ae599b396b50f9ebe6f642c01f6e97b46cc" translate="yes" xml:space="preserve">
          <source>Executable jars and Java</source>
          <target state="translated">실행 가능한 jar 및 Java</target>
        </trans-unit>
        <trans-unit id="61ca4228141bee8d5408cc0976255c84e34f1e4a" translate="yes" xml:space="preserve">
          <source>Executable jars can be used for production deployment. As they are self-contained, they are also ideally suited for cloud-based deployment.</source>
          <target state="translated">실행 가능한 jar는 프로덕션 배포에 사용할 수 있습니다. 독립형이므로 클라우드 기반 배포에도 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5fb2467614237c816cc7e729a955154aef4cbc91" translate="yes" xml:space="preserve">
          <source>Execute all Spring Batch jobs in the context on startup.</source>
          <target state="translated">시작시 컨텍스트에서 모든 Spring Batch 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="79220ff4483ca6fb845e3d5a84e3727784570839" translate="yes" xml:space="preserve">
          <source>Expected character encoding the application must use.</source>
          <target state="translated">애플리케이션에서 사용해야하는 예상 문자 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="95f5fe66bd259b64ee55a44d1257ca894ddeac9b" translate="yes" xml:space="preserve">
          <source>Expected time between heartbeats to the consumer coordinator.</source>
          <target state="translated">소비자 코디네이터에 대한 하트 비트 사이의 예상 시간입니다.</target>
        </trans-unit>
        <trans-unit id="37c60f14874c63b50f514c709adfc5d99ec9ade0" translate="yes" xml:space="preserve">
          <source>Explicit build support is provided for the following build tools:</source>
          <target state="translated">다음 빌드 도구에 대해 명시 적 빌드 지원이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="adfcfbbb18919e7bab56974a72c22075805245b4" translate="yes" xml:space="preserve">
          <source>Expose management beans to the JMX domain.</source>
          <target state="translated">JMX 도메인에 관리 Bean을 노출하십시오.</target>
        </trans-unit>
        <trans-unit id="484036c4d472c393b5472ba6835b598c191fe24f" translate="yes" xml:space="preserve">
          <source>Exposes JMX beans over HTTP (when Jolokia is on the classpath, not available for WebFlux). Requires a dependency on &lt;code&gt;jolokia-core&lt;/code&gt;.</source>
          <target state="translated">HTTP를 통해 JMX 빈을 노출합니다 (Jolokia가 클래스 경로에있을 때 WebFlux에서 사용할 수 없음). &lt;code&gt;jolokia-core&lt;/code&gt; 에 대한 종속성이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="18b60babfeef455313b4e35ad0f80e3466fd3f96" translate="yes" xml:space="preserve">
          <source>Exposes any key from the &lt;code&gt;Environment&lt;/code&gt; under the &lt;code&gt;info&lt;/code&gt; key.</source>
          <target state="translated">&lt;code&gt;Environment&lt;/code&gt; 에서 &lt;code&gt;info&lt;/code&gt; 키 아래의 모든 키를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="a64f3a2e55f81199d3eaff18b8dccf0b0144c2ef" translate="yes" xml:space="preserve">
          <source>Exposes audit events information for the current application. Requires an &lt;code&gt;AuditEventRepository&lt;/code&gt; bean.</source>
          <target state="translated">현재 애플리케이션에 대한 감사 이벤트 정보를 노출합니다. &lt;code&gt;AuditEventRepository&lt;/code&gt; Bean이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="c356a57069a3372667c50c11756a176cc9dcb1c9" translate="yes" xml:space="preserve">
          <source>Exposes available caches.</source>
          <target state="translated">사용 가능한 캐시를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="3565355ce841e4af8d26aa0a8c2df33fb331bc85" translate="yes" xml:space="preserve">
          <source>Exposes build information if a &lt;code&gt;META-INF/build-info.properties&lt;/code&gt; file is available.</source>
          <target state="translated">&lt;code&gt;META-INF/build-info.properties&lt;/code&gt; 파일을 사용할 수 있는 경우 빌드 정보를 표시 합니다.</target>
        </trans-unit>
        <trans-unit id="f9054bf111463bc2c76025611297a3a2ea9f1845" translate="yes" xml:space="preserve">
          <source>Exposes git information if a &lt;code&gt;git.properties&lt;/code&gt; file is available.</source>
          <target state="translated">&lt;code&gt;git.properties&lt;/code&gt; 파일을 사용할 수 있는 경우 git 정보를 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="fde294e457c645bb28309c1286925451469b2aab" translate="yes" xml:space="preserve">
          <source>Exposes metrics in a format that can be scraped by a Prometheus server. Requires a dependency on &lt;code&gt;micrometer-registry-prometheus&lt;/code&gt;.</source>
          <target state="translated">Prometheus 서버에서 스크랩 할 수있는 형식으로 메트릭을 노출합니다. &lt;code&gt;micrometer-registry-prometheus&lt;/code&gt; 에 대한 종속성이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="d0b7e616fdaddd1b506882f956fa4ddd0a0901b2" translate="yes" xml:space="preserve">
          <source>Exposes properties from Spring&amp;rsquo;s &lt;code&gt;ConfigurableEnvironment&lt;/code&gt;.</source>
          <target state="translated">Spring의 &lt;code&gt;ConfigurableEnvironment&lt;/code&gt; 에서 속성을 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="67c89edf897cffcfc7fc7d844355e2b2efbb1996" translate="yes" xml:space="preserve">
          <source>Exposes the &quot;Liveness&quot; application availability state.</source>
          <target state="translated">&quot;활성&quot;애플리케이션 가용성 상태를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="3bbdc34770c1a19a93eea47b1285f30699d78b1b" translate="yes" xml:space="preserve">
          <source>Exposes the &quot;Readiness&quot; application availability state.</source>
          <target state="translated">&quot;준비&quot;애플리케이션 가용성 상태를 노출합니다.</target>
        </trans-unit>
        <trans-unit id="3be998ab916d8a8a8685731198cd59bc1ed3ab9c" translate="yes" xml:space="preserve">
          <source>Exposing management endpoints by using the default HTTP port is a sensible choice for cloud-based deployments. If, however, your application runs inside your own data center, you may prefer to expose endpoints by using a different HTTP port.</source>
          <target state="translated">기본 HTTP 포트를 사용하여 관리 엔드 포인트를 노출하는 것은 클라우드 기반 배포를위한 현명한 선택입니다. 그러나 애플리케이션이 자체 데이터 센터 내에서 실행되는 경우 다른 HTTP 포트를 사용하여 엔드 포인트를 노출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1a0d71e0685e6b7ae4eb2258aca44b221f6dccfe" translate="yes" xml:space="preserve">
          <source>External Configuration</source>
          <target state="translated">외부 구성</target>
        </trans-unit>
        <trans-unit id="356f95cff80343973127f70ef9fb59ba7cbd4b52" translate="yes" xml:space="preserve">
          <source>External Logfile to be accessed. Can be used if the logfile is written by output redirect and not by the logging system itself.</source>
          <target state="translated">액세스 할 외부 로그 파일입니다. 로그 파일이 로깅 시스템 자체가 아닌 출력 리디렉션에 의해 기록 된 경우 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02d1958d53bd921a42f1a13a88547ced00f199cc" translate="yes" xml:space="preserve">
          <source>External properties, logging, and other features of Spring Boot are installed in the context by default only if you use &lt;code&gt;SpringApplication&lt;/code&gt; to create it.</source>
          <target state="translated">&lt;code&gt;SpringApplication&lt;/code&gt; 을 사용 하여 생성하는 경우에만 Spring Boot의 외부 속성, 로깅 및 기타 기능이 기본적으로 컨텍스트에 설치됩니다 .</target>
        </trans-unit>
        <trans-unit id="50b7c4b70a207fa9da95a9b429f824925f1afcda" translate="yes" xml:space="preserve">
          <source>Fails if ApplicationPidFileWriter is used but it cannot write the PID file.</source>
          <target state="translated">ApplicationPidFileWriter를 사용하는 경우 실패하지만 PID 파일을 쓸 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="d1e2bf582203cb69226ff6c6dccdf943b8e26265" translate="yes" xml:space="preserve">
          <source>File descriptor metrics</source>
          <target state="translated">파일 설명자 메트릭</target>
        </trans-unit>
        <trans-unit id="941a4eab974c7f5ff0cd7aafd71797422278e1a9" translate="yes" xml:space="preserve">
          <source>File encoding.</source>
          <target state="translated">파일 인코딩.</target>
        </trans-unit>
        <trans-unit id="401034bbeaf84c18aebe83c5247645a424982132" translate="yes" xml:space="preserve">
          <source>File name prefix for SQL migrations.</source>
          <target state="translated">SQL 마이그레이션을위한 파일 이름 접두사.</target>
        </trans-unit>
        <trans-unit id="eeafe8bb43af78da1f69a67d458cd355a3bb5346" translate="yes" xml:space="preserve">
          <source>File name prefix for repeatable SQL migrations.</source>
          <target state="translated">반복 가능한 SQL 마이그레이션을위한 파일 이름 접두사.</target>
        </trans-unit>
        <trans-unit id="76791b30a993e59e9639263164bfd9f00e5dc687" translate="yes" xml:space="preserve">
          <source>File name separator for SQL migrations.</source>
          <target state="translated">SQL 마이그레이션을위한 파일 이름 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="547f5f164d60c1374b1d04e75e8125d23a26dea4" translate="yes" xml:space="preserve">
          <source>File name suffix for SQL migrations.</source>
          <target state="translated">SQL 마이그레이션을위한 파일 이름 접미사.</target>
        </trans-unit>
        <trans-unit id="c4bb047317cb8ba0e488310569bee37168a008ff" translate="yes" xml:space="preserve">
          <source>File names</source>
          <target state="translated">파일 이름</target>
        </trans-unit>
        <trans-unit id="9ffa06e1aa7308ed20bd685308473660ccf2694b" translate="yes" xml:space="preserve">
          <source>File to which rollback SQL is written when an update is performed.</source>
          <target state="translated">업데이트가 수행 될 때 롤백 SQL이 기록되는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="ebd7f1fd9f5abb0d5a9f6dd8ad4067961d5c97bf" translate="yes" xml:space="preserve">
          <source>Files are only monitored when the remote client is running. If you change a file before starting the remote client, it is not pushed to the remote server.</source>
          <target state="translated">원격 클라이언트가 실행 중일 때만 파일이 모니터링됩니다. 원격 클라이언트를 시작하기 전에 파일을 변경하면 원격 서버로 푸시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cdb40698ba03968d966b7de028980e1a43e4f404" translate="yes" xml:space="preserve">
          <source>Finally, &amp;ldquo;hints&amp;rdquo; are additional information used to assist the user in configuring a given property. For example, when a developer is configuring the &lt;code&gt;spring.jpa.hibernate.ddl-auto&lt;/code&gt; property, a tool can use the hints to offer some auto-completion help for the &lt;code&gt;none&lt;/code&gt;, &lt;code&gt;validate&lt;/code&gt;, &lt;code&gt;update&lt;/code&gt;, &lt;code&gt;create&lt;/code&gt;, and &lt;code&gt;create-drop&lt;/code&gt; values.</source>
          <target state="translated">마지막으로 &quot;힌트&quot;는 사용자가 지정된 속성을 구성하는 데 도움이되는 추가 정보입니다. 예를 들어 개발자가 &lt;code&gt;spring.jpa.hibernate.ddl-auto&lt;/code&gt; 속성을 구성 할 때 도구는 힌트를 사용하여 &lt;code&gt;none&lt;/code&gt; , &lt;code&gt;validate&lt;/code&gt; , &lt;code&gt;update&lt;/code&gt; , &lt;code&gt;create&lt;/code&gt; 및 &lt;code&gt;create-drop&lt;/code&gt; 값에 대한 일부 자동 완성 도움말을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54796cf68b13bab208f3d1c6e04125a50dc4562d" translate="yes" xml:space="preserve">
          <source>Finally, Spring Boot also includes the following starters that can be used if you want to exclude or swap specific technical facets:</source>
          <target state="translated">마지막으로 Spring Boot에는 특정 기술 측면을 제외하거나 교체하려는 경우 사용할 수있는 다음 스타터도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3437d6eb34c1b82ded5f2d5d8edc4a8f63744b4" translate="yes" xml:space="preserve">
          <source>Finally, access logging for Jetty can also be configured as follows:</source>
          <target state="translated">마지막으로 Jetty에 대한 액세스 로깅을 다음과 같이 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b9f1f56b4e6bc41435b004bb5c4dd62983499ae" translate="yes" xml:space="preserve">
          <source>Finally, if you need access to web-framework-specific functionality, you can implement Servlet or Spring &lt;code&gt;@Controller&lt;/code&gt; and &lt;code&gt;@RestController&lt;/code&gt; endpoints at the cost of them not being available over JMX or when using a different web framework.</source>
          <target state="translated">마지막으로 웹 프레임 워크 관련 기능에 액세스해야하는 경우 JMX를 통해 사용할 수 없거나 다른 웹 프레임 워크를 사용할 때 Servlet 또는 Spring &lt;code&gt;@Controller&lt;/code&gt; 및 &lt;code&gt;@RestController&lt;/code&gt; 엔드 포인트를 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5012eb20586613bcbd3554d86839494001c6ccea" translate="yes" xml:space="preserve">
          <source>Finally, only standard Java Bean properties are considered and binding on static properties is not supported.</source>
          <target state="translated">마지막으로 표준 Java Bean 속성 만 고려되며 정적 속성에 대한 바인딩은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cfee69ddc3ee2f96cba9e22744f5c118ec425106" translate="yes" xml:space="preserve">
          <source>Finally, the &lt;a href=&quot;build-tool-plugins#build-tool-plugins&quot;&gt;Maven and Gradle plugins&lt;/a&gt; can be configured (see the &lt;code&gt;addResources&lt;/code&gt; property) to support running from the command line with reloading of static files directly from source. You can use that with an external css/js compiler process if you are writing that code with higher-level tools.</source>
          <target state="translated">마지막으로, 소스에서 직접 정적 파일을 다시로드하여 명령 줄에서 실행을 지원 하도록 &lt;a href=&quot;build-tool-plugins#build-tool-plugins&quot;&gt;Maven 및 Gradle 플러그인&lt;/a&gt; 을 구성 할 수 있습니다 ( &lt;code&gt;addResources&lt;/code&gt; 속성 참조 ). 상위 수준 도구로 해당 코드를 작성하는 경우 외부 css / js 컴파일러 프로세스와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b911548a362b7f9d6b4b8069610dc09e4515d66" translate="yes" xml:space="preserve">
          <source>Finally, we have a few topics for more advanced users:</source>
          <target state="translated">마지막으로 고급 사용자를위한 몇 가지 주제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1c583139b3fe4634039da72ef3fee73b0d9828" translate="yes" xml:space="preserve">
          <source>Finally, you can also create your own &lt;code&gt;RestTemplateBuilder&lt;/code&gt; bean. To prevent switching off the auto-configuration of a &lt;code&gt;RestTemplateBuilder&lt;/code&gt; and prevent any &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; beans from being used, make sure to configure your custom instance with a &lt;code&gt;RestTemplateBuilderConfigurer&lt;/code&gt;. The following example exposes a &lt;code&gt;RestTemplateBuilder&lt;/code&gt; with what Spring Boot would auto-configure, except that custom connect and read timeouts are also specified:</source>
          <target state="translated">마지막으로 자신 만의 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 빈을 생성 할 수도 있습니다 . a의 자동 구성 끄는 방지하기 위해 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 을 하고 방지 &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; 의 와 사용자 정의 인스턴스를 구성 할 수 있는지, 메이크업에 사용되는 콩을 &lt;code&gt;RestTemplateBuilderConfigurer&lt;/code&gt; . 다음 예제는 사용자 지정 연결 및 읽기 제한 시간도 지정된다는 점을 제외하고 Spring Boot가 자동 구성 하는 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 를 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="490df8447c2401717a3ae55fcbe041a582662acc" translate="yes" xml:space="preserve">
          <source>Finally, you can fall back to the original API and use &lt;code&gt;WebClient.create()&lt;/code&gt;. In that case, no auto-configuration or &lt;code&gt;WebClientCustomizer&lt;/code&gt; is applied.</source>
          <target state="translated">마지막으로 원래 API로 돌아가서 &lt;code&gt;WebClient.create()&lt;/code&gt; 사용할 수 있습니다 . 이 경우 자동 구성 또는 &lt;code&gt;WebClientCustomizer&lt;/code&gt; 가 적용 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="36ae5f1fb37c7f3bc98ec5d57afa7c455fa60ee6" translate="yes" xml:space="preserve">
          <source>Finally, you can take full control by defining your own &lt;code&gt;NewRelicClientProvider&lt;/code&gt; bean.</source>
          <target state="translated">마지막으로 자신의 &lt;code&gt;NewRelicClientProvider&lt;/code&gt; 빈 을 정의하여 모든 권한을 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="788d22c601e8a6677809fd015fe8ef715d55305d" translate="yes" xml:space="preserve">
          <source>Find and log</source>
          <target state="translated">찾기 및 기록</target>
        </trans-unit>
        <trans-unit id="abefc7d3f756033721edc094c12b8b1a458c1d87" translate="yes" xml:space="preserve">
          <source>Find and set</source>
          <target state="translated">찾기 및 설정</target>
        </trans-unit>
        <trans-unit id="f2b5808245c6f3b017b6a3858ac928e283f5d20a" translate="yes" xml:space="preserve">
          <source>Flag to explicitly request a specific type of web application. If not set, auto-detected based on the classpath.</source>
          <target state="translated">특정 유형의 웹 애플리케이션을 명시 적으로 요청하는 플래그입니다. 설정되지 않은 경우 클래스 경로를 기반으로 자동 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="1e565225ad663318ea60debd4f826920030f4477" translate="yes" xml:space="preserve">
          <source>Flagging the dependency as optional in Maven or using the &lt;code&gt;developmentOnly&lt;/code&gt; configuration in Gradle (as shown above) prevents devtools from being transitively applied to other modules that use your project.</source>
          <target state="translated">종속성을 Maven에서 선택 사항으로 표시하거나 Gradle 에서 &lt;code&gt;developmentOnly&lt;/code&gt; 구성을 사용하면 (위에 표시된대로) devtools가 프로젝트를 사용하는 다른 모듈에 전 이적으로 적용되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06d3cded2386df4963a8e89f632a27636fe9d609" translate="yes" xml:space="preserve">
          <source>Flyway supports SQL and Java &lt;a href=&quot;https://flywaydb.org/documentation/concepts/callbacks&quot;&gt;callbacks&lt;/a&gt;. To use SQL-based callbacks, place the callback scripts in the &lt;code&gt;classpath:db/migration&lt;/code&gt; directory. To use Java-based callbacks, create one or more beans that implement &lt;code&gt;Callback&lt;/code&gt;. Any such beans are automatically registered with &lt;code&gt;Flyway&lt;/code&gt;. They can be ordered by using &lt;code&gt;@Order&lt;/code&gt; or by implementing &lt;code&gt;Ordered&lt;/code&gt;. Beans that implement the deprecated &lt;code&gt;FlywayCallback&lt;/code&gt; interface can also be detected, however they cannot be used alongside &lt;code&gt;Callback&lt;/code&gt; beans.</source>
          <target state="translated">Flyway는 SQL 및 Java &lt;a href=&quot;https://flywaydb.org/documentation/concepts/callbacks&quot;&gt;콜백을&lt;/a&gt; 지원합니다 . SQL 기반 콜백을 사용하려면 &lt;code&gt;classpath:db/migration&lt;/code&gt; 디렉토리에 콜백 스크립트를 배치하십시오 . Java 기반 콜백을 사용하려면 &lt;code&gt;Callback&lt;/code&gt; 을 구현하는 하나 이상의 Bean을 작성하십시오 . 그러한 모든 콩은 &lt;code&gt;Flyway&lt;/code&gt; 에 자동으로 등록됩니다 . &lt;code&gt;@Order&lt;/code&gt; 를 사용 하거나 &lt;code&gt;Ordered&lt;/code&gt; 를 구현 하여 주문할 수 있습니다 . 더 이상 사용되지 않는 &lt;code&gt;FlywayCallback&lt;/code&gt; 인터페이스 를 구현하는 Bean 도 감지 할 수 있지만 &lt;code&gt;Callback&lt;/code&gt; Bean 과 함께 사용할 수는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="33f2c717e97624373c806b7dc0f9504e64790341" translate="yes" xml:space="preserve">
          <source>Folder containing the jar</source>
          <target state="translated">항아리가 들어있는 폴더</target>
        </trans-unit>
        <trans-unit id="2a1ab7c6ed1a993f282e20ea7d25374dbc8fa72e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;Map&lt;/code&gt; properties, you can bind with property values drawn from multiple sources. However, for the same property in multiple sources, the one with the highest priority is used. The following example exposes a &lt;code&gt;Map&amp;lt;String, MyPojo&amp;gt;&lt;/code&gt; from &lt;code&gt;AcmeProperties&lt;/code&gt;:</source>
          <target state="translated">를 들어 &lt;code&gt;Map&lt;/code&gt; 속성, 당신은 여러 소스에서 가져온 속성 값에 바인딩 할 수 있습니다. 그러나 여러 소스의 동일한 속성에 대해 우선 순위가 가장 높은 속성이 사용됩니다. 다음 예제는 &lt;code&gt;Map&amp;lt;String, MyPojo&amp;gt;&lt;/code&gt; 에서 Map &amp;lt;String, MyPojo&amp;gt; 를 &lt;code&gt;AcmeProperties&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d8b8160903821929679dceb4dd6745ae04d5b96" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;application.properties&lt;/code&gt; files a special &lt;code&gt;#---&lt;/code&gt; comment is used to mark the document splits:</source>
          <target state="translated">들어 &lt;code&gt;application.properties&lt;/code&gt; 특별한 파일 &lt;code&gt;#---&lt;/code&gt; 주석 문서 분할을 표시하는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="91af6c171016d3c487734251dfba813cb312ed04" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;application.yml&lt;/code&gt; files, the standard YAML multi-document syntax is used. Three consecutive hyphens represent the end of one document, and the start of the next.</source>
          <target state="translated">들어 &lt;code&gt;application.yml&lt;/code&gt; 파일, 표준 YAML 다중 문서 구문이 사용됩니다. 연속 된 세 개의 하이픈은 한 문서의 끝과 다음 문서의 시작을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe9d12746895e099bc44d5333c10618bebab99de" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;boolean&lt;/code&gt; types, start the description with &quot;Whether&quot; or &quot;Enable&quot;.</source>
          <target state="translated">들어 &lt;code&gt;boolean&lt;/code&gt; 유형, &quot;사용&quot; &quot;여부&quot;나에 대한 설명을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="5e68eba6245faa8f9c24eea8fa218edb04fdfc82" translate="yes" xml:space="preserve">
          <source>For Gradle, use the following declaration:</source>
          <target state="translated">Gradle의 경우 다음 선언을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28a5016b2a8bc7245d728b1fd8b31ecba53e31d2" translate="yes" xml:space="preserve">
          <source>For HTTP/2 support, Jetty requires the additional &lt;code&gt;org.eclipse.jetty.http2:http2-server&lt;/code&gt; dependency. Now depending on your deployment, you also need to choose other dependencies:</source>
          <target state="translated">HTTP / 2 지원을 위해 Jetty에는 추가 &lt;code&gt;org.eclipse.jetty.http2:http2-server&lt;/code&gt; 종속성이 필요합니다 . 이제 배포에 따라 다른 종속성도 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="26feff895b88637935004dffc72d392634299168" translate="yes" xml:space="preserve">
          <source>For Jetty, we need to add a connection factory to the existing connector:</source>
          <target state="translated">Jetty의 경우 기존 커넥터에 연결 팩토리를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="67693b72d0e2dc98fe765cbeb95c137bb76e10a9" translate="yes" xml:space="preserve">
          <source>For Maven users, the &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; POM includes a pre-configured plugin to generate a &lt;code&gt;git.properties&lt;/code&gt; file. To use it, add the following declaration to your POM:</source>
          <target state="translated">Maven 사용자의 경우 &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; POM에는 &lt;code&gt;git.properties&lt;/code&gt; 파일 을 생성하기 위해 사전 구성된 플러그인이 포함되어 있습니다. 이를 사용하려면 POM에 다음 선언을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="50735241363bcf689042b085545e48d46b923f81" translate="yes" xml:space="preserve">
          <source>For Maven, refer to the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#repackage-layers&quot;&gt;packaging layered jars section&lt;/a&gt; for more details on adding a layer index to the jar. For Gradle, refer to the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/gradle-plugin/reference/htmlsingle/#packaging-layered-jars&quot;&gt;packaging layered jars section&lt;/a&gt; of the Gradle plugin documentation.</source>
          <target state="translated">Maven의 경우 jar에 레이어 인덱스를 추가하는 방법에 대한 자세한 내용 은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#repackage-layers&quot;&gt;패키징 계층화 된 jar 섹션&lt;/a&gt; 을 참조하세요. Gradle 의 경우 Gradle 플러그인 문서 의 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/gradle-plugin/reference/htmlsingle/#packaging-layered-jars&quot;&gt;패키징 계층화 된 jar 섹션&lt;/a&gt; 을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="df28e87f3101ca06cc0d9067020d983ac1258d80" translate="yes" xml:space="preserve">
          <source>For Netty, we need to add &lt;code&gt;h2c&lt;/code&gt; as a supported protocol:</source>
          <target state="translated">Netty의 경우 지원되는 프로토콜로 &lt;code&gt;h2c&lt;/code&gt; 를 추가해야 합니다.</target>
        </trans-unit>
        <trans-unit id="898ff7c51674c68186591ad2783351c7352d19ef" translate="yes" xml:space="preserve">
          <source>For OpenID Connect providers that support &lt;a href=&quot;https://openid.net/specs/openid-connect-discovery-1_0.html&quot;&gt;OpenID Connect discovery&lt;/a&gt;, the configuration can be further simplified. The provider needs to be configured with an &lt;code&gt;issuer-uri&lt;/code&gt; which is the URI that the it asserts as its Issuer Identifier. For example, if the &lt;code&gt;issuer-uri&lt;/code&gt; provided is &quot;https://example.com&quot;, then an &lt;code&gt;OpenID Provider Configuration Request&lt;/code&gt; will be made to &quot;https://example.com/.well-known/openid-configuration&quot;. The result is expected to be an &lt;code&gt;OpenID Provider Configuration Response&lt;/code&gt;. The following example shows how an OpenID Connect Provider can be configured with the &lt;code&gt;issuer-uri&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://openid.net/specs/openid-connect-discovery-1_0.html&quot;&gt;OpenID Connect 검색&lt;/a&gt; 을 지원하는 OpenID Connect 공급자의 경우 구성을 더욱 단순화 할 수 있습니다. 공급자 는 발급자 식별자로 주장하는 URI 인 &lt;code&gt;issuer-uri&lt;/code&gt; 로 구성되어야합니다 . 예를 들어 제공된 &lt;code&gt;issuer-uri&lt;/code&gt; 가 &quot;https://example.com&quot;인 경우 &lt;code&gt;OpenID Provider Configuration Request&lt;/code&gt; 은 &quot;https://example.com/.well-known/openid-configuration&quot;으로 만들어집니다. 결과는 &lt;code&gt;OpenID Provider Configuration Response&lt;/code&gt; 일 것으로 예상됩니다 . 다음 예는 &lt;code&gt;issuer-uri&lt;/code&gt; 를 사용하여 OpenID Connect 공급자를 구성하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e41f20b67897882a19dedcf7e03e2da66ad3ef90" translate="yes" xml:space="preserve">
          <source>For Tomcat, we need to add an upgrade protocol:</source>
          <target state="translated">Tomcat의 경우 업그레이드 프로토콜을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="725fbec273392cae5ef2607c3b74170c7db974f1" translate="yes" xml:space="preserve">
          <source>For Undertow, we need to enable the HTTP2 option:</source>
          <target state="translated">Undertow의 경우 HTTP2 옵션을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3c258993b0ecaeb3f974ec3bf3f3706e1d34876" translate="yes" xml:space="preserve">
          <source>For WebFlux application (i.e. of type &lt;code&gt;WebApplicationType.REACTIVE&lt;/code&gt;), the RSocket server will be plugged into the Web Server only if the following properties match:</source>
          <target state="translated">WebFlux 응용 프로그램 (예 : &lt;code&gt;WebApplicationType.REACTIVE&lt;/code&gt; 유형 )의 경우 RSocket 서버는 다음 속성이 일치하는 경우에만 Web Server에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="99f3e96de95bdd6fd21b04988490a36e3174fe24" translate="yes" xml:space="preserve">
          <source>For YAML files, the brackets need to be surrounded by quotes for the keys to be parsed properly.</source>
          <target state="translated">YAML 파일의 경우 키를 올바르게 구문 분석하려면 대괄호를 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="27406a223a636b82d8e66c73ea3ad807df7bb954" translate="yes" xml:space="preserve">
          <source>For a &lt;code&gt;@WriteOperation&lt;/code&gt; (HTTP &lt;code&gt;POST&lt;/code&gt;) that uses the request body, the consumes clause of the predicate is &lt;code&gt;application/vnd.spring-boot.actuator.v2+json, application/json&lt;/code&gt;. For all other operations the consumes clause is empty.</source>
          <target state="translated">요청 본문을 사용 하는 &lt;code&gt;@WriteOperation&lt;/code&gt; (HTTP &lt;code&gt;POST&lt;/code&gt; )의 경우 술어의 소비 절은 &lt;code&gt;application/vnd.spring-boot.actuator.v2+json, application/json&lt;/code&gt; 입니다. 다른 모든 작업의 ​​경우 소비 절이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="baaa5c73ba082d25abdc06a63cef6e7ee4241a39" translate="yes" xml:space="preserve">
          <source>For a complete list of the configuration options, see the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/SpringApplication.html&quot;&gt;&lt;code&gt;SpringApplication&lt;/code&gt; Javadoc&lt;/a&gt;.</source>
          <target state="translated">구성 옵션의 전체 목록은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/SpringApplication.html&quot;&gt; &lt;code&gt;SpringApplication&lt;/code&gt; Javadoc을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="54e13f37d3d8a49a1b4c64bd35f0313cdf2cd3a1" translate="yes" xml:space="preserve">
          <source>For a complete list of the properties that are applied by the devtools, see &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java&quot;&gt;DevToolsPropertyDefaultsPostProcessor&lt;/a&gt;.</source>
          <target state="translated">DevTools로에 의해 적용되는 속성의 전체 목록을 보려면 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-devtools/src/main/java/org/springframework/boot/devtools/env/DevToolsPropertyDefaultsPostProcessor.java&quot;&gt;DevToolsPropertyDefaultsPostProcessor을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ad893bd58218fa28e08fd487691cd0beace0ca" translate="yes" xml:space="preserve">
          <source>For a list of additional community contributed starters, see the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/README.adoc&quot;&gt;README file&lt;/a&gt; in the &lt;code&gt;spring-boot-starters&lt;/code&gt; module on GitHub.</source>
          <target state="translated">추가 커뮤니티 기여 스타터 목록은 GitHub 의 &lt;code&gt;spring-boot-starters&lt;/code&gt; 모듈에 있는 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-starters/README.adoc&quot;&gt;README 파일&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7edb20353ed818189f098c316be47e09841c33e" translate="yes" xml:space="preserve">
          <source>For a more complete picture, you can also subclass &lt;code&gt;DefaultErrorWebExceptionHandler&lt;/code&gt; directly and override specific methods.</source>
          <target state="translated">보다 완전한 그림을 위해 &lt;code&gt;DefaultErrorWebExceptionHandler&lt;/code&gt; 를 직접 하위 클래스로 만들고 특정 메서드를 재정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6726c104b33a4c07955d7e98549566954e8772dc" translate="yes" xml:space="preserve">
          <source>For a pooling &lt;code&gt;DataSource&lt;/code&gt; to be created, we need to be able to verify that a valid &lt;code&gt;Driver&lt;/code&gt; class is available, so we check for that before doing anything. In other words, if you set &lt;code&gt;spring.datasource.driver-class-name=com.mysql.jdbc.Driver&lt;/code&gt;, then that class has to be loadable.</source>
          <target state="translated">풀링 &lt;code&gt;DataSource&lt;/code&gt; 를 만들려면 유효한 &lt;code&gt;Driver&lt;/code&gt; 클래스가 사용 가능한지 확인할 수 있어야 하므로 작업을 수행하기 전에 확인해야합니다. 즉, &lt;code&gt;spring.datasource.driver-class-name=com.mysql.jdbc.Driver&lt;/code&gt; 를 설정하면 해당 클래스를로드 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="ba066f4cecbbbf93054258e14ce4bf51ac7732ad" translate="yes" xml:space="preserve">
          <source>For a war file, it would be as follows:</source>
          <target state="translated">war 파일의 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="705c0be561a4c22c4340fa976eab654201b9a6bf" translate="yes" xml:space="preserve">
          <source>For additional &amp;ldquo;production ready&amp;rdquo; features, such as health, auditing, and metric REST or JMX end-points, consider adding &lt;code&gt;spring-boot-actuator&lt;/code&gt;. See &lt;em&gt;&lt;a href=&quot;production-ready-features#production-ready&quot;&gt;production-ready-features.html&lt;/a&gt;&lt;/em&gt; for details.</source>
          <target state="translated">상태, 감사, 메트릭 REST 또는 JMX 엔드 포인트와 같은 추가 &quot;프로덕션 준비&quot;기능의 경우 &lt;code&gt;spring-boot-actuator&lt;/code&gt; 추가를 고려하십시오 . 자세한 내용은 &lt;em&gt;&lt;a href=&quot;production-ready-features#production-ready&quot;&gt;production-ready-features.html&lt;/a&gt;&lt;/em&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bd970f057ffde702429a30aaae37752b5db71431" translate="yes" xml:space="preserve">
          <source>For additional details on Spring Security&amp;rsquo;s testing support, refer to Spring Security&amp;rsquo;s &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.4.1/reference/html5/#test&quot;&gt;reference documentation&lt;/a&gt;).</source>
          <target state="translated">Spring Security의 테스트 지원에 대한 자세한 내용은 Spring Security의 &lt;a href=&quot;https://docs.spring.io/spring-security/site/docs/5.4.1/reference/html5/#test&quot;&gt;참조 문서를 참조&lt;/a&gt; 하십시오 .</target>
        </trans-unit>
        <trans-unit id="de5ee265fb95002df80dd4545731838ecfcdcdad" translate="yes" xml:space="preserve">
          <source>For applications that do not use Spring MVC, you can use the &lt;code&gt;ErrorPageRegistrar&lt;/code&gt; interface to directly register &lt;code&gt;ErrorPages&lt;/code&gt;. This abstraction works directly with the underlying embedded servlet container and works even if you do not have a Spring MVC &lt;code&gt;DispatcherServlet&lt;/code&gt;.</source>
          <target state="translated">스프링 MVC를 사용하지 않는 응용 프로그램의 경우, 사용할 수 있습니다 &lt;code&gt;ErrorPageRegistrar&lt;/code&gt; 의 직접 등록에 인터페이스를 &lt;code&gt;ErrorPages&lt;/code&gt; 을 . 이 추상화는 기본 임베디드 서블릿 컨테이너와 직접 작동하며 Spring MVC &lt;code&gt;DispatcherServlet&lt;/code&gt; 이없는 경우에도 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="8431bd278cfa6444b6e071951ca160e2132060b0" translate="yes" xml:space="preserve">
          <source>For cases where the default value could not be detected, &lt;a href=&quot;#configuration-metadata-additional-metadata&quot;&gt;manual metadata&lt;/a&gt; should be provided. Consider the following example:</source>
          <target state="translated">기본값을 감지 할 수없는 경우 &lt;a href=&quot;#configuration-metadata-additional-metadata&quot;&gt;수동 메타 데이터&lt;/a&gt; 를 제공해야합니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="15d8906ffcd3f80cef1fbfa87a39459acc26985c" translate="yes" xml:space="preserve">
          <source>For collection-based types, start the description with &quot;Comma-separated list&quot;</source>
          <target state="translated">콜렉션 기반 유형의 경우 &quot;쉼표로 구분 된 목록&quot;으로 설명을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="ddd263c83a298ffd0d2c7bcd8a3511d709b2033b" translate="yes" xml:space="preserve">
          <source>For common OAuth2 and OpenID providers, including Google, Github, Facebook, and Okta, we provide a set of provider defaults (&lt;code&gt;google&lt;/code&gt;, &lt;code&gt;github&lt;/code&gt;, &lt;code&gt;facebook&lt;/code&gt;, and &lt;code&gt;okta&lt;/code&gt;, respectively).</source>
          <target state="translated">Google, Github, Facebook 및 Okta를 포함한 일반적인 OAuth2 및 OpenID 공급자의 경우 공급자 기본값 집합 (각각 &lt;code&gt;google&lt;/code&gt; , &lt;code&gt;github&lt;/code&gt; , &lt;code&gt;facebook&lt;/code&gt; 및 &lt;code&gt;okta&lt;/code&gt; )을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="22b5d1f001e46d3358dfef61d3955b9646266ef9" translate="yes" xml:space="preserve">
          <source>For complete details of Spring Data Cassandra, refer to the &lt;a href=&quot;https://docs.spring.io/spring-data/cassandra/docs/&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">SpringData Cassandra에 대한 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-data/cassandra/docs/&quot;&gt;참조 문서를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="0f995a3a3549e40032cf9e9fa4533bbb7537f113" translate="yes" xml:space="preserve">
          <source>For complete details of Spring Data Elasticsearch, refer to the &lt;a href=&quot;https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">SpringData Elasticsearch에 대한 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/&quot;&gt;참조 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="676b470f575e86308bc54acfb5fdfcd552dddae6" translate="yes" xml:space="preserve">
          <source>For complete details of Spring Data JDBC, please refer to the &lt;a href=&quot;https://docs.spring.io/spring-data/jdbc/docs/2.1.1/reference/html/&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">SpringData JDBC에 대한 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-data/jdbc/docs/2.1.1/reference/html/&quot;&gt;참조 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d705ab5e2bfc1f7408479a462293c7980fa033c" translate="yes" xml:space="preserve">
          <source>For complete details of Spring Data MongoDB, including its rich object mapping technologies, refer to its &lt;a href=&quot;https://spring.io/projects/spring-data-mongodb&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">풍부한 객체 매핑 기술을 포함하여 SpringData MongoDB에 대한 자세한 내용은 &lt;a href=&quot;https://spring.io/projects/spring-data-mongodb&quot;&gt;참조 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c5b26c40d59b2482ec25faed7d71f2e0c72dbc0" translate="yes" xml:space="preserve">
          <source>For ephemeral or batch jobs which may not exist long enough to be scraped, &lt;a href=&quot;https://github.com/prometheus/pushgateway&quot;&gt;Prometheus Pushgateway&lt;/a&gt; support can be used to expose their metrics to Prometheus. To enable Prometheus Pushgateway support, add the following dependency to your project:</source>
          <target state="translated">스크랩 할만큼 오래 존재하지 않을 수있는 임시 또는 일괄 작업의 경우 &lt;a href=&quot;https://github.com/prometheus/pushgateway&quot;&gt;Prometheus Pushgateway&lt;/a&gt; 지원을 사용하여 해당 메트릭을 Prometheus에 노출 할 수 있습니다. Prometheus Pushgateway 지원을 사용하려면 프로젝트에 다음 종속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3753beadf672ad7f32026a4d54194b251dbca987" translate="yes" xml:space="preserve">
          <source>For example, Spring Boot&amp;rsquo;s error handling is based on the &amp;ldquo;error page&amp;rdquo; support provided by the Servlet container. This means that, whilst you can test your MVC layer throws and handles exceptions as expected, you cannot directly test that a specific &lt;a href=&quot;#boot-features-error-handling-custom-error-pages&quot;&gt;custom error page&lt;/a&gt; is rendered. If you need to test these lower-level concerns, you can start a fully running server as described in the next section.</source>
          <target state="translated">예를 들어 Spring Boot의 오류 처리는 Servlet 컨테이너에서 제공하는 &quot;오류 페이지&quot;지원을 기반으로합니다. 즉, MVC 레이어가 예상대로 예외를 throw하고 처리하는 것을 테스트 할 수 있지만 특정 &lt;a href=&quot;#boot-features-error-handling-custom-error-pages&quot;&gt;사용자 지정 오류 페이지&lt;/a&gt; 가 렌더링되었는지 직접 테스트 할 수는 없습니다 . 이러한 하위 수준 문제를 테스트해야하는 경우 다음 섹션에 설명 된대로 완전히 실행중인 서버를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2419584bcbdb54cd3cff655e7bef1e6a056b6919" translate="yes" xml:space="preserve">
          <source>For example, a &lt;code&gt;spring.config.import&lt;/code&gt; value of &lt;code&gt;optional:file:./myconfig.properties&lt;/code&gt; allows your application to start, even if the &lt;code&gt;myconfig.properties&lt;/code&gt; file is missing.</source>
          <target state="translated">예를 들어, &lt;code&gt;optional:file:./myconfig.properties&lt;/code&gt; 의 &lt;code&gt;spring.config.import&lt;/code&gt; 값을 사용하면 &lt;code&gt;myconfig.properties&lt;/code&gt; 파일이 누락 된 경우에도 애플리케이션을 시작할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d59bba110003701e8f2564a49efe6cc1e2a6fdbc" translate="yes" xml:space="preserve">
          <source>For example, assume a &lt;code&gt;MyPojo&lt;/code&gt; object with &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt; attributes that are &lt;code&gt;null&lt;/code&gt; by default. The following example exposes a list of &lt;code&gt;MyPojo&lt;/code&gt; objects from &lt;code&gt;AcmeProperties&lt;/code&gt;:</source>
          <target state="translated">예를 들어, &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;description&lt;/code&gt; 속성이 기본적으로 &lt;code&gt;null&lt;/code&gt; &lt;code&gt;MyPojo&lt;/code&gt; 오브젝트를 가정하십시오 . 다음 예제는 &lt;code&gt;MyPojo&lt;/code&gt; 에서 &lt;code&gt;AcmeProperties&lt;/code&gt; 객체 목록을 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="cb17326f974839cd76e0be85d8cb2615798bc9db" translate="yes" xml:space="preserve">
          <source>For example, assume a new &lt;code&gt;Status&lt;/code&gt; with code &lt;code&gt;FATAL&lt;/code&gt; is being used in one of your &lt;code&gt;HealthIndicator&lt;/code&gt; implementations. To configure the severity order, add the following property to your application properties:</source>
          <target state="translated">예를 들어, 코드가 &lt;code&gt;FATAL&lt;/code&gt; 인 새 &lt;code&gt;Status&lt;/code&gt; 가 &lt;code&gt;HealthIndicator&lt;/code&gt; 구현 중 하나에서 사용되고 있다고 가정 하십시오 . 심각도 순서를 구성하려면 애플리케이션 속성에 다음 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="cd4e6339bf21346e5fec1784067f70b161b27a73" translate="yes" xml:space="preserve">
          <source>For example, consider the following declaration:</source>
          <target state="translated">예를 들어 다음 선언을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cbeb4c594fbd34be24b798af8b817db6a146083f" translate="yes" xml:space="preserve">
          <source>For example, given the following jar:</source>
          <target state="translated">예를 들어 다음과 같은 항아리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="53f0d0a7aeea44bfe275d4f959bda144b22374c7" translate="yes" xml:space="preserve">
          <source>For example, given the following volume:</source>
          <target state="translated">예를 들어 다음과 같은 볼륨이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c353e8a2064db8293ef6e5d9e5973939c8db350f" translate="yes" xml:space="preserve">
          <source>For example, if you are using Eclipse or STS and you have a project named &lt;code&gt;my-app&lt;/code&gt; that you have deployed to Cloud Foundry, you would do the following:</source>
          <target state="translated">예를 들어 Eclipse 또는 STS를 사용 중이고 Cloud Foundry에 배포 한 &lt;code&gt;my-app&lt;/code&gt; 이라는 프로젝트 가있는 경우 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d8960d0d9c60aeee972296c4012cdc158d71b9bc" translate="yes" xml:space="preserve">
          <source>For example, if you have a project with the following structure:</source>
          <target state="translated">예를 들어 다음과 같은 구조의 프로젝트가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="6918e937a38739e52f74f6d3f1b0ecb0e1ed0127" translate="yes" xml:space="preserve">
          <source>For example, if you have some Redis configuration and some MySQL configuration, you might want to keep those two pieces of configuration separate, while requiring that both those are present in an &lt;code&gt;application.properties&lt;/code&gt; file. This might result in two separate &lt;code&gt;application.properties&lt;/code&gt; files mounted at different locations such as &lt;code&gt;/config/redis/application.properties&lt;/code&gt; and &lt;code&gt;/config/mysql/application.properties&lt;/code&gt;. In such a case, having a wildcard location of &lt;code&gt;config/*/&lt;/code&gt;, will result in both files being processed.</source>
          <target state="translated">예를 들어 일부 Redis 구성과 일부 MySQL 구성이있는 경우 두 구성을 별도로 유지하면서 둘 다 &lt;code&gt;application.properties&lt;/code&gt; 파일 에 있어야 합니다. 이로 인해 &lt;code&gt;/config/redis/application.properties&lt;/code&gt; 및 &lt;code&gt;/config/mysql/application.properties&lt;/code&gt; 와 같은 서로 다른 위치 에 두 개의 별도 &lt;code&gt;application.properties&lt;/code&gt; 파일이 마운트 될 수 있습니다 . 이 경우 와일드 카드 위치가 &lt;code&gt;config/*/&lt;/code&gt; 이면 두 파일이 모두 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="6209ed3b0e8ca824f6bc2bcf1626884952b4fe7f" translate="yes" xml:space="preserve">
          <source>For example, if you want to configure Hibernate&amp;rsquo;s batch size you must use &lt;code&gt;spring.jpa.properties.hibernate.jdbc.batch_size&lt;/code&gt;. If you use other forms, such as &lt;code&gt;batchSize&lt;/code&gt; or &lt;code&gt;batch-size&lt;/code&gt;, Hibernate will not apply the setting.</source>
          <target state="translated">예를 들어 Hibernate의 배치 크기를 구성하려면 &lt;code&gt;spring.jpa.properties.hibernate.jdbc.batch_size&lt;/code&gt; 를 사용해야합니다 . &lt;code&gt;batchSize&lt;/code&gt; 또는 &lt;code&gt;batch-size&lt;/code&gt; 와 같은 다른 형식을 사용하는 경우 Hibernate는 설정을 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0214343dc9cf760ea1f4abfa4a8879142ca2f241" translate="yes" xml:space="preserve">
          <source>For example, if you want to rename the &lt;code&gt;mytag.region&lt;/code&gt; tag to &lt;code&gt;mytag.area&lt;/code&gt; for all meter IDs beginning with &lt;code&gt;com.example&lt;/code&gt;, you can do the following:</source>
          <target state="translated">당신이 이름을 변경하려는 경우 예를 들어, &lt;code&gt;mytag.region&lt;/code&gt; 의 에 태그를 &lt;code&gt;mytag.area&lt;/code&gt; 로 시작하는 모든 m ID에 대한 &lt;code&gt;com.example&lt;/code&gt; , 다음을 수행 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="41f3117b419820d765814a48c746d04214d964d8" translate="yes" xml:space="preserve">
          <source>For example, suppose you have a &lt;code&gt;/etc/config/myconfig&lt;/code&gt; file that you wish to import as yaml. You can import it from your &lt;code&gt;application.properties&lt;/code&gt; using the following:</source>
          <target state="translated">예를 들어 yaml로 가져 오려는 &lt;code&gt;/etc/config/myconfig&lt;/code&gt; 파일이 있다고 가정합니다 . 다음을 사용 하여 &lt;code&gt;application.properties&lt;/code&gt; 에서 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b061bb4bbf379e879b760f06d989228f35ff682" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;SPRING_APPLICATION_JSON&lt;/code&gt; property can be supplied on the command line in a UN*X shell as an environment variable:</source>
          <target state="translated">예를 들어 &lt;code&gt;SPRING_APPLICATION_JSON&lt;/code&gt; 속성은 UN * X 셸의 명령 줄에 환경 변수로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="255f24c32df4be89322c986cf5e1a308438230c3" translate="yes" xml:space="preserve">
          <source>For example, the configuration property &lt;code&gt;my.acme[0].other&lt;/code&gt; would use an environment variable named &lt;code&gt;MY_ACME_0_OTHER&lt;/code&gt;.</source>
          <target state="translated">예를 들어 구성 속성 &lt;code&gt;my.acme[0].other&lt;/code&gt; 는 &lt;code&gt;MY_ACME_0_OTHER&lt;/code&gt; 라는 환경 변수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="049acefb07a29709b2670235937e9d23f6367fb8" translate="yes" xml:space="preserve">
          <source>For example, the configuration property &lt;code&gt;spring.main.log-startup-info&lt;/code&gt; would be an environment variable named &lt;code&gt;SPRING_MAIN_LOGSTARTUPINFO&lt;/code&gt;.</source>
          <target state="translated">예를 들어 구성 속성 &lt;code&gt;spring.main.log-startup-info&lt;/code&gt; 는 &lt;code&gt;SPRING_MAIN_LOGSTARTUPINFO&lt;/code&gt; 라는 환경 변수가 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4723608bd432841f2374ce6ea2856d14f703ad8b" translate="yes" xml:space="preserve">
          <source>For example, the following file has two logical documents:</source>
          <target state="translated">예를 들어 다음 파일에는 두 개의 논리 문서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff21d4389165155e8e78ed292e27be718406fb5" translate="yes" xml:space="preserve">
          <source>For example, the following file will set &lt;code&gt;app.description&lt;/code&gt; to &amp;ldquo;MyApp is a Spring Boot application&amp;rdquo;:</source>
          <target state="translated">예를 들어 다음 파일은 &lt;code&gt;app.description&lt;/code&gt; 을&amp;ldquo;MyApp은 Spring Boot 애플리케이션입니다&amp;rdquo;로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1bc8cc6d9edc99317d904b7bfd3369ad8e4706d6" translate="yes" xml:space="preserve">
          <source>For example, the following specifies that the second document is only active when running on Kubernetes, and only when either the &amp;ldquo;prod&amp;rdquo; or &amp;ldquo;staging&amp;rdquo; profiles are active:</source>
          <target state="translated">예를 들어 다음은 두 번째 문서가 Kubernetes에서 실행될 때만 활성화되고 &quot;prod&quot;또는 &quot;staging&quot;프로필이 활성화 된 경우에만 활성화되도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="39d0cf0cb4a60d21f4413f615f650ec1c40e1256" translate="yes" xml:space="preserve">
          <source>For example, the typical POM dependencies would be as follows:</source>
          <target state="translated">예를 들어, 일반적인 POM 종속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b321e5319c5c83c27d7de239d760e5ebeb14785" translate="yes" xml:space="preserve">
          <source>For example, to enable pretty print, set &lt;code&gt;spring.jackson.serialization.indent_output=true&lt;/code&gt;. Note that, thanks to the use of &lt;a href=&quot;spring-boot-features#boot-features-external-config-relaxed-binding&quot;&gt;relaxed binding&lt;/a&gt;, the case of &lt;code&gt;indent_output&lt;/code&gt; does not have to match the case of the corresponding enum constant, which is &lt;code&gt;INDENT_OUTPUT&lt;/code&gt;.</source>
          <target state="translated">예를 들어 예쁜 인쇄를 사용하려면 &lt;code&gt;spring.jackson.serialization.indent_output=true&lt;/code&gt; 를 설정하십시오 . &lt;a href=&quot;spring-boot-features#boot-features-external-config-relaxed-binding&quot;&gt;완화 된 바인딩&lt;/a&gt; 의 사용 덕분 에 &lt;code&gt;indent_output&lt;/code&gt; 의 경우는 해당 열거 형 상수 인 &lt;code&gt;INDENT_OUTPUT&lt;/code&gt; 의 경우와 일치 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9e395f42f8054812efa66687218258ba9779a493" translate="yes" xml:space="preserve">
          <source>For example, to indicate that JRuby should be flagged for unpacking by using the Maven Plugin, you would add the following configuration:</source>
          <target state="translated">예를 들어 Maven 플러그인을 사용하여 JRuby에 압축 해제 플래그를 지정해야 함을 나타내려면 다음 구성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f937393f3f25b26826a27f96bff60d569b704f4b" translate="yes" xml:space="preserve">
          <source>For example, to map &lt;code&gt;404&lt;/code&gt; to a static HTML file, your directory structure would be as follows:</source>
          <target state="translated">예를 들어 &lt;code&gt;404&lt;/code&gt; 를 정적 HTML 파일 에 매핑 하려면 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e77c7f26bb729738731a2c263aefa855048e7c6" translate="yes" xml:space="preserve">
          <source>For example, to stop exposing all endpoints over JMX and only expose the &lt;code&gt;health&lt;/code&gt; and &lt;code&gt;info&lt;/code&gt; endpoints, use the following property:</source>
          <target state="translated">예를 들어 JMX를 통한 모든 엔드 포인트 노출을 중지하고 &lt;code&gt;health&lt;/code&gt; 및 &lt;code&gt;info&lt;/code&gt; 엔드 포인트 만 노출 하려면 다음 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53f34d66c8826ec8a1ebd6eb083c3c77bbe0a1bc" translate="yes" xml:space="preserve">
          <source>For example, we can create a &lt;code&gt;production&lt;/code&gt; group that consists of our &lt;code&gt;proddb&lt;/code&gt; and &lt;code&gt;prodmq&lt;/code&gt; profiles.</source>
          <target state="translated">예를 들어 &lt;code&gt;proddb&lt;/code&gt; 및 &lt;code&gt;prodmq&lt;/code&gt; 프로필 로 구성된 &lt;code&gt;production&lt;/code&gt; 그룹을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f55d56f48341207cb92fc892dfa59c6526f035b5" translate="yes" xml:space="preserve">
          <source>For example, we can export the &quot;Readiness&quot; state of the application to a file so that a Kubernetes &quot;exec Probe&quot; can look at this file:</source>
          <target state="translated">예를 들어 Kubernetes &quot;exec Probe&quot;가이 파일을 볼 수 있도록 애플리케이션의 &quot;준비&quot;상태를 파일로 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="828a820dddcc27c8c18aa6d9356a90c1042ddb13" translate="yes" xml:space="preserve">
          <source>For example, you can customize your security configuration by adding something like:</source>
          <target state="translated">예를 들어 다음과 같은 항목을 추가하여 보안 구성을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eac71425db4abb8b0fffc08c01d26915150a69b" translate="yes" xml:space="preserve">
          <source>For example, you might have the following in your classpath &lt;code&gt;application.properties&lt;/code&gt; file:</source>
          <target state="translated">예를 들어, 클래스 경로 &lt;code&gt;application.properties&lt;/code&gt; 파일에 다음이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="718a2ab8fa709c48af45a8769f7b7a0ea68f40e5" translate="yes" xml:space="preserve">
          <source>For instance, if you are running your application by using &lt;code&gt;java -jar&lt;/code&gt;, you can enable the &lt;code&gt;debug&lt;/code&gt; property as follows:</source>
          <target state="translated">예를 들어 &lt;code&gt;java -jar&lt;/code&gt; 을 사용하여 애플리케이션을 실행하는 경우 다음과 같이 &lt;code&gt;debug&lt;/code&gt; 속성을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="874acdd05c15f14ac41f1c0f771bd3cb2244ac37" translate="yes" xml:space="preserve">
          <source>For instance, if you use the &lt;a href=&quot;https://tomcat.apache.org/tomcat-9.0-doc/jdbc-pool.html#Common_Attributes&quot;&gt;Tomcat connection pool&lt;/a&gt;, you could customize many additional settings, as shown in the following example:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://tomcat.apache.org/tomcat-9.0-doc/jdbc-pool.html#Common_Attributes&quot;&gt;Tomcat 연결 풀&lt;/a&gt; 을 사용하는 경우 다음 예와 같이 많은 추가 설정을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8845a9f7d2b706661a1e88004cde24cfa5fdc16" translate="yes" xml:space="preserve">
          <source>For instance, the following configuration class exposes another factory that uses a specific &lt;code&gt;MessageConverter&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 구성 클래스는 특정 &lt;code&gt;MessageConverter&lt;/code&gt; 를 사용하는 다른 팩토리를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="893198947b0f3d080b8a4297fe3a536ab4921afd" translate="yes" xml:space="preserve">
          <source>For instance, the following configuration creates &lt;code&gt;cache1&lt;/code&gt; and &lt;code&gt;cache2&lt;/code&gt; caches with a maximum size of 500 and a &lt;em&gt;time to live&lt;/em&gt; of 10 minutes</source>
          <target state="translated">예를 들어 다음 구성은 최대 크기가 500이고 &lt;em&gt;TTL&lt;/em&gt; 이 10 분인 &lt;code&gt;cache1&lt;/code&gt; 및 &lt;code&gt;cache2&lt;/code&gt; 캐시를 만듭니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4f13c54618149c75b3dc4fe944aa0a0cbd9c8d19" translate="yes" xml:space="preserve">
          <source>For instance, the following example exposes another factory that uses a specific &lt;code&gt;MessageConverter&lt;/code&gt;:</source>
          <target state="translated">예를 들어 다음 예제에서는 특정 &lt;code&gt;MessageConverter&lt;/code&gt; 를 사용하는 다른 팩토리를 노출합니다 .</target>
        </trans-unit>
        <trans-unit id="760085be05763e027c5a6ab430a066df9d50aba8" translate="yes" xml:space="preserve">
          <source>For instance, the following service triggers the validation of the first argument, making sure its size is between 8 and 10:</source>
          <target state="translated">예를 들어 다음 서비스는 첫 번째 인수의 유효성 검사를 트리거하여 크기가 8에서 10 사이인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="338a10e803c52abbf50c16b5ca4765dcc9e2a1ac" translate="yes" xml:space="preserve">
          <source>For instance, the following settings log access on Tomcat with a &lt;a href=&quot;https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging&quot;&gt;custom pattern&lt;/a&gt;.</source>
          <target state="translated">예를 들어 다음 설정은 &lt;a href=&quot;https://tomcat.apache.org/tomcat-9.0-doc/config/valve.html#Access_Logging&quot;&gt;사용자 지정 패턴&lt;/a&gt; 으로 Tomcat에 대한 액세스를 기록합니다 .</target>
        </trans-unit>
        <trans-unit id="b4cf22deab45da8a11b6287010bc3dff525e5f46" translate="yes" xml:space="preserve">
          <source>For items of the script that need to be customized &lt;em&gt;after&lt;/em&gt; the jar has been written, you can use environment variables or a &lt;a href=&quot;#deployment-script-customization-conf-file&quot;&gt;config file&lt;/a&gt;.</source>
          <target state="translated">jar를 작성한 &lt;em&gt;후&lt;/em&gt; 사용자 정의해야하는 스크립트 항목의 경우 환경 변수 또는 &lt;a href=&quot;#deployment-script-customization-conf-file&quot;&gt;구성 파일을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="536f5873ce2cc8ae405c455e0568e1f61f3b6af8" translate="yes" xml:space="preserve">
          <source>For many applications, all you need is to put the right Spring Data dependencies on your classpath. There is a &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt; for JPA, &lt;code&gt;spring-boot-starter-data-mongodb&lt;/code&gt; for Mongodb, etc. To get started, create some repository interfaces to handle your &lt;code&gt;@Entity&lt;/code&gt; objects.</source>
          <target state="translated">많은 애플리케이션에서 필요한 것은 클래스 경로에 올바른 SpringData 종속성을 배치하는 것입니다. 이 &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt; JPA에 대한이, &lt;code&gt;spring-boot-starter-data-mongodb&lt;/code&gt; 등 MongoDB를위한이 시작하려면, 당신 처리 할 수있는 몇 가지 저장소 인터페이스를 만들 &lt;code&gt;@Entity&lt;/code&gt; 의 객체.</target>
        </trans-unit>
        <trans-unit id="1c7094aed0934b46047c4ac985f9e49106f7d233" translate="yes" xml:space="preserve">
          <source>For more about Spring Data, see the &lt;a href=&quot;https://spring.io/projects/spring-data&quot;&gt;Spring Data project page&lt;/a&gt;.</source>
          <target state="translated">SpringData에 대한 자세한 내용은 SpringData &lt;a href=&quot;https://spring.io/projects/spring-data&quot;&gt;프로젝트 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e5a5b56790f1180783039878890831f233afc067" translate="yes" xml:space="preserve">
          <source>For more about Spring Security, see the &lt;a href=&quot;https://spring.io/projects/spring-security&quot;&gt;Spring Security project page&lt;/a&gt;.</source>
          <target state="translated">Spring Security에 대한 자세한 내용은 &lt;a href=&quot;https://spring.io/projects/spring-security&quot;&gt;Spring Security 프로젝트 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f129b93d515df027fda1cdfd0490789dba881eda" translate="yes" xml:space="preserve">
          <source>For more advanced customizations, you can also register an arbitrary number of beans that implement &lt;code&gt;ResourceConfigCustomizer&lt;/code&gt;.</source>
          <target state="translated">고급 사용자 정의를 위해 &lt;code&gt;ResourceConfigCustomizer&lt;/code&gt; 를 구현하는 임의의 수의 Bean을 등록 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e421ce0c69f1ef09b4c9083b29cf51fb674b0c57" translate="yes" xml:space="preserve">
          <source>For more complex mappings, you can also add beans that implement the &lt;code&gt;ErrorViewResolver&lt;/code&gt; interface, as shown in the following example:</source>
          <target state="translated">더 복잡한 매핑의 경우 다음 예제와 같이 &lt;code&gt;ErrorViewResolver&lt;/code&gt; 인터페이스 를 구현하는 Bean을 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e881dfb6398e031bfc63231464109b34d407c8d" translate="yes" xml:space="preserve">
          <source>For more complex queries, you can annotate your method with Spring Data&amp;rsquo;s &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/2.4.1/api/org/springframework/data/jpa/repository/Query.html&quot;&gt;&lt;code&gt;Query&lt;/code&gt;&lt;/a&gt; annotation.</source>
          <target state="translated">더 복잡한 쿼리의 경우 SpringData의 &lt;a href=&quot;https://docs.spring.io/spring-data/jpa/docs/2.4.1/api/org/springframework/data/jpa/repository/Query.html&quot;&gt; &lt;code&gt;Query&lt;/code&gt; &lt;/a&gt; 주석으로 메서드에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9aedd4fbd5855d63db3a51a99bf41bf7eb0a635" translate="yes" xml:space="preserve">
          <source>For more complex queries, you can annotate your method with Spring Data&amp;rsquo;s &lt;a href=&quot;https://docs.spring.io/spring-data/r2dbc/docs/1.2.1/api/org/springframework/data/r2dbc/repository/Query.html&quot;&gt;&lt;code&gt;Query&lt;/code&gt;&lt;/a&gt; annotation.</source>
          <target state="translated">더 복잡한 쿼리의 경우 SpringData의 &lt;a href=&quot;https://docs.spring.io/spring-data/r2dbc/docs/1.2.1/api/org/springframework/data/r2dbc/repository/Query.html&quot;&gt; &lt;code&gt;Query&lt;/code&gt; &lt;/a&gt; 주석으로 메서드에 주석을 달 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a750b48c1f1efb6d0bf5643b733f8a313b32adc2" translate="yes" xml:space="preserve">
          <source>For more detail, see the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/server/ManagementServerProperties.java&quot;&gt;&lt;code&gt;ManagementServerProperties&lt;/code&gt;&lt;/a&gt; source code and &amp;ldquo;&lt;a href=&quot;production-ready-features#production-ready-customizing-management-server-port&quot;&gt;production-ready-features.html&lt;/a&gt;&amp;rdquo; in the &amp;ldquo;Production-ready features&amp;rdquo; section.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/web/server/ManagementServerProperties.java&quot;&gt; &lt;code&gt;ManagementServerProperties&lt;/code&gt; &lt;/a&gt; 소스 코드 및 &quot; &lt;a href=&quot;production-ready-features#production-ready-customizing-management-server-port&quot;&gt;프로덕션&lt;/a&gt; 준비 기능&quot;섹션의 &quot;프로덕션 준비 기능&quot;섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b42daa450e31d23fb775869cb74d8e3ab700a760" translate="yes" xml:space="preserve">
          <source>For more detail, see the following sections:</source>
          <target state="translated">자세한 내용은 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6355a8c38d646ffeb10637f8de4153ba8e9a9ff" translate="yes" xml:space="preserve">
          <source>For more details on concepts behind &lt;code&gt;percentiles-histogram&lt;/code&gt;, &lt;code&gt;percentiles&lt;/code&gt; and &lt;code&gt;sla&lt;/code&gt; refer to the &lt;a href=&quot;https://micrometer.io/docs/concepts#_histograms_and_percentiles&quot;&gt;&quot;Histograms and percentiles&quot; section&lt;/a&gt; of the micrometer documentation.</source>
          <target state="translated">&lt;code&gt;percentiles-histogram&lt;/code&gt; , &lt;code&gt;percentiles&lt;/code&gt; 및 &lt;code&gt;sla&lt;/code&gt; 의 개념에 대한 자세한 내용 은 마이크로 미터 문서 의 &lt;a href=&quot;https://micrometer.io/docs/concepts#_histograms_and_percentiles&quot;&gt;&quot;히스토그램 및 백분위 수&quot;섹션&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc7270d04124c8e29ec6c9219339dee0d3f077a2" translate="yes" xml:space="preserve">
          <source>For more details on why you should consider this new implementation, please check out the &lt;a href=&quot;https://spring.io/blog/2020/06/30/url-matching-with-pathpattern-in-spring-mvc&quot;&gt;dedicated blog post&lt;/a&gt;.</source>
          <target state="translated">이 새로운 구현을 고려해야하는 이유에 대한 자세한 내용은 &lt;a href=&quot;https://spring.io/blog/2020/06/30/url-matching-with-pathpattern-in-spring-mvc&quot;&gt;전용 블로그 게시물을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b8651379adbcbea28f09827cf2c26cf20a20292" translate="yes" xml:space="preserve">
          <source>For more details, see &amp;ldquo;&lt;a href=&quot;spring-boot-features#boot-features-customizing-embedded-containers&quot;&gt;spring-boot-features.html&lt;/a&gt;&amp;rdquo; in the &amp;lsquo;Spring Boot Features&amp;rsquo; section, or the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java&quot;&gt;&lt;code&gt;ServerProperties&lt;/code&gt;&lt;/a&gt; source code.</source>
          <target state="translated">자세한 내용 은 'Spring Boot Features'섹션의 &amp;ldquo; &lt;a href=&quot;spring-boot-features#boot-features-customizing-embedded-containers&quot;&gt;spring-boot-features.html&lt;/a&gt; &amp;rdquo;또는 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java&quot;&gt; &lt;code&gt;ServerProperties&lt;/code&gt; &lt;/a&gt; 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a59c6f88d0f01240e3d1e9f16f69d6b609e4fad" translate="yes" xml:space="preserve">
          <source>For more details, see the &lt;a href=&quot;using-spring-boot#using-boot-devtools&quot;&gt;using-spring-boot.html&lt;/a&gt; section.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;using-spring-boot#using-boot-devtools&quot;&gt;using-spring-boot.html&lt;/a&gt; 섹션을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="8fee71c4c3a323089190cc345673fbf61d0bd00a" translate="yes" xml:space="preserve">
          <source>For more info about Spring Batch, see the &lt;a href=&quot;https://spring.io/projects/spring-batch&quot;&gt;Spring Batch project page&lt;/a&gt;.</source>
          <target state="translated">Spring Batch에 대한 자세한 정보는 &lt;a href=&quot;https://spring.io/projects/spring-batch&quot;&gt;Spring Batch 프로젝트 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="934b8562d5dbc5040771b271a8fde18e59b58a12" translate="yes" xml:space="preserve">
          <source>For reactive applications, such as those using Spring WebFlux, &lt;code&gt;ReactiveHealthContributor&lt;/code&gt; provides a non-blocking contract for getting application health. Similar to a traditional &lt;code&gt;HealthContributor&lt;/code&gt;, health information is collected from the content of a &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributorRegistry.java&quot;&gt;&lt;code&gt;ReactiveHealthContributorRegistry&lt;/code&gt;&lt;/a&gt; (by default all &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java&quot;&gt;&lt;code&gt;HealthContributor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.java&quot;&gt;&lt;code&gt;ReactiveHealthContributor&lt;/code&gt;&lt;/a&gt; instances defined in your &lt;code&gt;ApplicationContext&lt;/code&gt;). Regular &lt;code&gt;HealthContributors&lt;/code&gt; that do not check against a reactive API are executed on the elastic scheduler.</source>
          <target state="translated">Spring WebFlux를 사용하는 것과 같은 반응 형 애플리케이션의 경우 &lt;code&gt;ReactiveHealthContributor&lt;/code&gt; 는 애플리케이션 상태를 얻기위한 비 차단 계약을 제공합니다. 기존 &lt;code&gt;HealthContributor&lt;/code&gt; 와 유사하게 , 건강 정보는 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributorRegistry.java&quot;&gt; &lt;code&gt;ReactiveHealthContributorRegistry&lt;/code&gt; &lt;/a&gt; 의 콘텐츠에서 수집됩니다 (기본적으로 &lt;code&gt;ApplicationContext&lt;/code&gt; 에 정의 된 모든 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java&quot;&gt; &lt;code&gt;HealthContributor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.java&quot;&gt; &lt;code&gt;ReactiveHealthContributor&lt;/code&gt; &lt;/a&gt; 인스턴스 ). 반응 형 API를 확인하지 않는 일반 &lt;code&gt;HealthContributors&lt;/code&gt; 는 탄력적 스케줄러에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="834506ffcf5c1b11c41a2168aaf5d6bbe5695437" translate="yes" xml:space="preserve">
          <source>For reactive stack applications, the &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; includes Reactor Netty by including &lt;code&gt;spring-boot-starter-reactor-netty&lt;/code&gt;, but you can use &lt;code&gt;spring-boot-starter-tomcat&lt;/code&gt;, &lt;code&gt;spring-boot-starter-jetty&lt;/code&gt;, or &lt;code&gt;spring-boot-starter-undertow&lt;/code&gt; instead.</source>
          <target state="translated">반응 스택 애플리케이션의 경우 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 는 &lt;code&gt;spring-boot-starter-reactor-netty&lt;/code&gt; 를 포함하여 Reactor Netty를 포함 하지만 &lt;code&gt;spring-boot-starter-tomcat&lt;/code&gt; , &lt;code&gt;spring-boot-starter-jetty&lt;/code&gt; 또는 &lt;code&gt;spring-boot-starter-undertow&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="4512f4c9e4d261638ac4ded7e80f46bf6a3df3ce" translate="yes" xml:space="preserve">
          <source>For security purposes, all actuators other than &lt;code&gt;/health&lt;/code&gt; and &lt;code&gt;/info&lt;/code&gt; are disabled by default. The &lt;code&gt;management.endpoints.web.exposure.include&lt;/code&gt; property can be used to enable the actuators.</source>
          <target state="translated">보안상의 이유로 &lt;code&gt;/health&lt;/code&gt; 및 &lt;code&gt;/info&lt;/code&gt; 를 제외한 모든 액추에이터 는 기본적으로 비활성화됩니다. &lt;code&gt;management.endpoints.web.exposure.include&lt;/code&gt; 속성은 액츄에이터를 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29bdf3b4a6e3aad5c177c25d3d9db96d63a6dfc0" translate="yes" xml:space="preserve">
          <source>For servlet stack applications, the &lt;code&gt;spring-boot-starter-web&lt;/code&gt; includes Tomcat by including &lt;code&gt;spring-boot-starter-tomcat&lt;/code&gt;, but you can use &lt;code&gt;spring-boot-starter-jetty&lt;/code&gt; or &lt;code&gt;spring-boot-starter-undertow&lt;/code&gt; instead.</source>
          <target state="translated">서블릿 스택 애플리케이션의 경우 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 은 &lt;code&gt;spring-boot-starter-tomcat&lt;/code&gt; 을 포함하여 Tomcat을 포함 하지만 대신 &lt;code&gt;spring-boot-starter-jetty&lt;/code&gt; 또는 &lt;code&gt;spring-boot-starter-undertow&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="686e8a768fe810a0720f38e8bde03454d36f32f8" translate="yes" xml:space="preserve">
          <source>For setting the timeout of the session you can use the &lt;code&gt;spring.session.timeout&lt;/code&gt; property. If that property is not set with a Servlet web appplication, the auto-configuration falls back to the value of &lt;code&gt;server.servlet.session.timeout&lt;/code&gt;.</source>
          <target state="translated">세션의 시간 제한을 설정하려면 &lt;code&gt;spring.session.timeout&lt;/code&gt; 속성을 사용할 수 있습니다 . 해당 속성이 Servlet 웹 응용 프로그램으로 설정되지 않은 경우 자동 구성은 &lt;code&gt;server.servlet.session.timeout&lt;/code&gt; 값으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="f32415e7c93522c0daeb046ad752b27a1b447829" translate="yes" xml:space="preserve">
          <source>For testing purposes, Spring Boot supports auto-configuration of an in-memory LDAP server from &lt;a href=&quot;https://ldap.com/unboundid-ldap-sdk-for-java/&quot;&gt;UnboundID&lt;/a&gt;. To configure the server, add a dependency to &lt;code&gt;com.unboundid:unboundid-ldapsdk&lt;/code&gt; and declare a &lt;code&gt;spring.ldap.embedded.base-dn&lt;/code&gt; property, as follows:</source>
          <target state="translated">테스트 목적으로 Spring Boot는 &lt;a href=&quot;https://ldap.com/unboundid-ldap-sdk-for-java/&quot;&gt;UnboundID&lt;/a&gt; 에서 메모리 내 LDAP 서버의 자동 구성을 지원합니다 . 서버를 구성하려면 &lt;code&gt;com.unboundid:unboundid-ldapsdk&lt;/code&gt; 에 종속성을 추가하고 다음과 같이 &lt;code&gt;spring.ldap.embedded.base-dn&lt;/code&gt; 속성을 선언 합니다.</target>
        </trans-unit>
        <trans-unit id="0413b2a8e5d17f6e444b60cb8bcdf80c0c6a7bd9" translate="yes" xml:space="preserve">
          <source>For the first case, you can import the YAML or Properties file directly using &lt;code&gt;spring.config.import&lt;/code&gt; as described &lt;a href=&quot;#boot-features-external-config-files-importing&quot;&gt;above&lt;/a&gt;. For the second case, you need to use the &lt;code&gt;configtree:&lt;/code&gt; prefix so that Spring Boot knows it needs to expose all the files as properties.</source>
          <target state="translated">첫 번째 경우에는 &lt;a href=&quot;#boot-features-external-config-files-importing&quot;&gt;위에서&lt;/a&gt; 설명한대로 &lt;code&gt;spring.config.import&lt;/code&gt; 를 사용하여 YAML 또는 속성 파일을 직접 가져올 수 있습니다 . 두 번째 경우에는 Spring Boot가 모든 파일을 속성으로 노출해야한다는 것을 알 수 있도록 &lt;code&gt;configtree:&lt;/code&gt; 접두사 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ca9a1b7d0217d42316c24df2e7ee5fd67c7c4c24" translate="yes" xml:space="preserve">
          <source>For the hierarchical naming convention, turn the specified tag keys into part of the metric prefix. Ignored if &quot;graphiteTagsEnabled&quot; is true.</source>
          <target state="translated">계층 적 이름 지정 규칙의 경우 지정된 태그 키를 메트릭 접두사의 일부로 바꿉니다. &quot;graphiteTagsEnabled&quot;가 true이면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="502e2f7121788163fe54900fefc903c8eaf9ae08" translate="yes" xml:space="preserve">
          <source>Form-based login or HTTP Basic security (depending on the &lt;code&gt;Accept&lt;/code&gt; header in the request) for the entire application (including actuator endpoints if actuator is on the classpath).</source>
          <target state="translated">전체 애플리케이션에 대한 양식 기반 로그인 또는 HTTP 기본 보안 ( 요청 의 &lt;code&gt;Accept&lt;/code&gt; 헤더에 따라 다름 ) (액추에이터가 클래스 경로에있는 경우 액추에이터 엔드 포인트 포함).</target>
        </trans-unit>
        <trans-unit id="041a5dec481d6bf0724caeaa84bc135d7d9062d4" translate="yes" xml:space="preserve">
          <source>Format</source>
          <target state="translated">Format</target>
        </trans-unit>
        <trans-unit id="6e315580ac437e8758ab6322c8915dced3fb356f" translate="yes" xml:space="preserve">
          <source>Format pattern for access logs.</source>
          <target state="translated">액세스 로그의 형식 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="3d82be8261d17c55c0f5f65bfd5d55c5f46c20a1" translate="yes" xml:space="preserve">
          <source>Format to use when serializing Date objects.</source>
          <target state="translated">Date 객체를 직렬화 할 때 사용할 형식입니다.</target>
        </trans-unit>
        <trans-unit id="d4711e4f92b6b68d107a5d4cfaa567c359a6c25b" translate="yes" xml:space="preserve">
          <source>Formatting strategy for message codes. For instance, `PREFIX_ERROR_CODE`.</source>
          <target state="translated">메시지 코드에 대한 형식화 전략. 예 :`PREFIX_ERROR_CODE`.</target>
        </trans-unit>
        <trans-unit id="f10dc4dd404656e2eaddf1f526b86a8ac45cdbd4" translate="yes" xml:space="preserve">
          <source>FreeMarker</source>
          <target state="translated">FreeMarker</target>
        </trans-unit>
        <trans-unit id="83f82920941b78d6fca544a069bbb8b9679970cc" translate="yes" xml:space="preserve">
          <source>Frequency for refreshing config settings from the LWC service.</source>
          <target state="translated">LWC 서비스에서 구성 설정을 새로 고치는 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="51d3bcc0cf3f4ab7598b87c0feda588e8a81e264" translate="yes" xml:space="preserve">
          <source>Frequency with which the consumer offsets are auto-committed to Kafka if 'enable.auto.commit' is set to true.</source>
          <target state="translated">'enable.auto.commit'이 true로 설정된 경우 소비자 오프셋이 Kafka에 자동 커밋되는 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="2795b88eb372bbfc09024e901b2d129744369df8" translate="yes" xml:space="preserve">
          <source>Frequency with which to push metrics.</source>
          <target state="translated">메트릭을 푸시 할 빈도입니다.</target>
        </trans-unit>
        <trans-unit id="4cc195a5362b748ac025b01f752376b351ecf04d" translate="yes" xml:space="preserve">
          <source>From inside the embedded shell, you can run other commands directly:</source>
          <target state="translated">포함 된 셸 내부에서 다른 명령을 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eac8913af7803ae0abe15518c40709ebdaf82470" translate="yes" xml:space="preserve">
          <source>Fully executable jars work by embedding an extra script at the front of the file. Currently, some tools do not accept this format, so you may not always be able to use this technique. For example, &lt;code&gt;jar -xf&lt;/code&gt; may silently fail to extract a jar or war that has been made fully executable. It is recommended that you make your jar or war fully executable only if you intend to execute it directly, rather than running it with &lt;code&gt;java -jar&lt;/code&gt; or deploying it to a servlet container.</source>
          <target state="translated">완전히 실행 가능한 jar는 파일 앞에 추가 스크립트를 삽입하여 작동합니다. 현재 일부 도구는이 형식을 허용하지 않으므로 항상이 기술을 사용하지 못할 수 있습니다. 예를 들어, &lt;code&gt;jar -xf&lt;/code&gt; 는 완전히 실행 가능한 jar 또는 war를 자동으로 추출하지 못할 수 있습니다. jar 또는 war를 &lt;code&gt;java -jar&lt;/code&gt; 로 실행 하거나 서블릿 컨테이너에 배포하는 것보다 직접 실행하려는 경우에만 jar 또는 war를 완전히 실행 가능하게 만드는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2cede8df16956488c52c2fbbc3df9c7465dd093e" translate="yes" xml:space="preserve">
          <source>Fully qualified name of the CachingProvider implementation to use to retrieve the JSR-107 compliant cache manager. Needed only if more than one JSR-107 implementation is available on the classpath.</source>
          <target state="translated">JSR-107 호환 캐시 관리자를 검색하는 데 사용할 CachingProvider 구현의 완전한 이름입니다. 클래스 경로에서 둘 이상의 JSR-107 구현을 사용할 수있는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5c1ab3362ff402ac20090efcc615b7885b4da2b5" translate="yes" xml:space="preserve">
          <source>Fully qualified name of the FieldNamingStrategy to use.</source>
          <target state="translated">사용할 FieldNamingStrategy의 정규화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="9258ff57444cb847e4cb740e3bfc1f5e38d1eef4" translate="yes" xml:space="preserve">
          <source>Fully qualified name of the JDBC driver. Auto-detected based on the URL by default.</source>
          <target state="translated">JDBC 드라이버의 완전한 이름입니다. 기본적으로 URL을 기반으로 자동 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="9407a295fd5b6445cacc1af2f25209ac79a36a9c" translate="yes" xml:space="preserve">
          <source>Fully qualified name of the connection pool implementation to use. By default, it is auto-detected from the classpath.</source>
          <target state="translated">사용할 연결 풀 구현의 완전한 이름입니다. 기본적으로 클래스 경로에서 자동 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="92d4eec8044b608d56054e9a8dd4fceb1c0aa7c3" translate="yes" xml:space="preserve">
          <source>Fully qualified name of the implicit naming strategy.</source>
          <target state="translated">암시 적 명명 전략의 정규화 된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e4f9f486aac57857d1ec96b7b7de40211b07df55" translate="yes" xml:space="preserve">
          <source>Fully qualified name of the physical naming strategy.</source>
          <target state="translated">물리적 이름 지정 전략의 완전한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="536dd5337a0e72cf7753a7582deca02df728c648" translate="yes" xml:space="preserve">
          <source>Furthermore, Spring Boot only sanitizes the sensitive portion of URIs for keys which end with &quot;uri&quot;, &quot;uris&quot;, &quot;address&quot;, or &quot;addresses&quot;. The sensitive portion of the URI is identified using the format &lt;code&gt;&amp;lt;scheme&amp;gt;://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&lt;/code&gt;. For example, for the property &lt;code&gt;myclient.uri=http://user1:password1@localhost:8081&lt;/code&gt;, the resulting sanitized value is &lt;code&gt;http://user1:******@localhost:8081&lt;/code&gt;.</source>
          <target state="translated">또한 Spring Boot는 &quot;uri&quot;, &quot;uris&quot;, &quot;address&quot;또는 &quot;addresses&quot;로 끝나는 키에 대한 URI의 민감한 부분 만 삭제합니다. URI의 민감한 부분은 &lt;code&gt;&amp;lt;scheme&amp;gt;://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&lt;/code&gt; 형식을 사용하여 식별됩니다 . 예를 들어 &lt;code&gt;myclient.uri=http://user1:password1@localhost:8081&lt;/code&gt; 속성의 경우 결과적으로 삭제 된 값은 &lt;code&gt;http://user1:******@localhost:8081&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c682ceeacadb68101cf54c1ac499a56f999e34de" translate="yes" xml:space="preserve">
          <source>Ganglia</source>
          <target state="translated">Ganglia</target>
        </trans-unit>
        <trans-unit id="a1785b16f7250a55df96b5f38a082bf0a1e9285e" translate="yes" xml:space="preserve">
          <source>General prefix to be prepended to the page number and page size parameters.</source>
          <target state="translated">페이지 번호 및 페이지 크기 매개 변수 앞에 추가 할 일반 접두어입니다.</target>
        </trans-unit>
        <trans-unit id="27ebb69c07cbd91ca90b8608e44747916e510358" translate="yes" xml:space="preserve">
          <source>Generally, you should first consider using one of the many available configuration keys and customize your web server by adding new entries in your &lt;code&gt;application.properties&lt;/code&gt; (or &lt;code&gt;application.yml&lt;/code&gt;, or environment, etc. see &amp;ldquo;&lt;a href=&quot;#howto-discover-build-in-options-for-external-properties&quot;&gt;Discover Built-in Options for External Properties&lt;/a&gt;&amp;rdquo;). The &lt;code&gt;server.*&lt;/code&gt; namespace is quite useful here, and it includes namespaces like &lt;code&gt;server.tomcat.*&lt;/code&gt;, &lt;code&gt;server.jetty.*&lt;/code&gt; and others, for server-specific features. See the list of &lt;a href=&quot;appendix-application-properties#common-application-properties&quot;&gt;appendix-application-properties.html&lt;/a&gt;.</source>
          <target state="translated">일반적으로, 먼저 사용할 수있는 많은 구성 키 중 하나를 사용하는 것이 좋습니다하고 새로운 항목을 추가하여 웹 서버를 사용자 정의 &lt;code&gt;application.properties&lt;/code&gt; (또는 &lt;code&gt;application.yml&lt;/code&gt; 표시 등, 또는 환경 &quot; &lt;a href=&quot;#howto-discover-build-in-options-for-external-properties&quot;&gt;발견 내장 외부 속성에 대한 옵션&lt;/a&gt; &quot; ). &lt;code&gt;server.*&lt;/code&gt; 네임 스페이스는 여기에 매우 유용하며,이 같은 네임 스페이스를 포함 &lt;code&gt;server.tomcat.*&lt;/code&gt; , &lt;code&gt;server.jetty.*&lt;/code&gt; 다른 사람, 서버 별 기능에 대해. &lt;a href=&quot;appendix-application-properties#common-application-properties&quot;&gt;appendix-application-properties.html&lt;/a&gt; 목록을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7dc74c36a3dce8d11ad418dccfe3db72770de4a5" translate="yes" xml:space="preserve">
          <source>Generate build information</source>
          <target state="translated">빌드 정보 생성</target>
        </trans-unit>
        <trans-unit id="41d856bb1bf5e49f688f21b2fb079d709efb677b" translate="yes" xml:space="preserve">
          <source>Generate git information</source>
          <target state="translated">Git 정보 생성</target>
        </trans-unit>
        <trans-unit id="ff7613e54fc90271b8a71da3dfd9a50e5acd96c2" translate="yes" xml:space="preserve">
          <source>Generic</source>
          <target state="translated">Generic</target>
        </trans-unit>
        <trans-unit id="21eba1ca2b855114aadc61159793503c153e8c71" translate="yes" xml:space="preserve">
          <source>Generic caching is used if the context defines &lt;em&gt;at least&lt;/em&gt; one &lt;code&gt;org.springframework.cache.Cache&lt;/code&gt; bean. A &lt;code&gt;CacheManager&lt;/code&gt; wrapping all beans of that type is created.</source>
          <target state="translated">일반 캐싱 컨텍스트 정의하는 경우 사용되는 &lt;em&gt;적어도&lt;/em&gt; 하나의 &lt;code&gt;org.springframework.cache.Cache&lt;/code&gt; 의 콩. 해당 유형의 모든 Bean을 래핑 하는 &lt;code&gt;CacheManager&lt;/code&gt; 가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="370c3d934a07f2b19607dc6f1b6c7fe877e03333" translate="yes" xml:space="preserve">
          <source>Generic type arguments, varargs and array elements nullability are not yet supported. See &lt;a href=&quot;https://jira.spring.io/browse/SPR-15942&quot;&gt;SPR-15942&lt;/a&gt; for up-to-date information. Also be aware that Spring Boot&amp;rsquo;s own API is &lt;a href=&quot;https://github.com/spring-projects/spring-boot/issues/10712&quot;&gt;not yet annotated&lt;/a&gt;.</source>
          <target state="translated">일반 형식 인수, varargs 및 배열 요소 null 허용 여부는 아직 지원되지 않습니다. 최신 정보는 &lt;a href=&quot;https://jira.spring.io/browse/SPR-15942&quot;&gt;SPR-15942&lt;/a&gt; 를 참조하십시오 . 또한 Spring Boot의 자체 API는 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/issues/10712&quot;&gt;아직 주석 처리되지 않았습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="0a61558d2e5a820fa0f204f6118dff0b5b67e7d5" translate="yes" xml:space="preserve">
          <source>Global prefix to separate metrics originating from this app's white box instrumentation from those originating from other Wavefront integrations when viewed in the Wavefront UI.</source>
          <target state="translated">Wavefront UI에서 볼 때이 앱의 화이트 박스 계측에서 발생하는 메트릭을 다른 Wavefront 통합에서 발생하는 메트릭과 구분하는 글로벌 접두사입니다.</target>
        </trans-unit>
        <trans-unit id="4ecfa50456b912af78aca11e5156571cfddaee02" translate="yes" xml:space="preserve">
          <source>Google Cloud has several options that can be used to launch Spring Boot applications. The easiest to get started with is probably App Engine, but you could also find ways to run Spring Boot in a container with Container Engine or on a virtual machine with Compute Engine.</source>
          <target state="translated">GCP에는 Spring Boot 애플리케이션을 시작하는 데 사용할 수있는 몇 가지 옵션이 있습니다. 시작하기 가장 쉬운 방법은 아마도 App Engine 일 것입니다.하지만 Container Engine이있는 컨테이너 또는 Compute Engine이있는 가상 머신에서 Spring Boot를 실행하는 방법도 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d5141298af5293b158f142b93cc79303bac8b47" translate="yes" xml:space="preserve">
          <source>Grabs</source>
          <target state="translated">Grabs</target>
        </trans-unit>
        <trans-unit id="8ef85cc7a7c6444cb46bd7b35e8249c9ee990a3c" translate="yes" xml:space="preserve">
          <source>Graceful shutdown</source>
          <target state="translated">정상 종료</target>
        </trans-unit>
        <trans-unit id="17503e06e0263d6fe9f105fa52b0724bb2946582" translate="yes" xml:space="preserve">
          <source>Graceful shutdown is supported with all four embedded web servers (Jetty, Reactor Netty, Tomcat, and Undertow) and with both reactive and Servlet-based web applications. It occurs as part of closing the application context and is performed in the earliest phase of stopping &lt;code&gt;SmartLifecycle&lt;/code&gt; beans. This stop processing uses a timeout which provides a grace period during which existing requests will be allowed to complete but no new requests will be permitted. The exact way in which new requests are not permitted varies depending on the web server that is being used. Jetty, Reactor Netty, and Tomcat will stop accepting requests at the network layer. Undertow will accept requests but respond immediately with a service unavailable (503) response.</source>
          <target state="translated">Graceful shutdown is supported with all four embedded web servers (Jetty, Reactor Netty, Tomcat, and Undertow) and with both reactive and Servlet-based web applications. It occurs as part of closing the application context and is performed in the earliest phase of stopping &lt;code&gt;SmartLifecycle&lt;/code&gt; beans. This stop processing uses a timeout which provides a grace period during which existing requests will be allowed to complete but no new requests will be permitted. The exact way in which new requests are not permitted varies depending on the web server that is being used. Jetty, Reactor Netty, and Tomcat will stop accepting requests at the network layer. Undertow will accept requests but respond immediately with a service unavailable (503) response.</target>
        </trans-unit>
        <trans-unit id="04c39b803c0e06f05528c75e5360282591dad32f" translate="yes" xml:space="preserve">
          <source>Graceful shutdown with Tomcat requires Tomcat 9.0.33 or later.</source>
          <target state="translated">Graceful shutdown with Tomcat requires Tomcat 9.0.33 or later.</target>
        </trans-unit>
        <trans-unit id="f426be61bd7a1e2a2ad7e39cb0258e09623e3b4d" translate="yes" xml:space="preserve">
          <source>Gradle</source>
          <target state="translated">Gradle</target>
        </trans-unit>
        <trans-unit id="c7ed092fe19e42fc8e269a29bb077a8bea606094" translate="yes" xml:space="preserve">
          <source>Gradle Shadow Plugin</source>
          <target state="translated">Gradle Shadow Plugin</target>
        </trans-unit>
        <trans-unit id="9e3a9c070da0e9a9e0358c2b1a1f4cf85bac7c60" translate="yes" xml:space="preserve">
          <source>Gradle Wrapper</source>
          <target state="translated">Gradle Wrapper</target>
        </trans-unit>
        <trans-unit id="d6b319e66557a860d4eeb5bae35ad082eca7b2e1" translate="yes" xml:space="preserve">
          <source>Gradle default</source>
          <target state="translated">Gradle default</target>
        </trans-unit>
        <trans-unit id="1751826bb4bc66e965fbbaff32990ec061aca168" translate="yes" xml:space="preserve">
          <source>Gradle users can achieve the same result by using the &lt;a href=&quot;https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties&quot;&gt;&lt;code&gt;gradle-git-properties&lt;/code&gt;&lt;/a&gt; plugin, as shown in the following example:</source>
          <target state="translated">Gradle users can achieve the same result by using the &lt;a href=&quot;https://plugins.gradle.org/plugin/com.gorylenko.gradle-git-properties&quot;&gt; &lt;code&gt;gradle-git-properties&lt;/code&gt; &lt;/a&gt; plugin, as shown in the following example:</target>
        </trans-unit>
        <trans-unit id="8563bcec902c464212ae894fc142cba2c3961dc7" translate="yes" xml:space="preserve">
          <source>Gradle&amp;rsquo;s &lt;code&gt;expand&lt;/code&gt; method uses Groovy&amp;rsquo;s &lt;code&gt;SimpleTemplateEngine&lt;/code&gt;, which transforms &lt;code&gt;${..}&lt;/code&gt; tokens. The &lt;code&gt;${..}&lt;/code&gt; style conflicts with Spring&amp;rsquo;s own property placeholder mechanism. To use Spring property placeholders together with automatic expansion, escape the Spring property placeholders as follows: &lt;code&gt;\${..}&lt;/code&gt;.</source>
          <target state="translated">Gradle&amp;rsquo;s &lt;code&gt;expand&lt;/code&gt; method uses Groovy&amp;rsquo;s &lt;code&gt;SimpleTemplateEngine&lt;/code&gt; , which transforms &lt;code&gt;${..}&lt;/code&gt; tokens. The &lt;code&gt;${..}&lt;/code&gt; style conflicts with Spring&amp;rsquo;s own property placeholder mechanism. To use Spring property placeholders together with automatic expansion, escape the Spring property placeholders as follows: &lt;code&gt;\${..}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95c949a818cfe42989a077c56b3db44d8dee4417" translate="yes" xml:space="preserve">
          <source>Granted roles for the default user name.</source>
          <target state="translated">Granted roles for the default user name.</target>
        </trans-unit>
        <trans-unit id="220c98deb1482e5b5361b123b929ee8e4ac1e18d" translate="yes" xml:space="preserve">
          <source>Graphite</source>
          <target state="translated">Graphite</target>
        </trans-unit>
        <trans-unit id="933bf21afdd55a0d2283845fed0e7bbdd1f5db49" translate="yes" xml:space="preserve">
          <source>Green</source>
          <target state="translated">Green</target>
        </trans-unit>
        <trans-unit id="9dd7abf77efe05e6912666fdd664a407ed8c6ea5" translate="yes" xml:space="preserve">
          <source>GridFS bucket name.</source>
          <target state="translated">GridFS bucket name.</target>
        </trans-unit>
        <trans-unit id="c56fa37167ea4ac415683d3c2935bcca9ae967d6" translate="yes" xml:space="preserve">
          <source>GridFS database name.</source>
          <target state="translated">GridFS database name.</target>
        </trans-unit>
        <trans-unit id="9c53c00c11322199b3e81911676df4641d902d7b" translate="yes" xml:space="preserve">
          <source>Groovy</source>
          <target state="translated">Groovy</target>
        </trans-unit>
        <trans-unit id="48e5ed679641de622aba19fc95bd4a176714e56e" translate="yes" xml:space="preserve">
          <source>Group ID</source>
          <target state="translated">Group ID</target>
        </trans-unit>
        <trans-unit id="3e11fc1f1d0f2e351fc8d269cb4db31729b98e90" translate="yes" xml:space="preserve">
          <source>Group for exported metrics. Used to specify custom device group name in the Dynatrace UI.</source>
          <target state="translated">Group for exported metrics. Used to specify custom device group name in the Dynatrace UI.</target>
        </trans-unit>
        <trans-unit id="eaf193e27d29a1e1d445beff6eba0c999c9b36f2" translate="yes" xml:space="preserve">
          <source>Grouping key for the pushed metrics.</source>
          <target state="translated">Grouping key for the pushed metrics.</target>
        </trans-unit>
        <trans-unit id="136a63c3429fc69de88e1cfb25a608757671fcc0" translate="yes" xml:space="preserve">
          <source>Gson</source>
          <target state="translated">Gson</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="818082e24bf60bff999b812d843c4dc43fe324c2" translate="yes" xml:space="preserve">
          <source>HTTP Tracing</source>
          <target state="translated">HTTP Tracing</target>
        </trans-unit>
        <trans-unit id="8d5159e0545649f87543e1dab237aa74d34310c4" translate="yes" xml:space="preserve">
          <source>HTTP Tracing can be enabled by providing a bean of type &lt;code&gt;HttpTraceRepository&lt;/code&gt; in your application&amp;rsquo;s configuration. For convenience, Spring Boot offers an &lt;code&gt;InMemoryHttpTraceRepository&lt;/code&gt; that stores traces for the last 100 request-response exchanges, by default. &lt;code&gt;InMemoryHttpTraceRepository&lt;/code&gt; is limited compared to other tracing solutions and we recommend using it only for development environments. For production environments, use of a production-ready tracing or observability solution, such as Zipkin or Spring Cloud Sleuth, is recommended. Alternatively, create your own &lt;code&gt;HttpTraceRepository&lt;/code&gt; that meets your needs.</source>
          <target state="translated">HTTP Tracing can be enabled by providing a bean of type &lt;code&gt;HttpTraceRepository&lt;/code&gt; in your application&amp;rsquo;s configuration. For convenience, Spring Boot offers an &lt;code&gt;InMemoryHttpTraceRepository&lt;/code&gt; that stores traces for the last 100 request-response exchanges, by default. &lt;code&gt;InMemoryHttpTraceRepository&lt;/code&gt; is limited compared to other tracing solutions and we recommend using it only for development environments. For production environments, use of a production-ready tracing or observability solution, such as Zipkin or Spring Cloud Sleuth, is recommended. Alternatively, create your own &lt;code&gt;HttpTraceRepository&lt;/code&gt; that meets your needs.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
