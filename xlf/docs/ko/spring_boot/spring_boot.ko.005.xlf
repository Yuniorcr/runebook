<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="spring_boot">
    <body>
      <group id="spring_boot">
        <trans-unit id="66c25b3f91fc8840e220899d8bb9aaf302a00d09" translate="yes" xml:space="preserve">
          <source>The format of the &lt;code&gt;additional-spring-configuration-metadata.json&lt;/code&gt; file is exactly the same as the regular &lt;code&gt;spring-configuration-metadata.json&lt;/code&gt;. The additional properties file is optional. If you do not have any additional properties, do not add the file.</source>
          <target state="translated">&lt;code&gt;additional-spring-configuration-metadata.json&lt;/code&gt; 파일 의 형식은 일반 &lt;code&gt;spring-configuration-metadata.json&lt;/code&gt; 과 정확히 동일 합니다 . 추가 속성 파일은 선택 사항입니다. 추가 속성이없는 경우 파일을 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9ddfd32c2e3e71e345cae5515d422d018062a360" translate="yes" xml:space="preserve">
          <source>The format to use when rendering the log level (default &lt;code&gt;%5p&lt;/code&gt;).</source>
          <target state="translated">로그 수준을 렌더링 할 때 사용할 형식 (기본값 &lt;code&gt;%5p&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7da785af774d728c7a48df5be51224c6da88296f" translate="yes" xml:space="preserve">
          <source>The full name of the group. This attribute is mandatory.</source>
          <target state="translated">그룹의 전체 이름입니다. 이 속성은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="31c410ebe1373afb82e278913855a6b6c87b9b79" translate="yes" xml:space="preserve">
          <source>The full name of the method (include parenthesis and argument types) that contributed this group (for example, the name of a &lt;code&gt;@ConfigurationProperties&lt;/code&gt; annotated &lt;code&gt;@Bean&lt;/code&gt; method). If the source method is not known, it may be omitted.</source>
          <target state="translated">이 그룹에 기여한 메서드의 전체 이름 (괄호 및 인수 유형 포함) (예 : &lt;code&gt;@Bean&lt;/code&gt; 메서드 주석이 달린 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 의 이름 )입니다. 소스 방법을 알 수없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="328ddbc00c02c8f4d8b207c9aac03fd620cfc720" translate="yes" xml:space="preserve">
          <source>The full name of the property that &lt;em&gt;replaces&lt;/em&gt; this deprecated property. If there is no replacement for this property, it may be omitted.</source>
          <target state="translated">이 더 이상 사용되지 않는 속성 을 &lt;em&gt;대체&lt;/em&gt; 하는 속성의 전체 이름입니다 . 이 속성을 대체 할 수없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c21e3105b22678edf57e5097137ba4b40b21a7b8" translate="yes" xml:space="preserve">
          <source>The full name of the property to which this hint refers. Names are in lower-case period-separated form (such as &lt;code&gt;spring.mvc.servlet.path&lt;/code&gt;). If the property refers to a map (such as &lt;code&gt;system.contexts&lt;/code&gt;), the hint either applies to the &lt;em&gt;keys&lt;/em&gt; of the map (&lt;code&gt;system.contexts.keys&lt;/code&gt;) or the &lt;em&gt;values&lt;/em&gt; (&lt;code&gt;system.contexts.values&lt;/code&gt;) of the map. This attribute is mandatory.</source>
          <target state="translated">이 힌트가 참조하는 속성의 전체 이름입니다. 이름은 마침표로 소문자로 구분 된 형식 (예 : &lt;code&gt;spring.mvc.servlet.path&lt;/code&gt; )입니다. 속성이 맵 (예 : &lt;code&gt;system.contexts&lt;/code&gt; )을 참조하는 경우 힌트 는 맵 의 &lt;em&gt;키&lt;/em&gt; ( &lt;code&gt;system.contexts.keys&lt;/code&gt; ) 또는 맵 의 &lt;em&gt;값&lt;/em&gt; ( &lt;code&gt;system.contexts.values&lt;/code&gt; )에 적용됩니다. 이 속성은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="4f39c4968dfb00d1083bc57c9ea5f4e1cfbc9b1a" translate="yes" xml:space="preserve">
          <source>The full name of the property. Names are in lower-case period-separated form (for example, &lt;code&gt;server.address&lt;/code&gt;). This attribute is mandatory.</source>
          <target state="translated">속성의 전체 이름입니다. 이름은 마침표로 소문자로 구분 된 형식입니다 (예 : &lt;code&gt;server.address&lt;/code&gt; ). 이 속성은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="72ecd30f8339ce1725974774e6e0d202f6a3cbdc" translate="yes" xml:space="preserve">
          <source>The full signature of the data type of the property (for example, &lt;code&gt;java.lang.String&lt;/code&gt;) but also a full generic type (such as &lt;code&gt;java.util.Map&amp;lt;java.lang.String,acme.MyEnum&amp;gt;&lt;/code&gt;). You can use this attribute to guide the user as to the types of values that they can enter. For consistency, the type of a primitive is specified by using its wrapper counterpart (for example, &lt;code&gt;boolean&lt;/code&gt; becomes &lt;code&gt;java.lang.Boolean&lt;/code&gt;). Note that this class may be a complex type that gets converted from a &lt;code&gt;String&lt;/code&gt; as values are bound. If the type is not known, it may be omitted.</source>
          <target state="translated">특성 데이터 유형의 전체 서명 (예 : &lt;code&gt;java.lang.String&lt;/code&gt; )과 전체 일반 유형 (예 : &lt;code&gt;java.util.Map&amp;lt;java.lang.String,acme.MyEnum&amp;gt;&lt;/code&gt; ). 이 속성을 사용하여 사용자가 입력 할 수있는 값 유형에 대해 안내 할 수 있습니다. 일관성을 위해 기본 유형은 래퍼 대응 요소를 사용하여 지정됩니다 (예 : &lt;code&gt;boolean&lt;/code&gt; 은 &lt;code&gt;java.lang.Boolean&lt;/code&gt; ). 이 클래스는 값이 바인딩 될 때 &lt;code&gt;String&lt;/code&gt; 에서 변환되는 복합 유형일 수 있습니다 . 유형을 알 수없는 경우 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b34b393cde3ceb48374646ec7423f4f1f131c2a0" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the bean class that should be assignable to the candidate. Typically used to filter out non-candidate beans.</source>
          <target state="translated">후보자에게 지정 가능해야하는 Bean 클래스의 완전한 이름입니다. 일반적으로 비 후보 Bean을 필터링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5672e24e2159e2034c7c08d7a398a2abf8c73b76" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the class that should be assignable to the chosen value. Typically used to filter out-non candidate classes. Note that this information can be provided by the type itself by exposing a class with the appropriate upper bound.</source>
          <target state="translated">선택한 값에 할당 할 수 있어야하는 클래스의 정규화 된 이름입니다. 일반적으로 비 후보 클래스를 필터링하는 데 사용됩니다. 이 정보는 적절한 상한이있는 클래스를 노출하여 유형 자체에서 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f71d9755a0d829c8a5d1bad6c20e0e752aa6690e" translate="yes" xml:space="preserve">
          <source>The fully qualified name of the type to consider for the property. This parameter is mandatory.</source>
          <target state="translated">특성에 대해 고려할 유형의 완전한 이름입니다. 이 매개 변수는 필수입니다.</target>
        </trans-unit>
        <trans-unit id="7db3d47265b9820501b6e0243e36905f1e32b4e4" translate="yes" xml:space="preserve">
          <source>The host of the proxy to use to connect to the remote application.</source>
          <target state="translated">원격 애플리케이션에 연결하는 데 사용할 프록시의 호스트입니다.</target>
        </trans-unit>
        <trans-unit id="e1929ac70e93c339c5bd8e38be87f945ac47619e" translate="yes" xml:space="preserve">
          <source>The identifier for a given &lt;code&gt;HealthIndicator&lt;/code&gt; is the name of the bean without the &lt;code&gt;HealthIndicator&lt;/code&gt; suffix, if it exists. In the preceding example, the health information is available in an entry named &lt;code&gt;my&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;HealthIndicator&lt;/code&gt; 에 대한 식별자 는 &lt;code&gt;HealthIndicator&lt;/code&gt; 접미사가 없는 경우 해당 Bean의 이름입니다 . 앞의 예에서 건강 정보는 &lt;code&gt;my&lt;/code&gt; 라는 항목에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="babe039ed969544f26641cbdddb378115daa24b3" translate="yes" xml:space="preserve">
          <source>The implementation can load arbitrary files and add them to the &lt;code&gt;Environment&lt;/code&gt;. For instance, the following example loads a YAML configuration file from the classpath:</source>
          <target state="translated">구현은 임의의 파일을로드하여 &lt;code&gt;Environment&lt;/code&gt; 추가 할 수 있습니다. 예를 들어 다음 예제는 클래스 경로에서 YAML 구성 파일을로드합니다.</target>
        </trans-unit>
        <trans-unit id="072fad81bf875ef998f82690ea5eb825c668b764" translate="yes" xml:space="preserve">
          <source>The in-memory backend disables itself as soon as you&amp;rsquo;re using any of the other available backend. You can also disable it explicitly:</source>
          <target state="translated">인 메모리 백엔드는 사용 가능한 다른 백엔드를 사용하는 즉시 자동으로 비활성화됩니다. 명시 적으로 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d805f6bf3a8fefce85f3fc71aca3f05420a23cc2" translate="yes" xml:space="preserve">
          <source>The index file would look like this:</source>
          <target state="translated">색인 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="728942a3920a99d47512490ff0d4c132584b697a" translate="yes" xml:space="preserve">
          <source>The internal state of Spring Boot applications is mostly represented by the Spring &lt;code&gt;ApplicationContext&lt;/code&gt;. If the application context has started successfully, Spring Boot assumes that the application is in a valid state. An application is considered live as soon as the context has been refreshed, see &lt;a href=&quot;#boot-features-application-events-and-listeners&quot;&gt;Spring Boot application lifecycle and related Application Events&lt;/a&gt;.</source>
          <target state="translated">Spring Boot 애플리케이션의 내부 상태는 대부분 Spring &lt;code&gt;ApplicationContext&lt;/code&gt; 로 표현됩니다 . 애플리케이션 컨텍스트가 성공적으로 시작된 경우 Spring Boot는 애플리케이션이 유효한 상태라고 가정합니다. 컨텍스트가 새로 고쳐지 자마자 애플리케이션은 라이브로 간주됩니다. &lt;a href=&quot;#boot-features-application-events-and-listeners&quot;&gt;Spring Boot 애플리케이션 수명주기 및 관련 애플리케이션 이벤트를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="8a144d83c7dfc1c341bd0d6dedefb7940d04f8c3" translate="yes" xml:space="preserve">
          <source>The jOOQ manual tends to use a variable named &lt;code&gt;create&lt;/code&gt; to hold the &lt;code&gt;DSLContext&lt;/code&gt;.</source>
          <target state="translated">jOOQ 설명서라는 이름의 변수를 사용하는 경향이 &lt;code&gt;create&lt;/code&gt; 보류 할 &lt;code&gt;DSLContext&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c05e3d1f59e9395062a2d73476a909741b0b5b8f" translate="yes" xml:space="preserve">
          <source>The latest copy is available at &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/&quot;&gt;docs.spring.io/spring-boot/docs/current/reference/&lt;/a&gt;.</source>
          <target state="translated">최신 사본은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/&quot;&gt;docs.spring.io/spring-boot/docs/current/reference/&lt;/a&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e71e0e23307f0b8e0c72e93bd2dbe49dd20517b2" translate="yes" xml:space="preserve">
          <source>The layers index file can be provided in &lt;code&gt;BOOT-INF/layers.idx&lt;/code&gt;. It provides a list of layers and the parts of the jar that should be contained within them. Layers are written in the order that they should be added to the Docker/OCI image. Layers names are written as quoted strings prefixed with dash space (&lt;code&gt;&quot;-&amp;middot;&quot;&lt;/code&gt;) and with a colon (&lt;code&gt;&quot;:&quot;&lt;/code&gt;) suffix. Layer content is either a file or directory name written as a quoted string prefixed by space space dash space (&lt;code&gt;&quot;&amp;middot;&amp;middot;-&amp;middot;&quot;&lt;/code&gt;). A directory name ends with &lt;code&gt;/&lt;/code&gt;, a file name does not. When a directory name is used it means that all files inside that directory are in the same layer.</source>
          <target state="translated">레이어 색인 파일은 &lt;code&gt;BOOT-INF/layers.idx&lt;/code&gt; 에서 제공 할 수 있습니다 . 레이어 목록과 그 안에 포함되어야하는 항아리 부분을 제공합니다. 레이어는 Docker / OCI 이미지에 추가되어야하는 순서대로 작성됩니다. 레이어 이름은 대시 공백 ( &lt;code&gt;&quot;-&amp;middot;&quot;&lt;/code&gt; )과 콜론 ( &lt;code&gt;&quot;:&quot;&lt;/code&gt; ) 접미사 가있는 따옴표로 묶인 문자열로 작성 됩니다. 레이어 내용은 공백 공백 대시 공백 ( &lt;code&gt;&quot;&amp;middot;&amp;middot;-&amp;middot;&quot;&lt;/code&gt; )이 앞에 붙은 따옴표로 묶인 문자열로 작성된 파일 또는 디렉토리 이름입니다 . 디렉토리 이름은 &lt;code&gt;/&lt;/code&gt; 로 끝나지만 파일 이름은 그렇지 않습니다. 디렉토리 이름이 사용되면 해당 디렉토리 내의 모든 파일이 동일한 레이어에 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5ac87227f6fa892229852d903eddcb1188368d5c" translate="yes" xml:space="preserve">
          <source>The level of deprecation, which can be either &lt;code&gt;warning&lt;/code&gt; (the default) or &lt;code&gt;error&lt;/code&gt;. When a property has a &lt;code&gt;warning&lt;/code&gt; deprecation level, it should still be bound in the environment. However, when it has an &lt;code&gt;error&lt;/code&gt; deprecation level, the property is no longer managed and is not bound.</source>
          <target state="translated">&lt;code&gt;warning&lt;/code&gt; (기본값) 또는 &lt;code&gt;error&lt;/code&gt; 될 수있는 지원 중단 수준입니다 . 속성에 &lt;code&gt;warning&lt;/code&gt; 사용 중단 수준이있는 경우에도 환경에 바인딩되어야합니다. 그러나 &lt;code&gt;error&lt;/code&gt; 폐기 수준이있는 경우 속성은 더 이상 관리되지 않으며 바인딩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75d148a738f9c8780f067529be57122c2c998399" translate="yes" xml:space="preserve">
          <source>The library directory must be made available, if not already, to the JVM library path. You can do so with a JVM argument such as &lt;code&gt;-Djava.library.path=/usr/local/opt/tomcat-native/lib&lt;/code&gt;. More on this in the &lt;a href=&quot;https://tomcat.apache.org/tomcat-9.0-doc/apr.html&quot;&gt;official Tomcat documentation&lt;/a&gt;.</source>
          <target state="translated">라이브러리 디렉토리는 아직 JVM 라이브러리 경로에서 사용할 수 있어야합니다. &lt;code&gt;-Djava.library.path=/usr/local/opt/tomcat-native/lib&lt;/code&gt; 와 같은 JVM 인수를 사용하여이를 수행 할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://tomcat.apache.org/tomcat-9.0-doc/apr.html&quot;&gt;공식 Tomcat 문서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f7bde1312de36803413519e5b89a42d12e53b20" translate="yes" xml:space="preserve">
          <source>The line in the preceding example passes a value of &lt;code&gt;true&lt;/code&gt; for the &lt;code&gt;hibernate.globally_quoted_identifiers&lt;/code&gt; property to the Hibernate entity manager.</source>
          <target state="translated">앞선 예제의 행 은 &lt;code&gt;hibernate.globally_quoted_identifiers&lt;/code&gt; 속성에 대한 &lt;code&gt;true&lt;/code&gt; 값을 Hibernate 엔티티 관리자에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="1188429780ff5631aa0a096f34348a6e0cec96fb" translate="yes" xml:space="preserve">
          <source>The list is ordered by precedence (with values from lower items overriding earlier ones). Documents from the loaded files are added as &lt;code&gt;PropertySources&lt;/code&gt; to the Spring &lt;code&gt;Environment&lt;/code&gt;.</source>
          <target state="translated">목록은 우선 순위에 따라 정렬됩니다 (하위 항목의 값이 이전 항목보다 우선 함). 로드 된 파일의 문서 는 Spring &lt;code&gt;Environment&lt;/code&gt; &lt;code&gt;PropertySources&lt;/code&gt; 로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b74a0e1fbf4d667e063cdb8bb86b49b4cbecc0b" translate="yes" xml:space="preserve">
          <source>The location of the &lt;code&gt;java&lt;/code&gt; executable is discovered by using the &lt;code&gt;PATH&lt;/code&gt; by default, but you can set it explicitly if there is an executable file at &lt;code&gt;$JAVA_HOME/bin/java&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;java&lt;/code&gt; 실행 파일 의 위치는 기본적으로 &lt;code&gt;PATH&lt;/code&gt; 를 사용하여 검색 되지만 &lt;code&gt;$JAVA_HOME/bin/java&lt;/code&gt; 실행 파일이있는 경우 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a3b44d95f8d38ac92133ce20b34c12a35e77155" translate="yes" xml:space="preserve">
          <source>The location of the configuration file to use to initialize EhCache.</source>
          <target state="translated">EhCache를 초기화하는 데 사용할 구성 파일의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="ef0d2e4e926fdc61959e84d544052004e216263a" translate="yes" xml:space="preserve">
          <source>The location of the configuration file to use to initialize Hazelcast.</source>
          <target state="translated">Hazelcast를 초기화하는 데 사용할 구성 파일의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="0688a24208a021f5db5d3a200ece812b5e20eeed" translate="yes" xml:space="preserve">
          <source>The location of the configuration file to use to initialize Infinispan.</source>
          <target state="translated">Infinispan을 초기화하는 데 사용할 구성 파일의 위치입니다.</target>
        </trans-unit>
        <trans-unit id="c04fce4df6166af7a615b0b143750ee577dfdda5" translate="yes" xml:space="preserve">
          <source>The location of the configuration file to use to initialize the cache manager. The configuration file is dependent of the underlying cache implementation.</source>
          <target state="translated">캐시 관리자를 초기화하는 데 사용할 구성 파일의 위치입니다. 구성 파일은 기본 캐시 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6c7983308decdb84ca9b691e3569034887d71cd3" translate="yes" xml:space="preserve">
          <source>The log message.</source>
          <target state="translated">로그 메시지</target>
        </trans-unit>
        <trans-unit id="7b689ff12a526bdf793ea93ac767aaa3d72174cf" translate="yes" xml:space="preserve">
          <source>The log pattern to use in a file (if &lt;code&gt;LOG_FILE&lt;/code&gt; is enabled).</source>
          <target state="translated">파일에서 사용할 로그 패턴 ( &lt;code&gt;LOG_FILE&lt;/code&gt; 이 활성화 된 경우).</target>
        </trans-unit>
        <trans-unit id="29bb58f455bd5f84947b8fb4a3409a193beda673" translate="yes" xml:space="preserve">
          <source>The log pattern to use on the console (stdout).</source>
          <target state="translated">콘솔에서 사용할 로그 패턴 (stdout).</target>
        </trans-unit>
        <trans-unit id="f8cae559009682eeae665016ffba80a8e488d966" translate="yes" xml:space="preserve">
          <source>The magic values are (in this example) are &lt;code&gt;sample1&lt;/code&gt; and &lt;code&gt;sample2&lt;/code&gt;. In order to offer additional content assistance for the keys, you could add the following JSON to &lt;a href=&quot;#configuration-metadata-additional-metadata&quot;&gt;the manual metadata of the module&lt;/a&gt;:</source>
          <target state="translated">매직 값은 (이 예에서) &lt;code&gt;sample1&lt;/code&gt; 및 &lt;code&gt;sample2&lt;/code&gt; 입니다. 키에 대한 추가 콘텐츠 지원을 제공하기 위해 &lt;a href=&quot;#configuration-metadata-additional-metadata&quot;&gt;모듈의 수동 메타 데이터에&lt;/a&gt; 다음 JSON을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28e3c44f42af3001a18c278a1c0b918fc7a83cd3" translate="yes" xml:space="preserve">
          <source>The main application class to run</source>
          <target state="translated">실행할 기본 애플리케이션 클래스</target>
        </trans-unit>
        <trans-unit id="0c1417ddf14cdd8daaa486a56b35d2a4411467ff" translate="yes" xml:space="preserve">
          <source>The majority of the metadata file is generated automatically at compile time by processing all items annotated with &lt;code&gt;@ConfigurationProperties&lt;/code&gt;. However, it is possible to &lt;a href=&quot;#configuration-metadata-additional-metadata&quot;&gt;write part of the metadata manually&lt;/a&gt; for corner cases or more advanced use cases.</source>
          <target state="translated">대부분의 메타 데이터 파일은 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 주석이 달린 모든 항목을 처리하여 컴파일 타임에 자동으로 생성됩니다 . 그러나 코너 케이스 또는 고급 사용 사례에 대해 &lt;a href=&quot;#configuration-metadata-additional-metadata&quot;&gt;메타 데이터의 일부를 수동으로 작성할&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a99e3c16779706d676298828b56f0bc02583a77" translate="yes" xml:space="preserve">
          <source>The maximum amount of size log archives can take before being deleted.</source>
          <target state="translated">로그 아카이브를 삭제할 수있는 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="f5d2468ae4f1ff5fddbc2fa7a555e2063ef46be8" translate="yes" xml:space="preserve">
          <source>The maximum size of log file before it&amp;rsquo;s archived.</source>
          <target state="translated">보관되기 전 로그 파일의 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="27fd07102c3516ee4eb7e38f951f9f14e71a455f" translate="yes" xml:space="preserve">
          <source>The method validation feature supported by Bean Validation 1.1 is automatically enabled as long as a JSR-303 implementation (such as Hibernate validator) is on the classpath. This lets bean methods be annotated with &lt;code&gt;javax.validation&lt;/code&gt; constraints on their parameters and/or on their return value. Target classes with such annotated methods need to be annotated with the &lt;code&gt;@Validated&lt;/code&gt; annotation at the type level for their methods to be searched for inline constraint annotations.</source>
          <target state="translated">Bean Validation 1.1에서 지원하는 메소드 유효성 검사 기능은 JSR-303 구현 (예 : Hibernate 유효성 검사기)이 클래스 경로에있는 한 자동으로 활성화됩니다. 이를 통해 Bean 메소드 는 매개 변수 및 / 또는 리턴 값에 대한 &lt;code&gt;javax.validation&lt;/code&gt; 제약 조건 으로 주석을 달 수 있습니다 . 이러한 어노테이션이있는 메소드가있는 대상 클래스 는 해당 메소드가 인라인 제약 어노테이션을 검색 할 수 있도록 유형 레벨에서 &lt;code&gt;@Validated&lt;/code&gt; 어노테이션으로 어노테이션을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="33586b93b5e8f45c17a2f86327bb93e343a66e94" translate="yes" xml:space="preserve">
          <source>The monitored classpath directories are now polled every 2 seconds for changes, and a 1 second quiet period is maintained to make sure there are no additional class changes.</source>
          <target state="translated">모니터링되는 클래스 경로 디렉토리는 이제 변경 사항에 대해 2 초마다 폴링되며 추가 클래스 변경 사항이 없는지 확인하기 위해 1 초의 조용한 기간이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="93acd161951b57dc720ac038b8cf3984782dacf0" translate="yes" xml:space="preserve">
          <source>The most common options to set are shown in the following example:</source>
          <target state="translated">설정하는 가장 일반적인 옵션은 다음 예에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="04986444099efffd8d56959f0e1128d6f95c6d79" translate="yes" xml:space="preserve">
          <source>The most extreme (and rarely used) option is to create your own &lt;code&gt;RestTemplateBuilder&lt;/code&gt; bean without using a configurer. Doing so switches off the auto-configuration of a &lt;code&gt;RestTemplateBuilder&lt;/code&gt; and prevents any &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; beans from being used.</source>
          <target state="translated">가장 극단적 인 (그리고 거의 사용되지 않는) 옵션은 구성자를 사용 하지 않고 자신 만의 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 빈 을 만드는 것 입니다. 이렇게하면의 자동 구성 꺼 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 및 방지 어떤 &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; 에 사용되는 콩.</target>
        </trans-unit>
        <trans-unit id="bb42a6c77bd77267cb1b652a1a1befe4c77aff73" translate="yes" xml:space="preserve">
          <source>The multipart support is helpful when you want to receive multipart encoded file data as a &lt;code&gt;@RequestParam&lt;/code&gt;-annotated parameter of type &lt;code&gt;MultipartFile&lt;/code&gt; in a Spring MVC controller handler method.</source>
          <target state="translated">멀티 파트 지원은 Spring MVC 컨트롤러 핸들러 메서드에서 &lt;code&gt;MultipartFile&lt;/code&gt; 유형 의 &lt;code&gt;@RequestParam&lt;/code&gt; 주석이 달린 매개 변수 로 멀티 파트 인코딩 된 파일 데이터를 수신하려는 경우 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="23ee662ae0659faa0ffa21e02b6e56ccba9207b8" translate="yes" xml:space="preserve">
          <source>The name of the MBean is usually generated from the &lt;code&gt;id&lt;/code&gt; of the endpoint. For example, the &lt;code&gt;health&lt;/code&gt; endpoint is exposed as &lt;code&gt;org.springframework.boot:type=Endpoint,name=Health&lt;/code&gt;.</source>
          <target state="translated">MBean의 이름은 일반적으로 엔드 포인트 의 &lt;code&gt;id&lt;/code&gt; 에서 생성 됩니다. 예를 들어 &lt;code&gt;health&lt;/code&gt; 엔드 포인트는 &lt;code&gt;org.springframework.boot:type=Endpoint,name=Health&lt;/code&gt; 로 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2b3bdd509135ac54d7c21f86558ceba6bc5dd8fe" translate="yes" xml:space="preserve">
          <source>The name of the app. If the jar is run from a symlink, the script guesses the app name. If it is not a symlink or you want to explicitly set the app name, this can be useful.</source>
          <target state="translated">앱의 이름입니다. jar가 심볼릭 링크에서 실행되는 경우 스크립트는 앱 이름을 추측합니다. 심볼릭 링크가 아니거나 앱 이름을 명시 적으로 설정하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeecd19922684f0ae7190b1528c6ce9555f9bc8b" translate="yes" xml:space="preserve">
          <source>The name of the folder from which to read .conf files (same folder as jar-file by default).</source>
          <target state="translated">.conf 파일을 읽을 폴더의 이름입니다 (기본적으로 jar-file과 동일한 폴더).</target>
        </trans-unit>
        <trans-unit id="1fa289e812bd0bb93833514254045ba9c1e8c923" translate="yes" xml:space="preserve">
          <source>The name of the folder in which to put log files (&lt;code&gt;/var/log&lt;/code&gt; by default).</source>
          <target state="translated">로그 파일을 저장할 폴더의 이름입니다 ( 기본적으로 &lt;code&gt;/var/log&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1908085a96a7e7280cbf5acdd5b84fd227e8934b" translate="yes" xml:space="preserve">
          <source>The name of the log file in the &lt;code&gt;LOG_FOLDER&lt;/code&gt; (&lt;code&gt;&amp;lt;appname&amp;gt;.log&lt;/code&gt; by default).</source>
          <target state="translated">&lt;code&gt;LOG_FOLDER&lt;/code&gt; ( 기본적으로 &lt;code&gt;&amp;lt;appname&amp;gt;.log&lt;/code&gt; ) 에있는 로그 파일의 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="1e03de2e17454aafb611a7bb9ba39ead589712dc" translate="yes" xml:space="preserve">
          <source>The name of the provider to use to offer additional content assistance for the element to which the hint refers.</source>
          <target state="translated">힌트가 참조하는 요소에 대한 추가 콘텐츠 지원을 제공하는 데 사용할 공급자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b627a61ccec8dd5e98000c5768073d3dcff8cb50" translate="yes" xml:space="preserve">
          <source>The name you use here should match the name used in the code, not the name after it has been naming-convention normalized for a monitoring system it is shipped to. In other words, if &lt;code&gt;jvm.memory.max&lt;/code&gt; appears as &lt;code&gt;jvm_memory_max&lt;/code&gt; in Prometheus because of its snake case naming convention, you should still use &lt;code&gt;jvm.memory.max&lt;/code&gt; as the selector when inspecting the meter in the &lt;code&gt;metrics&lt;/code&gt; endpoint.</source>
          <target state="translated">여기에서 사용하는 이름은 배송되는 모니터링 시스템에 대해 정규화 된 이름 지정 규칙 이후의 이름이 아니라 코드에 사용 된 이름과 일치해야합니다. 즉, 경우 &lt;code&gt;jvm.memory.max&lt;/code&gt; 으로 나타납니다 &lt;code&gt;jvm_memory_max&lt;/code&gt; 때문에 뱀 경우 명명 규칙의 프로 메테우스에서, 당신은 여전히 사용해야 &lt;code&gt;jvm.memory.max&lt;/code&gt; 에 미터를 검사 할 때 선택으로 &lt;code&gt;metrics&lt;/code&gt; 엔드 포인트.</target>
        </trans-unit>
        <trans-unit id="1ac12ea11ce4a239f0434e217d3ad2a7a3d9f9e6" translate="yes" xml:space="preserve">
          <source>The nested document will be filtered because the main file is named &lt;code&gt;application-dev.yml&lt;/code&gt;. It is already considered to be profile-specific, and nested documents will be ignored.</source>
          <target state="translated">기본 파일의 이름이 &lt;code&gt;application-dev.yml&lt;/code&gt; 이므로 중첩 된 문서가 필터링됩니다 . 이미 프로필에 특정한 것으로 간주되며 중첩 된 문서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4798fe7b532be5d748b7e3bf9f32ed914aeccfaf" translate="yes" xml:space="preserve">
          <source>The next section goes on to cover the &lt;em&gt;&lt;a href=&quot;spring-boot-cli#cli&quot;&gt;Spring Boot CLI&lt;/a&gt;&lt;/em&gt;, or you can jump ahead to read about &lt;em&gt;&lt;a href=&quot;build-tool-plugins#build-tool-plugins&quot;&gt;build tool plugins&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">다음 섹션에서는 &lt;em&gt;&lt;a href=&quot;spring-boot-cli#cli&quot;&gt;Spring Boot CLI&lt;/a&gt;&lt;/em&gt; 를 다루 거나 &lt;em&gt;&lt;a href=&quot;build-tool-plugins#build-tool-plugins&quot;&gt;빌드 도구 플러그인&lt;/a&gt;&lt;/em&gt; 에 대해 읽을 수 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2e710c9eb75bc0a71fde101a044467cce3c91bcf" translate="yes" xml:space="preserve">
          <source>The next step is to update your build configuration such that your project produces a war file rather than a jar file. If you use Maven and &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; (which configures Maven&amp;rsquo;s war plugin for you), all you need to do is to modify &lt;code&gt;pom.xml&lt;/code&gt; to change the packaging to war, as follows:</source>
          <target state="translated">다음 단계는 프로젝트가 jar 파일이 아닌 war 파일을 생성하도록 빌드 구성을 업데이트하는 것입니다. Maven 및 &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; (Maven의 war 플러그인 구성) 를 사용하는 경우 다음과 같이 &lt;code&gt;pom.xml&lt;/code&gt; 을 수정 하여 패키징을 war로 변경하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="0b6d566a00d163af4d8e684c102288eb351995c8" translate="yes" xml:space="preserve">
          <source>The number of days to keep log archives (defaults to 7)</source>
          <target state="translated">로그 아카이브 보관 일수 (기본값 : 7)</target>
        </trans-unit>
        <trans-unit id="81c47ab31d5d3bea0142dd81dc73c2f456c36fba" translate="yes" xml:space="preserve">
          <source>The official Java &quot;Low Level&quot; and &quot;High Level&quot; REST clients</source>
          <target state="translated">공식 Java &quot;Low Level&quot;및 &quot;High Level&quot;REST 클라이언트</target>
        </trans-unit>
        <trans-unit id="9e41aadf94f071ec541a9bf5e33630f6269664c2" translate="yes" xml:space="preserve">
          <source>The order of common tags is important if you are using Graphite. As the order of common tags cannot be guaranteed using this approach, Graphite users are advised to define a custom &lt;code&gt;MeterFilter&lt;/code&gt; instead.</source>
          <target state="translated">Graphite를 사용하는 경우 공통 태그의 순서가 중요합니다. 이 접근 방식을 사용하면 공통 태그의 순서를 보장 할 수 없으므로 Graphite 사용자는 대신 사용자 지정 &lt;code&gt;MeterFilter&lt;/code&gt; 를 정의하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6424d8ae13909b648555e066be4368a2e32eb9d7" translate="yes" xml:space="preserve">
          <source>The parameters passed to endpoint operation methods are, if necessary, automatically converted to the required type. Before calling an operation method, the input received via JMX or an HTTP request is converted to the required types using an instance of &lt;code&gt;ApplicationConversionService&lt;/code&gt; as well as any &lt;code&gt;Converter&lt;/code&gt; or &lt;code&gt;GenericConverter&lt;/code&gt; beans qualified with &lt;code&gt;@EndpointConverter&lt;/code&gt;.</source>
          <target state="translated">끝점 작업 메서드에 전달 된 매개 변수는 필요한 경우 자동으로 필요한 유형으로 변환됩니다. 동작 메소드를 호출하기 전에, 입력 JMX 통해 수신 또는 HTTP 요청의 예를 사용하여 필요한 형식으로 변환한다 &lt;code&gt;ApplicationConversionService&lt;/code&gt; 뿐만 아니라 &lt;code&gt;Converter&lt;/code&gt; 또는 &lt;code&gt;GenericConverter&lt;/code&gt; 으로 규정 콩 &lt;code&gt;@EndpointConverter&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="de166803f8828e9185f0257d9f5429ef403dd089" translate="yes" xml:space="preserve">
          <source>The path can be further customized by annotating one or more parameters of the operation method with &lt;code&gt;@Selector&lt;/code&gt;. Such a parameter is added to the path predicate as a path variable. The variable&amp;rsquo;s value is passed into the operation method when the endpoint operation is invoked. If you want to capture all remaining path elements, you can add &lt;code&gt;@Selector(Match=ALL_REMAINING)&lt;/code&gt; to the last parameter and make it a type that is conversion compatible with a &lt;code&gt;String[]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;@Selector&lt;/code&gt; 를 사용하여 작업 메서드의 하나 이상의 매개 변수에 주석을 추가하여 경로를 추가로 사용자 지정할 수 있습니다 . 이러한 매개 변수는 경로 변수로 경로 술어에 추가됩니다. 변수 값은 끝점 작업이 호출 될 때 작업 메서드에 전달됩니다. 나머지 모든 경로 요소를 캡처 하려면 마지막 매개 변수 에 &lt;code&gt;@Selector(Match=ALL_REMAINING)&lt;/code&gt; 를 추가 하고 &lt;code&gt;String[]&lt;/code&gt; 과 호환되는 변환 유형으로 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aee6d54f4f41ec165d96cb004bf5f868eee0382d" translate="yes" xml:space="preserve">
          <source>The path of the predicate is determined by the ID of the endpoint and the base path of web-exposed endpoints. The default base path is &lt;code&gt;/actuator&lt;/code&gt;. For example, an endpoint with the ID &lt;code&gt;sessions&lt;/code&gt; will use &lt;code&gt;/actuator/sessions&lt;/code&gt; as its path in the predicate.</source>
          <target state="translated">조건 자의 경로는 엔드 포인트의 ID와 웹에 노출 된 엔드 포인트의 기본 경로에 의해 결정됩니다. 기본 기본 경로는 &lt;code&gt;/actuator&lt;/code&gt; 입니다. 예를 들어 &lt;code&gt;sessions&lt;/code&gt; ID가있는 엔드 포인트 는 술어의 경로로 &lt;code&gt;/actuator/sessions&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="f0656ecd9796e4da1fb5968bc7247045b64c27a4" translate="yes" xml:space="preserve">
          <source>The patterns to use can be customized using the &lt;code&gt;management.endpoint.env.keys-to-sanitize&lt;/code&gt; and &lt;code&gt;management.endpoint.configprops.keys-to-sanitize&lt;/code&gt; respectively.</source>
          <target state="translated">사용할 패턴은 각각 &lt;code&gt;management.endpoint.env.keys-to-sanitize&lt;/code&gt; 및 &lt;code&gt;management.endpoint.configprops.keys-to-sanitize&lt;/code&gt; 를 사용하여 사용자 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a938c63848f47959aa084e1ab0739dd5ded55bb8" translate="yes" xml:space="preserve">
          <source>The port of the proxy to use to connect to the remote application.</source>
          <target state="translated">원격 애플리케이션에 연결하는 데 사용할 프록시 포트입니다.</target>
        </trans-unit>
        <trans-unit id="2be111a430ebda2afbf8aa01b8648d671e99e3d9" translate="yes" xml:space="preserve">
          <source>The port that Mongo listens on can be configured by setting the &lt;code&gt;spring.data.mongodb.port&lt;/code&gt; property. To use a randomly allocated free port, use a value of 0. The &lt;code&gt;MongoClient&lt;/code&gt; created by &lt;code&gt;MongoAutoConfiguration&lt;/code&gt; is automatically configured to use the randomly allocated port.</source>
          <target state="translated">Mongo가 수신하는 포트는 &lt;code&gt;spring.data.mongodb.port&lt;/code&gt; 속성 을 설정하여 구성 할 수 있습니다 . 임의로 할당 된 사용 가능한 포트를 사용하려면 0 값을 사용하십시오. &lt;code&gt;MongoClient&lt;/code&gt; 에 의해 생성 된 &lt;code&gt;MongoAutoConfiguration&lt;/code&gt; 는 임의로 할당 된 포트를 사용하도록 자동 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="31bbbe629b4580086b36804afdbfae5a18fc5f8b" translate="yes" xml:space="preserve">
          <source>The preceding &lt;code&gt;application.properties&lt;/code&gt; example changes the endpoint from &lt;code&gt;/actuator/{id}&lt;/code&gt; to &lt;code&gt;/manage/{id}&lt;/code&gt; (for example, &lt;code&gt;/manage/info&lt;/code&gt;).</source>
          <target state="translated">앞의 &lt;code&gt;application.properties&lt;/code&gt; 예제는 엔드 포인트를 &lt;code&gt;/actuator/{id}&lt;/code&gt; 에서 &lt;code&gt;/manage/{id}&lt;/code&gt; (예 : &lt;code&gt;/manage/info&lt;/code&gt; )로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="6eb7413ccbb011fcd8d2bce01f9810452986a454" translate="yes" xml:space="preserve">
          <source>The preceding POJO defines the following properties:</source>
          <target state="translated">앞의 POJO는 다음 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="905efa58745dc4094344d0271e5aa54cce0d071c" translate="yes" xml:space="preserve">
          <source>The preceding code makes sure that the deprecated property still works (delegating to the &lt;code&gt;name&lt;/code&gt; property behind the scenes). Once the &lt;code&gt;getTarget&lt;/code&gt; and &lt;code&gt;setTarget&lt;/code&gt; methods can be removed from your public API, the automatic deprecation hint in the metadata goes away as well. If you want to keep a hint, adding manual metadata with an &lt;code&gt;error&lt;/code&gt; deprecation level ensures that users are still informed about that property. Doing so is particularly useful when a &lt;code&gt;replacement&lt;/code&gt; is provided.</source>
          <target state="translated">앞의 코드는 deprecated 속성이 여전히 작동하는지 확인합니다 ( 배후에서 &lt;code&gt;name&lt;/code&gt; 속성에 위임 ). 한 번 &lt;code&gt;getTarget&lt;/code&gt; 및 &lt;code&gt;setTarget&lt;/code&gt; 방법이 공개 API에서 제거 할 수 있습니다, 메타 데이터의 자동 중단 힌트도 사라집니다. 힌트를 유지하려는 경우 &lt;code&gt;error&lt;/code&gt; 지원 중단 수준으로 수동 메타 데이터를 추가 하면 사용자에게 해당 속성에 대한 정보가 계속 제공됩니다. 이렇게하면 &lt;code&gt;replacement&lt;/code&gt; 가 제공 될 때 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="659caa5023b0513ddd625afbcda89818257e5802" translate="yes" xml:space="preserve">
          <source>The preceding declaration picks up &lt;code&gt;custom-bom-1.0.0.pom&lt;/code&gt; in a Maven repository under &lt;code&gt;com/example/custom-versions/1.0.0/&lt;/code&gt;.</source>
          <target state="translated">위의 선언 은 &lt;code&gt;com/example/custom-versions/1.0.0/&lt;/code&gt; 아래의 Maven 저장소에서 &lt;code&gt;custom-bom-1.0.0.pom&lt;/code&gt; 을 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="e1906575c82396ad87a059ae736a882ec717aa72" translate="yes" xml:space="preserve">
          <source>The preceding example YAML corresponds to the following &lt;code&gt;application.properties&lt;/code&gt; file:</source>
          <target state="translated">앞의 YAML 예제는 다음 &lt;code&gt;application.properties&lt;/code&gt; 파일에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="b1c02e2d91aa6ff81dae9e4761c967e22a489a83" translate="yes" xml:space="preserve">
          <source>The preceding example configures two data sources on custom namespaces with the same logic as Spring Boot would use in auto-configuration. Note that each &lt;code&gt;configuration&lt;/code&gt; sub namespace provides advanced settings based on the chosen implementation.</source>
          <target state="translated">앞의 예제는 Spring Boot가 자동 구성에서 사용하는 것과 동일한 로직으로 사용자 정의 네임 스페이스에 두 개의 데이터 소스를 구성합니다. 각 &lt;code&gt;configuration&lt;/code&gt; 하위 네임 스페이스는 선택한 구현을 기반으로 고급 설정을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f53bde56dc68fd45bf0e75abd87fa42843ae2ec8" translate="yes" xml:space="preserve">
          <source>The preceding example creates a &lt;code&gt;my-project&lt;/code&gt; directory with a Maven-based project that uses &lt;code&gt;spring-boot-starter-web&lt;/code&gt; and &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt;. You can list the capabilities of the service by using the &lt;code&gt;--list&lt;/code&gt; flag, as shown in the following example:</source>
          <target state="translated">앞의 예제 는 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 및 &lt;code&gt;spring-boot-starter-data-jpa&lt;/code&gt; 를 사용하는 Maven 기반 프로젝트 로 &lt;code&gt;my-project&lt;/code&gt; 디렉토리 를 생성합니다 . 다음 예와 같이 &lt;code&gt;--list&lt;/code&gt; 플래그 를 사용하여 서비스의 기능을 나열 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eed0faed14835655e955c1af347f383f8f1c6381" translate="yes" xml:space="preserve">
          <source>The preceding example indicates that the dependency management in &lt;code&gt;another-bom&lt;/code&gt; overrides the dependency management in &lt;code&gt;custom-bom&lt;/code&gt;.</source>
          <target state="translated">앞의 예제는 &lt;code&gt;another-bom&lt;/code&gt; 의 종속성 관리가 &lt;code&gt;custom-bom&lt;/code&gt; 의 종속성 관리를 재정의 함을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="293fe6f7ff3290e7d1db3c998f27c59b147c1d81" translate="yes" xml:space="preserve">
          <source>The preceding example overrides the default factory, and it should be applied to any other factory that your application defines, if any.</source>
          <target state="translated">앞의 예제는 기본 팩토리를 재정의하며 애플리케이션이 정의하는 다른 팩토리 (있는 경우)에 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a9f4de5ac752e76cd1ec66f96406db3f1fad9adf" translate="yes" xml:space="preserve">
          <source>The preceding example produces metadata information for &lt;code&gt;server.name&lt;/code&gt;, &lt;code&gt;server.host.ip&lt;/code&gt;, and &lt;code&gt;server.host.port&lt;/code&gt; properties. You can use the &lt;code&gt;@NestedConfigurationProperty&lt;/code&gt; annotation on a field to indicate that a regular (non-inner) class should be treated as if it were nested.</source>
          <target state="translated">앞의 예제는 &lt;code&gt;server.name&lt;/code&gt; , &lt;code&gt;server.host.ip&lt;/code&gt; 및 &lt;code&gt;server.host.port&lt;/code&gt; 속성에 대한 메타 데이터 정보를 생성 합니다. 필드에 &lt;code&gt;@NestedConfigurationProperty&lt;/code&gt; 주석을 사용하여 일반 (비 내부) 클래스가 중첩 된 것처럼 처리되어야 함을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a9d7540973d81ea773fc24abca3ae038b7aba3f" translate="yes" xml:space="preserve">
          <source>The preceding example shows how &lt;code&gt;A.class&lt;/code&gt; can be found in &lt;code&gt;/BOOT-INF/classes&lt;/code&gt; in &lt;code&gt;myapp.jar&lt;/code&gt; at position &lt;code&gt;0063&lt;/code&gt;. &lt;code&gt;B.class&lt;/code&gt; from the nested jar can actually be found in &lt;code&gt;myapp.jar&lt;/code&gt; at position &lt;code&gt;3452&lt;/code&gt;, and &lt;code&gt;C.class&lt;/code&gt; is at position &lt;code&gt;3980&lt;/code&gt;.</source>
          <target state="translated">앞의 예제는 &lt;code&gt;0063&lt;/code&gt; 위치에 있는 &lt;code&gt;myapp.jar&lt;/code&gt; 의 &lt;code&gt;/BOOT-INF/classes&lt;/code&gt; 에서 &lt;code&gt;A.class&lt;/code&gt; 를 찾을 수있는 방법을 보여줍니다 . 중첩 된 jar의 &lt;code&gt;B.class&lt;/code&gt; 는 실제로 &lt;code&gt;myapp.jar&lt;/code&gt; 위치 &lt;code&gt;3452&lt;/code&gt; 에서 찾을 수 있으며 &lt;code&gt;C.class&lt;/code&gt; 는 위치 &lt;code&gt;3980&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="380deea36257b681e8fa5315768fac1261b41692" translate="yes" xml:space="preserve">
          <source>The preceding example uses &lt;code&gt;EndpointRequest.toAnyEndpoint()&lt;/code&gt; to match a request to any endpoint and then ensures that all have the &lt;code&gt;ENDPOINT_ADMIN&lt;/code&gt; role. Several other matcher methods are also available on &lt;code&gt;EndpointRequest&lt;/code&gt;. See the API documentation (&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/htmlsingle&quot;&gt;HTML&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf&quot;&gt;PDF&lt;/a&gt;) for details.</source>
          <target state="translated">앞의 예제는 &lt;code&gt;EndpointRequest.toAnyEndpoint()&lt;/code&gt; 를 사용 하여 요청을 모든 엔드 포인트와 일치시킨 다음 모두 &lt;code&gt;ENDPOINT_ADMIN&lt;/code&gt; 역할을 갖도록합니다 . &lt;code&gt;EndpointRequest&lt;/code&gt; 에서 몇 가지 다른 매처 메서드도 사용할 수 있습니다 . 자세한 내용은 API 문서 ( &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/htmlsingle&quot;&gt;HTML&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf&quot;&gt;PDF&lt;/a&gt; )를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e48053f9c9713ecfcac3f8649adeef82301168e3" translate="yes" xml:space="preserve">
          <source>The preceding example would be transformed into these properties:</source>
          <target state="translated">앞의 예는 다음 속성으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0e0eb1f5c54643d2fa19f2def26685a64ad325f6" translate="yes" xml:space="preserve">
          <source>The preceding instructions install a local instance of &lt;code&gt;spring&lt;/code&gt; called the &lt;code&gt;dev&lt;/code&gt; instance. It points at your target build location, so every time you rebuild Spring Boot, &lt;code&gt;spring&lt;/code&gt; is up-to-date.</source>
          <target state="translated">앞의 지침 은 &lt;code&gt;dev&lt;/code&gt; 인스턴스 라는 &lt;code&gt;spring&lt;/code&gt; 의 로컬 인스턴스를 설치 합니다. 대상 빌드 위치를 가리 키므로 Spring Boot를 다시 빌드 할 때마다 &lt;code&gt;spring&lt;/code&gt; 이 최신 상태입니다.</target>
        </trans-unit>
        <trans-unit id="3bde5228723f5160afe6f3494a7a6a16fc8a6b87" translate="yes" xml:space="preserve">
          <source>The preceding listing should give you a working build. You can test it by running &lt;code&gt;mvn package&lt;/code&gt; (for now, you can ignore the &amp;ldquo;jar will be empty - no content was marked for inclusion!&amp;rdquo; warning).</source>
          <target state="translated">이전 목록은 작동하는 빌드를 제공해야합니다. &lt;code&gt;mvn package&lt;/code&gt; 를 실행하여 테스트 할 수 있습니다 (지금은 &quot;jar이 비어 있습니다-포함 할 내용이 표시되지 않았습니다!&quot;경고를 무시할 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="b71732935d22ec0a4e4fce1e7874cac908e82e99" translate="yes" xml:space="preserve">
          <source>The preceding merging rules apply to properties from all property sources, and not just files.</source>
          <target state="translated">앞의 병합 규칙은 파일뿐만 아니라 모든 속성 소스의 속성에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="055e5f209ecb4098348753f5eb40f747b659a2a3" translate="yes" xml:space="preserve">
          <source>The prefix &lt;code&gt;management.endpoint.&amp;lt;name&amp;gt;&lt;/code&gt; is used to uniquely identify the endpoint that is being configured.</source>
          <target state="translated">접두사 &lt;code&gt;management.endpoint.&amp;lt;name&amp;gt;&lt;/code&gt; 은 구성중인 엔드 포인트를 고유하게 식별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65313e493e0783aeb283e0bb4e6755a707889e75" translate="yes" xml:space="preserve">
          <source>The presence of a &lt;code&gt;com.hazelcast.client.config.ClientConfig&lt;/code&gt; bean.</source>
          <target state="translated">a의 존재 &lt;code&gt;com.hazelcast.client.config.ClientConfig&lt;/code&gt; 의 콩.</target>
        </trans-unit>
        <trans-unit id="a2369f57e3bcf0e90e80c3eb3cd7afbbce955195" translate="yes" xml:space="preserve">
          <source>The presence of the &lt;code&gt;hazelcast.client.config&lt;/code&gt; system property.</source>
          <target state="translated">의 존재 &lt;code&gt;hazelcast.client.config&lt;/code&gt; 의 시스템 속성입니다.</target>
        </trans-unit>
        <trans-unit id="c356da4bdfc89eb196020056f14c74f9b9f8bb6a" translate="yes" xml:space="preserve">
          <source>The previous sections covered already many common use cases, such as compression, SSL or HTTP/2. However, if a configuration key doesn&amp;rsquo;t exist for your use case, you should then look at &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/web/server/WebServerFactoryCustomizer.html&quot;&gt;&lt;code&gt;WebServerFactoryCustomizer&lt;/code&gt;&lt;/a&gt;. You can declare such a component and get access to the server factory relevant to your choice: you should select the variant for the chosen Server (Tomcat, Jetty, Reactor Netty, Undertow) and the chosen web stack (Servlet or Reactive).</source>
          <target state="translated">이전 섹션에서는 압축, SSL 또는 HTTP / 2와 같은 많은 일반적인 사용 사례를 이미 다루었습니다. 그러나 사용 사례에 대한 구성 키가 없으면 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/web/server/WebServerFactoryCustomizer.html&quot;&gt; &lt;code&gt;WebServerFactoryCustomizer&lt;/code&gt; &lt;/a&gt; 를 확인해야합니다 . 이러한 구성 요소를 선언하고 선택한 서버 팩토리에 액세스 할 수 있습니다. 선택한 서버 (Tomcat, Jetty, Reactor Netty, Undertow) 및 선택한 웹 스택 (Servlet 또는 Reactive)에 대한 변형을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e999ec85a88ce16af514595f6f9d4a07964f533" translate="yes" xml:space="preserve">
          <source>The printed banner is registered as a singleton bean under the following name: &lt;code&gt;springBootBanner&lt;/code&gt;.</source>
          <target state="translated">인쇄 된 배너는 &lt;code&gt;springBootBanner&lt;/code&gt; 라는 이름으로 싱글 톤 빈으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e31f636f65fde44dee505a31a4128f9378a0df1" translate="yes" xml:space="preserve">
          <source>The processor picks up both classes and methods that are annotated with &lt;code&gt;@ConfigurationProperties&lt;/code&gt;.</source>
          <target state="translated">프로세서는 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 주석이 달린 클래스와 메서드를 모두 선택합니다 .</target>
        </trans-unit>
        <trans-unit id="71c7406518e18d7f4ccecf0c0f1386f2a29c76c7" translate="yes" xml:space="preserve">
          <source>The produces clause of the predicate can be determined by the &lt;code&gt;produces&lt;/code&gt; attribute of the &lt;code&gt;@DeleteOperation&lt;/code&gt;, &lt;code&gt;@ReadOperation&lt;/code&gt;, and &lt;code&gt;@WriteOperation&lt;/code&gt; annotations. The attribute is optional. If it is not used, the produces clause is determined automatically.</source>
          <target state="translated">술어의 생성 절은 &lt;code&gt;@DeleteOperation&lt;/code&gt; , &lt;code&gt;@ReadOperation&lt;/code&gt; 및 &lt;code&gt;@WriteOperation&lt;/code&gt; 주석 의 &lt;code&gt;produces&lt;/code&gt; 속성에 의해 판별 될 수 있습니다 . 속성은 선택 사항입니다. 사용하지 않으면 생성 절이 자동으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d6b5f03d894005db4a13da96a2f187decd8ec8f" translate="yes" xml:space="preserve">
          <source>The properties above will bind to a &lt;code&gt;Map&lt;/code&gt; with &lt;code&gt;/key1&lt;/code&gt;, &lt;code&gt;/key2&lt;/code&gt; and &lt;code&gt;key3&lt;/code&gt; as the keys in the map.</source>
          <target state="translated">A와 의지 바인드 위의 속성 &lt;code&gt;Map&lt;/code&gt; 와 &lt;code&gt;/key1&lt;/code&gt; , &lt;code&gt;/key2&lt;/code&gt; 및 &lt;code&gt;key3&lt;/code&gt; 맵의 키와.</target>
        </trans-unit>
        <trans-unit id="9e3a58aa470931e890d7b620f962bb5d4b663321" translate="yes" xml:space="preserve">
          <source>The properties supported by auto configuration are shown in &lt;a href=&quot;appendix-application-properties#common-application-properties&quot;&gt;appendix-application-properties.html&lt;/a&gt;. Note that, for the most part, these properties (hyphenated or camelCase) map directly to the Apache Kafka dotted properties. Refer to the Apache Kafka documentation for details.</source>
          <target state="translated">자동 구성에서 지원하는 속성은 &lt;a href=&quot;appendix-application-properties#common-application-properties&quot;&gt;appendix-application-properties.html에 나와&lt;/a&gt; 있습니다. 대부분의 경우 이러한 속성 (하이픈 또는 camelCase)은 Apache Kafka 점 속성에 직접 매핑됩니다. 자세한 내용은 Apache Kafka 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ab17d3961622920fac81713de1cefca70efbc9c0" translate="yes" xml:space="preserve">
          <source>The properties that map to &lt;code&gt;@ConfigurationProperties&lt;/code&gt; classes available in Spring Boot, which are configured via properties files, YAML files, environment variables etc., are public API but the accessors (getters/setters) of the class itself are not meant to be used directly.</source>
          <target state="translated">속성 파일, YAML 파일, 환경 변수 등을 통해 구성되는 Spring Boot에서 사용할 수있는 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 클래스에 매핑 되는 속성은 공용 API이지만 클래스 자체의 접근 자 (게터 / 세터)는 직접 사용하기위한 것이 아닙니다. .</target>
        </trans-unit>
        <trans-unit id="aeafe5b2bb58e54c0334ddd97d42f057d24a0d07" translate="yes" xml:space="preserve">
          <source>The reactive auto-configuration replaces the need to use &lt;code&gt;@Enable*WebSession&lt;/code&gt;.</source>
          <target state="translated">반응 형 자동 구성은 &lt;code&gt;@Enable*WebSession&lt;/code&gt; 을 사용해야하는 필요성을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="46373140b6dc5df3d963805651a3df0796837afe" translate="yes" xml:space="preserve">
          <source>The recommended path is through the starters, even though it requires some jiggling. The following example shows how to set up the starters in Maven:</source>
          <target state="translated">권장 경로는 약간의 흔들림이 필요하지만 스타터를 통과하는 것입니다. 다음 예제는 Maven에서 스타터를 설정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2bf959309e331983c06e2803cb240b60d148f048" translate="yes" xml:space="preserve">
          <source>The reference documentation consists of the following sections:</source>
          <target state="translated">참조 문서는 다음 섹션으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e95079408983727ba0a56d1ae2639fa11c83aa06" translate="yes" xml:space="preserve">
          <source>The reference documentation has the following appendices:</source>
          <target state="translated">참조 문서에는 다음과 같은 부록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4edc275311b64c47aba2380542aad967eb05c3fe" translate="yes" xml:space="preserve">
          <source>The remote client application is designed to be run from within your IDE. You need to run &lt;code&gt;org.springframework.boot.devtools.RemoteSpringApplication&lt;/code&gt; with the same classpath as the remote project that you connect to. The application&amp;rsquo;s single required argument is the remote URL to which it connects.</source>
          <target state="translated">원격 클라이언트 애플리케이션은 IDE 내에서 실행되도록 설계되었습니다. 연결하는 원격 프로젝트와 동일한 클래스 경로로 &lt;code&gt;org.springframework.boot.devtools.RemoteSpringApplication&lt;/code&gt; 을 실행해야 합니다. 애플리케이션의 단일 필수 인수는 연결되는 원격 URL입니다.</target>
        </trans-unit>
        <trans-unit id="6ee5714e6591b3eb48576dde612e181494c452fc" translate="yes" xml:space="preserve">
          <source>The remote client monitors your application classpath for changes in the same way as the &lt;a href=&quot;#using-boot-devtools-restart&quot;&gt;local restart&lt;/a&gt;. Any updated resource is pushed to the remote application and (&lt;em&gt;if required&lt;/em&gt;) triggers a restart. This can be helpful if you iterate on a feature that uses a cloud service that you do not have locally. Generally, remote updates and restarts are much quicker than a full rebuild and deploy cycle.</source>
          <target state="translated">원격 클라이언트는 &lt;a href=&quot;#using-boot-devtools-restart&quot;&gt;로컬 재시작&lt;/a&gt; 과 같은 방식으로 변경 사항에 대해 응용 프로그램 클래스 경로를 모니터링합니다 . 업데이트 된 리소스는 원격 애플리케이션으로 푸시되고 &lt;em&gt;필요한 경우&lt;/em&gt; 다시 시작을 트리거합니다. 이는 로컬에없는 클라우드 서비스를 사용하는 기능을 반복하는 경우 유용 할 수 있습니다. 일반적으로 원격 업데이트 및 재시작은 전체 재 구축 및 배포주기보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="05c45da3de98bec33e3dc20a9efb2627c562a78a" translate="yes" xml:space="preserve">
          <source>The replication factor for change log topics and repartition topics created by the stream processing application.</source>
          <target state="translated">스트림 처리 애플리케이션에서 생성 한 변경 로그 항목 및 재 파티션 항목에 대한 복제 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ff2f0d5eda0e910a90dcfd6626585b3587004c26" translate="yes" xml:space="preserve">
          <source>The reported measurements are the &lt;em&gt;sum&lt;/em&gt; of the statistics of all meters matching the meter name and any tags that have been applied. So in the example above, the returned &quot;Value&quot; statistic is the sum of the maximum memory footprints of &quot;Code Cache&quot;, &quot;Compressed Class Space&quot;, and &quot;Metaspace&quot; areas of the heap. If you only wanted to see the maximum size for the &quot;Metaspace&quot;, you could add an additional &lt;code&gt;tag=id:Metaspace&lt;/code&gt;, i.e. &lt;code&gt;/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;amp;tag=id:Metaspace&lt;/code&gt;.</source>
          <target state="translated">보고 된 측정은 미터 이름과 일치하는 모든 미터의 통계 및 적용된 태그 의 &lt;em&gt;합계&lt;/em&gt; 입니다. 따라서 위의 예에서 반환 된 &quot;Value&quot;통계는 힙의 &quot;Code Cache&quot;, &quot;Compressed Class Space&quot;및 &quot;Metaspace&quot;영역의 최대 메모리 풋 프린트의 합계입니다. &quot;Metaspace&quot;의 최대 크기 만보고 싶다면 &lt;code&gt;tag=id:Metaspace&lt;/code&gt; , 즉 &lt;code&gt;/actuator/metrics/jvm.memory.max?tag=area:nonheap&amp;amp;tag=id:Metaspace&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5724023abab4c13a053844fc4ce12297e4512ef7" translate="yes" xml:space="preserve">
          <source>The restart technology provided by Spring Boot works by using two classloaders. Classes that do not change (for example, those from third-party jars) are loaded into a &lt;em&gt;base&lt;/em&gt; classloader. Classes that you are actively developing are loaded into a &lt;em&gt;restart&lt;/em&gt; classloader. When the application is restarted, the &lt;em&gt;restart&lt;/em&gt; classloader is thrown away and a new one is created. This approach means that application restarts are typically much faster than &amp;ldquo;cold starts&amp;rdquo;, since the &lt;em&gt;base&lt;/em&gt; classloader is already available and populated.</source>
          <target state="translated">Spring Boot에서 제공하는 재시작 기술은 두 개의 클래스 로더를 사용하여 작동합니다. 변경되지 않는 클래스 (예 : 타사 jar의 클래스 )는 &lt;em&gt;기본&lt;/em&gt; 클래스 로더에로드됩니다. 현재 개발중인 클래스 는 &lt;em&gt;다시 시작&lt;/em&gt; 클래스 로더에로드됩니다. 애플리케이션이 다시 시작되면 &lt;em&gt;다시 시작&lt;/em&gt; 클래스 로더가 폐기되고 새 클래스 로더가 작성됩니다. 이 접근 방식은 &lt;em&gt;기본&lt;/em&gt; 클래스 로더가 이미 사용 가능하고 채워져 있기 때문에 응용 프로그램 다시 시작이 일반적으로 &quot;콜드 시작&quot;보다 훨씬 빠르다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="da51f2668f485ab823ebb5ca1e57cc1aac59c885" translate="yes" xml:space="preserve">
          <source>The resulting jar contains the classes produced by compiling the application and all of the application&amp;rsquo;s dependencies so that it can then be run by using &lt;code&gt;java -jar&lt;/code&gt;. The jar file also contains entries from the application&amp;rsquo;s classpath. You can add and remove explicit paths to the jar by using &lt;code&gt;--include&lt;/code&gt; and &lt;code&gt;--exclude&lt;/code&gt;. Both are comma-separated, and both accept prefixes, in the form of &amp;ldquo;+&amp;rdquo; and &amp;ldquo;-&amp;rdquo;, to signify that they should be removed from the defaults. The default includes are as follows:</source>
          <target state="translated">결과 jar에는 응용 프로그램을 컴파일하여 생성 된 클래스와 응용 프로그램의 모든 종속성이 포함되므로 &lt;code&gt;java -jar&lt;/code&gt; 을 사용하여 실행할 수 있습니다 . jar 파일에는 애플리케이션 클래스 경로의 항목도 포함됩니다. &lt;code&gt;--include&lt;/code&gt; 및 &lt;code&gt;--exclude&lt;/code&gt; 를 사용하여 jar에 대한 명시 적 경로를 추가하고 제거 할 수 있습니다 . 둘 다 쉼표로 구분되며 둘 다 &quot;+&quot;및 &quot;-&quot;형식의 접두사를 허용하여 기본값에서 제거해야 함을 나타냅니다. 기본 포함은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6ab74c78499e6ae245986c3f7cf71ebf88816ae" translate="yes" xml:space="preserve">
          <source>The root directory of Java class files</source>
          <target state="translated">Java 클래스 파일의 루트 디렉토리</target>
        </trans-unit>
        <trans-unit id="8a913686039b3b4682e4ce7f04b2c4236e932082" translate="yes" xml:space="preserve">
          <source>The root name of the pid folder (&lt;code&gt;/var/run&lt;/code&gt; by default).</source>
          <target state="translated">pid 폴더의 루트 이름 ( 기본적으로 &lt;code&gt;/var/run&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6063d56acda1431d186500ef6658afac24c3a1de" translate="yes" xml:space="preserve">
          <source>The runner can also be used to display the &lt;code&gt;ConditionEvaluationReport&lt;/code&gt;. The report can be printed at &lt;code&gt;INFO&lt;/code&gt; or &lt;code&gt;DEBUG&lt;/code&gt; level. The following example shows how to use the &lt;code&gt;ConditionEvaluationReportLoggingListener&lt;/code&gt; to print the report in auto-configuration tests.</source>
          <target state="translated">러너를 사용하여 &lt;code&gt;ConditionEvaluationReport&lt;/code&gt; 를 표시 할 수도 있습니다 . 보고서는 &lt;code&gt;INFO&lt;/code&gt; 또는 &lt;code&gt;DEBUG&lt;/code&gt; 수준 에서 인쇄 할 수 있습니다 . 다음 예제는 &lt;code&gt;ConditionEvaluationReportLoggingListener&lt;/code&gt; 를 사용하여 자동 구성 테스트에서 보고서를 인쇄하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="fdefdeb606fd8e2103769c19124ef50d3f866db5" translate="yes" xml:space="preserve">
          <source>The same JSON can also be provided as a system property:</source>
          <target state="translated">동일한 JSON을 시스템 속성으로 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="168a430d6f663c315f6c5f56c0aa88991305dfe9" translate="yes" xml:space="preserve">
          <source>The same obstacle and the same features exist for other auto-configured Spring Data repository types (Elasticsearch, Solr, and others). To work with them, change the names of the annotations and flags accordingly.</source>
          <target state="translated">다른 자동 구성 스프링 데이터 저장소 유형 (Elasticsearch, Solr 등)에 대해 동일한 장애물과 동일한 기능이 존재합니다. 작업하려면 주석 및 플래그의 이름을 적절히 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5d5bfb755eabcdbe9aebaee8cf0c09e0c0774e0f" translate="yes" xml:space="preserve">
          <source>The same properties are applicable for both servlet and reactive applications.</source>
          <target state="translated">동일한 속성이 서블릿 및 반응 애플리케이션 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c730474fd84a48f2b2ead84f6a28c1587491542" translate="yes" xml:space="preserve">
          <source>The script mode.</source>
          <target state="translated">스크립트 모드.</target>
        </trans-unit>
        <trans-unit id="8949638a2a05ffe95800562a9365b290276e0ffe" translate="yes" xml:space="preserve">
          <source>The script supports the following features:</source>
          <target state="translated">스크립트는 다음 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="27a47727a0004a9898df6297805d2e651573334e" translate="yes" xml:space="preserve">
          <source>The search algorithm works up from the package that contains the test until it finds a class annotated with &lt;code&gt;@SpringBootApplication&lt;/code&gt; or &lt;code&gt;@SpringBootConfiguration&lt;/code&gt;. As long as you &lt;a href=&quot;using-spring-boot#using-boot-structuring-your-code&quot;&gt;structured your code&lt;/a&gt; in a sensible way, your main configuration is usually found.</source>
          <target state="translated">검색 알고리즘은 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 또는 &lt;code&gt;@SpringBootConfiguration&lt;/code&gt; 주석이 달린 클래스를 찾을 때까지 테스트가 포함 된 패키지에서 작동합니다 . 현명한 방식으로 &lt;a href=&quot;using-spring-boot#using-boot-structuring-your-code&quot;&gt;코드&lt;/a&gt; 를 구조화했다면 일반적으로 기본 구성을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef048ac8f05ec378e2f36747fbed1d6f6321b59" translate="yes" xml:space="preserve">
          <source>The search order for properties (where it makes sense to look in more than one place) is environment variables, system properties, &lt;code&gt;loader.properties&lt;/code&gt;, the exploded archive manifest, and the archive manifest.</source>
          <target state="translated">속성에 대한 검색 순서는 환경 변수, 시스템 속성, &lt;code&gt;loader.properties&lt;/code&gt; , 분해 된 아카이브 매니페스트 및 아카이브 매니페스트입니다.</target>
        </trans-unit>
        <trans-unit id="b6312603a7b54c45ee7443c027584abf8c08965e" translate="yes" xml:space="preserve">
          <source>The second class-level annotation is &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt;. This annotation tells Spring Boot to &amp;ldquo;guess&amp;rdquo; how you want to configure Spring, based on the jar dependencies that you have added. Since &lt;code&gt;spring-boot-starter-web&lt;/code&gt; added Tomcat and Spring MVC, the auto-configuration assumes that you are developing a web application and sets up Spring accordingly.</source>
          <target state="translated">두 번째 클래스 수준 주석은 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 입니다. 이 주석은 추가 한 jar 종속성을 기반으로 Spring을 구성하는 방법을 &quot;추측&quot;하도록 Spring Boot에 지시합니다. &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 은 Tomcat과 Spring MVC를 추가 했기 때문에 자동 구성은 웹 애플리케이션을 개발 중이라고 가정하고 그에 따라 Spring을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5f1fdf3ab80e4fd38aa7691c4749d381b8f91feb" translate="yes" xml:space="preserve">
          <source>The spec to use to create caches. See CaffeineSpec for more details on the spec format.</source>
          <target state="translated">캐시를 만드는 데 사용할 사양입니다. 사양 형식에 대한 자세한 내용은 CaffeineSpec을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="6b040e673e6ea91497941fb691f0dd3de3dce750" translate="yes" xml:space="preserve">
          <source>The special &lt;strong&gt;any&lt;/strong&gt; provider value permits any additional values to be provided. Regular value validation based on the property type should be applied if this is supported.</source>
          <target state="translated">특별한 &lt;strong&gt;any&lt;/strong&gt; provider 값은 추가 값을 제공 할 수 있도록 허용합니다. 지원되는 경우 속성 유형을 기반으로하는 정규 값 유효성 검사를 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ee4e62e24d83e6159af003e9a9637144aff6d7e" translate="yes" xml:space="preserve">
          <source>The specific beans that you want to test should be specified by using the &lt;code&gt;value&lt;/code&gt; or &lt;code&gt;components&lt;/code&gt; attribute of &lt;code&gt;@RestClientTest&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">테스트하려는 특정 Bean 은 다음 예에 표시된대로 &lt;code&gt;@RestClientTest&lt;/code&gt; 의 &lt;code&gt;value&lt;/code&gt; 또는 &lt;code&gt;components&lt;/code&gt; 속성을 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="624aaade1857f7a5b59667c78133eb24ef9ab303" translate="yes" xml:space="preserve">
          <source>The standard ISO-8601 format &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-&quot;&gt;used by &lt;code&gt;java.time.Duration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Duration.html#parse-java.lang.CharSequence-&quot;&gt; &lt;code&gt;java.time.Duration&lt;/code&gt; 에서&lt;/a&gt; 사용하는 표준 ISO-8601 형식</target>
        </trans-unit>
        <trans-unit id="ed31ee8401c6a76eca5a62c0884f080d42485bbb" translate="yes" xml:space="preserve">
          <source>The standard ISO-8601 format &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#parse-java.lang.CharSequence-&quot;&gt;used by &lt;code&gt;java.time.Period&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/time/Period.html#parse-java.lang.CharSequence-&quot;&gt; &lt;code&gt;java.time.Period&lt;/code&gt; 에서&lt;/a&gt; 사용하는 표준 ISO-8601 형식</target>
        </trans-unit>
        <trans-unit id="5dc4f420111ffb67b2bd0a0627ff1f97280682bd" translate="yes" xml:space="preserve">
          <source>The starter is really an empty jar. Its only purpose is to provide the necessary dependencies to work with the library. You can think of it as an opinionated view of what is required to get started.</source>
          <target state="translated">스타터는 정말 빈 병입니다. 유일한 목적은 라이브러리 작업에 필요한 종속성을 제공하는 것입니다. 시작하는 데 필요한 것이 무엇인지에 대한 독단적 인 견해로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f48e8937e7bbb1ea84a7ac89bdba10dde227307" translate="yes" xml:space="preserve">
          <source>The starters contain a lot of the dependencies that you need to get a project up and running quickly and with a consistent, supported set of managed transitive dependencies.</source>
          <target state="translated">스타터에는 프로젝트를 빠르게 시작하고 실행하는 데 필요한 많은 종속성과 일관되고 지원되는 관리되는 전이 종속성 집합이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d68fc12f2239c1310b5a39d4f522ee78a0badfdc" translate="yes" xml:space="preserve">
          <source>The support of Infinispan in Spring Boot is restricted to the embedded mode and is quite basic. If you want more options, you should use the official Infinispan Spring Boot starter instead. See &lt;a href=&quot;https://github.com/infinispan/infinispan-spring-boot&quot;&gt;Infinispan&amp;rsquo;s documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Spring Boot에서 Infinispan의 지원은 임베디드 모드로 제한되며 매우 기본적입니다. 더 많은 옵션을 원한다면 공식 Infinispan Spring Boot 스타터를 대신 사용해야합니다. 자세한 내용은 &lt;a href=&quot;https://github.com/infinispan/infinispan-spring-boot&quot;&gt;Infinispan의 문서&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="d57205dec187fccf01eb0d37bb7fb6d672da7cb9" translate="yes" xml:space="preserve">
          <source>The thread pool uses 8 core threads that can grow and shrink according to the load. Those default settings can be fine-tuned using the &lt;code&gt;spring.task.execution&lt;/code&gt; namespace as shown in the following example:</source>
          <target state="translated">스레드 풀은로드에 따라 늘어나거나 줄어들 수있는 8 개의 코어 스레드를 사용합니다. 이러한 기본 설정은 다음 예제와 같이 &lt;code&gt;spring.task.execution&lt;/code&gt; 네임 스페이스를 사용하여 미세 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="139d12d3a07428b3d60c8bbc86ddfb25804bd847" translate="yes" xml:space="preserve">
          <source>The time in seconds to wait when stopping the application before forcing a shutdown (&lt;code&gt;60&lt;/code&gt; by default).</source>
          <target state="translated">강제 종료하기 전에 애플리케이션을 중지 할 때 대기하는 시간 (초 )입니다 (기본값 : &lt;code&gt;60&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b4b0a0193660cea56e48cd8e01cd3774554d0171" translate="yes" xml:space="preserve">
          <source>The title of your application, as declared in &lt;code&gt;MANIFEST.MF&lt;/code&gt;. For example &lt;code&gt;Implementation-Title: MyApp&lt;/code&gt; is printed as &lt;code&gt;MyApp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MANIFEST.MF&lt;/code&gt; 에 선언 된 애플리케이션의 제목입니다 . 예를 들어 &lt;code&gt;Implementation-Title: MyApp&lt;/code&gt; 같이 인쇄됩니다 &lt;code&gt;MyApp&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="ff9052cf96a405ee7d1b452dbc9249d22577c874" translate="yes" xml:space="preserve">
          <source>The transaction manager's unique name. Defaults to the machine's IP address. If you plan to run more than one transaction manager against one database you must set this property to a unique value.</source>
          <target state="translated">트랜잭션 관리자의 고유 이름입니다. 기본값은 기기의 IP 주소입니다. 하나의 데이터베이스에 대해 둘 이상의 트랜잭션 관리자를 실행하려면이 속성을 고유 한 값으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="323e3efa0c7ca762ce2e087a296e387fc018a02b" translate="yes" xml:space="preserve">
          <source>The underlying component scan configuration of &lt;code&gt;@SpringBootApplication&lt;/code&gt; defines exclude filters that are used to make sure slicing works as expected. If you are using an explicit &lt;code&gt;@ComponentScan&lt;/code&gt; directive on your &lt;code&gt;@SpringBootApplication&lt;/code&gt;-annotated class, be aware that those filters will be disabled. If you are using slicing, you should define them again.</source>
          <target state="translated">&lt;code&gt;@SpringBootApplication&lt;/code&gt; 의 기본 구성 요소 스캔 구성은 슬라이싱이 예상대로 작동하는지 확인하는 데 사용되는 제외 필터를 정의합니다. &lt;code&gt;@SpringBootApplication&lt;/code&gt; -주석이 달린 클래스 에서 명시적인 &lt;code&gt;@ComponentScan&lt;/code&gt; 지시문을 사용하는 경우 해당 필터가 비활성화됩니다. 슬라이싱을 사용하는 경우 다시 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a9ad7c14f29550703bab05759d80c59dfde5610" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;java.util.Optional&lt;/code&gt; with &lt;code&gt;@ConfigurationProperties&lt;/code&gt; is not recommended as it is primarily intended for use as a return type. As such, it is not well-suited to configuration property injection. For consistency with properties of other types, if you do declare an &lt;code&gt;Optional&lt;/code&gt; property and it has no value, &lt;code&gt;null&lt;/code&gt; rather than an empty &lt;code&gt;Optional&lt;/code&gt; will be bound.</source>
          <target state="translated">&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 와 함께 &lt;code&gt;java.util.Optional&lt;/code&gt; 을 사용 하는 것은 주로 반환 유형으로 사용하기위한 것이므로 권장되지 않습니다. 따라서 구성 속성 주입에는 적합하지 않습니다. 다른 유형의 속성과의 일관성을 위해 &lt;code&gt;Optional&lt;/code&gt; 속성을 선언하고 값이없는 경우 빈 &lt;code&gt;Optional&lt;/code&gt; 이 아닌 &lt;code&gt;null&lt;/code&gt; 이 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3c4d918ea289cd8ae552883b8f0e061da31c8de2" translate="yes" xml:space="preserve">
          <source>The user that will be used to run the application. When not set, the user that owns the jar file will be used.</source>
          <target state="translated">애플리케이션을 실행하는 데 사용할 사용자입니다. 설정하지 않으면 jar 파일을 소유 한 사용자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8fa0eec0536d894dc988517de76d08301476900" translate="yes" xml:space="preserve">
          <source>The values in &lt;code&gt;application.properties&lt;/code&gt; and &lt;code&gt;application.yml&lt;/code&gt; are filtered through the existing &lt;code&gt;Environment&lt;/code&gt; when they are used, so you can refer back to previously defined values (for example, from System properties). The standard &lt;code&gt;${name}&lt;/code&gt; property-placeholder syntax can be used anywhere within a value.</source>
          <target state="translated">&lt;code&gt;application.properties&lt;/code&gt; 및 &lt;code&gt;application.yml&lt;/code&gt; 의 값 은 사용될 때 기존 &lt;code&gt;Environment&lt;/code&gt; 통해 필터링 되므로 이전에 정의 된 값을 다시 참조 할 수 있습니다 (예 : 시스템 속성에서). 표준 &lt;code&gt;${name}&lt;/code&gt; 속성 자리 표시 자 구문은 값 내의 모든 위치에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9190cfa6216bcb27da846cafe96b7eeaa3f4b953" translate="yes" xml:space="preserve">
          <source>The various logging systems can be activated by including the appropriate libraries on the classpath and can be further customized by providing a suitable configuration file in the root of the classpath or in a location specified by the following Spring &lt;code&gt;Environment&lt;/code&gt; property: &lt;code&gt;logging.config&lt;/code&gt;.</source>
          <target state="translated">다양한 로깅 시스템은 클래스 경로에 적절한 라이브러리를 포함하여 활성화 할 수 있으며 클래스 경로의 루트 또는 다음 Spring &lt;code&gt;Environment&lt;/code&gt; 속성에 지정된 위치 ( &lt;code&gt;logging.config&lt;/code&gt; )에 적절한 구성 파일을 제공하여 추가로 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ea9707d293ccf299cb339d44d111146843427af1" translate="yes" xml:space="preserve">
          <source>The version number of your application, as declared in &lt;code&gt;MANIFEST.MF&lt;/code&gt; and formatted for display (surrounded with brackets and prefixed with &lt;code&gt;v&lt;/code&gt;). For example &lt;code&gt;(v1.0)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MANIFEST.MF&lt;/code&gt; 에 선언되고 표시 형식이 지정된 애플리케이션의 버전 번호입니다 (괄호로 묶고 접두사 &lt;code&gt;v&lt;/code&gt; ). 예 : &lt;code&gt;(v1.0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e91b213521b6a64ea8c6dc0164ca179f76d174e" translate="yes" xml:space="preserve">
          <source>The version number of your application, as declared in &lt;code&gt;MANIFEST.MF&lt;/code&gt;. For example, &lt;code&gt;Implementation-Version: 1.0&lt;/code&gt; is printed as &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MANIFEST.MF&lt;/code&gt; 에 선언 된 애플리케이션의 버전 번호입니다 . 예를 들어, &lt;code&gt;Implementation-Version: 1.0&lt;/code&gt; 로 인쇄됩니다 &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5f0752aeec84e6d3c5af5a00d9ae91322fa8c47" translate="yes" xml:space="preserve">
          <source>The version of the Servlet API has been overridden as, unlike Tomcat 9 and Undertow 2.0, Jetty 9.4 does not support Servlet 4.0.</source>
          <target state="translated">Servlet API의 버전은 Tomcat 9 및 Undertow 2.0과 달리 Jetty 9.4가 Servlet 4.0을 지원하지 않기 때문에 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="58a0458eceffaecaf4c599833e34501a0c8b945b" translate="yes" xml:space="preserve">
          <source>Then deploy with &lt;code&gt;mvn appengine:deploy&lt;/code&gt; (if you need to authenticate first, the build fails).</source>
          <target state="translated">그런 다음 &lt;code&gt;mvn appengine:deploy&lt;/code&gt; 를 사용하여 배포합니다 (먼저 인증해야하는 경우 빌드가 실패 함).</target>
        </trans-unit>
        <trans-unit id="989a333b31e0cf5776a6c5f16ef1d1553ecf66ac" translate="yes" xml:space="preserve">
          <source>Then run it from a shell, as follows:</source>
          <target state="translated">그런 다음 다음과 같이 셸에서 실행합니다.</target>
        </trans-unit>
        <trans-unit id="57a05dc94d517aab86621a8e7972896e91e5e20c" translate="yes" xml:space="preserve">
          <source>Then the Spring Boot banner is not printed on startup, and the application is not starting an embedded web server.</source>
          <target state="translated">그러면 Spring Boot 배너가 시작시 인쇄되지 않고 애플리케이션이 임베디드 웹 서버를 시작하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b9325ac9ca277c8064872ad0325431cccfac3cb" translate="yes" xml:space="preserve">
          <source>Then you can use the factory in any &lt;code&gt;@JmsListener&lt;/code&gt;-annotated method as follows:</source>
          <target state="translated">그런 다음 다음과 같이 &lt;code&gt;@JmsListener&lt;/code&gt; 주석이 달린 메서드 에서 팩토리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2377c4d541cda703168e28b29a9d95f9ad14ed" translate="yes" xml:space="preserve">
          <source>Then you can use the factory in any &lt;code&gt;@RabbitListener&lt;/code&gt;-annotated method, as follows:</source>
          <target state="translated">그런 다음 다음과 같이 &lt;code&gt;@RabbitListener&lt;/code&gt; 주석이 달린 메서드 에서 팩토리를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58c53a30c8e030c6abc7314a5b286940396add8c" translate="yes" xml:space="preserve">
          <source>Then you need to set the &lt;code&gt;spring.devtools.remote.secret&lt;/code&gt; property. Like any important password or secret, the value should be unique and strong such that it cannot be guessed or brute-forced.</source>
          <target state="translated">그런 다음 &lt;code&gt;spring.devtools.remote.secret&lt;/code&gt; 속성 을 설정해야 합니다. 중요한 암호 또는 비밀과 마찬가지로 값은 추측하거나 무차별 대입 할 수 없도록 고유하고 강력해야합니다.</target>
        </trans-unit>
        <trans-unit id="384ff344f842b8f0560a95553388cfbf26ccde90" translate="yes" xml:space="preserve">
          <source>Then your &lt;code&gt;trigger-file&lt;/code&gt; property would be:</source>
          <target state="translated">그러면 &lt;code&gt;trigger-file&lt;/code&gt; 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccdfa9227a253a5861f872456e0f4d5fa4d8beab" translate="yes" xml:space="preserve">
          <source>There are a few beans that you can define in your own configuration to override those provided by the auto-configuration:</source>
          <target state="translated">자동 구성에서 제공하는 것을 대체하기 위해 자체 구성에서 정의 할 수있는 몇 가지 Bean이 있습니다.</target>
        </trans-unit>
        <trans-unit id="425abf8c629c289c50cf0ad1ec052005ed1a9a5b" translate="yes" xml:space="preserve">
          <source>There are a lot of logging frameworks available for Java. Do not worry if the above list seems confusing. Generally, you do not need to change your logging dependencies and the Spring Boot defaults work just fine.</source>
          <target state="translated">Java에 사용할 수있는 로깅 프레임 워크가 많이 있습니다. 위 목록이 헷갈 리더라도 걱정하지 마세요. 일반적으로 로깅 종속성을 변경할 필요가 없으며 Spring Boot 기본값이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e8ade31e706a9780e6e6bc8690ff1ecdaf000ec2" translate="yes" xml:space="preserve">
          <source>There are also flags (&lt;code&gt;spring.data.*.repositories.enabled&lt;/code&gt; and &lt;code&gt;spring.data.*.repositories.type&lt;/code&gt;) that you can use to switch the auto-configured repositories on and off in external configuration. Doing so is useful, for instance, in case you want to switch off the Mongo repositories and still use the auto-configured &lt;code&gt;MongoTemplate&lt;/code&gt;.</source>
          <target state="translated">외부 구성에서 자동 구성된 저장소를 켜고 끄는 데 사용할 수있는 플래그 ( &lt;code&gt;spring.data.*.repositories.enabled&lt;/code&gt; 및 &lt;code&gt;spring.data.*.repositories.type&lt;/code&gt; )도 있습니다. 예를 들어 Mongo 리포지토리를 끄고 자동 구성된 &lt;code&gt;MongoTemplate&lt;/code&gt; 을 사용하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="de8a4cfb76232f0ed266f7a57f84db29be0f3c47" translate="yes" xml:space="preserve">
          <source>There are known classloading issues with Java Util Logging that cause problems when running from an 'executable jar'. We recommend that you avoid it when running from an 'executable jar' if at all possible.</source>
          <target state="translated">'실행 가능한 jar'에서 실행할 때 문제를 일으키는 Java Util Logging에 알려진 클래스 로딩 문제가 있습니다. 가능하면 '실행 가능한 jar'에서 실행할 때 피하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ceaec725a4c57314c345ad0f1d94e77aa5f5f694" translate="yes" xml:space="preserve">
          <source>There are other ways to deal with HTTP clients that don&amp;rsquo;t consistently send proper &quot;Accept&quot; request headers. Instead of using suffix matching, we can use a query parameter to ensure that requests like &lt;code&gt;&quot;GET /projects/spring-boot?format=json&quot;&lt;/code&gt; will be mapped to &lt;code&gt;@GetMapping(&quot;/projects/spring-boot&quot;)&lt;/code&gt;:</source>
          <target state="translated">적절한 &quot;Accept&quot;요청 헤더를 일관되게 보내지 않는 HTTP 클라이언트를 처리하는 다른 방법이 있습니다. 접미사 일치를 사용하는 대신 쿼리 매개 변수를 사용하여 &lt;code&gt;&quot;GET /projects/spring-boot?format=json&quot;&lt;/code&gt; 과 같은 요청 이 &lt;code&gt;@GetMapping(&quot;/projects/spring-boot&quot;)&lt;/code&gt; 에 매핑되도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0f87a01efdb08c2ca7aa927d4de704b233ead45" translate="yes" xml:space="preserve">
          <source>There are several options for hot reloading. The recommended approach is to use &lt;a href=&quot;using-spring-boot#using-boot-devtools&quot;&gt;&lt;code&gt;spring-boot-devtools&lt;/code&gt;&lt;/a&gt;, as it provides additional development-time features, such as support for fast application restarts and LiveReload as well as sensible development-time configuration (such as template caching). Devtools works by monitoring the classpath for changes. This means that static resource changes must be &quot;built&quot; for the change to take effect. By default, this happens automatically in Eclipse when you save your changes. In IntelliJ IDEA, the Make Project command triggers the necessary build. Due to the &lt;a href=&quot;using-spring-boot#using-boot-devtools-restart-exclude&quot;&gt;default restart exclusions&lt;/a&gt;, changes to static resources do not trigger a restart of your application. They do, however, trigger a live reload.</source>
          <target state="translated">핫 리로딩에는 몇 가지 옵션이 있습니다. 권장되는 접근 방식은 &lt;a href=&quot;using-spring-boot#using-boot-devtools&quot;&gt; &lt;code&gt;spring-boot-devtools&lt;/code&gt; &lt;/a&gt; 를 사용 하는 것입니다. 빠른 애플리케이션 다시 시작 및 LiveReload 지원과 같은 추가 개발 시간 기능과 합리적인 개발 시간 구성 (예 : 템플릿 캐싱)을 제공하기 때문입니다. Devtools는 변경 사항에 대한 클래스 경로를 모니터링하여 작동합니다. 즉, 변경 사항을 적용하려면 정적 리소스 변경 사항을 &quot;구축&quot;해야합니다. 기본적으로 이는 변경 사항을 저장할 때 Eclipse에서 자동으로 발생합니다. IntelliJ IDEA에서 Make Project 명령은 필요한 빌드를 트리거합니다. &lt;a href=&quot;using-spring-boot#using-boot-devtools-restart-exclude&quot;&gt;기본 다시 시작 제외&lt;/a&gt; 로 인해 정적 리소스를 변경해도 애플리케이션이 다시 시작되지 않습니다. 그러나 라이브 리로드를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="557faa4b4531f554689e50f1bb964199ae699721" translate="yes" xml:space="preserve">
          <source>There are some &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-cli/samples&quot;&gt;sample groovy scripts&lt;/a&gt; available from the GitHub repository that you can use to try out the Spring Boot CLI. There is also extensive Javadoc throughout the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-cli/src/main/java/org/springframework/boot/cli&quot;&gt;source code&lt;/a&gt;.</source>
          <target state="translated">GitHub 저장소에서 사용할 수 있는 몇 가지 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-cli/samples&quot;&gt;샘플 그루비 스크립트를&lt;/a&gt; 사용하여 Spring Boot CLI를 사용해 볼 수 있습니다. &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-cli/src/main/java/org/springframework/boot/cli&quot;&gt;소스 코드&lt;/a&gt; 전체에 걸쳐 광범위한 Javadoc도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="538107ecc74950d032826f75a558da2d873a3ae1" translate="yes" xml:space="preserve">
          <source>There are some restrictions when creating an &lt;code&gt;ApplicationContext&lt;/code&gt; hierarchy. For example, Web components &lt;strong&gt;must&lt;/strong&gt; be contained within the child context, and the same &lt;code&gt;Environment&lt;/code&gt; is used for both parent and child contexts. See the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/builder/SpringApplicationBuilder.html&quot;&gt;&lt;code&gt;SpringApplicationBuilder&lt;/code&gt; Javadoc&lt;/a&gt; for full details.</source>
          <target state="translated">&lt;code&gt;ApplicationContext&lt;/code&gt; 계층을 만들 때 몇 가지 제한 사항이 있습니다 . 예를 들어 웹 구성 요소 &lt;strong&gt;는&lt;/strong&gt; 자식 컨텍스트 내에 포함되어야하며 부모 컨텍스트 와 자식 컨텍스트 모두에 동일한 &lt;code&gt;Environment&lt;/code&gt; 이 사용됩니다. 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/api/org/springframework/boot/builder/SpringApplicationBuilder.html&quot;&gt; &lt;code&gt;SpringApplicationBuilder&lt;/code&gt; Javadoc&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="b2c27f6f090ba9b26d24ad02e691e580906bc8c4" translate="yes" xml:space="preserve">
          <source>There are three launcher subclasses (&lt;code&gt;JarLauncher&lt;/code&gt;, &lt;code&gt;WarLauncher&lt;/code&gt;, and &lt;code&gt;PropertiesLauncher&lt;/code&gt;). Their purpose is to load resources (&lt;code&gt;.class&lt;/code&gt; files and so on) from nested jar files or war files in directories (as opposed to those explicitly on the classpath). In the case of &lt;code&gt;JarLauncher&lt;/code&gt; and &lt;code&gt;WarLauncher&lt;/code&gt;, the nested paths are fixed. &lt;code&gt;JarLauncher&lt;/code&gt; looks in &lt;code&gt;BOOT-INF/lib/&lt;/code&gt;, and &lt;code&gt;WarLauncher&lt;/code&gt; looks in &lt;code&gt;WEB-INF/lib/&lt;/code&gt; and &lt;code&gt;WEB-INF/lib-provided/&lt;/code&gt;. You can add extra jars in those locations if you want more. The &lt;code&gt;PropertiesLauncher&lt;/code&gt; looks in &lt;code&gt;BOOT-INF/lib/&lt;/code&gt; in your application archive by default. You can add additional locations by setting an environment variable called &lt;code&gt;LOADER_PATH&lt;/code&gt; or &lt;code&gt;loader.path&lt;/code&gt; in &lt;code&gt;loader.properties&lt;/code&gt; (which is a comma-separated list of directories, archives, or directories within archives).</source>
          <target state="translated">세 가지 런처 하위 클래스 ( &lt;code&gt;JarLauncher&lt;/code&gt; , &lt;code&gt;WarLauncher&lt;/code&gt; 및 &lt;code&gt;PropertiesLauncher&lt;/code&gt; )가 있습니다. 그들의 목적은 중첩 된 jar 파일 또는 디렉토리의 war 파일에서 리소스 ( &lt;code&gt;.class&lt;/code&gt; 파일 등 )를로드하는 것입니다 ( 클래스 경로에 명시 적으로있는 것과 반대). &lt;code&gt;JarLauncher&lt;/code&gt; 및 &lt;code&gt;WarLauncher&lt;/code&gt; 의 경우 중첩 경로가 고정됩니다. &lt;code&gt;JarLauncher&lt;/code&gt; 는 &lt;code&gt;BOOT-INF/lib/&lt;/code&gt; 에서 &lt;code&gt;WarLauncher&lt;/code&gt; 는 &lt;code&gt;WEB-INF/lib/&lt;/code&gt; 및 &lt;code&gt;WEB-INF/lib-provided/&lt;/code&gt; 에서 찾습니다 . 더 많은 것을 원한다면 그 위치에 여분의 병을 추가 할 수 있습니다. &lt;code&gt;PropertiesLauncher&lt;/code&gt; 의 모습에 &lt;code&gt;BOOT-INF/lib/&lt;/code&gt; 기본적으로 애플리케이션 아카이브의 BOOT-INF / lib / . 당신은라는 환경 변수를 설정하여 추가 위치를 추가 할 수 있습니다 &lt;code&gt;LOADER_PATH&lt;/code&gt; 또는 &lt;code&gt;loader.path&lt;/code&gt; 에 &lt;code&gt;loader.properties&lt;/code&gt; (아카이브 내에서 디렉토리, 아카이브, 또는 디렉토리의 쉼표로 구분 된 목록 인을).</target>
        </trans-unit>
        <trans-unit id="27a0665393b541f06548169da01a06cadb355c70" translate="yes" xml:space="preserve">
          <source>There are three main approaches to &lt;code&gt;RestTemplate&lt;/code&gt; customization, depending on how broadly you want the customizations to apply.</source>
          <target state="translated">사용자 지정을 적용하려는 범위에 따라 &lt;code&gt;RestTemplate&lt;/code&gt; 사용자 지정에 대한 세 가지 주요 접근 방식 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f368e4efabb8490ea532fbe55068854e1de9ba37" translate="yes" xml:space="preserve">
          <source>There are three main approaches to &lt;code&gt;WebClient&lt;/code&gt; customization, depending on how broadly you want the customizations to apply.</source>
          <target state="translated">사용자 지정을 적용하려는 범위에 따라 &lt;code&gt;WebClient&lt;/code&gt; 사용자 지정에 대한 세 가지 주요 접근 방식 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1226d8e7751fd57d5965a5eeb7a27ca0e104cfd" translate="yes" xml:space="preserve">
          <source>There are two common volume mount patterns that can be use:</source>
          <target state="translated">사용할 수있는 두 가지 일반적인 볼륨 마운트 패턴이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8357a4edc615e769472974e0f70ba5355cf5c226" translate="yes" xml:space="preserve">
          <source>There are two ways to customize the underlying &lt;code&gt;javax.cache.cacheManager&lt;/code&gt;:</source>
          <target state="translated">기본 &lt;code&gt;javax.cache.cacheManager&lt;/code&gt; 를 사용자 정의하는 두 가지 방법이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88c30a36fa616a98131ac6657138bbe58b5f5e86" translate="yes" xml:space="preserve">
          <source>There is a &lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt; &amp;ldquo;Starter&amp;rdquo; for collecting the dependencies in a convenient way. By default, it uses &lt;a href=&quot;https://github.com/lettuce-io/lettuce-core/&quot;&gt;Lettuce&lt;/a&gt;. That starter handles both traditional and reactive applications.</source>
          <target state="translated">이있는 &lt;code&gt;spring-boot-starter-data-redis&lt;/code&gt; 편리한 방법으로 종속성을 수집 &quot;초보&quot;를. 기본적으로 &lt;a href=&quot;https://github.com/lettuce-io/lettuce-core/&quot;&gt;Lettuce를&lt;/a&gt; 사용합니다 . 이 스타터는 기존 애플리케이션과 리 액티브 애플리케이션을 모두 처리합니다.</target>
        </trans-unit>
        <trans-unit id="839c5fcc904189d453d4c2904fd18c00ad3f0581" translate="yes" xml:space="preserve">
          <source>There is a really useful &lt;code&gt;ConditionEvaluationReport&lt;/code&gt; available in any Spring Boot &lt;code&gt;ApplicationContext&lt;/code&gt;. You can see it if you enable &lt;code&gt;DEBUG&lt;/code&gt; logging output. If you use the &lt;code&gt;spring-boot-actuator&lt;/code&gt; (see &lt;a href=&quot;production-ready-features#production-ready&quot;&gt;the Actuator chapter&lt;/a&gt;), there is also a &lt;code&gt;conditions&lt;/code&gt; endpoint that renders the report in JSON. Use that endpoint to debug the application and see what features have been added (and which have not been added) by Spring Boot at runtime.</source>
          <target state="translated">Spring Boot &lt;code&gt;ApplicationContext&lt;/code&gt; 에서 사용할 수 있는 정말 유용한 &lt;code&gt;ConditionEvaluationReport&lt;/code&gt; 가 있습니다 . &lt;code&gt;DEBUG&lt;/code&gt; 로깅 출력 을 활성화하면 볼 수 있습니다 . &lt;code&gt;spring-boot-actuator&lt;/code&gt; ( &lt;a href=&quot;production-ready-features#production-ready&quot;&gt;Actuator 장&lt;/a&gt; 참조) 를 사용하는 경우 보고서를 JSON으로 렌더링 하는 &lt;code&gt;conditions&lt;/code&gt; 엔드 포인트 도 있습니다 . 해당 엔드 포인트를 사용하여 애플리케이션을 디버그하고 런타임에 Spring Boot에 의해 추가 된 (그리고 추가되지 않은) 기능을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="45233fe53947bb4ac0476ef247598d4f0c3ee9f2" translate="yes" xml:space="preserve">
          <source>There is no way to set a &lt;code&gt;level&lt;/code&gt;. &lt;code&gt;warning&lt;/code&gt; is always assumed, since code is still handling the property.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 을 설정할 방법이 없습니다 . 코드가 여전히 속성을 처리하고 있기 때문에 &lt;code&gt;warning&lt;/code&gt; 는 항상 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="27d6d6f6096f1cb8bbe0350385f5a004d22d9547" translate="yes" xml:space="preserve">
          <source>These dependencies and plugins are provided by default if one bootstraps a Kotlin project on &lt;a href=&quot;https://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt;.</source>
          <target state="translated">이러한 종속성 및 플러그인은 &lt;a href=&quot;https://start.spring.io/#!language=kotlin&quot;&gt;start.spring.io&lt;/a&gt; 에서 Kotlin 프로젝트를 부트 스트랩하는 경우 기본적으로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7ef323901d758fe1d4facaf098332d6d3fb97aa" translate="yes" xml:space="preserve">
          <source>These health groups are only enabled automatically if the application is &lt;a href=&quot;deployment#cloud-deployment-kubernetes&quot;&gt;running in a Kubernetes environment&lt;/a&gt;. You can enable them in any environment using the &lt;code&gt;management.endpoint.health.probes.enabled&lt;/code&gt; configuration property.</source>
          <target state="translated">이러한 상태 그룹은 애플리케이션이 &lt;a href=&quot;deployment#cloud-deployment-kubernetes&quot;&gt;Kubernetes 환경에서 실행중인&lt;/a&gt; 경우에만 자동으로 활성화됩니다 . &lt;code&gt;management.endpoint.health.probes.enabled&lt;/code&gt; 구성 속성을 사용하여 모든 환경에서 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a59d84acc0ec9d6e5db2bb99bf2624f34436039" translate="yes" xml:space="preserve">
          <source>Third-party jars can offer support for additional technologies (there&amp;rsquo;s no requirement for files to be local). For example, you can imagine config data being from external stores such as Consul, Apache ZooKeeper or Netflix Archaius.</source>
          <target state="translated">타사 jar는 추가 기술에 대한 지원을 제공 할 수 있습니다 (파일이 로컬 일 필요는 없음). 예를 들어 Consul, Apache ZooKeeper 또는 Netflix Archaius와 같은 외부 저장소의 구성 데이터를 상상할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1fc47d650603c07292adc68cc14dc2f7a20728e" translate="yes" xml:space="preserve">
          <source>This appendix contains details of all of the auto-configuration classes provided by Spring Boot, with links to documentation and source code. Remember to also look at the conditions report in your application for more details of which features are switched on. (To do so, start the app with &lt;code&gt;--debug&lt;/code&gt; or &lt;code&gt;-Ddebug&lt;/code&gt; or, in an Actuator application, use the &lt;code&gt;conditions&lt;/code&gt; endpoint).</source>
          <target state="translated">이 부록에는 문서 및 소스 코드에 대한 링크와 함께 Spring Boot에서 제공하는 모든 자동 구성 클래스에 대한 세부 정보가 포함되어 있습니다. 어떤 기능이 켜져 있는지에 대한 자세한 내용은 응용 프로그램의 조건 보고서를 참조하십시오. (이렇게하려면 &lt;code&gt;--debug&lt;/code&gt; 또는 &lt;code&gt;-Ddebug&lt;/code&gt; 를 사용 하여 앱을 시작 하거나 Actuator 애플리케이션에서 &lt;code&gt;conditions&lt;/code&gt; 엔드 포인트를 사용합니다 .)</target>
        </trans-unit>
        <trans-unit id="984f673e277732a56de47a940ed29e7eb8783fb0" translate="yes" xml:space="preserve">
          <source>This appendix describes the &lt;code&gt;@&amp;hellip;Test&lt;/code&gt; auto-configuration annotations that Spring Boot provides to test slices of your application.</source>
          <target state="translated">이 부록 에서는 Spring Boot가 애플리케이션 슬라이스를 테스트하기 위해 제공 하는 &lt;code&gt;@&amp;hellip;Test&lt;/code&gt; 자동 구성 주석에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="ccf6a65ddbbb1be5f0033981a73b112335a52150" translate="yes" xml:space="preserve">
          <source>This appendix provides details of the dependencies that are managed by Spring Boot.</source>
          <target state="translated">이 부록에서는 Spring Boot에서 관리하는 종속성에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b2c91bccdf113474da4e53bebb554f7a4903992e" translate="yes" xml:space="preserve">
          <source>This can be achieved using the &lt;code&gt;management.endpoints.web.exposure.exclude&lt;/code&gt; property as well, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;management.endpoints.web.exposure.exclude&lt;/code&gt; 속성을 사용하여 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be3038015bd38bcaa3e17a77de5bea4252ebee38" translate="yes" xml:space="preserve">
          <source>This can be done with a static &lt;code&gt;@DynamicPropertySource&lt;/code&gt; method that allows adding dynamic property values to the Spring Environment.</source>
          <target state="translated">이것은 스프링 환경에 동적 속성 값을 추가 할 수 있는 정적 &lt;code&gt;@DynamicPropertySource&lt;/code&gt; 메소드 로 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a61838b1bb1e6ad76a8585f2f1a3bb5a82532259" translate="yes" xml:space="preserve">
          <source>This can be used to invoke a write operation that takes &lt;code&gt;String name&lt;/code&gt; and &lt;code&gt;int counter&lt;/code&gt; parameters, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 &lt;code&gt;String name&lt;/code&gt; 및 &lt;code&gt;int counter&lt;/code&gt; 매개 변수를 사용하는 쓰기 작업을 호출하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9a9010abe3110cb625dd05b7d1c4d4336fc4507" translate="yes" xml:space="preserve">
          <source>This changes the thread pool to use a bounded queue so that when the queue is full (100 tasks), the thread pool increases to maximum 16 threads. Shrinking of the pool is more aggressive as threads are reclaimed when they are idle for 10 seconds (rather than 60 seconds by default).</source>
          <target state="translated">이렇게하면 스레드 풀이 제한된 큐를 사용하도록 변경되어 큐가 가득 차면 (100 개의 작업) 스레드 풀이 최대 16 개의 스레드로 증가합니다. 풀 축소는 스레드가 10 초 동안 (기본적으로 60 초가 아닌) 유휴 상태 일 때 재 확보되기 때문에 더 적극적입니다.</target>
        </trans-unit>
        <trans-unit id="19140306758e9479ce889f0e36b875db09a91869" translate="yes" xml:space="preserve">
          <source>This contract is well suited for tasks that should run after application startup but before it starts accepting traffic.</source>
          <target state="translated">이 계약은 애플리케이션 시작 후 트래픽 수락을 시작하기 전에 실행해야하는 작업에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="9ccc535292943cb99a6236fb50422982b6375e4c" translate="yes" xml:space="preserve">
          <source>This customizer will configure Hibernate to use the same &lt;code&gt;CacheManager&lt;/code&gt; as the one that the application uses. It is also possible to use separate &lt;code&gt;CacheManager&lt;/code&gt; instances. For details, refer to &lt;a href=&quot;https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#caching-provider-jcache&quot;&gt;the Hibernate user guide&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;CacheManager&lt;/code&gt; 스터 마이 저는 애플리케이션 이 사용하는 것과 동일한 CacheManager 를 사용하도록 Hibernate를 설정 합니다. 별도의 &lt;code&gt;CacheManager&lt;/code&gt; 인스턴스 를 사용할 수도 있습니다 . 자세한 내용 &lt;a href=&quot;https://docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html#caching-provider-jcache&quot;&gt;은 Hibernate 사용자 가이드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d931ce8f98edb34b2725769650fa06f92889a5f5" translate="yes" xml:space="preserve">
          <source>This dependency ensures that the additional metadata is available when the annotation processor runs during compilation.</source>
          <target state="translated">이 종속성은 컴파일 중에 주석 프로세서가 실행될 때 추가 메타 데이터를 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="e2e9f15a4265ff675c8ffa73c78fd4c2bff7f01a" translate="yes" xml:space="preserve">
          <source>This environment-based configuration is applied to the auto-configured &lt;code&gt;Jackson2ObjectMapperBuilder&lt;/code&gt; bean and applies to any mappers created by using the builder, including the auto-configured &lt;code&gt;ObjectMapper&lt;/code&gt; bean.</source>
          <target state="translated">이 환경 기반 구성은 자동 구성된 &lt;code&gt;Jackson2ObjectMapperBuilder&lt;/code&gt; Bean에 적용되며 자동 구성된 &lt;code&gt;ObjectMapper&lt;/code&gt; Bean을 포함하여 빌더를 사용하여 생성 된 모든 매퍼에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c782d4945d30386e771eb84a56e0439f0f7dea7" translate="yes" xml:space="preserve">
          <source>This error is not fatal, and the application still starts with HTTP/1.1 SSL support.</source>
          <target state="translated">이 오류는 치명적이지 않으며 애플리케이션은 여전히 ​​HTTP / 1.1 SSL 지원으로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3fd2a3db4f896a900f42aa5368eb8076a7ac1836" translate="yes" xml:space="preserve">
          <source>This example demonstrates the use of caching on a potentially costly operation. Before invoking &lt;code&gt;computePiDecimal&lt;/code&gt;, the abstraction looks for an entry in the &lt;code&gt;piDecimals&lt;/code&gt; cache that matches the &lt;code&gt;i&lt;/code&gt; argument. If an entry is found, the content in the cache is immediately returned to the caller, and the method is not invoked. Otherwise, the method is invoked, and the cache is updated before returning the value.</source>
          <target state="translated">이 예제는 잠재적으로 비용이 많이 드는 작업에서 캐싱을 사용하는 방법을 보여줍니다. &lt;code&gt;computePiDecimal&lt;/code&gt; 을 호출하기 전에 추상화는 &lt;code&gt;i&lt;/code&gt; 인수 와 일치하는 &lt;code&gt;piDecimals&lt;/code&gt; 캐시 에서 항목을 찾습니다 . 항목이 발견되면 캐시의 콘텐츠가 즉시 호출자에게 반환되고 메서드가 호출되지 않습니다. 그렇지 않으면 메서드가 호출되고 값을 반환하기 전에 캐시가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="4ae35b375e3c0e286e69190c8b8387e8cd414874" translate="yes" xml:space="preserve">
          <source>This exposes three properties where &lt;code&gt;server.name&lt;/code&gt; has no default and &lt;code&gt;server.ip&lt;/code&gt; and &lt;code&gt;server.port&lt;/code&gt; defaults to &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; and &lt;code&gt;9797&lt;/code&gt; respectively. The Javadoc on fields is used to populate the &lt;code&gt;description&lt;/code&gt; attribute. For instance, the description of &lt;code&gt;server.ip&lt;/code&gt; is &quot;IP address to listen to.&quot;.</source>
          <target state="translated">이렇게하면 &lt;code&gt;server.name&lt;/code&gt; 에 기본값이없고 &lt;code&gt;server.ip&lt;/code&gt; 및 &lt;code&gt;server.port&lt;/code&gt; 기본값이 각각 &lt;code&gt;&quot;127.0.0.1&quot;&lt;/code&gt; 및 &lt;code&gt;9797&lt;/code&gt; 인 세 가지 속성이 표시 됩니다. 필드의 Javadoc은 &lt;code&gt;description&lt;/code&gt; 속성 을 채우는 데 사용됩니다 . 예를 들어 &lt;code&gt;server.ip&lt;/code&gt; 의 설명 은 &quot;수신 할 IP 주소&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9c950af61168cf48f875069726b5829662150d1a" translate="yes" xml:space="preserve">
          <source>This feature has been thoroughly described in a dedicated &lt;a href=&quot;https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources&quot;&gt;blog post&lt;/a&gt; and in Spring Framework&amp;rsquo;s &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-config-static-resources&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">이 기능은 전용 &lt;a href=&quot;https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources&quot;&gt;블로그 게시물&lt;/a&gt; 과 Spring Framework의 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-config-static-resources&quot;&gt;참조 문서&lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2138520f355b2c407e5f15678dd9e192623d173" translate="yes" xml:space="preserve">
          <source>This has no effect on collections and maps, as those types are automatically identified, and a single metadata property is generated for each of them.</source>
          <target state="translated">이러한 유형은 자동으로 식별되고 각 유형에 대해 단일 메타 데이터 속성이 생성되기 때문에 컬렉션과 맵에는 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="460f041997c5287303b677888b9ee4c179f56597" translate="yes" xml:space="preserve">
          <source>This is a drop-in replacement for &lt;code&gt;SpringApplication.run(MyApplication::class.java, *args)&lt;/code&gt;. It also allows customization of the application as shown in the following example:</source>
          <target state="translated">이것은 &lt;code&gt;SpringApplication.run(MyApplication::class.java, *args)&lt;/code&gt; 의 드롭 인 대체입니다 . 또한 다음 예제와 같이 응용 프로그램을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="774d83552d4cc4ae6cba6a40e5ba717384d23635" translate="yes" xml:space="preserve">
          <source>This is a multi-stage dockerfile. The builder stage extracts the directories that are needed later. Each of the &lt;code&gt;COPY&lt;/code&gt; commands relates to the layers extracted by the jarmode.</source>
          <target state="translated">이것은 다단계 도커 파일입니다. 빌더 단계는 나중에 필요한 디렉토리를 추출합니다. 각 &lt;code&gt;COPY&lt;/code&gt; 명령은 jarmode에 의해 추출 된 레이어와 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="65abcee4f5c5b820de47a4aeaa7773ed7b5f7459" translate="yes" xml:space="preserve">
          <source>This is actually slightly faster on startup (depending on the size of the jar) than running from an unexploded archive. At runtime you shouldn&amp;rsquo;t expect any differences.</source>
          <target state="translated">이것은 실제로 확장되지 않은 아카이브에서 실행하는 것보다 시작시 (단지 크기에 따라 다름) 약간 더 빠릅니다. 런타임에는 어떤 차이도 기 대해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="cc6e682516a6ad09927269eec4316520d0e41594" translate="yes" xml:space="preserve">
          <source>This is one of the easiest ways to get to AWS, but there are more things to cover, such as how to integrate Elastic Beanstalk into any CI / CD tool, use the Elastic Beanstalk Maven plugin instead of the CLI, and others. There is a &lt;a href=&quot;https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/&quot;&gt;blog post&lt;/a&gt; covering these topics more in detail.</source>
          <target state="translated">이것은 AWS로 이동하는 가장 쉬운 방법 중 하나이지만 Elastic Beanstalk를 CI / CD 도구에 통합하는 방법, CLI 대신 Elastic Beanstalk Maven 플러그인을 사용하는 방법 등과 같이 다루어야 할 사항이 더 많습니다. 이 &lt;a href=&quot;https://exampledriven.wordpress.com/2017/01/09/spring-boot-aws-elastic-beanstalk-example/&quot;&gt;블로그 게시물&lt;/a&gt; 더 자세히 이러한 주제를 다루는는.</target>
        </trans-unit>
        <trans-unit id="27f478501081366262c7458d55c6be86a05cb986" translate="yes" xml:space="preserve">
          <source>This is typically manifested by a warning in the &lt;code&gt;RemoteSpringApplication&lt;/code&gt; logs about failing to upload some of the classes, and a consequent retry. But it may also lead to application code inconsistency and failure to restart after the first batch of changes is uploaded. If you observe such problems constantly, try increasing the &lt;code&gt;spring.devtools.restart.poll-interval&lt;/code&gt; and &lt;code&gt;spring.devtools.restart.quiet-period&lt;/code&gt; parameters to the values that fit your development environment. See the &lt;a href=&quot;#configuring-file-system-watcher&quot;&gt;Configuring File System Watcher&lt;/a&gt; section for configuring these properties.</source>
          <target state="translated">이는 일반적으로 일부 클래스 업로드 실패 에 대한 &lt;code&gt;RemoteSpringApplication&lt;/code&gt; 로그 의 경고 와 그에 따른 재시 도로 나타납니다 . 그러나 첫 번째 변경 일괄 처리가 업로드 된 후 애플리케이션 코드 불일치 및 다시 시작 실패로 이어질 수도 있습니다. 이러한 문제가 지속적으로 관찰되는 경우 &lt;code&gt;spring.devtools.restart.poll-interval&lt;/code&gt; 및 &lt;code&gt;spring.devtools.restart.quiet-period&lt;/code&gt; 매개 변수를 개발 환경에 맞는 값으로 늘리 십시오. 이러한 속성을 구성 하려면 &lt;a href=&quot;#configuring-file-system-watcher&quot;&gt;파일 시스템 감시자&lt;/a&gt; 구성 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8807232cdffcee31c30f8455dbe11a36471d8a89" translate="yes" xml:space="preserve">
          <source>This layering is designed to separate code based on how likely it is to change between application builds. Library code is less likely to change between builds, so it is placed in its own layers to allow tooling to re-use the layers from cache. Application code is more likely to change between builds so it is isolated in a separate layer.</source>
          <target state="translated">이 계층화는 애플리케이션 빌드간에 변경 될 가능성에 따라 코드를 분리하도록 설계되었습니다. 라이브러리 코드는 빌드간에 변경 될 가능성이 적으므로 도구가 캐시에서 레이어를 재사용 할 수 있도록 자체 레이어에 배치됩니다. 애플리케이션 코드는 빌드간에 변경 될 가능성이 더 높으므로 별도의 레이어에서 격리됩니다.</target>
        </trans-unit>
        <trans-unit id="c5ef4701b03e6884ae66365ff7c9a5c4b0e5907f" translate="yes" xml:space="preserve">
          <source>This means that Spring Boot will create a &lt;code&gt;RSocketMessageHandler&lt;/code&gt; bean that will handle RSocket requests to your application.</source>
          <target state="translated">이는 Spring Boot가 애플리케이션에 대한 RSocket 요청을 처리 할 &lt;code&gt;RSocketMessageHandler&lt;/code&gt; 빈을 생성한다는 것을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="5eae2e67718a6dfd9018f9e6399d25366f798b97" translate="yes" xml:space="preserve">
          <source>This means that if you are using Spring MVC and the new &lt;code&gt;WebClient&lt;/code&gt; from Spring WebFlux in the same application, Spring MVC will be used by default. You can override that easily by calling &lt;code&gt;setWebApplicationType(WebApplicationType)&lt;/code&gt;.</source>
          <target state="translated">즉 , 동일한 애플리케이션에서 Spring MVC와 Spring WebFlux 의 새로운 &lt;code&gt;WebClient&lt;/code&gt; 를 사용하는 경우 기본적으로 Spring MVC가 사용됩니다. &lt;code&gt;setWebApplicationType(WebApplicationType)&lt;/code&gt; 을 호출하여 쉽게 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2646b2d13175c223b62a39f5ddfe7f8157de525a" translate="yes" xml:space="preserve">
          <source>This mechanism does not apply the same way to &lt;code&gt;@Bean&lt;/code&gt; methods where typically the return type is the target of the condition: before the condition on the method applies, the JVM will have loaded the class and potentially processed method references which will fail if the class is not present.</source>
          <target state="translated">이 메커니즘은 일반적으로 반환 유형이 조건의 대상인 &lt;code&gt;@Bean&lt;/code&gt; 메서드에 동일한 방식으로 적용되지 않습니다. 메서드의 조건이 적용되기 전에 JVM은 클래스를로드하고 잠재적으로 처리 된 메서드 참조를 처리하여 클래스가 실패하는 경우 실패합니다. 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e04a6129637843867969bfeb4e068f988b2c1482" translate="yes" xml:space="preserve">
          <source>This option applies to Spring Boot projects that produce a jar file and run an embedded web container. Elastic Beanstalk environments run an nginx instance on port 80 to proxy the actual application, running on port 5000. To configure it, add the following line to your &lt;code&gt;application.properties&lt;/code&gt; file:</source>
          <target state="translated">이 옵션은 jar 파일을 생성하고 임베디드 웹 컨테이너를 실행하는 Spring Boot 프로젝트에 적용됩니다. Elastic Beanstalk 환경은 포트 80에서 nginx 인스턴스를 실행하여 포트 5000에서 실행되는 실제 애플리케이션을 프록시합니다.이를 구성하려면 &lt;code&gt;application.properties&lt;/code&gt; 파일에 다음 줄을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="23d1133621317af1d989c72131e4710179de628d" translate="yes" xml:space="preserve">
          <source>This option applies to Spring Boot projects that produce a war file. No special configuration is required. You need only follow the official guide.</source>
          <target state="translated">이 옵션은 war 파일을 생성하는 Spring Boot 프로젝트에 적용됩니다. 특별한 구성이 필요하지 않습니다. 공식 가이드를 따르기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e0505b8a65050cd0e9d9b2071f29719bc73899b3" translate="yes" xml:space="preserve">
          <source>This provider is typically used if you have a list of values and any extra values should still be considered as valid.</source>
          <target state="translated">이 공급자는 일반적으로 값 목록이 있고 추가 값이 여전히 유효한 것으로 간주되어야하는 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4ad2c325143f08dfb46f0befdcf7f0c482a1e749" translate="yes" xml:space="preserve">
          <source>This provider supports the following parameters:</source>
          <target state="translated">이 공급자는 다음 매개 변수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e54550d08e2dad7df5255e1219bfa453c98a0370" translate="yes" xml:space="preserve">
          <source>This provides only one argument to the batch job: &lt;code&gt;someParameter=someValue&lt;/code&gt;.</source>
          <target state="translated">이는 배치 작업에 하나의 인수 ( &lt;code&gt;someParameter=someValue&lt;/code&gt; ) 만 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="22fc8d96be3312002845eb59330f80a1b7edc1e2" translate="yes" xml:space="preserve">
          <source>This sample needs to be created in its own directory. Subsequent instructions assume that you have created a suitable directory and that it is your current directory.</source>
          <target state="translated">이 샘플은 자체 디렉터리에 만들어야합니다. 후속 지침에서는 적합한 디렉토리를 작성했으며 현재 디렉토리라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f9fa29d3b2e8ac7908b0d41ef1a7c8f128996087" translate="yes" xml:space="preserve">
          <source>This search ordering lets you specify default values in one configuration file and then selectively override those values in another. You can provide default values for your application in &lt;code&gt;application.properties&lt;/code&gt; (or whatever other basename you choose with &lt;code&gt;spring.config.name&lt;/code&gt;) in one of the default locations. These default values can then be overridden at runtime with a different file located in one of the custom locations.</source>
          <target state="translated">이 검색 순서를 사용하면 한 구성 파일에서 기본값을 지정한 다음 다른 구성 파일에서 해당 값을 선택적으로 재정의 할 수 있습니다. 기본 위치 중 하나 에서 &lt;code&gt;application.properties&lt;/code&gt; (또는 &lt;code&gt;spring.config.name&lt;/code&gt; 으로 선택한 다른 기본 이름) 에서 애플리케이션의 기본값을 제공 할 수 있습니다 . 이러한 기본값은 사용자 지정 위치 중 하나에있는 다른 파일을 사용하여 런타임에 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98af5606c519e36542ec351d8486cb6859c633f2" translate="yes" xml:space="preserve">
          <source>This section addresses questions about security when working with Spring Boot, including questions that arise from using Spring Security with Spring Boot.</source>
          <target state="translated">이 섹션에서는 Spring Boot와 함께 Spring Security를 ​​사용할 때 발생하는 질문을 포함하여 Spring Boot로 작업 할 때 보안에 대한 질문을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="63d2a24b1fdff3ed5546f1a972979f48e3afe8f6" translate="yes" xml:space="preserve">
          <source>This section contains three examples of using &lt;code&gt;findmainclass&lt;/code&gt;.</source>
          <target state="translated">이 섹션에는 &lt;code&gt;findmainclass&lt;/code&gt; 사용에 대한 세 가지 예제가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8acedec21aec8bb92d4f624db5f059f55b7b4056" translate="yes" xml:space="preserve">
          <source>This section covers some of the more common deployment scenarios.</source>
          <target state="translated">이 섹션에서는 몇 가지 일반적인 배포 시나리오를 다룹니다.</target>
        </trans-unit>
        <trans-unit id="70b211ea63ca950926089e9def6a4e30c449147c" translate="yes" xml:space="preserve">
          <source>This section describes how to develop a small &amp;ldquo;Hello World!&amp;rdquo; web application that highlights some of Spring Boot&amp;rsquo;s key features. We use Maven to build this project, since most IDEs support it.</source>
          <target state="translated">이 섹션에서는 작은&amp;ldquo;Hello World!&amp;rdquo;를 개발하는 방법을 설명합니다. Spring Boot의 주요 기능 중 일부를 강조하는 웹 애플리케이션입니다. 대부분의 IDE에서 지원하므로 Maven을 사용하여이 프로젝트를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="63ebfcaa3ec5cd3905d00724e0eeba5ca871a2ed" translate="yes" xml:space="preserve">
          <source>This section dives into the details of Spring Boot. Here you can learn about the key features that you may want to use and customize. If you have not already done so, you might want to read the &quot;&lt;a href=&quot;getting-started#getting-started&quot;&gt;getting-started.html&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;using-spring-boot#using-boot&quot;&gt;using-spring-boot.html&lt;/a&gt;&quot; sections, so that you have a good grounding of the basics.</source>
          <target state="translated">이 섹션에서는 Spring Boot에 대해 자세히 설명합니다. 여기에서 사용하고 사용자 지정할 수있는 주요 기능에 대해 알아볼 수 있습니다. 아직 그렇게하지 않았다면 &quot; &lt;a href=&quot;getting-started#getting-started&quot;&gt;getting &lt;/a&gt;&lt;a href=&quot;using-spring-boot#using-boot&quot;&gt;-started.html&lt;/a&gt; &quot; 및 &quot; using-spring-boot.html &quot;섹션을 읽고 기본 사항을 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa32a19ddc3a86d4ab8bdef4dc856c7c3f1cd92d" translate="yes" xml:space="preserve">
          <source>This section goes into more detail about how you should use Spring Boot. It covers topics such as build systems, auto-configuration, and how to run your applications. We also cover some Spring Boot best practices. Although there is nothing particularly special about Spring Boot (it is just another library that you can consume), there are a few recommendations that, when followed, make your development process a little easier.</source>
          <target state="translated">이 섹션에서는 Spring Boot를 사용하는 방법에 대해 자세히 설명합니다. 빌드 시스템, 자동 구성 및 애플리케이션 실행 방법과 같은 주제를 다룹니다. 또한 몇 가지 Spring Boot 모범 사례를 다룹니다. Spring Boot에 대해 특별히 특별한 것은 없지만 (사용할 수있는 또 다른 라이브러리 일뿐) 몇 가지 권장 사항을 따르면 개발 프로세스를 좀 더 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c2c065b14100d63a7f263ab40adb253a558419e" translate="yes" xml:space="preserve">
          <source>This section includes topics about setting and reading properties and configuration settings and their interaction with Spring Boot applications.</source>
          <target state="translated">이 섹션에는 속성 및 구성 설정 설정 및 읽기와 Spring Boot 애플리케이션과의 상호 작용에 대한 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="68bf44b7331aa20ee33060f7be2c6d336d11651b" translate="yes" xml:space="preserve">
          <source>This section includes topics relating directly to Spring Boot applications.</source>
          <target state="translated">이 섹션에는 Spring Boot 애플리케이션과 직접 관련된 주제가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="21a790fda00a13c2afdc2633ee2d0b018fb43401" translate="yes" xml:space="preserve">
          <source>This section only covers jar based packaging. If you choose to package your application as a war file, you should refer to your server and IDE documentation.</source>
          <target state="translated">이 섹션에서는 단지 기반 포장 만 다룹니다. 애플리케이션을 war 파일로 패키징하기로 선택한 경우 서버 및 IDE 문서를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="78fc2879e4ad1c8aacfc386d63f895e7eea1abb8" translate="yes" xml:space="preserve">
          <source>This section provides a brief overview of Spring Boot reference documentation. It serves as a map for the rest of the document.</source>
          <target state="translated">이 섹션에서는 Spring Boot 참조 문서에 대한 간략한 개요를 제공합니다. 문서의 나머지 부분에 대한 맵 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="f958777b6bee155d608e729d89a9b3bebf1d3861" translate="yes" xml:space="preserve">
          <source>This section provides answers to some common &amp;lsquo;how do I do that&amp;hellip;​&amp;rsquo; questions that often arise when using Spring Boot. Its coverage is not exhaustive, but it does cover quite a lot.</source>
          <target state="translated">이 섹션에서는 Spring Boot를 사용할 때 자주 발생하는 몇 가지 일반적인 '어떻게하면 ...'질문에 대한 답변을 제공합니다. 그 범위는 완전하지는 않지만 꽤 많이 다루고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d9be02fea69d7068dfad55edc0923522bd8170" translate="yes" xml:space="preserve">
          <source>This section shows two examples of Ant tasks.</source>
          <target state="translated">이 섹션에서는 Ant 태스크의 두 가지 예를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="06b1f5b07a36526fc5d9c4f3a479a09ae49d16df" translate="yes" xml:space="preserve">
          <source>This separation in two modules is in no way necessary. If &quot;acme&quot; has several flavours, options or optional features, then it is better to separate the auto-configuration as you can clearly express the fact some features are optional. Besides, you have the ability to craft a starter that provides an opinion about those optional dependencies. At the same time, others can rely only on the &lt;code&gt;autoconfigure&lt;/code&gt; module and craft their own starter with different opinions.</source>
          <target state="translated">두 개의 모듈에서 이러한 분리는 필요하지 않습니다. &quot;acme&quot;에 여러 가지 맛, 옵션 또는 옵션 기능이있는 경우 일부 기능이 선택 사항이라는 사실을 명확하게 표현할 수 있으므로 자동 구성을 분리하는 것이 좋습니다. 또한 이러한 선택적 종속성에 대한 의견을 제공하는 스타터를 만들 수 있습니다. 동시에 다른 사람들은 &lt;code&gt;autoconfigure&lt;/code&gt; 모듈 에만 의존 하고 다른 의견으로 자신의 스타터를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe0c2a5e1c1667db97a516e07f56f197c054bfd2" translate="yes" xml:space="preserve">
          <source>This sets the common &lt;code&gt;prop.one&lt;/code&gt; Kafka property to &lt;code&gt;first&lt;/code&gt; (applies to producers, consumers and admins), the &lt;code&gt;prop.two&lt;/code&gt; admin property to &lt;code&gt;second&lt;/code&gt;, the &lt;code&gt;prop.three&lt;/code&gt; consumer property to &lt;code&gt;third&lt;/code&gt;, the &lt;code&gt;prop.four&lt;/code&gt; producer property to &lt;code&gt;fourth&lt;/code&gt; and the &lt;code&gt;prop.five&lt;/code&gt; streams property to &lt;code&gt;fifth&lt;/code&gt;.</source>
          <target state="translated">이것은 common &lt;code&gt;prop.one&lt;/code&gt; Kafka 속성을 &lt;code&gt;first&lt;/code&gt; 로 설정하고 (생산자, 소비자 및 관리자에 적용) &lt;code&gt;prop.two&lt;/code&gt; 관리 속성을 &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;prop.three&lt;/code&gt; 소비자 속성을 &lt;code&gt;third&lt;/code&gt; , &lt;code&gt;prop.four&lt;/code&gt; 생산자 속성을 &lt;code&gt;fourth&lt;/code&gt; 로, &lt;code&gt;prop.five&lt;/code&gt; 스트림 속성을 &lt;code&gt;fifth&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7ef8ea8678f7fcf1b792d7c676b306bd052f386" translate="yes" xml:space="preserve">
          <source>This setup is only supported by WebFlux applications as using &lt;code&gt;WebTestClient&lt;/code&gt; in a mocked web application only works with WebFlux at the moment.</source>
          <target state="translated">모의 웹 애플리케이션에서 &lt;code&gt;WebTestClient&lt;/code&gt; 를 사용하는 것은 현재 WebFlux에서만 작동 하므로이 설정은 WebFlux 애플리케이션에서만 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="eb482188f5594442f357f3e0e6680312716ffbc1" translate="yes" xml:space="preserve">
          <source>This setup puts you &lt;em&gt;in sync&lt;/em&gt; with what Spring Boot does for you by default, except that a dedicated connection pool is chosen (in code) and its settings are exposed in the &lt;code&gt;app.datasource.configuration&lt;/code&gt; sub namespace. Because &lt;code&gt;DataSourceProperties&lt;/code&gt; is taking care of the &lt;code&gt;url&lt;/code&gt;/&lt;code&gt;jdbcUrl&lt;/code&gt; translation for you, you can configure it as follows:</source>
          <target state="translated">이 설정은 전용 연결 풀이 선택되고 (코드에서) 해당 설정이 &lt;code&gt;app.datasource.configuration&lt;/code&gt; 하위 네임 스페이스에 노출된다는 점을 제외하고는 기본적으로 Spring Boot가 &lt;em&gt;수행하는 작업&lt;/em&gt; 과 &lt;em&gt;동기화&lt;/em&gt; 됩니다 . 때문에 &lt;code&gt;DataSourceProperties&lt;/code&gt; 이 의 치료를 취하고있다 &lt;code&gt;url&lt;/code&gt; / &lt;code&gt;jdbcUrl&lt;/code&gt; 의 당신을위한 번역, 다음과 같이 구성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a54ca376c967f54b5f3de3e7e319eca5cab3b808" translate="yes" xml:space="preserve">
          <source>This setup requires &lt;code&gt;spring-webflux&lt;/code&gt; on the classpath. If you can&amp;rsquo;t or won&amp;rsquo;t add webflux, Spring Boot also provides a &lt;code&gt;TestRestTemplate&lt;/code&gt; facility:</source>
          <target state="translated">이 설정에는 클래스 경로에 &lt;code&gt;spring-webflux&lt;/code&gt; 가 필요합니다 . webflux를 추가 할 수 없거나 추가하지 않을 경우 Spring Boot는 &lt;code&gt;TestRestTemplate&lt;/code&gt; 기능 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="84d7bfad4c1d411a409984af163140bdf3448c78" translate="yes" xml:space="preserve">
          <source>This should be everything you need. The most common deployment workflow for Heroku deployments is to &lt;code&gt;git push&lt;/code&gt; the code to production, as shown in the following example:</source>
          <target state="translated">이것이 필요한 모든 것입니다. Heroku 배포를위한 가장 일반적인 배포 워크 플로 는 다음 예와 같이 코드를 프로덕션 으로 &lt;code&gt;git push&lt;/code&gt; 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="393f3f6f2ef031ca1cff60f137d4a4baed5ad8dc" translate="yes" xml:space="preserve">
          <source>This style of configuration works particularly well with the &lt;code&gt;SpringApplication&lt;/code&gt; external YAML configuration, as shown in the following example:</source>
          <target state="translated">이 스타일의 구성은 다음 예제와 같이 &lt;code&gt;SpringApplication&lt;/code&gt; 외부 YAML 구성에서 특히 잘 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b74ccedd75661707cf53972e2f4f67ff3e40695a" translate="yes" xml:space="preserve">
          <source>This will add &lt;code&gt;db.username&lt;/code&gt;, &lt;code&gt;db.password&lt;/code&gt;, &lt;code&gt;mq.username&lt;/code&gt; and &lt;code&gt;mq.password&lt;/code&gt; properties.</source>
          <target state="translated">그러면 &lt;code&gt;db.username&lt;/code&gt; , &lt;code&gt;db.password&lt;/code&gt; , &lt;code&gt;mq.username&lt;/code&gt; 및 &lt;code&gt;mq.password&lt;/code&gt; 속성 이 추가 됩니다.</target>
        </trans-unit>
        <trans-unit id="6701a5571029f61c844ac3f8a6df09b47475e443" translate="yes" xml:space="preserve">
          <source>This will prevent any user, including root, from modifying the jar.</source>
          <target state="translated">이렇게하면 루트를 포함한 모든 사용자가 jar를 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c652550434d586e51511bab160a434f556a6a5cc" translate="yes" xml:space="preserve">
          <source>This will provide the following output:</source>
          <target state="translated">그러면 다음과 같은 출력이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="02dcde164b156486502408b465994d246d88e331" translate="yes" xml:space="preserve">
          <source>This will set the pool to wait 10000 ms before throwing an exception if no connection is available, limit the maximum number of connections to 50 and validate the connection before borrowing it from the pool.</source>
          <target state="translated">이렇게하면 연결을 사용할 수없는 경우 예외가 발생하기 전에 풀이 10000ms를 대기하도록 설정하고 최대 연결 수를 50으로 제한하고 연결을 풀에서 가져 오기 전에 유효성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="79123de85bc5887b35ad590e9149fa99fe8c1d92" translate="yes" xml:space="preserve">
          <source>This will start up a docker container running Neo4j (if Docker is running locally) before any of the tests are run. In most cases, you will need to configure the application using details from the running container, such as container IP or port.</source>
          <target state="translated">이렇게하면 테스트가 실행되기 전에 Neo4j (Docker가 로컬에서 실행중인 경우)를 실행하는 도커 컨테이너가 시작됩니다. 대부분의 경우 컨테이너 IP 또는 포트와 같은 실행중인 컨테이너의 세부 정보를 사용하여 애플리케이션을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d802a6996822557b82fa06b1e760c08cbdda7eb7" translate="yes" xml:space="preserve">
          <source>This will trigger the import of a &lt;code&gt;dev.properties&lt;/code&gt; file in current directory (if such a file exists). Values from the imported &lt;code&gt;dev.properties&lt;/code&gt; will take precedence over the file that triggered the import. In the above example, the &lt;code&gt;dev.properties&lt;/code&gt; could redefine &lt;code&gt;spring.application.name&lt;/code&gt; to a different value.</source>
          <target state="translated">이렇게하면 현재 디렉터리 에있는 &lt;code&gt;dev.properties&lt;/code&gt; 파일 가져 오기가 트리거됩니다 (해당 파일이있는 경우). 가져온 &lt;code&gt;dev.properties&lt;/code&gt; 의 값 이 가져 오기를 트리거 한 파일보다 우선합니다. 위의 예에서 &lt;code&gt;dev.properties&lt;/code&gt; 는 &lt;code&gt;spring.application.name&lt;/code&gt; 을 다른 값으로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d826b51779d73958d9b6c113421d73d845a0e3e1" translate="yes" xml:space="preserve">
          <source>Those two examples are identical as the port default to &lt;code&gt;9042&lt;/code&gt;. If you need to configure the port, use &lt;code&gt;spring.data.cassandra.port&lt;/code&gt;.</source>
          <target state="translated">이 두 예는 포트 기본값이 &lt;code&gt;9042&lt;/code&gt; 로 동일합니다 . 포트를 구성해야하는 경우 &lt;code&gt;spring.data.cassandra.port&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbd866504bcd113178a516d0710990501b9a4071" translate="yes" xml:space="preserve">
          <source>Thread name: Enclosed in square brackets (may be truncated for console output).</source>
          <target state="translated">스레드 이름 : 대괄호로 묶여 있습니다 (콘솔 출력을 위해 잘릴 수 있음).</target>
        </trans-unit>
        <trans-unit id="28445b4669291b203e64bda1777adedc52da2e7f" translate="yes" xml:space="preserve">
          <source>Threads utilization</source>
          <target state="translated">스레드 활용</target>
        </trans-unit>
        <trans-unit id="9a26d12d32344c924e9fb7e0b6cda24669f0b39e" translate="yes" xml:space="preserve">
          <source>Threshold after which files are written to disk.</source>
          <target state="translated">파일이 디스크에 기록되는 임계 값입니다.</target>
        </trans-unit>
        <trans-unit id="1b4f809dde23f137cf95e65fdda0184148439430" translate="yes" xml:space="preserve">
          <source>Thymeleaf</source>
          <target state="translated">Thymeleaf</target>
        </trans-unit>
        <trans-unit id="bca8f19eb632c6ccfbe984f98e174d41434e276e" translate="yes" xml:space="preserve">
          <source>Time between checks for non-responsive consumers. If a duration suffix is not specified, seconds will be used.</source>
          <target state="translated">반응이없는 소비자에 대한 확인 간격입니다. 기간 접미사가 지정되지 않은 경우 초가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6f938423afe4ec108333437fcf762e7dd925e565" translate="yes" xml:space="preserve">
          <source>Time between offset commits when ackMode is &quot;TIME&quot; or &quot;COUNT_TIME&quot;.</source>
          <target state="translated">ackMode가 &quot;TIME&quot;또는 &quot;COUNT_TIME&quot;일 때 오프셋 커밋 사이의 시간입니다.</target>
        </trans-unit>
        <trans-unit id="257a8e3e28ce36a9201e5e594190893668c7f4cf" translate="yes" xml:space="preserve">
          <source>Time between publishing idle consumer events (no data received).</source>
          <target state="translated">유휴 소비자 이벤트 게시 사이의 시간 (수신 된 데이터 없음)</target>
        </trans-unit>
        <trans-unit id="16edef0e1615af59ec5ec37a6f1b76b8724566e7" translate="yes" xml:space="preserve">
          <source>Time between runs of the idle object evictor thread. When positive, the idle object evictor thread starts, otherwise no idle object eviction is performed.</source>
          <target state="translated">유휴 오브젝트 축출 기 스레드 실행 사이의 시간입니다. 양수이면 유휴 오브젝트 축출 기 스레드가 시작되고 그렇지 않으면 유휴 오브젝트 축출이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a7ee8eff9bb0b66b975728003d3401d6a4dce74" translate="yes" xml:space="preserve">
          <source>Time format to use, for example `HH:mm:ss`.</source>
          <target state="translated">사용할 시간 형식 (예 :`HH : mm : ss`).</target>
        </trans-unit>
        <trans-unit id="e8bf663ffb266dffd11e68a6255174b6c7baa03d" translate="yes" xml:space="preserve">
          <source>Time limit for which threads may remain idle before being terminated.</source>
          <target state="translated">스레드가 종료되기 전에 유휴 상태를 유지할 수있는 시간 제한입니다.</target>
        </trans-unit>
        <trans-unit id="90deb36c0b03a4e98d0a54557d80ba7573ffecf0" translate="yes" xml:space="preserve">
          <source>Time period for which Influx should retain data in the current database. For instance 7d, check the influx documentation for more details on the duration format.</source>
          <target state="translated">Influx가 현재 데이터베이스에 데이터를 보관해야하는 기간입니다. 예를 들어 7d, 기간 형식에 대한 자세한 내용은 유입 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5755a712830b5358cee25a8d7d5bd3c88888e586" translate="yes" xml:space="preserve">
          <source>Time range covered by a shard group. For instance 2w, check the influx documentation for more details on the duration format.</source>
          <target state="translated">샤드 그룹에 포함되는 시간 범위입니다. 예를 들어 2w, 기간 형식에 대한 자세한 내용은 유입 문서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e048b8a2140a4da5a934e33a06f141d1a026b933" translate="yes" xml:space="preserve">
          <source>Time that the connection can be idle before it is closed.</source>
          <target state="translated">연결이 닫히기 전에 유휴 상태 일 수있는 시간입니다.</target>
        </trans-unit>
        <trans-unit id="08af1477dc7ae60ab5bf240e0ce50ec17583678c" translate="yes" xml:space="preserve">
          <source>Time to live for meters that do not have any activity. After this period the meter will be considered expired and will not get reported.</source>
          <target state="translated">활동이없는 계량기의 수명. 이 기간이 지나면 미터는 만료 된 것으로 간주되어보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="157a05dc4208cf8ba78eb0ca8d35438a23db3489" translate="yes" xml:space="preserve">
          <source>Time to live for metrics on Ganglia. Set the multi-cast Time-To-Live to be one greater than the number of hops (routers) between the hosts.</source>
          <target state="translated">Ganglia의 메트릭에 대한 수명. 멀티 캐스트 Time-To-Live를 호스트 간의 홉 (라우터) 수보다 하나 크게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="92d71d8d919c8d051ff5b484cea33464df8b8c15" translate="yes" xml:space="preserve">
          <source>Time to live for subscriptions from the LWC service.</source>
          <target state="translated">LWC 서비스의 구독을위한 TTL입니다.</target>
        </trans-unit>
        <trans-unit id="4da724f7300aaf90f6f509cae3b729229b3c4bca" translate="yes" xml:space="preserve">
          <source>Time to sleep between runs of the idle connection eviction thread. When negative, no idle connection eviction thread runs.</source>
          <target state="translated">유휴 연결 제거 스레드 실행 사이의 휴면 시간입니다. 음수이면 유휴 연결 제거 스레드가 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55e5751905354c493cd02a6ebad4088bb40721e4" translate="yes" xml:space="preserve">
          <source>Time to wait before considering a close complete.</source>
          <target state="translated">마감 완료를 고려하기 전에 기다려야 할 시간입니다.</target>
        </trans-unit>
        <trans-unit id="d41a68739496fda9bd790fa6b6ca841565b57dc1" translate="yes" xml:space="preserve">
          <source>Time to wait on message sends for a response. Set it to 0 to wait forever.</source>
          <target state="translated">응답을 위해 메시지 전송을 기다리는 시간입니다. 영원히 기다리려면 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="fa1f17973d6de3e97425a7545e3fe34a93f8cec7" translate="yes" xml:space="preserve">
          <source>Time zone used when formatting dates. For instance, &quot;America/Los_Angeles&quot; or &quot;GMT+10&quot;.</source>
          <target state="translated">날짜 형식을 지정할 때 사용되는 시간대입니다. 예 : &quot;America / Los_Angeles&quot;또는 &quot;GMT + 10&quot;.</target>
        </trans-unit>
        <trans-unit id="2f2d41854a72103d76672190b09df5c43a0666d7" translate="yes" xml:space="preserve">
          <source>Time, in seconds, after which connections are cleaned up from the pool.</source>
          <target state="translated">풀에서 연결이 정리되는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="af4e3e008d3d84e5d71b8056c4cb860bcee61b57" translate="yes" xml:space="preserve">
          <source>Time, in seconds, between runs of the pool's maintenance thread.</source>
          <target state="translated">풀의 유지 관리 스레드 실행 사이의 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="5633026c55c53b4292c025b0adbc6970f7a12239" translate="yes" xml:space="preserve">
          <source>Time, in seconds, that a connection can be pooled for before being destroyed. 0 denotes no limit.</source>
          <target state="translated">연결이 제거되기 전에 풀링 될 수있는 시간 (초)입니다. 0은 제한 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a15b84b66517aa2bf2de0082682c04f041d60c79" translate="yes" xml:space="preserve">
          <source>Time, in seconds, to wait before trying to acquire a connection again after an invalid connection was acquired.</source>
          <target state="translated">유효하지 않은 연결을 획득 한 후 다시 연결을 획득하기 전에 대기하는 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="36ef8b295ad08bdd5835f74cdc66de2e1332a7d3" translate="yes" xml:space="preserve">
          <source>Time-to-live of a message when sending. Enables QoS (Quality of Service) when set.</source>
          <target state="translated">보낼 때 메시지의 수명. 설정된 경우 QoS (서비스 품질)를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="fe08b01d8e2e106a9c750da662e001c52c32fe11" translate="yes" xml:space="preserve">
          <source>Time-to-live of the static resource cache.</source>
          <target state="translated">정적 리소스 캐시의 수명입니다.</target>
        </trans-unit>
        <trans-unit id="b4daf3ebec0205b3c5941c840e6f139a85eeaa8d" translate="yes" xml:space="preserve">
          <source>Timeout for `receive()` operations.</source>
          <target state="translated">`receive ()`작업 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="a4c01abbb5a190e1f666694a1c31b7595202bcbc" translate="yes" xml:space="preserve">
          <source>Timeout for `sendAndReceive()` operations.</source>
          <target state="translated">`sendAndReceive ()`작업 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e749bc73e79e06b505016ac86cc76bc4b48a32b" translate="yes" xml:space="preserve">
          <source>Timeout for borrowing connections from the pool.</source>
          <target state="translated">풀에서 연결을 차용하는 시간이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="ad68c7cd30ac34df9a64b0b1441e2b4d1044a3b4" translate="yes" xml:space="preserve">
          <source>Timeout for operations on a specific key-value with a durability level.</source>
          <target state="translated">내구성 수준이있는 특정 키-값에 대한 작업의 제한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="cd4079ad03b011219b9437a74d74a4b2ff22f438" translate="yes" xml:space="preserve">
          <source>Timeout for operations on a specific key-value.</source>
          <target state="translated">특정 키-값에 대한 작업 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="343f5afc92a52493a4bafa6b566c75becdf854ac" translate="yes" xml:space="preserve">
          <source>Timeout for the analytics service.</source>
          <target state="translated">분석 서비스의 제한 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2b5e18e5d99fc25ad2d6531a3ccdc1ca022aff69" translate="yes" xml:space="preserve">
          <source>Timeout for the management operations.</source>
          <target state="translated">관리 작업에 대한 시간 초과.</target>
        </trans-unit>
        <trans-unit id="8b030dd31deb534606f3933db3254b6ef5d2c4e3" translate="yes" xml:space="preserve">
          <source>Timeout for the search service.</source>
          <target state="translated">검색 서비스에 대한 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="97c62420c3106472b90dc919ae8289a61de2bfe0" translate="yes" xml:space="preserve">
          <source>Timeout for the shutdown of any phase (group of SmartLifecycle beans with the same 'phase' value).</source>
          <target state="translated">모든 단계 ( '단계'값이 동일한 SmartLifecycle Bean 그룹)의 종료 시간 초과.</target>
        </trans-unit>
        <trans-unit id="d96205316e07848c1427c856bbc6c2d6cd3c1a9b" translate="yes" xml:space="preserve">
          <source>Timeout to use for internal queries that run as part of the initialization process, just after a connection is opened.</source>
          <target state="translated">연결이 열린 직후 초기화 프로세스의 일부로 실행되는 내부 쿼리에 사용할 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="048e883b2751ff15fc925cd2c8f95b339cacea77" translate="yes" xml:space="preserve">
          <source>Timeout to use for receive calls.</source>
          <target state="translated">수신 전화에 사용할 시간 초과.</target>
        </trans-unit>
        <trans-unit id="d3eb9b5f3f03f8cf00aeb24095704a9e04160006" translate="yes" xml:space="preserve">
          <source>Timeout to use for receive calls. Use -1 for a no-wait receive or 0 for no timeout at all. The latter is only feasible if not running within a transaction manager and is generally discouraged since it prevents clean shutdown.</source>
          <target state="translated">수신 전화에 사용할 시간 초과. 대기하지 않는 수신에는 -1을 사용하고 시간 초과가없는 경우에는 0을 사용하십시오. 후자는 트랜잭션 관리자 내에서 실행되지 않는 경우에만 가능하며 정상적인 종료를 방지하므로 일반적으로 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ee815b47fb806e26cc5d8565b64b4cb27cce936" translate="yes" xml:space="preserve">
          <source>Timeout to use when establishing driver connections.</source>
          <target state="translated">드라이버 연결을 설정할 때 사용할 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="18617f279e6b6ec92a580f0a0ad7ac3ac4860b87" translate="yes" xml:space="preserve">
          <source>Timeout to use when polling the consumer.</source>
          <target state="translated">소비자를 폴링 할 때 사용할 시간 초과입니다.</target>
        </trans-unit>
        <trans-unit id="149832355c96122df1ffdd4b2e0ec7d3adfecdda" translate="yes" xml:space="preserve">
          <source>Timeout, in seconds, for acquiring connections from the pool.</source>
          <target state="translated">풀에서 연결을 확보하기위한 제한 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="3cdb59cee88af2120763f796e16f13e64a5de99b" translate="yes" xml:space="preserve">
          <source>Timeout, in seconds, for borrowing connections from the pool.</source>
          <target state="translated">풀에서 연결을 차용하기위한 제한 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="ab962604136c073fe7e13b7d03d0804820b94f77" translate="yes" xml:space="preserve">
          <source>Timeout, in seconds, for establishing a database connection.</source>
          <target state="translated">데이터베이스 연결 설정에 대한 제한 시간 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="a9e00d213e65d41eb8e3410116c58b0d62dd77d2" translate="yes" xml:space="preserve">
          <source>To &amp;ldquo;reset&amp;rdquo; the specific level of the logger (and use the default configuration instead), you can pass a value of &lt;code&gt;null&lt;/code&gt; as the &lt;code&gt;configuredLevel&lt;/code&gt;.</source>
          <target state="translated">로거의 특정 수준을 &quot;재설정&quot;(대신 기본 구성을 사용), 당신은의 값을 전달할 수 있습니다 &lt;code&gt;null&lt;/code&gt; 는 AS &lt;code&gt;configuredLevel&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="28ef52ad75ff027bf32fa0103b066cee4d9fdf23" translate="yes" xml:space="preserve">
          <source>To access MongoDB databases, you can inject an auto-configured &lt;code&gt;org.springframework.data.mongodb.MongoDatabaseFactory&lt;/code&gt;. By default, the instance tries to connect to a MongoDB server at &lt;code&gt;mongodb://localhost/test&lt;/code&gt;. The following example shows how to connect to a MongoDB database:</source>
          <target state="translated">MongoDB 데이터베이스에 액세스하려면 자동 구성된 &lt;code&gt;org.springframework.data.mongodb.MongoDatabaseFactory&lt;/code&gt; 를 삽입 할 수 있습니다 . 기본적으로 인스턴스는 &lt;code&gt;mongodb://localhost/test&lt;/code&gt; 에서 MongoDB 서버에 연결을 시도합니다 . 다음 예제는 MongoDB 데이터베이스에 연결하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6b2e6a79462b42f98f0ddebb1a416931398b299d" translate="yes" xml:space="preserve">
          <source>To access a Neo4j server, you can inject an auto-configured &lt;code&gt;org.neo4j.driver.Driver&lt;/code&gt;. By default, the instance tries to connect to a Neo4j server at &lt;code&gt;localhost:7687&lt;/code&gt; using the Bolt protocol. The following example shows how to inject a Neo4j &lt;code&gt;Driver&lt;/code&gt; that gives you access, amongst other things, to a &lt;code&gt;Session&lt;/code&gt;:</source>
          <target state="translated">Neo4j 서버에 액세스하려면 자동 구성된 &lt;code&gt;org.neo4j.driver.Driver&lt;/code&gt; 를 삽입 할 수 있습니다 . 기본적으로 인스턴스는 Bolt 프로토콜을 사용하여 &lt;code&gt;localhost:7687&lt;/code&gt; 에서 Neo4j 서버에 연결을 시도 합니다. 다음 예제는 무엇보다도 &lt;code&gt;Session&lt;/code&gt; 대한 액세스를 제공 하는 Neo4j &lt;code&gt;Driver&lt;/code&gt; 를 삽입하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="eddb65ac0fb7482cb7755c6f3f749537ff445381" translate="yes" xml:space="preserve">
          <source>To add a &lt;code&gt;Servlet&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, or Servlet &lt;code&gt;*Listener&lt;/code&gt; by using a Spring bean, you must provide a &lt;code&gt;@Bean&lt;/code&gt; definition for it. Doing so can be very useful when you want to inject configuration or dependencies. However, you must be very careful that they do not cause eager initialization of too many other beans, because they have to be installed in the container very early in the application lifecycle. (For example, it is not a good idea to have them depend on your &lt;code&gt;DataSource&lt;/code&gt; or JPA configuration.) You can work around such restrictions by initializing the beans lazily when first used instead of on initialization.</source>
          <target state="translated">Spring Bean을 사용하여 &lt;code&gt;Servlet&lt;/code&gt; , &lt;code&gt;Filter&lt;/code&gt; 또는 Servlet &lt;code&gt;*Listener&lt;/code&gt; 를 추가하려면 이에 대한 &lt;code&gt;@Bean&lt;/code&gt; 정의를 제공해야 합니다. 이렇게하면 구성 또는 종속성을 삽입 할 때 매우 유용 할 수 있습니다. 그러나 애플리케이션 라이프 사이클의 매우 초기에 컨테이너에 설치해야하므로 너무 많은 다른 Bean을 즉시 초기화하지 않도록주의해야합니다. (예를 들어, &lt;code&gt;DataSource&lt;/code&gt; 또는 JPA 구성 에 의존하도록하는 것은 좋은 생각이 아닙니다 .) 초기화 대신 처음 사용할 때 빈을 느리게 초기화하여 이러한 제한을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="498ca879cf0bac928c9eb892e8660d6416cafae9" translate="yes" xml:space="preserve">
          <source>To add additional logging during startup, you can override &lt;code&gt;logStartupInfo(boolean)&lt;/code&gt; in a subclass of &lt;code&gt;SpringApplication&lt;/code&gt;.</source>
          <target state="translated">시작시 추가 로깅을 추가하려면, 당신은 대체 할 수 있습니다 &lt;code&gt;logStartupInfo(boolean)&lt;/code&gt; 의 서브 클래스에 &lt;code&gt;SpringApplication&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1464a0158993f0aa3fb409307826b43e86e6429d" translate="yes" xml:space="preserve">
          <source>To add the actuator to a Maven based project, add the following &amp;lsquo;Starter&amp;rsquo; dependency:</source>
          <target state="translated">Maven 기반 프로젝트에 액추에이터를 추가하려면 다음 '스타터'종속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1783683a7bc3465e5ca2201eea584202d6b8b176" translate="yes" xml:space="preserve">
          <source>To add to the default tags, provide one or more &lt;code&gt;@Bean&lt;/code&gt;s that implement &lt;code&gt;WebFluxTagsContributor&lt;/code&gt;. To replace the default tags, provide a &lt;code&gt;@Bean&lt;/code&gt; that implements &lt;code&gt;WebFluxTagsProvider&lt;/code&gt;.</source>
          <target state="translated">기본 태그에 추가하려면 &lt;code&gt;WebFluxTagsContributor&lt;/code&gt; 를 구현 하는 하나 이상의 &lt;code&gt;@Bean&lt;/code&gt; 을 제공 하십시오 . 기본 태그를 대체하려면 &lt;code&gt;WebFluxTagsProvider&lt;/code&gt; 를 구현 하는 &lt;code&gt;@Bean&lt;/code&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fd6f9bbd6e31f23468b1b75277e1f1d41c8ca54" translate="yes" xml:space="preserve">
          <source>To add to the default tags, provide one or more &lt;code&gt;@Bean&lt;/code&gt;s that implement &lt;code&gt;WebMvcTagsContributor&lt;/code&gt;. To replace the default tags, provide a &lt;code&gt;@Bean&lt;/code&gt; that implements &lt;code&gt;WebMvcTagsProvider&lt;/code&gt;.</source>
          <target state="translated">기본 태그에 추가하려면 &lt;code&gt;WebMvcTagsContributor&lt;/code&gt; 를 구현 하는 하나 이상의 &lt;code&gt;@Bean&lt;/code&gt; 을 제공 하십시오 . 기본 태그를 대체하려면 &lt;code&gt;WebMvcTagsProvider&lt;/code&gt; 를 구현 하는 &lt;code&gt;@Bean&lt;/code&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="02aa24250a60b948a4451637cccebfd20b3f6fcf" translate="yes" xml:space="preserve">
          <source>To allow the input to be mapped to the operation method&amp;rsquo;s parameters, Java code implementing an endpoint should be compiled with &lt;code&gt;-parameters&lt;/code&gt;, and Kotlin code implementing an endpoint should be compiled with &lt;code&gt;-java-parameters&lt;/code&gt;. This will happen automatically if you are using Spring Boot&amp;rsquo;s Gradle plugin or if you are using Maven and &lt;code&gt;spring-boot-starter-parent&lt;/code&gt;.</source>
          <target state="translated">입력이 작업 메소드의 매개 변수에 매핑되도록하려면 엔드 포인트를 구현하는 자바 코드를 &lt;code&gt;-parameters&lt;/code&gt; 로 컴파일 하고 엔드 포인트를 구현하는 Kotlin 코드를 &lt;code&gt;-java-parameters&lt;/code&gt; 로 컴파일해야합니다 . 이는 Spring Boot의 Gradle 플러그인을 사용하거나 Maven 및 &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; 를 사용하는 경우 자동으로 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f1849861eee6d81fff7ee143f6deec466262e401" translate="yes" xml:space="preserve">
          <source>To allow your listener to distinguish between an event for its context and an event for a descendant context, it should request that its application context is injected and then compare the injected context with the context of the event. The context can be injected by implementing &lt;code&gt;ApplicationContextAware&lt;/code&gt; or, if the listener is a bean, by using &lt;code&gt;@Autowired&lt;/code&gt;.</source>
          <target state="translated">리스너가 컨텍스트에 대한 이벤트와 하위 컨텍스트에 대한 이벤트를 구별 할 수 있도록하려면 해당 애플리케이션 컨텍스트가 주입되도록 요청한 다음 주입 된 컨텍스트를 이벤트의 컨텍스트와 비교해야합니다. 컨텍스트는 &lt;code&gt;ApplicationContextAware&lt;/code&gt; 를 구현 하거나 리스너가 &lt;code&gt;@Autowired&lt;/code&gt; 를 사용하여 삽입 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="150c1630e8cfea4692c86d91d999e3a1e19d8991" translate="yes" xml:space="preserve">
          <source>To also switch off the &lt;code&gt;UserDetailsService&lt;/code&gt; configuration, you can add a bean of type &lt;code&gt;ReactiveUserDetailsService&lt;/code&gt; or &lt;code&gt;ReactiveAuthenticationManager&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UserDetailsService&lt;/code&gt; 구성 도 끄려면 &lt;code&gt;ReactiveUserDetailsService&lt;/code&gt; 또는 &lt;code&gt;ReactiveAuthenticationManager&lt;/code&gt; 유형의 Bean을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c0e01bce19ebe9e15821be388152d210901a4d6" translate="yes" xml:space="preserve">
          <source>To also switch off the &lt;code&gt;UserDetailsService&lt;/code&gt; configuration, you can add a bean of type &lt;code&gt;UserDetailsService&lt;/code&gt;, &lt;code&gt;AuthenticationProvider&lt;/code&gt;, or &lt;code&gt;AuthenticationManager&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;UserDetailsService&lt;/code&gt; 구성 도 끄려면 &lt;code&gt;UserDetailsService&lt;/code&gt; , &lt;code&gt;AuthenticationProvider&lt;/code&gt; 또는 &lt;code&gt;AuthenticationManager&lt;/code&gt; 유형의 Bean을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05e8831ca3d1f5bffc00fdd945c5396d1a35257d" translate="yes" xml:space="preserve">
          <source>To attach a remote debugger to a Spring Boot application that was started with Maven, you can use the &lt;code&gt;jvmArguments&lt;/code&gt; property of the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/&quot;&gt;maven plugin&lt;/a&gt;.</source>
          <target state="translated">Maven으로 시작한 Spring Boot 애플리케이션에 원격 디버거를 연결하려면 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/&quot;&gt;maven 플러그인&lt;/a&gt; 의 &lt;code&gt;jvmArguments&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bb7448aa7f52bec86f56d8498087659dc3caae7" translate="yes" xml:space="preserve">
          <source>To automatically run Flyway database migrations on startup, add the &lt;code&gt;org.flywaydb:flyway-core&lt;/code&gt; to your classpath.</source>
          <target state="translated">시작시 Flyway 데이터베이스 마이그레이션을 자동으로 실행하려면 &lt;code&gt;org.flywaydb:flyway-core&lt;/code&gt; 를 클래스 경로에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7cd8012ffc81e3d016e79e7aeddf8c402d9b1f8f" translate="yes" xml:space="preserve">
          <source>To automatically run Liquibase database migrations on startup, add the &lt;code&gt;org.liquibase:liquibase-core&lt;/code&gt; to your classpath.</source>
          <target state="translated">시작시 Liquibase 데이터베이스 마이그레이션을 자동으로 실행하려면 &lt;code&gt;org.liquibase:liquibase-core&lt;/code&gt; 를 클래스 경로에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="fbfbd010094acfd17280dbcb44e81206d43b1f53" translate="yes" xml:space="preserve">
          <source>To avoid hard-coding those names in your own config, you can reuse &lt;code&gt;BeanNames&lt;/code&gt; provided by Spring Data Couchbase. For instance, you can customize the converters to use, as follows:</source>
          <target state="translated">자신의 구성에서 이러한 이름을 하드 코딩하지 않으려면 SpringData Couchbase에서 제공하는 &lt;code&gt;BeanNames&lt;/code&gt; 를 재사용 할 수 있습니다 . 예를 들어 다음과 같이 사용할 변환기를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d768dca1fa3f46dc6929f476afd4d908840632f2" translate="yes" xml:space="preserve">
          <source>To build with Ant, you need to grab dependencies, compile, and then create a jar or war archive. To make it executable, you can either use the &lt;code&gt;spring-boot-antlib&lt;/code&gt; module or you can follow these instructions:</source>
          <target state="translated">Ant로 빌드하려면 종속성을 확보하고 컴파일 한 다음 jar 또는 war 아카이브를 만들어야합니다. 실행 가능하게하려면 &lt;code&gt;spring-boot-antlib&lt;/code&gt; 모듈을 사용하거나 다음 지침을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a120fcfd25654a1d5af1573b91d45dc10a79edc5" translate="yes" xml:space="preserve">
          <source>To change the error handling behavior, you can implement &lt;code&gt;ErrorWebExceptionHandler&lt;/code&gt; and register a bean definition of that type. Because a &lt;code&gt;WebExceptionHandler&lt;/code&gt; is quite low-level, Spring Boot also provides a convenient &lt;code&gt;AbstractErrorWebExceptionHandler&lt;/code&gt; to let you handle errors in a WebFlux functional way, as shown in the following example:</source>
          <target state="translated">오류 처리 동작을 변경하려면 &lt;code&gt;ErrorWebExceptionHandler&lt;/code&gt; 를 구현 하고 해당 유형의 Bean 정의를 등록 할 수 있습니다 . &lt;code&gt;WebExceptionHandler&lt;/code&gt; 는 매우 낮은 수준 이기 때문에 Spring Boot는 다음 예제와 같이 WebFlux 기능적인 방식으로 오류를 처리 할 수 있는 편리한 &lt;code&gt;AbstractErrorWebExceptionHandler&lt;/code&gt; 도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="263656a6a66ff3ce1a6ec8a258bebe379200cdbd" translate="yes" xml:space="preserve">
          <source>To change which endpoints are exposed, use the following technology-specific &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;exclude&lt;/code&gt; properties:</source>
          <target state="translated">노출되는 끝점을 변경하려면 다음과 같은 기술 별 &lt;code&gt;include&lt;/code&gt; 및 &lt;code&gt;exclude&lt;/code&gt; 속성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="45aa4d308528d2baeb4927668eb8de491398f9a8" translate="yes" xml:space="preserve">
          <source>To compile and run the application, type the following command:</source>
          <target state="translated">응용 프로그램을 컴파일하고 실행하려면 다음 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3f4a87ebbb18c2a7ff84ad5941afaf7f95d1f039" translate="yes" xml:space="preserve">
          <source>To configure Spring Security to require a secure channel for all (or some) requests, consider adding your own &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; that adds the following &lt;code&gt;HttpSecurity&lt;/code&gt; configuration:</source>
          <target state="translated">모든 (또는 일부) 요청에 대해 보안 채널을 요구하도록 Spring Security를 ​​구성하려면 다음 &lt;code&gt;HttpSecurity&lt;/code&gt; 구성 을 추가하는 자체 &lt;code&gt;WebSecurityConfigurerAdapter&lt;/code&gt; 를 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="094afe33a50e821139413245ebaacab37f668a71" translate="yes" xml:space="preserve">
          <source>To configure a bean from the &lt;code&gt;Environment&lt;/code&gt; properties, add &lt;code&gt;@ConfigurationProperties&lt;/code&gt; to its bean registration, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;Environment&lt;/code&gt; 특성 에서 Bean을 구성하려면 다음 예제에 표시된대로 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 를 Bean 등록에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="0eb3d6f89f580d16912047b819752254008a11ff" translate="yes" xml:space="preserve">
          <source>To configure a classifier of &lt;code&gt;exec&lt;/code&gt; in Maven, you can use the following configuration:</source>
          <target state="translated">Maven에서 &lt;code&gt;exec&lt;/code&gt; 의 분류 자를 구성하려면 다음 구성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fa53d14e43882d840de7380ad76ca082e9059a9" translate="yes" xml:space="preserve">
          <source>To configure a given logger, &lt;code&gt;POST&lt;/code&gt; a partial entity to the resource&amp;rsquo;s URI, as shown in the following example:</source>
          <target state="translated">지정된 로거를 구성하려면 다음 예와 같이 리소스의 URI에 부분 엔티티를 &lt;code&gt;POST&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="df60b66c308ed6fb3336ca108e162016a4e12494" translate="yes" xml:space="preserve">
          <source>To configure the more fine-grained settings of a logging system, you need to use the native configuration format supported by the &lt;code&gt;LoggingSystem&lt;/code&gt; in question. By default, Spring Boot picks up the native configuration from its default location for the system (such as &lt;code&gt;classpath:logback.xml&lt;/code&gt; for Logback), but you can set the location of the config file by using the &lt;code&gt;logging.config&lt;/code&gt; property.</source>
          <target state="translated">로깅 시스템의보다 세분화 된 설정을 구성하려면 해당 &lt;code&gt;LoggingSystem&lt;/code&gt; 에서 지원하는 기본 구성 형식을 사용해야합니다 . 기본적으로 Spring Boot는 시스템의 기본 위치 (예 &lt;code&gt;classpath:logback.xml&lt;/code&gt; Logback의 경우 classpath : logback.xml ) 에서 기본 구성을 선택 하지만 &lt;code&gt;logging.config&lt;/code&gt; 속성 을 사용하여 구성 파일의 위치를 ​​설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba815de84baf35508fce18f28f3791c04784ea15" translate="yes" xml:space="preserve">
          <source>To configure the timeout period, configure the &lt;code&gt;spring.lifecycle.timeout-per-shutdown-phase&lt;/code&gt; property, as shown in the following example:</source>
          <target state="translated">시간 초과 기간을 구성하려면 다음 예와 같이 &lt;code&gt;spring.lifecycle.timeout-per-shutdown-phase&lt;/code&gt; 속성을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="9a5f4605d493e9ca5c574421ff3ffd8eea88deb4" translate="yes" xml:space="preserve">
          <source>To configure your own &lt;code&gt;DataSource&lt;/code&gt;, define a &lt;code&gt;@Bean&lt;/code&gt; of that type in your configuration. Spring Boot reuses your &lt;code&gt;DataSource&lt;/code&gt; anywhere one is required, including database initialization. If you need to externalize some settings, you can bind your &lt;code&gt;DataSource&lt;/code&gt; to the environment (see &amp;ldquo;&lt;a href=&quot;spring-boot-features#boot-features-external-config-3rd-party-configuration&quot;&gt;spring-boot-features.html&lt;/a&gt;&amp;rdquo;).</source>
          <target state="translated">자신의 &lt;code&gt;DataSource&lt;/code&gt; 를 구성하려면 구성 에서 해당 유형 의 &lt;code&gt;@Bean&lt;/code&gt; 을 정의 하십시오. Spring Boot는 데이터베이스 초기화를 포함하여 필요한 곳 ​​어디에서나 &lt;code&gt;DataSource&lt;/code&gt; 를 재사용합니다 . 일부 설정을 외부화해야하는 경우 &lt;code&gt;DataSource&lt;/code&gt; 를 환경에 바인딩 할 수 있습니다 (&amp;ldquo; &lt;a href=&quot;spring-boot-features#boot-features-external-config-3rd-party-configuration&quot;&gt;spring-boot-features.html&lt;/a&gt; &amp;rdquo;참조).</target>
        </trans-unit>
        <trans-unit id="3614c5610f797a9ad43114f242fc0e6750f27e46" translate="yes" xml:space="preserve">
          <source>To connect to Elasticsearch, a &lt;code&gt;RestHighLevelClient&lt;/code&gt; bean must be defined, auto-configured by Spring Boot or manually provided by the application (see previous sections). With this configuration in place, an &lt;code&gt;ElasticsearchRestTemplate&lt;/code&gt; can be injected like any other Spring bean, as shown in the following example:</source>
          <target state="translated">Elasticsearch에 연결하려면 &lt;code&gt;RestHighLevelClient&lt;/code&gt; 빈을 정의하고 Spring Boot에 의해 자동 구성하거나 애플리케이션에서 수동으로 제공해야합니다 (이전 섹션 참조). 이 구성을 사용 하면 다음 예제와 같이 &lt;code&gt;ElasticsearchRestTemplate&lt;/code&gt; 을 다른 Spring Bean처럼 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7be3febdc837b8d2b3ede9a7350331aa8e78f674" translate="yes" xml:space="preserve">
          <source>To connect to an LDAP server, make sure you declare a dependency on the &lt;code&gt;spring-boot-starter-data-ldap&lt;/code&gt; &amp;ldquo;Starter&amp;rdquo; or &lt;code&gt;spring-ldap-core&lt;/code&gt; and then declare the URLs of your server in your application.properties, as shown in the following example:</source>
          <target state="translated">LDAP 서버에 연결하려면 다음과 같이 &lt;code&gt;spring-boot-starter-data-ldap&lt;/code&gt; &amp;ldquo;Starter&amp;rdquo;또는 &lt;code&gt;spring-ldap-core&lt;/code&gt; 에 대한 종속성을 선언 한 다음 application.properties에서 서버의 URL을 선언해야합니다. 다음 예 :</target>
        </trans-unit>
        <trans-unit id="510fca515d585954e9818889dd81b3237dca2d5a" translate="yes" xml:space="preserve">
          <source>To convert a property name in the canonical-form to an environment variable name you can follow these rules:</source>
          <target state="translated">canonical-form의 속성 이름을 환경 변수 이름으로 변환하려면 다음 규칙을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7135357c3b294e37ae76ba918e840703f755bd71" translate="yes" xml:space="preserve">
          <source>To convert an existing non-web Spring application to a Spring Boot application, replace the code that creates your &lt;code&gt;ApplicationContext&lt;/code&gt; and replace it with calls to &lt;code&gt;SpringApplication&lt;/code&gt; or &lt;code&gt;SpringApplicationBuilder&lt;/code&gt;. Spring MVC web applications are generally amenable to first creating a deployable war application and then migrating it later to an executable war or jar. See the &lt;a href=&quot;https://spring.io/guides/gs/convert-jar-to-war/&quot;&gt;Getting Started Guide on Converting a jar to a war&lt;/a&gt;.</source>
          <target state="translated">기존의 웹이 아닌 Spring 애플리케이션을 Spring Boot 애플리케이션으로 변환하려면 &lt;code&gt;ApplicationContext&lt;/code&gt; 를 생성하는 코드를 대체하고 &lt;code&gt;SpringApplication&lt;/code&gt; 또는 &lt;code&gt;SpringApplicationBuilder&lt;/code&gt; 에 대한 호출로 대체합니다 . Spring MVC 웹 애플리케이션은 일반적으로 먼저 배포 가능한 war 애플리케이션을 만든 다음 나중에 실행 가능한 war 또는 jar로 마이그레이션 할 수 있습니다. &lt;a href=&quot;https://spring.io/guides/gs/convert-jar-to-war/&quot;&gt;항아리를 전쟁으로 변환에 대한 시작 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="60697af70adf614cf8c974099c63aa68683a7a34" translate="yes" xml:space="preserve">
          <source>To create a &amp;lsquo;fully executable&amp;rsquo; jar with Maven, use the following plugin configuration:</source>
          <target state="translated">Maven으로 '완전히 실행 가능한'jar를 생성하려면 다음 플러그인 구성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="66cba0e23c97e083689bdcf88270ceff9d05aacc" translate="yes" xml:space="preserve">
          <source>To create a deployable war by extending &lt;code&gt;SpringBootServletInitializer&lt;/code&gt; (for example, in a class called &lt;code&gt;Application&lt;/code&gt;) and adding the Spring Boot &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotation, use code similar to that shown in the following example:</source>
          <target state="translated">&lt;code&gt;SpringBootServletInitializer&lt;/code&gt; 를 확장하고 (예 : &lt;code&gt;Application&lt;/code&gt; 이라는 클래스에서 ) Spring Boot &lt;code&gt;@SpringBootApplication&lt;/code&gt; 주석을 추가하여 배포 가능한 전쟁을 생성하려면 다음 예제에 표시된 것과 유사한 코드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d70942ebc7e96b4ffefe4f6159d05515820e1869" translate="yes" xml:space="preserve">
          <source>To create a health indicator group you can use the &lt;code&gt;management.endpoint.health.group.&amp;lt;name&amp;gt;&lt;/code&gt; property and specify a list of health indicator IDs to &lt;code&gt;include&lt;/code&gt; or &lt;code&gt;exclude&lt;/code&gt;. For example, to create a group that includes only database indicators you can define the following:</source>
          <target state="translated">Health 표시기 그룹을 생성하려면 &lt;code&gt;management.endpoint.health.group.&amp;lt;name&amp;gt;&lt;/code&gt; 속성을 사용하고 &lt;code&gt;include&lt;/code&gt; 하거나 &lt;code&gt;exclude&lt;/code&gt; 할 Health 표시기 ID 목록을 지정할 수 있습니다 . 예를 들어 데이터베이스 표시기 만 포함하는 그룹을 생성하려면 다음을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2091755f98c3824ef06a6689ff037e3bc6dc1bb" translate="yes" xml:space="preserve">
          <source>To create a topic on startup, add a bean of type &lt;code&gt;NewTopic&lt;/code&gt;. If the topic already exists, the bean is ignored.</source>
          <target state="translated">시작시 토픽을 작성하려면 &lt;code&gt;NewTopic&lt;/code&gt; 유형의 Bean을 추가하십시오 . 토픽이 이미 존재하는 경우 Bean은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="2b58b9847dab84d6686dc2d3c224dee06d642482" translate="yes" xml:space="preserve">
          <source>To create an executable jar, we need to add the &lt;code&gt;spring-boot-maven-plugin&lt;/code&gt; to our &lt;code&gt;pom.xml&lt;/code&gt;. To do so, insert the following lines just below the &lt;code&gt;dependencies&lt;/code&gt; section:</source>
          <target state="translated">실행 가능한 jar를 생성하려면 &lt;code&gt;spring-boot-maven-plugin&lt;/code&gt; 을 &lt;code&gt;pom.xml&lt;/code&gt; 에 추가해야합니다 . 이렇게하려면 &lt;code&gt;dependencies&lt;/code&gt; 섹션 바로 아래에 다음 줄을 삽입 하십시오.</target>
        </trans-unit>
        <trans-unit id="7a7a46c4a1b17e5f9408c54afe8453ea92aec6d8" translate="yes" xml:space="preserve">
          <source>To customize published security events, you can provide your own implementations of &lt;code&gt;AbstractAuthenticationAuditListener&lt;/code&gt; and &lt;code&gt;AbstractAuthorizationAuditListener&lt;/code&gt;.</source>
          <target state="translated">게시 된 보안 이벤트를 사용자 지정하기 위해 &lt;code&gt;AbstractAuthenticationAuditListener&lt;/code&gt; 및 &lt;code&gt;AbstractAuthorizationAuditListener&lt;/code&gt; 의 자체 구현을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15dc6ed63f28d69b442cdf002d107f69a700d63f" translate="yes" xml:space="preserve">
          <source>To customize the &lt;code&gt;WebTestClient&lt;/code&gt; bean, configure a &lt;code&gt;WebTestClientBuilderCustomizer&lt;/code&gt; bean. Any such beans are called with the &lt;code&gt;WebTestClient.Builder&lt;/code&gt; that is used to create the &lt;code&gt;WebTestClient&lt;/code&gt;.</source>
          <target state="translated">사용자 정의하기 &lt;code&gt;WebTestClient&lt;/code&gt; 의 콩을하는 구성 &lt;code&gt;WebTestClientBuilderCustomizer&lt;/code&gt; 의 콩을. 그러한 콩은 호출하는 &lt;code&gt;WebTestClient.Builder&lt;/code&gt; 작성하는 데 사용됩니다 &lt;code&gt;WebTestClient&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="c36d6af6b3a283b0cb9dcd89a1b146a0fc1bbec2" translate="yes" xml:space="preserve">
          <source>To customize the connections created by a &lt;code&gt;ConnectionFactory&lt;/code&gt;, i.e., set specific parameters that you do not want (or cannot) configure in your central database configuration, you can use a &lt;code&gt;ConnectionFactoryOptionsBuilderCustomizer&lt;/code&gt;&lt;code&gt;@Bean&lt;/code&gt;. The following example shows how to manually override the database port while the rest of the options is taken from the application configuration:</source>
          <target state="translated">&lt;code&gt;ConnectionFactory&lt;/code&gt; 에 의해 생성 된 연결을 사용자 정의하려면 , 즉 중앙 데이터베이스 구성에서 구성하지 않거나 구성 할 수없는 특정 매개 변수를 설정하려면 &lt;code&gt;ConnectionFactoryOptionsBuilderCustomizer&lt;/code&gt; &lt;code&gt;@Bean&lt;/code&gt; 을 사용할 수 있습니다 . 다음 예제는 애플리케이션 구성에서 나머지 옵션을 가져 오는 동안 데이터베이스 포트를 수동으로 대체하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e4763acf34b90430955dad0a20a11ac247924109" translate="yes" xml:space="preserve">
          <source>To customize the items that are included in each trace, use the &lt;code&gt;management.trace.http.include&lt;/code&gt; configuration property. For advanced customization, consider registering your own &lt;code&gt;HttpExchangeTracer&lt;/code&gt; implementation.</source>
          <target state="translated">각 추적에 포함 된 항목을 사용자 정의하려면 &lt;code&gt;management.trace.http.include&lt;/code&gt; 구성 특성을 사용하십시오 . 고급 사용자 지정의 경우 고유 한 &lt;code&gt;HttpExchangeTracer&lt;/code&gt; 구현을 등록 하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ba931925192105ae62d8ee1859dc49660955fcf7" translate="yes" xml:space="preserve">
          <source>To customize the tags, and depending on your choice of client, you can provide a &lt;code&gt;@Bean&lt;/code&gt; that implements &lt;code&gt;RestTemplateExchangeTagsProvider&lt;/code&gt; or &lt;code&gt;WebClientExchangeTagsProvider&lt;/code&gt;. There are convenience static functions in &lt;code&gt;RestTemplateExchangeTags&lt;/code&gt; and &lt;code&gt;WebClientExchangeTags&lt;/code&gt;.</source>
          <target state="translated">태그를 사용자 정의하고 선택한 클라이언트에 따라 &lt;code&gt;RestTemplateExchangeTagsProvider&lt;/code&gt; 또는 &lt;code&gt;WebClientExchangeTagsProvider&lt;/code&gt; 를 구현 하는 &lt;code&gt;@Bean&lt;/code&gt; 을 제공 할 수 있습니다 . &lt;code&gt;RestTemplateExchangeTags&lt;/code&gt; 및 &lt;code&gt;WebClientExchangeTags&lt;/code&gt; 에는 편리한 정적 함수가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18868922145d54b5df1c1ee2e5e559a7b11e0a62" translate="yes" xml:space="preserve">
          <source>To customize the tags, provide a &lt;code&gt;@Bean&lt;/code&gt; that implements &lt;code&gt;JerseyTagsProvider&lt;/code&gt;.</source>
          <target state="translated">태그를 사용자 정의하려면 &lt;code&gt;JerseyTagsProvider&lt;/code&gt; 를 구현 하는 &lt;code&gt;@Bean&lt;/code&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="1290dbb07196bfa6b85125f663324b0814f6c1fd" translate="yes" xml:space="preserve">
          <source>To customize written elements, use the &lt;code&gt;embeddedLaunchScriptProperties&lt;/code&gt; option of the Spring Boot Maven plugin or the &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/gradle-plugin/reference/htmlsingle/#packaging-executable-configuring-launch-script&quot;&gt;&lt;code&gt;properties&lt;/code&gt; property of the Spring Boot Gradle plugin&amp;rsquo;s &lt;code&gt;launchScript&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작성된 요소를 맞춤 설정하려면 Spring Boot Maven 플러그인 의 &lt;code&gt;embeddedLaunchScriptProperties&lt;/code&gt; 옵션 또는 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/gradle-plugin/reference/htmlsingle/#packaging-executable-configuring-launch-script&quot;&gt;Spring Boot Gradle 플러그인의 &lt;/a&gt; &lt;code&gt;launchScript&lt;/code&gt; &lt;code&gt;properties&lt;/code&gt; 속성을 사용 하세요 .</target>
        </trans-unit>
        <trans-unit id="0051988b42a02e8b294f4aea87a821ff847b3b2f" translate="yes" xml:space="preserve">
          <source>To deal with any problematic libraries, you can flag that specific nested jars should be automatically unpacked when the executable jar first runs. Such nested jars are written beneath the temporary directory identified by the &lt;code&gt;java.io.tmpdir&lt;/code&gt; system property.</source>
          <target state="translated">문제가있는 라이브러리를 처리하기 위해 실행 가능한 jar가 처음 실행될 때 특정 중첩 jar가 자동으로 압축 해제되도록 플래그를 지정할 수 있습니다. 이러한 중첩 된 jar는 &lt;code&gt;java.io.tmpdir&lt;/code&gt; 시스템 속성으로 식별되는 임시 디렉토리 아래에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="67d02995ac6d297ce2728981a0728dcacd13e236" translate="yes" xml:space="preserve">
          <source>To declare dependencies, a typical &lt;code&gt;ivy.xml&lt;/code&gt; file looks something like the following example:</source>
          <target state="translated">종속성을 선언하기 위해 일반적인 &lt;code&gt;ivy.xml&lt;/code&gt; 파일은 다음 예제와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="2354665a5159e6ca3204eae688affbfb88a9b08c" translate="yes" xml:space="preserve">
          <source>To deploy a Spring Boot application to WebLogic, you must ensure that your servlet initializer &lt;strong&gt;directly&lt;/strong&gt; implements &lt;code&gt;WebApplicationInitializer&lt;/code&gt; (even if you extend from a base class that already implements it).</source>
          <target state="translated">Spring Boot 애플리케이션을 WebLogic에 배포하려면 서블릿 이니셜 라이저가 &lt;code&gt;WebApplicationInitializer&lt;/code&gt; 를&lt;strong&gt;직접&lt;/strong&gt; 구현 하는지 확인해야합니다 (이미 구현 한 기본 클래스에서 확장하더라도).</target>
        </trans-unit>
        <trans-unit id="6ce3397cf40a76a4a52e0936c4801717e4766a2b" translate="yes" xml:space="preserve">
          <source>To disable the logging of the report, set the following property:</source>
          <target state="translated">보고서 로깅을 비활성화하려면 다음 속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c72382fa82b26ba692919be6dfc63b7f130056d3" translate="yes" xml:space="preserve">
          <source>To do this with JCache, first make sure that &lt;code&gt;org.hibernate:hibernate-jcache&lt;/code&gt; is available on the classpath. Then, add a &lt;code&gt;HibernatePropertiesCustomizer&lt;/code&gt; bean as shown in the following example:</source>
          <target state="translated">JCache로이를 수행하려면 먼저 &lt;code&gt;org.hibernate:hibernate-jcache&lt;/code&gt; 가 클래스 경로에서 사용 가능한지 확인하십시오 . 그런 다음 다음 예제와 같이 &lt;code&gt;HibernatePropertiesCustomizer&lt;/code&gt; 빈을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="4811ae8df2b7617dc82499cdeb8310578aa52798" translate="yes" xml:space="preserve">
          <source>To enable HTTP/2 with cleartext support, you need to leave the &lt;code&gt;server.http2.enabled&lt;/code&gt; property set to &lt;code&gt;false&lt;/code&gt;, and instead apply a customizer specific to your choice of server:</source>
          <target state="translated">일반 텍스트 지원과 함께 HTTP / 2를 활성화하려면 &lt;code&gt;server.http2.enabled&lt;/code&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정 하고 대신 선택한 서버에 맞는 사용자 지정 프로그램을 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="49a2631d1fa2afce31066cbd7f9087426dce47e5" translate="yes" xml:space="preserve">
          <source>To enable graceful shutdown, configure the &lt;code&gt;server.shutdown&lt;/code&gt; property, as shown in the following example:</source>
          <target state="translated">정상 종료를 활성화하려면 다음 예와 같이 &lt;code&gt;server.shutdown&lt;/code&gt; 속성을 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="bd810316d0f977881eaebd063add2fc734fcaa7a" translate="yes" xml:space="preserve">
          <source>To enable it, you need to make sure that &lt;code&gt;devtools&lt;/code&gt; is included in the repackaged archive, as shown in the following listing:</source>
          <target state="translated">이를 활성화하려면 다음 목록에 표시된 것처럼 &lt;code&gt;devtools&lt;/code&gt; 가 리 패키징 된 아카이브에 포함되어 있는지 확인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9f862771b780444d18d657a6a7948b5c5ba808de" translate="yes" xml:space="preserve">
          <source>To enable statistics, the standard JPA property &lt;code&gt;hibernate.generate_statistics&lt;/code&gt; must be set to &lt;code&gt;true&lt;/code&gt;. You can enable that on the auto-configured &lt;code&gt;EntityManagerFactory&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">통계를 활성화하려면 표준 JPA 속성 &lt;code&gt;hibernate.generate_statistics&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정해야 합니다 . 다음 예제와 같이 자동 구성된 &lt;code&gt;EntityManagerFactory&lt;/code&gt; 에서이를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f6526605b9483d1ef312c31ebbeb0433b4f2f28" translate="yes" xml:space="preserve">
          <source>To ensure that debug logging performed using &lt;code&gt;java.util.logging&lt;/code&gt; is routed into Log4j 2, configure its &lt;a href=&quot;https://logging.apache.org/log4j/2.x/log4j-jul/index.html&quot;&gt;JDK logging adapter&lt;/a&gt; by setting the &lt;code&gt;java.util.logging.manager&lt;/code&gt; system property to &lt;code&gt;org.apache.logging.log4j.jul.LogManager&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;java.util.logging&lt;/code&gt; 을 사용하여 수행 된 디버그 로깅 이 Log4j 2로 라우팅되도록 하려면 &lt;code&gt;java.util.logging.manager&lt;/code&gt; 시스템 특성을 &lt;code&gt;org.apache.logging.log4j.jul.LogManager&lt;/code&gt; 로 설정하여 &lt;a href=&quot;https://logging.apache.org/log4j/2.x/log4j-jul/index.html&quot;&gt;JDK 로깅 어댑터&lt;/a&gt; 를 구성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a66da54df81e5efdc52cfed720ad2331a3162336" translate="yes" xml:space="preserve">
          <source>To ensure that multiple transaction managers can safely coordinate the same resource managers, each Atomikos instance must be configured with a unique ID. By default, this ID is the IP address of the machine on which Atomikos is running. To ensure uniqueness in production, you should configure the &lt;code&gt;spring.jta.transaction-manager-id&lt;/code&gt; property with a different value for each instance of your application.</source>
          <target state="translated">여러 트랜잭션 관리자가 동일한 리소스 관리자를 안전하게 조정할 수 있도록하려면 각 Atomikos 인스턴스를 고유 한 ID로 구성해야합니다. 기본적으로이 ID는 Atomikos가 실행중인 시스템의 IP 주소입니다. 프로덕션에서 고유성을 보장하려면 애플리케이션의 각 인스턴스에 대해 다른 값으로 &lt;code&gt;spring.jta.transaction-manager-id&lt;/code&gt; 속성을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="50a3eead8cc279f0662c98f43f1060639c4a2520" translate="yes" xml:space="preserve">
          <source>To ensure that multiple transaction managers can safely coordinate the same resource managers, each Bitronix instance must be configured with a unique ID. By default, this ID is the IP address of the machine on which Bitronix is running. To ensure uniqueness in production, you should configure the &lt;code&gt;spring.jta.transaction-manager-id&lt;/code&gt; property with a different value for each instance of your application.</source>
          <target state="translated">여러 트랜잭션 관리자가 동일한 리소스 관리자를 안전하게 조정할 수 있도록하려면 각 Bitronix 인스턴스를 고유 한 ID로 구성해야합니다. 기본적으로이 ID는 Bitronix가 실행중인 시스템의 IP 주소입니다. 프로덕션에서 고유성을 보장하려면 애플리케이션의 각 인스턴스에 대해 다른 값으로 &lt;code&gt;spring.jta.transaction-manager-id&lt;/code&gt; 속성을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3238fd6522a2454690f389aac4090ac842f05093" translate="yes" xml:space="preserve">
          <source>To ensure that validation is always triggered for nested properties, even when no properties are found, the associated field must be annotated with &lt;code&gt;@Valid&lt;/code&gt;. The following example builds on the preceding &lt;code&gt;AcmeProperties&lt;/code&gt; example:</source>
          <target state="translated">속성이없는 경우에도 중첩 된 속성에 대해 유효성 검사가 항상 트리거되도록하려면 관련 필드에 &lt;code&gt;@Valid&lt;/code&gt; 주석을 추가해야합니다 . 다음 예제는 앞의 &lt;code&gt;AcmeProperties&lt;/code&gt; 예제 를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="becbcb1c7f2c9d46d5e507483b5adbc6ec29222a" translate="yes" xml:space="preserve">
          <source>To finish our application, we need to create a single Java file. By default, Maven compiles sources from &lt;code&gt;src/main/java&lt;/code&gt;, so you need to create that directory structure and then add a file named &lt;code&gt;src/main/java/Example.java&lt;/code&gt; to contain the following code:</source>
          <target state="translated">응용 프로그램을 완료하려면 단일 Java 파일을 만들어야합니다. 기본적으로 Maven은 &lt;code&gt;src/main/java&lt;/code&gt; 에서 소스를 컴파일 하므로 해당 디렉토리 구조를 만든 다음 &lt;code&gt;src/main/java/Example.java&lt;/code&gt; 라는 파일을 추가 하여 다음 코드를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="6948ccd651fe5324cd6cad1724548914d17318d2" translate="yes" xml:space="preserve">
          <source>To flag the application to start automatically on system boot, use the following command:</source>
          <target state="translated">시스템 부팅시 자동으로 시작되도록 애플리케이션에 플래그를 지정하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="de168255ca588720e127cccfd4f3c52ee0d8f3a3" translate="yes" xml:space="preserve">
          <source>To generate &lt;a href=&quot;appendix-configuration-metadata#configuration-metadata-annotation-processor&quot;&gt;your own metadata&lt;/a&gt; using the annotation processor, &lt;a href=&quot;https://kotlinlang.org/docs/reference/kapt.html&quot;&gt;&lt;code&gt;kapt&lt;/code&gt; should be configured&lt;/a&gt; with the &lt;code&gt;spring-boot-configuration-processor&lt;/code&gt; dependency. Note that some features (such as detecting the default value or deprecated items) are not working due to limitations in the model kapt provides.</source>
          <target state="translated">생성하기 위해 &lt;a href=&quot;appendix-configuration-metadata#configuration-metadata-annotation-processor&quot;&gt;자신의 메타 데이터를&lt;/a&gt; 주석 프로세서를 사용하여, &lt;a href=&quot;https://kotlinlang.org/docs/reference/kapt.html&quot;&gt; &lt;code&gt;kapt&lt;/code&gt; 을 구성해야&lt;/a&gt; 와 &lt;code&gt;spring-boot-configuration-processor&lt;/code&gt; 의존성. kapt가 제공하는 모델의 제한으로 인해 일부 기능 (예 : 기본값 또는 사용되지 않는 항목 감지)이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bfd8106708bd40de81d253e32fc14c42ed65b3b" translate="yes" xml:space="preserve">
          <source>To generate build information with Maven, add an execution for the &lt;code&gt;build-info&lt;/code&gt; goal, as shown in the following example:</source>
          <target state="translated">Maven으로 빌드 정보를 생성하려면 다음 예와 같이 &lt;code&gt;build-info&lt;/code&gt; 목표 에 대한 실행을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="3b022bfd0344ad349bcaf9fb88bcdeda959ac448" translate="yes" xml:space="preserve">
          <source>To get started with Jersey, include the &lt;code&gt;spring-boot-starter-jersey&lt;/code&gt; as a dependency and then you need one &lt;code&gt;@Bean&lt;/code&gt; of type &lt;code&gt;ResourceConfig&lt;/code&gt; in which you register all the endpoints, as shown in the following example:</source>
          <target state="translated">Jersey를 시작하려면 &lt;code&gt;spring-boot-starter-jersey&lt;/code&gt; 를 종속성 으로 포함시킨 다음 다음 예제와 같이 모든 엔드 포인트를 등록하는 &lt;code&gt;ResourceConfig&lt;/code&gt; 유형의 &lt;code&gt;@Bean&lt;/code&gt; 하나가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="ba257093d8b60c5fc142ccea369a7d4570145da7" translate="yes" xml:space="preserve">
          <source>To get started, add the &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; module to your application.</source>
          <target state="translated">시작하려면 애플리케이션에 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 모듈을 추가하세요.</target>
        </trans-unit>
        <trans-unit id="7a2d1e5ea6d8b889b0e95d591f85b446e700391f" translate="yes" xml:space="preserve">
          <source>To get the server to render XML instead of JSON, you might have to send an &lt;code&gt;Accept: text/xml&lt;/code&gt; header (or use a browser).</source>
          <target state="translated">서버가 JSON 대신 XML을 렌더링하도록하려면 &lt;code&gt;Accept: text/xml&lt;/code&gt; 헤더 를 보내야 하거나 브라우저를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e0dbeb0a1dc6b66fcbc497e6ce78a566faea12db" translate="yes" xml:space="preserve">
          <source>To gracefully exit the application, press &lt;code&gt;ctrl-c&lt;/code&gt;.</source>
          <target state="translated">애플리케이션을 정상적으로 종료하려면 &lt;code&gt;ctrl-c&lt;/code&gt; 를 누르십시오 .</target>
        </trans-unit>
        <trans-unit id="ef85cd41a4242d226b74c1484c09dda460940ad6" translate="yes" xml:space="preserve">
          <source>To handle the error automatically, consider extending from &lt;code&gt;AbstractReactiveHealthIndicator&lt;/code&gt;.</source>
          <target state="translated">오류를 자동으로 처리하려면 &lt;code&gt;AbstractReactiveHealthIndicator&lt;/code&gt; 에서 확장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d1d47eb5019e2680d6f961d132e5ab2bba3e68d3" translate="yes" xml:space="preserve">
          <source>To handle this scenario, a separate &lt;code&gt;@Configuration&lt;/code&gt; class can be used to isolate the condition, as shown in the following example:</source>
          <target state="translated">이 시나리오를 처리하기 위해 다음 예제와 같이 별도의 &lt;code&gt;@Configuration&lt;/code&gt; 클래스를 사용하여 조건을 격리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1a562dd8f28c94acfed6f2090261f9132a6ffd5d" translate="yes" xml:space="preserve">
          <source>To have Quartz use a &lt;code&gt;DataSource&lt;/code&gt; other than the application&amp;rsquo;s main &lt;code&gt;DataSource&lt;/code&gt;, declare a &lt;code&gt;DataSource&lt;/code&gt; bean, annotating its &lt;code&gt;@Bean&lt;/code&gt; method with &lt;code&gt;@QuartzDataSource&lt;/code&gt;. Doing so ensures that the Quartz-specific &lt;code&gt;DataSource&lt;/code&gt; is used by both the &lt;code&gt;SchedulerFactoryBean&lt;/code&gt; and for schema initialization. Similarly, to have Quartz use a &lt;code&gt;TransactionManager&lt;/code&gt; other than the application&amp;rsquo;s main &lt;code&gt;TransactionManager&lt;/code&gt; declare a &lt;code&gt;TransactionManager&lt;/code&gt; bean, annotating its &lt;code&gt;@Bean&lt;/code&gt; method with &lt;code&gt;@QuartzTransactionManager&lt;/code&gt;.</source>
          <target state="translated">Quartz 가 애플리케이션의 주요 &lt;code&gt;DataSource&lt;/code&gt; 이외의 &lt;code&gt;DataSource&lt;/code&gt; 를 사용하게하려면 &lt;code&gt;DataSource&lt;/code&gt; bean을 선언 하고 &lt;code&gt;@Bean&lt;/code&gt; 메소드에 &lt;code&gt;@QuartzDataSource&lt;/code&gt; 주석 을 추가 합니다. 이렇게하면 Quartz 특정 &lt;code&gt;DataSource&lt;/code&gt; 가 &lt;code&gt;SchedulerFactoryBean&lt;/code&gt; 과 스키마 초기화 모두에서 사용됩니다 . 마찬가지로 Quartz 가 애플리케이션의 메인 &lt;code&gt;TransactionManager&lt;/code&gt; 가 아닌 &lt;code&gt;TransactionManager&lt;/code&gt; 를 사용하도록하려면 &lt;code&gt;TransactionManager&lt;/code&gt; bean을 선언 하고 &lt;code&gt;@Bean&lt;/code&gt; 메소드에 &lt;code&gt;@QuartzTransactionManager&lt;/code&gt; 주석 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="2466d3a00955f30c6095ec602ad41149196ee2fd" translate="yes" xml:space="preserve">
          <source>To help reduce the size of your Groovy code, several &lt;code&gt;import&lt;/code&gt; statements are automatically included. Notice how the preceding example refers to &lt;code&gt;@Component&lt;/code&gt;, &lt;code&gt;@RestController&lt;/code&gt;, and &lt;code&gt;@RequestMapping&lt;/code&gt; without needing to use fully-qualified names or &lt;code&gt;import&lt;/code&gt; statements.</source>
          <target state="translated">Groovy 코드의 크기를 줄이기 위해 여러 &lt;code&gt;import&lt;/code&gt; 문이 자동으로 포함됩니다. 이전 예제 에서 정규화 된 이름이나 &lt;code&gt;import&lt;/code&gt; 문 을 사용할 필요없이 어떻게 &lt;code&gt;@Component&lt;/code&gt; , &lt;code&gt;@RestController&lt;/code&gt; 및 &lt;code&gt;@RequestMapping&lt;/code&gt; 을 참조하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="3520e1f6de5c7ce8333cc201c629df799a54079a" translate="yes" xml:space="preserve">
          <source>To help with the customization, some other properties are transferred from the Spring &lt;code&gt;Environment&lt;/code&gt; to System properties, as described in the following table:</source>
          <target state="translated">사용자 정의를 돕기 위해 다음 표에 설명 된대로 일부 다른 속성이 Spring &lt;code&gt;Environment&lt;/code&gt; 에서 시스템 속성 으로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="9fe6ab098da6ca83ea91ed90392c591b67bb0921" translate="yes" xml:space="preserve">
          <source>To help with this, Spring Boot allows you to define logging groups in your Spring &lt;code&gt;Environment&lt;/code&gt;. For example, here&amp;rsquo;s how you could define a &amp;ldquo;tomcat&amp;rdquo; group by adding it to your &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">이를 돕기 위해 Spring Boot를 사용하면 Spring &lt;code&gt;Environment&lt;/code&gt; 에서 로깅 그룹을 정의 할 수 있습니다 . 예를 들어, &lt;code&gt;application.properties&lt;/code&gt; 에 추가하여 &quot;tomcat&quot;그룹을 정의하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8360fce83b5ea34128eea992623ad5b1d4c67277" translate="yes" xml:space="preserve">
          <source>To help with this, Spring Boot lets you define profile groups. A profile group allows you to define a logical name for a related group of profiles.</source>
          <target state="translated">이를 돕기 위해 Spring Boot를 사용하면 프로필 그룹을 정의 할 수 있습니다. 프로필 그룹을 사용하면 관련 프로필 그룹에 대한 논리적 이름을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="237d63ce58b8d11a894f4850f68dce91c3c91561" translate="yes" xml:space="preserve">
          <source>To import these properties, you can add the following to your &lt;code&gt;application.properties&lt;/code&gt; or &lt;code&gt;application.yaml&lt;/code&gt; file:</source>
          <target state="translated">이러한 속성을 가져 오려면 &lt;code&gt;application.properties&lt;/code&gt; 또는 &lt;code&gt;application.yaml&lt;/code&gt; 파일에 다음을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26a7634911f3cf897c40c030da805a6d108e7533" translate="yes" xml:space="preserve">
          <source>To improve the user experience and further assist the user in configuring a given property, you can provide additional metadata that:</source>
          <target state="translated">사용자 환경을 개선하고 사용자가 특정 속성을 구성하는 데 도움을주기 위해 다음과 같은 추가 메타 데이터를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3729650a9408f2af75a5c5dc425de2461132524e" translate="yes" xml:space="preserve">
          <source>To learn about securing this file appropriately, see &lt;a href=&quot;#deployment-initd-service-securing&quot;&gt;the guidelines for securing an init.d service&lt;/a&gt;.</source>
          <target state="translated">이 파일을 적절하게 보안하는 방법에 대해 알아 보려면 &lt;a href=&quot;#deployment-initd-service-securing&quot;&gt;init.d 서비스 보안 지침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8748d835a65d384a3a26059fab2194a2e3070c24" translate="yes" xml:space="preserve">
          <source>To learn about using Spring Boot with Gradle, please refer to the documentation for Spring Boot&amp;rsquo;s Gradle plugin:</source>
          <target state="translated">Gradle과 함께 Spring Boot를 사용하는 방법에 대해 알아 보려면 Spring Boot의 Gradle 플러그인에 대한 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="e0d3a4720bb5fc6f7377033a50045f3a3bc1e830" translate="yes" xml:space="preserve">
          <source>To learn about using Spring Boot with Maven, please refer to the documentation for Spring Boot&amp;rsquo;s Maven plugin:</source>
          <target state="translated">Maven에서 Spring Boot를 사용하는 방법에 대해 알아 보려면 Spring Boot의 Maven 플러그인에 대한 문서를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="62c164149ee34de1ebc8ad3aacff1fdca3929d62" translate="yes" xml:space="preserve">
          <source>To learn how to swap technical facets, please see the how-to documentation for &lt;a href=&quot;howto#howto-use-another-web-server&quot;&gt;swapping web server&lt;/a&gt; and &lt;a href=&quot;howto#howto-configure-log4j-for-logging&quot;&gt;logging system&lt;/a&gt;.</source>
          <target state="translated">기술 측면을 바꾸는 방법을 알아 보려면 &lt;a href=&quot;howto#howto-use-another-web-server&quot;&gt;웹 서버&lt;/a&gt; 및 &lt;a href=&quot;howto#howto-configure-log4j-for-logging&quot;&gt;로깅 시스템&lt;/a&gt; 을 바꾸는 방법 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85a85535e8614fa50f76ae34f8faddee7f356e92" translate="yes" xml:space="preserve">
          <source>To learn more about Micrometer&amp;rsquo;s capabilities, please refer to its &lt;a href=&quot;https://micrometer.io/docs&quot;&gt;reference documentation&lt;/a&gt;, in particular the &lt;a href=&quot;https://micrometer.io/docs/concepts&quot;&gt;concepts section&lt;/a&gt;.</source>
          <target state="translated">Micrometer의 기능에 대한 자세한 내용은 &lt;a href=&quot;https://micrometer.io/docs&quot;&gt;참조 문서&lt;/a&gt; , 특히 &lt;a href=&quot;https://micrometer.io/docs/concepts&quot;&gt;개념 섹션을 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d41d5171097c70d76e93f80867fde76da78296c6" translate="yes" xml:space="preserve">
          <source>To learn more about the Actuator&amp;rsquo;s endpoints and their request and response formats, please refer to the separate API documentation (&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/htmlsingle&quot;&gt;HTML&lt;/a&gt; or &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf&quot;&gt;PDF&lt;/a&gt;).</source>
          <target state="translated">Actuator의 끝점과 요청 및 응답 형식에 대한 자세한 내용은 별도의 API 문서 ( &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/htmlsingle&quot;&gt;HTML&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/actuator-api/pdf/spring-boot-actuator-web-api.pdf&quot;&gt;PDF&lt;/a&gt; ) 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88c4f9087256237e2ce246daedaefbc67da5648d" translate="yes" xml:space="preserve">
          <source>To make Spring Boot auto-configuration work with the aforementioned embedded Apache Kafka broker, you need to remap a system property for embedded broker addresses (populated by the &lt;code&gt;EmbeddedKafkaBroker&lt;/code&gt;) into the Spring Boot configuration property for Apache Kafka. There are several ways to do that:</source>
          <target state="translated">앞서 언급 한 임베디드 Apache Kafka 브로커에서 Spring Boot 자동 구성이 작동하도록하려면 임베디드 브로커 주소 ( &lt;code&gt;EmbeddedKafkaBroker&lt;/code&gt; 로 채워짐 )에 대한 시스템 속성을 Apache Kafka의 Spring Boot 구성 속성에 다시 매핑해야합니다 . 이를 수행하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab69b2aa70c0cbc65afe2adc66437434008054e" translate="yes" xml:space="preserve">
          <source>To make an application-wide, additive customization to all &lt;code&gt;WebClient.Builder&lt;/code&gt; instances, you can declare &lt;code&gt;WebClientCustomizer&lt;/code&gt; beans and change the &lt;code&gt;WebClient.Builder&lt;/code&gt; locally at the point of injection.</source>
          <target state="translated">모든 &lt;code&gt;WebClient.Builder&lt;/code&gt; 인스턴스에 대해 애플리케이션 전체의 추가 사용자 정의를 수행하려면 &lt;code&gt;WebClientCustomizer&lt;/code&gt; Bean을 선언 하고 주입 지점에서 &lt;code&gt;WebClient.Builder&lt;/code&gt; 를 로컬로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76aceeac9111253b5f13c64a9995fe619ca4dc9a" translate="yes" xml:space="preserve">
          <source>To make an application-wide, additive customization, use a &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; bean. All such beans are automatically registered with the auto-configured &lt;code&gt;RestTemplateBuilder&lt;/code&gt; and are applied to any templates that are built with it.</source>
          <target state="translated">애플리케이션 전체의 추가 사용자 정의를 수행하려면 &lt;code&gt;RestTemplateCustomizer&lt;/code&gt; Bean을 사용하십시오 . 이러한 모든 빈은 자동 구성 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 에 자동으로 등록 되며이 빈으로 빌드 된 모든 템플릿에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="80037567978b39638059a76eddee883c77a1e2f5" translate="yes" xml:space="preserve">
          <source>To make it easier to create optimized Docker images that can be built with a dockerfile, Spring Boot supports adding a layer index file to the jar. It provides a list of layers and the parts of the jar that should be contained within them. The list of layers in the index is ordered based on the order in which the layers should be added to the Docker/OCI image. Out-of-the-box, the following layers are supported:</source>
          <target state="translated">dockerfile로 빌드 할 수있는 최적화 된 Docker 이미지를 더 쉽게 만들 수 있도록 Spring Boot는 jar에 레이어 인덱스 파일 추가를 지원합니다. 레이어 목록과 그 안에 포함되어야하는 항아리 부분을 제공합니다. 인덱스의 레이어 목록은 레이어가 Docker / OCI 이미지에 추가되어야하는 순서에 따라 정렬됩니다. 기본적으로 다음 레이어가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="a57fba3621864a82aa6f83e3041fda612f4ac21c" translate="yes" xml:space="preserve">
          <source>To make the scope of any customizations as narrow as possible, inject the auto-configured &lt;code&gt;RestTemplateBuilder&lt;/code&gt; and then call its methods as required. Each method call returns a new &lt;code&gt;RestTemplateBuilder&lt;/code&gt; instance, so the customizations only affect this use of the builder.</source>
          <target state="translated">사용자 지정 범위를 최대한 좁히려면 자동 구성된 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 를 삽입 한 다음 필요에 따라 메서드를 호출합니다. 각 메서드 호출은 새 &lt;code&gt;RestTemplateBuilder&lt;/code&gt; 인스턴스를 반환 하므로 사용자 지정은이 빌더 사용에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="e7158012d6f2c7fca0210332dc2f45166de03c70" translate="yes" xml:space="preserve">
          <source>To make the scope of any customizations as narrow as possible, inject the auto-configured &lt;code&gt;WebClient.Builder&lt;/code&gt; and then call its methods as required. &lt;code&gt;WebClient.Builder&lt;/code&gt; instances are stateful: Any change on the builder is reflected in all clients subsequently created with it. If you want to create several clients with the same builder, you can also consider cloning the builder with &lt;code&gt;WebClient.Builder other = builder.clone();&lt;/code&gt;.</source>
          <target state="translated">사용자 지정 범위를 최대한 좁히려면 자동 구성된 &lt;code&gt;WebClient.Builder&lt;/code&gt; 를 삽입 한 다음 필요에 따라 메서드를 호출합니다. &lt;code&gt;WebClient.Builder&lt;/code&gt; 인스턴스는 상태 저장 : 빌더의 모든 변경 사항은 이후에 생성 된 모든 클라이언트에 반영됩니다. 동일한 빌더로 여러 클라이언트를 작성하려는 경우 &lt;code&gt;WebClient.Builder other = builder.clone();&lt;/code&gt; 하여 빌더 복제를 고려할 수도 있습니다. other = builder.clone (); .</target>
        </trans-unit>
        <trans-unit id="029ecd89f6154e11ce40056b384fbe103c4d7b9d" translate="yes" xml:space="preserve">
          <source>To map all &lt;code&gt;5xx&lt;/code&gt; errors by using a FreeMarker template, your directory structure would be as follows:</source>
          <target state="translated">FreeMarker 템플릿을 사용하여 모든 &lt;code&gt;5xx&lt;/code&gt; 오류 를 매핑하려면 디렉터리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e84dd54c980d3099217870e671ee2f1f0423019f" translate="yes" xml:space="preserve">
          <source>To map all &lt;code&gt;5xx&lt;/code&gt; errors by using a Mustache template, your directory structure would be as follows:</source>
          <target state="translated">Mustache 템플릿을 사용하여 모든 &lt;code&gt;5xx&lt;/code&gt; 오류 를 매핑하려면 디렉토리 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4327ac96e42803f1e5dedaae307636868a371bf" translate="yes" xml:space="preserve">
          <source>To mock Kotlin classes, &lt;a href=&quot;https://mockk.io/&quot;&gt;MockK&lt;/a&gt; is recommended. If you need the &lt;code&gt;Mockk&lt;/code&gt; equivalent of the Mockito specific &lt;a href=&quot;#boot-features-testing-spring-boot-applications-mocking-beans&quot;&gt;&lt;code&gt;@MockBean&lt;/code&gt; and &lt;code&gt;@SpyBean&lt;/code&gt; annotations&lt;/a&gt;, you can use &lt;a href=&quot;https://github.com/Ninja-Squad/springmockk&quot;&gt;SpringMockK&lt;/a&gt; which provides similar &lt;code&gt;@MockkBean&lt;/code&gt; and &lt;code&gt;@SpykBean&lt;/code&gt; annotations.</source>
          <target state="translated">Kotlin 클래스를 모의하려면 &lt;a href=&quot;https://mockk.io/&quot;&gt;MockK&lt;/a&gt; 를 사용하는 것이 좋습니다. Mockito 특정 &lt;a href=&quot;#boot-features-testing-spring-boot-applications-mocking-beans&quot;&gt; &lt;code&gt;@MockBean&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;@SpyBean&lt;/code&gt; 주석 과 동등한 &lt;code&gt;Mockk&lt;/code&gt; 가 필요하면 유사한 &lt;code&gt;@MockkBean&lt;/code&gt; 및 &lt;code&gt;@SpykBean&lt;/code&gt; 주석 을 제공 하는 &lt;a href=&quot;https://github.com/Ninja-Squad/springmockk&quot;&gt;SpringMockK&lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8fc1c1d9470f442b43582befe2184e1ed328fa01" translate="yes" xml:space="preserve">
          <source>To override dependency versions in Gradle, see &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/gradle-plugin/reference/htmlsingle/#managing-dependencies-dependency-management-plugin-customizing&quot;&gt;this section&lt;/a&gt; of the Gradle plugin&amp;rsquo;s documentation.</source>
          <target state="translated">Gradle에서 종속성 버전을 재정의하려면 Gradle 플러그인 문서 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/gradle-plugin/reference/htmlsingle/#managing-dependencies-dependency-management-plugin-customizing&quot;&gt;의이 섹션&lt;/a&gt; 을 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="0dd9b65bfcf98708d0e5dc080df89810d255f579" translate="yes" xml:space="preserve">
          <source>To override dependency versions with Maven, see &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#using&quot;&gt;this section&lt;/a&gt; of the Maven plugin&amp;rsquo;s documentation.</source>
          <target state="translated">Maven으로 종속성 버전을 재정의하려면 Maven 플러그인 문서 &lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.4.0/maven-plugin/reference/htmlsingle/#using&quot;&gt;의이 섹션&lt;/a&gt; 을 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="7f221e7c27fc50fcce7371848a5df53c3e2dc70f" translate="yes" xml:space="preserve">
          <source>To pass command-line arguments to the application, use &lt;code&gt;--&lt;/code&gt; to separate the commands from the &amp;ldquo;spring&amp;rdquo; command arguments, as shown in the following example:</source>
          <target state="translated">응용 프로그램에 명령 줄 인수를 전달하려면 다음 예와 같이 &lt;code&gt;--&lt;/code&gt; 를 사용 하여 &quot;spring&quot;명령 인수에서 명령을 분리합니다.</target>
        </trans-unit>
        <trans-unit id="cbd902a88d71a4d380c69d7ee7cd5da888d41e2c" translate="yes" xml:space="preserve">
          <source>To produce the two artifacts, one that can be used as a dependency and one that is executable, a classifier must be specified. This classifier is applied to the name of the executable archive, leaving the default archive for use as a dependency.</source>
          <target state="translated">두 아티팩트, 즉 종속성으로 사용할 수있는 아티팩트와 실행 가능한 아티팩트를 생성하려면 분류자를 지정해야합니다. 이 분류자는 실행 가능한 아카이브의 이름에 적용되며 기본 아카이브는 종속성으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="439843261e583c6eda3a10871bff83cfdd56e05e" translate="yes" xml:space="preserve">
          <source>To provide a concrete example, suppose you develop a &lt;code&gt;@Component&lt;/code&gt; that uses a &lt;code&gt;name&lt;/code&gt; property, as shown in the following example:</source>
          <target state="translated">구체적인 예를 제공하기 위해 다음 예와 같이 &lt;code&gt;name&lt;/code&gt; 속성 을 사용하는 &lt;code&gt;@Component&lt;/code&gt; 를 개발한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="9bf7bb1426dc08a85e682338f957a2b2c0b73d4e" translate="yes" xml:space="preserve">
          <source>To provide custom application information, you can register Spring beans that implement the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java&quot;&gt;&lt;code&gt;InfoContributor&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">사용자 정의 애플리케이션 정보를 제공하기 위해 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/info/InfoContributor.java&quot;&gt; &lt;code&gt;InfoContributor&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 Spring Bean을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ade205b6988436803e0dbd79bcc471b61e3f95f" translate="yes" xml:space="preserve">
          <source>To provide custom health information from a reactive API, you can register Spring beans that implement the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java&quot;&gt;&lt;code&gt;ReactiveHealthIndicator&lt;/code&gt;&lt;/a&gt; interface. The following code shows a sample &lt;code&gt;ReactiveHealthIndicator&lt;/code&gt; implementation:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java&quot;&gt; &lt;code&gt;ReactiveHealthIndicator&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 Spring Bean을 등록하여 반응 API에서 사용자 정의 건강 정보를 제공 할 수 있습니다 . 다음 코드는 샘플 &lt;code&gt;ReactiveHealthIndicator&lt;/code&gt; 구현을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="30b3fde07b75289246e2b2c5747bf45739bfe86b" translate="yes" xml:space="preserve">
          <source>To provide custom health information, you can register Spring beans that implement the &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java&quot;&gt;&lt;code&gt;HealthIndicator&lt;/code&gt;&lt;/a&gt; interface. You need to provide an implementation of the &lt;code&gt;health()&lt;/code&gt; method and return a &lt;code&gt;Health&lt;/code&gt; response. The &lt;code&gt;Health&lt;/code&gt; response should include a status and can optionally include additional details to be displayed. The following code shows a sample &lt;code&gt;HealthIndicator&lt;/code&gt; implementation:</source>
          <target state="translated">사용자 정의 건강 정보를 제공하기 위해 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java&quot;&gt; &lt;code&gt;HealthIndicator&lt;/code&gt; &lt;/a&gt; 인터페이스 를 구현하는 Spring Bean을 등록 할 수 있습니다 . &lt;code&gt;health()&lt;/code&gt; 메서드 의 구현을 제공 하고 &lt;code&gt;Health&lt;/code&gt; 응답을 반환해야합니다 . &lt;code&gt;Health&lt;/code&gt; 응답은 상태를 포함해야하고 선택적으로 표시 할 추가 정보를 포함 할 수 있습니다. 다음 코드는 샘플 &lt;code&gt;HealthIndicator&lt;/code&gt; 구현을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="788eec8862017c7000f958af3b6b21359c3c2fb7" translate="yes" xml:space="preserve">
          <source>To reduce the chances of the application&amp;rsquo;s user account being compromised, you should consider preventing it from using a login shell. For example, you can set the account&amp;rsquo;s shell to &lt;code&gt;/usr/sbin/nologin&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램의 사용자 계정이 손상 될 가능성을 줄이려면 로그인 셸을 사용하지 않도록해야합니다. 예를 들어 계정의 셸을 &lt;code&gt;/usr/sbin/nologin&lt;/code&gt; 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="411b41f85a6cb367f6e6d7898e33f29f9f05f811" translate="yes" xml:space="preserve">
          <source>To register custom metrics, inject &lt;code&gt;MeterRegistry&lt;/code&gt; into your component, as shown in the following example:</source>
          <target state="translated">사용자 지정 지표를 등록하려면 다음 예제와 같이 &lt;code&gt;MeterRegistry&lt;/code&gt; 를 구성 요소에 삽입 합니다.</target>
        </trans-unit>
        <trans-unit id="c107934f7b84e2c48f5d8f94b338ce6ed36a8907" translate="yes" xml:space="preserve">
          <source>To repackage an existing archive so that it becomes a self-contained executable archive, use &lt;code&gt;org.springframework.boot.loader.tools.Repackager&lt;/code&gt;. The &lt;code&gt;Repackager&lt;/code&gt; class takes a single constructor argument that refers to an existing jar or war archive. Use one of the two available &lt;code&gt;repackage()&lt;/code&gt; methods to either replace the original file or write to a new destination. Various settings can also be configured on the repackager before it is run.</source>
          <target state="translated">자체 포함 된 실행 가능 아카이브가되도록 기존 아카이브를 다시 패키징하려면 &lt;code&gt;org.springframework.boot.loader.tools.Repackager&lt;/code&gt; 를 사용하십시오 . &lt;code&gt;Repackager&lt;/code&gt; 클래스는 기존의 항아리 또는 전쟁 아카이브를 참조하는 하나의 생성자 인수를합니다. 두 가지 사용 가능한 &lt;code&gt;repackage()&lt;/code&gt; 메서드 중 하나를 사용하여 원본 파일을 바꾸거나 새 대상에 기록합니다. 리 패키저를 실행하기 전에 다양한 설정을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e66cbd7ab49df10cefc3849a590e72c11bdb63b" translate="yes" xml:space="preserve">
          <source>To retry operations, you can enable retries on the &lt;code&gt;AmqpTemplate&lt;/code&gt; (for example, in the event that the broker connection is lost):</source>
          <target state="translated">작업을 재 시도하려면 &lt;code&gt;AmqpTemplate&lt;/code&gt; 에서 재 시도를 활성화 할 수 있습니다 (예 : 브로커 연결이 끊어진 경우).</target>
        </trans-unit>
        <trans-unit id="821e262dc78f3b7366c7656c2ddc1e8dee511059" translate="yes" xml:space="preserve">
          <source>To run an app with that &lt;code&gt;DataSource&lt;/code&gt;, all you need is the connection information. Pool-specific settings can also be provided. Check the implementation that is going to be used at runtime for more details.</source>
          <target state="translated">해당 &lt;code&gt;DataSource&lt;/code&gt; 로 앱을 실행하려면 연결 정보 만 있으면됩니다. 풀별 설정도 제공 할 수 있습니다. 자세한 내용은 런타임에 사용될 구현을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2ff814d335c9fede0bb451434c641322abd8cae0" translate="yes" xml:space="preserve">
          <source>To run in App Engine, you can create a project in the UI first, which sets up a unique identifier for you and also sets up HTTP routes. Add a Java app to the project and leave it empty and then use the &lt;a href=&quot;https://cloud.google.com/sdk/install&quot;&gt;Google Cloud SDK&lt;/a&gt; to push your Spring Boot app into that slot from the command line or CI build.</source>
          <target state="translated">App Engine에서 실행하려면 먼저 UI에서 프로젝트를 만들어 고유 식별자를 설정하고 HTTP 경로도 설정하면됩니다. 프로젝트에 자바 앱을 추가하고 비워 둔 다음 &lt;a href=&quot;https://cloud.google.com/sdk/install&quot;&gt;Google Cloud SDK&lt;/a&gt; 를 사용 하여 명령 줄 또는 CI 빌드에서 해당 슬롯에 Spring Boot 앱을 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="c1af965b44b6b84c2c01b93560b32dc4d77db635" translate="yes" xml:space="preserve">
          <source>To run that application, use the &lt;code&gt;java -jar&lt;/code&gt; command, as follows:</source>
          <target state="translated">해당 애플리케이션을 실행하려면 다음과 같이 &lt;code&gt;java -jar&lt;/code&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="89845f6c2d6e6ac23e0fd130b8dc292ce99a719e" translate="yes" xml:space="preserve">
          <source>To scan for a free port (using OS natives to prevent clashes) use &lt;code&gt;server.port=0&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 포트를 검색하려면 (충돌을 방지하기 위해 OS 네이티브 사용) &lt;code&gt;server.port=0&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4bae108eca923fd7e7ba2297dff0895501f37c6d" translate="yes" xml:space="preserve">
          <source>To see the order of every &lt;code&gt;Filter&lt;/code&gt; in your application, enable debug level logging for the &lt;code&gt;web&lt;/code&gt;&lt;a href=&quot;#boot-features-custom-log-groups&quot;&gt;logging group&lt;/a&gt; (&lt;code&gt;logging.level.web=debug&lt;/code&gt;). Details of the registered filters, including their order and URL patterns, will then be logged at startup.</source>
          <target state="translated">애플리케이션에서 모든 &lt;code&gt;Filter&lt;/code&gt; 의 순서를 보려면 &lt;code&gt;web&lt;/code&gt; &lt;a href=&quot;#boot-features-custom-log-groups&quot;&gt;로깅 그룹&lt;/a&gt; ( &lt;code&gt;logging.level.web=debug&lt;/code&gt; )에 대해 디버그 수준 로깅을 활성화 합니다. 그러면 순서 및 URL 패턴을 포함하여 등록 된 필터의 세부 사항이 시작시 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="15753153d9d9762f9f3a9d6ac74593c5bd3687ee" translate="yes" xml:space="preserve">
          <source>To set JVM command line arguments, you can use the &lt;code&gt;JAVA_OPTS&lt;/code&gt; environment variable, as shown in the following example:</source>
          <target state="translated">JVM 명령 줄 인수를 설정하려면 다음 예와 같이 &lt;code&gt;JAVA_OPTS&lt;/code&gt; 환경 변수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b26972cc056abfe77d369936ae35a8c9a249073" translate="yes" xml:space="preserve">
          <source>To solve this problem, many developers use &amp;ldquo;shaded&amp;rdquo; jars. A shaded jar packages all classes, from all jars, into a single &amp;ldquo;uber jar&amp;rdquo;. The problem with shaded jars is that it becomes hard to see which libraries are actually in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars. Spring Boot takes a different approach and lets you actually nest jars directly.</source>
          <target state="translated">이 문제를 해결하기 위해 많은 개발자가 &quot;음영 처리 된&quot;jar를 사용합니다. 음영 처리 된 jar는 모든 jar의 모든 클래스를 단일 &quot;uber jar&quot;로 패키지화합니다. 음영 처리 된 jar의 문제점은 실제로 애플리케이션에 어떤 라이브러리가 있는지 확인하기가 어렵다는 것입니다. 여러 jar에서 동일한 파일 이름을 사용하는 경우 (그러나 다른 내용으로) 문제가 될 수도 있습니다. Spring Boot는 다른 접근 방식을 취하며 실제로 jar를 직접 중첩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="418b91bb761b61e6505e236bb63a7c9604bf373b" translate="yes" xml:space="preserve">
          <source>To solve this problem, many developers use &amp;ldquo;uber&amp;rdquo; jars. An uber jar packages all the classes from all the application&amp;rsquo;s dependencies into a single archive. The problem with this approach is that it becomes hard to see which libraries are in your application. It can also be problematic if the same filename is used (but with different content) in multiple jars.</source>
          <target state="translated">이 문제를 해결하기 위해 많은 개발자가 &quot;uber&quot;jar를 사용합니다. uber jar는 모든 애플리케이션 종속성의 모든 클래스를 단일 아카이브로 패키징합니다. 이 접근 방식의 문제점은 애플리케이션에 어떤 라이브러리가 있는지 확인하기가 어렵다는 것입니다. 여러 jar에서 동일한 파일 이름을 사용하는 경우 (그러나 다른 내용으로) 문제가 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c026d69017fcdfaeb8895d71dce8c25d2e33724" translate="yes" xml:space="preserve">
          <source>To specify a buffer size of 10 megabytes, &lt;code&gt;10&lt;/code&gt; and &lt;code&gt;10MB&lt;/code&gt; are equivalent. A size threshold of 256 bytes can be specified as &lt;code&gt;256&lt;/code&gt; or &lt;code&gt;256B&lt;/code&gt;.</source>
          <target state="translated">10 메가 바이트 버퍼 크기를 지정하려면, &lt;code&gt;10&lt;/code&gt; 및 &lt;code&gt;10MB&lt;/code&gt; 동일합니다. 256 바이트의 크기 임계 값은 &lt;code&gt;256&lt;/code&gt; 또는 &lt;code&gt;256B&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5201abf1ce36b1dab4c7364cdf6899960534a75" translate="yes" xml:space="preserve">
          <source>To specify a session timeout of 30 seconds, &lt;code&gt;30&lt;/code&gt;, &lt;code&gt;PT30S&lt;/code&gt; and &lt;code&gt;30s&lt;/code&gt; are all equivalent. A read timeout of 500ms can be specified in any of the following form: &lt;code&gt;500&lt;/code&gt;, &lt;code&gt;PT0.5S&lt;/code&gt; and &lt;code&gt;500ms&lt;/code&gt;.</source>
          <target state="translated">세션 시간 초과를 30 초로 지정하려면 &lt;code&gt;30&lt;/code&gt; , &lt;code&gt;PT30S&lt;/code&gt; 및 &lt;code&gt;30s&lt;/code&gt; 가 모두 동일합니다. 500ms의 읽기 제한 시간은 &lt;code&gt;500&lt;/code&gt; , &lt;code&gt;PT0.5S&lt;/code&gt; 및 &lt;code&gt;500ms&lt;/code&gt; 형식으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c094808e125d827f6a6211165315c6e3d12a5a5" translate="yes" xml:space="preserve">
          <source>To switch off the HTTP endpoints completely but still create a &lt;code&gt;WebApplicationContext&lt;/code&gt;, use &lt;code&gt;server.port=-1&lt;/code&gt; (doing so is sometimes useful for testing).</source>
          <target state="translated">HTTP 끝점을 완전히 끄고 &lt;code&gt;WebApplicationContext&lt;/code&gt; 를 생성 하려면 &lt;code&gt;server.port=-1&lt;/code&gt; 을 사용하십시오 (이는 때때로 테스트에 유용합니다).</target>
        </trans-unit>
        <trans-unit id="c10e8cea726971c7fc103bb4e7da5dd0cd7536fd" translate="yes" xml:space="preserve">
          <source>To take control over this behaviour, define your &lt;code&gt;GraphiteMeterRegistry&lt;/code&gt; and supply your own &lt;code&gt;HierarchicalNameMapper&lt;/code&gt;. An auto-configured &lt;code&gt;GraphiteConfig&lt;/code&gt; and &lt;code&gt;Clock&lt;/code&gt; beans are provided unless you define your own:</source>
          <target state="translated">이 동작을 제어하려면 &lt;code&gt;GraphiteMeterRegistry&lt;/code&gt; 를 정의 하고 고유 한 &lt;code&gt;HierarchicalNameMapper&lt;/code&gt; 를 제공하십시오 . 사용자가 직접 정의하지 않는 한 자동 구성된 &lt;code&gt;GraphiteConfig&lt;/code&gt; 및 &lt;code&gt;Clock&lt;/code&gt; Bean이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="978c77b844eeccf093a90060c972f0a386b7a661" translate="yes" xml:space="preserve">
          <source>To take control over this behaviour, define your &lt;code&gt;JmxMeterRegistry&lt;/code&gt; and supply your own &lt;code&gt;HierarchicalNameMapper&lt;/code&gt;. An auto-configured &lt;code&gt;JmxConfig&lt;/code&gt; and &lt;code&gt;Clock&lt;/code&gt; beans are provided unless you define your own:</source>
          <target state="translated">이 동작을 제어하려면 &lt;code&gt;JmxMeterRegistry&lt;/code&gt; 를 정의 하고 고유 한 &lt;code&gt;HierarchicalNameMapper&lt;/code&gt; 를 제공하십시오 . 사용자가 직접 정의하지 않는 한 자동 구성된 &lt;code&gt;JmxConfig&lt;/code&gt; 및 &lt;code&gt;Clock&lt;/code&gt; Bean이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="05fcfc031547d4f81c6c470218df3ed4c55abb88" translate="yes" xml:space="preserve">
          <source>To take full control of the configuration of the &lt;code&gt;EntityManagerFactory&lt;/code&gt;, you need to add a &lt;code&gt;@Bean&lt;/code&gt; named &amp;lsquo;entityManagerFactory&amp;rsquo;. Spring Boot auto-configuration switches off its entity manager in the presence of a bean of that type.</source>
          <target state="translated">&lt;code&gt;EntityManagerFactory&lt;/code&gt; 의 구성을 완전히 제어하려면 'entityManagerFactory'라는 &lt;code&gt;@Bean&lt;/code&gt; 을 추가해야합니다 . Spring Boot 자동 구성은 해당 유형의 Bean이있는 경우 엔티티 관리자를 끕니다.</target>
        </trans-unit>
        <trans-unit id="3d80d062ce7f4c98164e76b98598466a4680caa5" translate="yes" xml:space="preserve">
          <source>To test that &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web-reactive.html&quot;&gt;Spring WebFlux&lt;/a&gt; controllers are working as expected, you can use the &lt;code&gt;@WebFluxTest&lt;/code&gt; annotation. &lt;code&gt;@WebFluxTest&lt;/code&gt; auto-configures the Spring WebFlux infrastructure and limits scanned beans to &lt;code&gt;@Controller&lt;/code&gt;, &lt;code&gt;@ControllerAdvice&lt;/code&gt;, &lt;code&gt;@JsonComponent&lt;/code&gt;, &lt;code&gt;Converter&lt;/code&gt;, &lt;code&gt;GenericConverter&lt;/code&gt;, &lt;code&gt;WebFilter&lt;/code&gt;, and &lt;code&gt;WebFluxConfigurer&lt;/code&gt;. Regular &lt;code&gt;@Component&lt;/code&gt; and &lt;code&gt;@ConfigurationProperties&lt;/code&gt; beans are not scanned when the &lt;code&gt;@WebFluxTest&lt;/code&gt; annotation is used. &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; can be used to include &lt;code&gt;@ConfigurationProperties&lt;/code&gt; beans.</source>
          <target state="translated">&lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web-reactive.html&quot;&gt;Spring WebFlux&lt;/a&gt; 컨트롤러가 예상대로 작동하는지 테스트하려면 &lt;code&gt;@WebFluxTest&lt;/code&gt; 주석을 사용할 수 있습니다 . &lt;code&gt;@WebFluxTest&lt;/code&gt; 는 Spring WebFlux 인프라를 자동 구성하고 스캔 된 Bean을 &lt;code&gt;@Controller&lt;/code&gt; , &lt;code&gt;@ControllerAdvice&lt;/code&gt; , &lt;code&gt;@JsonComponent&lt;/code&gt; , &lt;code&gt;Converter&lt;/code&gt; , &lt;code&gt;GenericConverter&lt;/code&gt; , &lt;code&gt;WebFilter&lt;/code&gt; 및 &lt;code&gt;WebFluxConfigurer&lt;/code&gt; 로 제한 합니다. &lt;code&gt;@WebFluxTest&lt;/code&gt; 어노테이션이 사용될 때 일반 &lt;code&gt;@Component&lt;/code&gt; 및 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; Bean은 스캔되지 않습니다 . &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 를 사용하여 다음을 포함 할 수 있습니다. &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 빈.</target>
        </trans-unit>
        <trans-unit id="e4f6849362ffdceb4140cb0eae229bb6b91f0748" translate="yes" xml:space="preserve">
          <source>To test that object JSON serialization and deserialization is working as expected, you can use the &lt;code&gt;@JsonTest&lt;/code&gt; annotation. &lt;code&gt;@JsonTest&lt;/code&gt; auto-configures the available supported JSON mapper, which can be one of the following libraries:</source>
          <target state="translated">객체 JSON 직렬화 및 역 직렬화가 예상대로 작동하는지 테스트하려면 &lt;code&gt;@JsonTest&lt;/code&gt; 주석을 사용할 수 있습니다 . &lt;code&gt;@JsonTest&lt;/code&gt; 는 지원되는 사용 가능한 JSON 매퍼를 자동 구성하며 다음 라이브러리 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72273788175486d9b72fd1cdb35fce7fbc896918" translate="yes" xml:space="preserve">
          <source>To test whether Spring MVC controllers are working as expected, use the &lt;code&gt;@WebMvcTest&lt;/code&gt; annotation. &lt;code&gt;@WebMvcTest&lt;/code&gt; auto-configures the Spring MVC infrastructure and limits scanned beans to &lt;code&gt;@Controller&lt;/code&gt;, &lt;code&gt;@ControllerAdvice&lt;/code&gt;, &lt;code&gt;@JsonComponent&lt;/code&gt;, &lt;code&gt;Converter&lt;/code&gt;, &lt;code&gt;GenericConverter&lt;/code&gt;, &lt;code&gt;Filter&lt;/code&gt;, &lt;code&gt;HandlerInterceptor&lt;/code&gt;, &lt;code&gt;WebMvcConfigurer&lt;/code&gt;, and &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt;. Regular &lt;code&gt;@Component&lt;/code&gt; and &lt;code&gt;@ConfigurationProperties&lt;/code&gt; beans are not scanned when the &lt;code&gt;@WebMvcTest&lt;/code&gt; annotation is used. &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; can be used to include &lt;code&gt;@ConfigurationProperties&lt;/code&gt; beans.</source>
          <target state="translated">Spring MVC 컨트롤러가 예상대로 작동하는지 테스트하려면 &lt;code&gt;@WebMvcTest&lt;/code&gt; 주석을 사용하십시오 . &lt;code&gt;@WebMvcTest&lt;/code&gt; 는 Spring MVC 인프라를 자동 구성하고 스캔 된 빈을 &lt;code&gt;@Controller&lt;/code&gt; , &lt;code&gt;@ControllerAdvice&lt;/code&gt; , &lt;code&gt;@JsonComponent&lt;/code&gt; , &lt;code&gt;Converter&lt;/code&gt; , &lt;code&gt;GenericConverter&lt;/code&gt; , &lt;code&gt;Filter&lt;/code&gt; , &lt;code&gt;HandlerInterceptor&lt;/code&gt; , &lt;code&gt;WebMvcConfigurer&lt;/code&gt; 및 &lt;code&gt;HandlerMethodArgumentResolver&lt;/code&gt; 로 제한 합니다. &lt;code&gt;@WebMvcTest&lt;/code&gt; 어노테이션이 사용 되면 일반 &lt;code&gt;@Component&lt;/code&gt; 및 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; Bean이 스캔되지 않습니다 . &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 를 사용하여 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; Bean 을 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcc0cdfd12fb7a3ce74ba76659a8c2a1b2b76694" translate="yes" xml:space="preserve">
          <source>To trigger LiveReload when a file changes, &lt;a href=&quot;#using-boot-devtools-restart&quot;&gt;Automatic Restart&lt;/a&gt; must be enabled.</source>
          <target state="translated">파일이 변경 될 때 LiveReload를 트리거하려면 &lt;a href=&quot;#using-boot-devtools-restart&quot;&gt;자동 다시 시작&lt;/a&gt; 을 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d869ae41ce8a4456c08f4cfa1c89c786c6c4bb3" translate="yes" xml:space="preserve">
          <source>To uninstall a dependency, use the &lt;code&gt;uninstall&lt;/code&gt; command. As with the &lt;code&gt;install&lt;/code&gt; command, it takes one or more sets of artifact coordinates in the format of &lt;code&gt;group:artifact:version&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">종속성을 제거하려면 사용하는 &lt;code&gt;uninstall&lt;/code&gt; 명령을 사용합니다. &lt;code&gt;install&lt;/code&gt; 명령 과 마찬가지로 다음 예와 같이 &lt;code&gt;group:artifact:version&lt;/code&gt; 형식의 하나 이상의 아티팩트 좌표 세트를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="e179623a791a8c49821f833950393cffe93aa0f8" translate="yes" xml:space="preserve">
          <source>To uninstall all additional dependencies, you can use the &lt;code&gt;--all&lt;/code&gt; option, as shown in the following example:</source>
          <target state="translated">모든 추가 종속성을 제거하려면 다음 예와 같이 &lt;code&gt;--all&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79d237463c317d24048bb1f8d1e43fa839d780d6" translate="yes" xml:space="preserve">
          <source>To upgrade an existing CLI installation, use the appropriate package manager command (for example, &lt;code&gt;brew upgrade&lt;/code&gt;). If you manually installed the CLI, follow the &lt;a href=&quot;#getting-started-manual-cli-installation&quot;&gt;standard instructions&lt;/a&gt;, remembering to update your &lt;code&gt;PATH&lt;/code&gt; environment variable to remove any older references.</source>
          <target state="translated">기존 CLI 설치를 업그레이드하려면 적절한 패키지 관리자 명령 (예 : &lt;code&gt;brew upgrade&lt;/code&gt; )을 사용하십시오. CLI를 수동으로 설치 한 경우 &lt;a href=&quot;#getting-started-manual-cli-installation&quot;&gt;표준 지침을&lt;/a&gt; 따르고 &lt;code&gt;PATH&lt;/code&gt; 환경 변수를 업데이트하여 이전 참조를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="97041c38811806b87bf6626a1205ff3fb37709e0" translate="yes" xml:space="preserve">
          <source>To use Jersey alongside another web framework, such as Spring MVC, it should be configured so that it will allow the other framework to handle requests that it cannot handle. First, configure Jersey to use a Filter rather than a Servlet by configuring the &lt;code&gt;spring.jersey.type&lt;/code&gt; application property with a value of &lt;code&gt;filter&lt;/code&gt;. Second, configure your &lt;code&gt;ResourceConfig&lt;/code&gt; to forward requests that would have resulted in a 404, as shown in the following example.</source>
          <target state="translated">Spring MVC와 같은 다른 웹 프레임 워크와 함께 Jersey를 사용하려면 다른 프레임 워크가 처리 할 수없는 요청을 처리 할 수 ​​있도록 구성해야합니다. 먼저 &lt;code&gt;spring.jersey.type&lt;/code&gt; 애플리케이션 속성을 &lt;code&gt;filter&lt;/code&gt; 값으로 구성하여 Servlet 대신 필터를 사용하도록 Jersey를 구성합니다 . 둘째, 다음 예제와 같이 404를 초래할 요청을 전달하도록 &lt;code&gt;ResourceConfig&lt;/code&gt; 를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7b2444f17d5c879c8aed9df81339daacbfea961" translate="yes" xml:space="preserve">
          <source>To use a trigger file, set the &lt;code&gt;spring.devtools.restart.trigger-file&lt;/code&gt; property to the name (excluding any path) of your trigger file. The trigger file must appear somewhere on your classpath.</source>
          <target state="translated">트리거 파일을 사용하려면 &lt;code&gt;spring.devtools.restart.trigger-file&lt;/code&gt; 속성을 트리거 파일 의 이름 (모든 경로 제외)으로 설정합니다. 트리거 파일은 클래스 경로의 어딘가에 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="345d566bf6577b60f3da0778ccd404ae101f0b72" translate="yes" xml:space="preserve">
          <source>To use cache busting, the following configuration configures a cache busting solution for all static resources, effectively adding a content hash, such as &lt;code&gt;&amp;lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&amp;gt;&lt;/code&gt;, in URLs:</source>
          <target state="translated">캐시 무효화를 사용하기 위해 다음 구성은 모든 정적 리소스에 대해 캐시 무효화 솔루션을 구성하여 &lt;code&gt;&amp;lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&amp;gt;&lt;/code&gt; 와 같은 콘텐츠 해시 를 URL에 효과적으로 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="ba6b36cd4f00846ae8eece4fc8d354f0678413c6" translate="yes" xml:space="preserve">
          <source>To use configuration property scanning, add the &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt; annotation to your application. Typically, it is added to the main application class that is annotated with &lt;code&gt;@SpringBootApplication&lt;/code&gt; but it can be added to any &lt;code&gt;@Configuration&lt;/code&gt; class. By default, scanning will occur from the package of the class that declares the annotation. If you want to define specific packages to scan, you can do so as shown in the following example:</source>
          <target state="translated">구성 속성 스캔을 사용하려면 &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt; 주석을 애플리케이션에 추가합니다 . 일반적으로 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 으로 주석이 달린 기본 애플리케이션 클래스에 추가되지만 모든 &lt;code&gt;@Configuration&lt;/code&gt; 클래스에 추가 할 수 있습니다 . 기본적으로 주석을 선언하는 클래스의 패키지에서 스캔이 발생합니다. 스캔 할 특정 패키지를 정의하려면 다음 예에 표시된대로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4df377ab19485c8e94bcb9c3fd11297b10aeeb3" translate="yes" xml:space="preserve">
          <source>To use constructor binding the class must be enabled using &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; or configuration property scanning. You cannot use constructor binding with beans that are created by the regular Spring mechanisms (e.g. &lt;code&gt;@Component&lt;/code&gt; beans, beans created via &lt;code&gt;@Bean&lt;/code&gt; methods or beans loaded using &lt;code&gt;@Import&lt;/code&gt;)</source>
          <target state="translated">생성자 바인딩을 사용하려면 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 또는 구성 속성 스캔을 사용하여 클래스를 활성화해야합니다 . 당신은 (예를 들어 일반 스프링 메커니즘에 의해 생성 된 콩 바인딩 생성자를 사용할 수 없습니다 &lt;code&gt;@Component&lt;/code&gt; 통해 생성 된 콩, 콩 &lt;code&gt;@Bean&lt;/code&gt; 사용 방법이나 콩로드 된 &lt;code&gt;@Import&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="4a4571f1714e8a1753db34e3cb3c68d5d0ec4195" translate="yes" xml:space="preserve">
          <source>To use the factory bean, wire &lt;code&gt;StreamsBuilder&lt;/code&gt; into your &lt;code&gt;@Bean&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">팩토리 빈을 사용하려면 다음 예제와 같이 &lt;code&gt;StreamsBuilder&lt;/code&gt; 를 &lt;code&gt;@Bean&lt;/code&gt; 에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="5ebaeec9bf614df4be39d99298f4b39f9c743da4" translate="yes" xml:space="preserve">
          <source>To use the processor, include a dependency on &lt;code&gt;spring-boot-configuration-processor&lt;/code&gt;.</source>
          <target state="translated">프로세서를 사용하려면 &lt;code&gt;spring-boot-configuration-processor&lt;/code&gt; 에 대한 종속성을 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="f573223c600422d4eddb9891fac45218d46f643e" translate="yes" xml:space="preserve">
          <source>To use version agnostic URLs for Webjars, add the &lt;code&gt;webjars-locator-core&lt;/code&gt; dependency. Then declare your Webjar. Using jQuery as an example, adding &lt;code&gt;&quot;/webjars/jquery/jquery.min.js&quot;&lt;/code&gt; results in &lt;code&gt;&quot;/webjars/jquery/x.y.z/jquery.min.js&quot;&lt;/code&gt; where &lt;code&gt;x.y.z&lt;/code&gt; is the Webjar version.</source>
          <target state="translated">Webjars에 버전에 구애받지 않는 URL을 사용하려면 &lt;code&gt;webjars-locator-core&lt;/code&gt; 종속성을 추가하십시오 . 그런 다음 Webjar를 선언하십시오. 추가 예로서 jQuery를 사용하여 &lt;code&gt;&quot;/webjars/jquery/jquery.min.js&quot;&lt;/code&gt; 결과 &lt;code&gt;&quot;/webjars/jquery/x.y.z/jquery.min.js&quot;&lt;/code&gt; &lt;code&gt;x.y.z&lt;/code&gt; Webjar 버전이다.</target>
        </trans-unit>
        <trans-unit id="0bbcfcd889b86b993317c5f361655ec5e2c24f36" translate="yes" xml:space="preserve">
          <source>To work with &lt;code&gt;@ConfigurationProperties&lt;/code&gt; beans, you can inject them in the same way as any other bean, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;@ConfigurationProperties&lt;/code&gt; Bean에 대해 작업하려면 다음 예제에 표시된대로 다른 Bean과 동일한 방식으로 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a0d7d7d8e6343434f03db48b10e32574249c0fd" translate="yes" xml:space="preserve">
          <source>Tomcat</source>
          <target state="translated">Tomcat</target>
        </trans-unit>
        <trans-unit id="91e8b91d5c574bd17e0311fd1c54df5015f9c38d" translate="yes" xml:space="preserve">
          <source>Tomcat 9.0</source>
          <target state="translated">톰캣 9.0</target>
        </trans-unit>
        <trans-unit id="0e3a2df5d8db2fcf82a6a73727f283d41a7e6ca3" translate="yes" xml:space="preserve">
          <source>Tomcat base directory. If not specified, a temporary directory is used.</source>
          <target state="translated">Tomcat 기본 디렉토리. 지정하지 않으면 임시 디렉토리가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd0cdd681674f386aee7a82465011651ef75a4db" translate="yes" xml:space="preserve">
          <source>Tomcat datasource specific settings bound to an instance of Tomcat JDBC's DataSource</source>
          <target state="translated">Tomcat JDBC의 DataSource 인스턴스에 바인딩 된 Tomcat 데이터 소스 특정 설정</target>
        </trans-unit>
        <trans-unit id="8d8aaffc99e7d388edf44b6fa6be220482443087" translate="yes" xml:space="preserve">
          <source>Tomcat is also configured with a default regular expression that matches internal proxies that are to be trusted. By default, IP addresses in &lt;code&gt;10/8&lt;/code&gt;, &lt;code&gt;192.168/16&lt;/code&gt;, &lt;code&gt;169.254/16&lt;/code&gt; and &lt;code&gt;127/8&lt;/code&gt; are trusted. You can customize the valve&amp;rsquo;s configuration by adding an entry to &lt;code&gt;application.properties&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">Tomcat은 또한 신뢰할 수있는 내부 프록시와 일치하는 기본 정규식으로 구성됩니다. 기본적으로 &lt;code&gt;10/8&lt;/code&gt; , &lt;code&gt;192.168/16&lt;/code&gt; , &lt;code&gt;169.254/16&lt;/code&gt; 및 &lt;code&gt;127/8&lt;/code&gt; 의 IP 주소 가 신뢰됩니다. 다음 예제에 표시된대로 &lt;code&gt;application.properties&lt;/code&gt; 에 항목을 추가하여 밸브의 구성을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0cd978b92098762d3dbd384be99c16125b8c68d" translate="yes" xml:space="preserve">
          <source>Tomcat metrics (&lt;code&gt;server.tomcat.mbeanregistry.enabled&lt;/code&gt; must be set to &lt;code&gt;true&lt;/code&gt; for all Tomcat metrics to be registered)</source>
          <target state="translated">Tomcat 메트릭 ( 모든 Tomcat 메트릭을 등록 하려면 &lt;code&gt;server.tomcat.mbeanregistry.enabled&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 )</target>
        </trans-unit>
        <trans-unit id="c31a517a1e961932ca24e01953683e1952da1a8c" translate="yes" xml:space="preserve">
          <source>Total length of a single payload should be kept within your network's MTU.</source>
          <target state="translated">단일 페이로드의 총 길이는 네트워크의 MTU 내에 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="999f121e5def84ff7cb388aef725e7ea52805368" translate="yes" xml:space="preserve">
          <source>Total memory size the producer can use to buffer records waiting to be sent to the server.</source>
          <target state="translated">생산자가 서버로 전송 대기중인 레코드를 버퍼링하는 데 사용할 수있는 총 메모리 크기입니다.</target>
        </trans-unit>
        <trans-unit id="1ff0ea389cc083f8c20dbdc10d4b94064dd4e759" translate="yes" xml:space="preserve">
          <source>Total size of log backups to be kept.</source>
          <target state="translated">보관할 로그 백업의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="194db2e708fa01996c59361ff80bcff823dfcec4" translate="yes" xml:space="preserve">
          <source>Tracks the application&amp;rsquo;s PID by using &lt;code&gt;/var/run/&amp;lt;appname&amp;gt;/&amp;lt;appname&amp;gt;.pid&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/var/run/&amp;lt;appname&amp;gt;/&amp;lt;appname&amp;gt;.pid&lt;/code&gt; 를 사용하여 애플리케이션의 PID를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="627a8c3dcf098deb5d3fe89f3f356f80349ba5f4" translate="yes" xml:space="preserve">
          <source>Traditionally, JPA &amp;ldquo;Entity&amp;rdquo; classes are specified in a &lt;code&gt;persistence.xml&lt;/code&gt; file. With Spring Boot, this file is not necessary and &amp;ldquo;Entity Scanning&amp;rdquo; is used instead. By default, all packages below your main configuration class (the one annotated with &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; or &lt;code&gt;@SpringBootApplication&lt;/code&gt;) are searched.</source>
          <target state="translated">일반적으로 JPA &quot;Entity&quot;클래스는 &lt;code&gt;persistence.xml&lt;/code&gt; 파일에 지정되어 있습니다. Spring Boot에서는이 파일이 필요하지 않으며 대신 &quot;Entity Scanning&quot;이 사용됩니다. 기본적으로 기본 구성 클래스 아래의 모든 패키지 ( &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 또는 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 로 주석이 달린 패키지 )가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="29d003870a257287d1df3c8e4f337853d000d270" translate="yes" xml:space="preserve">
          <source>Transaction logs directory.</source>
          <target state="translated">트랜잭션 로그 디렉토리.</target>
        </trans-unit>
        <trans-unit id="b45bbb72686c6f3c52c5e0fc1e6dd848c8f30537" translate="yes" xml:space="preserve">
          <source>Transaction manager implementation that should be started.</source>
          <target state="translated">시작해야하는 트랜잭션 관리자 구현입니다.</target>
        </trans-unit>
        <trans-unit id="17ca20775330ea9d4b066f0683bc785cd855af20" translate="yes" xml:space="preserve">
          <source>Transaction manager unique identifier.</source>
          <target state="translated">트랜잭션 관리자 고유 식별자.</target>
        </trans-unit>
        <trans-unit id="5979d55d0d1e60227e4395c3abd1f1946e8afdcb" translate="yes" xml:space="preserve">
          <source>Transactional tests are not supported with reactive access. If you are using this style, you must configure &lt;code&gt;@DataNeo4jTest&lt;/code&gt; tests as described above.</source>
          <target state="translated">반응 적 액세스에서는 트랜잭션 테스트가 지원되지 않습니다. 이 스타일을 사용하는 경우 위에서 설명한대로 &lt;code&gt;@DataNeo4jTest&lt;/code&gt; 테스트를 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6c9a9a4386943d5de82c9dae180382229e6c66ae" translate="yes" xml:space="preserve">
          <source>Transactions log file base name.</source>
          <target state="translated">트랜잭션 로그 파일 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6ddc76a2202854953b15b1d6bbdb5080e0796ad0" translate="yes" xml:space="preserve">
          <source>Triggering a restart</source>
          <target state="translated">재시작 트리거</target>
        </trans-unit>
        <trans-unit id="13c028fa16c262ab0e25411d592c7b1e9d58ce00" translate="yes" xml:space="preserve">
          <source>Trust store that holds SSL certificates.</source>
          <target state="translated">SSL 인증서를 보유하는 신뢰 저장소.</target>
        </trans-unit>
        <trans-unit id="07f3a73e994ba05a7203b2774cfb7d088abb5db4" translate="yes" xml:space="preserve">
          <source>Trust store type.</source>
          <target state="translated">신뢰 저장소 유형.</target>
        </trans-unit>
        <trans-unit id="0623d45902fcbb7c1170054e369ff25f951ba824" translate="yes" xml:space="preserve">
          <source>Trust strategy to use.</source>
          <target state="translated">사용할 신뢰 전략.</target>
        </trans-unit>
        <trans-unit id="581b3da98ddfb8335176e73d03ac48ebbc15749d" translate="yes" xml:space="preserve">
          <source>Try Kotlin in your browser</source>
          <target state="translated">브라우저에서 Kotlin 사용해보기</target>
        </trans-unit>
        <trans-unit id="1d866de5fab333d470710dd23f302981ae604b74" translate="yes" xml:space="preserve">
          <source>Try the &lt;a href=&quot;howto#howto&quot;&gt;How-to documents&lt;/a&gt;. They provide solutions to the most common questions.</source>
          <target state="translated">&lt;a href=&quot;howto#howto&quot;&gt;방법 문서를&lt;/a&gt; 사용해보십시오 . 가장 일반적인 질문에 대한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="81df25f4da8827871b3351f861a9dc734774967a" translate="yes" xml:space="preserve">
          <source>Tutorial: building web applications with Spring Boot and Kotlin</source>
          <target state="translated">가이드 : Spring Boot 및 Kotlin으로 웹 애플리케이션 빌드</target>
        </trans-unit>
        <trans-unit id="4f01a5f504b6f32f75e70897bac1ab0fb0e0883e" translate="yes" xml:space="preserve">
          <source>Two popular cloud providers, Heroku and Cloud Foundry, employ a &amp;ldquo;buildpack&amp;rdquo; approach. The buildpack wraps your deployed code in whatever is needed to &lt;em&gt;start&lt;/em&gt; your application. It might be a JDK and a call to &lt;code&gt;java&lt;/code&gt;, an embedded web server, or a full-fledged application server. A buildpack is pluggable, but ideally you should be able to get by with as few customizations to it as possible. This reduces the footprint of functionality that is not under your control. It minimizes divergence between development and production environments.</source>
          <target state="translated">인기있는 두 클라우드 제공 업체 인 Heroku와 Cloud Foundry는 &quot;빌드 팩&quot;접근 방식을 사용합니다. 빌드 팩은 애플리케이션 을 &lt;em&gt;시작하는&lt;/em&gt; 데 필요한 모든 것에 배포 된 코드를 래핑합니다 . JDK 및 &lt;code&gt;java&lt;/code&gt; 에 대한 호출 , 내장 웹 서버 또는 본격적인 애플리케이션 서버 일 수 있습니다. 빌드 팩은 플러그 가능하지만 이상적으로는 가능한 한 적은 수의 사용자 정의로 얻을 수 있어야합니다. 이렇게하면 제어 할 수없는 기능의 풋 프린트가 줄어 듭니다. 개발 환경과 프로덕션 환경 간의 차이를 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="f6fb23c1829740181b8abe567d4013a56967b910" translate="yes" xml:space="preserve">
          <source>Type &lt;code&gt;spring help jar&lt;/code&gt; on the command line for more information.</source>
          <target state="translated">자세한 내용은 명령 줄에 &lt;code&gt;spring help jar&lt;/code&gt; 를 입력 하십시오.</target>
        </trans-unit>
        <trans-unit id="e37e580e4119598a274c41571ffdaae191300701" translate="yes" xml:space="preserve">
          <source>Type of Cassandra repositories to enable.</source>
          <target state="translated">활성화 할 Cassandra 저장소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="34802f86b492e75b0771845215fd6a9fde720f8c" translate="yes" xml:space="preserve">
          <source>Type of Couchbase repositories to enable.</source>
          <target state="translated">활성화 할 Couchbase 저장소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6741e63b66a55550f2aa0e5579e27d41294e64da" translate="yes" xml:space="preserve">
          <source>Type of Mongo repositories to enable.</source>
          <target state="translated">활성화 할 Mongo 저장소 유형입니다.</target>
        </trans-unit>
        <trans-unit id="0715803f1dddb6c9f5ab68bedf5189410b92e9b3" translate="yes" xml:space="preserve">
          <source>Type of Neo4j repositories to enable.</source>
          <target state="translated">활성화 할 Neo4j 저장소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="f701b5bc2a61b85cbd76690cec0f8ac842e76b91" translate="yes" xml:space="preserve">
          <source>Type of client to use. By default, auto-detected according to the classpath.</source>
          <target state="translated">사용할 클라이언트 유형입니다. 기본적으로 클래스 경로에 따라 자동 감지됩니다.</target>
        </trans-unit>
        <trans-unit id="e2aff7dbd29671a817eab8f6eacfd8473fa0718a" translate="yes" xml:space="preserve">
          <source>Type of publisher confirms to use.</source>
          <target state="translated">사용을 확인하는 게시자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a1d6c91bb766bb004d35a0bd0044abae79dd21c4" translate="yes" xml:space="preserve">
          <source>Type of shutdown that the server will support.</source>
          <target state="translated">서버가 지원할 종료 유형입니다.</target>
        </trans-unit>
        <trans-unit id="31e141da37ec71b3d43ba4fb3ebfbe3751ae0a47" translate="yes" xml:space="preserve">
          <source>Type of the key store.</source>
          <target state="translated">키 저장소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="2796c5dd875c2c0c515b4690c9e118265e76acf7" translate="yes" xml:space="preserve">
          <source>Type of the trust store.</source>
          <target state="translated">신뢰 저장소의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="abf58822f52224de08dfbc3fcc79e0b66adc4fa4" translate="yes" xml:space="preserve">
          <source>Type-safe Configuration Properties</source>
          <target state="translated">형식이 안전한 구성 속성</target>
        </trans-unit>
        <trans-unit id="306bb5e6fa61f4f2729e486da449a62c4032aaf5" translate="yes" xml:space="preserve">
          <source>Typically, migrations are scripts in the form &lt;code&gt;V&amp;lt;VERSION&amp;gt;__&amp;lt;NAME&amp;gt;.sql&lt;/code&gt; (with &lt;code&gt;&amp;lt;VERSION&amp;gt;&lt;/code&gt; an underscore-separated version, such as &amp;lsquo;1&amp;rsquo; or &amp;lsquo;2_1&amp;rsquo;). By default, they are in a directory called &lt;code&gt;classpath:db/migration&lt;/code&gt;, but you can modify that location by setting &lt;code&gt;spring.flyway.locations&lt;/code&gt;. This is a comma-separated list of one or more &lt;code&gt;classpath:&lt;/code&gt; or &lt;code&gt;filesystem:&lt;/code&gt; locations. For example, the following configuration would search for scripts in both the default classpath location and the &lt;code&gt;/opt/migration&lt;/code&gt; directory:</source>
          <target state="translated">일반적으로 마이그레이션은 &lt;code&gt;V&amp;lt;VERSION&amp;gt;__&amp;lt;NAME&amp;gt;.sql&lt;/code&gt; 형식의 스크립트입니다 ( &lt;code&gt;&amp;lt;VERSION&amp;gt;&lt;/code&gt; 은 '1'또는 '2_1'과 같이 밑줄로 구분 된 버전). 기본적으로 &lt;code&gt;classpath:db/migration&lt;/code&gt; 이라는 디렉토리 에 있지만 &lt;code&gt;spring.flyway.locations&lt;/code&gt; 를 설정하여 해당 위치를 수정할 수 있습니다 . 하나 이상의 &lt;code&gt;classpath:&lt;/code&gt; 또는 &lt;code&gt;filesystem:&lt;/code&gt; 위치 의 쉼표로 구분 된 목록입니다 . 예를 들어 다음 구성은 기본 클래스 경로 위치와 &lt;code&gt;/opt/migration&lt;/code&gt; 디렉토리 모두에서 스크립트를 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="57c6897c2ff85203a8c6f15de509953ff47a06b5" translate="yes" xml:space="preserve">
          <source>UDP addressing mode, either unicast or multicast.</source>
          <target state="translated">유니 캐스트 또는 멀티 캐스트의 UDP 주소 지정 모드.</target>
        </trans-unit>
        <trans-unit id="25ba44ec3b391ba4ce5fbbd2979635e254775e7d" translate="yes" xml:space="preserve">
          <source>UNKNOWN</source>
          <target state="translated">UNKNOWN</target>
        </trans-unit>
        <trans-unit id="11a66854c0ed7fd7fbaf5a561663c5dc867c9f19" translate="yes" xml:space="preserve">
          <source>UP</source>
          <target state="translated">UP</target>
        </trans-unit>
        <trans-unit id="82e5f8cb0afd0a8fc12c60e00bf8a876f4e9653c" translate="yes" xml:space="preserve">
          <source>URI for the Atlas LWC endpoint to evaluate the data for a subscription.</source>
          <target state="translated">구독 데이터를 평가하기위한 Atlas LWC 엔드 포인트의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="e254fabcfb4af699584d8a7ae2aade3728e90775" translate="yes" xml:space="preserve">
          <source>URI for the Atlas LWC endpoint to retrieve current subscriptions.</source>
          <target state="translated">현재 구독을 검색하기위한 Atlas LWC 엔드 포인트의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="2d45d7281fc9e77b29d5b362db5a8b1b1be6cd8d" translate="yes" xml:space="preserve">
          <source>URI of the Atlas server.</source>
          <target state="translated">Atlas 서버의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="2a300b4198cba91811ee44c8600fdabf6a778456" translate="yes" xml:space="preserve">
          <source>URI of the Influx server.</source>
          <target state="translated">Influx 서버의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="39de44275d339b62a24c6346f6e2919f927087fd" translate="yes" xml:space="preserve">
          <source>URI of the KairosDB server.</source>
          <target state="translated">KairosDB 서버의 URI입니다.</target>
        </trans-unit>
        <trans-unit id="7287388520fef9af270e987ed326d680210d9611" translate="yes" xml:space="preserve">
          <source>URI that can either be an OpenID Connect discovery endpoint or an OAuth 2.0 Authorization Server Metadata endpoint defined by RFC 8414.</source>
          <target state="translated">OpenID Connect 검색 엔드 포인트 또는 RFC 8414에 의해 정의 된 OAuth 2.0 권한 부여 서버 메타 데이터 엔드 포인트 일 수있는 URI입니다.</target>
        </trans-unit>
        <trans-unit id="fbcdf5d8f896093a241a0e79f396eaaa45106cfa" translate="yes" xml:space="preserve">
          <source>URI to ship metrics to.</source>
          <target state="translated">메트릭을 전달할 URI입니다.</target>
        </trans-unit>
        <trans-unit id="576e605d6d417e6d8f4f89ce31bcdce089e33870" translate="yes" xml:space="preserve">
          <source>URI to ship metrics to. If you need to publish metrics to an internal proxy en-route to Datadog, you can define the location of the proxy with this.</source>
          <target state="translated">메트릭을 전달할 URI입니다. Datadog으로가는 도중에 내부 프록시에 메트릭을 게시해야하는 경우이를 사용하여 프록시 위치를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0628050def50bad40cb0410b9483861afcdb29f" translate="yes" xml:space="preserve">
          <source>URI to ship metrics to. If you need to publish metrics to an internal proxy en-route to Humio, you can define the location of the proxy with this.</source>
          <target state="translated">메트릭을 전달할 URI입니다. Humio로가는 도중에 내부 프록시에 메트릭을 게시해야하는 경우이를 사용하여 프록시 위치를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a8df0d596d0b25be5cb661e54701c3fbedb3b5" translate="yes" xml:space="preserve">
          <source>URI to ship metrics to. Should be used for SaaS, self managed instances or to en-route through an internal proxy.</source>
          <target state="translated">메트릭을 전달할 URI입니다. SaaS, 자체 관리 형 인스턴스 또는 내부 프록시를 통해 경로를 지정하는 데 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ceeba41fc89adba0cf65685cfc69ba345a72880f" translate="yes" xml:space="preserve">
          <source>URI used by the driver.</source>
          <target state="translated">드라이버에서 사용하는 URI입니다.</target>
        </trans-unit>
        <trans-unit id="ff82cdc4064164729912444950fcbbbc6e6b8e93" translate="yes" xml:space="preserve">
          <source>URL of the ActiveMQ broker. Auto-generated by default.</source>
          <target state="translated">ActiveMQ 브로커의 URL입니다. 기본적으로 자동 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="a8fe3e49d7b49c5631b8b918d2594ac9b250d3eb" translate="yes" xml:space="preserve">
          <source>URL of the InfluxDB instance to which to connect.</source>
          <target state="translated">연결할 InfluxDB 인스턴스의 URL입니다.</target>
        </trans-unit>
        <trans-unit id="769af4be7324809aaad53b251df7da35e4071cf7" translate="yes" xml:space="preserve">
          <source>Unconditionally activate the specified comma-separated list of profiles (or list of profiles if using YAML).</source>
          <target state="translated">지정된 쉼표로 구분 된 프로필 목록 (또는 YAML을 사용하는 경우 프로필 목록)을 무조건 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="27b88d799bcbb8220eb816fed000faec696e0ea1" translate="yes" xml:space="preserve">
          <source>Under the hood, Spring Boot uses a different type of &lt;code&gt;ApplicationContext&lt;/code&gt; for embedded servlet container support. The &lt;code&gt;ServletWebServerApplicationContext&lt;/code&gt; is a special type of &lt;code&gt;WebApplicationContext&lt;/code&gt; that bootstraps itself by searching for a single &lt;code&gt;ServletWebServerFactory&lt;/code&gt; bean. Usually a &lt;code&gt;TomcatServletWebServerFactory&lt;/code&gt;, &lt;code&gt;JettyServletWebServerFactory&lt;/code&gt;, or &lt;code&gt;UndertowServletWebServerFactory&lt;/code&gt; has been auto-configured.</source>
          <target state="translated">내부적으로 Spring Boot는 임베디드 서블릿 컨테이너 지원을 위해 다른 유형의 &lt;code&gt;ApplicationContext&lt;/code&gt; 를 사용합니다 . &lt;code&gt;ServletWebServerApplicationContext&lt;/code&gt; 은 특별한 유형 &lt;code&gt;WebApplicationContext&lt;/code&gt; 그 하나를 검색하여 부트 스트랩 자체를 &lt;code&gt;ServletWebServerFactory&lt;/code&gt; 의 콩. 일반적으로 &lt;code&gt;TomcatServletWebServerFactory&lt;/code&gt; , &lt;code&gt;JettyServletWebServerFactory&lt;/code&gt; 또는 &lt;code&gt;UndertowServletWebServerFactory&lt;/code&gt; 가 자동 구성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee3f6b4a191afaef70e566af1a569b8dde9a6e8f" translate="yes" xml:space="preserve">
          <source>Under the hood, auto-configuration is implemented with standard &lt;code&gt;@Configuration&lt;/code&gt; classes. Additional &lt;code&gt;@Conditional&lt;/code&gt; annotations are used to constrain when the auto-configuration should apply. Usually, auto-configuration classes use &lt;code&gt;@ConditionalOnClass&lt;/code&gt; and &lt;code&gt;@ConditionalOnMissingBean&lt;/code&gt; annotations. This ensures that auto-configuration applies only when relevant classes are found and when you have not declared your own &lt;code&gt;@Configuration&lt;/code&gt;.</source>
          <target state="translated">내부적으로 자동 구성은 표준 &lt;code&gt;@Configuration&lt;/code&gt; 클래스로 구현됩니다 . 추가 &lt;code&gt;@Conditional&lt;/code&gt; 주석은 자동 구성을 적용해야하는시기를 제한하는 데 사용됩니다. 일반적으로 자동 구성 클래스는 &lt;code&gt;@ConditionalOnClass&lt;/code&gt; 및 &lt;code&gt;@ConditionalOnMissingBean&lt;/code&gt; 주석을 사용합니다. 이렇게하면 관련 클래스가 발견되고 자신의 &lt;code&gt;@Configuration&lt;/code&gt; 을 선언하지 않은 경우에만 자동 구성이 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2daf2564b43d3af147d901ed275de89c0a88346b" translate="yes" xml:space="preserve">
          <source>Underlying implementation class name of the XA resource.</source>
          <target state="translated">XA 리소스의 기본 구현 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7993f4d09aa7006c6cce4bf1789fe288530708bc" translate="yes" xml:space="preserve">
          <source>Underscore notation, which is an alternative format for use in &lt;code&gt;.properties&lt;/code&gt; and &lt;code&gt;.yml&lt;/code&gt; files.</source>
          <target state="translated">&lt;code&gt;.properties&lt;/code&gt; 및 &lt;code&gt;.yml&lt;/code&gt; 파일 에서 사용하기위한 대체 형식 인 밑줄 표기법 입니다.</target>
        </trans-unit>
        <trans-unit id="e15b56c87d3bf8555f16e6bea0a4cc80d38115f9" translate="yes" xml:space="preserve">
          <source>Undertow</source>
          <target state="translated">Undertow</target>
        </trans-unit>
        <trans-unit id="4d4625c23b9a67402021084a54ba86d02d07967f" translate="yes" xml:space="preserve">
          <source>Undertow 2.0</source>
          <target state="translated">언더 토우 2.0</target>
        </trans-unit>
        <trans-unit id="5df119d0507358970364bcbfd1b96b9996720277" translate="yes" xml:space="preserve">
          <source>Undertow access log directory.</source>
          <target state="translated">Undertow 액세스 로그 디렉토리.</target>
        </trans-unit>
        <trans-unit id="f5d3ca8a600d096e78521c454d6ddd4f41aa469c" translate="yes" xml:space="preserve">
          <source>Undertow does not support JSPs.</source>
          <target state="translated">Undertow는 JSP를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f51c4f2459aa9c139f6684cefbffdad39e606de1" translate="yes" xml:space="preserve">
          <source>Unfortunately, several third-party libraries deserialize without considering the context classloader. If you find such a problem, you need to request a fix with the original authors.</source>
          <target state="translated">불행히도 여러 타사 라이브러리는 컨텍스트 클래스 로더를 고려하지 않고 역 직렬화합니다. 이러한 문제를 발견하면 원저자에게 수정을 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="b406fd8d12e379b522158caa7187046c3e623613" translate="yes" xml:space="preserve">
          <source>Unique identifier for the app instance that is the source of metrics being published to Wavefront. Defaults to the local host name.</source>
          <target state="translated">Wavefront에 게시되는 메트릭의 소스 인 앱 인스턴스의 고유 식별자입니다. 기본값은 로컬 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7009aedbac798beff00a5efc3c122e916adb02b2" translate="yes" xml:space="preserve">
          <source>Unique name used to identify the resource during recovery.</source>
          <target state="translated">복구 중에 리소스를 식별하는 데 사용되는 고유 한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4ca9a50b84a5e47188770e1ea1eb63f1c0e2dabc" translate="yes" xml:space="preserve">
          <source>Unique string that identifies the consumer group to which this consumer belongs.</source>
          <target state="translated">이 소비자가 속한 소비자 그룹을 식별하는 고유 한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4db0ce0ec9b9bab383032bc59da34601d585fe31" translate="yes" xml:space="preserve">
          <source>Uniquely identifies the app instance that is publishing metrics to SignalFx. Defaults to the local host name.</source>
          <target state="translated">SignalFx에 메트릭을 게시하는 앱 인스턴스를 고유하게 식별합니다. 기본값은 로컬 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="99d0d185366dff17077a26a26f5906d451aa9447" translate="yes" xml:space="preserve">
          <source>Unless the &lt;code&gt;spring.jooq.sql-dialect&lt;/code&gt; property has been configured, Spring Boot determines the SQL dialect to use for your datasource. If Spring Boot could not detect the dialect, it uses &lt;code&gt;DEFAULT&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spring.jooq.sql-dialect&lt;/code&gt; 속성이 구성되어 있지 않으면 Spring Boot는 데이터 소스에 사용할 SQL 언어를 결정합니다. Spring Boot가 방언을 감지하지 못하면 &lt;code&gt;DEFAULT&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="0fc03bf8183917e3737efebfe615eae134b165d4" translate="yes" xml:space="preserve">
          <source>Unless the management port has been configured to &lt;a href=&quot;#production-ready-customizing-management-server-port&quot;&gt;expose endpoints by using a different HTTP port&lt;/a&gt;, &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; is relative to &lt;code&gt;server.servlet.context-path&lt;/code&gt; (Servlet web applications) or &lt;code&gt;spring.webflux.base-path&lt;/code&gt; (reactive web applications). If &lt;code&gt;management.server.port&lt;/code&gt; is configured, &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; is relative to &lt;code&gt;management.server.base-path&lt;/code&gt;.</source>
          <target state="translated">관리 포트가 구성되어 있지 않은 &lt;a href=&quot;#production-ready-customizing-management-server-port&quot;&gt;다른 HTTP 포트를 이용하여 엔드 포인트를 노출&lt;/a&gt; , &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; 에 상대적인 &lt;code&gt;server.servlet.context-path&lt;/code&gt; (서블릿 웹 애플리케이션) 또는 &lt;code&gt;spring.webflux.base-path&lt;/code&gt; ( 반응 형 웹 애플리케이션). 경우 &lt;code&gt;management.server.port&lt;/code&gt; 가 구성되어 &lt;code&gt;management.endpoints.web.base-path&lt;/code&gt; 에 상대적인 &lt;code&gt;management.server.base-path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7e077904c44aaef08ea36706c425b8008b6bbd3" translate="yes" xml:space="preserve">
          <source>Unlike the equivalent Java application, you do not need to include a &lt;code&gt;public static void main(String[] args)&lt;/code&gt; method with your &lt;code&gt;Groovy&lt;/code&gt; scripts. A &lt;code&gt;SpringApplication&lt;/code&gt; is automatically created, with your compiled code acting as the &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">동등한 Java 애플리케이션과 달리, &lt;code&gt;Groovy&lt;/code&gt; 스크립트에 &lt;code&gt;public static void main(String[] args)&lt;/code&gt; 메소드 를 포함 할 필요가 없습니다 . &lt;code&gt;SpringApplication&lt;/code&gt; 은 자동으로 컴파일 된 코드가 역할을 함께 만들어 &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e5fd95b92003658ce47721181589f7c621196b10" translate="yes" xml:space="preserve">
          <source>Upgrading instructions are always the first item in the release notes. If you are more than one release behind, please make sure that you also review the release notes of the versions that you jumped.</source>
          <target state="translated">업그레이드 지침은 항상 릴리스 정보의 첫 번째 항목입니다. 둘 이상의 릴리스가 뒤처진 경우 점프 한 버전의 릴리스 노트도 검토해야합니다.</target>
        </trans-unit>
        <trans-unit id="5f852e8ffed963fb691399132e42808b6463d427" translate="yes" xml:space="preserve">
          <source>Upload binaries instead of sources</source>
          <target state="translated">소스 대신 바이너리 업로드</target>
        </trans-unit>
        <trans-unit id="ca96637664a220b2f0ef82bb367945605fab34b5" translate="yes" xml:space="preserve">
          <source>Upper case format with underscore as the delimiter (see &lt;a href=&quot;#boot-features-external-config-relaxed-binding-from-environment-variables&quot;&gt;Binding from Environment Variables&lt;/a&gt;).</source>
          <target state="translated">구분 기호로 밑줄이있는 대문자 형식 ( &lt;a href=&quot;#boot-features-external-config-relaxed-binding-from-environment-variables&quot;&gt;환경 변수에서 바인딩&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="1f896e26a190b167ccc06d32ffdf0e1c6ba06364" translate="yes" xml:space="preserve">
          <source>Upper case format, which is recommended when using system environment variables.</source>
          <target state="translated">시스템 환경 변수를 사용할 때 권장되는 대문자 형식입니다.</target>
        </trans-unit>
        <trans-unit id="9126698b321b399f279348bd7f2d5dd265b42b3f" translate="yes" xml:space="preserve">
          <source>Uptime metrics: report a gauge for uptime and a fixed gauge representing the application&amp;rsquo;s absolute start time</source>
          <target state="translated">가동 시간 메트릭 : 가동 시간에 대한 게이지 및 애플리케이션의 절대 시작 시간을 나타내는 고정 게이지보고</target>
        </trans-unit>
        <trans-unit id="105a028d2cb7ed53d9a1ec90cb9cd687935f2eff" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;java.time.Duration&lt;/code&gt; rather than &lt;code&gt;long&lt;/code&gt; and describe the default unit if it differs from milliseconds, e.g. &quot;If a duration suffix is not specified, seconds will be used&quot;.</source>
          <target state="translated">사용 &lt;code&gt;java.time.Duration&lt;/code&gt; 이 아닌 &lt;code&gt;long&lt;/code&gt; 은 &quot;기간 접미사를 지정하지 않으면, 초 사용됩니다&quot;, 밀리 초에서 예를 다른 경우와 기본 단위를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d627eb6089fb036ddf8db3068b175a292bc84d18" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;org.springframework.boot.devtools.RemoteSpringApplication&lt;/code&gt; as the main class.</source>
          <target state="translated">&lt;code&gt;org.springframework.boot.devtools.RemoteSpringApplication&lt;/code&gt; 을 기본 클래스로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="36139e7d49e8e7fd6a7c34571b7d5ac523791ed1" translate="yes" xml:space="preserve">
          <source>Use a placeholder in configuration properties:</source>
          <target state="translated">구성 속성에서 자리 표시자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c92cdce65ba68d982f02ca6bc941c1f3bc812ab3" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;spring-boot-starter-cache&lt;/code&gt; &amp;ldquo;Starter&amp;rdquo; to quickly add basic caching dependencies. The starter brings in &lt;code&gt;spring-context-support&lt;/code&gt;. If you add dependencies manually, you must include &lt;code&gt;spring-context-support&lt;/code&gt; in order to use the JCache, EhCache 2.x, or Caffeine support.</source>
          <target state="translated">사용 &lt;code&gt;spring-boot-starter-cache&lt;/code&gt; 신속하게 기본 캐시 종속성을 추가하는 &quot;초보&quot;를. 스타터는 &lt;code&gt;spring-context-support&lt;/code&gt; 를 가져옵니다 . 종속성을 수동으로 추가 하는 경우 JCache, EhCache 2.x 또는 Caffeine 지원을 사용하려면 &lt;code&gt;spring-context-support&lt;/code&gt; 를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="261589f015e9bb1144ded71b5feb0b0a2ec985ef" translate="yes" xml:space="preserve">
          <source>Use the appropriate launcher (such as &lt;code&gt;JarLauncher&lt;/code&gt; for a jar file) as a &lt;code&gt;Main-Class&lt;/code&gt; attribute in the manifest and specify the other properties it needs as manifest entries &amp;mdash; principally, by setting a &lt;code&gt;Start-Class&lt;/code&gt; property.</source>
          <target state="translated">적절한 시작 관리자 (예 : jar 파일의 경우 &lt;code&gt;JarLauncher&lt;/code&gt; )를 매니페스트 의 &lt;code&gt;Main-Class&lt;/code&gt; 속성으로 사용하고 매니페스트 항목으로 필요한 다른 속성을 지정합니다. 주로 &lt;code&gt;Start-Class&lt;/code&gt; 속성 을 설정하여 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="e58a3b99db2361062809a8397a4bde9f052e9fa0" translate="yes" xml:space="preserve">
          <source>Use the prefix &lt;code&gt;optional:&lt;/code&gt; if the &lt;a href=&quot;#boot-features-external-config-optional-prefix&quot;&gt;locations are optional&lt;/a&gt; and you don&amp;rsquo;t mind if they don&amp;rsquo;t exist.</source>
          <target state="translated">사용 접두사 &lt;code&gt;optional:&lt;/code&gt; 경우 &lt;a href=&quot;#boot-features-external-config-optional-prefix&quot;&gt;위치는 선택&lt;/a&gt; 과 그들이 존재하지 않는 경우에 당신이 마음을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ff07cdba4d13a2eec504151ffece9d630e633df" translate="yes" xml:space="preserve">
          <source>Used to resolve relative paths in &lt;code&gt;loader.path&lt;/code&gt;. For example, given &lt;code&gt;loader.path=lib&lt;/code&gt;, then &lt;code&gt;${loader.home}/lib&lt;/code&gt; is a classpath location (along with all jar files in that directory). This property is also used to locate a &lt;code&gt;loader.properties&lt;/code&gt; file, as in the following example &lt;code&gt;&lt;a href=&quot;file:///opt/app&quot;&gt;/opt/app&lt;/a&gt;&lt;/code&gt; It defaults to &lt;code&gt;${user.dir}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;loader.path&lt;/code&gt; 에서 상대 경로를 확인하는 데 사용됩니다 . 예를 들어, 주어진 &lt;code&gt;loader.path=lib&lt;/code&gt; 에 , 다음 &lt;code&gt;${loader.home}/lib&lt;/code&gt; (디렉토리에있는 모든 jar 파일과 함께) 클래스 경로의 위치입니다. 이 속성은 다음 예제에서와 같이 &lt;code&gt;loader.properties&lt;/code&gt; 파일 을 찾는데도 사용됩니다. &lt;code&gt;&lt;a href=&quot;file:///opt/app&quot;&gt;/opt/app&lt;/a&gt;&lt;/code&gt; 기본값은 &lt;code&gt;${user.dir}&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ab5506a7f5412a5000f83db3cbe09d94b20ea74" translate="yes" xml:space="preserve">
          <source>User to use to connect to the JMS provider.</source>
          <target state="translated">JMS 공급자에 연결하는 데 사용할 사용자입니다.</target>
        </trans-unit>
        <trans-unit id="dec1e9bb0360b77006be5a8fd9afeb048cf44f9c" translate="yes" xml:space="preserve">
          <source>Username of the database to execute DDL scripts (if different).</source>
          <target state="translated">DDL 스크립트를 실행할 데이터베이스의 사용자 이름입니다 (다른 경우).</target>
        </trans-unit>
        <trans-unit id="df69e3422a0a8cee83e24189f0a7e34ce90cbd7f" translate="yes" xml:space="preserve">
          <source>Username of the database to execute DML scripts (if different).</source>
          <target state="translated">DML 스크립트를 실행할 데이터베이스의 사용자 이름입니다 (다른 경우).</target>
        </trans-unit>
        <trans-unit id="30dfac2f56a7ad1937c64a307327002c46f65896" translate="yes" xml:space="preserve">
          <source>Username recorded in the schema history table as having applied the migration.</source>
          <target state="translated">마이그레이션을 적용한 것으로 스키마 기록 테이블에 기록 된 사용자 이름입니다.</target>
        </trans-unit>
        <trans-unit id="49e8a4d248f04d7ba28d8f9eb8f69ab3acb55da4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;@ConfigurationProperties&lt;/code&gt; also lets you generate metadata files that can be used by IDEs to offer auto-completion for your own keys. See the &lt;a href=&quot;appendix-configuration-metadata#configuration-metadata&quot;&gt;appendix&lt;/a&gt; for details.</source>
          <target state="translated">사용 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 은 또한 당신이 당신의 자신의 키에 대해 제공 자동 완성에 IDE를 사용할 수 있습니다 메타 데이터 파일을 생성 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;appendix-configuration-metadata#configuration-metadata&quot;&gt;부록&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86da806be35e1a21acd3c86c2f8ad0f5d98155bf" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ConfigFileApplicationContextInitializer&lt;/code&gt; alone does not provide support for &lt;code&gt;@Value(&quot;${&amp;hellip;​}&quot;)&lt;/code&gt; injection. Its only job is to ensure that &lt;code&gt;application.properties&lt;/code&gt; files are loaded into Spring&amp;rsquo;s &lt;code&gt;Environment&lt;/code&gt;. For &lt;code&gt;@Value&lt;/code&gt; support, you need to either additionally configure a &lt;code&gt;PropertySourcesPlaceholderConfigurer&lt;/code&gt; or use &lt;code&gt;@SpringBootTest&lt;/code&gt;, which auto-configures one for you.</source>
          <target state="translated">&lt;code&gt;ConfigFileApplicationContextInitializer&lt;/code&gt; 만 사용하면 &lt;code&gt;@Value(&quot;${&amp;hellip;​}&quot;)&lt;/code&gt; 삽입이 지원되지 않습니다 . 유일한 작업은 &lt;code&gt;application.properties&lt;/code&gt; 파일이 Spring의 &lt;code&gt;Environment&lt;/code&gt; 에 로드 되도록하는 것 입니다. 들어 &lt;code&gt;@Value&lt;/code&gt; 의 지원, 당신도 추가로 구성 할 필요가 &lt;code&gt;PropertySourcesPlaceholderConfigurer&lt;/code&gt; 를 사용하거나 &lt;code&gt;@SpringBootTest&lt;/code&gt; 하는 자동차를 구성하고, 당신을 위해 하나.</target>
        </trans-unit>
        <trans-unit id="232643314fe540e277c4dbd5a37125668776ae4f" translate="yes" xml:space="preserve">
          <source>Using Spring Boot</source>
          <target state="translated">Spring Boot 사용</target>
        </trans-unit>
        <trans-unit id="b0b35af64cf6e8d4bde4e00da3139587c649abec" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;MeterBinder&lt;/code&gt; ensures that the correct dependency relationships are set up and that the bean is available when the metric&amp;rsquo;s value is retrieved. By default, metrics from all &lt;code&gt;MeterBinder&lt;/code&gt; beans will be automatically bound to the Spring-managed &lt;code&gt;MeterRegistry&lt;/code&gt;. A &lt;code&gt;MeterBinder&lt;/code&gt; implementation can also be useful if you find that you repeatedly instrument a suite of metrics across components or applications.</source>
          <target state="translated">&lt;code&gt;MeterBinder&lt;/code&gt; 를 사용 하면 올바른 종속성 관계가 설정되고 메트릭 값이 검색 될 때 Bean을 사용할 수 있습니다. 기본적으로 모든 &lt;code&gt;MeterBinder&lt;/code&gt; Bean의 메트릭 은 Spring 관리 &lt;code&gt;MeterRegistry&lt;/code&gt; 에 자동으로 바인딩됩니다 . &lt;code&gt;MeterBinder&lt;/code&gt; 를 찾을 경우 구현은 유용 할 수 있습니다 당신이 반복적으로 악기 구성 요소 나 응용 프로그램에서 메트릭의 제품군을 그.</target>
        </trans-unit>
        <trans-unit id="2be9e29a9245867605d2a7b1e6281e41f51bdb6d" translate="yes" xml:space="preserve">
          <source>Using configuration such as the preceding example means the application no longer supports a plain HTTP connector at port 8080. Spring Boot does not support the configuration of both an HTTP connector and an HTTPS connector through &lt;code&gt;application.properties&lt;/code&gt;. If you want to have both, you need to configure one of them programmatically. We recommend using &lt;code&gt;application.properties&lt;/code&gt; to configure HTTPS, as the HTTP connector is the easier of the two to configure programmatically.</source>
          <target state="translated">앞의 예제와 같은 구성을 사용하면 애플리케이션이 더 이상 포트 8080에서 일반 HTTP 커넥터를 지원하지 않습니다. Spring Boot는 &lt;code&gt;application.properties&lt;/code&gt; 를 통해 HTTP 커넥터와 HTTPS 커넥터의 구성을 모두 지원하지 않습니다 . 둘 다 포함하려면 둘 중 하나를 프로그래밍 방식으로 구성해야합니다. HTTP 커넥터가 프로그래밍 방식으로 구성하는 것이 더 쉽기 때문에 &lt;code&gt;application.properties&lt;/code&gt; 를 사용하여 HTTPS를 구성하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6df71dd0d4d1dcb80ca563c0529e7b21cf6fbfd0" translate="yes" xml:space="preserve">
          <source>Using graceful shutdown with your IDE may not work properly if it does not send a proper &lt;code&gt;SIGTERM&lt;/code&gt; signal. Refer to the documentation of your IDE for more details.</source>
          <target state="translated">적절한 &lt;code&gt;SIGTERM&lt;/code&gt; 신호를 보내지 않으면 IDE에서 정상 종료를 사용하면 제대로 작동하지 않을 수 있습니다. 자세한 내용은 IDE 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba597ba695853fba0c6cfd2bcd7492a46228c468" translate="yes" xml:space="preserve">
          <source>Using spring boot</source>
          <target state="translated">스프링 부트 사용</target>
        </trans-unit>
        <trans-unit id="6057c37f4ad19c91728bb926eba4cf0721724e42" translate="yes" xml:space="preserve">
          <source>Using the &amp;ldquo;exejar&amp;rdquo; Task</source>
          <target state="translated">&quot;exejar&quot;작업 사용</target>
        </trans-unit>
        <trans-unit id="0101e78c501781c5ae1c16480935d4da5d425614" translate="yes" xml:space="preserve">
          <source>Using the &amp;ldquo;findmainclass&amp;rdquo; Task</source>
          <target state="translated">&quot;findmainclass&quot;작업 사용</target>
        </trans-unit>
        <trans-unit id="7b01669e858e201635ab4e3959d3315f0d501cfa" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;@Value(&quot;${property}&quot;)&lt;/code&gt; annotation to inject configuration properties can sometimes be cumbersome, especially if you are working with multiple properties or your data is hierarchical in nature. Spring Boot provides an alternative method of working with properties that lets strongly typed beans govern and validate the configuration of your application.</source>
          <target state="translated">은 Using &lt;code&gt;@Value(&quot;${property}&quot;)&lt;/code&gt; 분사 구성 속성에 주석 때로는 여러 속성 작업 또는 데이터가 자연 계층, 특히 경우 번거로울 수 있습니다. Spring Boot는 강력한 유형의 Bean이 애플리케이션의 구성을 관리하고 유효성을 검사 할 수 있도록하는 속성 작업의 대체 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1f8ba49c282439a0ab26651ad29a3adb795c325e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;JarLauncher&lt;/code&gt; over the application&amp;rsquo;s main method has the added benefit of a predictable classpath order. The jar contains a &lt;code&gt;classpath.idx&lt;/code&gt; file which is used by the &lt;code&gt;JarLauncher&lt;/code&gt; when constructing the classpath.</source>
          <target state="translated">응용 프로그램의 기본 메서드에 대해 &lt;code&gt;JarLauncher&lt;/code&gt; 를 사용하면 예측 가능한 클래스 경로 순서의 추가 이점이 있습니다. jar에는 &lt;code&gt;classpath.idx&lt;/code&gt; 구성 할 때 &lt;code&gt;JarLauncher&lt;/code&gt; 에서 사용 하는 classpath.idx 파일이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f1886e62dc25a8ce4c42a8a5cea86b655977fa4" translate="yes" xml:space="preserve">
          <source>Using the CLI</source>
          <target state="translated">CLI 사용</target>
        </trans-unit>
        <trans-unit id="51e9fb10a5b5d70a4a914ded19e9b8a92558263a" translate="yes" xml:space="preserve">
          <source>Using the Java SE Platform</source>
          <target state="translated">Java SE 플랫폼 사용</target>
        </trans-unit>
        <trans-unit id="f6863ecb4b67b3265691b5d41cf3451e2e18f9ea" translate="yes" xml:space="preserve">
          <source>Using the S2I builder</source>
          <target state="translated">S2I 빌더 사용</target>
        </trans-unit>
        <trans-unit id="13e5b8862ae89349fb14ef715ad8c3f700a51770" translate="yes" xml:space="preserve">
          <source>Using the Tomcat Platform</source>
          <target state="translated">Tomcat 플랫폼 사용</target>
        </trans-unit>
        <trans-unit id="03813f38146afe15598caec1d6484a54a54022d4" translate="yes" xml:space="preserve">
          <source>Using the multi-document YAML syntax in profile-specific YAML files can lead to unexpected behavior. For example, consider the following config in a file:</source>
          <target state="translated">프로필 별 YAML 파일에서 다중 문서 YAML 구문을 사용하면 예기치 않은 동작이 발생할 수 있습니다. 예를 들어 파일에서 다음 구성을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="57c8e251a6d18af5e829337162b68a23a5e05e0b" translate="yes" xml:space="preserve">
          <source>Using the “exejar” Task</source>
          <target state="translated">&quot;exejar&quot;작업 사용</target>
        </trans-unit>
        <trans-unit id="c0135d5dc370cdb0547a3a93d1d268190ab11ed9" translate="yes" xml:space="preserve">
          <source>Using the “findmainclass” Task</source>
          <target state="translated">&quot;findmainclass&quot;작업 사용</target>
        </trans-unit>
        <trans-unit id="24a271451e65e20717de9aee72e172c4a79d419b" translate="yes" xml:space="preserve">
          <source>Utils</source>
          <target state="translated">Utils</target>
        </trans-unit>
        <trans-unit id="9ca5b42e13c2fcef84ca89753b19f03046e7d142" translate="yes" xml:space="preserve">
          <source>Validation depth.</source>
          <target state="translated">검증 깊이.</target>
        </trans-unit>
        <trans-unit id="793bcdfed156c84ee16ae95443780036d0c74b2a" translate="yes" xml:space="preserve">
          <source>Validation query.</source>
          <target state="translated">유효성 검사 쿼리.</target>
        </trans-unit>
        <trans-unit id="0636e27ff82cdc0b8c80b95d6bee5c4f5635de65" translate="yes" xml:space="preserve">
          <source>Value of a default routing key to use for send operations.</source>
          <target state="translated">보내기 작업에 사용할 기본 라우팅 키 값입니다.</target>
        </trans-unit>
        <trans-unit id="1bce275605291903c99bc9b92cd5cef092ba097e" translate="yes" xml:space="preserve">
          <source>Value of the protocol header indicating whether the incoming request uses SSL.</source>
          <target state="translated">들어오는 요청이 SSL을 사용하는지 여부를 나타내는 프로토콜 헤더의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e417aa7a08949074fd38d41360647237944d1fee" translate="yes" xml:space="preserve">
          <source>Value to use for the Server response header (if empty, no header is sent).</source>
          <target state="translated">서버 응답 헤더에 사용할 값입니다 (비어있는 경우 헤더가 전송되지 않음).</target>
        </trans-unit>
        <trans-unit id="749237f79710dbb14c717ad467770c4d7835d5b7" translate="yes" xml:space="preserve">
          <source>ValueHint[]</source>
          <target state="translated">ValueHint[]</target>
        </trans-unit>
        <trans-unit id="23182abfffa1e84ff155f3ee21455a0f33e463c6" translate="yes" xml:space="preserve">
          <source>ValueProvider[]</source>
          <target state="translated">ValueProvider[]</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="0255dc3f55cf9062adc0eefc64291f76979d0a02" translate="yes" xml:space="preserve">
          <source>Vanilla usage of Spring &lt;code&gt;DispatcherServlet&lt;/code&gt; and Spring Security should require no further changes. If you have other features in your application (for instance, using other servlets or filters), you may need to add some configuration to your &lt;code&gt;Application&lt;/code&gt; context, by replacing those elements from the &lt;code&gt;web.xml&lt;/code&gt;, as follows:</source>
          <target state="translated">Spring &lt;code&gt;DispatcherServlet&lt;/code&gt; 및 Spring Security 의 Vanilla 사용은 추가 변경이 필요하지 않습니다. 애플리케이션에 다른 기능이있는 경우 (예 : 다른 서블릿 또는 필터 사용) 다음과 같이 &lt;code&gt;web.xml&lt;/code&gt; 의 해당 요소를 대체 하여 &lt;code&gt;Application&lt;/code&gt; 컨텍스트에 일부 구성을 추가해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="c45b3fd7fe4a4703a29c4492ea7d84ad8c01c61d" translate="yes" xml:space="preserve">
          <source>Various memory and buffer pools</source>
          <target state="translated">다양한 메모리 및 버퍼 풀</target>
        </trans-unit>
        <trans-unit id="dabaca3b4ceaad3d31dd698c6b5374e716ac1569" translate="yes" xml:space="preserve">
          <source>Various properties can be specified inside your &lt;code&gt;application.properties&lt;/code&gt; file, inside your &lt;code&gt;application.yml&lt;/code&gt; file, or as command line switches. This appendix provides a list of common Spring Boot properties and references to the underlying classes that consume them.</source>
          <target state="translated">&lt;code&gt;application.properties&lt;/code&gt; 파일 내부, &lt;code&gt;application.yml&lt;/code&gt; 파일 내부 또는 명령 줄 스위치로 다양한 속성을 지정할 수 있습니다 . 이 부록에서는 일반적인 Spring Boot 속성 목록과이를 사용하는 기본 클래스에 대한 참조를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a0ae8193e40c48a491aa4ece64504fc8813d8220" translate="yes" xml:space="preserve">
          <source>Vendor-specific XA properties.</source>
          <target state="translated">공급 업체별 XA 속성.</target>
        </trans-unit>
        <trans-unit id="7336f5e8e4a8c57a46c9a84737f88b668082ce60" translate="yes" xml:space="preserve">
          <source>Vendor-specific implementation of XAConnectionFactory.</source>
          <target state="translated">XAConnectionFactory의 공급 업체별 구현.</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="c7cc2d9f24d44f4638005d50a9d3b8a9f0fc1b76" translate="yes" xml:space="preserve">
          <source>Version Property</source>
          <target state="translated">버전 속성</target>
        </trans-unit>
        <trans-unit id="5d6499cf207a0a1ad787a9cdfd2b6b01be3763ec" translate="yes" xml:space="preserve">
          <source>Version of Mongo to use.</source>
          <target state="translated">사용할 Mongo 버전입니다.</target>
        </trans-unit>
        <trans-unit id="d8ad7e93c3e103c0b3e7b5745bba0f48b273c1c8" translate="yes" xml:space="preserve">
          <source>Version string to use for the fixed Version Strategy.</source>
          <target state="translated">고정 버전 전략에 사용할 버전 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4b8c133b523eddc0c120c704c7a63ef0f4e05d8c" translate="yes" xml:space="preserve">
          <source>Version to tag an existing schema with when executing baseline.</source>
          <target state="translated">기준을 실행할 때 기존 스키마에 태그를 지정할 버전입니다.</target>
        </trans-unit>
        <trans-unit id="62686b404a96eed41f5d9ffc47990e083f7cab9d" translate="yes" xml:space="preserve">
          <source>View names that can be resolved.</source>
          <target state="translated">확인할 수있는 이름을 봅니다.</target>
        </trans-unit>
        <trans-unit id="5a0d7820f11354ca3b4e25830607cff2d234ab6a" translate="yes" xml:space="preserve">
          <source>Virtual host to use when connecting to the broker.</source>
          <target state="translated">브로커에 연결할 때 사용할 가상 호스트입니다.</target>
        </trans-unit>
        <trans-unit id="99439b047d496d85e6b4b582033610cf3c351f4a" translate="yes" xml:space="preserve">
          <source>Wavefront</source>
          <target state="translated">Wavefront</target>
        </trans-unit>
        <trans-unit id="7b8203979ab39e3aa4094aa46945cf0ecc18185d" translate="yes" xml:space="preserve">
          <source>Wavefront registry pushes metrics to &lt;a href=&quot;https://micrometer.io/docs/registry/wavefront&quot;&gt;Wavefront&lt;/a&gt; periodically. If you are exporting metrics to &lt;a href=&quot;https://www.wavefront.com/&quot;&gt;Wavefront&lt;/a&gt; directly, your API token must be provided:</source>
          <target state="translated">Wavefront 레지스트리는 주기적으로 메트릭을 &lt;a href=&quot;https://micrometer.io/docs/registry/wavefront&quot;&gt;Wavefront에&lt;/a&gt; 푸시 합니다. 지표를 &lt;a href=&quot;https://www.wavefront.com/&quot;&gt;Wavefront로&lt;/a&gt; 직접 내보내는 경우 API 토큰을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="3d652ef0512f495d5a12247d68df1db16c75f028" translate="yes" xml:space="preserve">
          <source>We also provide a &lt;code&gt;spring-boot-starter-data-redis-reactive&lt;/code&gt; &amp;ldquo;Starter&amp;rdquo; for consistency with the other stores with reactive support.</source>
          <target state="translated">또한 사후 지원을 통해 다른 상점과의 일관성을 위해 &lt;code&gt;spring-boot-starter-data-redis-reactive&lt;/code&gt; &amp;ldquo;Starter&amp;rdquo;를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f88696762e132d073e24da12027a56e55350cd16" translate="yes" xml:space="preserve">
          <source>We are also more than happy to extend this section. If you want to add a &amp;lsquo;how-to&amp;rsquo;, send us a &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="translated">또한이 섹션을 확장하게되어 기쁩니다. '방법'을 추가하려면 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0&quot;&gt;풀 요청을&lt;/a&gt; 보내주세요 .</target>
        </trans-unit>
        <trans-unit id="e724a60e5e7c734b3ef58ad90e820f316d664bf0" translate="yes" xml:space="preserve">
          <source>We can also update the state of the application, when the application breaks and cannot recover:</source>
          <target state="translated">응용 프로그램이 중단되어 복구 할 수없는 경우 응용 프로그램의 상태를 업데이트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4eb2b6d392d2ce78486b990b80c2fa5cc112e7e1" translate="yes" xml:space="preserve">
          <source>We do not go into too many details of JPA or &lt;a href=&quot;https://spring.io/projects/spring-data&quot;&gt;Spring Data&lt;/a&gt; here. You can follow the &lt;a href=&quot;https://spring.io/guides/gs/accessing-data-jpa/&quot;&gt;&amp;ldquo;Accessing Data with JPA&amp;rdquo;&lt;/a&gt; guide from &lt;a href=&quot;https://spring.io&quot;&gt;spring.io&lt;/a&gt; and read the &lt;a href=&quot;https://spring.io/projects/spring-data-jpa&quot;&gt;Spring Data JPA&lt;/a&gt; and &lt;a href=&quot;https://hibernate.org/orm/documentation/&quot;&gt;Hibernate&lt;/a&gt; reference documentation.</source>
          <target state="translated">우리는 JPA 또는 너무 많은 세부 사항에 가지 마세요 &lt;a href=&quot;https://spring.io/projects/spring-data&quot;&gt;봄 데이터&lt;/a&gt; 여기. 당신은 따를 수 있습니다 &lt;a href=&quot;https://spring.io/guides/gs/accessing-data-jpa/&quot;&gt;&quot;데이터 액세스 JPA와&quot;&lt;/a&gt; 에서 가이드 &lt;a href=&quot;https://spring.io&quot;&gt;spring.io을&lt;/a&gt; 하고 읽어 &lt;a href=&quot;https://spring.io/projects/spring-data-jpa&quot;&gt;봄 데이터 JPA&lt;/a&gt; 와 &lt;a href=&quot;https://hibernate.org/orm/documentation/&quot;&gt;최대 절전 모드&lt;/a&gt; 참조 문서를.</target>
        </trans-unit>
        <trans-unit id="896ae35827d0a402f2cd54cdb750b361ff3ff8f3" translate="yes" xml:space="preserve">
          <source>We finish our example by creating a completely self-contained executable jar file that we could run in production. Executable jars (sometimes called &amp;ldquo;fat jars&amp;rdquo;) are archives containing your compiled classes along with all of the jar dependencies that your code needs to run.</source>
          <target state="translated">프로덕션에서 실행할 수있는 완전히 독립적 인 실행 가능 jar 파일을 생성하여 예제를 마칩니다. 실행 가능한 jar ( &quot;fat jar&quot;라고도 함)는 코드를 실행하는 데 필요한 모든 jar 종속성과 함께 컴파일 된 클래스를 포함하는 아카이브입니다.</target>
        </trans-unit>
        <trans-unit id="ee9382bd1b18298c6b5b6d6a90b1d63af92bf674" translate="yes" xml:space="preserve">
          <source>We generally find these common libraries to be useful when writing tests. If these libraries do not suit your needs, you can add additional test dependencies of your own.</source>
          <target state="translated">일반적으로 이러한 공통 라이브러리는 테스트를 작성할 때 유용합니다. 이러한 라이브러리가 필요에 맞지 않으면 자체 테스트 종속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eef3ce5d157a92206dd1a82d57a9fbaeb9f414da" translate="yes" xml:space="preserve">
          <source>We generally recommend that you locate your main application class in a root package above other classes. The &lt;a href=&quot;#using-boot-using-springbootapplication-annotation&quot;&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt; annotation&lt;/a&gt; is often placed on your main class, and it implicitly defines a base &amp;ldquo;search package&amp;rdquo; for certain items. For example, if you are writing a JPA application, the package of the &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotated class is used to search for &lt;code&gt;@Entity&lt;/code&gt; items. Using a root package also allows component scan to apply only on your project.</source>
          <target state="translated">일반적으로 다른 클래스 위의 루트 패키지에서 기본 애플리케이션 클래스를 찾는 것이 좋습니다. &lt;a href=&quot;#using-boot-using-springbootapplication-annotation&quot;&gt; &lt;code&gt;@SpringBootApplication&lt;/code&gt; 의 주석은&lt;/a&gt; 종종 메인 클래스에 배치, 그리고 암시 적으로 특정 항목에 대한 기본 &quot;검색 패키지&quot;를 정의합니다. 예를 들어 JPA 응용 프로그램을 작성하는 경우 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 주석이 달린 클래스 의 패키지가 &lt;code&gt;@Entity&lt;/code&gt; 항목 을 검색하는 데 사용됩니다 . 루트 패키지를 사용하면 구성 요소 스캔이 프로젝트에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f7ba2747a31b1716c6a12ce63801ca69c7d1c08" translate="yes" xml:space="preserve">
          <source>We have barely scratched the surface of Spring Data JPA. For complete details, see the &lt;a href=&quot;https://docs.spring.io/spring-data/jdbc/docs/2.1.1/reference/html/&quot;&gt;Spring Data JPA reference documentation&lt;/a&gt;.</source>
          <target state="translated">우리는 SpringData JPA의 표면을 거의 긁지 않았습니다. 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-data/jdbc/docs/2.1.1/reference/html/&quot;&gt;SpringData JPA 참조 문서를 참조&lt;/a&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="d3303b780f5bb3e3ce842dec5c5ca3ef218abf62" translate="yes" xml:space="preserve">
          <source>We have barely scratched the surface of Spring Data R2DBC. For complete details, see the &lt;a href=&quot;https://docs.spring.io/spring-data/r2dbc/docs/1.2.1/reference/html/&quot;&gt;Spring Data R2DBC reference documentation&lt;/a&gt;.</source>
          <target state="translated">우리는 SpringData R2DBC의 표면을 거의 긁지 않았습니다. 자세한 내용은 &lt;a href=&quot;https://docs.spring.io/spring-data/r2dbc/docs/1.2.1/reference/html/&quot;&gt;SpringData R2DBC 참조 문서를 참조하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0aa75e3e651c71b29cde84f8a321c4446f63cdd" translate="yes" xml:space="preserve">
          <source>We need to start by creating a Maven &lt;code&gt;pom.xml&lt;/code&gt; file. The &lt;code&gt;pom.xml&lt;/code&gt; is the recipe that is used to build your project. Open your favorite text editor and add the following:</source>
          <target state="translated">먼저 Maven &lt;code&gt;pom.xml&lt;/code&gt; 파일 을 만들어야 합니다. &lt;code&gt;pom.xml&lt;/code&gt; 프로젝트를 빌드하는 데 사용되는 조리법이다. 좋아하는 텍스트 편집기를 열고 다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7f6b7a55dee80393e8ef62788549610380c3c5df" translate="yes" xml:space="preserve">
          <source>We prefer &lt;a href=&quot;https://github.com/brettwooldridge/HikariCP&quot;&gt;HikariCP&lt;/a&gt; for its performance and concurrency. If HikariCP is available, we always choose it.</source>
          <target state="translated">우리 는 성능과 동시성을 위해 &lt;a href=&quot;https://github.com/brettwooldridge/HikariCP&quot;&gt;HikariCP&lt;/a&gt; 를 선호 합니다. HikariCP를 사용할 수있는 경우 항상 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b957d7f968f6faf774c21a0db86d96417f27eff0" translate="yes" xml:space="preserve">
          <source>We recommend disabling CSRF protection completely only if you are creating a service that is used by non-browser clients.</source>
          <target state="translated">브라우저가 아닌 클라이언트에서 사용하는 서비스를 생성하는 경우에만 CSRF 보호를 완전히 비활성화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d5d6ccc488e731bf91014a67330776445ca1c3d3" translate="yes" xml:space="preserve">
          <source>We recommend that &lt;code&gt;@ConfigurationProperties&lt;/code&gt; only deal with the environment and, in particular, does not inject other beans from the context. For corner cases, setter injection can be used or any of the &lt;code&gt;*Aware&lt;/code&gt; interfaces provided by the framework (such as &lt;code&gt;EnvironmentAware&lt;/code&gt; if you need access to the &lt;code&gt;Environment&lt;/code&gt;). If you still want to inject other beans using the constructor, the configuration properties bean must be annotated with &lt;code&gt;@Component&lt;/code&gt; and use JavaBean-based property binding.</source>
          <target state="translated">&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 는 환경 만 처리하고 특히 컨텍스트에서 다른 Bean을 주입하지 않는 것이 좋습니다 . 코너 케이스의 경우 setter 주입 또는 프레임 워크에서 제공 하는 &lt;code&gt;*Aware&lt;/code&gt; 인터페이스 (예 : &lt;code&gt;EnvironmentAware&lt;/code&gt; 액세스해야하는 경우 &lt;code&gt;Environment&lt;/code&gt; Aware )를 사용할 수 있습니다. 여전히 생성자를 사용하여 다른 빈을 삽입하려면 구성 속성 빈에 &lt;code&gt;@Component&lt;/code&gt; 주석을 달고 JavaBean 기반 속성 바인딩을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8899f2fed29479c34cbcde701c53c6fbe76558f3" translate="yes" xml:space="preserve">
          <source>We recommend that you don&amp;rsquo;t mix profile-specific YAML files and multiple YAML documents. Stick to using only one of them.</source>
          <target state="translated">프로필 별 YAML 파일과 여러 YAML 문서를 혼합하지 않는 것이 좋습니다. 그중 하나만 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9b70097ec59569eca3c44682fc7f1b365ffb0d4c" translate="yes" xml:space="preserve">
          <source>We recommend that you follow Java&amp;rsquo;s recommended package naming conventions and use a reversed domain name (for example, &lt;code&gt;com.example.project&lt;/code&gt;).</source>
          <target state="translated">Java의 권장 패키지 이름 지정 규칙을 따르고 역 도메인 이름 (예 : &lt;code&gt;com.example.project&lt;/code&gt; ) 을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e234b874facaa6dcf97f02c0b58d3b2c75bea799" translate="yes" xml:space="preserve">
          <source>We recommend that you use an &lt;code&gt;Enum&lt;/code&gt; for those two values instead. If your IDE supports it, this is by far the most effective approach to auto-completion.</source>
          <target state="translated">대신이 두 값에 대해 &lt;code&gt;Enum&lt;/code&gt; 을 사용하는 것이 좋습니다 . IDE에서 지원하는 경우 이것이 자동 완성에 대한 가장 효과적인 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="c817a2952b904c087a49ee2dcdfc50519070efca" translate="yes" xml:space="preserve">
          <source>We recommend that, when possible, properties are stored in lower-case kebab format, such as &lt;code&gt;my.property-name=acme&lt;/code&gt;.</source>
          <target state="translated">가능하면 속성을 &lt;code&gt;my.property-name=acme&lt;/code&gt; 와 같은 소문자 케밥 형식으로 저장하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="a8323a2a9b34ae7e0cbe8181ebcfe45bf2c5f3aa" translate="yes" xml:space="preserve">
          <source>Web</source>
          <target state="translated">Web</target>
        </trans-unit>
        <trans-unit id="f99c160590a9ffce61c3d2227997931a937022c2" translate="yes" xml:space="preserve">
          <source>Web Application Conditions</source>
          <target state="translated">웹 애플리케이션 조건</target>
        </trans-unit>
        <trans-unit id="b8d55e75dffe79e6c560076d706895d601ee8279" translate="yes" xml:space="preserve">
          <source>Web Endpoint Range Requests</source>
          <target state="translated">웹 끝점 범위 요청</target>
        </trans-unit>
        <trans-unit id="6fbee6b61a463a11a91017130d9f5345f6c3cc8e" translate="yes" xml:space="preserve">
          <source>Web Endpoint Request Predicates</source>
          <target state="translated">웹 끝점 요청 조건 자</target>
        </trans-unit>
        <trans-unit id="748647235bc5257e337ccceffc983d59943ea3b3" translate="yes" xml:space="preserve">
          <source>Web Endpoint Response Status</source>
          <target state="translated">웹 엔드 포인트 응답 상태</target>
        </trans-unit>
        <trans-unit id="5e8b05e01b9874942eeadc8735d913a867dc91a3" translate="yes" xml:space="preserve">
          <source>Web Endpoint Security</source>
          <target state="translated">웹 엔드 포인트 보안</target>
        </trans-unit>
        <trans-unit id="ca04e0450b467d53b5e82364bc827d34a4af1e0b" translate="yes" xml:space="preserve">
          <source>Web Filter</source>
          <target state="translated">웹 필터</target>
        </trans-unit>
        <trans-unit id="619f84c1657ff482222e4b665ae0d3864a0b40b5" translate="yes" xml:space="preserve">
          <source>WebFlux and MVC end-to-end testing</source>
          <target state="translated">WebFlux 및 MVC 종단 간 테스트</target>
        </trans-unit>
        <trans-unit id="c15bdace14e18785727454d67379714557de1e29" translate="yes" xml:space="preserve">
          <source>WebFlux integration tests</source>
          <target state="translated">WebFlux 통합 테스트</target>
        </trans-unit>
        <trans-unit id="b4710ac6f7c8df7dd715e0ed9cdad5af24d5b60e" translate="yes" xml:space="preserve">
          <source>WebFlux is part of the Spring Framework and detailed information is available in its &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web-reactive.html#webflux-fn&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">WebFlux는 Spring Framework의 일부이며 자세한 정보는 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web-reactive.html#webflux-fn&quot;&gt;참조 문서&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24dcab53ee6c1cabc2dea7cdc32bc91ef200bd6f" translate="yes" xml:space="preserve">
          <source>WebSocket RSocket server uri to connect to.</source>
          <target state="translated">연결할 WebSocket RSocket 서버 URI입니다.</target>
        </trans-unit>
        <trans-unit id="d9465cfbbb0e0efce12171008ba13b3e41807416" translate="yes" xml:space="preserve">
          <source>WebSocket support is also available for &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web-reactive.html#webflux-websocket&quot;&gt;reactive web applications&lt;/a&gt; and requires to include the WebSocket API alongside &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt;:</source>
          <target state="translated">WebSocket 지원은 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web-reactive.html#webflux-websocket&quot;&gt;반응 형 웹 애플리케이션&lt;/a&gt; 에도 사용할 수 있으며 &lt;code&gt;spring-boot-starter-webflux&lt;/code&gt; 와 함께 WebSocket API를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08a2e2f5be9a856ad9b156db19e32f1fc14b6332" translate="yes" xml:space="preserve">
          <source>Well-known FreeMarker keys which are passed to FreeMarker's Configuration.</source>
          <target state="translated">FreeMarker의 구성에 전달되는 잘 알려진 FreeMarker 키입니다.</target>
        </trans-unit>
        <trans-unit id="e77c28b7aa56a4f5276e436761a44f9a751c1922" translate="yes" xml:space="preserve">
          <source>What to do when there is no initial offset in Kafka or if the current offset no longer exists on the server.</source>
          <target state="translated">Kafka에 초기 오프셋이 없거나 현재 오프셋이 서버에 더 이상 존재하지 않는 경우 수행 할 작업.</target>
        </trans-unit>
        <trans-unit id="3e35a27aaf4de3289456a70a97ee911483f12087" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s in a name</source>
          <target state="translated">이름에있는 것</target>
        </trans-unit>
        <trans-unit id="79419526a7d7ca60a75ad36fe038a3ac56b41185" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;https://activemq.apache.org/&quot;&gt;ActiveMQ&lt;/a&gt; is available on the classpath, Spring Boot can also configure a &lt;code&gt;ConnectionFactory&lt;/code&gt;. If the broker is present, an embedded broker is automatically started and configured (provided no broker URL is specified through configuration).</source>
          <target state="translated">때 &lt;a href=&quot;https://activemq.apache.org/&quot;&gt;의 ActiveMQ는&lt;/a&gt; 클래스 패스에 사용할 수 있으며, 봄 부팅도 구성 할 수 있습니다 &lt;code&gt;ConnectionFactory&lt;/code&gt; 를을 . 브로커가있는 경우 포함 된 브로커가 자동으로 시작되고 구성됩니다 (구성을 통해 브로커 URL을 지정하지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="25128af6d0b28c714a72aba63740947dee6fb537" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;@EnableCaching&lt;/code&gt; is present in your configuration, a suitable cache configuration is expected as well. If you need to disable caching altogether in certain environments, force the cache type to &lt;code&gt;none&lt;/code&gt; to use a no-op implementation, as shown in the following example:</source>
          <target state="translated">때 &lt;code&gt;@EnableCaching&lt;/code&gt; 이 구성에 존재하는, 적절한 캐시 구성은 물론 예상된다. 특정 환경에서 캐싱을 모두 비활성화해야하는 경우 다음 예제와 같이 no-op 구현을 사용 하려면 캐시 유형을 &lt;code&gt;none&lt;/code&gt; 으로 강제 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="97bf78f883e0fd07909909d8283aa3e497ad8f23" translate="yes" xml:space="preserve">
          <source>When Kubernetes deletes an application instance, the shutdown process involves several subsystems concurrently: shutdown hooks, unregistering the service, removing the instance from the load-balancer&amp;hellip;​ Because this shutdown processing happens in parallel (and due to the nature of distributed systems), there is a window during which traffic can be routed to a pod that has also begun its shutdown processing.</source>
          <target state="translated">Kubernetes가 애플리케이션 인스턴스를 삭제할 때 종료 프로세스에는 여러 하위 시스템이 동시에 포함됩니다. 종료 후크, 서비스 등록 취소,로드 밸런서에서 인스턴스 제거&amp;hellip; 종료 처리도 시작된 포드로 트래픽을 라우팅 할 수있는 기간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d682075a87932e85e000a6c9da2e9064e60edc0" translate="yes" xml:space="preserve">
          <source>When Micrometer&amp;rsquo;s &lt;code&gt;micrometer-jersey2&lt;/code&gt; module is on the classpath, auto-configuration enables the instrumentation of requests handled by the Jersey JAX-RS implementation. When &lt;code&gt;management.metrics.web.server.request.autotime.enabled&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this instrumentation occurs for all requests. Alternatively, when set to &lt;code&gt;false&lt;/code&gt;, you can enable instrumentation by adding &lt;code&gt;@Timed&lt;/code&gt; to a request-handling method:</source>
          <target state="translated">Micrometer의 &lt;code&gt;micrometer-jersey2&lt;/code&gt; 모듈이 클래스 경로에있는 경우 자동 구성을 통해 Jersey JAX-RS 구현에서 처리하는 요청을 계측 할 수 있습니다. 때 &lt;code&gt;management.metrics.web.server.request.autotime.enabled&lt;/code&gt; 이 있다 &lt;code&gt;true&lt;/code&gt; ,이 장비는 모든 요청에 대해 발생합니다. 또는 &lt;code&gt;false&lt;/code&gt; 로 설정 하면 요청 처리 메서드에 &lt;code&gt;@Timed&lt;/code&gt; 를 추가하여 계측을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c805b3a7f1ca35978d14d39e1fbd70b95dc11157" translate="yes" xml:space="preserve">
          <source>When Reactor Netty is on the classpath a Reactor Netty-based &lt;code&gt;WebClient&lt;/code&gt; is auto-configured. To customize the client&amp;rsquo;s handling of network connections, provide a &lt;code&gt;ClientHttpConnector&lt;/code&gt; bean. The following example configures a 60 second connect timeout and adds a &lt;code&gt;ReadTimeoutHandler&lt;/code&gt;:</source>
          <target state="translated">Reactor Netty가 클래스 경로에 있으면 Reactor Netty 기반 &lt;code&gt;WebClient&lt;/code&gt; 가 자동 구성됩니다. 클라이언트의 네트워크 연결 처리를 사용자 정의하려면 &lt;code&gt;ClientHttpConnector&lt;/code&gt; Bean을 제공하십시오 . 다음 예제는 60 초 연결 시간 제한을 구성하고 &lt;code&gt;ReadTimeoutHandler&lt;/code&gt; 를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="cb98d494ebb8bb01c49e4e827d3219e838ad1c48" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;ConnectionFactory&lt;/code&gt; bean is available, the regular JDBC &lt;code&gt;DataSource&lt;/code&gt; auto-configuration backs off. If you want to retain the JDBC &lt;code&gt;DataSource&lt;/code&gt; auto-configuration, and are comfortable with the risk of using the blocking JDBC API in a reactive application, add &lt;code&gt;@Import(DataSourceAutoConfiguration.class)&lt;/code&gt; on a &lt;code&gt;@Configuration&lt;/code&gt; class in your application to re-enable it.</source>
          <target state="translated">때 &lt;code&gt;ConnectionFactory&lt;/code&gt; 에 콩이 가능하며, 일반 JDBC &lt;code&gt;DataSource&lt;/code&gt; 자동 구성이 꺼 백업합니다. JDBC &lt;code&gt;DataSource&lt;/code&gt; 자동 구성 을 유지하고 반응 애플리케이션에서 차단 JDBC API를 사용하는 위험에 익숙 하다면 애플리케이션 의 &lt;code&gt;@Configuration&lt;/code&gt; 클래스에 &lt;code&gt;@Import(DataSourceAutoConfiguration.class)&lt;/code&gt; 를 추가 하여 다시 활성화하십시오. .</target>
        </trans-unit>
        <trans-unit id="69f3ac1bd16a1c2c06e4d7529b8fa9d384dbcccd" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;List&lt;/code&gt; is specified in multiple profiles, the one with the highest priority (and only that one) is used. Consider the following example:</source>
          <target state="translated">&lt;code&gt;List&lt;/code&gt; 이 여러 프로필에 지정 되면 우선 순위가 가장 높은 프로필 (및 해당 프로필 만)이 사용됩니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5b9005d9ac77f6aba678a9c94e57a184f3061e43" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;jndi-name&lt;/code&gt; is set, it takes precedence over all other Session-related settings.</source>
          <target state="translated">때 &lt;code&gt;jndi-name&lt;/code&gt; 설정되어, 다른 모든 세션 관련 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="ec4d23f0792064325151a6612c2bfed0dcc21e53" translate="yes" xml:space="preserve">
          <source>When a JTA environment is detected, Spring&amp;rsquo;s &lt;code&gt;JtaTransactionManager&lt;/code&gt; is used to manage transactions. Auto-configured JMS, DataSource, and JPA beans are upgraded to support XA transactions. You can use standard Spring idioms, such as &lt;code&gt;@Transactional&lt;/code&gt;, to participate in a distributed transaction. If you are within a JTA environment and still want to use local transactions, you can set the &lt;code&gt;spring.jta.enabled&lt;/code&gt; property to &lt;code&gt;false&lt;/code&gt; to disable the JTA auto-configuration.</source>
          <target state="translated">JTA 환경이 감지되면 Spring의 &lt;code&gt;JtaTransactionManager&lt;/code&gt; 를 사용하여 트랜잭션을 관리합니다. 자동 구성된 JMS, DataSource 및 JPA Bean이 업그레이드되어 XA 트랜잭션을 지원합니다. &lt;code&gt;@Transactional&lt;/code&gt; 과 같은 표준 Spring 관용구를 사용 하여 분산 트랜잭션에 참여할 수 있습니다. JTA 환경에 있고 여전히 로컬 트랜잭션을 사용하려는 경우 &lt;code&gt;spring.jta.enabled&lt;/code&gt; 속성을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 JTA 자동 구성을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="656c1b2f3320fa923139cd52fa74c681b01b7233" translate="yes" xml:space="preserve">
          <source>When a Spring Boot application shuts down:</source>
          <target state="translated">Spring Boot 애플리케이션이 종료 될 때 :</target>
        </trans-unit>
        <trans-unit id="f4151bdd995a909369d2797a22a1caf9cbe97f1c" translate="yes" xml:space="preserve">
          <source>When a Spring Boot application starts:</source>
          <target state="translated">Spring Boot 애플리케이션이 시작되면 :</target>
        </trans-unit>
        <trans-unit id="8591308ddf541353363b8793e001146bb2b004b9" translate="yes" xml:space="preserve">
          <source>When a cache library offers both a native implementation and JSR-107 support, Spring Boot prefers the JSR-107 support, so that the same features are available if you switch to a different JSR-107 implementation.</source>
          <target state="translated">캐시 라이브러리가 기본 구현과 JSR-107 지원을 모두 제공하는 경우 Spring Boot는 JSR-107 지원을 선호하므로 다른 JSR-107 구현으로 전환하는 경우 동일한 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa226405d623680cb0bfa35ceb198b67321baacd" translate="yes" xml:space="preserve">
          <source>When a class does not include a &lt;code&gt;package&lt;/code&gt; declaration, it is considered to be in the &amp;ldquo;default package&amp;rdquo;. The use of the &amp;ldquo;default package&amp;rdquo; is generally discouraged and should be avoided. It can cause particular problems for Spring Boot applications that use the &lt;code&gt;@ComponentScan&lt;/code&gt;, &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt;, &lt;code&gt;@EntityScan&lt;/code&gt;, or &lt;code&gt;@SpringBootApplication&lt;/code&gt; annotations, since every class from every jar is read.</source>
          <target state="translated">클래스에 &lt;code&gt;package&lt;/code&gt; 선언이 포함되지 않은 경우 &quot;기본 패키지&quot;에있는 것으로 간주됩니다. &quot;기본 패키지&quot;의 사용은 일반적으로 권장되지 않으며 피해야합니다. 모든 jar의 모든 클래스를 읽으 &lt;code&gt;@EntityScan&lt;/code&gt; &lt;code&gt;@ComponentScan&lt;/code&gt; , &lt;code&gt;@ConfigurationPropertiesScan&lt;/code&gt; , @EntityScan 또는 &lt;code&gt;@SpringBootApplication&lt;/code&gt; 주석 을 사용하는 Spring Boot 애플리케이션에 특정 문제가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="edb4a506ecc15380a2e39a7856f810a63c005bb1" translate="yes" xml:space="preserve">
          <source>When a custom management context path is configured, the &amp;ldquo;discovery page&amp;rdquo; automatically moves from &lt;code&gt;/actuator&lt;/code&gt; to the root of the management context. For example, if the management context path is &lt;code&gt;/management&lt;/code&gt;, then the discovery page is available from &lt;code&gt;/management&lt;/code&gt;. When the management context path is set to &lt;code&gt;/&lt;/code&gt;, the discovery page is disabled to prevent the possibility of a clash with other mappings.</source>
          <target state="translated">사용자 정의 관리 컨텍스트 경로가 구성되면 &quot;검색 페이지&quot;가 &lt;code&gt;/actuator&lt;/code&gt; 에서 관리 컨텍스트의 루트로 자동으로 이동 합니다. 관리 컨텍스트 경로 인 경우 예를 들어, &lt;code&gt;/management&lt;/code&gt; , 다음 검색 페이지에서 사용할 수 있습니다 &lt;code&gt;/management&lt;/code&gt; . 관리 컨텍스트 경로가 &lt;code&gt;/&lt;/code&gt; 로 설정되면 다른 매핑과 충돌 할 가능성을 방지하기 위해 검색 페이지가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="f94f0e713b0836b77ca89b89f676eee04b6ed838" translate="yes" xml:space="preserve">
          <source>When auto-configuring a Reactor Netty or Jetty server, Spring Boot will create specific beans that will provide HTTP resources to the server instance: &lt;code&gt;ReactorResourceFactory&lt;/code&gt; or &lt;code&gt;JettyResourceFactory&lt;/code&gt;.</source>
          <target state="translated">Reactor Netty 또는 Jetty 서버를 자동 구성 할 때 Spring Boot는 서버 인스턴스에 HTTP 리소스를 제공 할 특정 빈을 생성합니다 : &lt;code&gt;ReactorResourceFactory&lt;/code&gt; 또는 &lt;code&gt;JettyResourceFactory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2061a6bf84a5cee4b249d64373f234f77cbbc4a" translate="yes" xml:space="preserve">
          <source>When binding to &lt;code&gt;Map&lt;/code&gt; properties, if the &lt;code&gt;key&lt;/code&gt; contains anything other than lowercase alpha-numeric characters or &lt;code&gt;-&lt;/code&gt;, you need to use the bracket notation so that the original value is preserved. If the key is not surrounded by &lt;code&gt;[]&lt;/code&gt;, any characters that are not alpha-numeric or &lt;code&gt;-&lt;/code&gt; are removed. For example, consider binding the following properties to a &lt;code&gt;Map&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Map&lt;/code&gt; 속성에 바인딩 할 때 &lt;code&gt;key&lt;/code&gt; 에 소문자 영숫자 또는 &lt;code&gt;-&lt;/code&gt; 이외의 문자 가 포함 된 경우 원래 값이 유지되도록 대괄호 표기법을 사용해야합니다. 키가 &lt;code&gt;[]&lt;/code&gt; 로 둘러싸여 있지 않으면 영숫자 또는 &lt;code&gt;-&lt;/code&gt; 가 아닌 모든 문자 가 제거됩니다. 예를 들어 다음 속성을 &lt;code&gt;Map&lt;/code&gt; 에 바인딩하는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="e13a02c40ccf20b569f41c9f8724d89d66fccad1" translate="yes" xml:space="preserve">
          <source>When building a reactive web application, the following stores can be auto-configured:</source>
          <target state="translated">반응 형 웹 애플리케이션을 빌드 할 때 다음 저장소를 자동 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7edcd8884881532d1ff4b819b831bde7b3bc8a" translate="yes" xml:space="preserve">
          <source>When choosing this option, &lt;code&gt;org.springframework:spring-jdbc&lt;/code&gt; is still a required dependency.</source>
          <target state="translated">이 옵션을 선택할 때 &lt;code&gt;org.springframework:spring-jdbc&lt;/code&gt; 는 여전히 필수 종속성입니다.</target>
        </trans-unit>
        <trans-unit id="c080a4b752d08d9d297b7b608488194c8fd8df6d" translate="yes" xml:space="preserve">
          <source>When configured to use a custom port, the management server can also be configured with its own SSL by using the various &lt;code&gt;management.server.ssl.*&lt;/code&gt; properties. For example, doing so lets a management server be available over HTTP while the main application uses HTTPS, as shown in the following property settings:</source>
          <target state="translated">사용자 지정 포트를 사용하도록 구성된 경우 다양한 &lt;code&gt;management.server.ssl.*&lt;/code&gt; 속성 을 사용하여 관리 서버를 자체 SSL로 구성 할 수도 있습니다 . 예를 들어, 이렇게하면 다음 속성 설정에 표시된 것처럼 기본 응용 프로그램이 HTTPS를 사용하는 동안 HTTP를 통해 관리 서버를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a12ebadb197a1deedc48dd617ec32b711a18847" translate="yes" xml:space="preserve">
          <source>When declaring a &lt;code&gt;@Bean&lt;/code&gt; method, provide as much type information as possible in the method&amp;rsquo;s return type. For example, if your bean&amp;rsquo;s concrete class implements an interface the bean method&amp;rsquo;s return type should be the concrete class and not the interface. Providing as much type information as possible in &lt;code&gt;@Bean&lt;/code&gt; methods is particularly important when using bean conditions as their evaluation can only rely upon to type information that&amp;rsquo;s available in the method signature.</source>
          <target state="translated">&lt;code&gt;@Bean&lt;/code&gt; 메소드를 선언 할 때 메소드의 리턴 유형에 가능한 한 많은 유형 정보를 제공하십시오. 예를 들어, 빈의 구체적인 클래스가 인터페이스를 구현하는 경우 빈 메소드의 반환 유형은 인터페이스가 아닌 구체적인 클래스 여야합니다. &lt;code&gt;@Bean&lt;/code&gt; 메소드 에서 가능한 한 많은 유형 정보를 제공하는 것은 Bean 조건을 사용할 때 특히 중요합니다. 평가는 메소드 서명에서 사용할 수있는 유형 정보에만 의존 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c1bbcc1f9da9220b9fa67db8ff9be6dec95fad2f" translate="yes" xml:space="preserve">
          <source>When deployed on platforms, applications can provide information about their availability to the platform using infrastructure such as &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&quot;&gt;Kubernetes Probes&lt;/a&gt;. Spring Boot includes out-of-the box support for the commonly used &amp;ldquo;liveness&amp;rdquo; and &amp;ldquo;readiness&amp;rdquo; availability states. If you are using Spring Boot&amp;rsquo;s &amp;ldquo;actuator&amp;rdquo; support then these states are exposed as health endpoint groups.</source>
          <target state="translated">플랫폼에 배포 할 때 애플리케이션은 &lt;a href=&quot;https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/&quot;&gt;Kubernetes Probes&lt;/a&gt; 와 같은 인프라를 사용하여 플랫폼에 대한 가용성에 대한 정보를 제공 할 수 있습니다 . Spring Boot에는 일반적으로 사용되는 &quot;활성&quot;및 &quot;준비&quot;가용성 상태에 대한 기본 지원이 포함되어 있습니다. Spring Boot의 &quot;액추에이터&quot;지원을 사용하는 경우 이러한 상태는 상태 엔드 포인트 그룹으로 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="dd01b9708db5a2f5be6895819c19a82c5d8714f5" translate="yes" xml:space="preserve">
          <source>When deployed to a servlet container, Spring Boot uses its error page filter to forward a request with an error status to the appropriate error page. This is necessary as the Servlet specification does not provide an API for registering error pages. Depending on the container that you are deploying your war file to and the technologies that your application uses, some additional configuration may be required.</source>
          <target state="translated">서블릿 컨테이너에 배포되면 Spring Boot는 오류 페이지 필터를 사용하여 오류 상태가있는 요청을 적절한 오류 페이지로 전달합니다. 이는 Servlet 사양이 오류 페이지 등록을위한 API를 제공하지 않기 때문에 필요합니다. war 파일을 배포하는 컨테이너와 애플리케이션에서 사용하는 기술에 따라 몇 가지 추가 구성이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4822eb22c6cabdf0212adef4166d5bb80a19298" translate="yes" xml:space="preserve">
          <source>When embedding the broker, you can choose if you want to enable persistence and list the destinations that should be made available. These can be specified as a comma-separated list to create them with the default options, or you can define bean(s) of type &lt;code&gt;org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration&lt;/code&gt; or &lt;code&gt;org.apache.activemq.artemis.jms.server.config.TopicConfiguration&lt;/code&gt;, for advanced queue and topic configurations, respectively.</source>
          <target state="translated">브로커를 포함 할 때 지속성을 활성화하고 사용 가능해야하는 대상을 나열할지 여부를 선택할 수 있습니다. 쉼표로 구분 된 목록으로 지정하여 기본 옵션을 사용하여 생성하거나 &lt;code&gt;org.apache.activemq.artemis.jms.server.config.JMSQueueConfiguration&lt;/code&gt; 또는 &lt;code&gt;org.apache.activemq.artemis.jms.server.config.TopicConfiguration&lt;/code&gt; 유형의 빈을 정의 할 수 있습니다 . artemis.jms.server.config.TopicConfiguration , 각각 고급 대기열 및 주제 구성 용.</target>
        </trans-unit>
        <trans-unit id="ba49f040bbc37906f2970cea4939e6751ae69ccc" translate="yes" xml:space="preserve">
          <source>When executed as root, as is the case when root is being used to start an init.d service, the default executable script runs the application as the user specified in the &lt;code&gt;RUN_AS_USER&lt;/code&gt; environment variable. When the environment variable is not set, the user who owns the jar file is used instead. You should never run a Spring Boot application as &lt;code&gt;root&lt;/code&gt;, so &lt;code&gt;RUN_AS_USER&lt;/code&gt; should never be root and your application&amp;rsquo;s jar file should never be owned by root. Instead, create a specific user to run your application and set the &lt;code&gt;RUN_AS_USER&lt;/code&gt; environment variable or use &lt;code&gt;chown&lt;/code&gt; to make it the owner of the jar file, as shown in the following example:</source>
          <target state="translated">root로 실행하면 root가 init.d 서비스를 시작하는 데 사용되는 경우와 같이 기본 실행 스크립트는 &lt;code&gt;RUN_AS_USER&lt;/code&gt; 환경 변수에 지정된 사용자로 응용 프로그램을 실행합니다 . 환경 변수가 설정되지 않은 경우 jar 파일을 소유 한 사용자가 대신 사용됩니다. 당신은 스프링 부팅 응용 프로그램을 실행해서는 안 &lt;code&gt;root&lt;/code&gt; , 그래서 &lt;code&gt;RUN_AS_USER&lt;/code&gt; 이 루트 않을 것입니다 및 응용 프로그램의 jar 파일이 루트가 소유해서는 안됩니다. 대신 다음 예제와 같이 특정 사용자를 생성하여 애플리케이션을 실행하고 &lt;code&gt;RUN_AS_USER&lt;/code&gt; 환경 변수를 설정 하거나 &lt;code&gt;chown&lt;/code&gt; 을 사용 하여 jar 파일의 소유자로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="1db6534d2f7f3c406621529098d3e6efb0183091" translate="yes" xml:space="preserve">
          <source>When greater than zero, enables retrying of failed sends.</source>
          <target state="translated">0보다 크면 실패한 전송을 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e23446bdce689fc3ca0110fb61c992a6caa4e3b" translate="yes" xml:space="preserve">
          <source>When lists are configured in more than one place, overriding works by replacing the entire list.</source>
          <target state="translated">목록이 둘 이상의 위치에 구성된 경우 재정의는 전체 목록을 대체하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e0c3d5135d714f4d1ed3cf1f532f44f24a7db81c" translate="yes" xml:space="preserve">
          <source>When loading resources dynamically with, for example, a JavaScript module loader, renaming files is not an option. That is why other strategies are also supported and can be combined. A &quot;fixed&quot; strategy adds a static version string in the URL without changing the file name, as shown in the following example:</source>
          <target state="translated">예를 들어 JavaScript 모듈 로더를 사용하여 리소스를 동적으로로드 할 때 파일 이름을 바꾸는 것은 옵션이 아닙니다. 그렇기 때문에 다른 전략도 지원되고 결합 될 수 있습니다. &quot;고정&quot;전략은 다음 예와 같이 파일 이름을 변경하지 않고 URL에 정적 버전 문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2e1d54fd7b3594775e07fd6d15881fe1500d50cd" translate="yes" xml:space="preserve">
          <source>When multiple locations are specified, the later ones can override the values of earlier ones.</source>
          <target state="translated">여러 위치를 지정하면 이후 위치가 이전 위치의 값을 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="331838622353ab9e1cb097584684b93cada12542" translate="yes" xml:space="preserve">
          <source>When non empty, enables transaction support for producer.</source>
          <target state="translated">비어 있지 않으면 생산자에 대한 트랜잭션 지원을 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="3d58543b81705f91a71431d5a583246e37214478" translate="yes" xml:space="preserve">
          <source>When only basic SQL scripts are used, Spring Boot automatically creates the schema of an embedded &lt;code&gt;DataSource&lt;/code&gt;. This behavior can be customized by using the &lt;code&gt;spring.datasource.initialization-mode&lt;/code&gt; property. For instance, if you want to always initialize the &lt;code&gt;DataSource&lt;/code&gt; regardless of its type:</source>
          <target state="translated">기본 SQL 스크립트 만 사용하는 경우 Spring Boot는 내장 된 &lt;code&gt;DataSource&lt;/code&gt; 의 스키마를 자동으로 생성합니다 . 이 동작은 &lt;code&gt;spring.datasource.initialization-mode&lt;/code&gt; 속성 을 사용하여 사용자 정의 할 수 있습니다 . 예를 들어, 유형에 관계없이 항상 &lt;code&gt;DataSource&lt;/code&gt; 를 초기화하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="c4f051365abb15e406ec92c585a98efdf8a0025e" translate="yes" xml:space="preserve">
          <source>When placed on a &lt;code&gt;@Bean&lt;/code&gt; method, the target type defaults to the return type of the method, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;@Bean&lt;/code&gt; 메소드 에 배치 될 때 대상 유형은 다음 예제와 같이 메소드의 리턴 유형으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cd37626130103f29ce87938e913162e6fd9db2a8" translate="yes" xml:space="preserve">
          <source>When possible, we recommend that you use the &lt;code&gt;-spring&lt;/code&gt; variants for your logging configuration (for example, &lt;code&gt;logback-spring.xml&lt;/code&gt; rather than &lt;code&gt;logback.xml&lt;/code&gt;). If you use standard configuration locations, Spring cannot completely control log initialization.</source>
          <target state="translated">가능하면 로깅 구성에 &lt;code&gt;-spring&lt;/code&gt; 변형을 사용하는 것이 좋습니다 (예 : &lt;code&gt;logback.xml&lt;/code&gt; 대신 &lt;code&gt;logback-spring.xml&lt;/code&gt; ). 표준 구성 위치를 사용하는 경우 Spring은 로그 초기화를 완전히 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b470327a567627d21241e80c3e781cbc0640dcda" translate="yes" xml:space="preserve">
          <source>When repackaging an archive, you can include references to dependency files by using the &lt;code&gt;org.springframework.boot.loader.tools.Libraries&lt;/code&gt; interface. We do not provide any concrete implementations of &lt;code&gt;Libraries&lt;/code&gt; here as they are usually build-system-specific.</source>
          <target state="translated">아카이브를 다시 패키징 할 때 &lt;code&gt;org.springframework.boot.loader.tools.Libraries&lt;/code&gt; 인터페이스 를 사용하여 종속성 파일에 대한 참조를 포함 할 수 있습니다 . 일반적으로 빌드 시스템에 따라 다르기 때문에 여기서는 &lt;code&gt;Libraries&lt;/code&gt; 구체적인 구현을 제공하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b990c6a436ce82d5e0da52dd9ffe7905629c8a01" translate="yes" xml:space="preserve">
          <source>When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support.</source>
          <target state="translated">임베디드 서블릿 컨테이너를 사용하고 실행 가능한 아카이브로 패키징 된 Spring Boot 애플리케이션을 실행할 때 JSP 지원에 몇 가지 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="166a4c20b9d1f115dc51da3f36cf7358fb8f0ffd" translate="yes" xml:space="preserve">
          <source>When running applications on a cloud platform (such as Kubernetes) you often need to read config values that the platform supplies. It&amp;rsquo;s not uncommon to use environment variables for such purposes, but this can have drawbacks, especially if the value is supposed to be kept secret.</source>
          <target state="translated">클라우드 플랫폼 (예 : Kubernetes)에서 애플리케이션을 실행할 때 종종 플랫폼이 제공하는 구성 값을 읽어야합니다. 이러한 목적으로 환경 변수를 사용하는 것은 드문 일이 아니지만, 특히 값을 비밀로 유지해야하는 경우 단점이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b590e204406a763c9432c6af0dfc8bc3f4c4834d" translate="yes" xml:space="preserve">
          <source>When running tests, it is sometimes necessary to mock certain components within your application context. For example, you may have a facade over some remote service that is unavailable during development. Mocking can also be useful when you want to simulate failures that might be hard to trigger in a real environment.</source>
          <target state="translated">테스트를 실행할 때 애플리케이션 컨텍스트 내에서 특정 구성 요소를 모의해야하는 경우가 있습니다. 예를 들어 개발 중에 사용할 수없는 일부 원격 서비스에 대한 파사드가있을 수 있습니다. 모킹은 실제 환경에서 트리거하기 어려울 수있는 실패를 시뮬레이션하려는 경우에도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb719ac0bb17afc286e305575bc5ac750065ffe" translate="yes" xml:space="preserve">
          <source>When setting &lt;code&gt;JAVA_OPTS&lt;/code&gt; on Microsoft Windows, make sure to quote the entire instruction, such as &lt;code&gt;set &quot;JAVA_OPTS=-Xms256m -Xmx2048m&quot;&lt;/code&gt;. Doing so ensures the values are properly passed to the process.</source>
          <target state="translated">Microsoft Windows에서 &lt;code&gt;JAVA_OPTS&lt;/code&gt; 를 설정할 때는 &lt;code&gt;set &quot;JAVA_OPTS=-Xms256m -Xmx2048m&quot;&lt;/code&gt; 과 같이 전체 지침을 인용해야합니다 . 이렇게하면 값이 프로세스에 제대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b37eb2139a8063c7aa8bca8bdbfb110e79a0e90f" translate="yes" xml:space="preserve">
          <source>When specified as environment variables or manifest entries, the following names should be used:</source>
          <target state="translated">환경 변수 또는 매니페스트 항목으로 지정되는 경우 다음 이름을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1119cb2661ebaa0bfc4fba1cbe34637ce316656" translate="yes" xml:space="preserve">
          <source>When specifying addresses that way, the &lt;code&gt;host&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; properties are ignored. If the address uses the &lt;code&gt;amqps&lt;/code&gt; protocol, SSL support is enabled automatically.</source>
          <target state="translated">이러한 방식으로 주소를 지정하면 &lt;code&gt;host&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 속성이 무시됩니다. 주소가 &lt;code&gt;amqps&lt;/code&gt; 프로토콜을 사용하는 경우 SSL 지원이 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b0bb2a229600b4b9ec90dd3d8e5269b3018911da" translate="yes" xml:space="preserve">
          <source>When switching to a different HTTP server, you need to swap the default dependencies for those that you need instead. To help with this process, Spring Boot provides a separate starter for each of the supported HTTP servers.</source>
          <target state="translated">다른 HTTP 서버로 전환 할 때 대신 필요한 기본 종속성을 교체해야합니다. 이 프로세스를 돕기 위해 Spring Boot는 지원되는 각 HTTP 서버에 대해 별도의 스타터를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b5eef20c4113105a91f44348601544f5027b6fd6" translate="yes" xml:space="preserve">
          <source>When testing Spring Boot applications, this is often not required. Spring Boot&amp;rsquo;s &lt;code&gt;@*Test&lt;/code&gt; annotations search for your primary configuration automatically whenever you do not explicitly define one.</source>
          <target state="translated">Spring Boot 애플리케이션을 테스트 할 때 이것은 종종 필요하지 않습니다. Spring Boot의 &lt;code&gt;@*Test&lt;/code&gt; 주석은 명시 적으로 정의하지 않을 때마다 자동으로 기본 구성을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="fb802321c2c3b801f3d52aeb74ea76101052d8b8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;@ConfigurationProperties&lt;/code&gt; bean is registered using configuration property scanning or via &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;, the bean has a conventional name: &lt;code&gt;&amp;lt;prefix&amp;gt;-&amp;lt;fqn&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; is the environment key prefix specified in the &lt;code&gt;@ConfigurationProperties&lt;/code&gt; annotation and &lt;code&gt;&amp;lt;fqn&amp;gt;&lt;/code&gt; is the fully qualified name of the bean. If the annotation does not provide any prefix, only the fully qualified name of the bean is used.</source>
          <target state="translated">&lt;code&gt;@ConfigurationProperties&lt;/code&gt; Bean이 구성 특성 스캐닝을 사용하거나 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 를 통해 등록 될 때 Bean은 일반 이름 : &lt;code&gt;&amp;lt;prefix&amp;gt;-&amp;lt;fqn&amp;gt;&lt;/code&gt; 을 갖습니다 . 여기서 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 는 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 주석 및 &lt;code&gt;&amp;lt;fqn&amp;gt;&lt;/code&gt; 에 지정된 환경 키 접 두부입니다. Bean의 완전한 이름입니다. 어노테이션이 접 두부를 제공하지 않는 경우 Bean의 완전한 이름 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d45608ecb938301e7bb2c640c9f09a4413980f8" translate="yes" xml:space="preserve">
          <source>When the Apache Kafka infrastructure is present, any bean can be annotated with &lt;code&gt;@KafkaListener&lt;/code&gt; to create a listener endpoint. If no &lt;code&gt;KafkaListenerContainerFactory&lt;/code&gt; has been defined, a default one is automatically configured with keys defined in &lt;code&gt;spring.kafka.listener.*&lt;/code&gt;.</source>
          <target state="translated">Apache Kafka 인프라가있는 경우 모든 Bean에 &lt;code&gt;@KafkaListener&lt;/code&gt; 주석을 추가 하여 수신기 끝점을 만들 수 있습니다 . &lt;code&gt;KafkaListenerContainerFactory&lt;/code&gt; 가 정의 되지 않은 경우 기본값은 &lt;code&gt;spring.kafka.listener.*&lt;/code&gt; 에 정의 된 키로 자동 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc337ad6a29a601497eac4f84b56224913dda123" translate="yes" xml:space="preserve">
          <source>When the JDBC store is used, the schema can be initialized on startup, as shown in the following example:</source>
          <target state="translated">JDBC 저장소를 사용하는 경우 다음 예와 같이 시작시 스키마를 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19eb27a8c635967fb916ec78517df63ceee60db5" translate="yes" xml:space="preserve">
          <source>When the JMS infrastructure is present, any bean can be annotated with &lt;code&gt;@JmsListener&lt;/code&gt; to create a listener endpoint. If no &lt;code&gt;JmsListenerContainerFactory&lt;/code&gt; has been defined, a default one is configured automatically. If a &lt;code&gt;DestinationResolver&lt;/code&gt; or a &lt;code&gt;MessageConverter&lt;/code&gt; beans is defined, it is associated automatically to the default factory.</source>
          <target state="translated">JMS 인프라가있는 경우 모든 Bean에 &lt;code&gt;@JmsListener&lt;/code&gt; 로 주석을 달아 리스너 엔드 포인트를 생성 할 수 있습니다 . &lt;code&gt;JmsListenerContainerFactory&lt;/code&gt; 가 정의 되지 않은 경우 기본값이 자동으로 구성됩니다. 경우 &lt;code&gt;DestinationResolver&lt;/code&gt; 또는 &lt;code&gt;MessageConverter&lt;/code&gt; 콩이 정의, 그것은 기본 공장에 자동으로 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="50f0bbd6afa93b71b892f56503a3b1f11a886642" translate="yes" xml:space="preserve">
          <source>When the Prometheus Pushgateway dependency is present on the classpath and the &lt;code&gt;management.metrics.export.prometheus.pushgateway.enabled&lt;/code&gt; property is set to &lt;code&gt;true&lt;/code&gt;, a &lt;code&gt;PrometheusPushGatewayManager&lt;/code&gt; bean is auto-configured. This manages the pushing of metrics to a Prometheus Pushgateway.</source>
          <target state="translated">Prometheus Pushgateway 종속성이 클래스 경로에 있고 &lt;code&gt;management.metrics.export.prometheus.pushgateway.enabled&lt;/code&gt; 특성이 &lt;code&gt;true&lt;/code&gt; 로 설정 되면 &lt;code&gt;PrometheusPushGatewayManager&lt;/code&gt; Bean이 자동 구성됩니다. Prometheus Pushgateway에 대한 메트릭 푸시를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="9c67f5a9f6c46e8f5d733622c958dc20ca6479bd" translate="yes" xml:space="preserve">
          <source>When the Rabbit infrastructure is present, any bean can be annotated with &lt;code&gt;@RabbitListener&lt;/code&gt; to create a listener endpoint. If no &lt;code&gt;RabbitListenerContainerFactory&lt;/code&gt; has been defined, a default &lt;code&gt;SimpleRabbitListenerContainerFactory&lt;/code&gt; is automatically configured and you can switch to a direct container using the &lt;code&gt;spring.rabbitmq.listener.type&lt;/code&gt; property. If a &lt;code&gt;MessageConverter&lt;/code&gt; or a &lt;code&gt;MessageRecoverer&lt;/code&gt; bean is defined, it is automatically associated with the default factory.</source>
          <target state="translated">Rabbit 인프라가 있으면 모든 Bean에 &lt;code&gt;@RabbitListener&lt;/code&gt; 로 주석을 달아 수신기 끝점을 만들 수 있습니다 . &lt;code&gt;RabbitListenerContainerFactory&lt;/code&gt; 가 정의 되지 않은 경우 기본 &lt;code&gt;SimpleRabbitListenerContainerFactory&lt;/code&gt; 가 자동으로 구성되며 &lt;code&gt;spring.rabbitmq.listener.type&lt;/code&gt; 속성을 사용하여 직접 컨테이너로 전환 할 수 있습니다 . 경우 &lt;code&gt;MessageConverter&lt;/code&gt; 또는 &lt;code&gt;MessageRecoverer&lt;/code&gt; 의 콩이 정의, 자동으로 기본 공장과 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f03cc4078594ab7cabdffb18d8434529ac5b31" translate="yes" xml:space="preserve">
          <source>When the debug mode is enabled, a selection of core loggers (embedded container, Hibernate, and Spring Boot) are configured to output more information. Enabling the debug mode does &lt;em&gt;not&lt;/em&gt; configure your application to log all messages with &lt;code&gt;DEBUG&lt;/code&gt; level.</source>
          <target state="translated">디버그 모드가 활성화되면 코어 로거 (임베디드 컨테이너, Hibernate 및 Spring Boot)가 더 많은 정보를 출력하도록 구성됩니다. 디버그 모드를 활성화해도 &lt;code&gt;DEBUG&lt;/code&gt; 수준으로 모든 메시지를 기록하도록 애플리케이션이 구성 되지는 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ca0dfb6bb618abdaebb38370f1bdb84604a0e1a1" translate="yes" xml:space="preserve">
          <source>When to include &quot;errors&quot; attribute.</source>
          <target state="translated">&quot;오류&quot;속성을 포함해야하는 경우.</target>
        </trans-unit>
        <trans-unit id="089db356b67247a8b9d267b74f62658376b1b234" translate="yes" xml:space="preserve">
          <source>When to include &quot;message&quot; attribute.</source>
          <target state="translated">&quot;메시지&quot;속성을 포함하는 경우.</target>
        </trans-unit>
        <trans-unit id="12fa1f6a9a949ab72b648d1f433e5bfb0d934aa6" translate="yes" xml:space="preserve">
          <source>When to include the &quot;trace&quot; attribute.</source>
          <target state="translated">&quot;trace&quot;속성을 포함해야하는 경우.</target>
        </trans-unit>
        <trans-unit id="36bd6fda6ae35beb820543b7ca538bdc1b1afd26" translate="yes" xml:space="preserve">
          <source>When to show components. If not specified the 'show-details' setting will be used.</source>
          <target state="translated">구성 요소를 표시 할시기. 지정하지 않으면 'show-details'설정이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="59d9b30437777f82b1cf10181f4f4bf633707094" translate="yes" xml:space="preserve">
          <source>When to show full health details.</source>
          <target state="translated">전체 건강 정보를 표시해야하는 경우.</target>
        </trans-unit>
        <trans-unit id="71111bf129c83fcb8da16a05eccd593621c5d652" translate="yes" xml:space="preserve">
          <source>When upgrading to a new feature release, some properties may have been renamed or removed. Spring Boot provides a way to analyze your application&amp;rsquo;s environment and print diagnostics at startup, but also temporarily migrate properties at runtime for you. To enable that feature, add the following dependency to your project:</source>
          <target state="translated">새 기능 릴리스로 업그레이드 할 때 일부 속성의 이름이 바뀌거나 제거되었을 수 있습니다. Spring Boot는 애플리케이션의 환경을 분석하고 시작시 진단을 인쇄하는 방법을 제공하지만 런타임에 속성을 임시로 마이그레이션 할 수도 있습니다. 해당 기능을 사용하려면 프로젝트에 다음 종속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8a54d3429f1b14f3d91403df32d0d92ed2a9d010" translate="yes" xml:space="preserve">
          <source>When using JTA, the primary JMS &lt;code&gt;ConnectionFactory&lt;/code&gt; bean is XA-aware and participates in distributed transactions. In some situations, you might want to process certain JMS messages by using a non-XA &lt;code&gt;ConnectionFactory&lt;/code&gt;. For example, your JMS processing logic might take longer than the XA timeout.</source>
          <target state="translated">JTA를 사용할 때 기본 JMS &lt;code&gt;ConnectionFactory&lt;/code&gt; Bean은 XA를 인식하고 분산 트랜잭션에 참여합니다. 일부 상황에서는 비 XA &lt;code&gt;ConnectionFactory&lt;/code&gt; 를 사용하여 특정 JMS 메시지를 처리 ​​할 수 ​​있습니다 . 예를 들어 JMS 처리 로직은 XA 제한 시간보다 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19116fab9e23619e53bf52cf57b7e0474061a1aa" translate="yes" xml:space="preserve">
          <source>When using an embedded container, automatic registration of classes annotated with &lt;code&gt;@WebServlet&lt;/code&gt;, &lt;code&gt;@WebFilter&lt;/code&gt;, and &lt;code&gt;@WebListener&lt;/code&gt; can be enabled by using &lt;code&gt;@ServletComponentScan&lt;/code&gt;.</source>
          <target state="translated">내장 된 용기를 사용하는 경우, 주석 클래스 자동 등록 &lt;code&gt;@WebServlet&lt;/code&gt; , &lt;code&gt;@WebFilter&lt;/code&gt; 및 &lt;code&gt;@WebListener&lt;/code&gt; 를 사용하여 활성화 될 수 &lt;code&gt;@ServletComponentScan&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="900f576f8e37166d808ecf179cd5786c826b10ac" translate="yes" xml:space="preserve">
          <source>When using an embedded servlet container, you can register servlets, filters, and all the listeners (such as &lt;code&gt;HttpSessionListener&lt;/code&gt;) from the Servlet spec, either by using Spring beans or by scanning for Servlet components.</source>
          <target state="translated">임베디드 서블릿 컨테이너 를 사용할 때 Spring Bean을 사용하거나 Servlet 컴포넌트를 스캔하여 서블릿 스펙에서 서블릿, 필터 및 모든 리스너 (예 : &lt;code&gt;HttpSessionListener&lt;/code&gt; )를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7daeb47e9dc9a3d23ad9b1cc067030e3c53202fe" translate="yes" xml:space="preserve">
          <source>When you add the &lt;code&gt;org.liquibase:liquibase-core&lt;/code&gt; to your classpath, database migrations run by default for both during application startup and before your tests run. This behavior can be customized by using the &lt;code&gt;spring.liquibase.enabled&lt;/code&gt; property, setting different values in the &lt;code&gt;main&lt;/code&gt; and &lt;code&gt;test&lt;/code&gt; configurations. It is not possible to use two different ways to initialize the database (e.g. Liquibase for application startup, JPA for test runs).</source>
          <target state="translated">&lt;code&gt;org.liquibase:liquibase-core&lt;/code&gt; 를 클래스 경로에 추가하면 데이터베이스 마이그레이션이 기본적으로 애플리케이션 시작 중과 테스트 실행 전에 모두 실행됩니다. 이 동작은 &lt;code&gt;spring.liquibase.enabled&lt;/code&gt; 속성 을 사용 하고 &lt;code&gt;main&lt;/code&gt; 및 &lt;code&gt;test&lt;/code&gt; 구성 에서 다른 값을 설정 하여 사용자 정의 할 수 있습니다 . 데이터베이스를 초기화하는 데 두 가지 다른 방법을 사용할 수 없습니다 (예 : 애플리케이션 시작을위한 Liquibase, 테스트 실행을위한 JPA).</target>
        </trans-unit>
        <trans-unit id="a913f0628f28cbf7a28411a03b72ecd6451603cc" translate="yes" xml:space="preserve">
          <source>When you are ready to push your Spring Boot application to production, we have &lt;a href=&quot;production-ready-features#production-ready&quot;&gt;some tricks&lt;/a&gt; that you might like:</source>
          <target state="translated">Spring Boot 애플리케이션을 프로덕션으로 푸시 할 준비 가 되었으면 다음과 같은 &lt;a href=&quot;production-ready-features#production-ready&quot;&gt;몇 가지 트릭&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5a303269af1a44ddd3382f0f358404f53d5dbb" translate="yes" xml:space="preserve">
          <source>When you are using &lt;code&gt;@SpyBean&lt;/code&gt; to spy on a bean that is proxied by Spring, you may need to remove Spring&amp;rsquo;s proxy in some situations, for example when setting expectations using &lt;code&gt;given&lt;/code&gt; or &lt;code&gt;when&lt;/code&gt;. Use &lt;code&gt;AopTestUtils.getTargetObject(yourProxiedSpy)&lt;/code&gt; to do so.</source>
          <target state="translated">&lt;code&gt;@SpyBean&lt;/code&gt; 을 사용하여 Spring에 의해 프록시 된 Bean을 감시 할 때, 예를 들어 &lt;code&gt;given&lt;/code&gt; 또는 &lt;code&gt;when&lt;/code&gt; 을 사용하여 기대치를 설정할 때와 같은 상황에서 Spring의 프록시를 제거해야 할 수 있습니다 . 그렇게 하려면 &lt;code&gt;AopTestUtils.getTargetObject(yourProxiedSpy)&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9904fce62f17ed55adaf9448ff99a1ca2daa647f" translate="yes" xml:space="preserve">
          <source>When you create a bean for &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; yourself, any customization that was applied during the creation of the auto-configured &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; is lost. For example, in case of Hibernate, any properties under the &lt;code&gt;spring.jpa.hibernate&lt;/code&gt; prefix will not be automatically applied to your &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt;. If you were relying on these properties for configuring things like the naming strategy or the DDL mode, you will need to explicitly configure that when creating the &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; bean. On the other hand, properties that get applied to the auto-configured &lt;code&gt;EntityManagerFactoryBuilder&lt;/code&gt;, which are specified via &lt;code&gt;spring.jpa.properties&lt;/code&gt;, will automatically be applied, provided you use the auto-configured &lt;code&gt;EntityManagerFactoryBuilder&lt;/code&gt; to build the &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; bean.</source>
          <target state="translated">&lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; 에 대한 Bean을 직접 작성하면 자동 구성된 &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; 작성 중에 적용된 모든 사용자 정의 가 손실됩니다. 예를 들어, Hibernate의 경우 &lt;code&gt;spring.jpa.hibernate&lt;/code&gt; 접두어 아래의 속성은 &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; 에 자동으로 적용되지 않습니다 . 이름 지정 전략 또는 DDL 모드와 같은 사항을 구성하기 위해 이러한 속성에 의존하는 경우 &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; 빈을 만들 때 명시 적으로 구성해야합니다 . 반면에 자동 구성된 &lt;code&gt;EntityManagerFactoryBuilder&lt;/code&gt; 에 적용되는 속성은자동 구성된 &lt;code&gt;EntityManagerFactoryBuilder&lt;/code&gt; 를 사용하여 &lt;code&gt;LocalContainerEntityManagerFactoryBean&lt;/code&gt; 빈 을 빌드하는 경우 &lt;code&gt;spring.jpa.properties&lt;/code&gt; 를 통해 지정된 이 자동으로 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a310c4918f8f24a0f03c3a7ca0044b8ea26afaa" translate="yes" xml:space="preserve">
          <source>When you create a jar containing the layers index file, the &lt;code&gt;spring-boot-jarmode-layertools&lt;/code&gt; jar will be added as a dependency to your jar. With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers.</source>
          <target state="translated">레이어 인덱스 파일을 포함하는 jar를 만들 때 &lt;code&gt;spring-boot-jarmode-layertools&lt;/code&gt; jar가 jar에 대한 종속성으로 추가됩니다. 클래스 경로에서이 jar를 사용하면 부트 스트랩 코드가 애플리케이션과 완전히 다른 것을 실행할 수있는 특수 모드 (예 : 계층을 추출하는 항목)에서 애플리케이션을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63d5f7a87c08e923d9dbc15d922649b15e262f39" translate="yes" xml:space="preserve">
          <source>When you deploy your application to a servlet container or application server, logging performed via the Java Util Logging API is not routed into your application&amp;rsquo;s logs. This prevents logging performed by the container or other applications that have been deployed to it from appearing in your application&amp;rsquo;s logs.</source>
          <target state="translated">애플리케이션을 서블릿 컨테이너 또는 애플리케이션 서버에 배포 할 때 Java Util Logging API를 통해 수행 된 로깅은 애플리케이션의 로그로 라우팅되지 않습니다. 이렇게하면 컨테이너 또는 컨테이너에 배포 된 다른 애플리케이션에서 수행 한 로깅이 애플리케이션의 로그에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="364a5e3077b269c5b6ae240575bf0ac6c68ec850" translate="yes" xml:space="preserve">
          <source>When you specify multiple BOMs, they are applied in the order in which you declare them, as shown in the following example:</source>
          <target state="translated">여러 BOM을 지정하면 다음 예와 같이 선언 한 순서대로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cfab9547053717472b3eacec6f45f74457c0e41" translate="yes" xml:space="preserve">
          <source>When you use one of these templating engines with the default configuration, your templates are picked up automatically from &lt;code&gt;src/main/resources/templates&lt;/code&gt;.</source>
          <target state="translated">기본 구성으로 이러한 템플릿 엔진 중 하나를 사용하면 템플릿이 &lt;code&gt;src/main/resources/templates&lt;/code&gt; 에서 자동으로 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="ae32379b95092c4f270d708905d78eb98d5ea93f" translate="yes" xml:space="preserve">
          <source>When your application starts, any &lt;code&gt;spring.application.json&lt;/code&gt; or &lt;code&gt;SPRING_APPLICATION_JSON&lt;/code&gt; properties will be parsed and added to the &lt;code&gt;Environment&lt;/code&gt;.</source>
          <target state="translated">애플리케이션이 시작되면 &lt;code&gt;spring.application.json&lt;/code&gt; 또는 &lt;code&gt;SPRING_APPLICATION_JSON&lt;/code&gt; 속성이 구문 분석되어 &lt;code&gt;Environment&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="33a70ecc8f90e7e761cfdafe3f49bc7ecfe977fd" translate="yes" xml:space="preserve">
          <source>When your application starts, you should see something similar to the following output:</source>
          <target state="translated">애플리케이션이 시작되면 다음 출력과 유사한 내용이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="93b298df3ace7e05ab941cea019861266a3a05fb" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;NAME&lt;/code&gt; is the name of an ANSI escape code. See &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java&quot;&gt;&lt;code&gt;AnsiPropertySource&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">여기서 &lt;code&gt;NAME&lt;/code&gt; 은 ANSI 이스케이프 코드의 이름입니다. 자세한 내용은 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/tree/v2.4.0/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/ansi/AnsiPropertySource.java&quot;&gt; &lt;code&gt;AnsiPropertySource&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57ceac3ec9fbb20010ded8b30904cf5382f849b2" translate="yes" xml:space="preserve">
          <source>Where the order of the filters is important they can implement &lt;code&gt;Ordered&lt;/code&gt; or be annotated with &lt;code&gt;@Order&lt;/code&gt;. Spring Boot auto-configuration may configure web filters for you. When it does so, the orders shown in the following table will be used:</source>
          <target state="translated">필터의 순서가 중요한 경우 &lt;code&gt;Ordered&lt;/code&gt; 를 구현 하거나 &lt;code&gt;@Order&lt;/code&gt; 주석을 달 수 있습니다 . Spring Boot 자동 구성은 웹 필터를 구성 할 수 있습니다. 이렇게하면 다음 표에 표시된 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa6d742809c9bfcd1d00de178ce54ca82f80578b" translate="yes" xml:space="preserve">
          <source>Whether Connection.isValid() is called when acquiring a connection from the pool.</source>
          <target state="translated">풀에서 연결을 획득 할 때 Connection.isValid ()가 호출되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1b826309b9ef25d233e546e12af04b76a35bd2f5" translate="yes" xml:space="preserve">
          <source>Whether Flyway should attempt to create the schemas specified in the schemas property.</source>
          <target state="translated">Flyway가 schemas 속성에 지정된 스키마 생성을 시도해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="12c45fd1c8a882527bb995ac06da6acc3c67d03a" translate="yes" xml:space="preserve">
          <source>Whether Flyway should output a table with the results of queries when executing migrations. Requires Flyway Teams.</source>
          <target state="translated">마이그레이션을 실행할 때 Flyway가 쿼리 결과와 함께 테이블을 출력해야하는지 여부입니다. Flyway 팀이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3fa6de3d1903057d2b140eff62c96c95734d596e" translate="yes" xml:space="preserve">
          <source>Whether Flyway should skip executing the contents of the migrations and only update the schema history table. Requires Flyway teams.</source>
          <target state="translated">Flyway가 마이그레이션 내용 실행을 건너 뛰고 스키마 기록 테이블 만 업데이트해야하는지 여부입니다. Flyway 팀이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef3e6402a11dc007afe4ffd9d2ada7e4e52c37c3" translate="yes" xml:space="preserve">
          <source>Whether Graphite tags should be used, as opposed to a hierarchical naming convention. Enabled by default unless &quot;tagsAsPrefix&quot; is set.</source>
          <target state="translated">계층 적 명명 규칙과 달리 Graphite 태그를 사용해야하는지 여부입니다. &quot;tagsAsPrefix&quot;가 설정되어 있지 않으면 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e36841af1969cb1a064c5001bc957096e559f503" translate="yes" xml:space="preserve">
          <source>Whether HTTP 1.1 and later location headers generated by a call to sendRedirect will use relative or absolute redirects.</source>
          <target state="translated">sendRedirect 호출로 생성 된 HTTP 1.1 이상 위치 헤더가 상대 또는 절대 리디렉션을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="859cfdf85fd8f89b412b7bf9cf53126bab2e2d8e" translate="yes" xml:space="preserve">
          <source>Whether HttpServletRequest attributes are allowed to override (hide) controller generated model attributes of the same name.</source>
          <target state="translated">HttpServletRequest 속성이 동일한 이름의 컨트롤러 생성 모델 속성을 대체 (숨기기) 할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="28169259a5a2b63e0810b8d0e9bef42f1f39595c" translate="yes" xml:space="preserve">
          <source>Whether HttpSession attributes are allowed to override (hide) controller generated model attributes of the same name.</source>
          <target state="translated">HttpSession 속성이 동일한 이름의 컨트롤러 생성 모델 속성을 대체 (숨기기) 할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="17f9b1009a2d4f6e069d81b2fea9b1d02a41b5e2" translate="yes" xml:space="preserve">
          <source>Whether NameNotFoundException should be ignored in searches via the LdapTemplate.</source>
          <target state="translated">LdapTemplate을 통한 검색에서 NameNotFoundException을 무시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="864818a8a0340d9fdbc9d8905edbcf6cfff78cb1" translate="yes" xml:space="preserve">
          <source>Whether PartialResultException should be ignored in searches via the LdapTemplate.</source>
          <target state="translated">LdapTemplate을 통한 검색에서 PartialResultException을 무시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0038aa42ce1f4d6c101ce95268bd6a5d3d213fe6" translate="yes" xml:space="preserve">
          <source>Whether SizeLimitExceededException should be ignored in searches via the LdapTemplate.</source>
          <target state="translated">LdapTemplate을 통한 검색에서 SizeLimitExceededException을 무시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0f456753dae11617bb6c57b3b3effb6665cb895c" translate="yes" xml:space="preserve">
          <source>Whether TMJOIN should be used when starting XAResources.</source>
          <target state="translated">XAResources를 시작할 때 TMJOIN을 사용해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2928df4f05237009ef4d6afaa6faf5849b01f95b" translate="yes" xml:space="preserve">
          <source>Whether Thymeleaf should start writing partial output as soon as possible or buffer until template processing is finished.</source>
          <target state="translated">Thymeleaf가 가능한 한 빨리 부분 출력 쓰기를 시작해야하는지 또는 템플릿 처리가 완료 될 때까지 버퍼링해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="a10da187489d6299a565af010b378ee28ee5b9ea" translate="yes" xml:space="preserve">
          <source>Whether Tomcat's MBean Registry should be enabled.</source>
          <target state="translated">Tomcat의 MBean 레지스트리를 활성화해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="28fcbfb14301b7616d9921e9146e3530fe701570" translate="yes" xml:space="preserve">
          <source>Whether a &quot;NoHandlerFoundException&quot; should be thrown if no Handler was found to process a request.</source>
          <target state="translated">요청을 처리 할 핸들러가 발견되지 않은 경우 &quot;NoHandlerFoundException&quot;이 발생해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="83b569885364fb8099fe537566fc9fdf427c210f" translate="yes" xml:space="preserve">
          <source>Whether a JmsPoolConnectionFactory should be created, instead of a regular ConnectionFactory.</source>
          <target state="translated">일반 ConnectionFactory 대신 JmsPoolConnectionFactory를 작성해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="864f2b799af68302b2016e62e2d16397cd44ad3a" translate="yes" xml:space="preserve">
          <source>Whether a VM shutdown should trigger forced shutdown of the transaction core.</source>
          <target state="translated">VM 종료가 트랜잭션 코어의 강제 종료를 트리거해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c8b4085de4fdd22ac426c6ba4827b0bbc6b91a1d" translate="yes" xml:space="preserve">
          <source>Whether a request parameter (&quot;format&quot; by default) should be used to determine the requested media type.</source>
          <target state="translated">요청 매개 변수 (기본적으로 &quot;형식&quot;)를 사용하여 요청 된 미디어 유형을 결정해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b45e06e23290d6c07d0c7b181f904cfbaf379a59" translate="yes" xml:space="preserve">
          <source>Whether adaptive topology refreshing using all available refresh triggers should be used.</source>
          <target state="translated">사용 가능한 모든 새로 고침 트리거를 사용하는 적응 형 토폴로지 새로 고침을 사용해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b091d9801755223cc178c054e3a03ee7f4f42d4a" translate="yes" xml:space="preserve">
          <source>Whether all HttpSession attributes should be added to the model prior to merging with the template.</source>
          <target state="translated">템플릿과 병합하기 전에 모든 HttpSession 속성을 모델에 추가해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8fa15179194996d06e1146833ada28296a3685ef" translate="yes" xml:space="preserve">
          <source>Whether all request attributes should be added to the model prior to merging with the template.</source>
          <target state="translated">템플릿과 병합하기 전에 모든 요청 속성을 모델에 추가해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="65facdb06081cee13236133d2066e9880d387cd6" translate="yes" xml:space="preserve">
          <source>Whether application/hal+json responses should be sent to requests that accept application/json.</source>
          <target state="translated">application / json을 수락하는 요청에 application / hal + json 응답을 보내야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b043deaafbbe8bc7f4edb52961cba9a95414719f" translate="yes" xml:space="preserve">
          <source>Whether auto-configured MeterRegistry implementations should be bound to the global static registry on Metrics. For testing, set this to 'false' to maximize test independence.</source>
          <target state="translated">자동 구성된 MeterRegistry 구현이 메트릭의 전역 정적 레지스트리에 바인딩되어야하는지 여부입니다. 테스트의 경우이를 'false'로 설정하여 테스트 독립성을 최대화하십시오.</target>
        </trans-unit>
        <trans-unit id="3fa3ed77ffc8dea03f49a153dc1aa569ef258a35" translate="yes" xml:space="preserve">
          <source>Whether bean definition overriding, by registering a definition with the same name as an existing definition, is allowed.</source>
          <target state="translated">기존 정의와 동일한 이름으로 정의를 등록하여 Bean 정의 대체가 허용되는지 여부.</target>
        </trans-unit>
        <trans-unit id="eea764bab35f37b82a9b736b929a7a7b556333f7" translate="yes" xml:space="preserve">
          <source>Whether configured jobs should overwrite existing job definitions.</source>
          <target state="translated">구성된 작업이 기존 작업 정의를 덮어 써야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="78ff1ddb35b202fd0d219b21ef772bd58b1eade3" translate="yes" xml:space="preserve">
          <source>Whether connections in the ACCESSIBLE state can be shared within the context of a transaction.</source>
          <target state="translated">ACCESSIBLE 상태의 연결을 트랜잭션 컨텍스트 내에서 공유 할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d963e504d2818a32c6f1cd2593a93c07bb4158f5" translate="yes" xml:space="preserve">
          <source>Whether connections should be tested when acquired from the pool.</source>
          <target state="translated">풀에서 획득 할 때 연결을 테스트해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5fd8ccdf81071ce3acc62c7bfec42b2bf5bb9cf8" translate="yes" xml:space="preserve">
          <source>Whether core threads are allowed to time out. This enables dynamic growing and shrinking of the pool.</source>
          <target state="translated">코어 스레드가 시간 초과 될 수 있는지 여부. 이를 통해 풀의 동적 증가 및 축소가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5dfdf411e58e272e6c46568bdcf9bea70ef54e44" translate="yes" xml:space="preserve">
          <source>Whether credentials are supported. When not set, credentials are not supported.</source>
          <target state="translated">자격 증명이 지원되는지 여부. 설정하지 않으면 자격 증명이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f4aa9b7cd97e52c599c08a95bfbbd709f2d1306" translate="yes" xml:space="preserve">
          <source>Whether exporting of metrics to Ganglia is enabled.</source>
          <target state="translated">Ganglia로 메트릭 내보내기가 활성화되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="09ed2e7bb45e1c8160f8143534d193835df767e1" translate="yes" xml:space="preserve">
          <source>Whether exporting of metrics to Graphite is enabled.</source>
          <target state="translated">Graphite로 메트릭 내보내기가 활성화되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="8bfa0563e916b415ce3d219408212fb2dd8abd28" translate="yes" xml:space="preserve">
          <source>Whether exporting of metrics to JMX is enabled.</source>
          <target state="translated">메트릭을 JMX로 내보낼 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8e71466838aaeefca39fe951f090279a44ecc07c" translate="yes" xml:space="preserve">
          <source>Whether exporting of metrics to Prometheus is enabled.</source>
          <target state="translated">Prometheus로 메트릭 내보내기가 활성화되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="07b3669db6e708415a89f90135925c9c598dced5" translate="yes" xml:space="preserve">
          <source>Whether exporting of metrics to StatsD is enabled.</source>
          <target state="translated">통계를 StatsD로 내보낼 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="31b449be60672cbad28e93391839da6748080117" translate="yes" xml:space="preserve">
          <source>Whether exporting of metrics to this backend is enabled.</source>
          <target state="translated">이 백엔드로 메트릭 내보내기가 활성화되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5889f5a601f7bf6c67a21d87ea7e4d90637ee2b0" translate="yes" xml:space="preserve">
          <source>Whether hidden form inputs acting as markers for checkboxes should be rendered before the checkbox element itself.</source>
          <target state="translated">확인란의 마커 역할을하는 숨겨진 양식 입력이 확인란 요소 자체보다 먼저 렌더링되어야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="728c1c45f2713ee897adaa57111e405c61504e50" translate="yes" xml:space="preserve">
          <source>Whether hostname verification is required.</source>
          <target state="translated">호스트 이름 확인이 필요한지 여부.</target>
        </trans-unit>
        <trans-unit id="b01dd6b955a205aeb7287eb768a463240e6410d8" translate="yes" xml:space="preserve">
          <source>Whether images should be inverted for dark terminal themes.</source>
          <target state="translated">어두운 터미널 테마에 대해 이미지를 반전해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ebf8824e22e47b0299766725aa2c9033eb471c91" translate="yes" xml:space="preserve">
          <source>Whether initialization should be performed lazily.</source>
          <target state="translated">초기화를 느리게 수행해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6247eeb82d8b665986aecffc2f5ec83adbfbe28b" translate="yes" xml:space="preserve">
          <source>Whether local transactions are desired.</source>
          <target state="translated">로컬 트랜잭션이 필요한지 여부.</target>
        </trans-unit>
        <trans-unit id="f238273c3eb375feeef8a32811b7ac5cea41fb1d" translate="yes" xml:space="preserve">
          <source>Whether logging of (potentially sensitive) request details at DEBUG and TRACE level is allowed.</source>
          <target state="translated">DEBUG 및 TRACE 레벨에서 (잠재적으로 민감한) 요청 세부 사항의 로깅이 허용되는지 여부.</target>
        </trans-unit>
        <trans-unit id="167e459cb1743f67cf62f55af8f2866e91a64ced" translate="yes" xml:space="preserve">
          <source>Whether logging of the request will only be enabled if &quot;ServletRequest.getAttribute(conditionIf)&quot; does not yield null.</source>
          <target state="translated">&quot;ServletRequest.getAttribute (conditionIf)&quot;가 null을 생성하지 않는 경우에만 요청 로깅을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c98c6e431699604c27fa9a4c98177eea6864d2be" translate="yes" xml:space="preserve">
          <source>Whether logging of the request will only be enabled if &quot;ServletRequest.getAttribute(conditionUnless)&quot; yield null.</source>
          <target state="translated">&quot;ServletRequest.getAttribute (conditionUnless)&quot;가 null을 생성하는 경우에만 요청 로깅을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="74265d90e543a40a869de9f966af437ee77def59" translate="yes" xml:space="preserve">
          <source>Whether meter IDs starting with the specified name should be enabled. The longest match wins, the key `all` can also be used to configure all meters.</source>
          <target state="translated">지정된 이름으로 시작하는 측정기 ID를 활성화해야하는지 여부입니다. 가장 긴 경기가 이기고 'all'키를 사용하여 모든 미터를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26ff7a93bbdd2d79cc6a7a7cb47176918efef20e" translate="yes" xml:space="preserve">
          <source>Whether meter IDs starting with the specified name should publish percentile histograms. For monitoring systems that support aggregable percentile calculation based on a histogram, this can be set to true. For other systems, this has no effect. The longest match wins, the key `all` can also be used to configure all meters.</source>
          <target state="translated">지정된 이름으로 시작하는 미터 ID가 백분위 수 히스토그램을 게시해야하는지 여부입니다. 히스토그램을 기반으로 집계 가능한 백분위 수 계산을 지원하는 모니터링 시스템의 경우이 값을 true로 설정할 수 있습니다. 다른 시스템의 경우 이것은 효과가 없습니다. 가장 긴 경기가 이기고 'all'키를 사용하여 모든 미터를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dddd6b57dfa0229e906ad8843ab796fe28adfb7" translate="yes" xml:space="preserve">
          <source>Whether or not to auto-start the streams factory bean.</source>
          <target state="translated">스트림 팩토리 Bean을 자동 시작할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="822dc307014eeb60f223a1f773c63b6ccf530f6a" translate="yes" xml:space="preserve">
          <source>Whether percentile histograms should be published.</source>
          <target state="translated">백분위 수 히스토그램을 게시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="cf14485e27183f846c7d41951b508961695c8cfb" translate="yes" xml:space="preserve">
          <source>Whether pooling is enabled. Enabled automatically if &quot;r2dbc-pool&quot; is on the classpath.</source>
          <target state="translated">풀링 활성화 여부. &quot;r2dbc-pool&quot;이 클래스 경로에있는 경우 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="3343244f8cf275be4e5e75142acb4287bd947604" translate="yes" xml:space="preserve">
          <source>Whether producers and consumers should be cached.</source>
          <target state="translated">생산자와 소비자를 캐시해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="5c27b48dbe70a43297f20af82cc5a02f7a049bc6" translate="yes" xml:space="preserve">
          <source>Whether publishing retries are enabled.</source>
          <target state="translated">게시 재 시도가 활성화되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="2f7ecc2ca57a38cc926fbcf448bd9de197ddcb49" translate="yes" xml:space="preserve">
          <source>Whether read-only operations should use an anonymous environment. Disabled by default unless a username is set.</source>
          <target state="translated">읽기 전용 작업이 익명 환경을 사용해야하는지 여부입니다. 사용자 이름이 설정되어 있지 않으면 기본적으로 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="591e47dbeef3504f1918575fdb73e489aa705ed0" translate="yes" xml:space="preserve">
          <source>Whether recovery failures should be ignored.</source>
          <target state="translated">복구 실패를 무시해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="6b50ae54db3e2c639d72cb5d6972197c27942240" translate="yes" xml:space="preserve">
          <source>Whether rejected deliveries are re-queued by default.</source>
          <target state="translated">거부 된 배달이 기본적으로 다시 대기열에 추가되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7f13328faf882b5c9926a913bbcea725caa01a8c" translate="yes" xml:space="preserve">
          <source>Whether requests to the context root should be redirected by appending a / to the path. When using SSL terminated at a proxy, this property should be set to false.</source>
          <target state="translated">경로에 /를 추가하여 컨텍스트 루트에 대한 요청을 리디렉션해야하는지 여부입니다. 프록시에서 종료 된 SSL을 사용하는 경우이 속성을 false로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="e92cbb8c81a8811ace3e8a2135470c09c602a45b" translate="yes" xml:space="preserve">
          <source>Whether resources should be enlisted and delisted automatically.</source>
          <target state="translated">리소스가 자동으로 등록 및 삭제되어야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ca852488f9e354cde0f6b84a80738cf5757da4f2" translate="yes" xml:space="preserve">
          <source>Whether response compression is enabled.</source>
          <target state="translated">응답 압축이 사용되는지 여부.</target>
        </trans-unit>
        <trans-unit id="df4b1d6d01ea59f89f9d92a78d6516e59f110a60" translate="yes" xml:space="preserve">
          <source>Whether retries are stateless or stateful.</source>
          <target state="translated">재 시도가 Stateless인지 Stateful인지 여부.</target>
        </trans-unit>
        <trans-unit id="854e7144e1601e350950b3accd57fbf244da8fd5" translate="yes" xml:space="preserve">
          <source>Whether rollback should be tested before update is performed.</source>
          <target state="translated">업데이트를 수행하기 전에 롤백을 테스트해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ff04f9b0f0cb105d107802505d79a4e33e3eb634" translate="yes" xml:space="preserve">
          <source>Whether servlet filters should be initialized on startup.</source>
          <target state="translated">시작시 서블릿 필터를 초기화해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="affd835303abdb41783c1d90c585719532299ba7" translate="yes" xml:space="preserve">
          <source>Whether static resource caching is permitted for this web application.</source>
          <target state="translated">이 웹 애플리케이션에 정적 자원 캐싱이 허용되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1b86fb645d206dc82447a2a2d9b1be81f4d7f5c2" translate="yes" xml:space="preserve">
          <source>Whether sub-transactions should be joined when possible.</source>
          <target state="translated">가능한 경우 하위 트랜잭션을 결합해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e7268607b4de57738f48cefb2383f41a64bd3529" translate="yes" xml:space="preserve">
          <source>Whether subclass-based (CGLIB) proxies are to be created (true), as opposed to standard Java interface-based proxies (false).</source>
          <target state="translated">표준 Java 인터페이스 기반 프록시 (false)와 달리 서브 클래스 기반 (CGLIB) 프록시가 작성되는지 (true) 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b79bac485111aa56626437cf1d7234b19615f7b2" translate="yes" xml:space="preserve">
          <source>Whether the 'Connection: keep-alive' header should be added to all responses, even if not required by the HTTP specification.</source>
          <target state="translated">HTTP 사양에서 요구하지 않는 경우에도 'Connection : keep-alive'헤더를 모든 응답에 추가해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5986f0fb799897acf7f0accbc5f735b5d88aeadd" translate="yes" xml:space="preserve">
          <source>Whether the &lt;code&gt;start-stop-daemon&lt;/code&gt; command, when it&amp;rsquo;s available, should be used to control the process</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;start-stop-daemon&lt;/code&gt; 명령을 사용하여 프로세스를 제어해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="3d669066b9e19e6647b2867b9273bff65d285af4" translate="yes" xml:space="preserve">
          <source>Whether the &lt;code&gt;start-stop-daemon&lt;/code&gt; command, when it&amp;rsquo;s available, should be used to control the process. Defaults to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 경우 &lt;code&gt;start-stop-daemon&lt;/code&gt; 명령을 사용하여 프로세스를 제어해야하는지 여부입니다. 기본값은 &lt;code&gt;true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c63600d449caad2e788349fa13ed4fc8e26cd95f" translate="yes" xml:space="preserve">
          <source>Whether the JSP servlet is registered.</source>
          <target state="translated">JSP 서블릿이 등록되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="a1a50537fecaa5244ff46698ab59dd5e8774b497" translate="yes" xml:space="preserve">
          <source>Whether the Reactor Debug Agent should be enabled when reactor-tools is present.</source>
          <target state="translated">리액터 도구가있을 때 리액터 디버그 에이전트를 활성화해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="5abbf67dc685a2da599ba02d1fa35921d73bbddc" translate="yes" xml:space="preserve">
          <source>Whether the URL should be decoded. When disabled, percent-encoded characters in the URL will be left as-is.</source>
          <target state="translated">URL을 디코딩해야하는지 여부입니다. 비활성화하면 URL에서 백분율로 인코딩 된 문자가 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="6cc31e35f3df69adb7fc0a1340bd9bb9c852278a" translate="yes" xml:space="preserve">
          <source>Whether the application should have a shutdown hook registered.</source>
          <target state="translated">애플리케이션에 종료 후크를 등록해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="88d0a225afec78ca95073adbbe8a0a29a7c8cf22" translate="yes" xml:space="preserve">
          <source>Whether the client should use SSL to connect to the endpoints.</source>
          <target state="translated">클라이언트가 SSL을 사용하여 엔드 포인트에 연결해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="e9cc2a3114d96562e10a70b73936553b334041af" translate="yes" xml:space="preserve">
          <source>Whether the consumer's offset is periodically committed in the background.</source>
          <target state="translated">소비자의 오프셋이 백그라운드에서 주기적으로 커밋되는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d8b2c7eb25fa97f968d65a63e25fb9f3e5d2ec46" translate="yes" xml:space="preserve">
          <source>Whether the container creates a batch of messages based on the 'receive-timeout' and 'batch-size'. Coerces 'de-batching-enabled' to true to include the contents of a producer created batch in the batch as discrete records.</source>
          <target state="translated">컨테이너가 'receive-timeout'및 'batch-size'를 기반으로 메시지 배치를 생성하는지 여부입니다. 생산자가 생성 한 배치의 내용을 개별 레코드로 배치에 포함하도록 '배치 해제 사용'을 true로 강제 변환합니다.</target>
        </trans-unit>
        <trans-unit id="063a8505796f17babf79ef0289d11bc535d43a7c" translate="yes" xml:space="preserve">
          <source>Whether the container should fail to start if at least one of the configured topics are not present on the broker.</source>
          <target state="translated">구성된 토픽 중 하나 이상이 브로커에없는 경우 컨테이너 시작에 실패해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="bfb9327d7644f744b86e2f688ed34643374207de" translate="yes" xml:space="preserve">
          <source>Whether the container should present batched messages as discrete messages or call the listener with the batch.</source>
          <target state="translated">컨테이너가 일괄 처리 된 메시지를 개별 메시지로 표시해야하는지 또는 일괄 처리와 함께 리스너를 호출해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6088cd47ee1d0661cda80242485f7d3a10864143" translate="yes" xml:space="preserve">
          <source>Whether the content of the &quot;default&quot; model should be ignored during redirect scenarios.</source>
          <target state="translated">리디렉션 시나리오에서 &quot;기본&quot;모델의 콘텐츠를 무시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="da09e3fe4cdf37a8e77adc02f6681db4585bcaec" translate="yes" xml:space="preserve">
          <source>Whether the database can run many transactions on the same connection and supports transaction interleaving.</source>
          <target state="translated">데이터베이스가 동일한 연결에서 많은 트랜잭션을 실행할 수 있고 트랜잭션 인터리빙을 지원하는지 여부.</target>
        </trans-unit>
        <trans-unit id="a462b7f12b28eecbfb0402c1e98ea3fe33eab43b" translate="yes" xml:space="preserve">
          <source>Whether the default broker URL should be in memory. Ignored if an explicit broker has been specified.</source>
          <target state="translated">기본 브로커 URL이 메모리에 있어야하는지 여부입니다. 명시 적 브로커가 지정된 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1daf30b22a96ff9718f70a10b6b1b405b9c126aa" translate="yes" xml:space="preserve">
          <source>Whether the default destination type is topic.</source>
          <target state="translated">기본 대상 유형이 주제인지 여부.</target>
        </trans-unit>
        <trans-unit id="28ca417fdb81c6e436c3def578eca7ce08c37da8" translate="yes" xml:space="preserve">
          <source>Whether the driver should use encrypted traffic.</source>
          <target state="translated">드라이버가 암호화 된 트래픽을 사용해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="58bd1157d4037c3869a0cb7adbe8f507b98d8570" translate="yes" xml:space="preserve">
          <source>Whether the executor should wait for scheduled tasks to complete on shutdown.</source>
          <target state="translated">실행 프로그램이 종료시 예약 된 작업이 완료 될 때까지 기다려야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2016c2d11b80c1093e5ea3b53246a09c0ce57e91" translate="yes" xml:space="preserve">
          <source>Whether the provider can run many transactions on the same connection and supports transaction interleaving.</source>
          <target state="translated">공급자가 동일한 연결에서 많은 트랜잭션을 실행할 수 있고 트랜잭션 인터리빙을 지원하는지 여부.</target>
        </trans-unit>
        <trans-unit id="2ac4150b461868087a90d3bc177835fdf281034c" translate="yes" xml:space="preserve">
          <source>Whether the server should decode percent encoded slash characters. Enabling encoded slashes can have security implications due to different servers interpreting the slash differently. Only enable this if you have a legacy application that requires it.</source>
          <target state="translated">서버가 백분율로 인코딩 된 슬래시 문자를 디코딩해야하는지 여부입니다. 인코딩 된 슬래시를 활성화하면 서버마다 슬래시를 다르게 해석하므로 보안에 영향을 미칠 수 있습니다. 이를 필요로하는 레거시 애플리케이션이있는 경우에만 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="e3c8d10eb2f6a8bb9628a3de10bfd7fe08410970" translate="yes" xml:space="preserve">
          <source>Whether the trailing slash should be ignored when recording metrics.</source>
          <target state="translated">메트릭을 기록 할 때 후행 슬래시를 무시해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b7a543821141c21165c321edb9943c4325e87ad2" translate="yes" xml:space="preserve">
          <source>Whether the transaction manager should allow mixing XA and non-XA transactions.</source>
          <target state="translated">트랜잭션 관리자가 XA 및 비 XA 트랜잭션 혼합을 허용해야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="bf84fcdbec83af0d19a5300cc9684280795da782" translate="yes" xml:space="preserve">
          <source>Whether the transaction timeout should be set on the XAResource when it is enlisted.</source>
          <target state="translated">트랜잭션 제한 시간이 등록 될 때 XAResource에 설정되어야하는지 여부.</target>
        </trans-unit>
        <trans-unit id="bfb1b9d465f880db908d2169fd38566fc0639307" translate="yes" xml:space="preserve">
          <source>Whether this resource is disabled, meaning it's temporarily forbidden to acquire a connection from its pool.</source>
          <target state="translated">이 리소스가 비활성화되었는지 여부. 즉, 해당 풀에서 연결을 얻는 것이 일시적으로 금지되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced698b777da39a9e1435844fe16b57091c90991" translate="yes" xml:space="preserve">
          <source>Whether to allocate buffers outside the Java heap. The default is derived from the maximum amount of memory that is available to the JVM.</source>
          <target state="translated">Java 힙 외부에 버퍼를 할당할지 여부입니다. 기본값은 JVM에서 사용할 수있는 최대 메모리 양에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="8f668b60af02e8a037549f88be1bf3827999b8a3" translate="yes" xml:space="preserve">
          <source>Whether to allow migrations to be run out of order.</source>
          <target state="translated">마이그레이션이 순서대로 실행되도록 허용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="26dfd1d957cee3d4cf1a855c943dc44d836ba3e2" translate="yes" xml:space="preserve">
          <source>Whether to allow mixing transactional and non-transactional statements within the same migration.</source>
          <target state="translated">동일한 마이그레이션 내에서 트랜잭션 문과 비 트랜잭션 문을 혼합 할 수 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6e48f5165cb6892cd369b9a185e76abefea8ed2d" translate="yes" xml:space="preserve">
          <source>Whether to always apply the MessageFormat rules, parsing even messages without arguments.</source>
          <target state="translated">항상 MessageFormat 규칙을 적용하여 인수가없는 메시지도 구문 분석할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="69d84e8529bb755f9606e21cc033622178de5de1" translate="yes" xml:space="preserve">
          <source>Whether to always mark the session cookie as secure.</source>
          <target state="translated">세션 쿠키를 항상 보안으로 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="06ce550b2a1f9f20c0dd8878a6109fbbc66b30d7" translate="yes" xml:space="preserve">
          <source>Whether to automatically call baseline when migrating a non-empty schema.</source>
          <target state="translated">비어 있지 않은 스키마를 마이그레이션 할 때 기준선을 자동으로 호출할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="776f094b7a42775aa6039b34d87381450edfd420" translate="yes" xml:space="preserve">
          <source>Whether to automatically call clean when a validation error occurs.</source>
          <target state="translated">유효성 검사 오류 발생시 자동으로 clean을 호출할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e8ce6ca0c611bca575eeae0b3bea5378444e7520" translate="yes" xml:space="preserve">
          <source>Whether to automatically call validate when performing a migration.</source>
          <target state="translated">마이그레이션을 수행 할 때 자동으로 validate를 호출할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="de2d39bc1b6df7a04e3f79708dd0b83101ae8c7d" translate="yes" xml:space="preserve">
          <source>Whether to automatically start the scheduler after initialization.</source>
          <target state="translated">초기화 후 스케줄러를 자동으로 시작할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a0acad5b6393f60ec365ad0bb70acd58e8ccba18" translate="yes" xml:space="preserve">
          <source>Whether to automatically time web client requests.</source>
          <target state="translated">웹 클라이언트 요청 시간을 자동으로 지정할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b5913e92088b28722a6f38cc6436d7d7424b03ef" translate="yes" xml:space="preserve">
          <source>Whether to automatically time web server requests.</source>
          <target state="translated">웹 서버 요청 시간을 자동으로 지정할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="17e3835fa4c550958380411f591966d3d60e3b53" translate="yes" xml:space="preserve">
          <source>Whether to batch SQL statements when executing them. Requires Flyway Teams.</source>
          <target state="translated">SQL 문을 실행할 때 일괄 처리할지 여부입니다. Flyway 팀이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="72c6fcbf71fb223211ee90d8f7da733078454467" translate="yes" xml:space="preserve">
          <source>Whether to be lenient about parsing JSON that doesn't conform to RFC 4627.</source>
          <target state="translated">RFC 4627을 준수하지 않는 JSON 구문 분석에 관대한지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f7c4eee8375a82ba402b37527b8d7062f7b4691a" translate="yes" xml:space="preserve">
          <source>Whether to block when a connection is requested and the pool is full. Set it to false to throw a &quot;JMSException&quot; instead.</source>
          <target state="translated">연결이 요청되고 풀이 가득 찬 경우 차단할지 여부입니다. 대신 &quot;JMSException&quot;을 발생 시키려면 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ca0f7ba29d35eca2ffc1f78029d078ae6c9f4dfc" translate="yes" xml:space="preserve">
          <source>Whether to buffer output such that it is flushed only periodically.</source>
          <target state="translated">주기적으로 만 플러시되도록 출력을 버퍼링할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d07c2a2b6a7ccd0397def360da0496c388785922" translate="yes" xml:space="preserve">
          <source>Whether to cache message consumers.</source>
          <target state="translated">메시지 소비자를 캐시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="064cffda2d0205b9a675a03e44b82fdfb49d8d81" translate="yes" xml:space="preserve">
          <source>Whether to cache message producers.</source>
          <target state="translated">메시지 생성자를 캐시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2e43b03bd401bb5fd4c4094acce1a54480951097" translate="yes" xml:space="preserve">
          <source>Whether to cache sessions.</source>
          <target state="translated">세션을 캐시할지 여부.</target>
        </trans-unit>
        <trans-unit id="70ddd6e341bf74000b7ffde54533ea4ccac9b206" translate="yes" xml:space="preserve">
          <source>Whether to check for log file existence so it can be recreated it if an external process has renamed it.</source>
          <target state="translated">외부 프로세스에서 이름을 변경 한 경우 다시 생성 할 수 있도록 로그 파일 존재 여부를 확인할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6de7d818a142a96a3c1ba84768c1df26ce14c5dc" translate="yes" xml:space="preserve">
          <source>Whether to check that migration scripts location exists.</source>
          <target state="translated">마이그레이션 스크립트 위치가 있는지 확인할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a7076b91dd2eda612d27759d0454d30c8234a002" translate="yes" xml:space="preserve">
          <source>Whether to check that the template exists before rendering it.</source>
          <target state="translated">템플릿을 렌더링하기 전에 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b09f98d6577e0532c4d0a04ddd301aedbd2c4181" translate="yes" xml:space="preserve">
          <source>Whether to check that the templates location exists.</source>
          <target state="translated">템플릿 위치가 있는지 확인할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3240b3ca327077f198e5c2bb5f1a728fab7ac1bb" translate="yes" xml:space="preserve">
          <source>Whether to clean the archive log files on startup.</source>
          <target state="translated">시작시 아카이브 로그 파일을 정리할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e20c03aa7313c876ec6e05ef1bd310d8fb324e60" translate="yes" xml:space="preserve">
          <source>Whether to clear all checksums in the current changelog, so they will be recalculated upon the next update.</source>
          <target state="translated">현재 변경 로그의 모든 체크섬을 지 울지 여부. 다음 업데이트시 다시 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3da5f3879cf8f917fc84dd2651a19c338d9b0c34" translate="yes" xml:space="preserve">
          <source>Whether to create an AmqpAdmin bean.</source>
          <target state="translated">AmqpAdmin Bean 작성 여부입니다.</target>
        </trans-unit>
        <trans-unit id="575799cef965480fe14f016c6f018ea921ef6dd0" translate="yes" xml:space="preserve">
          <source>Whether to create the Influx database if it does not exist before attempting to publish metrics to it.</source>
          <target state="translated">메트릭을 게시하기 전에 Influx 데이터베이스가없는 경우 생성할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="08a02c446de78acf585d7325f10108b1b8565363" translate="yes" xml:space="preserve">
          <source>Whether to create the index automatically if it does not exist.</source>
          <target state="translated">인덱스가없는 경우 자동으로 생성할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b04dcdd891e2ccec8d3c233bb097b5c075e38cfb" translate="yes" xml:space="preserve">
          <source>Whether to defer inclusion of the date stamp in the file name until rotate time.</source>
          <target state="translated">회전 시간까지 파일 이름에 날짜 스탬프 포함을 연기할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b0d60221b35120eaf226407943723aaeadc52108" translate="yes" xml:space="preserve">
          <source>Whether to deny meters from emitting any metrics.</source>
          <target state="translated">미터가 메트릭을 내보내는 것을 거부할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0523ec20da1cb7d8ef87fc3e6dcfc0f80f2370cf" translate="yes" xml:space="preserve">
          <source>Whether to disable cleaning of the database.</source>
          <target state="translated">데이터베이스 정리를 비활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0fa86a1fa6bb56078f075d118a2366e95d204760" translate="yes" xml:space="preserve">
          <source>Whether to disable the escaping of HTML characters such as '&amp;lt;', '&amp;gt;', etc.</source>
          <target state="translated">'&amp;lt;', '&amp;gt;'등과 같은 HTML 문자의 이스케이프를 비활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1ab28b63bf97e1a59ccb3f6dd830a7274603c311" translate="yes" xml:space="preserve">
          <source>Whether to discover and query all cluster nodes for obtaining the cluster topology. When set to false, only the initial seed nodes are used as sources for topology discovery.</source>
          <target state="translated">클러스터 토폴로지를 얻기 위해 모든 클러스터 노드를 검색하고 쿼리할지 여부입니다. false로 설정하면 초기 시드 노드 만 토폴로지 검색을위한 소스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="56716408ee02874657ddd15b31ab23e573c43eb0" translate="yes" xml:space="preserve">
          <source>Whether to dispatch OPTIONS requests to the FrameworkServlet doService method.</source>
          <target state="translated">OPTIONS 요청을 FrameworkServlet doService 메소드로 디스패치할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2f45f744af7b14b2d1e548d401258374044e9bb7" translate="yes" xml:space="preserve">
          <source>Whether to dispatch TRACE requests to the FrameworkServlet doService method.</source>
          <target state="translated">FrameworkServlet doService 메소드에 TRACE 요청을 발송할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3a6f09830dc2d85af886a5ae246c3e7f064fb95c" translate="yes" xml:space="preserve">
          <source>Whether to enable Cassandra health check.</source>
          <target state="translated">Cassandra 상태 확인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f999eea52abd9684db21ccabd25864ce4dd2e4e8" translate="yes" xml:space="preserve">
          <source>Whether to enable Couchbase health check.</source>
          <target state="translated">Couchbase 상태 확인 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="992d14be64b746fd4a38f7e86d06e494c19bc236" translate="yes" xml:space="preserve">
          <source>Whether to enable Elasticsearch health check.</source>
          <target state="translated">Elasticsearch 상태 확인을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="cd12df09f8847728360870b90af1800ea0434462" translate="yes" xml:space="preserve">
          <source>Whether to enable Elasticsearch repositories.</source>
          <target state="translated">Elasticsearch 리포지토리 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ff98d1e883840c027910b5bb2f2a4edcdb2d2fc3" translate="yes" xml:space="preserve">
          <source>Whether to enable GZIP compression of metrics batches published to Influx.</source>
          <target state="translated">Influx에 게시 된 메트릭 배치의 GZIP 압축을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="39cbd267c5a20dcf34a87f47bb35c58f5c2e33f4" translate="yes" xml:space="preserve">
          <source>Whether to enable HTTP request-response tracing.</source>
          <target state="translated">HTTP 요청-응답 추적을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f815bb5d2f6edb041431384a61f007463713e876" translate="yes" xml:space="preserve">
          <source>Whether to enable HTTP/2 support, if the current environment supports it.</source>
          <target state="translated">현재 환경에서 지원하는 경우 HTTP / 2 지원 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a363bd4841f63fda607941c1d4f860541c167391" translate="yes" xml:space="preserve">
          <source>Whether to enable InfluxDB health check.</source>
          <target state="translated">InfluxDB 상태 확인 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3ee55e70ff08f28589c1988438e17101b1220587" translate="yes" xml:space="preserve">
          <source>Whether to enable JAAS configuration.</source>
          <target state="translated">JAAS 구성 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7786b2b057b3ae646c61640bd1ed7b645e2d1883" translate="yes" xml:space="preserve">
          <source>Whether to enable JDBC repositories.</source>
          <target state="translated">JDBC 저장소 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b393797c0dea4a236305b28a9ea5cb6830bbb28b" translate="yes" xml:space="preserve">
          <source>Whether to enable JMS health check.</source>
          <target state="translated">JMS 상태 확인 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d4bead9c30463a755b01c8adb2e067cffdf477e7" translate="yes" xml:space="preserve">
          <source>Whether to enable JPA repositories.</source>
          <target state="translated">JPA 저장소를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="6214d3814963c3bb44f5abb4acd10e19302b333f" translate="yes" xml:space="preserve">
          <source>Whether to enable JTA support.</source>
          <target state="translated">JTA 지원 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="51c0f20697cf0d4d81529ba41cb005f05a8ceec5" translate="yes" xml:space="preserve">
          <source>Whether to enable LDAP health check.</source>
          <target state="translated">LDAP 상태 확인 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f45f260e25dad68f1826c6e86ce8dec792ee72d1" translate="yes" xml:space="preserve">
          <source>Whether to enable LDAP repositories.</source>
          <target state="translated">LDAP 저장소를 사용할지 여부.</target>
        </trans-unit>
        <trans-unit id="620dfaa4e222232a9750f61319e24a5c052bd256" translate="yes" xml:space="preserve">
          <source>Whether to enable LDAP schema validation.</source>
          <target state="translated">LDAP 스키마 유효성 검사를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b6cc48a1b2d0e6318b6399c7eecaf02bd3420266" translate="yes" xml:space="preserve">
          <source>Whether to enable Liquibase support.</source>
          <target state="translated">Liquibase 지원 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="0c25c9485b5937731dbdd59acabebe26e2f676a0" translate="yes" xml:space="preserve">
          <source>Whether to enable MVC view resolution for this technology.</source>
          <target state="translated">이 기술에 대해 MVC보기 해상도를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="cf5f0e359f801d9918916eab665cf8db31b3bbbe" translate="yes" xml:space="preserve">
          <source>Whether to enable Mail health check.</source>
          <target state="translated">메일 상태 확인 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="518b2b801502234d8dc7e32653e484b6fe2f9106" translate="yes" xml:space="preserve">
          <source>Whether to enable MongoDB health check.</source>
          <target state="translated">MongoDB 상태 확인을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7357209b98d6782fc50cab424a539c935df3e33a" translate="yes" xml:space="preserve">
          <source>Whether to enable Neo4j health check.</source>
          <target state="translated">Neo4j 상태 확인을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c115444d85ba90837693f28b542f71047d61e62f" translate="yes" xml:space="preserve">
          <source>Whether to enable R2DBC repositories.</source>
          <target state="translated">R2DBC 저장소 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9a27479e8331f6c265e86f7ab4f0dd0e76b34998" translate="yes" xml:space="preserve">
          <source>Whether to enable RabbitMQ health check.</source>
          <target state="translated">RabbitMQ 상태 확인 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d417ed2796deab8a36ff1bb012e5fb9d4d6f2e94" translate="yes" xml:space="preserve">
          <source>Whether to enable Redis health check.</source>
          <target state="translated">Redis 상태 확인을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="aa9827d0bb40ab24534c7da75b6db17e30a59a80" translate="yes" xml:space="preserve">
          <source>Whether to enable Redis repositories.</source>
          <target state="translated">Redis 리포지토리 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7d078d8cd37e6a87599a768d1bd356ab1c47c3e1" translate="yes" xml:space="preserve">
          <source>Whether to enable SSL support.</source>
          <target state="translated">SSL 지원 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="60799845ad99fe8ee14ccec4edaec9555eae5634" translate="yes" xml:space="preserve">
          <source>Whether to enable SSL support. Determined automatically if an address is provided with the protocol (amqp:// vs. amqps://).</source>
          <target state="translated">SSL 지원 활성화 여부. 주소가 프로토콜과 함께 제공되면 자동으로 결정됩니다 (amqp : // 대 amqps : //).</target>
        </trans-unit>
        <trans-unit id="f8a68defdcf69e7a699758a363f2b7f02dc1a65f" translate="yes" xml:space="preserve">
          <source>Whether to enable SSL support. Enabled automatically if a &quot;keyStore&quot; is provided unless specified otherwise.</source>
          <target state="translated">SSL 지원 활성화 여부. 달리 지정하지 않는 한 &quot;keyStore&quot;가 제공되면 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1f5841aa457ffdc9adc1d2b7deb609092a3fb8" translate="yes" xml:space="preserve">
          <source>Whether to enable Solr health check.</source>
          <target state="translated">Solr 상태 확인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1eeabec029a4feedc2ff009ec7a771df6358affd" translate="yes" xml:space="preserve">
          <source>Whether to enable Solr repositories.</source>
          <target state="translated">Solr 저장소를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7d42ff0d5797cfb3ddafd6babf79d6c549547e32" translate="yes" xml:space="preserve">
          <source>Whether to enable Spring's FormContentFilter.</source>
          <target state="translated">Spring의 FormContentFilter 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="ad8d6c85f993ff99fd5529b5a070fccdb17b3ac9" translate="yes" xml:space="preserve">
          <source>Whether to enable Spring's HiddenHttpMethodFilter.</source>
          <target state="translated">Spring의 HiddenHttpMethodFilter 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="8408b7aa50057bcea36bfdd484992c62e98105c8" translate="yes" xml:space="preserve">
          <source>Whether to enable Thymeleaf view resolution for Web frameworks.</source>
          <target state="translated">웹 프레임 워크에 대해 Thymeleaf보기 해상도를 사용할지 여부.</target>
        </trans-unit>
        <trans-unit id="94d189d2ad174ae8155bd06b76e2b3358fb23bf5" translate="yes" xml:space="preserve">
          <source>Whether to enable a livereload.com-compatible server.</source>
          <target state="translated">livereload.com 호환 서버 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="1d905606dad6b57d5b67abb615c8f88a1a83f568" translate="yes" xml:space="preserve">
          <source>Whether to enable access log rotation.</source>
          <target state="translated">액세스 로그 회전을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="fa8e1ee8b042a5946cfef1515d70c2acbac86987" translate="yes" xml:space="preserve">
          <source>Whether to enable admin features for the application.</source>
          <target state="translated">애플리케이션에 대한 관리자 기능을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a77325baa22590bac68981d2c5e84482caf9b2b3" translate="yes" xml:space="preserve">
          <source>Whether to enable auto-index creation.</source>
          <target state="translated">자동 색인 생성 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="fd592b25c884e8c970370510ba07f04219a72979" translate="yes" xml:space="preserve">
          <source>Whether to enable automatic restart.</source>
          <target state="translated">자동 재시작 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="893cacc5afe1f20a1efc4f29584a8f354ffe9d4a" translate="yes" xml:space="preserve">
          <source>Whether to enable build info.</source>
          <target state="translated">빌드 정보 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="63c68427d171ad86215d920c1c458a202e5d0e60" translate="yes" xml:space="preserve">
          <source>Whether to enable cache statistics.</source>
          <target state="translated">캐시 통계 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5e9165966537db32546f261d59f72373043aca62" translate="yes" xml:space="preserve">
          <source>Whether to enable caching in the Resource chain.</source>
          <target state="translated">리소스 체인에서 캐싱을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e661fa24ccfd194a2938080af4f90fade7822521" translate="yes" xml:space="preserve">
          <source>Whether to enable database health check.</source>
          <target state="translated">데이터베이스 상태 확인 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d761e8b2896ea42e6468c99246ed05ebcc1e869f" translate="yes" xml:space="preserve">
          <source>Whether to enable default health indicators.</source>
          <target state="translated">기본 Health 표시기 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="78a20be068df2ec46056e91da97d40b521607216" translate="yes" xml:space="preserve">
          <source>Whether to enable default info contributors.</source>
          <target state="translated">기본 정보 제공자를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8f0bb76b9f4fdd6ec1dcb2ce7d988d1ee29e5332" translate="yes" xml:space="preserve">
          <source>Whether to enable default metrics exporters.</source>
          <target state="translated">기본 메트릭 내보내기를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b6bdf0bbe28c6c782bd00a436569a22610f78c71" translate="yes" xml:space="preserve">
          <source>Whether to enable default resource handling.</source>
          <target state="translated">기본 리소스 처리를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7a2da15fb427278b15d402c7b9ac955f4f431ece" translate="yes" xml:space="preserve">
          <source>Whether to enable development property defaults.</source>
          <target state="translated">개발 속성 기본값을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="31f56419b2aa2a2db9e9e338da3848dd4bcf45f0" translate="yes" xml:space="preserve">
          <source>Whether to enable disk logging.</source>
          <target state="translated">디스크 로깅 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="23dd61f30e59dd38e243c2a9d5d1aa99b0b72df6" translate="yes" xml:space="preserve">
          <source>Whether to enable disk space health check.</source>
          <target state="translated">디스크 공간 상태 확인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e4e6fd03d2cba8e7c6f237d2e940d488a62c6732" translate="yes" xml:space="preserve">
          <source>Whether to enable embedded mode if the Artemis server APIs are available.</source>
          <target state="translated">Artemis 서버 API를 사용할 수있는 경우 임베디드 모드를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="18337f10eb26bfaa6c3b7035c953f1fadde3bff3" translate="yes" xml:space="preserve">
          <source>Whether to enable enum value translation through the Spring Data REST default resource bundle.</source>
          <target state="translated">SpringData REST 기본 리소스 번들을 통해 열거 형 값 변환을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a3290f9fb576002745ce0281f6787d425071d21f" translate="yes" xml:space="preserve">
          <source>Whether to enable environment info.</source>
          <target state="translated">환경 정보 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7d44706584b9c70ceb5686bb1fa1a0cba74b440b" translate="yes" xml:space="preserve">
          <source>Whether to enable explicit QoS (Quality of Service) when sending a message. When enabled, the delivery mode, priority and time-to-live properties will be used when sending a message. QoS is automatically enabled when at least one of those settings is customized.</source>
          <target state="translated">메시지를 보낼 때 명시 적 QoS (서비스 품질)를 사용할지 여부입니다. 활성화되면 메시지를 보낼 때 배달 모드, 우선 순위 및 TTL 속성이 사용됩니다. QoS는 이러한 설정 중 하나 이상이 사용자 지정되면 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="205fe3f6d02865a4e829493e0147a61c30979784" translate="yes" xml:space="preserve">
          <source>Whether to enable extended Cloud Foundry actuator endpoints.</source>
          <target state="translated">확장 된 Cloud Foundry 액추에이터 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5ba8fa9808bb1a07e1d84ab8f50634c57f3f49a7" translate="yes" xml:space="preserve">
          <source>Whether to enable flyway.</source>
          <target state="translated">플라이 웨이 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="43f8598ec8b441d3ae6fa8f84747c38126b41c82" translate="yes" xml:space="preserve">
          <source>Whether to enable git info.</source>
          <target state="translated">git info 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="65f32f79f4effee4bb6984cea1d67f5ffed123fe" translate="yes" xml:space="preserve">
          <source>Whether to enable hostname verification.</source>
          <target state="translated">호스트 이름 확인 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f5fb577c319c502657a391a7e59ea60ab7e7028c" translate="yes" xml:space="preserve">
          <source>Whether to enable http encoding support.</source>
          <target state="translated">http 인코딩 지원 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3238877e16978789394e2a38ee471465cf91a7c3" translate="yes" xml:space="preserve">
          <source>Whether to enable liveness and readiness probes.</source>
          <target state="translated">활성 및 준비 상태 프로브를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="bde9db0503b9fbc80e111547015ef705b040dc97" translate="yes" xml:space="preserve">
          <source>Whether to enable liveness state health check.</source>
          <target state="translated">활성 상태 상태 확인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f4ce9a489548d3f7114d4f63ba6062eaab359c74" translate="yes" xml:space="preserve">
          <source>Whether to enable logging of SQL statements.</source>
          <target state="translated">SQL 문 로깅 사용 여부.</target>
        </trans-unit>
        <trans-unit id="90db37c089ec5cb922b1b59e47fbe500e8f907f1" translate="yes" xml:space="preserve">
          <source>Whether to enable mandatory messages.</source>
          <target state="translated">필수 메시지 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f47fb3fe651e8fa05080f4251ce93107836dc36c" translate="yes" xml:space="preserve">
          <source>Whether to enable metrics.</source>
          <target state="translated">메트릭 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="4fefd9697531897bb181da79ecf5157ca25c1111" translate="yes" xml:space="preserve">
          <source>Whether to enable or disable all endpoints by default.</source>
          <target state="translated">기본적으로 모든 엔드 포인트를 활성화 또는 비활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8664b1b345cf54bb7b37a6af21774c0530c55fbb" translate="yes" xml:space="preserve">
          <source>Whether to enable persistent store.</source>
          <target state="translated">영구 저장소 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7c7122d4ce8d9870a4358d6e98c6650e78137153" translate="yes" xml:space="preserve">
          <source>Whether to enable ping health check.</source>
          <target state="translated">ping 상태 확인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="253ab330b5e51b7124d4e700accd5faa098fb5db" translate="yes" xml:space="preserve">
          <source>Whether to enable publisher returns.</source>
          <target state="translated">게시자 반품을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="b67764d739e641994c7e1807e636559c584981c5" translate="yes" xml:space="preserve">
          <source>Whether to enable publishing descriptions as part of the scrape payload to Prometheus. Turn this off to minimize the amount of data sent on each scrape.</source>
          <target state="translated">Prometheus에 스크랩 페이로드의 일부로 설명 게시를 활성화할지 여부입니다. 각 스크랩에서 전송되는 데이터의 양을 최소화하려면이 옵션을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="afd1459f146d5a7c91df6876ad6e1f02be9e97e3" translate="yes" xml:space="preserve">
          <source>Whether to enable readiness state health check.</source>
          <target state="translated">준비 상태 상태 확인을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4634c24fd9a0b53d245f0e117f1da76bf5167fed" translate="yes" xml:space="preserve">
          <source>Whether to enable remote access.</source>
          <target state="translated">원격 액세스를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ac3bbd7ad7089ff552b60d6ee72c52492d04ab0d" translate="yes" xml:space="preserve">
          <source>Whether to enable remote restart.</source>
          <target state="translated">원격 재시작 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="22854bc1c83a1da2663558bdde25fbb069860808" translate="yes" xml:space="preserve">
          <source>Whether to enable resolution of already compressed resources (gzip, brotli). Checks for a resource name with the '.gz' or '.br' file extensions.</source>
          <target state="translated">이미 압축 된 리소스 (gzip, brotli)의 확인을 활성화할지 여부입니다. 파일 확장자가 '.gz'또는 '.br'인 리소스 이름을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6b924228d360a0992db39b90215d93a5a6d9c2f8" translate="yes" xml:space="preserve">
          <source>Whether to enable serialization of complex map keys (i.e. non-primitives).</source>
          <target state="translated">복잡한 맵 키 (예 : 기본이 아닌)의 직렬화를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="dd5c8db1c9329eac9fb11b0de7a00fe15c5b946f" translate="yes" xml:space="preserve">
          <source>Whether to enable server side certificate validation.</source>
          <target state="translated">서버 측 인증서 유효성 검사를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="516290e52cae71fb243b762d96f4410a89a31138" translate="yes" xml:space="preserve">
          <source>Whether to enable storage of audit events.</source>
          <target state="translated">감사 이벤트 저장 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e04914cfb30766b904fe593d3e0e58f15bea5fc7" translate="yes" xml:space="preserve">
          <source>Whether to enable streaming to Atlas LWC.</source>
          <target state="translated">Atlas LWC로 스트리밍을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="39d634f35d6dea877836f40779465bda0f62de50" translate="yes" xml:space="preserve">
          <source>Whether to enable support for Oracle SQL*Plus commands. Requires Flyway Teams.</source>
          <target state="translated">Oracle SQL * Plus 명령 지원 활성화 여부. Flyway 팀이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="717e632d07f6ac0c28202d032bf53429529f2b1c" translate="yes" xml:space="preserve">
          <source>Whether to enable support of multipart uploads.</source>
          <target state="translated">멀티 파트 업로드 지원 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="fd6d051fd02ec1149ee21da2c231178023e32889" translate="yes" xml:space="preserve">
          <source>Whether to enable template caching.</source>
          <target state="translated">템플릿 캐싱 활성화 여부입니다.</target>
        </trans-unit>
        <trans-unit id="438e15fced0aa3bb0d73e8d978e6cfdbcc36b764" translate="yes" xml:space="preserve">
          <source>Whether to enable the PersistenceExceptionTranslationPostProcessor.</source>
          <target state="translated">PersistenceExceptionTranslationPostProcessor 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d6a7e6e678e3dcbc1166e1933e74d112649196d2" translate="yes" xml:space="preserve">
          <source>Whether to enable the Spring Resource Handling chain. By default, disabled unless at least one strategy has been enabled.</source>
          <target state="translated">스프링 리소스 핸들링 체인 활성화 여부. 기본적으로 하나 이상의 전략이 활성화되어 있지 않으면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="fd33ea7720b98ee9c923f0afe7f26bd013d194e2" translate="yes" xml:space="preserve">
          <source>Whether to enable the access log.</source>
          <target state="translated">액세스 로그 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="910aa80e2bd2bf5fc98325bdd87ce7159c1c2e38" translate="yes" xml:space="preserve">
          <source>Whether to enable the auditevents endpoint.</source>
          <target state="translated">auditevents 끝점을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a1b4dc00df9c516e964baa8de720e34260c82361" translate="yes" xml:space="preserve">
          <source>Whether to enable the beans endpoint.</source>
          <target state="translated">Bean 엔드 포인트 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0005a03444ade4119f701dc46f78c5525c489a35" translate="yes" xml:space="preserve">
          <source>Whether to enable the caches endpoint.</source>
          <target state="translated">캐시 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e99c1a1d03276a84b5c4d1f8f8a0dcde35cd35ad" translate="yes" xml:space="preserve">
          <source>Whether to enable the conditions endpoint.</source>
          <target state="translated">조건 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4b97e36c974e87d02ec75401dd9c78b62f7efd3c" translate="yes" xml:space="preserve">
          <source>Whether to enable the configprops endpoint.</source>
          <target state="translated">configprops 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="77ad28eb1e8a044b6ec1ea8c2178d3dcb1b093cf" translate="yes" xml:space="preserve">
          <source>Whether to enable the console.</source>
          <target state="translated">콘솔 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="44a59cf8640a26ae596008e8b3193532782d8161" translate="yes" xml:space="preserve">
          <source>Whether to enable the content Version Strategy.</source>
          <target state="translated">콘텐츠 버전 전략을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5a6ca47688bacde3dacaca47f1d83bf8953b2f8c" translate="yes" xml:space="preserve">
          <source>Whether to enable the default error page displayed in browsers in case of a server error.</source>
          <target state="translated">서버 오류시 브라우저에 표시되는 기본 오류 페이지를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8deaf0fe891861fe6318718ae47288ebb5875150" translate="yes" xml:space="preserve">
          <source>Whether to enable the env endpoint.</source>
          <target state="translated">env 엔드 포인트 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ea592e8fa2b73873d4a7b1878315f018c2bd970f" translate="yes" xml:space="preserve">
          <source>Whether to enable the fixed Version Strategy.</source>
          <target state="translated">고정 버전 전략을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="bc610d6af62f1011f48a5de8462e3a09defccd56" translate="yes" xml:space="preserve">
          <source>Whether to enable the flyway endpoint.</source>
          <target state="translated">플라이 웨이 끝점을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1c1b5fd45514b47ac7ef54827796dde167fbd819" translate="yes" xml:space="preserve">
          <source>Whether to enable the health endpoint.</source>
          <target state="translated">상태 엔드 포인트를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="65bcd4a3ca7b05cb3a7f707e523415f6ae476d08" translate="yes" xml:space="preserve">
          <source>Whether to enable the heapdump endpoint.</source>
          <target state="translated">힙 덤프 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="f9597a07b50ebd8dce5b38eb959d157a85aa1b05" translate="yes" xml:space="preserve">
          <source>Whether to enable the httptrace endpoint.</source>
          <target state="translated">httptrace 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d0b5019cd8b4fcd88b79807c525b69cdb232589b" translate="yes" xml:space="preserve">
          <source>Whether to enable the info endpoint.</source>
          <target state="translated">정보 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e450418baa9deee368b3f6774654c4283121d946" translate="yes" xml:space="preserve">
          <source>Whether to enable the integrationgraph endpoint.</source>
          <target state="translated">통합 그래프 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7a6773a56e4f78d3d6d8d75ba71d5b4c69f0ac62" translate="yes" xml:space="preserve">
          <source>Whether to enable the jolokia endpoint.</source>
          <target state="translated">jolokia 끝점을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c56959e716d76cefb143713200367e13211a67b7" translate="yes" xml:space="preserve">
          <source>Whether to enable the liquibase endpoint.</source>
          <target state="translated">liquibase 끝점을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="2004a96e30c654891fb7e828c3425289c833c6db" translate="yes" xml:space="preserve">
          <source>Whether to enable the logfile endpoint.</source>
          <target state="translated">로그 파일 엔드 포인트를 사용할지 여부.</target>
        </trans-unit>
        <trans-unit id="8aa41cf0fb2048761128df4599f470a58282c891" translate="yes" xml:space="preserve">
          <source>Whether to enable the loggers endpoint.</source>
          <target state="translated">로거 엔드 포인트 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8d53499202ac60ca28954fcff6fe2c93d92c0f6d" translate="yes" xml:space="preserve">
          <source>Whether to enable the mappings endpoint.</source>
          <target state="translated">매핑 끝점을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="464c371fe5c52f8be936613abf4678c4f4b05d39" translate="yes" xml:space="preserve">
          <source>Whether to enable the metrics endpoint.</source>
          <target state="translated">메트릭 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="de3c7efbddeac448b72479c227b912b1d3a626eb" translate="yes" xml:space="preserve">
          <source>Whether to enable the prometheus endpoint.</source>
          <target state="translated">prometheus 엔드 포인트를 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="285fd7419feb58aea37998e85e9eb6b597ed9ad7" translate="yes" xml:space="preserve">
          <source>Whether to enable the scheduledtasks endpoint.</source>
          <target state="translated">예약 된 작업 끝점을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8a8438c9dac10ff652b6d2cd65b9d0507be44e0f" translate="yes" xml:space="preserve">
          <source>Whether to enable the sessions endpoint.</source>
          <target state="translated">세션 엔드 포인트를 사용할지 여부.</target>
        </trans-unit>
        <trans-unit id="bf110aec40deb5ab4906afa8c0af64eb1b0e5ec7" translate="yes" xml:space="preserve">
          <source>Whether to enable the shutdown endpoint.</source>
          <target state="translated">종료 엔드 포인트를 사용할지 여부.</target>
        </trans-unit>
        <trans-unit id="53aebcdae163f498f6a78f8298f7a58d5f7309c0" translate="yes" xml:space="preserve">
          <source>Whether to enable the startup endpoint.</source>
          <target state="translated">시작 엔드 포인트 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="dcdc35d9b769834985ae792b81ea509a7e4c4067" translate="yes" xml:space="preserve">
          <source>Whether to enable the threaddump endpoint.</source>
          <target state="translated">스레드 덤프 엔드 포인트를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="90e25583f40760d9340e0043b26a19d2b702ccae" translate="yes" xml:space="preserve">
          <source>Whether to enable trace output.</source>
          <target state="translated">추적 출력 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="41047f4f4f75d1b1debbff37a9986f0a6a4b0ba2" translate="yes" xml:space="preserve">
          <source>Whether to enable warn logging of exceptions resolved by a &quot;HandlerExceptionResolver&quot;, except for &quot;DefaultHandlerExceptionResolver&quot;.</source>
          <target state="translated">&quot;DefaultHandlerExceptionResolver&quot;를 제외하고 &quot;HandlerExceptionResolver&quot;에 의해 해결 된 예외의 경고 로깅을 활성화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ffbc01837e197768b12ba403aa4e9bfa1d225eee" translate="yes" xml:space="preserve">
          <source>Whether to exclude all fields from consideration for serialization or deserialization that do not have the &quot;Expose&quot; annotation.</source>
          <target state="translated">&quot;Expose&quot;주석이없는 직렬화 또는 역 직렬화 고려에서 모든 필드를 제외할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d7bb8f9ddc323ef1516a7845e0be58d3ee5b7e93" translate="yes" xml:space="preserve">
          <source>Whether to exclude inner classes during serialization.</source>
          <target state="translated">직렬화 중에 내부 클래스를 제외할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0d012f7e17272da2bf2309f4a3f7c14a072ffa74" translate="yes" xml:space="preserve">
          <source>Whether to expose a RequestContext for use by Spring's macro library, under the name &quot;springMacroRequestContext&quot;.</source>
          <target state="translated">&quot;springMacroRequestContext&quot;라는 이름으로 Spring의 매크로 라이브러리에서 사용할 RequestContext를 노출할지 여부.</target>
        </trans-unit>
        <trans-unit id="329ab47b8a8353d6e0b649c7fd36d30336180366" translate="yes" xml:space="preserve">
          <source>Whether to expose and assume 1-based page number indexes. Defaults to &quot;false&quot;, meaning a page number of 0 in the request equals the first page.</source>
          <target state="translated">1 기반 페이지 번호 인덱스를 노출하고 가정할지 여부입니다. 기본값은 &quot;false&quot;이며 요청의 페이지 번호 0이 첫 번째 페이지와 동일 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="98fab74174fd6a8e397fe04382b37520c8e5b082" translate="yes" xml:space="preserve">
          <source>Whether to fail fast if the broker is not available on startup.</source>
          <target state="translated">시작시 브로커를 사용할 수없는 경우 빠르게 실패할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="fd871aafb968ce14268209a901263498c18b4a34" translate="yes" xml:space="preserve">
          <source>Whether to fail if the queues declared by the container are not available on the broker and/or whether to stop the container if one or more queues are deleted at runtime.</source>
          <target state="translated">컨테이너가 선언 한 큐를 브로커에서 사용할 수없는 경우 실패할지 여부 및 / 또는 런타임에 하나 이상의 큐가 삭제 된 경우 컨테이너를 중지할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e7d4a8ce0696431044fb905fe51871bdee2956c5" translate="yes" xml:space="preserve">
          <source>Whether to fail if the queues declared by the container are not available on the broker.</source>
          <target state="translated">컨테이너가 선언 한 큐를 브로커에서 사용할 수없는 경우 실패할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1c3bdb221c9290c06581cd8bb0aade09cdcdc53d" translate="yes" xml:space="preserve">
          <source>Whether to fall back to the system Locale if no files for a specific Locale have been found. if this is turned off, the only fallback will be the default file (e.g. &quot;messages.properties&quot; for basename &quot;messages&quot;).</source>
          <target state="translated">특정 로케일에 대한 파일이 발견되지 않은 경우 시스템 로케일로 폴백할지 여부입니다. 이 기능이 꺼져 있으면 유일한 폴백은 기본 파일 (예 : 기본 이름 &quot;messages&quot;의 &quot;messages.properties&quot;)이됩니다.</target>
        </trans-unit>
        <trans-unit id="5f2e2dc024c882704d55a5afdf4e7e97390e5fce" translate="yes" xml:space="preserve">
          <source>Whether to first drop the database schema.</source>
          <target state="translated">데이터베이스 스키마를 먼저 삭제할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a8ecf95c5a8cb92ab343ff185724909cf96859de" translate="yes" xml:space="preserve">
          <source>Whether to generate a random database name. Ignore any configured name when enabled.</source>
          <target state="translated">임의의 데이터베이스 이름을 생성할지 여부입니다. 활성화되면 구성된 이름을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="14f41d49d13c6060d23c74ac941914db7e6b9db8" translate="yes" xml:space="preserve">
          <source>Whether to generate a random datasource name.</source>
          <target state="translated">임의의 데이터 소스 이름을 생성할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="971d0e30891f6153f5e4efdc5f2e0dd245ecb4c2" translate="yes" xml:space="preserve">
          <source>Whether to generate non executable JSON by prefixing the output with some special text.</source>
          <target state="translated">출력 앞에 특수 텍스트를 추가하여 실행 불가능한 JSON을 생성할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ffa5185f6cd6280dfb03fa9bcf1540b80393137a" translate="yes" xml:space="preserve">
          <source>Whether to group all pending migrations together in the same transaction when applying them.</source>
          <target state="translated">모든 보류중인 마이그레이션을 적용 할 때 동일한 트랜잭션에서 함께 그룹화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="48be1796e6c707da145ab3bae3785c1956a09bf5" translate="yes" xml:space="preserve">
          <source>Whether to handle message mapping for RSocket via Spring Integration.</source>
          <target state="translated">Spring Integration을 통해 RSocket에 대한 메시지 매핑을 처리할지 여부.</target>
        </trans-unit>
        <trans-unit id="766a3110e86aa212fdfd8fe1fb9ee0ec5ee946d5" translate="yes" xml:space="preserve">
          <source>Whether to ignore AbstractRoutingDataSources when creating database health indicators.</source>
          <target state="translated">데이터베이스 상태 표시기를 작성할 때 AbstractRoutingDataSources를 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="3f70d244ad0d582ec29d8581e200881e0b9740df" translate="yes" xml:space="preserve">
          <source>Whether to ignore future migrations when reading the schema history table.</source>
          <target state="translated">스키마 히스토리 테이블을 읽을 때 향후 마이그레이션을 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="08547cac3ecf72e7cef7321f0bb7ebe7a3fedc1c" translate="yes" xml:space="preserve">
          <source>Whether to ignore ignored migrations when reading the schema history table.</source>
          <target state="translated">스키마 히스토리 테이블을 읽을 때 무시 된 마이그레이션을 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="318bb0ac9550d0bd1cd74c444b2bb8d74c00eaa6" translate="yes" xml:space="preserve">
          <source>Whether to ignore missing migrations when reading the schema history table.</source>
          <target state="translated">스키마 히스토리 테이블을 읽을 때 누락 된 마이그레이션을 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="42c717b77daec9be539d958901299a24be0e7d22" translate="yes" xml:space="preserve">
          <source>Whether to ignore pending migrations when reading the schema history table.</source>
          <target state="translated">스키마 히스토리 테이블을 읽을 때 보류중인 마이그레이션을 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c73f358d61f99c7b60f3b5a2581d7ec2586e08b0" translate="yes" xml:space="preserve">
          <source>Whether to ignore the transacted flag when creating session.</source>
          <target state="translated">세션 생성시 트랜잭션 플래그를 무시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="18340225e63f911d84191a29ec7a5598fba98f3c" translate="yes" xml:space="preserve">
          <source>Whether to initialize the schema on startup.</source>
          <target state="translated">시작시 스키마를 초기화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="67150a7a7b039c24e43f47bae5bbb7ec10aba8d7" translate="yes" xml:space="preserve">
          <source>Whether to issue a warning rather than an error when a not-yet-supported Oracle SQL*Plus statement is encountered. Requires Flyway Teams.</source>
          <target state="translated">아직 지원되지 않는 Oracle SQL * Plus 문이 발견 될 때 오류가 아닌 경고를 발행할지 여부입니다. Flyway 팀이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b1b97ba993632774867122ad1dc9f1bb667acf43" translate="yes" xml:space="preserve">
          <source>Whether to log form data at DEBUG level, and headers at TRACE level.</source>
          <target state="translated">DEBUG 수준에서 양식 데이터를 기록하고 TRACE 수준에서 헤더를 기록할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="62b1553ab6c4fe05f5d00bd8f13b47c91f6157a5" translate="yes" xml:space="preserve">
          <source>Whether to log information about the application when it starts.</source>
          <target state="translated">시작할 때 애플리케이션에 대한 정보를 기록할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="53aed1e80c9f370da80be15b39c46bf666c92847" translate="yes" xml:space="preserve">
          <source>Whether to log leaked sessions.</source>
          <target state="translated">유출 된 세션을 기록할지 여부.</target>
        </trans-unit>
        <trans-unit id="23fd15ba3469f8e42f6c3a8cd9c3c07530551b58" translate="yes" xml:space="preserve">
          <source>Whether to log the condition evaluation delta upon restart.</source>
          <target state="translated">재시작시 조건 평가 델타를 기록할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="a3cf61568e67a2d367c0e7575d087b95de8083d1" translate="yes" xml:space="preserve">
          <source>Whether to log the container configuration during initialization (INFO level).</source>
          <target state="translated">초기화 중 컨테이너 구성을 기록할지 여부 (INFO 수준).</target>
        </trans-unit>
        <trans-unit id="218b6d2ba6b64e550f072c272583b094d86f55d3" translate="yes" xml:space="preserve">
          <source>Whether to output serialized JSON that fits in a page for pretty printing.</source>
          <target state="translated">예쁜 인쇄를 위해 페이지에 맞는 직렬화 된 JSON을 출력할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="250b140ef0abb4621c34bed5e4e162a2f13e5fa9" translate="yes" xml:space="preserve">
          <source>Whether to persist session data between restarts.</source>
          <target state="translated">재시작 사이에 세션 데이터를 유지할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="56184683d375f8988f31061c1c8701f78aa9ae2a" translate="yes" xml:space="preserve">
          <source>Whether to prefer file system access for template loading to enable hot detection of template changes. When a template path is detected as a directory, templates are loaded from the directory only and other matching classpath locations will not be considered.</source>
          <target state="translated">템플릿 변경 사항을 즉시 감지 할 수 있도록 템플릿로드시 파일 시스템 액세스를 선호할지 여부입니다. 템플릿 경로가 디렉토리로 감지되면 템플릿은 디렉토리에서만로드되며 일치하는 다른 클래스 경로 위치는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5c51f4623382109cca509b8459a0fc0e5ba8525" translate="yes" xml:space="preserve">
          <source>Whether to preserve the path of a request when it is forwarded.</source>
          <target state="translated">요청이 전달 될 때 경로를 보존할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="c798d78c8dfb45dd046f090015c4970bca8119f5" translate="yes" xml:space="preserve">
          <source>Whether to publish a ServletRequestHandledEvent at the end of each request.</source>
          <target state="translated">각 요청의 끝에 ServletRequestHandledEvent를 게시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="75fdbb97548463e4556ad536155ccb08b28e6bb3" translate="yes" xml:space="preserve">
          <source>Whether to publish a histogram suitable for computing aggregable (across dimension) percentile approximations.</source>
          <target state="translated">집계 가능한 (차원 간) 백분위 수 근사치를 계산하는 데 적합한 히스토그램을 게시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="0cc67c23fd8e7fffd5ed5c98cb83dc3e50f51b47" translate="yes" xml:space="preserve">
          <source>Whether to publish descriptions metadata to Datadog. Turn this off to minimize the amount of metadata sent.</source>
          <target state="translated">설명 메타 데이터를 Datadog에 게시할지 여부입니다. 전송되는 메타 데이터의 양을 최소화하려면이 옵션을 끄십시오.</target>
        </trans-unit>
        <trans-unit id="709ef5dcca684a34ddcf783bd12a3a803074637e" translate="yes" xml:space="preserve">
          <source>Whether to register the default Servlet with the container.</source>
          <target state="translated">컨테이너에 기본 서블릿을 등록할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="4fcd32cb3d1e4bc637f12e92d4ce6b936285aa5d" translate="yes" xml:space="preserve">
          <source>Whether to resolve the multipart request lazily at the time of file or parameter access.</source>
          <target state="translated">파일 또는 매개 변수 액세스시 멀티 파트 요청을 느리게 해결할지 여부.</target>
        </trans-unit>
        <trans-unit id="69ff86b02998e02d637561b96cfa35681c58d9b3" translate="yes" xml:space="preserve">
          <source>Whether to return a response body after creating an entity.</source>
          <target state="translated">엔터티를 만든 후 응답 본문을 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7bde89a363a749be39e6aadd27686c6631294ce2" translate="yes" xml:space="preserve">
          <source>Whether to return a response body after updating an entity.</source>
          <target state="translated">항목을 업데이트 한 후 응답 본문을 반환할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7628c0f4429f8962f9444842a2855b8efce596eb" translate="yes" xml:space="preserve">
          <source>Whether to roll back on commit failures.</source>
          <target state="translated">커밋 실패시 롤백할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1c5fe42c6ee9e6fb5910b2a8338c672326c8ec52" translate="yes" xml:space="preserve">
          <source>Whether to send the meter name as the event type instead of using the 'event-type' configuration property value. Can be set to 'true' if New Relic guidelines are not being followed or event types consistent with previous Spring Boot releases are required.</source>
          <target state="translated">'event-type'구성 속성 값을 사용하는 대신 미터 이름을 이벤트 유형으로 보낼지 여부입니다. New Relic 지침을 따르지 않거나 이전 Spring Boot 릴리스와 일치하는 이벤트 유형이 필요한 경우 'true'로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f10c989f93883de289871bea6a27fcf51bfd1a9" translate="yes" xml:space="preserve">
          <source>Whether to send unchanged meters to the StatsD server.</source>
          <target state="translated">변경되지 않은 미터를 StatsD 서버로 보낼지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="e0d15cbe8da4ea85d7b400d111a36ea65c47b0cb" translate="yes" xml:space="preserve">
          <source>Whether to serialize null fields.</source>
          <target state="translated">null 필드를 직렬화할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="00158dc0fa439272a473b514c75205bc95dfd674" translate="yes" xml:space="preserve">
          <source>Whether to ship a floored time, useful when sending measurements from multiple hosts to align them on a given time boundary.</source>
          <target state="translated">지정된 시간 경계에 정렬하기 위해 여러 호스트에서 측정 값을 보낼 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5ee7484570edbfadc247e9c13387490be83160ea" translate="yes" xml:space="preserve">
          <source>Whether to skip SSL verification for Cloud Foundry actuator endpoint security calls.</source>
          <target state="translated">Cloud Foundry 액추에이터 엔드 포인트 보안 호출에 대한 SSL 확인을 건너 뛸지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="9b999b979a3e45c95822a67eeacc47ecad8e0051" translate="yes" xml:space="preserve">
          <source>Whether to skip default callbacks. If true, only custom callbacks are used.</source>
          <target state="translated">기본 콜백을 건너 뛸지 여부입니다. true 인 경우 사용자 지정 콜백 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8eefebacf9a3d139b1df79a30c79cc021bfaaf1b" translate="yes" xml:space="preserve">
          <source>Whether to skip default resolvers. If true, only custom resolvers are used.</source>
          <target state="translated">기본 해석기를 건너 뛸지 여부입니다. true 인 경우 사용자 지정 해결 프로그램 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="90a7f4ee0dc2b3b6bd1722b97e14733f3ed0f6d1" translate="yes" xml:space="preserve">
          <source>Whether to skip search of BeanInfo classes.</source>
          <target state="translated">BeanInfo 클래스 검색 건너 뛰기 여부.</target>
        </trans-unit>
        <trans-unit id="885db1a8e8d2d9a65648275070164a3fbc1b2690" translate="yes" xml:space="preserve">
          <source>Whether to start the container automatically on startup.</source>
          <target state="translated">시작시 컨테이너를 자동으로 시작할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="5c09f2b6bcea32c315e16dd0cdcd2cf6e38d3b46" translate="yes" xml:space="preserve">
          <source>Whether to stop if an error occurs while initializing the database.</source>
          <target state="translated">데이터베이스 초기화 중 오류 발생시 중지 여부.</target>
        </trans-unit>
        <trans-unit id="5addeb5b76d28d62bbdce4f189efcdccc9b5e430" translate="yes" xml:space="preserve">
          <source>Whether to stop message delivery before re-delivering messages from a rolled back transaction. This implies that message order is not preserved when this is enabled.</source>
          <target state="translated">롤백 된 트랜잭션에서 메시지를 다시 배달하기 전에 메시지 배달을 중지할지 여부입니다. 이것은 이것이 사용 가능할 때 메시지 순서가 보존되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f3f9c2235f64c577befcd16820f5aa9f96f56703" translate="yes" xml:space="preserve">
          <source>Whether to stream SQL migrations when executing them. Requires Flyway Teams.</source>
          <target state="translated">SQL 마이그레이션을 실행할 때 스트리밍할지 여부입니다. Flyway 팀이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="df29a2c71cbd0d9d70dff3ee4fad0d6e674b7cf0" translate="yes" xml:space="preserve">
          <source>Whether to test that the mail server is available on startup.</source>
          <target state="translated">시작시 메일 서버를 사용할 수 있는지 테스트할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="7b88b092435953883356a2156da1a554a06a4cd7" translate="yes" xml:space="preserve">
          <source>Whether to transparently migrate legacy endpoint IDs.</source>
          <target state="translated">레거시 엔드 포인트 ID를 투명하게 마이그레이션할지 여부.</target>
        </trans-unit>
        <trans-unit id="7088d140f2e7247b80bccf5a32ed5b1536d8e620" translate="yes" xml:space="preserve">
          <source>Whether to trust all packages.</source>
          <target state="translated">모든 패키지를 신뢰할지 여부.</target>
        </trans-unit>
        <trans-unit id="6c22d6bf6290524191f56350ab92bf64e8541c2e" translate="yes" xml:space="preserve">
          <source>Whether to use &quot;HttpOnly&quot; cookies for session cookies.</source>
          <target state="translated">세션 쿠키에 &quot;HttpOnly&quot;쿠키를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="29f9f06bffe59e3ca138d9822631f7a5210709b0" translate="yes" xml:space="preserve">
          <source>Whether to use Hibernate's newer IdentifierGenerator for AUTO, TABLE and SEQUENCE. This is actually a shortcut for the &quot;hibernate.id.new_generator_mappings&quot; property. When not specified will default to &quot;true&quot;.</source>
          <target state="translated">AUTO, TABLE 및 SEQUENCE에 대해 Hibernate의 새로운 IdentifierGenerator를 사용할지 여부. 이것은 실제로 &quot;hibernate.id.new_generator_mappings&quot;속성의 단축키입니다. 지정하지 않으면 기본값은 &quot;true&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="d1c42744a7fd78f639423cd2e83f5f22119d631c" translate="yes" xml:space="preserve">
          <source>Whether to use IPv6 canonical representation format as defined by RFC 5952.</source>
          <target state="translated">RFC 5952에 정의 된대로 IPv6 표준 표현 형식을 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="634692588b7241bea7be2388ce2d41d2a8851a13" translate="yes" xml:space="preserve">
          <source>Whether to use concurrent connection validation.</source>
          <target state="translated">동시 연결 유효성 검사를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="45c7099060673c68f0d5148b8473114f391d2147" translate="yes" xml:space="preserve">
          <source>Whether to use different (and concurrent) threads for two-phase commit on the participating resources.</source>
          <target state="translated">참여 자원에 대한 2 단계 커미트에 다른 (및 동시) 스레드를 사용할지 여부.</target>
        </trans-unit>
        <trans-unit id="aecc32ce1fe09e15328c3a69bd375fc8360abc7b" translate="yes" xml:space="preserve">
          <source>Whether to use only one anonymous &quot;MessageProducer&quot; instance. Set it to false to create one &quot;MessageProducer&quot; every time one is required.</source>
          <target state="translated">하나의 익명 &quot;MessageProducer&quot;인스턴스 만 사용할지 여부입니다. &quot;MessageProducer&quot;가 필요할 때마다 하나를 작성하려면 false로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f852251f75fe16b5f96d7ba41193cd964ecf8446" translate="yes" xml:space="preserve">
          <source>Whether to use the key prefix when writing to Redis.</source>
          <target state="translated">Redis에 쓸 때 키 접두사를 사용할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="12acb4440e2a34feae775591e335f6972cc06f6b" translate="yes" xml:space="preserve">
          <source>Whether to use the message code as the default message instead of throwing a &quot;NoSuchMessageException&quot;. Recommended during development only.</source>
          <target state="translated">&quot;NoSuchMessageException&quot;을 발생시키는 대신 메시지 코드를 기본 메시지로 사용할지 여부입니다. 개발 중에 만 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d720e95f290398cf2968a2571425c4f64d47e719" translate="yes" xml:space="preserve">
          <source>Whether to validate headers when decoding requests.</source>
          <target state="translated">요청을 디코딩 할 때 헤더의 유효성을 검사할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="ff2503980c311f4cd6c6de3b020b4180e664781c" translate="yes" xml:space="preserve">
          <source>Whether to validate migrations and callbacks whose scripts do not obey the correct naming convention.</source>
          <target state="translated">스크립트가 올바른 이름 지정 규칙을 따르지 않는 마이그레이션 및 콜백의 유효성을 검사할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="8b3e8531898adb44ebb0b973ba1b929f507e2cc9" translate="yes" xml:space="preserve">
          <source>Whether to wait for running jobs to complete on shutdown.</source>
          <target state="translated">종료시 실행중인 작업이 완료 될 때까지 대기할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="bdfbdb3bf1bc4fdf7defc33636e4dd6f01ce91fc" translate="yes" xml:space="preserve">
          <source>Whether unique runtime object names should be ensured.</source>
          <target state="translated">고유 한 런타임 개체 이름을 보장해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="be133b7298c42d06fb70b69c6c694fe87566bbb2" translate="yes" xml:space="preserve">
          <source>Whether we should use the &quot;lastModified&quot; metadata of the files in HTTP caching headers.</source>
          <target state="translated">HTTP 캐싱 헤더에서 파일의 &quot;lastModified&quot;메타 데이터를 사용해야하는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="16a41ba1833d12bffb573e9e57abc25e34d85534" translate="yes" xml:space="preserve">
          <source>Whether, in the absence of any other exporter, exporting of metrics to an in-memory backend is enabled.</source>
          <target state="translated">다른 내보내기가없는 경우 메모리 내 백엔드로 메트릭 내보내기가 활성화되었는지 여부.</target>
        </trans-unit>
        <trans-unit id="443ca577d33f8ec2a869ba67b470b08762120426" translate="yes" xml:space="preserve">
          <source>While Spring&amp;rsquo;s test framework caches application contexts between tests and reuses a context for tests sharing the same configuration, the use of &lt;code&gt;@MockBean&lt;/code&gt; or &lt;code&gt;@SpyBean&lt;/code&gt; influences the cache key, which will most likely increase the number of contexts.</source>
          <target state="translated">Spring의 테스트 프레임 워크는 테스트간에 애플리케이션 컨텍스트를 캐시하고 동일한 구성을 공유하는 테스트를 위해 컨텍스트를 재사용하지만 &lt;code&gt;@MockBean&lt;/code&gt; 또는 &lt;code&gt;@SpyBean&lt;/code&gt; 을 사용하면 캐시 키에 영향을 미치므로 컨텍스트 수가 증가 할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="9fd0400962e95219b3c323445d98b60b4eb5ed76" translate="yes" xml:space="preserve">
          <source>While caching is very beneficial in production, it can be counter-productive during development, preventing you from seeing the changes you just made in your application. For this reason, spring-boot-devtools disables the caching options by default.</source>
          <target state="translated">캐싱은 프로덕션에서 매우 유용하지만 개발 중에는 비생산적 일 수 있으므로 방금 애플리케이션에서 변경 한 내용을 볼 수 없습니다. 이러한 이유로 spring-boot-devtools는 기본적으로 캐싱 옵션을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="75a052aa9f274cecf932e1d20ead1f18d5b227a6" translate="yes" xml:space="preserve">
          <source>While it is possible to use JUnit 4 to test Kotlin code, JUnit 5 is provided by default and is recommended. JUnit 5 enables a test class to be instantiated once and reused for all of the class&amp;rsquo;s tests. This makes it possible to use &lt;code&gt;@BeforeAll&lt;/code&gt; and &lt;code&gt;@AfterAll&lt;/code&gt; annotations on non-static methods, which is a good fit for Kotlin.</source>
          <target state="translated">JUnit 4를 사용하여 Kotlin 코드를 테스트 할 수 있지만 JUnit 5가 기본적으로 제공되며 권장됩니다. JUnit 5를 사용하면 테스트 클래스를 한 번 인스턴스화하고 클래스의 모든 테스트에 재사용 할 수 있습니다. 이를 통해 비 정적 메서드에서 &lt;code&gt;@BeforeAll&lt;/code&gt; 및 &lt;code&gt;@AfterAll&lt;/code&gt; 주석 을 사용할 수 있으며 이는 Kotlin에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="4d6335f35800e3639e43a575ab1b7af85a762995" translate="yes" xml:space="preserve">
          <source>While using &lt;code&gt;@PropertySource&lt;/code&gt; on your &lt;code&gt;@SpringBootApplication&lt;/code&gt; may seem to be a convenient way to load a custom resource in the &lt;code&gt;Environment&lt;/code&gt;, we do not recommend it. Such property sources are not added to the &lt;code&gt;Environment&lt;/code&gt; until the application context is being refreshed. This is too late to configure certain properties such as &lt;code&gt;logging.*&lt;/code&gt; and &lt;code&gt;spring.main.*&lt;/code&gt; which are read before refresh begins.</source>
          <target state="translated">&lt;code&gt;@SpringBootApplication&lt;/code&gt; 에서 &lt;code&gt;@PropertySource&lt;/code&gt; 를 사용 하는 것이 &lt;code&gt;Environment&lt;/code&gt; 에서 사용자 지정 리소스를로드하는 편리한 방법 인 것처럼 보일 수 있지만 권장하지 않습니다. 이러한 속성 소스는 애플리케이션 컨텍스트를 새로 고칠 때까지 &lt;code&gt;Environment&lt;/code&gt; 추가되지 않습니다 . 새로 고침이 시작되기 전에 읽는 &lt;code&gt;logging.*&lt;/code&gt; 및 &lt;code&gt;spring.main.*&lt;/code&gt; 와 같은 특정 속성을 구성하기에는 너무 늦었습니다 .</target>
        </trans-unit>
        <trans-unit id="34af3995adf0544ac3c504c1e616abc37ede93f9" translate="yes" xml:space="preserve">
          <source>While you can write a &lt;code&gt;SpEL&lt;/code&gt; expression in &lt;code&gt;@Value&lt;/code&gt;, such expressions are not processed from &lt;a href=&quot;#boot-features-external-config-files&quot;&gt;application property files&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;@Value&lt;/code&gt; 에 &lt;code&gt;SpEL&lt;/code&gt; 식을 작성할 수 있지만 이러한 식은 &lt;a href=&quot;#boot-features-external-config-files&quot;&gt;응용 프로그램 속성 파일&lt;/a&gt; 에서 처리되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b1b7f131a7112f9cc2fa73a30dcf4c0f661e80fe" translate="yes" xml:space="preserve">
          <source>Width of the banner image in chars.</source>
          <target state="translated">배너 이미지의 너비 (문자)입니다.</target>
        </trans-unit>
        <trans-unit id="67e465aac7b8f742b1785e6c20a05ea753b7f19a" translate="yes" xml:space="preserve">
          <source>Wildcard locations only work with external directories. You cannot use a wildcard in a &lt;code&gt;classpath:&lt;/code&gt; location.</source>
          <target state="translated">와일드 카드 위치는 외부 디렉토리에서만 작동합니다. &lt;code&gt;classpath:&lt;/code&gt; 위치 에는 와일드 카드를 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eadf42673bc7da6d0e5b5f372c95a6e937b88796" translate="yes" xml:space="preserve">
          <source>With Cloud Native Buildpacks, you can create Docker compatible images that you can run anywhere. Spring Boot includes buildpack support directly for both Maven and Gradle. This means you can just type a single command and quickly get a sensible image into your locally running Docker daemon.</source>
          <target state="translated">Cloud Native Buildpack을 사용하면 어디서나 실행할 수있는 Docker 호환 이미지를 만들 수 있습니다. Spring Boot에는 Maven과 Gradle 모두에 대한 빌드 팩 지원이 포함되어 있습니다. 즉, 단일 명령을 입력하기 만하면 로컬에서 실행중인 Docker 데몬으로 빠르게 이미지를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d7cb7b91a1bf62c7c3bb03ae6c2a54dfce73a9" translate="yes" xml:space="preserve">
          <source>With Gradle 4.5 and earlier, the dependency should be declared in the &lt;code&gt;compileOnly&lt;/code&gt; configuration, as shown in the following example:</source>
          <target state="translated">Gradle 4.5 이하 에서는 다음 예제와 같이 &lt;code&gt;compileOnly&lt;/code&gt; 구성 에서 종속성을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fc23501b952a1643f7009a9158e57929c8027f4" translate="yes" xml:space="preserve">
          <source>With Gradle 4.6 and later, the dependency should be declared in the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration, as shown in the following example:</source>
          <target state="translated">Gradle 4.6 이상 에서는 다음 예와 같이 &lt;code&gt;annotationProcessor&lt;/code&gt; 구성 에서 종속성을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7dc3a8898217656b1e2af1588012c2a758998ef1" translate="yes" xml:space="preserve">
          <source>With Gradle, the dependency should be declared in the &lt;code&gt;annotationProcessor&lt;/code&gt; configuration, as shown in the following example:</source>
          <target state="translated">Gradle을 사용 하면 다음 예제와 같이 &lt;code&gt;annotationProcessor&lt;/code&gt; 구성 에서 종속성을 선언해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c147159e2f31f0f2b08bf57b738603f8b75f5a7d" translate="yes" xml:space="preserve">
          <source>With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with &lt;code&gt;java -jar&lt;/code&gt;, and will also be deployable to any standard container. JSPs are not supported when using an executable jar.</source>
          <target state="translated">Jetty와 Tomcat을 사용하면 전쟁 패키징을 사용하면 작동합니다. 실행 가능한 전쟁은 &lt;code&gt;java -jar&lt;/code&gt; 로 시작될 때 작동 하며 모든 표준 컨테이너에도 배포 할 수 있습니다. JSP는 실행 가능한 jar를 사용할 때 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="916ef3e925289eeb70d4853dd4e27d373f6a6cde" translate="yes" xml:space="preserve">
          <source>With Maven the dependency should be declared as optional, as shown in the following example:</source>
          <target state="translated">Maven에서는 다음 예제와 같이 종속성을 선택 사항으로 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1759c3fbf33e3a7db068cc2b5c7469e3e267875" translate="yes" xml:space="preserve">
          <source>With Maven, the Kotlin version can be customized via the &lt;code&gt;kotlin.version&lt;/code&gt; property and plugin management is provided for &lt;code&gt;kotlin-maven-plugin&lt;/code&gt;. With Gradle, the Spring Boot plugin automatically aligns the &lt;code&gt;kotlin.version&lt;/code&gt; with the version of the Kotlin plugin.</source>
          <target state="translated">Maven을 사용하면 &lt;code&gt;kotlin.version&lt;/code&gt; 속성을 통해 Kotlin 버전을 맞춤 설정할 수 있으며 &lt;code&gt;kotlin-maven-plugin&lt;/code&gt; 에 대한 플러그인 관리가 제공됩니다 . Gradle을 사용하면 Spring Boot 플러그인이 &lt;code&gt;kotlin.version&lt;/code&gt; 을 Kotlin 플러그인 버전과 자동으로 정렬합니다 .</target>
        </trans-unit>
        <trans-unit id="190df6e46204253cf38a377f73433482f343ee94" translate="yes" xml:space="preserve">
          <source>With that setup, migrations in &lt;code&gt;dev/db/migration&lt;/code&gt; run only when the &lt;code&gt;dev&lt;/code&gt; profile is active.</source>
          <target state="translated">이 설정을 사용하면 &lt;code&gt;dev/db/migration&lt;/code&gt; 의 마이그레이션 은 &lt;code&gt;dev&lt;/code&gt; 프로필이 활성화 된 경우에만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="06c4865f9ce04767e8a0882f6cba03a509a11a41" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;JARFILE&lt;/code&gt; and &lt;code&gt;APP_NAME&lt;/code&gt;, the settings listed in the preceding section can be configured by using a &lt;code&gt;.conf&lt;/code&gt; file. The file is expected to be next to the jar file and have the same name but suffixed with &lt;code&gt;.conf&lt;/code&gt; rather than &lt;code&gt;.jar&lt;/code&gt;. For example, a jar named &lt;code&gt;/var/myapp/myapp.jar&lt;/code&gt; uses the configuration file named &lt;code&gt;/var/myapp/myapp.conf&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;JARFILE&lt;/code&gt; 및 &lt;code&gt;APP_NAME&lt;/code&gt; 을 제외 하고 이전 섹션에 나열된 설정은 &lt;code&gt;.conf&lt;/code&gt; 파일 을 사용하여 구성 할 수 있습니다 . 파일은 jar 파일 옆에있을 것으로 예상되며 이름은 동일하지만 &lt;code&gt;.jar&lt;/code&gt; 이 아닌 &lt;code&gt;.conf&lt;/code&gt; 접미사가 붙습니다 . 예를 들어, &lt;code&gt;/var/myapp/myapp.jar&lt;/code&gt; 라는 jar 는 다음 예제와 같이 &lt;code&gt;/var/myapp/myapp.conf&lt;/code&gt; 라는 구성 파일을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6d64c05c1c871c6d9ce671337fb016ba77550215" translate="yes" xml:space="preserve">
          <source>With the preceding code, the following properties names can all be used:</source>
          <target state="translated">앞의 코드에서는 다음 속성 이름을 모두 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ca88b341681bd0c249196bf349292b510c54e2" translate="yes" xml:space="preserve">
          <source>With this configuration, JavaScript modules located under &lt;code&gt;&quot;/js/lib/&quot;&lt;/code&gt; use a fixed versioning strategy (&lt;code&gt;&quot;/v12/js/lib/mymodule.js&quot;&lt;/code&gt;), while other resources still use the content one (&lt;code&gt;&amp;lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">이 구성에서 &lt;code&gt;&quot;/js/lib/&quot;&lt;/code&gt; 아래에있는 JavaScript 모듈 은 고정 된 버전 관리 전략 ( &lt;code&gt;&quot;/v12/js/lib/mymodule.js&quot;&lt;/code&gt; )을 사용하는 반면 다른 리소스는 여전히 콘텐츠 하나 ( &lt;code&gt;&amp;lt;link href=&quot;/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css&quot;/&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="554f001599eb3810dd8a4b949e5b33b556ec2110" translate="yes" xml:space="preserve">
          <source>Write consistency for each point.</source>
          <target state="translated">각 포인트에 대한 쓰기 일관성.</target>
        </trans-unit>
        <trans-unit id="ff6df66ddd66cea94af9573c8ec1fa4d44305eee" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;spring.log&lt;/code&gt; to the specified directory. Names can be an exact location or relative to the current directory.</source>
          <target state="translated">&lt;code&gt;spring.log&lt;/code&gt; 를 지정된 디렉토리에 씁니다 . 이름은 정확한 위치이거나 현재 디렉토리에 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2403929d240119c74ece4bba63dbd47e0a053a68" translate="yes" xml:space="preserve">
          <source>Writes console logs to &lt;code&gt;/var/log/&amp;lt;appname&amp;gt;.log&lt;/code&gt;</source>
          <target state="translated">콘솔 로그를 &lt;code&gt;/var/log/&amp;lt;appname&amp;gt;.log&lt;/code&gt; 에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="248b92f3878e62e55a6bf7f23faf4f59aff3d101" translate="yes" xml:space="preserve">
          <source>Writes to the specified log file. Names can be an exact location or relative to the current directory.</source>
          <target state="translated">지정된 로그 파일에 기록합니다. 이름은 정확한 위치이거나 현재 디렉토리에 상대적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85ece886b0e43b4b015a03ddc42c6f0a49057731" translate="yes" xml:space="preserve">
          <source>XA datasource fully qualified name.</source>
          <target state="translated">XA 데이터 소스 완전한 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ffbcb202b09db426bae56cf2ffb88f18594f2258" translate="yes" xml:space="preserve">
          <source>YAML</source>
          <target state="translated">YAML</target>
        </trans-unit>
        <trans-unit id="a50a8ac0e2ebaf82e64080a74bcd16c4ca5c0bf8" translate="yes" xml:space="preserve">
          <source>YAML Files</source>
          <target state="translated">YAML 파일</target>
        </trans-unit>
        <trans-unit id="d04ebd1237af6a11c62145369a337aeb51a694ea" translate="yes" xml:space="preserve">
          <source>YAML documents need to be converted from their hierarchical format to a flat structure that can be used with the Spring &lt;code&gt;Environment&lt;/code&gt;. For example, consider the following YAML document:</source>
          <target state="translated">YAML 문서는 계층 적 형식에서 Spring &lt;code&gt;Environment&lt;/code&gt; 사용할 수있는 플랫 구조로 변환되어야 합니다. 예를 들어 다음 YAML 문서를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7f315f3b678b1f3762c2a2b9f519552ccf88a950" translate="yes" xml:space="preserve">
          <source>YAML files cannot be loaded by using the &lt;code&gt;@PropertySource&lt;/code&gt; annotation. So, in the case that you need to load values that way, you need to use a properties file.</source>
          <target state="translated">YAML 파일은 &lt;code&gt;@PropertySource&lt;/code&gt; 주석 을 사용하여로드 할 수 없습니다 . 따라서 이러한 방식으로 값을로드해야하는 경우 속성 파일을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="930b6a252baa9ca40cae8d3e976f4ff2d4a36143" translate="yes" xml:space="preserve">
          <source>YAML is a superset of JSON and, as such, is a convenient syntax for storing external properties in a hierarchical format, as shown in the following example:</source>
          <target state="translated">YAML은 JSON의 상위 집합이므로 다음 예제와 같이 계층 적 형식으로 외부 속성을 저장하기위한 편리한 구문입니다.</target>
        </trans-unit>
        <trans-unit id="7e28ba02652752f1a7174d03a759af2c4acd6006" translate="yes" xml:space="preserve">
          <source>Yaml</source>
          <target state="translated">Yaml</target>
        </trans-unit>
        <trans-unit id="3526f607bcd4f51ad0bc05f814579a42c2c0ba57" translate="yes" xml:space="preserve">
          <source>Yellow</source>
          <target state="translated">Yellow</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="e45013cb500539e407e1e7d1c231fa78ed4f1ade" translate="yes" xml:space="preserve">
          <source>Yes &lt;em&gt;(unless &lt;code&gt;mainclass&lt;/code&gt; is specified)&lt;/em&gt;</source>
          <target state="translated">예 &lt;em&gt;( &lt;code&gt;mainclass&lt;/code&gt; 가 지정 되지 않은 경우)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc1ee84e2dc69d7e1117f0dccd5baf938b8c3ca4" translate="yes" xml:space="preserve">
          <source>You almost always want to include one or more &lt;code&gt;@Conditional&lt;/code&gt; annotations on your auto-configuration class. The &lt;code&gt;@ConditionalOnMissingBean&lt;/code&gt; annotation is one common example that is used to allow developers to override auto-configuration if they are not happy with your defaults.</source>
          <target state="translated">거의 항상 자동 구성 클래스에 하나 이상의 &lt;code&gt;@Conditional&lt;/code&gt; 주석 을 포함하려고합니다 . &lt;code&gt;@ConditionalOnMissingBean&lt;/code&gt; 주석은 그들이 당신의 기본값에 만족하지 않은 경우 개발자가 자동 설정을 재정의 할 수 있도록하는 데 사용되는 하나의 일반적인 예이다.</target>
        </trans-unit>
        <trans-unit id="7d88e6d5d87f5f27307e584612f90ccdc79ac0d7" translate="yes" xml:space="preserve">
          <source>You also need to add &lt;code&gt;logging.file.name&lt;/code&gt; to your &lt;code&gt;application.properties&lt;/code&gt; or &lt;code&gt;application.yaml&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">또한 다음 예제와 같이 &lt;code&gt;logging.file.name&lt;/code&gt; 을 &lt;code&gt;application.properties&lt;/code&gt; 또는 &lt;code&gt;application.yaml&lt;/code&gt; 에 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="96019d4a503272da92d45dda5f8f6e0c34cc2430" translate="yes" xml:space="preserve">
          <source>You also need to include the following element inside &lt;code&gt;&amp;lt;plugins/&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">또한 &lt;code&gt;&amp;lt;plugins/&amp;gt;&lt;/code&gt; 안에 다음 요소를 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2e886b73cdd7c919e382e232879296832e77e80e" translate="yes" xml:space="preserve">
          <source>You are developing a servlet-based web application.</source>
          <target state="translated">서블릿 기반 웹 애플리케이션을 개발 중입니다.</target>
        </trans-unit>
        <trans-unit id="ee6d408334d5d6f93e09a5ca37cfd23e2db03be8" translate="yes" xml:space="preserve">
          <source>You are free to use any of the standard Spring Framework techniques to define your beans and their injected dependencies. We often find that using &lt;code&gt;@ComponentScan&lt;/code&gt; (to find your beans) and using &lt;code&gt;@Autowired&lt;/code&gt; (to do constructor injection) works well.</source>
          <target state="translated">표준 Spring Framework 기술을 자유롭게 사용하여 Bean과 삽입 된 종속성을 정의 할 수 있습니다. 우리는 종종 &lt;code&gt;@ComponentScan&lt;/code&gt; (빈을 찾기 위해)을 사용하고 &lt;code&gt;@Autowired&lt;/code&gt; (생성자 주입을 위해 )를 사용하는 것이 잘 작동 한다는 것을 종종 발견합니다 .</target>
        </trans-unit>
        <trans-unit id="5f7ae5ea9c867ced17018a42db53b95848b4d952" translate="yes" xml:space="preserve">
          <source>You are using &lt;a href=&quot;using-spring-boot#using-boot-devtools&quot;&gt;Spring Boot&amp;rsquo;s developer tools&lt;/a&gt;.</source>
          <target state="translated">당신이 사용하는 &lt;a href=&quot;using-spring-boot#using-boot-devtools&quot;&gt;봄 부츠의 개발자 도구를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2995030c1391009c3c201bcbe07d3d8a406ccfb0" translate="yes" xml:space="preserve">
          <source>You can access the port the server is running on from log output or from the &lt;code&gt;WebServerApplicationContext&lt;/code&gt; through its &lt;code&gt;WebServer&lt;/code&gt;. The best way to get that and be sure it has been initialized is to add a &lt;code&gt;@Bean&lt;/code&gt; of type &lt;code&gt;ApplicationListener&amp;lt;WebServerInitializedEvent&amp;gt;&lt;/code&gt; and pull the container out of the event when it is published.</source>
          <target state="translated">당신은 서버 로그 출력에서 또는에서 실행되는 포트에 액세스 할 수 있습니다 &lt;code&gt;WebServerApplicationContext&lt;/code&gt; 의를 통해 &lt;code&gt;WebServer&lt;/code&gt; . 이를 가져오고 초기화되었는지 확인하는 가장 좋은 방법은 &lt;code&gt;ApplicationListener&amp;lt;WebServerInitializedEvent&amp;gt;&lt;/code&gt; 유형 의 &lt;code&gt;@Bean&lt;/code&gt; 을 추가하고 게시 될 때 이벤트에서 컨테이너를 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e238d2aacad70f58573317541f831f197e470830" translate="yes" xml:space="preserve">
          <source>You can add MDC and other ad-hoc content to log lines by overriding only the &lt;code&gt;LOG_LEVEL_PATTERN&lt;/code&gt; (or &lt;code&gt;logging.pattern.level&lt;/code&gt; with Logback). For example, if you use &lt;code&gt;logging.pattern.level=user:%X{user} %5p&lt;/code&gt;, then the default log format contains an MDC entry for &quot;user&quot;, if it exists, as shown in the following example.</source>
          <target state="translated">&lt;code&gt;LOG_LEVEL_PATTERN&lt;/code&gt; (또는 Logback으로 &lt;code&gt;logging.pattern.level&lt;/code&gt; ) 만 재정 의하여 MDC 및 기타 임시 콘텐츠를 로그 줄에 추가 할 수 있습니다 . 예를 들어, &lt;code&gt;logging.pattern.level=user:%X{user} %5p&lt;/code&gt; 를 사용하는 경우 기본 로그 형식에는 다음 예와 같이 &quot;user&quot;(존재하는 경우)에 대한 MDC 항목이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="76faccefc507c595bf8b12e32db470cefdc50f06" translate="yes" xml:space="preserve">
          <source>You can add an &lt;code&gt;org.apache.catalina.connector.Connector&lt;/code&gt; to the &lt;code&gt;TomcatServletWebServerFactory&lt;/code&gt;, which can allow multiple connectors, including HTTP and HTTPS connectors, as shown in the following example:</source>
          <target state="translated">다음 예와 같이 HTTP 및 HTTPS 커넥터를 포함하여 여러 커넥터를 허용 할 수 있는 &lt;code&gt;TomcatServletWebServerFactory&lt;/code&gt; 에 &lt;code&gt;org.apache.catalina.connector.Connector&lt;/code&gt; 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0557c91096cb54050839a529fd2f04d0cd8aa675" translate="yes" xml:space="preserve">
          <source>You can add extensions to the CLI by using the &lt;code&gt;install&lt;/code&gt; command. The command takes one or more sets of artifact coordinates in the format &lt;code&gt;group:artifact:version&lt;/code&gt;, as shown in the following example:</source>
          <target state="translated">&lt;code&gt;install&lt;/code&gt; 명령 을 사용하여 CLI에 확장을 추가 할 수 있습니다 . 이 명령은 다음 예제와 같이 &lt;code&gt;group:artifact:version&lt;/code&gt; 형식의 하나 이상의 아티팩트 좌표 세트를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="c71425e5096a7df98cdd8e241aace0e7c3764181" translate="yes" xml:space="preserve">
          <source>You can also activate a listener by invoking the &lt;code&gt;SpringApplication.addListeners(&amp;hellip;​)&lt;/code&gt; method and passing the appropriate &lt;code&gt;Writer&lt;/code&gt; object. This method also lets you customize the file name and path in the &lt;code&gt;Writer&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;SpringApplication.addListeners(&amp;hellip;​)&lt;/code&gt; 메소드 를 호출 하고 적절한 &lt;code&gt;Writer&lt;/code&gt; 객체를 전달하여 리스너를 활성화 할 수도 있습니다 . 이 메서드를 사용하면 &lt;code&gt;Writer&lt;/code&gt; 생성자 에서 파일 이름과 경로를 사용자 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29438cddd0dff959a02b3317d0dd0d2f84c73c8f" translate="yes" xml:space="preserve">
          <source>You can also add a custom Spring &lt;code&gt;Validator&lt;/code&gt; by creating a bean definition called &lt;code&gt;configurationPropertiesValidator&lt;/code&gt;. The &lt;code&gt;@Bean&lt;/code&gt; method should be declared &lt;code&gt;static&lt;/code&gt;. The configuration properties validator is created very early in the application&amp;rsquo;s lifecycle, and declaring the &lt;code&gt;@Bean&lt;/code&gt; method as static lets the bean be created without having to instantiate the &lt;code&gt;@Configuration&lt;/code&gt; class. Doing so avoids any problems that may be caused by early instantiation.</source>
          <target state="translated">&lt;code&gt;configurationPropertiesValidator&lt;/code&gt; 라는 빈 정의를 생성하여 커스텀 Spring &lt;code&gt;Validator&lt;/code&gt; 를 추가 할 수도 있습니다 . &lt;code&gt;@Bean&lt;/code&gt; 메소드 선언해야 &lt;code&gt;static&lt;/code&gt; . 구성 속성 유효성 검사기는 응용 프로그램의 수명주기 초기에 생성되며 &lt;code&gt;@Bean&lt;/code&gt; 메서드를 정적으로 선언 하면 &lt;code&gt;@Configuration&lt;/code&gt; 클래스 를 인스턴스화하지 않고도 빈을 만들 수 있습니다 . 이렇게하면 초기 인스턴스화로 인해 발생할 수있는 문제를 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ea8120cd900368e8193c8a8aab0bf156d248ed3" translate="yes" xml:space="preserve">
          <source>You can also add a special &lt;code&gt;{vendor}&lt;/code&gt; placeholder to use vendor-specific scripts. Assume the following:</source>
          <target state="translated">공급 업체별 스크립트를 사용하기 위해 특별한 &lt;code&gt;{vendor}&lt;/code&gt; 자리 표시자를 추가 할 수도 있습니다 . 다음을 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="f24525cae7a91129d4361f0a7546a3d238d28a2d" translate="yes" xml:space="preserve">
          <source>You can also add any number of &lt;code&gt;tag=KEY:VALUE&lt;/code&gt; query parameters to the end of the URL to dimensionally drill down on a meter, e.g. &lt;code&gt;/actuator/metrics/jvm.memory.max?tag=area:nonheap&lt;/code&gt;.</source>
          <target state="translated">또한 URL 끝에 &lt;code&gt;tag=KEY:VALUE&lt;/code&gt; 쿼리 매개 변수를 &lt;code&gt;/actuator/metrics/jvm.memory.max?tag=area:nonheap&lt;/code&gt; 하여 측정기를 차원별로 드릴 다운 할 수 있습니다 (예 : /actuator/metrics/jvm.memory.max?tag=area:nonheap) .</target>
        </trans-unit>
        <trans-unit id="81bc3b28bc0783db1c562f779c0cb1a289cd933d" translate="yes" xml:space="preserve">
          <source>You can also auto-configure &lt;code&gt;MockMvc&lt;/code&gt; in a non-&lt;code&gt;@WebMvcTest&lt;/code&gt; (such as &lt;code&gt;@SpringBootTest&lt;/code&gt;) by annotating it with &lt;code&gt;@AutoConfigureMockMvc&lt;/code&gt;. The following example uses &lt;code&gt;MockMvc&lt;/code&gt;:</source>
          <target state="translated">당신은 또한 자동 구성 &lt;code&gt;MockMvc&lt;/code&gt; 비에 &lt;code&gt;@WebMvcTest&lt;/code&gt; (예 : &lt;code&gt;@SpringBootTest&lt;/code&gt; 로 주석을 달아도) &lt;code&gt;@AutoConfigureMockMvc&lt;/code&gt; . 다음 예제에서는 &lt;code&gt;MockMvc&lt;/code&gt; 를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="9cbcf106f1768b318dea2af23188f0551407c2ca" translate="yes" xml:space="preserve">
          <source>You can also auto-configure &lt;code&gt;WebTestClient&lt;/code&gt; in a non-&lt;code&gt;@WebFluxTest&lt;/code&gt; (such as &lt;code&gt;@SpringBootTest&lt;/code&gt;) by annotating it with &lt;code&gt;@AutoConfigureWebTestClient&lt;/code&gt;. The following example shows a class that uses both &lt;code&gt;@WebFluxTest&lt;/code&gt; and a &lt;code&gt;WebTestClient&lt;/code&gt;:</source>
          <target state="translated">당신은 할 수도 자동으로 구성 &lt;code&gt;WebTestClient&lt;/code&gt; 비에 &lt;code&gt;@WebFluxTest&lt;/code&gt; (예 : &lt;code&gt;@SpringBootTest&lt;/code&gt; 로 주석을 달아도) &lt;code&gt;@AutoConfigureWebTestClient&lt;/code&gt; . 다음 예제는 &lt;code&gt;@WebFluxTest&lt;/code&gt; 와 &lt;code&gt;WebTestClient&lt;/code&gt; 를 모두 사용하는 클래스를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="21c8590ba836fd794819851c7d878bc540f8af6e" translate="yes" xml:space="preserve">
          <source>You can also change the StatsD line protocol to use (default to Datadog):</source>
          <target state="translated">사용할 StatsD 라인 프로토콜을 변경할 수도 있습니다 (기본값은 Datadog).</target>
        </trans-unit>
        <trans-unit id="9848d18c626ee70db12e9c4d375345c155ebecdd" translate="yes" xml:space="preserve">
          <source>You can also change the interval at which metrics are sent to Datadog:</source>
          <target state="translated">메트릭이 Datadog으로 전송되는 간격을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c60aa66654d13463e259ed30cf8c2874b8337f1" translate="yes" xml:space="preserve">
          <source>You can also change the interval at which metrics are sent to Dynatrace:</source>
          <target state="translated">메트릭이 Dynatrace로 전송되는 간격을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc59840eb0c4d23e6840e0a60fb0e037c0874518" translate="yes" xml:space="preserve">
          <source>You can also change the interval at which metrics are sent to New Relic:</source>
          <target state="translated">메트릭이 New Relic으로 전송되는 간격을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d16d6d642b4187fc35fc28ac0203c82601335b" translate="yes" xml:space="preserve">
          <source>You can also change the interval at which metrics are sent to SignalFx:</source>
          <target state="translated">메트릭이 SignalFx로 전송되는 간격을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d91135f0dc9747bfdf227355acbe07b7f04da1f" translate="yes" xml:space="preserve">
          <source>You can also change the interval at which metrics are sent to Stackdriver:</source>
          <target state="translated">측정 항목이 Stackdriver로 전송되는 간격을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a870b11942300aa2608ad2c9fbf073e9968fe9ce" translate="yes" xml:space="preserve">
          <source>You can also change the interval at which metrics are sent to Wavefront:</source>
          <target state="translated">Wavefront로 메트릭을 보내는 간격을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ffe7f3d197cde0520218e9ae7db9b79739ac8c" translate="yes" xml:space="preserve">
          <source>You can also configure the Spring Kafka &lt;code&gt;JsonDeserializer&lt;/code&gt; as follows:</source>
          <target state="translated">다음과 같이 Spring Kafka &lt;code&gt;JsonDeserializer&lt;/code&gt; 를 구성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0954bd06e49802c622c891069754707ffdcd622f" translate="yes" xml:space="preserve">
          <source>You can also create your own &lt;code&gt;org.jooq.Configuration&lt;/code&gt;&lt;code&gt;@Bean&lt;/code&gt; if you want to take complete control of the jOOQ configuration.</source>
          <target state="translated">jOOQ 구성을 완전히 제어하려면 고유 한 &lt;code&gt;org.jooq.Configuration&lt;/code&gt; &lt;code&gt;@Bean&lt;/code&gt; 을 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6478f68692bb67318c035b6d5fe42c73844301ab" translate="yes" xml:space="preserve">
          <source>You can also customize the JMX domain under which endpoints are exposed. The following settings show an example of doing so in &lt;code&gt;application.properties&lt;/code&gt;:</source>
          <target state="translated">엔드 포인트가 노출되는 JMX 도메인을 사용자 정의 할 수도 있습니다. 다음 설정은 &lt;code&gt;application.properties&lt;/code&gt; 에서 수행하는 예를 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="37e049b463825ee01aace48c5447264e0c739358" translate="yes" xml:space="preserve">
          <source>You can also customize the static resource locations by using &lt;code&gt;spring.web.resources.static-locations&lt;/code&gt;. Doing so replaces the default values with a list of directory locations. If you do so, the default welcome page detection switches to your custom locations. So, if there is an &lt;code&gt;index.html&lt;/code&gt; in any of your locations on startup, it is the home page of the application.</source>
          <target state="translated">&lt;code&gt;spring.web.resources.static-locations&lt;/code&gt; 를 사용하여 정적 리소스 위치를 사용자 지정할 수도 있습니다 . 이렇게하면 기본값이 디렉토리 위치 목록으로 대체됩니다. 이렇게하면 기본 시작 페이지 검색이 사용자 지정 위치로 전환됩니다. 따라서 시작시 위치에 &lt;code&gt;index.html&lt;/code&gt; 이있는 경우 응용 프로그램의 홈 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="4e9bc55dbdd1ec57515adcc75d265971bf809c07" translate="yes" xml:space="preserve">
          <source>You can also customize the static resource locations by using the &lt;code&gt;spring.web.resources.static-locations&lt;/code&gt; property (replacing the default values with a list of directory locations). The root Servlet context path, &lt;code&gt;&quot;/&quot;&lt;/code&gt;, is automatically added as a location as well.</source>
          <target state="translated">&lt;code&gt;spring.web.resources.static-locations&lt;/code&gt; 속성 을 사용하여 정적 리소스 위치를 사용자 정의 할 수도 있습니다 (디폴트 값을 디렉토리 위치 목록으로 대체). 루트 서블릿 컨텍스트 경로 인 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 도 자동으로 위치로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="59789fe4af325518eae89aa9ecf38f8fc909281c" translate="yes" xml:space="preserve">
          <source>You can also define a class annotated with &lt;code&gt;@ControllerAdvice&lt;/code&gt; to customize the JSON document to return for a particular controller and/or exception type, as shown in the following example:</source>
          <target state="translated">또한 다음 예제와 같이 &lt;code&gt;@ControllerAdvice&lt;/code&gt; 로 주석이 달린 클래스 를 정의하여 특정 컨트롤러 및 / 또는 예외 유형에 대해 반환하도록 JSON 문서를 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f2cfd1a6c1ca373f014bc352127bc28ce30f25" translate="yes" xml:space="preserve">
          <source>You can also deploy Spring Boot applications to any Servlet 3.1+ compatible container.</source>
          <target state="translated">Servlet 3.1+ 호환 컨테이너에 Spring Boot 애플리케이션을 배포 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="477ca1b4d254351e2d3d5d36aa5aadb0b8a119e6" translate="yes" xml:space="preserve">
          <source>You can also disable all registries unless stated otherwise by the registry-specific property, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 레지스트리 관련 속성에서 달리 명시하지 않는 한 모든 레지스트리를 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="463476592344b8459d00f911b81ff70b938c577f" translate="yes" xml:space="preserve">
          <source>You can also flag the application to start automatically by using your standard operating system tools. For example, on Debian, you could use the following command:</source>
          <target state="translated">표준 운영 체제 도구를 사용하여 애플리케이션이 자동으로 시작되도록 플래그를 지정할 수도 있습니다. 예를 들어 Debian에서는 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bf0c182e51ca8cdbb16418db62843a6fa30956d" translate="yes" xml:space="preserve">
          <source>You can also inject an auto-configured &lt;code&gt;LdapTemplate&lt;/code&gt; instance as you would with any other Spring Bean, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 다른 Spring Bean과 마찬가지로 자동 구성된 &lt;code&gt;LdapTemplate&lt;/code&gt; 인스턴스를 삽입 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e9841e72a4069ec9d6e71b84ba77cc3dd868bc9b" translate="yes" xml:space="preserve">
          <source>You can also leverage &lt;a href=&quot;#boot-features-json-components&quot;&gt;Boot&amp;rsquo;s custom JSON serializers and deserializers&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#boot-features-json-components&quot;&gt;Boot의 사용자 지정 JSON serializer 및 deserializer를&lt;/a&gt; 활용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9006da0382b93d839d922317197abd9ce0426f54" translate="yes" xml:space="preserve">
          <source>You can also provide the following System properties (or environment variables) to change the behavior:</source>
          <target state="translated">다음과 같은 시스템 속성 (또는 환경 변수)을 제공하여 동작을 변경할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="00b5e0540fe6a7ea0e548602c3d84544f199d2cd" translate="yes" xml:space="preserve">
          <source>You can also register an arbitrary number of beans that implement &lt;code&gt;LettuceClientConfigurationBuilderCustomizer&lt;/code&gt; for more advanced customizations. If you use Jedis, &lt;code&gt;JedisClientConfigurationBuilderCustomizer&lt;/code&gt; is also available.</source>
          <target state="translated">고급 사용자 지정을 위해 &lt;code&gt;LettuceClientConfigurationBuilderCustomizer&lt;/code&gt; 를 구현하는 임의의 수의 Bean을 등록 할 수도 있습니다. &lt;code&gt;JedisClientConfigurationBuilderCustomizer&lt;/code&gt; 를 사용하는 경우 JedisClientConfigurationBuilderCustomizer 도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5efd2aa153de167f0b9b50f7939c143f0bc9fa95" translate="yes" xml:space="preserve">
          <source>You can also register an arbitrary number of beans that implement &lt;code&gt;RestClientBuilderCustomizer&lt;/code&gt; for more advanced customizations. To take full control over the registration, define a &lt;code&gt;RestClientBuilder&lt;/code&gt; bean.</source>
          <target state="translated">고급 사용자 정의를 위해 &lt;code&gt;RestClientBuilderCustomizer&lt;/code&gt; 를 구현하는 임의의 수의 Bean을 등록 할 수도 있습니다. 등록을 완전히 제어하려면 &lt;code&gt;RestClientBuilder&lt;/code&gt; 빈을 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8036627c96661e5d246f8aaf9accb893ca36b54" translate="yes" xml:space="preserve">
          <source>You can also set the location of a file to which to write the log (in addition to the console) by using &lt;code&gt;logging.file.name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;logging.file.name&lt;/code&gt; 을 사용하여 콘솔 외에 로그를 기록 할 파일의 위치를 ​​설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfb0f825e61f3ad6f5443b8b8fde1f3ac0349616" translate="yes" xml:space="preserve">
          <source>You can also specify &lt;code&gt;debug=true&lt;/code&gt; in your &lt;code&gt;application.properties&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;application.properties&lt;/code&gt; 에서 &lt;code&gt;debug=true&lt;/code&gt; 를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa5dbefae93e8f55eac894f5ef218eacde038e94" translate="yes" xml:space="preserve">
          <source>You can also switch off the initialization explicitly by setting &lt;code&gt;spring.batch.initialize-schema&lt;/code&gt; to &lt;code&gt;never&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;spring.batch.initialize-schema&lt;/code&gt; 를 &lt;code&gt;never&lt;/code&gt; 로 설정하여 초기화를 명시 적으로 끌 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d79ac25f16ff2746c645bbd647cd40a7cff8d3" translate="yes" xml:space="preserve">
          <source>You can also trigger validation by annotating the &lt;code&gt;@Bean&lt;/code&gt; method that creates the configuration properties with &lt;code&gt;@Validated&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;@Validated&lt;/code&gt; 로 구성 속성을 생성하는 &lt;code&gt;@Bean&lt;/code&gt; 메서드 에 주석을 달아 유효성 검사를 트리거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3f5bada294fe27fe71f0e0874e75d36ca11b91f" translate="yes" xml:space="preserve">
          <source>You can also use Flyway to provide data for specific scenarios. For example, you can place test-specific migrations in &lt;code&gt;src/test/resources&lt;/code&gt; and they are run only when your application starts for testing. Also, you can use profile-specific configuration to customize &lt;code&gt;spring.flyway.locations&lt;/code&gt; so that certain migrations run only when a particular profile is active. For example, in &lt;code&gt;application-dev.properties&lt;/code&gt;, you might specify the following setting:</source>
          <target state="translated">Flyway를 사용하여 특정 시나리오에 대한 데이터를 제공 할 수도 있습니다. 예를 들어, &lt;code&gt;src/test/resources&lt;/code&gt; 에 테스트 별 마이그레이션을 배치 할 수 있으며 애플리케이션이 테스트를 시작할 때만 실행됩니다. 또한 특정 프로필이 활성화 된 경우에만 특정 마이그레이션이 실행되도록 프로필 별 구성을 사용하여 &lt;code&gt;spring.flyway.locations&lt;/code&gt; 를 사용자 지정할 수 있습니다 . 예를 들어 &lt;code&gt;application-dev.properties&lt;/code&gt; 에서 다음 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ffc90be78de83ce6926b85418f6e19317ca9f7e" translate="yes" xml:space="preserve">
          <source>You can also use any of the supported units. These are:</source>
          <target state="translated">지원되는 모든 단위를 사용할 수도 있습니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="b8168059533af06cffde63d8f4d47ca82a906c74" translate="yes" xml:space="preserve">
          <source>You can also use regular Spring MVC features such as &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-exceptionhandlers&quot;&gt;&lt;code&gt;@ExceptionHandler&lt;/code&gt; methods&lt;/a&gt; and &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-ann-controller-advice&quot;&gt;&lt;code&gt;@ControllerAdvice&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;ErrorController&lt;/code&gt; then picks up any unhandled exceptions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-exceptionhandlers&quot;&gt; &lt;code&gt;@ExceptionHandler&lt;/code&gt; 메소드&lt;/a&gt; 및 &lt;a href=&quot;https://docs.spring.io/spring/docs/5.3.1/reference/html/web.html#mvc-ann-controller-advice&quot;&gt; &lt;code&gt;@ControllerAdvice&lt;/code&gt; &lt;/a&gt; 와 같은 일반적인 Spring MVC 기능을 사용할 수도 있습니다 . &lt;code&gt;ErrorController&lt;/code&gt; 는 다음 처리되지 않은 예외를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e0fd1ba42a971e140af070acfbf29e6a8c20f5a5" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;YamlPropertySourceLoader&lt;/code&gt; class if you want to load YAML as a Spring &lt;code&gt;PropertySource&lt;/code&gt;.</source>
          <target state="translated">YAML을 Spring &lt;code&gt;PropertySource&lt;/code&gt; 로로드하려는 경우 &lt;code&gt;YamlPropertySourceLoader&lt;/code&gt; 클래스를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3667cfac0db478ca06f911ca87af8669823526d2" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;spring.main.banner-mode&lt;/code&gt; property to determine if the banner has to be printed on &lt;code&gt;System.out&lt;/code&gt; (&lt;code&gt;console&lt;/code&gt;), sent to the configured logger (&lt;code&gt;log&lt;/code&gt;), or not produced at all (&lt;code&gt;off&lt;/code&gt;).</source>
          <target state="translated">또한 &lt;code&gt;spring.main.banner-mode&lt;/code&gt; 속성을 사용하여 배너가 &lt;code&gt;System.out&lt;/code&gt; 에 인쇄되어야하는지 ( &lt;code&gt;console&lt;/code&gt; ), 구성된 로거로 전송되어야하는지 ( &lt;code&gt;log&lt;/code&gt; ), 아니면 전혀 생성되지 않아야하는지 ( &lt;code&gt;off&lt;/code&gt; ) 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81c83874b9afe6ffcb420d616b6817f8050f836a" translate="yes" xml:space="preserve">
          <source>You can also use the audit services for your own business events. To do so, either inject the &lt;code&gt;AuditEventRepository&lt;/code&gt; bean into your own components and use that directly or publish an &lt;code&gt;AuditApplicationEvent&lt;/code&gt; with the Spring &lt;code&gt;ApplicationEventPublisher&lt;/code&gt; (by implementing &lt;code&gt;ApplicationEventPublisherAware&lt;/code&gt;).</source>
          <target state="translated">자신의 비즈니스 이벤트에 대해 감사 서비스를 사용할 수도 있습니다. 그렇게하려면 &lt;code&gt;AuditEventRepository&lt;/code&gt; 빈을 자신의 구성 요소에 삽입하고 이를 직접 사용하거나 Spring &lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 를 사용하여 &lt;code&gt;AuditApplicationEvent&lt;/code&gt; 를 게시합니다 ( &lt;code&gt;ApplicationEventPublisherAware&lt;/code&gt; 구현 ).</target>
        </trans-unit>
        <trans-unit id="62e7c44a4f2ddca49d4c00ae2a4d91c5eeb7a795" translate="yes" xml:space="preserve">
          <source>You can also use the standard JSR-107 (JCache) annotations (such as &lt;code&gt;@CacheResult&lt;/code&gt;) transparently. However, we strongly advise you to not mix and match the Spring Cache and JCache annotations.</source>
          <target state="translated">표준 JSR-107 (JCache) 주석 (예 : &lt;code&gt;@CacheResult&lt;/code&gt; )을 투명하게 사용할 수도 있습니다. 그러나 Spring Cache 및 JCache 주석을 혼합 및 일치시키지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="85fd7cc2c80e4e2e18d4272b7da0f31cf3fd8a8f" translate="yes" xml:space="preserve">
          <source>You can also use this technique to create &amp;ldquo;short&amp;rdquo; variants of existing Spring Boot properties. See the &lt;em&gt;&lt;a href=&quot;howto#howto-use-short-command-line-arguments&quot;&gt;howto.html&lt;/a&gt;&lt;/em&gt; how-to for details.</source>
          <target state="translated">이 기술을 사용하여 기존 Spring Boot 속성의 &quot;짧은&quot;변형을 만들 수도 있습니다. 자세한 내용은 &lt;em&gt;&lt;a href=&quot;howto#howto-use-short-command-line-arguments&quot;&gt;howto.html&lt;/a&gt;&lt;/em&gt; 방법을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="4977d02bc5a328895cf3f043a312b63857fb16e2" translate="yes" xml:space="preserve">
          <source>You can also write technology-specific endpoints by using &lt;code&gt;@JmxEndpoint&lt;/code&gt; or &lt;code&gt;@WebEndpoint&lt;/code&gt;. These endpoints are restricted to their respective technologies. For example, &lt;code&gt;@WebEndpoint&lt;/code&gt; is exposed only over HTTP and not over JMX.</source>
          <target state="translated">&lt;code&gt;@JmxEndpoint&lt;/code&gt; 또는 &lt;code&gt;@WebEndpoint&lt;/code&gt; 를 사용하여 기술 별 엔드 포인트를 작성할 수도 있습니다 . 이러한 엔드 포인트는 해당 기술로 제한됩니다. 예를 들어 &lt;code&gt;@WebEndpoint&lt;/code&gt; 는 JMX가 아닌 HTTP를 통해서만 노출됩니다.</target>
        </trans-unit>
        <trans-unit id="207fc2d806742e19d72cdc0f40c647d7ae8f518c" translate="yes" xml:space="preserve">
          <source>You can apply customizations to particular registry implementations by being more specific about the generic type:</source>
          <target state="translated">일반 유형에 대해 더 구체적으로 지정하여 특정 레지스트리 구현에 사용자 정의를 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="868b0c2b69dd194d4986331d1b94164d5d4ee70c" translate="yes" xml:space="preserve">
          <source>You can apply the same concept to the secondary &lt;code&gt;DataSource&lt;/code&gt; as well, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 동일한 개념을 보조 &lt;code&gt;DataSource&lt;/code&gt; 에도 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78e9605872dce6e9034a6f7047fc08ec97b28640" translate="yes" xml:space="preserve">
          <source>You can automatically expand properties from the Gradle project by configuring the Java plugin&amp;rsquo;s &lt;code&gt;processResources&lt;/code&gt; task to do so, as shown in the following example:</source>
          <target state="translated">다음 예제와 같이 Java 플러그인의 &lt;code&gt;processResources&lt;/code&gt; 작업을 구성하여 Gradle 프로젝트에서 속성을 자동으로 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5dbec85f3c5053792d52c4052b34c895ff88907a" translate="yes" xml:space="preserve">
          <source>You can automatically expand properties from the Maven project by using resource filtering. If you use the &lt;code&gt;spring-boot-starter-parent&lt;/code&gt;, you can then refer to your Maven &amp;lsquo;project properties&amp;rsquo; with &lt;code&gt;@..@&lt;/code&gt; placeholders, as shown in the following example:</source>
          <target state="translated">리소스 필터링을 사용하여 Maven 프로젝트에서 속성을 자동으로 확장 할 수 있습니다. &lt;code&gt;spring-boot-starter-parent&lt;/code&gt; 를 사용하는 경우 다음 예제와 같이 &lt;code&gt;@..@&lt;/code&gt; 자리 표시자를 사용하여 Maven '프로젝트 속성'을 참조 할 수 있습니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
