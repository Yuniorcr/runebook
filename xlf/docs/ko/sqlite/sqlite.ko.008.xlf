<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0a8b8eec2dca22f4460d3c1b6d1607de62d83c18" translate="yes" xml:space="preserve">
          <source>For example, to create an archive containing two text files, &quot;a.txt&quot; and &quot;b.txt&quot;, containing the text &quot;abc&quot; and &quot;123&quot; respectively:</source>
          <target state="translated">예를 들어, 텍스트 &quot;abc&quot;및 &quot;123&quot;을 각각 포함하는 &quot;a.txt&quot;및 &quot;b.txt&quot;라는 두 개의 텍스트 파일을 포함하는 아카이브를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e1c45bec4422b2834e5d74273014f0905a33b70e" translate="yes" xml:space="preserve">
          <source>For example, to inspect the contents of zip archive &quot;test.zip&quot; from the current directory:</source>
          <target state="translated">예를 들어, 현재 디렉토리에서 zip 아카이브 &quot;test.zip&quot;의 내용을 검사하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="460920e6960fc9166bdf09c3d3e3d2d1b9cb1172" translate="yes" xml:space="preserve">
          <source>For example, to optimize the full-text index for an FTS table named &quot;docs&quot;:</source>
          <target state="translated">예를 들어 &quot;docs&quot;라는 FTS 테이블의 전체 텍스트 인덱스를 최적화하려면</target>
        </trans-unit>
        <trans-unit id="8112859719fda223d11dd9ecc671a2d731113a48" translate="yes" xml:space="preserve">
          <source>For example, to see a list of the tables in the database, you can enter &quot;.tables&quot;.</source>
          <target state="translated">예를 들어, 데이터베이스의 테이블 목록을 보려면 &quot;.tables&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="3403f20bef06b9f62c829264d38a448f07fbf25f" translate="yes" xml:space="preserve">
          <source>For example, using the tables created above:</source>
          <target state="translated">예를 들어 위에서 만든 테이블을 사용하면</target>
        </trans-unit>
        <trans-unit id="8baebd4e0fce8f0dca8a23890fbbeb7b6c6bd6f4" translate="yes" xml:space="preserve">
          <source>For example, when a document containing the text &quot;Right now, they're very frustrated.&quot;, the terms extracted from the document and added to the full-text index are, in order, &quot;right now they re very frustrated&quot;. Such a document would match a full-text query such as &quot;MATCH 'Frustrated'&quot;, as the simple tokenizer transforms the term in the query to lowercase before searching the full-text index.</source>
          <target state="translated">예를 들어, &quot;지금 바로, 지금 당황합니다.&quot;라는 텍스트가 포함 된 문서의 경우, 문서에서 추출하여 전체 텍스트 색인에 추가 된 용어는 &quot;지금 당장 매우 실망&quot;입니다. 간단한 토크 나이 저는 전체 텍스트 인덱스를 검색하기 전에 쿼리의 용어를 소문자로 변환하므로 이러한 문서는 &quot;MATCH 'Frustrated'&quot;와 같은 전체 텍스트 쿼리와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0dc693a709e03c8a242ebc99f829d5a5f0d7f07e" translate="yes" xml:space="preserve">
          <source>For examples of how the SQLite C/C++ interface can be used, refer to the source code for the &lt;b&gt;sqlite&lt;/b&gt; program in the file &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c&lt;/a&gt; of the source tree. Additional information about sqlite is available at &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt;. See also the sources to the Tcl interface for SQLite in the source file &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src/tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">SQLite C / C ++ 인터페이스 사용 방법에 대한 예제 는 소스 트리의 &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c&lt;/a&gt; 파일에서 &lt;b&gt;sqlite&lt;/b&gt; 프로그램 의 소스 코드를 참조하십시오 . sqlite에 대한 추가 정보는 &lt;a href=&quot;cli&quot;&gt;cli.html&lt;/a&gt; 에서 볼 수 있습니다 . 소스 파일 &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;src / tclsqlite.c의&lt;/a&gt; SQLite 용 Tcl 인터페이스에 대한 소스도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db416b5f222a1960fcc408837e83b440afa98ccd" translate="yes" xml:space="preserve">
          <source>For floating-point substitutions (%e, %E, %f, %g, %G) the precision specifies the number of digits to display to the right of the decimal point.</source>
          <target state="translated">부동 소수점 대체 (% e, % E, % f, % g, % G)의 경우 정밀도는 소수점 오른쪽에 표시 할 자릿수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cf9d217953f034811d5791d9759455b504d70d86" translate="yes" xml:space="preserve">
          <source>For full prefix support, method (3) may be preferred. In this case, because the index contains entries for both &quot;first&quot; and &quot;1st&quot;, prefix queries such as 'fi*' or '1s*' will match correctly. However, because extra entries are added to the FTS index, this method uses more space within the database.</source>
          <target state="translated">완전한 접두사 지원을 위해, 방법 (3)이 바람직 할 수있다. 이 경우 인덱스에 &quot;first&quot;및 &quot;1st&quot;에 대한 항목이 포함되므로 'fi *'또는 '1s *'와 같은 접두사 쿼리가 올바르게 일치합니다. 그러나 추가 항목이 FTS 인덱스에 추가되므로이 방법은 데이터베이스 내에서 더 많은 공간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="af625b5ec940a13ac3f0b796c61917d55c083bf9" translate="yes" xml:space="preserve">
          <source>For functions that accept &quot;</source>
          <target state="translated">&quot;를받는 기능</target>
        </trans-unit>
        <trans-unit id="8e0c304ceb8d93d914d671ff91751c10ea1ee104" translate="yes" xml:space="preserve">
          <source>For functions that accept JSON as their first argument, that argument can be a JSON object, array, number, string, or null. SQLite numeric values and NULL values are interpreted as JSON numbers and nulls, respectively. SQLite text values can be understood as JSON objects, arrays, or strings. If an SQLite text value that is not a well-formed JSON object, array, or string is passed into json1 function, that function will usually throw an error. (Exceptions to this rule are &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid()&lt;/a&gt; and &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt;.)</source>
          <target state="translated">JSON을 첫 번째 인수로 허용하는 함수의 경우 해당 인수는 JSON 객체, 배열, 숫자, 문자열 또는 null 일 수 있습니다. SQLite 숫자 값과 NULL 값은 각각 JSON 숫자와 널로 해석됩니다. SQLite 텍스트 값은 JSON 객체, 배열 또는 문자열로 이해 될 수 있습니다. 올바르게 구성된 JSON 객체, 배열 또는 문자열이 아닌 SQLite 텍스트 값이 json1 함수에 전달되면 해당 함수는 일반적으로 오류를 발생시킵니다. (이 규칙의 예외는 &lt;a href=&quot;json1#jvalid&quot;&gt;json_valid ()&lt;/a&gt; 및 &lt;a href=&quot;json1#jquote&quot;&gt;json_quote ()&lt;/a&gt; 입니다.)</target>
        </trans-unit>
        <trans-unit id="f4454df1a142f9ac3cdff944002d68d2bfdcbcbb" translate="yes" xml:space="preserve">
          <source>For functions that accept PATH arguments, that PATH must be well-formed or else the function will throw an error. A well-formed PATH is a text value that begins with exactly one '$' character followed by zero or more instances of &quot;.</source>
          <target state="translated">PATH 인수를 허용하는 함수의 경우 해당 PATH의 형식이 양호해야합니다. 그렇지 않으면 함수에서 오류가 발생합니다. 올바른 형식의 PATH는 정확히 하나의 '$'문자로 시작하고 0 개 이상의 &quot;&quot;인스턴스로 시작하는 텍스트 값입니다.</target>
        </trans-unit>
        <trans-unit id="8848d7d3d9820023afd4f5c595baf809ffcb7c92" translate="yes" xml:space="preserve">
          <source>For general use in cases where the workload contains few UPDATE or DELETE operations, a good choice for automerge is 8. If the workload contains many UPDATE or DELETE commands, or if query speed is a concern, it may be advantageous to reduce automerge to 2.</source>
          <target state="translated">작업 부하에 UPDATE 또는 DELETE 작업이 거의없는 경우 일반적인 사용의 경우 자동 병합에 적합한 선택은 8입니다. 작업 부하에 많은 UPDATE 또는 DELETE 명령이 있거나 쿼리 속도가 중요한 경우 자동 병합을 2로 줄이는 것이 유리할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="bf5110604d852a2448723644607996c9499bf3c7" translate="yes" xml:space="preserve">
          <source>For historic compatibility, the C-language interfaces return primary result codes by default. The extended result code for the most recent error can be retrieved using the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes()&lt;/a&gt; interface can be used to put a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; into a mode where it returns the extended result codes instead of the primary result codes.</source>
          <target state="translated">기록 호환성을 위해 C 언어 인터페이스는 기본적으로 기본 결과 코드를 반환합니다. &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode ()&lt;/a&gt; 인터페이스를 사용하여 가장 최근의 오류에 대한 확장 결과 코드를 검색 할 수 있습니다 . &lt;a href=&quot;c3ref/extended_result_codes&quot;&gt;sqlite3_extended_result_codes ()&lt;/a&gt; 인터페이스는 넣어 사용할 수있는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 확장 된 결과 코드 대신의 주요 결과 코드를 반환하는 모드로합니다.</target>
        </trans-unit>
        <trans-unit id="17b53a99ea41c50893270b0043884f065027650e" translate="yes" xml:space="preserve">
          <source>For historical reasons, and for efficiency, all sorting is currently done in memory.</source>
          <target state="translated">역사적 이유로 그리고 효율성을 위해 모든 정렬은 현재 메모리에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eeed22fa30af9d54901acfbf4c1ce1f017feb462" translate="yes" xml:space="preserve">
          <source>For integer substitutions (%d, %i, %x, %X, %o, and %p) the precision specifies minimum number of digits to display. Leading zeros are added if necessary, to expand the output to the minimum number of digits.</source>
          <target state="translated">정수 대체 (% d, % i, % x, % X, % o 및 % p)의 경우 정밀도는 표시 할 최소 자릿수를 지정합니다. 필요한 경우 선행 0이 추가되어 출력을 최소 자릿수로 확장합니다.</target>
        </trans-unit>
        <trans-unit id="6f753dacad85542947673dd8fa7db3bccc0a7592" translate="yes" xml:space="preserve">
          <source>For maximum reliability and for robustness against database corruption, SQLite should always be run with its default synchronous setting of FULL.</source>
          <target state="translated">안정성을 최대화하고 데이터베이스 손상에 대한 견고성을 유지하려면 SQLite는 항상 기본 동기 설정 인 FULL로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="489e54409f8b7e0829c336efb96f4282b5ccf13a" translate="yes" xml:space="preserve">
          <source>For more details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;헤더 파일 sqlite3rbu.h&lt;/a&gt; 의 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4e6f70ecf49e4210656602d693e569fcb03d8193" translate="yes" xml:space="preserve">
          <source>For most applications, the recommended method for building SQLite is to use &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; code file, &lt;b&gt;sqlite3.c&lt;/b&gt;, and its corresponding header file &lt;b&gt;sqlite3.h&lt;/b&gt;. The sqlite3.c code file should compile and run on any unix, Windows system without any changes or special compiler options. Most applications can simply include the sqlite3.c file together with the other C code files that make up the application, compile them all together, and have working and well configured version of SQLite.</source>
          <target state="translated">대부분의 애플리케이션에서 SQLite를 빌드하기 위해 권장되는 방법 &lt;a href=&quot;amalgamation&quot;&gt;은 통합&lt;/a&gt; 코드 파일 인 &lt;b&gt;sqlite3.c&lt;/b&gt; 및 해당 헤더 파일 인 &lt;b&gt;sqlite3.h를 사용하는 것&lt;/b&gt; 입니다. sqlite3.c 코드 파일은 변경 또는 특수 컴파일러 옵션없이 UNIX 시스템에서 컴파일 및 실행되어야합니다. 대부분의 응용 프로그램은 sqlite3.c 파일을 다른 C 코드 파일과 함께 포함하여 응용 프로그램을 구성하고 모두 함께 컴파일하며 SQLite 버전이 제대로 작동하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="99e3c9a88b32764d83bb0da10699b12fcd9a531f" translate="yes" xml:space="preserve">
          <source>For most applications, upgrading from the legacy query planner to the NGQP requires little thought or effort. Simply replace the older SQLite version with the newer version of SQLite and recompile and the application will run faster. There are no API changes nor modifications to compilation procedures.</source>
          <target state="translated">대부분의 응용 프로그램에서 레거시 쿼리 플래너에서 NGQP로 업그레이드하는 데는 약간의 노력이나 노력이 필요합니다. 이전 SQLite 버전을 최신 버전의 SQLite로 바꾸고 다시 컴파일하면 응용 프로그램이 더 빨리 실행됩니다. 컴파일 절차에 대한 API 변경이나 수정은 없습니다.</target>
        </trans-unit>
        <trans-unit id="0efe87a820fa8cd327d2f74d3e3f1deb32107fb9" translate="yes" xml:space="preserve">
          <source>For most cases, it is true that potential attackers have no way of injecting arbitrary SQL, and so most uses of SQLite are immune to the attack above. But there are some notable exceptions. To wit:</source>
          <target state="translated">대부분의 경우 잠재적 인 공격자는 임의의 SQL을 주입 할 방법이 없으므로 대부분의 SQLite 사용은 위의 공격에 영향을받지 않습니다. 그러나 몇 가지 주목할만한 예외가 있습니다. 재치 :</target>
        </trans-unit>
        <trans-unit id="c86754da6df36988096aed27dea948d5f58eceba" translate="yes" xml:space="preserve">
          <source>For most non-trivial SQL databases, the key to performance is creating the right SQL indexes. In this context &quot;the right SQL indexes&quot; means those that cause the queries that an application needs to optimize run fast. The &quot;.expert&quot; command can assist with this by proposing indexes that might assist with specific queries, were they present in the database.</source>
          <target state="translated">사소한 SQL 데이터베이스의 경우 성능의 핵심은 올바른 SQL 인덱스를 작성하는 것입니다. 이와 관련하여 &quot;올바른 SQL 인덱스&quot;는 응용 프로그램이 최적화해야하는 쿼리를 빠르게 실행하는 쿼리를 의미합니다. &quot;.expert&quot;명령은 데이터베이스에있는 특정 쿼리를 지원할 수있는 인덱스를 제안하여이를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fd582fdc761484a0a0ca3bb5f583aafab7cdf5" translate="yes" xml:space="preserve">
          <source>For most purposes, SQLite can be built just fine using the default compilation options. However, if required, the compile-time options documented below can be used to &lt;a href=&quot;#omitfeatures&quot;&gt;omit SQLite features&lt;/a&gt; (resulting in a &lt;a href=&quot;footprint&quot;&gt;smaller compiled library size&lt;/a&gt;) or to change the &lt;a href=&quot;#defaults&quot;&gt;default values&lt;/a&gt; of some parameters.</source>
          <target state="translated">대부분의 경우 기본 컴파일 옵션을 사용하여 SQLite를 올바르게 빌드 할 수 있습니다. 그러나 필요한 경우 아래에 설명 된 컴파일 시간 옵션을 사용하여 &lt;a href=&quot;#omitfeatures&quot;&gt;SQLite 기능&lt;/a&gt; 을 생략 하거나 ( &lt;a href=&quot;footprint&quot;&gt;컴파일 된 라이브러리 크기&lt;/a&gt; 가 더 작음 ) 일부 매개 변수 의 &lt;a href=&quot;#defaults&quot;&gt;기본값&lt;/a&gt; 을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be3d8fa3ad8b3f16b5f81b3d35db241bab90e030" translate="yes" xml:space="preserve">
          <source>For multi-threaded applications that are careful about how they manage threads, SQLite supports an alternative run-time configuration that is half way between not using any mutexes and the default situation of mutexing everything in sight. This in-the-middle mutex alignment can be established as follows:</source>
          <target state="translated">스레드 관리 방식에주의를 기울이는 멀티 스레드 응용 프로그램의 경우 SQLite는 뮤텍스를 사용하지 않는 것과 모든 것을 뮤텍스 팅하는 기본 상황 사이의 절반에 이르는 대체 런타임 구성을 지원합니다. 이 중간 뮤텍스 정렬은 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bfaf72720042391e9725050a2097ea765a5277e" translate="yes" xml:space="preserve">
          <source>For newer applications, FTS4 is recommended; though if compatibility with older versions of SQLite is important, then FTS3 will usually serve just as well.</source>
          <target state="translated">최신 응용 프로그램의 경우 FTS4가 권장됩니다. 이전 버전의 SQLite와의 호환성이 중요한 경우 FTS3도 일반적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="74f1cec569d928f5163be03c8f3a97d88c4bb5d9" translate="yes" xml:space="preserve">
          <source>For non-TEMP triggers, the table to be modified or queried must exist in the same database as the table or view to which the trigger is attached. TEMP triggers are not subject to the same-database rule. A TEMP trigger is allowed to query or modify any table in any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed database.</source>
          <target state="translated">TEMP가 아닌 트리거의 경우 수정 또는 쿼리 할 테이블이 트리거가 연결된 테이블 또는 뷰와 동일한 데이터베이스에 있어야합니다. TEMP 트리거에는 동일한 데이터베이스 규칙이 적용되지 않습니다. TEMP 트리거는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 데이터베이스 에서 테이블을 쿼리하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaf4afda655b698c5089cf162bb3637b1ddce067" translate="yes" xml:space="preserve">
          <source>For numeric data, this situation is more complex. If both inputs look like well-formed numbers, then they are converted into floating point values using &lt;b&gt;atof()&lt;/b&gt; and compared numerically. If one input is not a well-formed number but the other is, then the number is considered to be less than the non-number. If neither inputs is a well-formed number, then &lt;b&gt;strcmp()&lt;/b&gt; is used to do the comparison.</source>
          <target state="translated">숫자 데이터의 경우이 상황이 더 복잡합니다. 두 입력이 올바르게 구성된 숫자 인 경우 &lt;b&gt;atof ()를&lt;/b&gt; 사용하여 부동 소수점 값으로 변환되어 숫자로 비교됩니다. 하나의 입력이 올바른 형식의 숫자는 아니지만 다른 입력은 숫자가 아닌 숫자보다 작은 것으로 간주됩니다. 입력이 올바른 형식의 숫자가 아닌 경우 &lt;b&gt;strcmp ()&lt;/b&gt; 를 사용하여 비교합니다.</target>
        </trans-unit>
        <trans-unit id="11d66790f63457992337a522f75d0ba8c19d49c3" translate="yes" xml:space="preserve">
          <source>For ordinary FTS3/FTS4 queries, the search tree depth is approximately the base-2 logarithm of the number of terms in the right-hand side of the MATCH operator. However, for &lt;a href=&quot;fts3#phrase&quot;&gt;phrase queries&lt;/a&gt; and &lt;a href=&quot;fts3#near&quot;&gt;NEAR queries&lt;/a&gt; the search tree depth is linear in the number of right-hand side terms. So the default depth limit of 12 is sufficient for up to 4095 ordinary terms on a MATCH, it is only sufficient for 11 or 12 phrase or NEAR terms. Even so, the default is more than enough for most application.</source>
          <target state="translated">일반적인 FTS3 / FTS4 쿼리의 경우 검색 트리 깊이는 대략 MATCH 연산자의 오른쪽에있는 용어 수의 기본 2 로그입니다. 그러나 &lt;a href=&quot;fts3#phrase&quot;&gt;구문 쿼리&lt;/a&gt; 및 &lt;a href=&quot;fts3#near&quot;&gt;NEAR 쿼리의&lt;/a&gt; 경우 검색 트리 깊이는 오른쪽 항의 수에서 선형입니다. 따라서 기본 깊이 제한 12는 MATCH에서 최대 4095 개의 일반 용어에 충분하고 11 또는 12 구 또는 NEAR 용어에 충분합니다. 그럼에도 불구하고 기본값은 대부분의 응용 프로그램에 충분합니다.</target>
        </trans-unit>
        <trans-unit id="87e6be4eb608f1997fb25355e4537ee88db28dd4" translate="yes" xml:space="preserve">
          <source>For performance measurement, SQLite is compiled in approximately the same way as it would be for use in production systems. The compile-time configuration is &quot;approximate&quot; in the sense that every production use of SQLite is different. Compile-time options used by one system are not necessarily the same as those used by others. The key point is that options that significantly impact the generated machine code are avoided. For example, the -DSQLITE_DEBUG option is omitted because that option inserts thousands of assert() statements in the middle of performance critical sections of the SQLite library. The -pg option (on GCC) is omitted because it causes the compiler to emit extra probabilistic performance measuring code which interferes with actual performance measurements.</source>
          <target state="translated">성능 측정을 위해 SQLite는 프로덕션 시스템에서 사용하는 것과 거의 같은 방식으로 컴파일됩니다. 컴파일 타임 구성은 SQLite의 모든 프로덕션 용도가 다르다는 점에서 &quot;대략&quot;입니다. 한 시스템에서 사용하는 컴파일 시간 옵션이 다른 시스템에서 사용되는 옵션과 반드시 ​​같을 필요는 없습니다. 요점은 생성 된 기계 코드에 큰 영향을주는 옵션을 피하는 것입니다. 예를 들어, -DSQLITE_DEBUG 옵션은 해당 옵션이 SQLite 라이브러리의 성능 중요 섹션 중간에 수천 개의 assert () 문을 삽입하므로 생략됩니다. -pg 옵션 (GCC에서)은 컴파일러가 실제 성능 측정을 방해하는 추가적인 확률 적 성능 측정 코드를 생성하게하므로 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f448cd989ab34ec0bc46f3d775e49bf2cb96fd96" translate="yes" xml:space="preserve">
          <source>For performance measurements, the -Os option is used (optimize for size) rather than -O2 because the -O2 option creates so much code movement that it is difficult to associate specific CPU instructions to C source code lines.</source>
          <target state="translated">성능 측정의 경우 -O2 옵션이 너무 많은 코드 이동을 생성하여 특정 CPU 명령어를 C 소스 코드 라인에 연결하기 어렵 기 때문에 -Os 옵션이 -O2 대신에 사용됩니다 (크기에 최적화).</target>
        </trans-unit>
        <trans-unit id="5c184bd0f5295912e4ff3123f4057a4db6895161" translate="yes" xml:space="preserve">
          <source>For performance reasons, it is advantageous to &lt;b&gt;minimize the quantity of data read and written&lt;/b&gt; to and from the file-system.</source>
          <target state="translated">성능상의 이유로 파일 시스템에서 &lt;b&gt;읽고 쓰는 데이터의 양&lt;/b&gt; 을 &lt;b&gt;최소화하는&lt;/b&gt; 것이 유리 합니다.</target>
        </trans-unit>
        <trans-unit id="07b863ed3fe569c9ef5b6a594040618449a6d03c" translate="yes" xml:space="preserve">
          <source>For programs that have a lot of data that must be sifted and sorted in diverse ways, it is often easier and quicker to load the data into an in-memory SQLite database and use queries with joins and ORDER BY clauses to extract the data in the form and order needed rather than to try to code the same operations manually. Using an SQL database internally in this way also gives the program greater flexibility since new columns and indices can be added without having to recode every query.</source>
          <target state="translated">다양한 방식으로 선별 및 정렬해야하는 데이터가 많은 프로그램의 경우 데이터를 메모리 내 SQLite 데이터베이스에로드하고 조인 및 ORDER BY 절과 함께 쿼리를 사용하여 데이터를 추출하는 것이 더 쉽고 빠릅니다. 동일한 작업을 수동으로 코딩하기보다는 양식 및 순서가 필요합니다. 이러한 방식으로 SQL 데이터베이스를 내부적으로 사용하면 모든 쿼리를 다시 코딩하지 않고도 새로운 열과 인덱스를 추가 할 수 있으므로 프로그램의 유연성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="9dd6714e0fb0a2d212f83820882b4bc1eae38324" translate="yes" xml:space="preserve">
          <source>For queries that use OR expressions, or those that use LIMIT or return many rows, the 'y' matchinfo option may be faster than 'x'.</source>
          <target state="translated">OR 표현식을 사용하거나 LIMIT를 사용하거나 많은 행을 리턴하는 쿼리의 경우 'y'matchinfo 옵션이 'x'보다 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c9ccc0a52d5200b9388c921b60acbab7d6fb34e" translate="yes" xml:space="preserve">
          <source>For queries, extract results by calling &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; in between two calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">쿼리의 경우, 호출에 의해 추출 결과 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column ()&lt;/a&gt; 를 두 번 호출 사이에서 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85d9929e5f003ec622c68d9ac564cf73c6c4c155" translate="yes" xml:space="preserve">
          <source>For reading existing zip archives, the Zipfile module provides a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; that accepts a single argument. If the argument is a text value, then it is a path to a zip archive to read from the file-system. Or, if the argument is an SQL blob, then it is the zip archive data itself.</source>
          <target state="translated">기존 zip 아카이브를 읽기 위해 Zipfile 모듈은 단일 인수를 허용하는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 를 제공합니다 . 인수가 텍스트 값인 경우 파일 시스템에서 읽을 zip 아카이브의 경로입니다. 또는 인수가 SQL Blob 인 경우 zip 아카이브 데이터 자체입니다.</target>
        </trans-unit>
        <trans-unit id="9867027f324defd1a582c5a9d9007cb8936fd6ce" translate="yes" xml:space="preserve">
          <source>For reasons of backwards compatibility, the &quot;automerge=1&quot; command sets the automerge parameter to 8, not 1 (a value of 1 would make no sense anyway, as merging data from a single segment is a no-op).</source>
          <target state="translated">이전 버전과의 호환성을 위해 &quot;automerge = 1&quot;명령은 automerge 매개 변수를 1이 아닌 8로 설정합니다 (단일 세그먼트에서 데이터를 병합하는 것은 아무 작업도 없으므로 1 값은 의미가 없습니다).</target>
        </trans-unit>
        <trans-unit id="a23d1c74ece13b6a1e6d02aa92a4e6d015b8a626" translate="yes" xml:space="preserve">
          <source>For regular functions, the &lt;b&gt;xFunc&lt;/b&gt; callback is invoked once for each function call. The implementation of xFunc should call one of the &lt;b&gt;sqlite_set_result_...&lt;/b&gt; interfaces to return its result. The &lt;b&gt;sqlite_user_data()&lt;/b&gt; routine can be used to retrieve the &lt;b&gt;pUserData&lt;/b&gt; pointer that was passed in when the function was registered.</source>
          <target state="translated">일반 함수의 경우 &lt;b&gt;xFunc&lt;/b&gt; 콜백은 각 함수 호출마다 한 번씩 호출됩니다. xFunc의 구현은 &lt;b&gt;sqlite_set_result _...&lt;/b&gt; 인터페이스 중 하나를 호출 하여 결과를 반환해야합니다. &lt;b&gt;sqlite_user_data ()&lt;/b&gt; 루틴은 검색하는 데 사용할 수 있습니다 &lt;b&gt;pUserData의&lt;/b&gt; 기능을 등록 할 때 전달 된 포인터.</target>
        </trans-unit>
        <trans-unit id="d0ed67ff8b79adf22c16c2b1f3556a389aea4a01" translate="yes" xml:space="preserve">
          <source>For resilience when confronted with historical SQL statements, SQLite will sometimes bend the quoting rules above:</source>
          <target state="translated">과거 SQL 문에 직면했을 때의 탄력성을 위해 SQLite는 때때로 위의 인용 규칙을 구부릴 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7eae9c3102a4115cf6fa58568800e787b48e7a4" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loaded is turned off by default and must be enabled by a prior call to &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt;.</source>
          <target state="translated">보안상의 이유로로드 된 확장은 기본적으로 해제되어 있으며 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 에 대한 사전 호출로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4880044a5796d62d55405bede28ef5f4f52805b" translate="yes" xml:space="preserve">
          <source>For security reasons, extension loading is turned off by default. In order to use either the C-language or SQL extension loading functions, one must first enable extension loading using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,1,NULL) C-language API in your application.</source>
          <target state="translated">보안상의 이유로 확장 프로그램로드는 기본적으로 해제되어 있습니다. C 언어 또는 SQL 확장로드 기능을 사용하려면 먼저 응용 프로그램에서 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt; , 1, NULL) C 언어 API를 사용하여 확장로드를 사용 가능하게해야합니다 .</target>
        </trans-unit>
        <trans-unit id="92cbc8f2d6b97260523c5a56f27aa3c653ce65fe" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, include a &quot;+&quot; sign before positive numbers. A &quot;-&quot; sign always appears before negative numbers regardless of flag settings.</source>
          <target state="translated">부호있는 숫자 대체의 경우 양수 앞에 &quot;+&quot;부호를 포함하십시오. 플래그 설정에 관계없이 &quot;-&quot;기호는 항상 음수 앞에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0a389ef1f84e1f5ea12705422f16f304415d7e84" translate="yes" xml:space="preserve">
          <source>For signed numeric substitutions, prepend a single space before positive numbers.</source>
          <target state="translated">부호있는 숫자 대체의 경우 양수 앞에 단일 공백을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8361cfb2d567750344a1d16c228e8f02d706a6ad" translate="yes" xml:space="preserve">
          <source>For simple queries against a single table with few indexes, there is usually an obvious choice for the best algorithm. But for larger and more complex queries, such as multi-way joins with many indexes and subqueries, there can be hundreds, thousands, or millions of reasonable algorithms for computing the result. The job of the query planner is to choose the single &quot;best&quot; query plan from this multitude of possibilities.</source>
          <target state="translated">인덱스가 적은 단일 테이블에 대한 간단한 쿼리의 경우 일반적으로 최상의 알고리즘을 선택하는 것이 분명합니다. 그러나 많은 인덱스 및 하위 쿼리와의 다 방향 조인과 같은 더 크고 복잡한 쿼리의 경우 결과 계산을위한 수백, 수천 또는 수백만 개의 합리적인 알고리즘이있을 수 있습니다. 쿼리 플래너의 역할은이 다양한 가능성 중에서 단일 &quot;최상의&quot;쿼리 계획을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9d77b186d3d3bf7ae8219371bcb8b76fedae519" translate="yes" xml:space="preserve">
          <source>For small databases and modern CPUs, there is usually no reason not to pass &quot;--sample 100&quot;. However, gathering data distribution statistics can be expensive for large database tables. If the operation is too slow, try passing a smaller value for the --sample option.</source>
          <target state="translated">소규모 데이터베이스 및 최신 CPU의 경우 일반적으로 &quot;--sample 100&quot;을 통과하지 않을 이유가 없습니다. 그러나 큰 데이터베이스 테이블의 경우 데이터 분산 통계를 수집하면 비용이 많이들 수 있습니다. 작업이 너무 느리면 --sample 옵션에 더 작은 값을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a4a24ddee4d5daf8ddd5ba8dfd7d48787ebb03b7" translate="yes" xml:space="preserve">
          <source>For string substitutions (%s, %z, %q, %Q, or %w) the precision is the number of byte or character used from the argument. The number is bytes by default but is characters if the &quot;!&quot; flag is present. If there is no precision, then the entire string is substituted. Examples: &quot;%.3s&quot; substitutes the first 3 bytes of the argument string. &quot;%!.3s&quot; substitutes the first three characters of the argument string.</source>
          <target state="translated">문자열 대체 (% s, % z, % q, % Q 또는 % w)의 경우 정밀도는 인수에서 사용 된 바이트 또는 문자 수입니다. 기본적으로 숫자는 바이트이지만 &quot;!&quot; 플래그가 존재합니다. 정밀도가 없으면 전체 문자열이 대체됩니다. 예 : &quot;% .3s&quot;는 인수 문자열의 처음 3 바이트를 대체합니다. &quot;% !. 3s&quot;는 인수 문자열의 처음 세 문자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e7573ff9c5daeb6537cacfee96e59061a43495a3" translate="yes" xml:space="preserve">
          <source>For subprograms, there is a bitmask in the VdbeFrame that determines whether or not the jump should be taken. The bitmask is necessary because the self-altering code trick does not work for recursive triggers.</source>
          <target state="translated">서브 프로그램의 경우 VdbeFrame에는 점프를 수행할지 여부를 결정하는 비트 마스크가 있습니다. 자체 변경 코드 트릭은 재귀 트리거에 작동하지 않기 때문에 비트 마스크가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1ef6b92612835372e131287be2c793df5805bcf9" translate="yes" xml:space="preserve">
          <source>For table columns, the datatype is determined by the type declaration of the CREATE TABLE statement. The datatype is text if and only if the type declaration contains one or more of the following strings:</source>
          <target state="translated">테이블 컬럼의 경우, 데이터 유형은 CREATE TABLE 문의 유형 선언에 의해 결정됩니다. 데이터 유형은 유형 선언에 다음 문자열 중 하나 이상이 포함 된 경우에만 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="7117d5cbbb5730360ccac5d30c1470b52beef293" translate="yes" xml:space="preserve">
          <source>For testing on embedded systems, the mkth3.tcl script and the compiler steps shown above are performed on an ordinary workstation using a cross-compiler, then the resulting test program is transferred onto the device to be run.</source>
          <target state="translated">임베디드 시스템에서 테스트하기 위해 mkth3.tcl 스크립트와 위에 표시된 컴파일러 단계는 크로스 컴파일러를 사용하여 일반 워크 스테이션에서 수행 된 후 결과 테스트 프로그램이 실행될 장치로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="d2eb4ede923268e657583d146fd6fd411d8b52aa" translate="yes" xml:space="preserve">
          <source>For the --insert command, all files listed are inserted into the archive. For the --update command, files are only inserted if they do not previously exist in the archive, or if their &quot;mtime&quot; or &quot;mode&quot; is different from what is currently in the archive.</source>
          <target state="translated">--insert 명령의 경우 나열된 모든 파일이 아카이브에 삽입됩니다. --update 명령의 경우 파일이 이전에 아카이브에 없거나 &quot;mtime&quot;또는 &quot;mode&quot;가 현재 아카이브에있는 파일과 다른 경우에만 파일이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="0d9d2265812b12b9762e700ccc4ceb3931ebf930" translate="yes" xml:space="preserve">
          <source>For the C-language interfaces, the argument is an integer which is interpreted as a character. For the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; the argument is a string from which the first character is extracted and displayed.</source>
          <target state="translated">C 언어 인터페이스의 경우 인수는 문자로 해석되는 정수입니다. 내용 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;의 printf () SQL 함수&lt;/a&gt; 의 인수는 첫 번째 문자가 추출되어 표시되는 문자열이다.</target>
        </trans-unit>
        <trans-unit id="c95ceb997c597a8e6a21b33cbd1c20d5ac14d94b" translate="yes" xml:space="preserve">
          <source>For the GLOB operator, the column must be indexed using the built-in BINARY collating sequence.</source>
          <target state="translated">GLOB 연산자의 경우 내장 BINARY 조합 순서를 사용하여 열을 색인화해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b7943406433a1489b27536ff1cedb40c6a83fc4" translate="yes" xml:space="preserve">
          <source>For the LIKE operator, if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is enabled then the column must indexed using BINARY collating sequence, or if &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; mode is disabled then the column must indexed using built-in NOCASE collating sequence.</source>
          <target state="translated">LIKE 연산자의 경우 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; 모드가 사용 가능한 경우 BINARY 조합 순서를 사용하여 열을 색인화해야하거나 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;case_sensitive_like&lt;/a&gt; 모드가 사용 불가능한 경우 내장 NOCASE 조합 순서를 사용하여 열이 색인화되어야합니다.</target>
        </trans-unit>
        <trans-unit id="394b73aae0d0953d9f85a4d75a67f00c2d16e226" translate="yes" xml:space="preserve">
          <source>For the SELECT statement above, the optimizer can use the ex2i1 index to lookup rows of ex2 that contain x=5 and then test each row against the y=6 term. Or it can use the ex2i2 index to lookup rows of ex2 that contain y=6 then test each of those rows against the x=5 term.</source>
          <target state="translated">위의 SELECT 문에서 옵티마이 저는 ex2i1 색인을 사용하여 x = 5를 포함하는 ex2의 행을 찾은 다음 y = 6 항에 대해 각 행을 테스트 할 수 있습니다. 또는 ex2i2 색인을 사용하여 y = 6을 포함하는 ex2의 행을 찾은 다음 x = 5 항에 대해 각 행을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6880a2956aa62196c20844c37991ebf1c9cc0265" translate="yes" xml:space="preserve">
          <source>For the character substitution (%c) a precision N greater than 1 causes the character to be repeated N times. This is a non-standard extension found only in SQLite.</source>
          <target state="translated">문자 치환 (% c)의 경우 1보다 큰 정밀도 N은 문자가 N 번 반복되도록합니다. 이것은 SQLite에서만 발견되는 비표준 확장입니다.</target>
        </trans-unit>
        <trans-unit id="cbfa8c438ab75aa5b53746b3a61a2493fdc0fcad" translate="yes" xml:space="preserve">
          <source>For the common case where we want the busy callback to sleep, the SQLite library provides a convenience routine &lt;b&gt;sqlite_busy_timeout&lt;/b&gt;. The first argument to &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; is a pointer to an open SQLite database and the second argument is a number of milliseconds. After &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; has been executed, the SQLite library will wait for the lock to clear for at least the number of milliseconds specified before it returns SQLITE_BUSY. Specifying zero milliseconds for the timeout restores the default behavior.</source>
          <target state="translated">통화 중 콜백을 휴면 상태로 유지하려는 일반적인 경우 SQLite 라이브러리는 편리한 루틴 &lt;b&gt;sqlite_busy_timeout을&lt;/b&gt; 제공합니다 . &lt;b&gt;sqlite_busy_timeout에&lt;/b&gt; 대한 첫 번째 인수 는 열린 SQLite 데이터베이스에 대한 포인터이고 두 번째 인수는 수 밀리 초입니다. &lt;b&gt;sqlite_busy_timeout&lt;/b&gt; 이 실행 된 후 SQLite 라이브러리는 SQLITE_BUSY를 리턴하기 전에 지정된 밀리 초 동안 잠금이 해제 될 때까지 대기합니다. 시간 초과에 0 밀리 초를 지정하면 기본 동작이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="77995af2794868d5e3e1a545ee53f68c9abf9c9a" translate="yes" xml:space="preserve">
          <source>For the index above and WHERE clause like this:</source>
          <target state="translated">위의 색인과 다음과 같은 WHERE 절의 경우 :</target>
        </trans-unit>
        <trans-unit id="bb541928f8f21ef53252b3fcd58c0333fdfa446f" translate="yes" xml:space="preserve">
          <source>For the most part, ordinary rowid tables and WITHOUT ROWID tables are interchangeable. But there are some additional restrictions on WITHOUT ROWID tables that do not apply to ordinary rowid tables:</source>
          <target state="translated">대부분의 경우 일반 rowid 테이블과 WITHOUT ROWID 테이블은 서로 호환됩니다. 그러나 WITHOUT ROWID 테이블에는 일반 rowid 테이블에 적용되지 않는 몇 가지 추가 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee902327ddee3eaa34014db30d1eb9d18663957" translate="yes" xml:space="preserve">
          <source>For the purpose of computing window functions, the result set of a query is divided into one or more &quot;partitions&quot;. A partition consists of all rows that have the same value for all terms of the PARTITION BY clause in the window-defn. If there is no PARTITION BY clause, then the entire result set of the query is a single partition. Window-function processing is performed separately for each partition.</source>
          <target state="translated">창 기능 계산을 위해 쿼리 결과 집합은 하나 이상의 &quot;파티션&quot;으로 나뉩니다. 파티션은 window-defn에서 PARTITION BY 절의 모든 용어에 대해 동일한 값을 갖는 모든 행으로 구성됩니다. PARTITION BY 절이 없으면 쿼리의 전체 결과 집합이 단일 파티션입니다. 창 기능 처리는 각 파티션마다 별도로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b3fd877f7b6778afbc1e68eb5017d97a2b27eeb2" translate="yes" xml:space="preserve">
          <source>For the purpose of the &lt;b&gt;sqlite_complete&lt;/b&gt; function, an SQL statement is complete if it ends in a semicolon.</source>
          <target state="translated">&lt;b&gt;sqlite_complete&lt;/b&gt; 함수 의 목적으로 SQL 문이 세미콜론으로 끝나면 SQL 문이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="3bdae1911eb2b3c855db66c9e8e796a26c988410" translate="yes" xml:space="preserve">
          <source>For the purposes of determining duplicate rows for the results of compound SELECT operators, NULL values are considered equal to other NULL values and distinct from all non-NULL values. The collation sequence used to compare two text values is determined as if the columns of the left and right-hand SELECT statements were the left and right-hand operands of the equals (=) operator, except that greater precedence is not assigned to a collation sequence specified with the postfix COLLATE operator. No affinity transformations are applied to any values when comparing rows as part of a compound SELECT.</source>
          <target state="translated">복합 SELECT 연산자의 결과에 대한 중복 행을 결정하기 위해 NULL 값은 다른 NULL 값과 같으며 NULL이 아닌 모든 값과는 다른 것으로 간주됩니다. 두 개의 텍스트 값을 비교하는 데 사용되는 데이터 정렬 시퀀스는 왼쪽 및 오른쪽 SELECT 문의 열이 등호 (=) 연산자의 왼쪽 및 오른쪽 피연산자 인 것처럼 결정됩니다 (단, 더 큰 우선 순위가 데이터 정렬에 할당되지 않음) 접미사 COLLATE 연산자로 지정된 순서. 복합 SELECT의 일부로 행을 비교할 때는 선호도 변환이 값에 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="593804fd692754b9bd9050d15e0853bf78663ff7" translate="yes" xml:space="preserve">
          <source>For the purposes of determining validity, leading and trailing whitespace on JSON inputs is ignored. Interior whitespace is also ignored, in accordance with the JSON spec. These routines accept exactly the &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON syntax&lt;/a&gt; &amp;mdash; no more and no less.</source>
          <target state="translated">유효성을 확인하기 위해 JSON 입력의 선행 및 후행 공백은 무시됩니다. JSON 사양에 따라 내부 공백도 무시됩니다. 이 루틴은 &lt;a href=&quot;http://www.rfc-editor.org/rfc/rfc7159.txt&quot;&gt;rfc-7159 JSON 구문을&lt;/a&gt; 그대로 받아들 입니다.</target>
        </trans-unit>
        <trans-unit id="4f71629a5f8d309dcb7934e2a9e496e90193e44f" translate="yes" xml:space="preserve">
          <source>For the purposes of sorting rows, values are compared in the same way as for &lt;a href=&quot;datatype3#comparisons&quot;&gt;comparison expressions&lt;/a&gt;. The collation sequence used to compare two text values is determined as follows:</source>
          <target state="translated">행을 정렬하기 위해 &lt;a href=&quot;datatype3#comparisons&quot;&gt;비교 표현식&lt;/a&gt; 과 같은 방식으로 값을 비교합니다 . 두 텍스트 값을 비교하는 데 사용되는 데이터 정렬 순서는 다음과 같이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="15ea441aee0df5dfef81b948679ce855bde68d24" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous four items, two database connections that use the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which enable &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection, not separate database connections.</source>
          <target state="translated">이전 4 개 항목의 목적 상, 동일한 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 를 사용하고 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; 를 가능하게 하는 두 개의 데이터베이스 연결은 별도의 데이터베이스 연결이 아니라 동일한 데이터베이스 연결로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="206270d8fd15072121eb3d0a56144d865640f2b5" translate="yes" xml:space="preserve">
          <source>For the purposes of the previous two paragraphs, two database connections that have the same &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; and which have enabled &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted&lt;/a&gt; are considered to be the same database connection.</source>
          <target state="translated">이전 두 단락의 목적을 위해 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 가 동일 하고 &lt;a href=&quot;pragma#pragma_read_uncommitted&quot;&gt;PRAGMA read_uncommitted를&lt;/a&gt; 활성화 한 두 데이터베이스 연결 은 동일한 데이터베이스 연결로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a17e59e38b9d3bf2b2df3849089638f1437b4d1e" translate="yes" xml:space="preserve">
          <source>For the purposes of this API, a transaction is said to have been rolled back if an explicit &quot;ROLLBACK&quot; statement is executed, or an error or constraint causes an implicit rollback to occur. The rollback callback is not invoked if a transaction is automatically rolled back because the database connection is closed.</source>
          <target state="translated">이 API의 목적 상, 명시적인 &quot;ROLLBACK&quot;문이 실행되거나 오류 또는 제한 조건으로 인해 내재적 롤백이 발생하면 트랜잭션이 롤백되었다고합니다. 데이터베이스 연결이 닫혀서 트랜잭션이 자동으로 롤백되면 롤백 콜백이 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57f69f1f3e95239c1d08d8e626c461a431a40ba6" translate="yes" xml:space="preserve">
          <source>For the purposes of this pragma, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is considered a schema change, since &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; will usual alter the &quot;rootpage&quot; values for entries in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;.</source>
          <target state="translated">이 pragma의 목적으로 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령은 스키마 변경으로 간주됩니다. &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 은 일반적으로 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블의&lt;/a&gt; 항목에 대한 &quot;루트 페이지&quot;값을 변경하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="4e03b6c7391fbf0bc56188a8c09cd4a7c0b4cdfb" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">이 루틴의 목적 상, &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 는 나중에 롤백 되더라도 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4c58e719af76025bd3937a17763f87efc5e13c1f" translate="yes" xml:space="preserve">
          <source>For the purposes of this routine, an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; is considered to be successful even if it is subsequently rolled back.</source>
          <target state="translated">이 루틴의 목적 상, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 는 나중에 롤백 되더라도 성공한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="713e891998daa01c37d2616d81cfb2bf2962ac1e" translate="yes" xml:space="preserve">
          <source>For the right-hand table of a LEFT JOIN, compute the values of expressions directly rather than loading precomputed values out of an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt; as the expression index might not contain the correct value. Ticket &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</source>
          <target state="translated">LEFT JOIN의 오른쪽 테이블의 경우 &lt;a href=&quot;expridx&quot;&gt;식 인덱스&lt;/a&gt; 에 올바른 값이 포함되어 있지 않을 수 있으므로 식 인덱스에서 미리 계산 된 값을로드하지 않고 식의 값을 직접 계산 하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/7fa8049685b50b5aeb0c2&quot;&gt;7fa8049685b50b5aeb0c2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5c9ca201b99a3489f4b36f53a1d0536e05b123a3" translate="yes" xml:space="preserve">
          <source>For the second case, when the table already exists, every row of the CSV file, including the first row, is assumed to be actual content. If the CSV file contains an initial row of column labels, that row will be read as data and inserted into the table. To avoid this, make sure that table does not previously exist.</source>
          <target state="translated">두 번째 경우, 테이블이 이미 존재하면 첫 번째 행을 포함하여 CSV 파일의 모든 행이 실제 컨텐츠 인 것으로 가정합니다. CSV 파일에 열 레이블의 초기 행이 포함 된 경우 해당 행은 데이터로 읽히고 테이블에 삽입됩니다. 이를 피하려면 테이블이 이전에 존재하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="814f69ac0546d66f0db75207e5064bf283a12829" translate="yes" xml:space="preserve">
          <source>For these reasons, many complex queries may use less memory and run faster using FTS5.</source>
          <target state="translated">이러한 이유로 많은 복잡한 쿼리는 메모리를 적게 사용하고 FTS5를 사용하여 더 빠르게 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fe943bac7177b3cc26bc016acdb488812414486" translate="yes" xml:space="preserve">
          <source>For these substitutions, the precision is the number of bytes or characters taken from the argument, not the number of bytes or characters that are written into the output.</source>
          <target state="translated">이러한 대체의 경우 정밀도는 출력에 기록되는 바이트 또는 문자 수가 아닌 인수에서 가져온 바이트 또는 문자 수입니다.</target>
        </trans-unit>
        <trans-unit id="ddecb7fc6ac9ebf678a969f318e2c93050dc15ef" translate="yes" xml:space="preserve">
          <source>For this first experiment, nothing else about the file format is changed. The OpenDocument is still a pile-of-files, only now each file is a row in an SQLite database rather than an entry in a ZIP archive. This simple change does not use the power of a relational database. Even so, this simple change shows some improvements.</source>
          <target state="translated">이 첫 번째 실험에서는 파일 형식에 대한 다른 내용이 변경되지 않았습니다. OpenDocument는 여전히 파일 더미이며, 이제는 각 파일 만 ZIP 아카이브의 항목이 아니라 SQLite 데이터베이스의 행입니다. 이 간단한 변경은 관계형 데이터베이스의 힘을 사용하지 않습니다. 그럼에도 불구하고이 간단한 변화는 약간의 개선점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fbfd34ac3082b66cb73eae2395605bfffd9afee2" translate="yes" xml:space="preserve">
          <source>For this form, the &amp;lt;expr&amp;gt; does not have to be an integer. It can evaluate to a real number as long as it is constant and non-negative.</source>
          <target state="translated">이 형식의 경우 &amp;lt;expr&amp;gt;은 정수일 필요는 없습니다. 일정하고 음이 아닌 한 실수로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="752d2cd19688f392b69d1efc9ea4707b6423ad4e" translate="yes" xml:space="preserve">
          <source>For this particular UPDATE test, MySQL is consistently five or ten times slower than PostgreSQL and SQLite. I do not know why. MySQL is normally a very fast engine. Perhaps this problem has been addressed in later versions of MySQL.</source>
          <target state="translated">이 특정 UPDATE 테스트의 경우 MySQL은 PostgreSQL 및 SQLite보다 일관되게 5-10 배 느립니다. 이유를 모르겠습니다. MySQL은 일반적으로 매우 빠른 엔진입니다. 아마도이 문제는 이후 버전의 MySQL에서 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="9db0e6302461b7556c4838a4a6492fc335414fcc" translate="yes" xml:space="preserve">
          <source>For usage hints and a summary of all options, simply give the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; the -A option with no additional arguments:</source>
          <target state="translated">사용법 힌트 및 모든 옵션 요약을 보려면 추가 인수없이 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에 -A 옵션을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c9239816897eb996f78a6efe04536d4eaf0b8d55" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be an integer. If the value in P1 is not an integer and cannot be converted into an integer without data loss, then jump immediately to P2, or if P2==0 raise an SQLITE_MISMATCH exception.</source>
          <target state="translated">레지스터 P1의 값을 정수로 만듭니다. P1의 값이 정수가 아니고 데이터 손실없이 정수로 변환 될 수 없으면 즉시 P2로 건너 뛰거나 P2 == 0 인 경우 SQLITE_MISMATCH 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e1652af1b46a8724b09c6398e58d043cf684e88e" translate="yes" xml:space="preserve">
          <source>Force the value in register P1 to be the type defined by P2.</source>
          <target state="translated">레지스터 P1의 값이 P2에 의해 정의 된 유형이되도록합니다.</target>
        </trans-unit>
        <trans-unit id="c3788028d350f50070224e2ffa767d1574a8ab2d" translate="yes" xml:space="preserve">
          <source>Foreign Key Constraints</source>
          <target state="translated">외래 키 제약</target>
        </trans-unit>
        <trans-unit id="8ea9876246ba7c653355a0ce27076bc76b4c8469" translate="yes" xml:space="preserve">
          <source>Foreign key ON DELETE and ON UPDATE clauses are used to configure actions that take place when deleting rows from the parent table (ON DELETE), or modifying the parent key values of existing rows (ON UPDATE). A single foreign key constraint may have different actions configured for ON DELETE and ON UPDATE. Foreign key actions are similar to triggers in many ways.</source>
          <target state="translated">외래 키 ON DELETE 및 ON UPDATE 절은 부모 테이블에서 행을 삭제하거나 (ON DELETE) 기존 행의 부모 키 값을 수정 (ON UPDATE) 할 때 수행되는 작업을 구성하는 데 사용됩니다. 단일 외래 키 제약 조건은 ON DELETE 및 ON UPDATE에 대해 서로 다른 동작을 구성 할 수 있습니다. 외래 키 동작은 여러 가지면에서 트리거와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="474365badbb1f3b57e5eb366037b4f712db8f5d1" translate="yes" xml:space="preserve">
          <source>Foreign key actions</source>
          <target state="translated">외래 핵심 행동</target>
        </trans-unit>
        <trans-unit id="d3465e4f63b19b36c358f39673e35fd218b96287" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are disabled by default (for backwards compatibility), so must be enabled separately for each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. (Note, however, that future releases of SQLite might change so that foreign key constraints enabled by default. Careful developers will not make any assumptions about whether or not foreign keys are enabled by default but will instead enable or disable them as necessary.) The application can also use a &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement to determine if foreign keys are currently enabled. The following command-line session demonstrates this:</source>
          <target state="translated">외래 키 제약 조건은 기본적으로 비활성화되어 있으므로 (이전 버전과의 호환성을 위해) 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 별도로 활성화해야합니다 . 그러나 이후의 SQLite 릴리스에서는 기본적으로 외래 키 제약 조건이 활성화되도록 변경 될 수 있습니다.주의 깊은 개발자는 외래 키가 기본적으로 활성화되어 있는지 여부를 가정하지 않고 대신 필요에 따라 외래 키를 활성화하거나 비활성화합니다. 응용 프로그램은 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; 문을 사용하여 외래 키가 현재 활성화되어 있는지 확인할 수 있습니다. 다음 명령 줄 세션에서이를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fadb49ecb31870fa195b79a63507d69332246c87" translate="yes" xml:space="preserve">
          <source>Foreign key constraints are enabled</source>
          <target state="translated">외래 키 제약 조건이 활성화되었습니다</target>
        </trans-unit>
        <trans-unit id="ce28942b103c42389428127f519c6795e562c011" translate="yes" xml:space="preserve">
          <source>Format 1 is understood by all versions of SQLite back to &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;version 3.0.0&lt;/a&gt; (2004-06-18).</source>
          <target state="translated">형식 1은 모든 버전의 SQLite에서 &lt;a href=&quot;https://sqlite.org/releaselog/3_0_0.html&quot;&gt;버전 3.0.0&lt;/a&gt; (2004-06-18)으로 다시 이해됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb846b850c6fa3ff33f8d13f455d688d28aa22d8" translate="yes" xml:space="preserve">
          <source>Format 2 adds the ability of rows within the same table to have a varying number of columns, in order to support the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; functionality. Support for reading and writing format 2 was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;version 3.1.3&lt;/a&gt; on 2005-02-20.</source>
          <target state="translated">형식 2는 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; 기능 을 지원하기 위해 동일한 테이블 내의 행이 다양한 수의 열을 갖도록하는 기능을 추가 합니다. 읽기 및 쓰기 형식 2에 대한 지원은 2005-02-20의 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_3.html&quot;&gt;버전 3.1.3&lt;/a&gt; 에서 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e74a0202e30c00da07d8e3f647ad619d797750ee" translate="yes" xml:space="preserve">
          <source>Format 3 adds the ability of extra columns added by &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; to have non-NULL default values. This capability was added in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;version 3.1.4&lt;/a&gt; on 2005-03-11.</source>
          <target state="translated">형식 3은 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; 에 의해 추가 된 추가 열 이 NULL이 아닌 기본값을 갖도록합니다. 이 기능은 2005-03-11의 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_1_4.html&quot;&gt;버전 3.1.4&lt;/a&gt; 에서 추가 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6f87214a5c89d4a264dcabc8b3ff76d0ecb7e6ab" translate="yes" xml:space="preserve">
          <source>Format 4 causes SQLite to respect the &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC keyword&lt;/a&gt; on index declarations. (The DESC keyword is ignored in indexes for formats 1, 2, and 3.) Format 4 also adds two new boolean record type values (&lt;a href=&quot;fileformat2#serialtype&quot;&gt;serial types&lt;/a&gt; 8 and 9). Support for format 4 was added in SQLite 3.3.0 on 2006-01-10.</source>
          <target state="translated">형식 4는 SQLite가 인덱스 선언 에서 &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC 키워드&lt;/a&gt; 를 존중하게합니다 . (DESC 키워드는 형식 1, 2 및 3의 색인에서 무시됩니다.) 형식 4는 두 개의 새로운 부울 레코드 유형 값 ( &lt;a href=&quot;fileformat2#serialtype&quot;&gt;직렬 유형&lt;/a&gt; 8 및 9) 도 추가합니다 . 형식 4에 대한 지원이 2006-01-10의 SQLite 3.3.0에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d2e4ea8f983e7648b4500b3c2517f1581f43edb0" translate="yes" xml:space="preserve">
          <source>Formats 2 through 10 may be optionally followed by a timezone indicator of the form &quot;</source>
          <target state="translated">형식 2부터 10까지는 선택적으로 &quot;&quot;형식의 시간대 표시기가 올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff2a0eb4d03de61d70053787eab6804fcec445da" translate="yes" xml:space="preserve">
          <source>Formatted String Printing Functions</source>
          <target state="translated">형식화 된 문자열 인쇄 기능</target>
        </trans-unit>
        <trans-unit id="73cdbab7825af4beabbe4e8fccce8b346886e89f" translate="yes" xml:space="preserve">
          <source>Fossil gives me peace of mind that I have everything ... synced to the server with a single command.... I never get this peace of mind with git.</source>
          <target state="translated">화석은 하나의 명령으로 서버에 동기화 된 모든 것을 가지고 있다는 확신을주었습니다 .... 나는 결코 git으로 마음의 평화를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="968f45bf8ccf7ca67b780b2bdd22df3354350003" translate="yes" xml:space="preserve">
          <source>Fossil is a completely stand-alone program, so install it simply by putting the &quot;fossil&quot; or &quot;fossil.exe&quot; executable someplace on your $PATH or %PATH%. After you have Fossil installed, do this:</source>
          <target state="translated">Fossil은 완전 독립형 프로그램이므로 &quot;FOssil&quot;또는 &quot;fossil.exe&quot;실행 파일을 $ PATH 또는 % PATH %에 설치하면됩니다. 화석을 설치 한 후 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="94257cd970f113fc11ecc5cc6011f7bfff67e319" translate="yes" xml:space="preserve">
          <source>Fossil is easy to install and use. Here are the steps for unix. (Windows is similar.)</source>
          <target state="translated">화석은 설치 및 사용이 쉽습니다. 유닉스에 대한 단계는 다음과 같습니다. (Windows도 비슷합니다.)</target>
        </trans-unit>
        <trans-unit id="233904fc6b6c8ee70d33af66e4cb04bfc0af5c1f" translate="yes" xml:space="preserve">
          <source>Fossil vs. Git</source>
          <target state="translated">화석 대 Git</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="a9521a3d73988a064707ebf1e7a52b3d8155b49c" translate="yes" xml:space="preserve">
          <source>Frame boundary</source>
          <target state="translated">프레임 경계</target>
        </trans-unit>
        <trans-unit id="77433082b8e51b0f02140d5bb2ad80c6960db0b1" translate="yes" xml:space="preserve">
          <source>Frame type</source>
          <target state="translated">프레임 타입</target>
        </trans-unit>
        <trans-unit id="6e84d556b35797f261b67f9c140d77ba6a16046e" translate="yes" xml:space="preserve">
          <source>Free Memory Used By A Database Connection</source>
          <target state="translated">데이터베이스 연결에 사용 된 여유 메모리</target>
        </trans-unit>
        <trans-unit id="c3f00513ee103316a9c102f8d540f97f3d93a05d" translate="yes" xml:space="preserve">
          <source>Freelist leaf pages contain no information. SQLite avoids reading or writing freelist leaf pages in order to reduce disk I/O.</source>
          <target state="translated">프리리스트 리프 페이지에는 정보가 없습니다. SQLite는 디스크 I / O를 줄이기 위해 프리리스트 리프 페이지를 읽거나 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71c292b702c9c6ddbea2af4ccdda270456dc5dd4" translate="yes" xml:space="preserve">
          <source>Frequent inserts, updates, and deletes can cause the database file to become fragmented - where data for a single table or index is scattered around the database file. Running VACUUM ensures that each table and index is largely stored contiguously within the database file. In some cases, VACUUM may also reduce the number of partially filled pages in the database, reducing the size of the database file further.</source>
          <target state="translated">빈번한 삽입, 업데이트 및 삭제로 인해 데이터베이스 파일이 조각 날 수 있습니다. 단일 테이블 또는 인덱스에 대한 데이터가 데이터베이스 파일 주위에 분산되어 있습니다. VACUUM을 실행하면 각 테이블과 인덱스가 데이터베이스 파일 내에 연속적으로 저장됩니다. 경우에 따라 VACUUM은 데이터베이스에서 부분적으로 채워진 페이지 수를 줄여 데이터베이스 파일의 크기를 더 줄일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d790b402d79ac1a723c790313bcd679999474630" translate="yes" xml:space="preserve">
          <source>Frequently Asked Questions</source>
          <target state="translated">자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="4dca8789d725335eabc320e5fd334c48abe46050" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, extensions can be loaded using the &quot;.load&quot; dot-command. For example:</source>
          <target state="translated">로부터 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; , 확장은 &quot;.load&quot;점 명령을 사용하여로드 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9622d74f0a066cde3991b933210f9d9f6547b468" translate="yes" xml:space="preserve">
          <source>From the point of view of a single process, a database file can be in one of five locking states:</source>
          <target state="translated">단일 프로세스의 관점에서 데이터베이스 파일은 5 가지 잠금 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2bf6ce9c451768f240ac82fe10e69d266839161" translate="yes" xml:space="preserve">
          <source>From the point of view of the uppers layers of the SQLite stack, each open database file uses exactly one VFS. But in practice, a particular VFS might just be a thin wrapper around another VFS that does the real work. We call a wrapper VFS a &quot;shim&quot;.</source>
          <target state="translated">SQLite 스택의 상위 계층 관점에서 볼 때 열려있는 각 데이터베이스 파일은 정확히 하나의 VFS를 사용합니다. 그러나 실제로 특정 VFS는 실제 작업을 수행하는 다른 VFS를 둘러싼 얇은 래퍼 일 수 있습니다. 래퍼 VFS를 &quot;심&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b51b364d89abfa3baa92bcc31eb6e45de7419ef6" translate="yes" xml:space="preserve">
          <source>From the users point of view, FTS tables are similar to ordinary SQLite tables in many ways. Data may be added to, modified within and removed from FTS tables using the INSERT, UPDATE and DELETE commands just as it may be with ordinary tables. Similarly, the SELECT command may be used to query data. The following list summarizes the differences between FTS and ordinary tables:</source>
          <target state="translated">사용자 관점에서 FTS 테이블은 여러 가지면에서 일반 SQLite 테이블과 유사합니다. INSERT, UPDATE 및 DELETE 명령을 사용하여 일반 테이블에서와 마찬가지로 FTS 테이블에서 데이터를 추가, 수정 및 제거 할 수 있습니다. 마찬가지로 SELECT 명령을 사용하여 데이터를 쿼리 할 수 ​​있습니다. 다음 목록은 FTS와 일반 테이블의 차이점을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="27c4a8e9b8642a933f67723d0e4be1b9a0f44d80" translate="yes" xml:space="preserve">
          <source>From this we get the following output</source>
          <target state="translated">이것으로부터 우리는 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2180268f2a9a9fda782b57bf8e01a18a029a7a96" translate="yes" xml:space="preserve">
          <source>Fulfill God's commandments daily in your deeds.</source>
          <target state="translated">당신의 행동으로 매일 하나님의 계명을 완수하십시오.</target>
        </trans-unit>
        <trans-unit id="b471a096b84cc0494684e033a051e31af5d4baaa" translate="yes" xml:space="preserve">
          <source>Fulfill not the desires of the flesh; hate your own will.</source>
          <target state="translated">육체의 욕망을 충족시키지 마십시오. 자신의 의지를 싫어하십시오.</target>
        </trans-unit>
        <trans-unit id="c55154da9bee9185f44dff21df8abc2c3aabdcae" translate="yes" xml:space="preserve">
          <source>Full unicode case folding is supported in SQLite if it is compiled with the &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; option and linked against the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; library.</source>
          <target state="translated">전체 유니 코드 케이스 폴딩은 &lt;a href=&quot;compile#enable_icu&quot;&gt;-DSQLITE_ENABLE_ICU&lt;/a&gt; 옵션으로 컴파일되고 &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; 라이브러리에 링크 된 경우 SQLite에서 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="90b0c8025a15a6f38263adcf72861e6ab67a9305" translate="yes" xml:space="preserve">
          <source>Full-Featured SQL</source>
          <target state="translated">모든 기능을 갖춘 SQL</target>
        </trans-unit>
        <trans-unit id="9e0f1c37b71547a59fac0e69533c4df840ff38fe" translate="yes" xml:space="preserve">
          <source>Full-Text Search</source>
          <target state="translated">전문 검색</target>
        </trans-unit>
        <trans-unit id="369603a7ebe96771eca2b1d07435e9996bd963f3" translate="yes" xml:space="preserve">
          <source>Full-text search</source>
          <target state="translated">전체 텍스트 검색</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="9365da4d7427ae049cd7228599ffdbf56ca765df" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; is called to clean up resources allocated by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt;.</source>
          <target state="translated">기능 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish은 ()&lt;/a&gt; 에 의해 할당 정리 자원에 대한라고 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6ee739a58d0601e439d67d32ce677eb6f284f6f0" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data between the two databases (either from a file and into the in-memory database, or vice-versa).</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; 함수 는 &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 를 작성 하여 두 데이터베이스 사이에서 파일과 메모리 내 데이터베이스로 또는 그 반대로 데이터를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="3518bc62cbd77290edb8df852902f3d26b669db7" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; is called to create an &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; object to copy data from database pDb to the backup database file identified by zFilename.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; 함수 는 &lt;a href=&quot;c3ref/backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 를 작성하여 데이터베이스 pDb에서 zFilename으로 식별 된 백업 데이터베이스 파일로 데이터를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="391bd2c3bef8e5815ac8dc9e143dc5e9f29edc4b" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of 5 to copy 5 pages of database pDb to the backup database (file zFilename).</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 함수 는 매개 변수 5로 호출되어 데이터베이스 pDb의 5 페이지를 백업 데이터베이스 (파일 zFilename)에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="38d0016fe914d4211802e56c1b039ba739bf3a21" translate="yes" xml:space="preserve">
          <source>Function &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; is called with a parameter of &lt;code&gt;-1&lt;/code&gt; to copy the entire source database to the destination.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 함수 는 매개 변수 &lt;code&gt;-1&lt;/code&gt; 로 호출되어 전체 소스 데이터베이스를 대상으로 복사합니다.</target>
        </trans-unit>
        <trans-unit id="a019467e942226e7593baeafe04451d52208ddbd" translate="yes" xml:space="preserve">
          <source>Function Auxiliary Data</source>
          <target state="translated">기능 보조 데이터</target>
        </trans-unit>
        <trans-unit id="95b0294dd891e754097881615649b65fc6ba31c5" translate="yes" xml:space="preserve">
          <source>Function Flags</source>
          <target state="translated">기능 플래그</target>
        </trans-unit>
        <trans-unit id="17555700d9f22f47c91cbb0e6dcdac3a03a90e07" translate="yes" xml:space="preserve">
          <source>Function implementations use the following APIs to acquire context and to report results:</source>
          <target state="translated">함수 구현은 다음 API를 사용하여 컨텍스트를 획득하고 결과를보고합니다.</target>
        </trans-unit>
        <trans-unit id="7db899803172ac5c12cb30190a927b06044d501c" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">sqlite3_backup_step (B, N) 함수는 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 B에 의해 지정된 소스 및 대상 데이터베이스 사이에서 최대 N 페이지를 복사 합니다. N이 음수이면 나머지 모든 소스 페이지가 복사됩니다. sqlite3_backup_step (B, N)이 N 페이지를 성공적으로 복사하고 여전히 복사 할 페이지가 더 있으면 함수는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . sqlite3_backup_step (B, N)이 모든 페이지를 소스에서 대상으로 복사를 완료하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; 을 리턴합니다 . sqlite3_backup_step (B, N)을 실행하는 동안 오류가 발생하면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴됩니다. 뿐만 아니라 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 및 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; , sqlite3_backup_step ()에 대한 호출이 반환 할 수 있습니다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; ,&lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; 확장 오류 코드.</target>
        </trans-unit>
        <trans-unit id="9255837a8368562d39b56b025c25a117e386acd6" translate="yes" xml:space="preserve">
          <source>Function sqlite3_backup_step(B,N) will copy up to N pages between the source and destination databases specified by &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object B. If N is negative, all remaining source pages are copied. If sqlite3_backup_step(B,N) successfully copies N pages and there are still more pages to be copied, then the function returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If sqlite3_backup_step(B,N) successfully finishes copying all pages from source to destination, then it returns &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. If an error occurs while running sqlite3_backup_step(B,N), then an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. As well as &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, a call to sqlite3_backup_step() may return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt;, or an &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; extended error code.</source>
          <target state="translated">sqlite3_backup_step (B, N) 함수는 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 B에 의해 지정된 소스 및 대상 데이터베이스 사이에서 최대 N 페이지를 복사 합니다. N이 음수이면 나머지 모든 소스 페이지가 복사됩니다. sqlite3_backup_step (B, N)이 N 페이지를 성공적으로 복사하고 여전히 복사 할 페이지가 더 있으면 함수는 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . sqlite3_backup_step (B, N)이 모든 페이지를 소스에서 대상으로 복사를 완료하면 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; 을 리턴합니다 . sqlite3_backup_step (B, N)을 실행하는 동안 오류가 발생하면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴됩니다. 뿐만 아니라 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 및 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; , sqlite3_backup_step ()에 대한 호출이 반환 할 수 있습니다 &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; ,&lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; , &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; 확장 오류 코드.</target>
        </trans-unit>
        <trans-unit id="02506e4ca51a17167d74a2f8b901e6d46a621915" translate="yes" xml:space="preserve">
          <source>Function sqlite3rbu_step() is called on the RBU handle until either the RBU vacuum is finished, an error occurs or the application wishes to suspend the RBU vacuum.</source>
          <target state="translated">sqlite3rbu_step () 함수는 RBU 진공이 완료되거나 오류가 발생하거나 응용 프로그램이 RBU 진공을 일시 중단하려고 할 때까지 RBU 핸들에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c29dbde42f9e09b5fa1fe9e874978bd60461ca23" translate="yes" xml:space="preserve">
          <source>Function0</source>
          <target state="translated">Function0</target>
        </trans-unit>
        <trans-unit id="885fce7082ac7fe77b80dbde8d190b12ddbee6ea" translate="yes" xml:space="preserve">
          <source>Functionality Testing</source>
          <target state="translated">기능 테스트</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a1198fbca49df3b9353761343f6ab00ba7526e3" translate="yes" xml:space="preserve">
          <source>Functions:</source>
          <target state="translated">Functions:</target>
        </trans-unit>
        <trans-unit id="1ddc4309220e5ca80653bda487622cf643ea376d" translate="yes" xml:space="preserve">
          <source>Fundamental Datatypes</source>
          <target state="translated">기본 데이터 유형</target>
        </trans-unit>
        <trans-unit id="f728c83ebd508ddfa64fa9b670d3c24c116a1c08" translate="yes" xml:space="preserve">
          <source>Further performance improves can be made by using the &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; feature of SQLite. In the next chart, the entire 1GB database file is memory mapped and blobs are read (in random order) using the &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; interface. With these optimizations, SQLite is twice as fast as Android or MacOS-X and over 10 times faster than Windows.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;mmap&quot;&gt;메모리 매핑 된 I / O&lt;/a&gt; 기능을 사용하면 성능을 더욱 향상시킬 수 있습니다 . 다음 차트에서 전체 1GB 데이터베이스 파일은 메모리 매핑되고 &lt;a href=&quot;c3ref/blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 인터페이스를 사용하여 블로 브 를 임의 순서대로 읽습니다 . 이러한 최적화를 통해 SQLite는 Android 또는 MacOS-X보다 2 배 빠르며 Windows보다 10 배 이상 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="215d209e37d2a11fed7e914dfee16f71ee55be90" translate="yes" xml:space="preserve">
          <source>Further suppose that column x contains values spread out between 0 and 1,000,000 and column y contains values that span between 0 and 1,000. In that scenario, the range constraint on column x should reduce the search space by a factor of 10,000 whereas the range constraint on column y should reduce the search space by a factor of only 10. So the ex2i1 index should be preferred.</source>
          <target state="translated">또한 x 열에 0에서 1,000,000 사이의 값이 포함되고 y 열에 0에서 1,000 사이의 값이 포함되어 있다고 가정합니다. 이 시나리오에서 x 열의 범위 제한은 검색 공간을 10,000 배로 줄여야하는 반면 y 열의 범위 제한은 검색 공간을 10 배로 줄여야합니다. 따라서 ex2i1 색인이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="09aabcfb38f7cb10806136de02a602b19c076fd6" translate="yes" xml:space="preserve">
          <source>Further to keeping &lt;b&gt;n&lt;/b&gt; small, one desires to keep the size of the largest memory allocations under control. Large requests to the general-purpose memory allocator might come from several sources:</source>
          <target state="translated">&lt;b&gt;n을&lt;/b&gt; 작게 유지하는 것 외에도, 가장 큰 메모리 할당의 크기를 제어하기를 원한다. 범용 메모리 할당 자에 대한 대량 요청은 여러 소스에서 온 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a74f247651044b2313a36316a7929616b6d570a" translate="yes" xml:space="preserve">
          <source>Furthermore, a single SQLite database holding 10-kilobyte blobs uses about 20% less disk space than storing the blobs in individual files.</source>
          <target state="translated">또한 10KB의 Blob을 보유한 단일 SQLite 데이터베이스는 개별 파일에 Blob을 저장하는 것보다 디스크 공간을 약 20 % 적게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8bd50359d3a17558a2d398e2f44b82ca134e4e80" translate="yes" xml:space="preserve">
          <source>Future releases may add new output columns and may change the order of legacy columns. Further detail about the meaning of each column in the SQLITE_STMT virtual table is provided below:</source>
          <target state="translated">향후 릴리스에서는 새로운 출력 열이 추가 될 수 있으며 레거시 열의 순서가 변경 될 수 있습니다. SQLITE_STMT 가상 테이블에서 각 열의 의미에 대한 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6831b46470717c86c7d25cb9cedff9f9bee20302" translate="yes" xml:space="preserve">
          <source>Future releases of SQLite might enable those interfaces by default and instead offer an SQLITE_OMIT_DESERIALIZE option to leave them out.</source>
          <target state="translated">이후 릴리스의 SQLite는 기본적으로 해당 인터페이스를 사용 가능하게하고 대신 SQLITE_OMIT_DESERIALIZE 옵션을 제공하여이를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="69eed414fd6ede90f6e232a4b640df2129c7213e" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite may extend the list of errors which might cause automatic transaction rollback. Future versions of SQLite might change the error response. In particular, we may choose to simplify the interface in future versions of SQLite by causing the errors above to force an unconditional rollback.</source>
          <target state="translated">이후 버전의 SQLite는 오류 목록을 확장하여 자동 트랜잭션 롤백을 유발할 수 있습니다. 이후 버전의 SQLite는 오류 응답을 변경할 수 있습니다. 특히, 위의 오류로 인해 무조건 롤백이 발생하도록하여 향후 버전의 SQLite에서 인터페이스를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0b58ce3a5e420ed148b6052399ca3a065dfe3cb" translate="yes" xml:space="preserve">
          <source>Future versions of SQLite might enable the batch-atomic-write capability by default, at which point this compile-time option will become superfluous.</source>
          <target state="translated">이후 버전의 SQLite는 기본적으로 일괄 원자 쓰기 기능을 활성화 할 수 있으며이 시점에서이 컴파일 타임 옵션이 불필요 해집니다.</target>
        </trans-unit>
        <trans-unit id="7aac4860a695a884103c23bef4fe10cea8ac21a0" translate="yes" xml:space="preserve">
          <source>Fuzz tests</source>
          <target state="translated">퍼지 테스트</target>
        </trans-unit>
        <trans-unit id="cbf13864eb622e042fd70afc25b332a98febed1d" translate="yes" xml:space="preserve">
          <source>GCC-7 generates binaries that are smaller and faster than GCC-5, though the difference is not that great.</source>
          <target state="translated">GCC-7은 GCC-5보다 작고 빠른 이진 파일을 생성하지만 그 차이는 크지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c1c8852a41864ea17cea1296e10f38e7d36f590" translate="yes" xml:space="preserve">
          <source>GIT - Git source code repository</source>
          <target state="translated">GIT-Git 소스 코드 저장소</target>
        </trans-unit>
        <trans-unit id="801660e770a91f34fb13ac91a9b5cbd2d98c6d3a" translate="yes" xml:space="preserve">
          <source>GLOB</source>
          <target state="translated">GLOB</target>
        </trans-unit>
        <trans-unit id="ea5a383494f81c4f464965d03bf916c41d68ced5" translate="yes" xml:space="preserve">
          <source>GROUP</source>
          <target state="translated">GROUP</target>
        </trans-unit>
        <trans-unit id="992f3cd91fffb522eba0b5e27b68c643f2967283" translate="yes" xml:space="preserve">
          <source>GROUP BY now considers NULLs to be equal again, as it should</source>
          <target state="translated">GROUP BY는 이제 NULL을 다시 같은 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="1f8969d436579977f5b13e27e290ffdb25736672" translate="yes" xml:space="preserve">
          <source>GROUPS</source>
          <target state="translated">GROUPS</target>
        </trans-unit>
        <trans-unit id="47abf252888b506642430a87f17ad2e364853ea7" translate="yes" xml:space="preserve">
          <source>GROUPS frames</source>
          <target state="translated">그룹 프레임</target>
        </trans-unit>
        <trans-unit id="5023fde21a93efcc45f3ef1278a03020db274d7f" translate="yes" xml:space="preserve">
          <source>Ge</source>
          <target state="translated">Ge</target>
        </trans-unit>
        <trans-unit id="5f5383c13d2f60a6733afafdeaf91505cfcc253b" translate="yes" xml:space="preserve">
          <source>Generalized ALTER TABLE procedure</source>
          <target state="translated">일반화 된 ALTER TABLE 프로 시저</target>
        </trans-unit>
        <trans-unit id="200f1a824c74356136271be8f5cec761b8361890" translate="yes" xml:space="preserve">
          <source>Generalized the IS and IS NOT operators to take arbitrary expressions on their right-hand side.</source>
          <target state="translated">IS 및 IS NOT 연산자를 일반화하여 오른쪽에 임의의 표현을 취했습니다.</target>
        </trans-unit>
        <trans-unit id="b3419155244f27d32ab3d7f4be3add6bd08da9d5" translate="yes" xml:space="preserve">
          <source>Generally speaking, there are three separate subsystems within SQLite that can be modified or overridden at compile-time. The mutex subsystem is used to serialize access to SQLite resources that are shared among threads. The memory allocation subsystem is used to allocate memory required by SQLite objects and for the database cache. Finally, the &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; subsystem is used to provide a portable interface between SQLite and the underlying operating system and especially the file system. We call these three subsystems the &quot;interface&quot; subsystems of SQLite.</source>
          <target state="translated">일반적으로 SQLite에는 컴파일 타임에 수정하거나 재정의 할 수있는 세 개의 개별 하위 시스템이 있습니다. mutex 서브 시스템은 스레드간에 공유되는 SQLite 자원에 대한 액세스를 직렬화하는 데 사용됩니다. 메모리 할당 서브 시스템은 SQLite 오브젝트 및 데이터베이스 캐시에 필요한 메모리를 할당하는 데 사용됩니다. 마지막으로 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 하위 시스템은 SQLite와 기본 운영 체제, 특히 파일 시스템 간의 이식 가능한 인터페이스를 제공하는 데 사용됩니다. 우리는이 세 가지 서브 시스템을 SQLite의 &quot;인터페이스&quot;서브 시스템이라고합니다.</target>
        </trans-unit>
        <trans-unit id="03b11aad395b9bb3b854450c1f0acff0112439bd" translate="yes" xml:space="preserve">
          <source>Generate A Changeset From A Session Object</source>
          <target state="translated">세션 객체에서 변경 세트 생성</target>
        </trans-unit>
        <trans-unit id="771f6c81129288bd0dca35edc653f4896b8a38b9" translate="yes" xml:space="preserve">
          <source>Generate A Patchset From A Session Object</source>
          <target state="translated">세션 객체에서 패치 세트 생성</target>
        </trans-unit>
        <trans-unit id="c543fcc61a656cc087657032229c13b299493cc4" translate="yes" xml:space="preserve">
          <source>Generate all multiples of 5 less than or equal to 100:</source>
          <target state="translated">100보다 작거나 같은 5의 배수를 모두 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="79e208b13cb09ea92286261229fb60357b5683cd" translate="yes" xml:space="preserve">
          <source>Generate the 20 random integer values:</source>
          <target state="translated">20 개의 임의의 정수 값을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="46614740c9601066a8714b11664b1eb75a5a0bb4" translate="yes" xml:space="preserve">
          <source>Generating the results of a simple SELECT statement is presented as a four step process in the description below:</source>
          <target state="translated">간단한 SELECT 문의 결과 생성은 아래 설명에서 4 단계 프로세스로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0060bdc4470d529ca18bce37edc0d7a0701d9b10" translate="yes" xml:space="preserve">
          <source>Geopoly</source>
          <target state="translated">Geopoly</target>
        </trans-unit>
        <trans-unit id="c4340d254981277ce14859ec23653c0dac4e3963" translate="yes" xml:space="preserve">
          <source>Geopoly operates on &quot;simple&quot; polygons - that is, polygons for which the boundary does not intersect itself. Geopoly thus extends the capabilities of the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; which can only deal with rectangular areas. On the other hand, the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; is able to handle between 1 and 5 coordinate dimensions, whereas Geopoly is restricted to 2-dimensional shapes only.</source>
          <target state="translated">Geopoly는 &quot;간단한&quot;다각형, 즉 경계가 서로 교차하지 않는 다각형에서 작동합니다. 따라서 Geopoly 는 직사각형 영역 만 처리 할 수 있는 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장 기능&lt;/a&gt; 을 확장 합니다. 반면 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 은 1에서 5까지의 좌표 치수를 처리 할 수있는 반면 Geopoly는 2 차원 형태로만 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6dd9a0429b5e12a110f96aed0989c67466586ea1" translate="yes" xml:space="preserve">
          <source>Geopoly stores all polygons internally using a binary format. A binary polygon consists of a 4-byte header following by an array of coordinate pairs in which each dimension of each coordinate is a 32-bit floating point number.</source>
          <target state="translated">Geopoly는 이진 형식을 사용하여 모든 다각형을 내부적으로 저장합니다. 이진 다각형은 각 좌표의 각 차원이 32 비트 부동 소수점 숫자 인 좌표 쌍 배열이 뒤에 오는 4 바이트 헤더로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="230fd79e9ac234b116998f305ec36a626773a0c1" translate="yes" xml:space="preserve">
          <source>Get a copy of the prebuilt binaries for your machine, or get a copy of the sources and compile them yourself. Visit the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download&lt;/a&gt; page for more information.</source>
          <target state="translated">머신의 사전 빌드 된 바이너리 사본을 얻거나 소스 사본을 가져 와서 직접 컴파일하십시오. 자세한 내용 은 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드&lt;/a&gt; 페이지를 방문 하십시오.</target>
        </trans-unit>
        <trans-unit id="f22b4172b2caeb752e5b6845137b0e1c3132162f" translate="yes" xml:space="preserve">
          <source>Get a new integer record number (a.k.a &quot;rowid&quot;) used as the key to a table. The record number is not previously used as a key in the database table that cursor P1 points to. The new record number is written written to register P2.</source>
          <target state="translated">테이블의 키로 사용되는 새로운 정수 레코드 번호 (일명 &quot;rowid&quot;)를 가져옵니다. 레코드 번호는 이전에 커서 P1이 가리키는 데이터베이스 테이블에서 키로 사용되지 않았습니다. 새로운 레코드 번호가 레지스터 P2에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8ad3eda2ae8758b9937a69c2cdf3d37bc6a82b" translate="yes" xml:space="preserve">
          <source>Get extension loading working on Cygwin.</source>
          <target state="translated">Cygwin에서 확장 로딩을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="70d300a9221d054ecf73f3a432c241cce5538fb1" translate="yes" xml:space="preserve">
          <source>Get the SQLITE_ENABLE_LOCKING_STYLE macro working again on Mac OS X.</source>
          <target state="translated">Mac OS X에서 SQLITE_ENABLE_LOCKING_STYLE 매크로를 다시 작동 시키십시오.</target>
        </trans-unit>
        <trans-unit id="191ab3ffcff8c3d125f02fa19cf1b4772a774563" translate="yes" xml:space="preserve">
          <source>Get the library working correctly when compiled with GCC option &quot;-fstrict-aliasing&quot;.</source>
          <target state="translated">GCC 옵션 &quot;-fstrict-aliasing&quot;으로 컴파일 할 때 라이브러리가 올바르게 작동하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="e33fe52a421a08f566920837d8eaa9b7577c26cc" translate="yes" xml:space="preserve">
          <source>Git allows you to go backwards in time easily. Given the latest check-in on a branch, Git lets you see all the ancestors of that check-in. But Git makes it difficult to move in the other direction. Given some historical check-in, it is quite challenging in Git to find out what came next. It can be done, but it is sufficiently difficult that people rarely do it. Common interfaces for Git, such as GitHub, do not support the ability.</source>
          <target state="translated">힘내 당신이 쉽게 시간을 거꾸로 갈 수 있습니다. 지점에서 최신 체크인을 한 경우 Git을 사용하면 해당 체크인의 모든 조상을 볼 수 있습니다. 그러나 Git은 다른 방향으로 움직이기가 어렵습니다. 역사적으로 체크인을한다면 Git에서 다음에 무엇이 올 것인지 알아내는 것은 매우 어려운 일입니다. 할 수는 있지만 사람들이 거의하지 않는 것은 충분히 어렵다. GitHub와 같은 Git의 공통 인터페이스는이 기능을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6fbc2ab6d8b00135f72a297ae81133b9c538d92" translate="yes" xml:space="preserve">
          <source>Git commands (and/or options on commands) for moving and comparing content between all of these locations.</source>
          <target state="translated">이 모든 위치 사이에서 컨텐츠를 이동하고 비교하기위한 Git 명령 (및 / 또는 명령 옵션).</target>
        </trans-unit>
        <trans-unit id="913e20aa0e82cacccbed30743753b5fea41f9dd9" translate="yes" xml:space="preserve">
          <source>Git is complex software. One needs an installer of some kind to put Git on a developer workstation, or to upgrade to a newer version of Git. Setting up a Git server is non-trivial, and so most users have to use a third-party service such as GitHub or GitLab, and thus introduce additional (unnecessary) dependencies into the project.</source>
          <target state="translated">힘내는 복잡한 소프트웨어입니다. 개발자 워크 스테이션에 Git을 설치하거나 최신 버전의 Git으로 업그레이드하려면 일종의 설치 프로그램이 필요합니다. Git 서버를 설정하는 것은 쉬운 일이 아니므로 대부분의 사용자는 GitHub 또는 GitLab과 같은 타사 서비스를 사용해야하므로 프로젝트에 추가 (필요하지 않은) 종속성을 도입해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee613d9b4f6dfc0f80be0bd2cfff2ea77808bbb6" translate="yes" xml:space="preserve">
          <source>Git keeps the complete DAG of the check-in sequence. But branch tags are local information that is not synced and not retained once a branch closes. This makes review of historical branches tedious.</source>
          <target state="translated">Git은 체크인 순서의 완전한 DAG를 유지합니다. 그러나 지점 태그는 지점이 닫히면 동기화되지 않고 유지되지 않는 로컬 정보입니다. 이것은 역사적 지점에 대한 검토를 지루하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="48b3160f0b763f1616179debce43562e664f02d9" translate="yes" xml:space="preserve">
          <source>GitHub and GitLab offer nothing comparable. The closest I have found is the &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;network&lt;/a&gt;, which is slow to render (unless it is already cached), does not offer nearly as much details, and scarcely works on mobile. The &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;commits&lt;/a&gt; view of GitHub provides more detail, renders quickly, and works on mobile, but only shows a single branch at a time, so I cannot easily know if I've seen all of the recent changes. And even if GitHub/GitLab did offer better interfaces, both are third-party services. They are not a core part of Git. Hence, using them introduces yet another dependency into the project.</source>
          <target state="translated">GitHub와 GitLab은 비교할만한 것을 제공하지 않습니다. 내가 찾은 가장 가까운 &lt;a href=&quot;https://github.com/sqlite/sqlite/network&quot;&gt;네트워크&lt;/a&gt; 는 렌더링이 느리고 (이미 캐시되지 않은 한) 거의 세부 정보를 제공하지 않으며 모바일에서 거의 작동하지 않습니다. GitHub 의 &lt;a href=&quot;https://github.com/sqlite/sqlite/commits/master&quot;&gt;커밋&lt;/a&gt; 보기는 더 자세한 정보를 제공하고 신속하게 렌더링하며 모바일에서 작동하지만 한 번에 하나의 지점 만 표시하므로 최근의 모든 변경 사항을 보았는지 쉽게 알 수 없습니다. 그리고 GitHub / GitLab이 더 나은 인터페이스를 제공 했더라도 타사 서비스입니다. 그것들은 Git의 핵심 부분이 아닙니다. 따라서 그것들을 사용하면 프로젝트에 또 다른 의존성이 생깁니다.</target>
        </trans-unit>
        <trans-unit id="ba7606fea498a9e876c11c77be2a94dc96cb33f9" translate="yes" xml:space="preserve">
          <source>Given a page number P and a maximum WAL frame index M, return the largest WAL frame index for page P that does not exceed M, or return NULL if there are no frames for page P that do not exceed M.</source>
          <target state="translated">페이지 번호 P와 최대 WAL 프레임 인덱스 M이 주어지면 M을 초과하지 않는 페이지 P에 대해 가장 큰 WAL 프레임 인덱스를 리턴하거나 페이지 P에 대해 M을 초과하지 않는 프레임이 없으면 NULL을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="d4a9375f517c74831802a20b14cf1be5743c9399" translate="yes" xml:space="preserve">
          <source>Given a single SQL statement, there might be dozens, hundreds, or even thousands of ways to implement that statement, depending on the complexity of the statement itself and of the underlying database schema. The task of the query planner is to select an algorithm from among the many choices that provides the answer with a minimum of disk I/O and CPU overhead.</source>
          <target state="translated">단일 SQL 문이 제공되면 명령문 자체와 기본 데이터베이스 스키마의 복잡도에 따라 해당 명령문을 구현하는 데 수십, 수백 또는 수천 가지 방법이있을 수 있습니다. 쿼리 플래너의 임무는 최소의 디스크 I / O 및 CPU 오버 헤드를 제공하는 다양한 선택 중에서 알고리즘을 선택하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6bcca46f0f74a9ae01ce42d9f7404d2419d51ad" translate="yes" xml:space="preserve">
          <source>Given all of the information above, the job of the xBestIndex method it to figure out the best way to search the virtual table.</source>
          <target state="translated">위의 모든 정보가 주어지면 xBestIndex 메서드의 작업은 가상 테이블을 검색하는 가장 좋은 방법을 찾는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3214b13dd0b542c059230864a7a5bcd2b12ab804" translate="yes" xml:space="preserve">
          <source>Given an input string X, this routine attempts to determine the dominant script of that input and returns the ISO-15924 numeric code for that script. The current implementation understands the following scripts:</source>
          <target state="translated">입력 문자열 X가 주어지면이 루틴은 해당 입력의 주요 스크립트를 판별하려고 시도하고 해당 스크립트의 ISO-15924 숫자 코드를 리턴합니다. 현재 구현은 다음 스크립트를 이해합니다.</target>
        </trans-unit>
        <trans-unit id="c57b59e0dd1b427eb5c7b60fabfb8b9d76033a70" translate="yes" xml:space="preserve">
          <source>Given the definition of X1 above, the following expressions have historically evaluated to FALSE in SQLite, though the correct answer is actually NULL:</source>
          <target state="translated">위의 X1의 정의를 감안할 때 다음 표현식은 역사적으로 SQLite에서 FALSE로 평가되었지만 정답은 실제로 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="bd2ada8cc33bdc4785b371a48d725c0e9ca58446" translate="yes" xml:space="preserve">
          <source>Given the new multi-column Idx3 index, it is now possible for SQLite to find the price of California oranges using only 2 binary searches:</source>
          <target state="translated">새로운 다중 열 Idx3 인덱스를 감안할 때 이제 SQLite는 2 개의 이진 검색 만 사용하여 캘리포니아 오렌지의 가격을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="617490ec40d56766edf8aff111990bee9834d1c1" translate="yes" xml:space="preserve">
          <source>Gosub</source>
          <target state="translated">Gosub</target>
        </trans-unit>
        <trans-unit id="0a9ffc4a328e6d21b11f3b8312d08e5b413aec49" translate="yes" xml:space="preserve">
          <source>Goto</source>
          <target state="translated">Goto</target>
        </trans-unit>
        <trans-unit id="1dee13ac09a18c736a85fb7212501ca3f0535655" translate="yes" xml:space="preserve">
          <source>Gt</source>
          <target state="translated">Gt</target>
        </trans-unit>
        <trans-unit id="60f4e65b35154fc853b0c67ac464ba87691c1af9" translate="yes" xml:space="preserve">
          <source>Guard your tongue against evil and depraved speech.</source>
          <target state="translated">악하고 타락한 말로부터 혀를 지키십시오.</target>
        </trans-unit>
        <trans-unit id="3472b7100ee6c34d2c985ec6e738e904962356df" translate="yes" xml:space="preserve">
          <source>HAVING</source>
          <target state="translated">HAVING</target>
        </trans-unit>
        <trans-unit id="a4c7ee9ba5c961273e153da9b6004699add74ac0" translate="yes" xml:space="preserve">
          <source>HH:MM</source>
          <target state="translated">HH:MM</target>
        </trans-unit>
        <trans-unit id="4a05a9c514dbbe7b13aeee7ffbbac9804dba7f74" translate="yes" xml:space="preserve">
          <source>HH:MM:SS</source>
          <target state="translated">HH:MM:SS</target>
        </trans-unit>
        <trans-unit id="4fe76e489c6dd906a0f1a9c53aab6e472da095e8" translate="yes" xml:space="preserve">
          <source>HH:MM:SS.SSS</source>
          <target state="translated">HH:MM:SS.SSS</target>
        </trans-unit>
        <trans-unit id="65f5a5cdef2d1220d932d3711961b5f933bef00b" translate="yes" xml:space="preserve">
          <source>HHHHHHHH</source>
          <target state="translated">HHHHHHHH</target>
        </trans-unit>
        <trans-unit id="cbc6ab8d850f8cff446447123804da23a703c293" translate="yes" xml:space="preserve">
          <source>Halt</source>
          <target state="translated">Halt</target>
        </trans-unit>
        <trans-unit id="c9efb4e35e5411aedaf0542890d4f34de7fdc553" translate="yes" xml:space="preserve">
          <source>HaltIfNull</source>
          <target state="translated">HaltIfNull</target>
        </trans-unit>
        <trans-unit id="eda901a16a2ed9d0d0e178d305fa51f41c885dd9" translate="yes" xml:space="preserve">
          <source>Has the same PRIMARY KEY definition.</source>
          <target state="translated">동일한 기본 키 정의를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="7b3c15bec716c58e30bb9a01cc52d490760b69bf" translate="yes" xml:space="preserve">
          <source>Has the same name,</source>
          <target state="translated">이름이 같고</target>
        </trans-unit>
        <trans-unit id="96ee9d0e4b354db6f1aac2ad6a31abd4bc3e74ca" translate="yes" xml:space="preserve">
          <source>Has the same set of columns declared in the same order, and</source>
          <target state="translated">동일한 순서로 동일한 열 집합이 선언되어 있으며</target>
        </trans-unit>
        <trans-unit id="71024d7461751155928cb62c4bbb4edb8155f4cb" translate="yes" xml:space="preserve">
          <source>Hate no one.</source>
          <target state="translated">아무도 싫어</target>
        </trans-unit>
        <trans-unit id="f5e9b1bebb569eb2b57a7ab4d85d0681e37d4262" translate="yes" xml:space="preserve">
          <source>Having SQLite take ownership of the type strings would impose a performance cost on all applications, even applications that do not use the pointer-passing interfaces. SQLite passes values around as instances of the &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value&lt;/a&gt; object. That object has a destructor, which because of the fact that sqlite3_value objects are used for nearly everything, is invoked frequently. If the destructor needs to check to see if there is a pointer type string that needs to be freed, that is a few extra CPU cycles that need to be burned on each call to the destructor. Those cycles add up. We would be willing to bear the cost of the extra CPU cycles if pointer-passing was a commonly used programming paradigm, but pointer-passing is rare, and so it seems unwise to impose a run-time cost on billions and billions of applications that do not use pointer passing just for convenience of a few applications that do.</source>
          <target state="translated">SQLite가 형식 문자열의 소유권을 갖도록하면 포인터 전달 인터페이스를 사용하지 않는 응용 프로그램까지도 모든 응용 프로그램에 성능 비용이 부과됩니다. SQLite는 &lt;a href=&quot;c3ref/value&quot;&gt;sqlite3_value의&lt;/a&gt; 인스턴스로 값을 전달합니다.목적. 이 객체에는 소멸자가 있습니다. sqlite3_value 객체가 거의 모든 용도로 사용되기 때문에 자주 호출됩니다. 소멸자가 해제해야하는 포인터 유형 문자열이 있는지 확인해야하는 경우 소멸자를 호출 할 때마다 레코딩해야하는 추가 CPU주기가 몇 개 있습니다. 그 사이클이 더해집니다. 포인터 전달이 일반적으로 사용되는 프로그래밍 패러다임 인 경우 추가 CPU주기의 비용을 부담 할 의향이 있지만 포인터 전달이 드물기 때문에 수십억 및 수십억 개의 응용 프로그램에 런타임 비용을 부과하는 것은 현명하지 않은 것 같습니다. 몇 가지 응용 프로그램의 편의를 위해 포인터 전달을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3880fcd08d24da661937a86693cfca26882a3b4e" translate="yes" xml:space="preserve">
          <source>Hazards of upgrading to the NGQP</source>
          <target state="translated">NGQP 로의 업그레이드 위험</target>
        </trans-unit>
        <trans-unit id="5050e4d38d7df11eb3b253f0629fcc46c260dc76" translate="yes" xml:space="preserve">
          <source>Header string: 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7</source>
          <target state="translated">헤더 문자열 : 0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7</target>
        </trans-unit>
        <trans-unit id="4bc19fb4af9f917cd00992c6391f45202ff0d0ec" translate="yes" xml:space="preserve">
          <source>Hence, a good rule of thumb is that your database schema should never contain two indices where one index is a prefix of the other. Drop the index with fewer columns. SQLite will still be able to do efficient lookups with the longer index.</source>
          <target state="translated">따라서 데이터베이스 스키마에는 한 인덱스가 다른 인덱스의 접두사 인 두 개의 인덱스를 포함해서는 안된다는 것이 좋습니다. 더 적은 열로 인덱스를 삭제하십시오. SQLite는 여전히 더 긴 인덱스로 효율적인 조회를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3f076946ec3be55b66dffc59ab395c4e63eeb8f" translate="yes" xml:space="preserve">
          <source>Hence, by adding extra &quot;output&quot; columns onto the end of an index, one can avoid having to reference the original table and thereby cut the number of binary searches for a query in half. This is a constant-factor improvement in performance (roughly a doubling of the speed). But on the other hand, it is also just a refinement; A two-fold performance increase is not nearly as dramatic as the one-million-fold increase seen when the table was first indexed. And for most queries, the difference between 1 microsecond and 2 microseconds is unlikely to be noticed.</source>
          <target state="translated">따라서 인덱스 끝에 추가 &quot;출력&quot;열을 추가하면 원래 테이블을 참조하지 않아도되므로 쿼리에 대한 이진 검색 수를 절반으로 줄일 수 있습니다. 이것은 성능의 지속적인 요소 개선 (대략 속도의 두 배)입니다. 그러나 다른 한편으로, 그것은 또한 단지 개선 일뿐입니다. 2 배의 성능 향상은 테이블을 처음 인덱스 할 때 백만배 증가한 것만 큼 크게 크지 않습니다. 그리고 대부분의 쿼리에서 1 마이크로 초와 2 마이크로 초의 차이는 눈에 띄지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="b665f7a53251e88b80c18ae95a6e2a7570ff2c9e" translate="yes" xml:space="preserve">
          <source>Hence, in comparison to other approaches, the use of an SQLite database as an application file format has compelling advantages. Here are a few of these advantages, enumerated and expounded:</source>
          <target state="translated">따라서 다른 접근 방식과 비교하여 SQLite 데이터베이스를 응용 프로그램 파일 형식으로 사용하면 강력한 이점이 있습니다. 다음은 이러한 장점 중 몇 가지를 열거하고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="39e8db1d33a3457396e45de0c0793052727a641e" translate="yes" xml:space="preserve">
          <source>Hence, the content encoding for a WITHOUT ROWID table is the same as the content encoding for an ordinary rowid table, except that the order of the columns is rearranged so that PRIMARY KEY columns come first, and the content is used as the key in an index b-tree rather than as the data in a table b-tree. The special encoding rules for columns with REAL affinity apply to WITHOUT ROWID tables the same as they do with rowid tables.</source>
          <target state="translated">따라서 WITHOUT ROWID 테이블의 컨텐츠 인코딩은 일반 rowid 테이블의 컨텐츠 인코딩과 동일하지만 PRIMARY KEY 컬럼이 먼저 오도록 컬럼 순서가 재 배열되고 컨텐츠가 테이블 b- 트리의 데이터가 아닌 인덱스 b- 트리. REAL 선호도가있는 열의 특수 인코딩 규칙은 rowid 테이블에서와 동일하게 WITHOUT ROWID 테이블에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="999cfa83416c7b736dc3f3dfa6e7f25b9ba6e98f" translate="yes" xml:space="preserve">
          <source>Here again, version 2.7.0 of SQLite used to run at about the same speed as MySQL. But now version 2.7.6 is over two times faster than MySQL and over twenty times faster than PostgreSQL.</source>
          <target state="translated">여기서도 SQLite 버전 2.7.0은 MySQL과 거의 같은 속도로 실행되었습니다. 그러나 이제 버전 2.7.6은 MySQL보다 2 배, PostgreSQL보다 20 배 이상 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="c79a9d1055558ef2d9992c6424392d62b259c2a6" translate="yes" xml:space="preserve">
          <source>Here are some existing and postulated uses for virtual tables:</source>
          <target state="translated">다음은 가상 테이블에 대한 기존 및 가정 된 사용법입니다.</target>
        </trans-unit>
        <trans-unit id="f0580ad7def68334eac7c2c033faae47fa33aa31" translate="yes" xml:space="preserve">
          <source>Here are the syntax details:</source>
          <target state="translated">구문 세부 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c84ee5f5403083ecda923ec1470b2d4f31fd0f00" translate="yes" xml:space="preserve">
          <source>Here is a complete template extension that you can copy/paste to get started:</source>
          <target state="translated">다음은 시작하기 위해 복사 / 붙여 넣기 할 수있는 완전한 템플릿 확장입니다.</target>
        </trans-unit>
        <trans-unit id="537d394cf0d1eecb92a9cbe8efc7e1a703bdd18e" translate="yes" xml:space="preserve">
          <source>Here is a query that computes the average height over everyone in Alice's organization, including Alice:</source>
          <target state="translated">다음은 Alice를 포함하여 Alice 조직의 모든 사람에 대한 평균 키를 계산하는 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="dd42feed9698b376dcb10e9aa54e385c734b65a6" translate="yes" xml:space="preserve">
          <source>Here is a query to show the tree structure in a breadth-first pattern:</source>
          <target state="translated">다음은 너비 우선 패턴으로 트리 구조를 보여주는 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="b68ea20ab0a8004dffe949b080033114856a05ba" translate="yes" xml:space="preserve">
          <source>Here is a simple example of omitting a LEFT JOIN:</source>
          <target state="translated">LEFT JOIN을 생략하는 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22d888f42ada11de3c14b5860a924536cf19b222" translate="yes" xml:space="preserve">
          <source>Here is a slightly different way to describe the aPgno values: If you think of all aPgno values as a contiguous array, then the database page number stored in the i-th frame of the WAL file is stored in aPgno[i]. Of course, aPgno is not a contiguous array. The first 4062 entries are on the first 32768-byte unit of the shm file and subsequent values are in 4096 entry chunks in later units of the shm file.</source>
          <target state="translated">다음은 aPgno 값을 설명하는 약간 다른 방법입니다. 모든 aPgno 값을 연속 배열로 생각하면 WAL 파일의 i 번째 프레임에 저장된 데이터베이스 페이지 번호가 aPgno [i]에 저장됩니다. 물론 aPgno는 연속 배열이 아닙니다. 첫 번째 4062 항목은 shm 파일의 첫 번째 32768 바이트 단위에 있으며 후속 값은 shm 파일의 이후 단위에서 4096 개의 입력 청크에 있습니다.</target>
        </trans-unit>
        <trans-unit id="eeed83aeb26a72a7167e0caa92d0a130551072b7" translate="yes" xml:space="preserve">
          <source>Here is a summary of what the core interfaces do:</source>
          <target state="translated">핵심 인터페이스의 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a2373a91d98c2486bbd1ed6e2138a7e77394ed5" translate="yes" xml:space="preserve">
          <source>Here is a variation on the previous example:</source>
          <target state="translated">이전 예의 변형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1319ba3fc57ef36ac27efdbc47123bdd4cb7f431" translate="yes" xml:space="preserve">
          <source>Here is an alternative description of the same computation:</source>
          <target state="translated">동일한 계산에 대한 대체 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44eacff0724c9f996876f69099ca0b2726a97ade" translate="yes" xml:space="preserve">
          <source>Here is an alternative way of describing the hash look-up algorithm: Start with h = (P * 383)%8192 and look at aHash[h] and subsequent entries, wrapping around to zero when h reaches 8192, until finding an entry with aHash[h]==0. All aPgno entries having a page number of P will have an index that is one of the aHash[h] values thusly computed. But not all the computed aHash[h] values will meet the matching criteria, so you must check them independently. The speed advantage comes about because normally this set of h values is very small.</source>
          <target state="translated">해시 조회 알고리즘을 설명하는 다른 방법은 다음과 같습니다. h = (P * 383) % 8192로 시작하여 aHash [h] 및 후속 항목을 확인합니다. 해시 [h] == 0. 페이지 번호가 P 인 모든 aPgno 항목에는 계산 된 aHash [h] 값 중 하나 인 인덱스가 있습니다. 그러나 모든 계산 된 aHash [h] 값이 일치 기준을 충족하지는 않으므로 독립적으로 확인해야합니다. 일반적으로이 h 값 세트가 매우 작기 때문에 속도 이점이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a49c4bb8c6fe24c99e1160edbe5f45003dd833d" translate="yes" xml:space="preserve">
          <source>Here is an example using the built-in row_number() window function:</source>
          <target state="translated">다음은 내장 row_number () 창 함수를 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="1ed2d64e0577782df2f1f708b1c461ee5ebea46a" translate="yes" xml:space="preserve">
          <source>Here is what is going to happen: The first SELECT statement will construct rows of the result and save each row as the key of an entry in the transient table. The data for each entry in the transient table is a never used so we fill it in with an empty string. The second SELECT statement also constructs rows, but the rows constructed by the second SELECT are removed from the transient table. That is why we want the rows to be stored in the key of the SQLite file instead of in the data -- so they can be easily located and deleted.</source>
          <target state="translated">다음과 같은 상황이 발생합니다. 첫 번째 SELECT 문은 결과의 행을 구성하고 각 행을 임시 테이블의 항목 키로 저장합니다. 임시 테이블의 각 항목에 대한 데이터는 사용되지 않으므로 빈 문자열로 채 웁니다. 두 번째 SELECT 문도 행을 구성하지만 두 번째 SELECT로 구성된 행은 임시 테이블에서 제거됩니다. 그렇기 때문에 행이 데이터가 아닌 SQLite 파일의 키에 저장되기를 원하므로 쉽게 찾고 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a844050eead2e7f9a21cd042c8a0efba1c399bc" translate="yes" xml:space="preserve">
          <source>Here is what the program must do. First it has to locate all of the records in the table &quot;examp&quot; that are to be deleted. This is done using a loop very much like the loop used in the SELECT examples above. Once all records have been located, then we can go back through and delete them one by one. Note that we cannot delete each record as soon as we find it. We have to locate all records first, then go back and delete them. This is because the SQLite database backend might change the scan order after a delete operation. And if the scan order changes in the middle of the scan, some records might be visited more than once and other records might not be visited at all.</source>
          <target state="translated">프로그램이해야 할 일은 다음과 같습니다. 먼저 &quot;examp&quot;테이블에서 삭제할 모든 레코드를 찾아야합니다. 이것은 위의 SELECT 예제에서 사용 된 루프와 매우 유사한 루프를 사용하여 수행됩니다. 모든 기록을 찾은 후에는 다시 돌아가서 하나씩 삭제할 수 있습니다. 각 레코드를 찾 자마자 삭제할 수는 없습니다. 먼저 모든 레코드를 찾은 다음 돌아가서 삭제해야합니다. 삭제 조작 후 SQLite 데이터베이스 백엔드가 스캔 순서를 변경할 수 있기 때문입니다. 스캔 중간에 스캔 순서가 변경되면 일부 레코드가 두 번 이상 방문되고 다른 레코드가 전혀 방문되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed0e64b4172a16a9716e7e75ddd35007c4f6e5a" translate="yes" xml:space="preserve">
          <source>Here is what you do to start experimenting with SQLite without having to do a lot of tedious reading and configuration:</source>
          <target state="translated">많은 지루한 읽기 및 구성을 수행하지 않고도 SQLite를 실험하기 시작하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c11a956fd1daf361e07b9a2963b5331668a6cb09" translate="yes" xml:space="preserve">
          <source>Here the apostrophe has been escaped and the SQL statement is well-formed. When generating SQL on-the-fly from data that might contain a single-quote character ('), it is always a good idea to use the SQLite printf routines and the %q formatting option instead of &lt;b&gt;sprintf&lt;/b&gt;.</source>
          <target state="translated">여기서 아포스트로피가 이스케이프되었으며 SQL 문이 올바르게 구성되었습니다. 작은 따옴표 문자 ( ')를 포함 할 수있는 데이터에서 SQL을 즉석에서 생성 할 때는 항상 &lt;b&gt;sprintf&lt;/b&gt; 대신 SQLite printf 루틴 및 % q 형식 옵션을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="53844b42e0f15c4e9c92f326da701e5edff51b64" translate="yes" xml:space="preserve">
          <source>Here the inequalities are on columns x and y which are not the left-most index columns. Hence, the histogram data which is collected no left-most column of indices is useless in helping to choose between the range constraints on columns x and y.</source>
          <target state="translated">여기서 불평등은 가장 왼쪽의 인덱스 열이 아닌 x 및 y 열에 있습니다. 따라서, 가장 왼쪽의 열 열에서 수집되지 않은 히스토그램 데이터는 열 x와 y의 범위 제한 중에서 선택하는 데 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="54b1a90f72334cf67c79da3608b8cff7cc194a79" translate="yes" xml:space="preserve">
          <source>Hexadecimal</source>
          <target state="translated">Hexadecimal</target>
        </trans-unit>
        <trans-unit id="f3f781093bc605abee81ccbeb636a20f530bbe5d" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals</source>
          <target state="translated">16 진 정수 리터럴</target>
        </trans-unit>
        <trans-unit id="35e13960711ca47c62471d92f2b4029ee7852496" translate="yes" xml:space="preserve">
          <source>Hexadecimal integer literals follow the C-language notation of &quot;0x&quot; or &quot;0X&quot; followed by hexadecimal digits. For example, 0x1234 means the same as 4660 and 0x8000000000000000 means the same as -9223372036854775808. Hexadecimal integer literals are interpreted as 64-bit two's-complement integers and are thus limited to sixteen significant digits of precision. Support for hexadecimal integers was added to SQLite version 3.8.6 (2014-08-15). For backwards compatibility, the &quot;0x&quot; hexadecimal integer notation is only understood by the SQL language parser, not by the type conversions routines. String variables that contain text formatted like hexadecimal integers are not interpreted as hexadecimal integers when coercing the string value into an integer due to a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; or for a &lt;a href=&quot;datatype3#affinity&quot;&gt;column affinity&lt;/a&gt; transformation or prior to performing a numeric operation or for any other run-time conversions. When coercing a string value in the format of a hexadecimal integer into an integer value, the conversion process stops when the 'x' character is seen so the resulting integer value is always zero. SQLite only understands the hexadecimal integer notation when it appears in the SQL statement text, not when it appears as part of the content of the database.</source>
          <target state="translated">16 진 정수 리터럴은 &quot;0x&quot;또는 &quot;0X&quot;의 C 언어 표기법 뒤에 16 진 숫자를 따릅니다. 예를 들어 0x1234는 4660과 동일하고 0x8000000000000000은 -9223372036854775808과 동일합니다. 16 진 정수 리터럴은 64 비트 2의 보수 정수로 해석되므로 16 자리의 유효 자릿수로 제한됩니다. 16 진수 정수에 대한 지원이 SQLite 버전 3.8.6 (2014-08-15)에 추가되었습니다. 이전 버전과의 호환성을 위해 &quot;0x&quot;16 진 정수 표기법은 형식 변환 루틴이 아니라 SQL 언어 파서 만 이해합니다.&lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식&lt;/a&gt; 또는 &lt;a href=&quot;datatype3#affinity&quot;&gt;열 선호도 로 인해 문자열 값을 정수로 강제 변환 할 때 16 진 정수와 같은 형식의 텍스트를 포함하는 문자열 변수는 16 진 정수로 해석되지 않습니다.&lt;/a&gt;변환 또는 숫자 연산을 수행하기 전 또는 기타 런타임 변환을 위해. 16 진 정수 형식의 문자열 값을 정수 값으로 강제 변환 할 때 'x'문자가 표시되면 변환 프로세스가 중지되므로 결과 정수 값은 항상 0입니다. SQLite는 16 진수 정수 표기법이 데이터베이스 내용의 일부로 나타날 때가 아니라 SQL 문 텍스트에 나타날 때만 이해합니다.</target>
        </trans-unit>
        <trans-unit id="4413e5afdd76b08f7a57f3501dcd353af75c6909" translate="yes" xml:space="preserve">
          <source>Hexadecimal integers</source>
          <target state="translated">16 진 정수</target>
        </trans-unit>
        <trans-unit id="34ad49fd08b5d8ebfe6309e8a94dbdda68560346" translate="yes" xml:space="preserve">
          <source>Hidden column</source>
          <target state="translated">숨겨진 열</target>
        </trans-unit>
        <trans-unit id="47adea5ce487ea3890476b37d1c95b4a2f866391" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the expansion of a &quot;*&quot; expression in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, and</source>
          <target state="translated">숨겨진 열은 결과 집합에서 &quot;*&quot;표현의 확장에 포함되지 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 및</target>
        </trans-unit>
        <trans-unit id="20096dd8d3b8c2cfd4d3a69c38df377eed777771" translate="yes" xml:space="preserve">
          <source>Hidden columns are not included in the implicit column-list used by an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that lacks an explicit column-list.</source>
          <target state="translated">숨겨진 열은 명시적인 열 목록이없는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문에서 사용하는 암시 적 열 목록에 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b7668a93e533ae2c015270865d5e714d07d437f1" translate="yes" xml:space="preserve">
          <source>Hidden columns are not listed in the dataset returned by &quot;&lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt;&quot;,</source>
          <target state="translated">숨겨진 열은 &quot; &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; &quot;에 의해 반환 된 데이터 집합에 나열되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c4cf7b97c327f9d39106315e4a050c0b0f137cef" translate="yes" xml:space="preserve">
          <source>Hierarchical Query Examples</source>
          <target state="translated">계층 적 쿼리 예</target>
        </trans-unit>
        <trans-unit id="62ae978c372dd625e1ad5bee3c09efecd27ef87c" translate="yes" xml:space="preserve">
          <source>High Reliability</source>
          <target state="translated">높은 신뢰성</target>
        </trans-unit>
        <trans-unit id="5b43fa59ed80a4a74e2345ca9a7be4d00498a5de" translate="yes" xml:space="preserve">
          <source>High-Level Query Language</source>
          <target state="translated">고급 쿼리 언어</target>
        </trans-unit>
        <trans-unit id="f0be6eee61b3f35036173bb461da267d072410b3" translate="yes" xml:space="preserve">
          <source>High-security Value</source>
          <target state="translated">높은 보안 가치</target>
        </trans-unit>
        <trans-unit id="d4e0f8e3d3d0dc08399c35d69b24eda9dfffeab6" translate="yes" xml:space="preserve">
          <source>Higher level logic within SQLite will normally intercept the error code and create a temporary in-memory shared memory region so that the current process can at least read the content of the database. This result code should not reach the application interface layer.</source>
          <target state="translated">SQLite 내의 높은 수준의 논리는 일반적으로 오류 코드를 가로 채고 임시 프로세스 내 메모리 공유 메모리 영역을 만들어 현재 프로세스가 최소한 데이터베이스의 내용을 읽을 수 있도록합니다. 이 결과 코드는 응용 프로그램 인터페이스 계층에 도달하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8ec8e6f8b27cff894766ae4e4215e6f333126ae8" translate="yes" xml:space="preserve">
          <source>Highest precedence (tightest grouping).</source>
          <target state="translated">가장 높은 우선 순위 (가장 엄격한 그룹화).</target>
        </trans-unit>
        <trans-unit id="9d8bc8b9f1a6b46c231d4505eec0f99894497892" translate="yes" xml:space="preserve">
          <source>Hint: applications can generate globally unique identifiers using this function together with &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; and/or &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; like this:</source>
          <target state="translated">힌트 : 응용 프로그램은 다음과 같이 &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower ()&lt;/a&gt; 와 함께이 함수를 사용하여 전역 고유 식별자를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13895cc550db90756c2c44f981469cdd85261a1d" translate="yes" xml:space="preserve">
          <source>Hints for Debugging SQLite</source>
          <target state="translated">SQLite 디버깅을위한 힌트</target>
        </trans-unit>
        <trans-unit id="6b205a779ffaeec5fb12feda7165de7c06e54bbe" translate="yes" xml:space="preserve">
          <source>Historical test cases from &lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt;, &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt;, and &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; are collected in a set of database files in the main SQLite source tree and then rerun by the &quot;fuzzcheck&quot; utility program whenever one runs &quot;make test&quot;. Fuzzcheck only runs a few thousand &quot;interesting&quot; cases out of the hundreds of millions of cases that the various fuzzers have examined over the years. &quot;Interesting&quot; cases are cases that exhibit previously unseen behavior. Actual bugs found by fuzzers are always included among the interesting test cases, but most of the cases run by fuzzcheck were never actual bugs.</source>
          <target state="translated">&lt;a href=&quot;testing#aflfuzz&quot;&gt;AFL&lt;/a&gt; , &lt;a href=&quot;testing#ossfuzz&quot;&gt;OSS Fuzz&lt;/a&gt; 및 &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz의&lt;/a&gt; 히스토리 테스트 케이스 는 기본 SQLite 소스 트리의 데이터베이스 파일 세트에서 수집 된 후 &quot;make test&quot;를 실행할 때마다 &quot;fuzzcheck&quot;유틸리티 프로그램으로 다시 실행됩니다. Fuzzcheck는 다양한 퍼 저가 수년에 걸쳐 조사한 수억 건의 사례 중 수천 건의 &quot;흥미로운&quot;사례 만 실행합니다. &quot;흥미로운&quot;사례는 이전에 보지 못한 행동을 보이는 사례입니다. fuzzers에서 발견 한 실제 버그는 항상 흥미로운 테스트 사례에 포함되지만 fuzzcheck으로 실행되는 대부분의 사례는 실제 버그가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="67fec9a6d19b7573beec194f9c1e57c883f7bff1" translate="yes" xml:space="preserve">
          <source>Historically, backups (copies) of SQLite databases have been created using the following method:</source>
          <target state="translated">역사적으로 SQLite 데이터베이스의 백업 (복사본)은 다음 방법을 사용하여 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a7796946d81b3e384b117135d383fc5e5877941f" translate="yes" xml:space="preserve">
          <source>Historically, the bytecode engine in SQLite is called the &quot;Virtual DataBase Engine&quot; or &quot;VDBE&quot;. This website uses the terms &quot;bytecode engine&quot;, &quot;VDBE&quot;, &quot;virtual machine&quot;, and &quot;bytecode virtual machine&quot; interchangeably, as they all mean the same thing.</source>
          <target state="translated">역사적으로 SQLite의 바이트 코드 엔진을 &quot;가상 데이터베이스 엔진&quot;또는 &quot;VDBE&quot;라고합니다. 이 웹 사이트는 &quot;바이트 코드 엔진&quot;, &quot;VDBE&quot;, &quot;가상 머신&quot;및 &quot;바이트 코드 가상 머신&quot;이라는 용어를 모두 같은 의미로 사용하므로 상호 교환 적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="186352c9ed4b1d5538fac7c967930c7dfb52b78f" translate="yes" xml:space="preserve">
          <source>Historically, the return value from xFindFunction() was either zero or one. Zero means that the function is not overloaded and one means that it is overload. The ability to return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater was added in version 3.25.0 (2018-09-15). If xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or greater, than means that the function takes two arguments and the function can be used as a boolean in the WHERE clause of a query and that the virtual table is able to exploit that function to speed up the query result. When xFindFunction returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, the value returned becomes the sqlite3_index_info.aConstraint.op value for one of the constraints passed into &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; and the second argument becomes the value corresponding to that constraint that is passed to &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter()&lt;/a&gt;. This enables the xBestIndex()/xFilter implementations to use the function to speed its search.</source>
          <target state="translated">역사적으로 xFindFunction ()의 반환 값은 0 또는 1이었습니다. 0은 함수에 과부하가 걸리지 않았 음을 의미하고, 하나는 과부하가 걸린 것을 의미합니다. &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; 이상의 값을 반환하는 기능 은 버전 3.25.0 (2018-09-15)에 추가되었습니다. xFindFunction이 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; 이상을 리턴하는 경우 보다 함수가 두 개의 인수를 사용하며 쿼리의 WHERE 절에서 부울로 함수를 사용할 수 있으며 가상 테이블이 해당 함수를 이용하여 쿼리 결과를 가속화 할 수 있음을 의미합니다. xFindFunction이 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; 이상을 리턴하면 리턴 된 값은 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()에&lt;/a&gt; 전달 된 제한 조건 중 하나에 대한 sqlite3_index_info.aConstraint.op 값이됩니다.두 번째 인수는 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter ()에&lt;/a&gt; 전달 된 해당 제약 조건에 해당하는 값이됩니다 . 이를 통해 xBestIndex () / xFilter 구현이 함수를 사용하여 검색 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48f87256a37f996b34f071b6b4ef5f1805966dbd" translate="yes" xml:space="preserve">
          <source>Historically, this was not considered a threat. The argument was that if a hostile agent is able to inject arbitrary SQL text into the application, then that agent is already in full control of the application, so letting the hostile agent forge a pointer does not give the agent any new capability.</source>
          <target state="translated">역사적으로 이것은 위협으로 간주되지 않았습니다. 적대적인 에이전트가 임의의 SQL 텍스트를 애플리케이션에 삽입 할 수 있으면 해당 에이전트는 이미 애플리케이션을 완전히 제어 할 수 있으므로 적대적인 에이전트가 포인터를 위조하도록하면 에이전트에 새로운 기능이 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfbddd574d4f950742d8e5d7a49607c23d347f95" translate="yes" xml:space="preserve">
          <source>Honor all.</source>
          <target state="translated">모두 존중하십시오.</target>
        </trans-unit>
        <trans-unit id="645a5172c51f2105b78cb24101222af4c2581b31" translate="yes" xml:space="preserve">
          <source>Honor the &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY&lt;/a&gt; flag, which was previously described in the documentation, but was previously a no-op.</source>
          <target state="translated">명예 &lt;a href=&quot;c3ref/c_deserialize_freeonclose&quot;&gt;SQLITE_DESERIALIZE_READONLY의&lt;/a&gt; 이전 문서에 설명하지만, 이전에 어떤 조합 없었다되었다 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="2fff26aa56e0db9e63e42ae6a74896b210340408" translate="yes" xml:space="preserve">
          <source>Honor the ORDER BY and LIMIT clause of a SELECT even if the result set is used for an INSERT.</source>
          <target state="translated">결과 세트가 INSERT에 사용 되더라도 SELECT의 ORDER BY 및 LIMIT 절을 존중하십시오.</target>
        </trans-unit>
        <trans-unit id="972205ef02943c809b85189066f29ea5a922b1d8" translate="yes" xml:space="preserve">
          <source>Host parameter names can begin with '@' for compatibility with SQL Server.</source>
          <target state="translated">SQL Server와의 호환성을 위해 호스트 매개 변수 이름은 '@'로 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2107ab6c47208816e9f85a68b6f666b821dd323b" translate="yes" xml:space="preserve">
          <source>Hot Journal Detection</source>
          <target state="translated">핫 저널 감지</target>
        </trans-unit>
        <trans-unit id="387adc1437f284bb8f7d821272256c3791f7c532" translate="yes" xml:space="preserve">
          <source>Hot Journal Rollback</source>
          <target state="translated">핫 저널 롤백</target>
        </trans-unit>
        <trans-unit id="51a2396551270d6b1b9b0daa06c843f02294bf7a" translate="yes" xml:space="preserve">
          <source>Hot journal files</source>
          <target state="translated">인기 저널 파일</target>
        </trans-unit>
        <trans-unit id="33f85488d44d0b31b265f227edf83b283232673c" translate="yes" xml:space="preserve">
          <source>Hot journal rollback</source>
          <target state="translated">핫 저널 롤백</target>
        </trans-unit>
        <trans-unit id="72b9d3b59a2cd3c6b5726c2ec8f20f5cbd8fc2c8" translate="yes" xml:space="preserve">
          <source>How &lt;a href=&quot;queryplanner&quot;&gt;indexing&lt;/a&gt; works.</source>
          <target state="translated">어떻게 &lt;a href=&quot;queryplanner&quot;&gt;색인&lt;/a&gt; 작품.</target>
        </trans-unit>
        <trans-unit id="de544e283cfebc5d70d3d7b590e023e13a9bf879" translate="yes" xml:space="preserve">
          <source>How Memory-Mapped I/O Works</source>
          <target state="translated">메모리 매핑 된 I / O 작동 방식</target>
        </trans-unit>
        <trans-unit id="56b803311ab7e3e616ef538b11ad7fad3dcd0741" translate="yes" xml:space="preserve">
          <source>How SQLite Is Tested</source>
          <target state="translated">SQLite 테스트 방법</target>
        </trans-unit>
        <trans-unit id="f0b874a1265664f2f8c8240dcb0a141334e57668" translate="yes" xml:space="preserve">
          <source>How To Compile SQLite</source>
          <target state="translated">SQLite를 컴파일하는 방법</target>
        </trans-unit>
        <trans-unit id="bac0366a300ac4acaffdcf4c3d4ee83a4619271d" translate="yes" xml:space="preserve">
          <source>How To Corrupt</source>
          <target state="translated">부패하는 방법</target>
        </trans-unit>
        <trans-unit id="07961a03bdae1448ec20af2c6389f109c109cecd" translate="yes" xml:space="preserve">
          <source>How To Corrupt An SQLite Database File</source>
          <target state="translated">SQLite 데이터베이스 파일을 손상시키는 방법</target>
        </trans-unit>
        <trans-unit id="ac75035a65466ee12d9ad12dabe0ea72bf4078bd" translate="yes" xml:space="preserve">
          <source>How To Corrupt Your Database Files</source>
          <target state="translated">데이터베이스 파일을 손상시키는 방법</target>
        </trans-unit>
        <trans-unit id="6c4dc04d73e3b62534455f3b1b128df4687ca99e" translate="yes" xml:space="preserve">
          <source>How To Download Canonical SQLite Source Code</source>
          <target state="translated">정식 SQLite 소스 코드를 다운로드하는 방법</target>
        </trans-unit>
        <trans-unit id="023a32566bba30a34815129fd5e3cc90c1e899ca" translate="yes" xml:space="preserve">
          <source>How VACUUM works</source>
          <target state="translated">VACUUM 작동 방식</target>
        </trans-unit>
        <trans-unit id="996ef93cbabdf3a445d79226e8fa6d9c24a881f0" translate="yes" xml:space="preserve">
          <source>How are the syntax diagrams (a.k.a. &quot;railroad&quot; diagrams) for SQLite generated?</source>
          <target state="translated">SQLite에 대한 구문 다이어그램 (일명 &quot;철도&quot;다이어그램)은 어떻게 생성됩니까?</target>
        </trans-unit>
        <trans-unit id="fc0899650d804dfcac8dc2104606bf9268efcf1e" translate="yes" xml:space="preserve">
          <source>How collation is determined</source>
          <target state="translated">콜 레이션 결정 방법</target>
        </trans-unit>
        <trans-unit id="9a3218133ebd28240c94b4e7364a4f7e2e221ee5" translate="yes" xml:space="preserve">
          <source>How do I add or delete columns from an existing table in SQLite.</source>
          <target state="translated">SQLite의 기존 테이블에서 열을 추가하거나 삭제하는 방법</target>
        </trans-unit>
        <trans-unit id="30aeec19cd6396142e3416e018900e8041d11cdb" translate="yes" xml:space="preserve">
          <source>How do I create an AUTOINCREMENT field?</source>
          <target state="translated">AUTOINCREMENT 필드는 어떻게 만듭니 까?</target>
        </trans-unit>
        <trans-unit id="a6cedc80b4e8057201d930bd24da72e7284f5f18" translate="yes" xml:space="preserve">
          <source>How do I list all tables/indices contained in an SQLite database</source>
          <target state="translated">SQLite 데이터베이스에 포함 된 모든 테이블 / 표시를 나열하는 방법</target>
        </trans-unit>
        <trans-unit id="94a002c7d3ab3f319a7a958c2ffad735eae889c1" translate="yes" xml:space="preserve">
          <source>How do I use a string literal that contains an embedded single-quote (') character?</source>
          <target state="translated">작은 따옴표 ( ') 문자가 포함 된 문자열 리터럴을 어떻게 사용합니까?</target>
        </trans-unit>
        <trans-unit id="df2742c7cfd9e0aab79b47f5b91d0027a0daa0fc" translate="yes" xml:space="preserve">
          <source>How many executable files are in the archive?</source>
          <target state="translated">아카이브에 몇 개의 실행 파일이 있습니까?</target>
        </trans-unit>
        <trans-unit id="463cdf2e00bc03ffb0a58ce75a36b28173bad1d1" translate="yes" xml:space="preserve">
          <source>How vacuum works</source>
          <target state="translated">진공 작동 방식</target>
        </trans-unit>
        <trans-unit id="c2ebee163b547a5e69c6b8f18b3ce7ade428f296" translate="yes" xml:space="preserve">
          <source>However, client/server database engines (such as PostgreSQL, MySQL, or Oracle) usually support a higher level of concurrency and allow multiple processes to be writing to the same database at the same time. This is possible in a client/server database because there is always a single well-controlled server process available to coordinate access. If your application has a need for a lot of concurrency, then you should consider using a client/server database. But experience suggests that most applications need much less concurrency than their designers imagine.</source>
          <target state="translated">그러나 클라이언트 / 서버 데이터베이스 엔진 (예 : PostgreSQL, MySQL 또는 Oracle)은 일반적으로 높은 수준의 동시성을 지원하며 여러 프로세스가 동시에 동일한 데이터베이스에 쓸 수 있도록합니다. 액세스를 조정할 수있는 잘 제어 된 단일 서버 프로세스가 항상 있기 때문에 클라이언트 / 서버 데이터베이스에서 가능합니다. 응용 프로그램에 많은 동시성이 필요한 경우 클라이언트 / 서버 데이터베이스 사용을 고려해야합니다. 그러나 경험에 따르면 대부분의 응용 프로그램은 디자이너가 생각하는 것보다 훨씬 적은 동시성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a6ddbe53650906819e58dd27910958633c3e2cfa" translate="yes" xml:space="preserve">
          <source>However, for a &quot;contained-within&quot; style query, rounding the bounding boxes outward might cause some entries to be excluded from the result set if the edge of the entry bounding box corresponds to the edge of the query bounding box. To guard against this, applications should expand their contained-within query boxes slightly (by 0.000012%) by rounding down the lower coordinates and rounding up the top coordinates, in each dimension.</source>
          <target state="translated">그러나 &quot;포함 된&quot;스타일 쿼리의 경우 경계 상자를 바깥쪽으로 반올림하면 항목 경계 상자의 가장자리가 쿼리 경계 상자의 가장자리에 해당하는 경우 일부 항목이 결과 집합에서 제외 될 수 있습니다. 이를 방지하기 위해 응용 프로그램은 각 차원에서 하위 좌표를 반올림하고 최상위 좌표를 반올림하여 포함 된 쿼리 상자를 약간 (0.000012 %) 확장해야합니다.</target>
        </trans-unit>
        <trans-unit id="036059da8b4b48b5c802bde550324a35ba2a35da" translate="yes" xml:space="preserve">
          <source>However, highly tuned and specialized applications may want or need to replace some of SQLite's built-in system interfaces with alternative implementations more suitable for the needs of the application. SQLite is designed to be easily reconfigured at compile-time to meet the specific needs of individual projects. Among the compile-time configuration options for SQLite are these:</source>
          <target state="translated">그러나 고도로 조정되고 전문화 된 응용 프로그램은 SQLite의 기본 제공 시스템 인터페이스 중 일부를 응용 프로그램 요구에보다 적합한 대체 구현으로 대체하거나 원할 수도 있습니다. SQLite는 개별 프로젝트의 특정 요구를 충족시키기 위해 컴파일 타임에 쉽게 재구성 할 수 있도록 설계되었습니다. SQLite의 컴파일 타임 구성 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9070a26476fc8018912ec09ceeee6b8f4a55c4f3" translate="yes" xml:space="preserve">
          <source>However, if a</source>
          <target state="translated">그러나</target>
        </trans-unit>
        <trans-unit id="96aad563dbeff373bd60c0d93a4ac2c049bba808" translate="yes" xml:space="preserve">
          <source>However, if a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation creates real tables (sometimes referred to as &quot;shadow&quot; tables) within the database to store its data in, then sqldiff.exe does calculate the difference between these. This can have surprising effects if the resulting SQL script is then run on a database that is not</source>
          <target state="translated">그러나 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현이 데이터베이스 내에 데이터를 저장하기 위해 실제 테이블 (때때로 &quot;섀도우&quot;테이블이라고도 함)을 생성하면 sqldiff.exe는 이들 간의 차이를 계산합니다. 결과 SQL 스크립트가 그렇지 않은 데이터베이스에서 실행될 경우 이는 놀라운 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90ac212208b638040cc57dde761531e1857cf547" translate="yes" xml:space="preserve">
          <source>However, if a database has many concurrent overlapping readers and there is always at least one active reader, then no checkpoints will be able to complete and hence the WAL file will grow without bound.</source>
          <target state="translated">그러나 데이터베이스에 동시 겹치는 판독기 수가 많고 항상 활성 판독기가 하나 이상 있으면 체크 포인트를 완료 할 수 없으므로 WAL 파일이 제한없이 커집니다.</target>
        </trans-unit>
        <trans-unit id="908b33a654e5b5eaa50e924611f16debc0d52007" translate="yes" xml:space="preserve">
          <source>However, if in-memory database pInMemory has just been opened (and is therefore completely empty) before being passed to function loadOrSaveDb(), then it is still possible to change its page size using an SQLite &quot;PRAGMA page_size&quot; command. Function loadOrSaveDb() could detect this case, and attempt to set the page-size of the in-memory database to the page-size of database zFilename before invoking the online backup API functions.</source>
          <target state="translated">그러나 메모리 내 데이터베이스 pInMemory가 loadOrSaveDb () 함수로 전달되기 전에 방금 열렸으므로 완전히 비어있는 경우에도 SQLite &quot;PRAGMA page_size&quot;명령을 사용하여 페이지 크기를 변경할 수 있습니다. loadOrSaveDb () 함수는이 경우를 감지하고 온라인 백업 API 함수를 호출하기 전에 인 메모리 데이터베이스의 페이지 크기를 데이터베이스 zFilename의 페이지 크기로 설정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="9282d84ef089a46651581dc23d9984a0b853a197" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">그러나 응용 프로그램은 sqlite3_backup_init ()가 호출 된 후 및 sqlite3_backup_finish ()에 대한 해당 호출 전에 대상 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 다른 API로 스레드에 의해 전달되지 않도록해야합니다. SQLite는 현재 응용 프로그램이 대상 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 잘못 액세스하는지 확인하지 않으므로 오류 코드가보고되지 않지만 그럼에도 불구하고 작업이 오작동 할 수 있습니다. 백업이 진행되는 동안 대상 데이터베이스 연결을 사용하면 뮤텍스 교착 상태가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bd67d83c5ac9c5a6146085621d60822aa5f256c" translate="yes" xml:space="preserve">
          <source>However, the application must guarantee that the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is not passed to any other API (by any thread) after sqlite3_backup_init() is called and before the corresponding call to sqlite3_backup_finish(). SQLite does not currently check to see if the application incorrectly accesses the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and so no error code is reported, but the operations may malfunction nevertheless. Use of the destination database connection while a backup is in progress might also also cause a mutex deadlock.</source>
          <target state="translated">그러나 응용 프로그램은 sqlite3_backup_init ()가 호출 된 후 및 sqlite3_backup_finish ()에 대한 해당 호출 전에 대상 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 다른 API로 스레드에 의해 전달되지 않도록해야합니다. SQLite는 현재 응용 프로그램이 대상 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 잘못 액세스하는지 확인하지 않으므로 오류 코드가보고되지 않지만 그럼에도 불구하고 작업이 오작동 할 수 있습니다. 백업이 진행되는 동안 대상 데이터베이스 연결을 사용하면 뮤텍스 교착 상태가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2051ec90af96c4dbbb12c8a2bb3921b04fb0a7f2" translate="yes" xml:space="preserve">
          <source>However, the b-tree for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table is in the same format as an index b-tree. Thus, an index b-tree can be accessed as if it were a WITHOUT ROWID table.</source>
          <target state="translated">그러나 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 b- 트리는 인덱스 b- 트리와 같은 형식입니다. 따라서 인덱스 b- 트리는 마치 WITHOUT ROWID 테이블 인 것처럼 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdab598cbadf7cd7b2bb8bc0bda2ecbe3c4ceb3a" translate="yes" xml:space="preserve">
          <source>Hundreds of virtual tables that publish various aspects of the host computer, such as the process table, user lists, active network connections, and so forth. OsQuery is a separate project, started by Facebook, hosted on &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt;, and intended for security analysis and intrusion detection OsQuery is not a part of the SQLite project, but is included in this list because it demonstrates how the SQL language and the SQLite virtual table mechanism can be leveraged to provide elegant solutions to important real-world problems.</source>
          <target state="translated">프로세스 테이블, 사용자 목록, 활성 네트워크 연결 등과 같은 호스트 컴퓨터의 다양한 측면을 게시하는 수백 개의 가상 테이블. OsQuery는 Facebook에서 시작하여 &lt;a href=&quot;https://github.com/facebook/osquery&quot;&gt;GitHub&lt;/a&gt; 에서 호스팅되는 별도의 프로젝트이며 보안 분석 및 침입 감지를 위해 설계되었습니다. OsQuery는 SQLite 프로젝트의 일부가 아니지만 SQL 언어 및 SQLite 가상 테이블의 방법을 보여주기 때문에이 목록에 포함됩니다. 중요한 실제 문제에 대한 우아한 솔루션을 제공하기 위해 메커니즘을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d245e7140689124e74b20cb072465076d95b006" translate="yes" xml:space="preserve">
          <source>I accidentally deleted some important information from my SQLite database. How can I recover it?</source>
          <target state="translated">실수로 SQLite 데이터베이스에서 중요한 정보를 삭제했습니다. 어떻게 복구 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="dc9c3207dff5659b4c310cd90f15260ed36f68c7" translate="yes" xml:space="preserve">
          <source>I am told that Git users commonly install third-party graphical viewers for Git, many of which do a better job of showing recent activity on the project. That is great, but these are still more third-party applications that must be installed and managed separately. Many are platform-specific. (One of the better ones, &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt;, only works on Mac, for example.) All require that you first sync your local repository then bring up their graphical interface on your desktop. And even with all that, I still cannot see what I typically want to see without multiple clicks. Checking on project status from a phone while away from the office is not an option.</source>
          <target state="translated">Git 사용자는 일반적으로 Git 용 타사 그래픽 뷰어를 설치한다고 들었는데, 그 중 상당수는 프로젝트에서 최근 활동을 더 잘 보여줍니다. 훌륭하지만 이것들은 여전히 ​​별도로 설치하고 관리 해야하는 더 많은 타사 응용 프로그램입니다. 많은 플랫폼에 따라 다릅니다. 더 나은 것 중 하나 인 &lt;a href=&quot;https://gitup.co/&quot;&gt;GitUp&lt;/a&gt; 은 예를 들어 Mac에서만 작동합니다. 먼저 로컬 리포지토리를 동기화 한 다음 데스크톱에서 그래픽 인터페이스를 불러 와야합니다. 그리고 그 모든 것에도 불구하고 여전히 여러 번의 클릭없이 일반적으로보고 싶은 것을 볼 수 없습니다. 사무실 밖에서 전화로 프로젝트 상태를 확인하는 것은 옵션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a5d8bfaba744d8865014e1b5776daef69b8ba64a" translate="yes" xml:space="preserve">
          <source>I am told that the default PostgreSQL configuration in RedHat 7.3 is unnecessarily conservative (it is designed to work on a machine with 8MB of RAM) and that PostgreSQL could be made to run a lot faster with some knowledgeable configuration tuning. Matt Sergeant reports that he has tuned his PostgreSQL installation and rerun the tests shown below. His results show that PostgreSQL and MySQL run at about the same speed. For Matt's results, visit</source>
          <target state="translated">RedHat 7.3의 기본 PostgreSQL 구성은 불필요하게 보수적이며 (8MB의 RAM이있는 컴퓨터에서 작동하도록 설계되었습니다) PostgreSQL은 지식이 풍부한 구성 조정으로 훨씬 빠르게 실행될 수 있다고 들었습니다. Matt Sergeant는 자신의 PostgreSQL 설치를 조정했으며 아래 표시된 테스트를 다시 실행한다고보고합니다. 그의 결과에 따르면 PostgreSQL과 MySQL은 거의 같은 속도로 실행됩니다. Matt의 결과를 보려면 방문</target>
        </trans-unit>
        <trans-unit id="c4b4aed72c495e6b69cc90a12c1002093ba09a73" translate="yes" xml:space="preserve">
          <source>I deleted a lot of data but the database file did not get any smaller. Is this a bug?</source>
          <target state="translated">많은 데이터를 삭제했지만 데이터베이스 파일이 더 작아지지 않았습니다. 이것이 버그입니까?</target>
        </trans-unit>
        <trans-unit id="30c131b4d60b85b44b7c7e76894246c9eeed47f8" translate="yes" xml:space="preserve">
          <source>I get a compiler error if I use the SQLITE_OMIT_... compile-time options when building SQLite.</source>
          <target state="translated">SQLite를 빌드 할 때 SQLITE_OMIT _... 컴파일 타임 옵션을 사용하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="96380689d1c266e443557fac220e162eb248fe7f" translate="yes" xml:space="preserve">
          <source>I get some compiler warnings when I compile SQLite. Isn't this a problem? Doesn't it indicate poor code quality?</source>
          <target state="translated">SQLite를 컴파일 할 때 컴파일러 경고가 나타납니다. 이것이 문제가되지 않습니까? 코드 품질이 좋지 않습니까?</target>
        </trans-unit>
        <trans-unit id="b0631d514fcfd330a2105540a0b813b7c7b65c3f" translate="yes" xml:space="preserve">
          <source>I/O error testing is similar in concept to OOM testing; I/O errors are simulated and checks are made to verify that SQLite responds correctly to the simulated errors. I/O errors are simulated in both the TCL and TH3 test harnesses by inserting a new &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System object&lt;/a&gt; that is specially rigged to simulate an I/O error after a set number of I/O operations. As with OOM error testing, the I/O error simulators can be set to fail just once, or to fail continuously after the first failure. Tests are run in a loop, slowly increasing the point of failure until the test case runs to completion without error. The loop is run twice, once with the I/O error simulator set to simulate only a single failure and a second time with it set to fail all I/O operations after the first failure.</source>
          <target state="translated">I / O 오류 테스트는 개념적으로 OOM 테스트와 유사합니다. I / O 오류가 시뮬레이션되고 SQLite가 시뮬레이션 된 오류에 올바르게 응답하는지 확인합니다. I / O 오류는 정해진 수의 I / O 작업 후 I / O 오류를 시뮬레이션하기 위해 특별히 조작 된 새로운 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템 개체&lt;/a&gt; 를 삽입하여 TCL 및 TH3 테스트 하니스 모두에서 시뮬레이션됩니다. OOM 오류 테스트와 마찬가지로 I / O 오류 시뮬레이터는 한 번만 실패하거나 첫 번째 실패 후에 지속적으로 실패하도록 설정할 수 있습니다. 테스트는 루프에서 실행되며 테스트 케이스가 오류없이 완료 될 때까지 실패 지점을 천천히 증가시킵니다. 루프는 단일 오류 만 시뮬레이션하도록 설정된 I / O 오류 시뮬레이터로 한 번 두 번 실행되고 첫 번째 장애 후 모든 I / O 조작이 실패하도록 두 번째로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7e39c1a666c2fd143f11a87457de9e9888317484" translate="yes" xml:space="preserve">
          <source>I/O error testing seeks to verify that SQLite responds sanely to failed I/O operations. I/O errors might result from a full disk drive, malfunctioning disk hardware, network outages when using a network file system, system configuration or permission changes that occur in the middle of an SQL operation, or other hardware or operating system malfunctions. Whatever the cause, it is important that SQLite be able to respond correctly to these errors and I/O error testing seeks to verify that it does.</source>
          <target state="translated">I / O 오류 테스트는 SQLite가 실패한 I / O 작업에 제대로 응답하는지 확인합니다. I / O 오류는 전체 디스크 드라이브, 디스크 하드웨어 오작동, 네트워크 파일 시스템 사용 중 네트워크 중단, SQL 조작 중에 발생하는 시스템 구성 또는 권한 변경 또는 기타 하드웨어 또는 운영 체제 오작동으로 인해 발생할 수 있습니다. 원인이 무엇이든, SQLite가 이러한 오류에 올바르게 응답 할 수 있어야하며 I / O 오류 테스트는 해당 오류가 있는지 확인하려고합니다.</target>
        </trans-unit>
        <trans-unit id="8d8651647c9490ad914b1a9a6e6d44929ce46c04" translate="yes" xml:space="preserve">
          <source>I/O error tests</source>
          <target state="translated">I / O 오류 테스트</target>
        </trans-unit>
        <trans-unit id="35d92e9f60aece05bafa666d5e6093c27b070d38" translate="yes" xml:space="preserve">
          <source>I/O errors in the OS-interface generate error logging events. The message to these events gives the line number in the source code where the error originated and the filename associated with the event when there is a corresponding file.</source>
          <target state="translated">OS 인터페이스의 I / O 오류는 오류 로깅 이벤트를 생성합니다. 이러한 이벤트에 대한 메시지는 오류가 발생한 소스 코드의 행 번호와 해당 파일이있을 때 이벤트와 연관된 파일 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d998ed8c49ae368254ded62fce1c76a6c0d44f30" translate="yes" xml:space="preserve">
          <source>I/O performance is measured using the &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; program from the SQLite source tree. To compile this test program, first gather the kvtest.c source file into a directory with the &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; source files &quot;sqlite3.c&quot; and &quot;sqlite3.h&quot;. Then on unix, run a command like the following:</source>
          <target state="translated">I / O 성능은 SQLite 소스 트리 의 &lt;a href=&quot;https://www.sqlite.org/src/file/test/kvtest.c&quot;&gt;kvtest.c&lt;/a&gt; 프로그램을 사용하여 측정됩니다 . 이 테스트 프로그램을 컴파일하려면 먼저 kvtest.c 소스 파일을 &lt;a href=&quot;amalgamation&quot;&gt;SQLite amalgamation&lt;/a&gt; 소스 파일 &quot;sqlite3.c&quot;및 &quot;sqlite3.h&quot;가 있는 디렉토리에 수집하십시오 . 그런 다음 유닉스에서 다음과 같은 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e779dca751c9ced361a0eadbe7916be59d02dc09" translate="yes" xml:space="preserve">
          <source>I/O performance varies widely depending on operating system and hardware. Make your own measurements before drawing conclusions.</source>
          <target state="translated">I / O 성능은 운영 체제 및 하드웨어에 따라 크게 다릅니다. 결론을 내리기 전에 직접 측정하십시오.</target>
        </trans-unit>
        <trans-unit id="267e452e4d048aacef682e30a9d368c22e7501e4" translate="yes" xml:space="preserve">
          <source>IDF(q&lt;sub&gt;i&lt;/sub&gt;)</source>
          <target state="translated">IDF(q&lt;sub&gt;i&lt;/sub&gt;)</target>
        </trans-unit>
        <trans-unit id="7be63e2881f7da8faa393bfe0ce4667f10916b66" translate="yes" xml:space="preserve">
          <source>IF</source>
          <target state="translated">IF</target>
        </trans-unit>
        <trans-unit id="235cae5b9c97fbc3364fb92af44d64b71392dbb2" translate="yes" xml:space="preserve">
          <source>IF EXISTS and IF NOT EXISTS clauses on CREATE/DROP TABLE/INDEX.</source>
          <target state="translated">CREATE / DROP TABLE / INDEX의 IF EXISTS 및 IF NOT EXISTS 절</target>
        </trans-unit>
        <trans-unit id="c9226f99dd645a71848cf0585c15059d7de868f4" translate="yes" xml:space="preserve">
          <source>IGNORE</source>
          <target state="translated">IGNORE</target>
        </trans-unit>
        <trans-unit id="8ae3e8381a64e36db57a5344790db89d7de90954" translate="yes" xml:space="preserve">
          <source>IMMEDIATE</source>
          <target state="translated">IMMEDIATE</target>
        </trans-unit>
        <trans-unit id="1f94ea3de1605903ae5123660f5457eb8bd32e9f" translate="yes" xml:space="preserve">
          <source>IMMEDIATE cause the database connection to start a new write immediately, without waiting for a writes statement. The BEGIN IMMEDIATE might fail with &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if another write transaction is already active on another database connection.</source>
          <target state="translated">IMMEDIATE는 데이터베이스 연결이 writes 문을 기다리지 않고 즉시 새 쓰기를 시작하게합니다. 다른 데이터베이스 연결에서 다른 쓰기 트랜잭션이 이미 활성화 된 경우 BEGIN IMMEDIATE가 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac8fb933cd53d38ff3f25855409c3725df641570" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">중요 : 추정 행 필드가 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;버전 3.8.2&lt;/a&gt; (2013-12-06) 의 sqlite3_index_info 구조에 추가되었습니다 . 가상 테이블 확장이 3.8.2 이전의 SQLite 버전과 함께 사용되는 경우 추정 행 필드를 읽거나 쓰려고 시도한 결과는 정의되지 않지만 응용 프로그램이 충돌하는 경우가 있습니다. 추정 행 필드는 따라서 다음과 같은 경우에만 사용해야합니다&lt;a href=&quot;#sqlite3_libversion&quot;&gt; sqlite3_libversion_number ()&lt;/a&gt; 가 3008002 이상의 값을 반환하는 합니다. 마찬가지로 idxFlags 필드는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 에 추가되었습니다 . 따라서 sqlite3_libversion_number ()가 3009000 이상의 값을 반환하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7788b148a07ca2844906ea43293afae622f959f" translate="yes" xml:space="preserve">
          <source>IMPORTANT: The estimatedRows field was added to the sqlite3_index_info structure for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06). If a virtual table extension is used with an SQLite version earlier than 3.8.2, the results of attempting to read or write the estimatedRows field are undefined (but are likely to included crashing the application). The estimatedRows field should therefore only be used if &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; returns a value greater than or equal to 3008002. Similarly, the idxFlags field was added for &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14). It may therefore only be used if sqlite3_libversion_number() returns a value greater than or equal to 3009000.</source>
          <target state="translated">중요 : 추정 행 필드가 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;버전 3.8.2&lt;/a&gt; (2013-12-06) 의 sqlite3_index_info 구조에 추가되었습니다 . 가상 테이블 확장이 3.8.2 이전의 SQLite 버전과 함께 사용되는 경우 추정 행 필드를 읽거나 쓰려고 시도한 결과는 정의되지 않지만 응용 프로그램 충돌을 포함 할 수 있습니다. 추정 된 행 필드는&lt;a href=&quot;libversion&quot;&gt; sqlite3_libversion_number ()&lt;/a&gt; 가 3008002 이상의 값을 반환하는 경우에만 사용해야 합니다. 마찬가지로 idxFlags 필드는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 에 추가되었습니다 . 따라서 sqlite3_libversion_number ()가 3009000 이상의 값을 반환하는 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fca55ca3c828a46bfe96a10e69f572b61ce540c" translate="yes" xml:space="preserve">
          <source>IN</source>
          <target state="translated">IN</target>
        </trans-unit>
        <trans-unit id="9e93d8e547641024337c9f88c37aeeb56b09cfd4" translate="yes" xml:space="preserve">
          <source>IN operator</source>
          <target state="translated">IN 연산자</target>
        </trans-unit>
        <trans-unit id="2704c1d8c3fc215c38ee176f6cc30e434a22b7d7" translate="yes" xml:space="preserve">
          <source>INDEX</source>
          <target state="translated">INDEX</target>
        </trans-unit>
        <trans-unit id="d34941b7cef935d2b4b0705a24e87fad9ef16cef" translate="yes" xml:space="preserve">
          <source>INDEXED</source>
          <target state="translated">INDEXED</target>
        </trans-unit>
        <trans-unit id="0a477a77f065212096e980b210eda0227cabf37c" translate="yes" xml:space="preserve">
          <source>INDEXED BY</source>
          <target state="translated">INDEXED BY</target>
        </trans-unit>
        <trans-unit id="fd4d2f0d5aa850e30c0830c19e27d0fa4c65c7a7" translate="yes" xml:space="preserve">
          <source>INITIALLY</source>
          <target state="translated">INITIALLY</target>
        </trans-unit>
        <trans-unit id="88d86d54436967d4b4599d22d53c2a3db38390e6" translate="yes" xml:space="preserve">
          <source>INNER</source>
          <target state="translated">INNER</target>
        </trans-unit>
        <trans-unit id="c20ea07e32d25c072a65368c234d6f5a88f4521a" translate="yes" xml:space="preserve">
          <source>INSERT</source>
          <target state="translated">INSERT</target>
        </trans-unit>
        <trans-unit id="06c4e866c3ade62ba74b04b1ef54dce90603c067" translate="yes" xml:space="preserve">
          <source>INSERT Changes</source>
          <target state="translated">INSERT 변경</target>
        </trans-unit>
        <trans-unit id="4e7c6a59e9c103dd735d95fe84726b20fe104acf" translate="yes" xml:space="preserve">
          <source>INSERT INTO demo2(command) VALUES(&quot;reset&quot;);</source>
          <target state="translated">INSERT INTO demo2 (명령) VALUES ( &quot;reset&quot;);</target>
        </trans-unit>
        <trans-unit id="ed9844477a7bb01e976b863376804eb769331989" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 SELECT b,a,c FROM t2;</source>
          <target state="translated">t1에 삽입 선택 b, a, c from t2;</target>
        </trans-unit>
        <trans-unit id="767dcfed1e7a66d267a3220fbe439232373351ee" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,10719,'ten thousand seven hundred nineteen');</source>
          <target state="translated">t1 값에 삽입 (1,10719, '만 천 칠십 구');</target>
        </trans-unit>
        <trans-unit id="a30ee5b0b970fc276bf5d3453cfa994508fd0177" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1,13153,'thirteen thousand one hundred fifty three');</source>
          <target state="translated">t1 값에 삽입 (1,13153, '13, 000 1 억 쉰 3 ');</target>
        </trans-unit>
        <trans-unit id="4bc6de27aceadc240c8dd43059a82f9a9561379b" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(1000,94142,'ninety four thousand one hundred forty two');</source>
          <target state="translated">t1 값에 삽입 (1000,94142, '94 만 사십 사십이 ');</target>
        </trans-unit>
        <trans-unit id="62d9636f68aa675dabacb22b938d9f2be06b55e0" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(11999,72836,'seventy two thousand eight hundred thirty six');</source>
          <target state="translated">t1 값에 삽입 (11999,72836, 'seventy 이천 팔백 삼십 육');</target>
        </trans-unit>
        <trans-unit id="f0fbe2df8c33450eafb90fd96d71291641e02aa4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(12000,64231,'sixty four thousand two hundred thirty one');</source>
          <target state="translated">t1 값에 삽입 (12000,64231, '64 만 이백 삼십 삼 ');</target>
        </trans-unit>
        <trans-unit id="31a76630ad88d2e05dde2c415d8576db8ec6caf9" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(2,75560,'seventy five thousand five hundred sixty');</source>
          <target state="translated">t1 값에 삽입 (2,75560, 'seventy 5 천오백 육십');</target>
        </trans-unit>
        <trans-unit id="215d5732ce27fd223582c712aaa4660a83a173d4" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(998,66289,'sixty six thousand two hundred eighty nine');</source>
          <target state="translated">t1 값에 삽입 (998,66289, '육십 육 이백 팔십 구');</target>
        </trans-unit>
        <trans-unit id="4b533e1d2a14d2013c249801c64abee1873ad0e7" translate="yes" xml:space="preserve">
          <source>INSERT INTO t1 VALUES(999,24322,'twenty four thousand three hundred twenty two');</source>
          <target state="translated">t1 값에 삽입 (999,24322, '이만 사천 삼백이');</target>
        </trans-unit>
        <trans-unit id="c97d31d96ba9608129ccb018853e9ea9cb6076d1" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT * FROM t1;</source>
          <target state="translated">t2에 삽입 * 선택 t1;</target>
        </trans-unit>
        <trans-unit id="18573be7d634b7266c9f3fabe6799c0e9de399b2" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 SELECT b,a,c FROM t1;</source>
          <target state="translated">t2에 삽입 SELECT b, a, c from t1;</target>
        </trans-unit>
        <trans-unit id="6654bc4310d1eef443b5f0f2c1641262634e1e66" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(1,59672,'fifty nine thousand six hundred seventy two');</source>
          <target state="translated">t2 값에 삽입 (1,59672, '오천 구백 칠십이');</target>
        </trans-unit>
        <trans-unit id="94d1d27ed943c864c7cfd96715bf162e7beab100" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(24999,89569,'eighty nine thousand five hundred sixty nine');</source>
          <target state="translated">t2 값에 삽입 (24999,89569, '80 만 백만 오십 육십 ');</target>
        </trans-unit>
        <trans-unit id="253860cdd49bceb80fa941fa6a7a8aa222a2af3e" translate="yes" xml:space="preserve">
          <source>INSERT INTO t2 VALUES(25000,94666,'ninety four thousand six hundred sixty six');</source>
          <target state="translated">t2 값에 삽입 (25000,94666, '96 만 육백 육십 ');</target>
        </trans-unit>
        <trans-unit id="0e8f253b1b555988f2df4dcb60865d19307f1b0c" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(24999,88509,'eighty eight thousand five hundred nine');</source>
          <target state="translated">t3 값에 삽입 (24999,88509, '80 8000 쉰 9 ');</target>
        </trans-unit>
        <trans-unit id="00be643bf7f738dedf700c9b2a35f10694c7941a" translate="yes" xml:space="preserve">
          <source>INSERT INTO t3 VALUES(25000,84791,'eighty four thousand seven hundred ninety one');</source>
          <target state="translated">t3 값에 삽입 (25000,84791, '팔십 사천 칠십 구');</target>
        </trans-unit>
        <trans-unit id="eb2365c71aa4f9cd4a1bfec486fd83fcbdda7977" translate="yes" xml:space="preserve">
          <source>INSERT INTO tab1 VALUES(?,?,?);</source>
          <target state="translated">tab1에 삽입 값 VALUES (?,?,?);</target>
        </trans-unit>
        <trans-unit id="0666a7f2affc6b3653a4c2bdf54c9b4bb98361ed" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('automerge=N');</source>
          <target state="translated">INSERT INTO xyz (xyz) 값 ( 'automerge = N');</target>
        </trans-unit>
        <trans-unit id="4e8b9a8e297bede64cc05b119a6cea847e694a59" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('integrity-check');</source>
          <target state="translated">xyz (xyz) 값에 삽입 ( 'integrity-check');</target>
        </trans-unit>
        <trans-unit id="f5e0d229ccc9b20df140de91fa55ac169f3840fe" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('merge=X,Y');</source>
          <target state="translated">INSERT INTO xyz (xyz) 값 ( 'merge = X, Y');</target>
        </trans-unit>
        <trans-unit id="5af88d4a59ba50ff893198ed67ae451d74a117e2" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('optimize');</source>
          <target state="translated">INSERT INTO xyz (xyz) 값 ( 'optimize');</target>
        </trans-unit>
        <trans-unit id="13f47444da210de43c60aab402a316dfe2becb56" translate="yes" xml:space="preserve">
          <source>INSERT INTO xyz(xyz) VALUES('rebuild');</source>
          <target state="translated">INSERT INTO xyz (xyz) 값 ( '재 구축');</target>
        </trans-unit>
        <trans-unit id="2f103f7920401a2a0647c3f2159a7c89eabff571" translate="yes" xml:space="preserve">
          <source>INSERT is really slow - I can only do few dozen INSERTs per second</source>
          <target state="translated">INSERT는 실제로 느리다-초당 수십 개의 INSERT 만 할 수있다</target>
        </trans-unit>
        <trans-unit id="62d1399645f66158b7511abeddf89f395dea5fde" translate="yes" xml:space="preserve">
          <source>INSERT runs a little faster when the source is a SELECT statement.</source>
          <target state="translated">소스가 SELECT 문인 경우 INSERT가 약간 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="aeb597e62b4ad26deac5b62c60062c710ea90371" translate="yes" xml:space="preserve">
          <source>INSTEAD</source>
          <target state="translated">INSTEAD</target>
        </trans-unit>
        <trans-unit id="2300ac39d09a99728ae682403c03797ee8da658b" translate="yes" xml:space="preserve">
          <source>INSTEAD OF trigger</source>
          <target state="translated">INSTEAD OF 트리거</target>
        </trans-unit>
        <trans-unit id="d8374d53c837e126cb6abc0132fba2a1f9a3a9c8" translate="yes" xml:space="preserve">
          <source>INSTEAD OF triggers</source>
          <target state="translated">INSTEAD OF 트리거</target>
        </trans-unit>
        <trans-unit id="793985cddb68d46ef51b688aecf85864c9e06813" translate="yes" xml:space="preserve">
          <source>INT</source>
          <target state="translated">INT</target>
        </trans-unit>
        <trans-unit id="a3a0ec55e3e26ee54417c786dfad5d709ecb7c40" translate="yes" xml:space="preserve">
          <source>INT2</source>
          <target state="translated">INT2</target>
        </trans-unit>
        <trans-unit id="021a30ffe1ce8750cb57ce941d7fb3d04090b37c" translate="yes" xml:space="preserve">
          <source>INT8</source>
          <target state="translated">INT8</target>
        </trans-unit>
        <trans-unit id="0fe37e40e5dab3ac411c2ddca6d21991e811acfa" translate="yes" xml:space="preserve">
          <source>INTEGER</source>
          <target state="translated">INTEGER</target>
        </trans-unit>
        <trans-unit id="e3752510d6a9d0fb8f3974168ca6bea1a562a9ac" translate="yes" xml:space="preserve">
          <source>INTEGER PRIMARY KEY columns can be used to implement the equivalent of AUTOINCREMENT. If you try to insert a NULL into an INTEGER PRIMARY KEY column, the column will actually be filled with an integer that is one greater than the largest key already in the table. Or if the largest key is 2147483647, then the column will be filled with a random integer. Either way, the INTEGER PRIMARY KEY column will be assigned a unique integer. You can retrieve this integer using the &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function or using the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function in a subsequent SELECT statement.</source>
          <target state="translated">INTEGER PRIMARY KEY 열을 사용하여 동일한 AUTOINCREMENT를 구현할 수 있습니다. INTEGER PRIMARY KEY 열에 NULL을 삽입하려고하면 열이 실제로 테이블에서 이미 가장 큰 키보다 큰 정수로 채워집니다. 또는 가장 큰 키가 2147483647이면 열이 임의의 정수로 채워집니다. 어느 쪽이든 INTEGER PRIMARY KEY 열에는 고유 한 정수가 할당됩니다. &lt;b&gt;sqlite_last_insert_rowid ()&lt;/b&gt; API 함수를 사용하거나 후속 SELECT 문에서 &lt;b&gt;last_insert_rowid ()&lt;/b&gt; SQL 함수를 사용하여이 정수를 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f436e25f27f33e27c6053472309a17baa61d133" translate="yes" xml:space="preserve">
          <source>INTERFACE</source>
          <target state="translated">INTERFACE</target>
        </trans-unit>
        <trans-unit id="3230de938114213aa9c2d1e95f291cad51ede171" translate="yes" xml:space="preserve">
          <source>INTERSECT</source>
          <target state="translated">INTERSECT</target>
        </trans-unit>
        <trans-unit id="ce45b16212fe00c28d1a00de9cdfe954aa5bdc83" translate="yes" xml:space="preserve">
          <source>INTO</source>
          <target state="translated">INTO</target>
        </trans-unit>
        <trans-unit id="ec4a2a5056d72d8e03345caaebf4607d163e6dd7" translate="yes" xml:space="preserve">
          <source>IS</source>
          <target state="translated">IS</target>
        </trans-unit>
        <trans-unit id="819809f7649d3da66fd65a40dff83509ed2b98d0" translate="yes" xml:space="preserve">
          <source>IS NOT</source>
          <target state="translated">아니다</target>
        </trans-unit>
        <trans-unit id="437390c0773d23a0b0e272480ef7204b356f23ad" translate="yes" xml:space="preserve">
          <source>IS operator</source>
          <target state="translated">IS 연산자</target>
        </trans-unit>
        <trans-unit id="4e93120a53b25e7642cc15924ececcc7c79ac693" translate="yes" xml:space="preserve">
          <source>ISNULL</source>
          <target state="translated">ISNULL</target>
        </trans-unit>
        <trans-unit id="c8c6b6fe3176986c9e57f2648e139dfd273d0908" translate="yes" xml:space="preserve">
          <source>Ideally, all changes for an entire write transaction are buffered in the page cache until the end of the transaction. When the user commits the transaction, all changes are applied to the database file in the most efficient way possible, taking into account the assumptions enumerated in section</source>
          <target state="translated">이상적으로는 전체 쓰기 트랜잭션에 대한 모든 변경 사항이 트랜잭션이 끝날 때까지 페이지 캐시에 버퍼링됩니다. 사용자가 트랜잭션을 커밋하면 모든 변경 사항이 섹션에 열거 된 가정을 고려하여 가장 효율적인 방식으로 데이터베이스 파일에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6acc0ba610f36525f417357719583f041f6f89df" translate="yes" xml:space="preserve">
          <source>Identify all methods for important objects in the interface documentation. (&lt;a href=&quot;c3ref/context&quot;&gt;example&lt;/a&gt;)</source>
          <target state="translated">인터페이스 문서에서 중요한 객체에 대한 모든 방법을 식별하십시오. ( &lt;a href=&quot;c3ref/context&quot;&gt;예&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b22904746b6da6e6da1cdf65a007a3a92ddeb189" translate="yes" xml:space="preserve">
          <source>IdxDelete</source>
          <target state="translated">IdxDelete</target>
        </trans-unit>
        <trans-unit id="366f895979adef772b50f0a751ee770dc166bab5" translate="yes" xml:space="preserve">
          <source>IdxGE</source>
          <target state="translated">IdxGE</target>
        </trans-unit>
        <trans-unit id="267d8b7b66c2e63c7420b46c7edd1ef118e13442" translate="yes" xml:space="preserve">
          <source>IdxGT</source>
          <target state="translated">IdxGT</target>
        </trans-unit>
        <trans-unit id="bdc0a8ea07737acbd00822ec9e49840776244c14" translate="yes" xml:space="preserve">
          <source>IdxInsert</source>
          <target state="translated">IdxInsert</target>
        </trans-unit>
        <trans-unit id="ba9bc003fbf28927e55ed674e6312a7b981c1435" translate="yes" xml:space="preserve">
          <source>IdxLE</source>
          <target state="translated">IdxLE</target>
        </trans-unit>
        <trans-unit id="11ede54300baae62726a3150e6c2f825098c4577" translate="yes" xml:space="preserve">
          <source>IdxLT</source>
          <target state="translated">IdxLT</target>
        </trans-unit>
        <trans-unit id="c82f35a450e8e6ba85d6a5ba639866e8424ba8d9" translate="yes" xml:space="preserve">
          <source>IdxRowid</source>
          <target state="translated">IdxRowid</target>
        </trans-unit>
        <trans-unit id="751c68a3471b1c791efaee0a8e7c24ea0c266efd" translate="yes" xml:space="preserve">
          <source>If</source>
          <target state="translated">If</target>
        </trans-unit>
        <trans-unit id="7194c23292e4ec0e7bfbbaa15bc21cc90107f2f5" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">경우 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 물체 V를 사용하여 초기화시켰다 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;(S, I, P, X, D) sqlite3_bind_pointer을&lt;/a&gt; 하거나 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_pointer (C, P, X, D)&lt;/a&gt; 과 X 및 Y는 STRCMP 동등한있어서 비교 문자열 (X, Y)를, 있다면 sqlite3_value_pointer (V, Y)는 포인터 P를 반환합니다. 그렇지 않으면 sqlite3_value_pointer (V, Y)는 NULL을 반환합니다. sqlite3_bind_pointer () 루틴은 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 SQLite 3.20.0에 추가 된 .</target>
        </trans-unit>
        <trans-unit id="6f26b5b5b34df807b99862702ef8a28042e009ca" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;../uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">경우 &lt;a href=&quot;../uri&quot;&gt;URI 파일 이름의&lt;/a&gt; 해석이 가능하며, 파일 이름 인수로 시작 &quot;파일 :&quot;다음 파일 이름은 URI로 해석됩니다. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그가 세 번째 인수에서 sqlite3_open_v2 ()로 설정 되거나 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 메소드 와 함께 또는 &lt;a href=&quot;../compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; 컴파일 타임 옵션으로 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; 옵션을 사용하여 전체적으로 사용 가능한 경우 URI 파일 이름 해석이 사용 가능합니다 . URI 파일 이름 해석은 기본적으로 해제되어 있지만 향후 릴리스의 SQLite에서는 기본적으로 URI 파일 이름 해석을 활성화 할 수 있습니다. &quot; &lt;a href=&quot;../uri&quot;&gt;URI 파일 이름&lt;/a&gt; 참조 추가 정보는 &quot;을 .</target>
        </trans-unit>
        <trans-unit id="05071756ec11a7890791b184fe1e16795132ff77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;enabled&lt;/a&gt; and a column with a &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;REFERENCES clause&lt;/a&gt; is added, the column must have a default value of NULL.</source>
          <target state="translated">경우 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건이&lt;/a&gt; 된다 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;활성화&lt;/a&gt; 하고있는 열 &lt;a href=&quot;syntax/foreign-key-clause&quot;&gt;참조 절&lt;/a&gt; 추가, 열이 NULL의 디폴트 값이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f1ff78b03ab38bd9d7bc0c0b70bf71a047d9c7f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; are enabled, a DROP TABLE command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE FROM&lt;/a&gt; command before removing the table from the database schema. Any triggers attached to the table are dropped from the database schema before the implicit DELETE FROM is executed, so this cannot cause any triggers to fire. By contrast, an implicit DELETE FROM does cause any configured &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; to take place. If the implicit DELETE FROM executed as part of a DROP TABLE command violates any immediate foreign key constraints, an error is returned and the table is not dropped. If the implicit DELETE FROM causes any deferred foreign key constraints to be violated, and the violations still exist when the transaction is committed, an error is returned at the time of commit.</source>
          <target state="translated">경우 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건을&lt;/a&gt; 활성화하는 DROP TABLE 명령이 암시 수행 &lt;a href=&quot;lang_delete&quot;&gt;에서 삭제&lt;/a&gt; 데이터베이스 스키마에서 테이블을 제거하기 전에 명령을. 암시 적 DELETE FROM이 실행되기 전에 테이블에 연결된 모든 트리거가 데이터베이스 스키마에서 삭제되므로 트리거가 실행될 수 없습니다. 반대로, 암시 적 DELETE FROM은 구성된 &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 동작을&lt;/a&gt; 유발합니다. 을 발생시킵니다. DROP TABLE 명령의 일부로 실행 된 내재적 DELETE FROM이 즉시 외부 키 제한 조건을 위반하면 오류가 리턴되고 테이블이 삭제되지 않습니다. 내재 된 DELETE FROM으로 인해 지연된 외래 키 제약 조건이 위반되고 트랜잭션이 커밋 될 때 위반이 여전히 존재하면 커밋시 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5f1e27999e2bb2ba42de86bd45d31998c0603f29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt; is set to OFF (thus disabling the rollback journal file) then the behavior of the ROLLBACK command is undefined.</source>
          <target state="translated">경우 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode는&lt;/a&gt; (따라서 롤백 저널 파일을 해제)를 OFF로 설정 한 후 ROLLBACK 명령의 동작은 보증되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff29cd60491f93076673fb75bedc0744960c9309" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;EXCLUSIVE locking mode&lt;/a&gt; is set prior to the first WAL-mode database access, then SQLite never attempts to call any of the shared-memory methods and hence no shared-memory wal-index is ever created. In that case, the database connection remains in EXCLUSIVE mode as long as the journal mode is WAL; attempts to change the locking mode using &quot;&lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt;&quot; are no-ops. The only way to change out of EXCLUSIVE locking mode is to first change out of WAL journal mode.</source>
          <target state="translated">경우 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;배타적 잠금 모드가&lt;/a&gt; 이전에 최초의 WAL-모드 데이터베이스 액세스로 설정되어, 다음 SQLite는 결코 시도는 공유 메모리의 방법 중 하나 따라서 어떤 공유 메모리 월마트 인덱스 이제까지 생성을 호출합니다. 이 경우, 저널 모드가 WAL 인 한 데이터베이스 연결은 EXCLUSIVE 모드로 유지됩니다. &quot; &lt;code&gt;PRAGMA locking_mode=NORMAL;&lt;/code&gt; &quot;을 사용하여 잠금 모드를 변경하려고 시도 하지 않습니다. 독점 잠금 모드를 변경하는 유일한 방법은 먼저 WAL 저널 모드를 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="53ecc95d367e022d4f668ded862caf4b37a61a3f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; interpretation is enabled, and the filename argument begins with &quot;file:&quot;, then the filename is interpreted as a URI. URI filename interpretation is enabled if the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flag is set in the third argument to sqlite3_open_v2(), or if it has been enabled globally using the &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; option with the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; method or by the &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; compile-time option. URI filename interpretation is turned off by default, but future releases of SQLite might enable URI filename interpretation by default. See &quot;&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">경우 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름의&lt;/a&gt; 해석이 가능하며, 파일 이름 인수로 시작 &quot;파일 :&quot;다음 파일 이름은 URI로 해석됩니다. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그가 세 번째 인수에서 sqlite3_open_v2 ()로 설정 되거나 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 메소드 와 함께 또는 &lt;a href=&quot;compile#use_uri&quot;&gt;SQLITE_USE_URI&lt;/a&gt; 컴파일 타임 옵션으로 &lt;a href=&quot;#sqliteconfiguri&quot;&gt;SQLITE_CONFIG_URI&lt;/a&gt; 옵션을 사용하여 전체적으로 사용 가능한 경우 URI 파일 이름 해석이 사용 가능합니다 . URI 파일 이름 해석은 기본적으로 해제되어 있지만 향후 릴리스의 SQLite에서는 기본적으로 URI 파일 이름 해석을 활성화 할 수 있습니다. 추가 정보는 &quot; &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; &quot;을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b1cbecea1bfc84769a23d468c11c6578d2f04c8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V was initialized using &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_pointer(S,I,P,X,D)&lt;/a&gt; or &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer(C,P,X,D)&lt;/a&gt; and if X and Y are strings that compare equal according to strcmp(X,Y), then sqlite3_value_pointer(V,Y) will return the pointer P. Otherwise, sqlite3_value_pointer(V,Y) returns a NULL. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">경우 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 물체 V를 사용하여 초기화시켰다 &lt;a href=&quot;bind_blob&quot;&gt;(S, I, P, X, D) sqlite3_bind_pointer을&lt;/a&gt; 하거나 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_pointer (C, P, X, D)&lt;/a&gt; 과 X 및 Y는 STRCMP 동등한있어서 비교 문자열 (X, Y)를, 있다면 sqlite3_value_pointer (V, Y)는 포인터 P를 반환합니다. 그렇지 않으면 sqlite3_value_pointer (V, Y)는 NULL을 반환합니다. sqlite3_bind_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;../bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="efa51497a7f80ea6cb0e82aee000934c754a4257" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B THEN B&amp;gt;A.</source>
          <target state="translated">A &amp;lt;B THEN B&amp;gt; A 인 경우.</target>
        </trans-unit>
        <trans-unit id="af85ab5198e03592c9a1e93f75055ff7f7b4d432" translate="yes" xml:space="preserve">
          <source>If A&amp;lt;B and B&amp;lt;C then A&amp;lt;C.</source>
          <target state="translated">A &amp;lt;B 및 B &amp;lt;C이면 A &amp;lt;C.</target>
        </trans-unit>
        <trans-unit id="ee7bb0a19c51474ba2d6ea010cd538d977b0b7a6" translate="yes" xml:space="preserve">
          <source>If A==B and B==C then A==C.</source>
          <target state="translated">A == B이고 B == C이면 A == C입니다.</target>
        </trans-unit>
        <trans-unit id="ad62f244096def890ab26a681e8f0120126f5af5" translate="yes" xml:space="preserve">
          <source>If A==B then B==A.</source>
          <target state="translated">A == B이면 B == A입니다.</target>
        </trans-unit>
        <trans-unit id="215c914a1a9a516e367b5ac91682005ac659922c" translate="yes" xml:space="preserve">
          <source>If AUTOVACUUM is enabled then it is possible that another root page might be moved into the newly deleted root page in order to keep all root pages contiguous at the beginning of the database. The former value of the root page that moved - its value before the move occurred - is stored in register P2. If no page movement was required (because the table being dropped was already the last one in the database) then a zero is stored in register P2. If AUTOVACUUM is disabled then a zero is stored in register P2.</source>
          <target state="translated">AUTOVACUUM이 사용 가능한 경우 데이터베이스의 시작 부분에서 모든 루트 페이지를 연속적으로 유지하기 위해 다른 루트 페이지가 새로 삭제 된 루트 페이지로 이동 될 수 있습니다. 이동 한 루트 페이지의 이전 값 (이동이 발생하기 전의 값)은 레지스터 P2에 저장됩니다. 페이지 이동이 필요하지 않은 경우 (삭제되는 테이블이 이미 데이터베이스의 마지막 테이블이므로) 레지스터 P2에 0이 저장됩니다. AUTOVACUUM이 비활성화되면 레지스터 P2에 0이 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ed950ba22e4eb6cfb3232df6ec7b67b59a4df463" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_CONFLICT conflict handler, then the conflicting row is removed from the database and a second attempt to apply the change is made. If this second attempt fails, the original row is restored to the database before continuing.</source>
          <target state="translated">SQLITE_CHANGESET_CONFLICT 충돌 핸들러가 CHANGESET_REPLACE를 리턴하면 충돌하는 행이 데이터베이스에서 제거되고 두 번째로 변경 사항을 적용하려고 시도합니다. 이 두 번째 시도가 실패하면 계속하기 전에 원래 행이 데이터베이스로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="30467096b4dd78c0d45cf667e992ae71e7009c64" translate="yes" xml:space="preserve">
          <source>If CHANGESET_REPLACE is returned by an SQLITE_CHANGESET_DATA conflict handler, then the conflicting row is either updated or deleted, depending on the type of change.</source>
          <target state="translated">CHANGESET_REPLACE가 SQLITE_CHANGESET_DATA 충돌 핸들러에 의해 리턴되면 충돌 유형은 변경 유형에 따라 업데이트되거나 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6c0fd79d5064239e68ae7d0df720319dab8e2b" translate="yes" xml:space="preserve">
          <source>If F is a NULL pointer, then sqlite3_uri_parameter(F,P) returns NULL and sqlite3_uri_boolean(F,P,B) returns B. If F is not a NULL pointer and is not a database file pathname pointer that SQLite passed into the xOpen VFS method, then the behavior of this routine is undefined and probably undesirable.</source>
          <target state="translated">F가 NULL 포인터 인 경우 sqlite3_uri_parameter (F, P)는 NULL을 리턴하고 sqlite3_uri_boolean (F, P, B)는 B를 리턴합니다. F가 NULL 포인터가 아니며 SQLite가 xOpen VFS로 전달한 데이터베이스 파일 경로 이름 포인터가 아닌 경우 이 루틴의 동작은 정의되지 않았으며 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9276605b0b0a889bb4c7aa5fcec85c6fc6240625" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">F가 xOpen ()에 대한 플래그 매개 변수에 하나 이상의 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; 비트 세트가 있고 P가 조회 매개 변수의 이름 인 경우 VFS 구현의 xOpen () 메소드에 전달 된 데이터베이스 파일 이름 포인터 인 경우 sqlite3_uri_parameter ( F, P)는 P 매개 변수가 존재하는 경우 P 매개 변수의 값을 리턴하고, P가 F에 조회 매개 변수로 나타나지 않으면 NULL 포인터를 리턴합니다. 빈 문자열에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8ba138ee3e59443a69735dbcd87f0f8269dd9564" translate="yes" xml:space="preserve">
          <source>If F is the database filename pointer passed into the xOpen() method of a VFS implementation when the flags parameter to xOpen() has one or more of the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; bits set and P is the name of the query parameter, then sqlite3_uri_parameter(F,P) returns the value of the P parameter if it exists or a NULL pointer if P does not appear as a query parameter on F. If P is a query parameter of F has no explicit value, then sqlite3_uri_parameter(F,P) returns a pointer to an empty string.</source>
          <target state="translated">F가 xOpen ()에 대한 플래그 매개 변수에 하나 이상의 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 또는 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_DB&lt;/a&gt; 비트 세트가 있고 P가 조회 매개 변수의 이름 인 경우 VFS 구현의 xOpen () 메소드에 전달 된 데이터베이스 파일 이름 포인터 인 경우 sqlite3_uri_parameter ( F, P)는 P 매개 변수가 존재하는 경우 P 매개 변수의 값을 리턴하고, P가 F에 조회 매개 변수로 나타나지 않으면 NULL 포인터를 리턴합니다. 빈 문자열에 대한 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="298246b211caead4a1410b71d74279a5d314bec4" translate="yes" xml:space="preserve">
          <source>If FILE is a ZIP archive rather than an SQLite Archive, the &quot;.archive&quot; command and the &quot;-A&quot; command-line option still work. This is accomplished using of the &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; extension. Hence, the following commands are roughly equivalent, differing only in output formatting:</source>
          <target state="translated">FILE이 SQLite 아카이브가 아닌 ZIP 아카이브 인 경우 &quot;.archive&quot;명령 및 &quot;-A&quot;명령 행 옵션이 계속 작동합니다. 이것은 &lt;a href=&quot;zipfile&quot;&gt;zip 파일&lt;/a&gt; 확장자를 사용하여 수행됩니다 . 따라서 다음 명령은 출력 형식에서만 다른 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d860543f88997bfbcee9b4b76e89b05bba6e3e47" translate="yes" xml:space="preserve">
          <source>If M is -1 in the initial journal header, then the number of page records that follow is computed by computing how many page records will fit in the available space of the remainder of the journal file.</source>
          <target state="translated">초기 저널 헤더에서 M이 -1이면 후속 저널 파일 수는 나머지 저널 파일의 사용 가능한 공간에 얼마나 많은 페이지 레코드가 들어갈 지 계산하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="9d3a57a4870ed12272e250deed6ea841c224df1b" translate="yes" xml:space="preserve">
          <source>If NORMAL locking mode is in effect for the first WAL-mode database access, then the shared-memory wal-index is created. This means that the underlying VFS must support the &quot;version 2&quot; shared-memory. If the VFS does not support shared-memory methods, then the attempt to open a database that is already in WAL mode, or the attempt convert a database into WAL mode, will fail. As long as exactly one connection is using a shared-memory wal-index, the locking mode can be changed freely between NORMAL and EXCLUSIVE. It is only when the shared-memory wal-index is omitted, when the locking mode is EXCLUSIVE prior to the first WAL-mode database access, that the locking mode is stuck in EXCLUSIVE.</source>
          <target state="translated">첫 번째 WAL 모드 데이터베이스 액세스에 NORMAL 잠금 모드가 적용되는 경우 공유 메모리 wal-index가 작성됩니다. 이는 기본 VFS가 &quot;버전 2&quot;공유 메모리를 지원해야 함을 의미합니다. VFS가 공유 메모리 방법을 지원하지 않으면 이미 WAL 모드에있는 데이터베이스를 열거 나 데이터베이스를 WAL 모드로 변환하지 못합니다. 정확히 하나의 연결이 공유 메모리 wal-index를 사용하는 한, 잠금 모드는 NORMAL과 EXCLUSIVE 사이에서 자유롭게 변경할 수 있습니다. 공유 메모리 wal-index가 생략 된 경우에만, 잠금 모드가 첫 번째 WAL 모드 데이터베이스 액세스 이전에 독점적 일 때 잠금 모드는 독점적입니다.</target>
        </trans-unit>
        <trans-unit id="084a98d24eb789b16e0f410999491d6ca6f68655" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mode column, then the mode of the new archive entry is automatically set to either 33188 (-rw-r--r--) or 16877 (drwxr-xr-x), depending on whether or not the values specified for columns &quot;sz&quot;, &quot;data&quot; and &quot;rawdata&quot; indicate that the new entry is a directory.</source>
          <target state="translated">NULL이 모드 열에 삽입되면 새 아카이브 항목의 모드는 자동으로 33188 (-rw-r--r--) 또는 16877 (drwxr-xr-x)로 설정됩니다. &quot;sz&quot;, &quot;data&quot;및 &quot;rawdata&quot;열에 지정된 값은 새 항목이 디렉토리임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4101f8cb88698edd15d7c951de1289b2d8eaa71c" translate="yes" xml:space="preserve">
          <source>If NULL is inserted into the mtime column, then the timestamp of the new entry is set to the current time. Otherwise, the specified value is interpreted as an integer and used as is.</source>
          <target state="translated">mtime 열에 NULL이 삽입되면 새 항목의 타임 스탬프가 현재 시간으로 설정됩니다. 그렇지 않으면 지정된 값이 정수로 해석되어 그대로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="43806989f629698fba47d7f7a7bc8a167120b2e8" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_area(P) returns the area enclosed by that polygon. If P is not a polygon, geopoly_area(P) returns NULL.</source>
          <target state="translated">P가 다각형이면 geopoly_area (P)는 해당 다각형으로 둘러싸인 영역을 반환합니다. P가 다각형이 아닌 경우 geopoly_area (P)는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7923fadf3f55cd9b6d47a16ad18e97575f464043" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_bbox(P) returns a new polygon that is the smallest (axis-aligned) rectangle completely enclosing P. If P is not a polygon, geopoly_bbox(P) returns NULL.</source>
          <target state="translated">P가 다각형 인 경우 geopoly_bbox (P)는 P를 완전히 둘러싸는 가장 작은 (축 정렬) 사각형 인 새 다각형을 반환합니다. P가 다각형이 아닌 경우 geopoly_bbox (P)는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="231cf86fd88561789cf32053e3b5a58ac30a1c90" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_blob(P) returns the binary encoding of that polygon as a BLOB. If P is not a polygon, geopoly_blob(P) returns NULL.</source>
          <target state="translated">P가 다각형이면 geopoly_blob (P)는 해당 다각형의 이진 인코딩을 BLOB으로 반환합니다. P가 다각형이 아닌 경우 geopoly_blob (P)는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85466629c4fd74bf6816a1cb264ff5557384a47f" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_contains_point(P,X,Y) returns a non-zero integer if and only if the coordinate X,Y is inside or on the boundary of the polygon P. If P is not a polygon, geopoly_contains_point(P,X,Y) returns NULL.</source>
          <target state="translated">P가 다각형 인 경우 geopoly_contains_point (P, X, Y)는 좌표 X, Y가 다각형 P의 내부 또는 경계에있는 경우에만 0이 아닌 정수를 반환합니다. P가 다각형이 아닌 경우 geopoly_contains_point ( P, X, Y)는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="01d01cedd541548c033da5a76ae2b943d566e364" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_json(P) returns the GeoJSON representation of that polygon as a TEXT string. If P is not a polygon, geopoly_json(P) returns NULL.</source>
          <target state="translated">P가 다각형이면 geopoly_json (P)는 해당 다각형의 GeoJSON 표현을 TEXT 문자열로 반환합니다. P가 다각형이 아닌 경우 geopoly_json (P)는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4d96f5fac84b02e3eed71829015c2301166a1102" translate="yes" xml:space="preserve">
          <source>If P is a polygon, then geopoly_svg(P,...) returns a text string which is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;Scalable Vector Graphics (SVG)&lt;/a&gt; representation of that polygon. If there is more one argument, then second and subsequent arguments are added as attributes to each SVG glyph. For example:</source>
          <target state="translated">P가 다각형이면 geopoly_svg (P, ...)는 해당 다각형의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Scalable_Vector_Graphics&quot;&gt;SVG (Scalable Vector Graphics)&lt;/a&gt; 표현 인 텍스트 문자열을 반환합니다 . 하나 이상의 인수가 있으면 두 번째 이후의 인수가 각 SVG 글리프에 속성으로 추가됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8bf89c8791c7886430f52d199af4522be0892c2c" translate="yes" xml:space="preserve">
          <source>If P is not a polygon, geopoly_svg(P,...) returns NULL.</source>
          <target state="translated">P가 다각형이 아닌 경우 geopoly_svg (P, ...)는 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8d6c1d000f406140de377a0a6166c3f4f4ee6ecf" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;gt;X then the first M bytes of P are stored on the btree page and the remaining P-M bytes are stored on overflow pages.</source>
          <target state="translated">P&amp;gt; X 및 K&amp;gt; X이면 P의 첫 번째 M 바이트는 btree 페이지에 저장되고 나머지 PM 바이트는 오버플로 페이지에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="40c35ab59089c6d8a3b822955c4be859755a9e2b" translate="yes" xml:space="preserve">
          <source>If P&amp;gt;X and K&amp;lt;=X then the first K bytes of P are stored on the btree page and the remaining P-K bytes are stored on overflow pages.</source>
          <target state="translated">P&amp;gt; X 및 K &amp;lt;= X이면 P의 첫 번째 K 바이트는 btree 페이지에 저장되고 나머지 PK 바이트는 오버플로 페이지에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fa33ffa92f81891eff9dffa21d7e8d38e3faa786" translate="yes" xml:space="preserve">
          <source>If P&amp;lt;=X then all P bytes of payload are stored directly on the btree page without overflow.</source>
          <target state="translated">P &amp;lt;= X이면 페이로드의 모든 P 바이트가 오버플로없이 btree 페이지에 직접 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a69350651a4faef3f95c007babd7352f8f77d85e" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_overlap(P1,P2) function returns a non-zero integer if there is any overlap between P1 and P2, or it returns zero if P1 and P2 completely disjoint. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">P1과 P2가 모두 다각형 인 경우 geopoly_overlap (P1, P2) 함수는 P1과 P2간에 겹치는 부분이 있으면 0이 아닌 정수를 반환하거나 P1과 P2가 완전히 분리 된 경우 0을 반환합니다. P1 또는 P2가 다각형이 아닌 경우이 루틴은 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dd9f5db9ef38463d2501fa9dc6b70e3f4750a4f2" translate="yes" xml:space="preserve">
          <source>If P1 and P2 are both polygons, then the geopoly_within(P1,P2) function returns a non-zero integer if P2 is completely contained within P1, or it returns zero if any part of P2 is outside of P1. If P1 and P2 are the same polygon, this routine returns non-zero. If either P1 or P2 is not a polygon, this routine returns NULL.</source>
          <target state="translated">P1과 P2가 둘 다 다각형 인 경우 geopoly_within (P1, P2) 함수는 P2가 P1에 완전히 포함되어 있으면 0이 아닌 정수를 반환하거나 P2의 일부가 P1 밖에 있으면 0을 반환합니다. P1과 P2가 동일한 다각형이면이 루틴은 0이 아닌 값을 반환합니다. P1 또는 P2가 다각형이 아닌 경우이 루틴은 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4157b5ffd90247cfe9008c1ae67666efa84d2bdb" translate="yes" xml:space="preserve">
          <source>If P1 is 0, then all SQL statements become expired. If P1 is non-zero, then only the currently executing statement is expired.</source>
          <target state="translated">P1이 0이면 모든 SQL 문이 만료됩니다. P1이 0이 아닌 경우 현재 실행중인 명령문 만 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="7196e8103cc1b57f49e64f9cffafd04bf56cea94" translate="yes" xml:space="preserve">
          <source>If P1 is non-zero, then the jump is taken if the database constraint-counter is zero (the one that counts deferred constraint violations). If P1 is zero, the jump is taken if the statement constraint-counter is zero (immediate foreign key constraint violations).</source>
          <target state="translated">P1이 0이 아닌 경우, 데이터베이스 제한 카운터가 0 (지연된 제한 위반을 계산하는 것) 인 경우 점프가 수행됩니다. P1이 0 인 경우 명령문 제한 조건 카운터가 0 인 경우 점프가 수행됩니다 (즉각 외래 키 제한 조건 위반).</target>
        </trans-unit>
        <trans-unit id="e76da0aa98d442426a710c17ffdd5c83f500e5de" translate="yes" xml:space="preserve">
          <source>If P1 is not zero, then it is a register that a subsequent min() or max() aggregate will set to 1 if the current row is not the minimum or maximum. The P1 register is initialized to 0 by this instruction.</source>
          <target state="translated">P1이 0이 아닌 경우 현재 행이 최소값 또는 최대 값이 아닌 경우 후속 min () 또는 max () 집계가 1로 설정되는 것은 레지스터입니다. P1 레지스터는이 명령어에 의해 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="12e05de4c2b1f6e3dffb8fed2e435034a63c1753" translate="yes" xml:space="preserve">
          <source>If P2 is 0, then SQL statements are expired immediately. If P2 is 1, then running SQL statements are allowed to continue to run to completion. The P2==1 case occurs when a CREATE INDEX or similar schema change happens that might help the statement run faster but which does not affect the correctness of operation.</source>
          <target state="translated">P2가 0이면 SQL 문이 즉시 만료됩니다. P2가 1이면 실행중인 SQL 문을 계속 실행하여 완료 할 수 있습니다. P2 == 1의 경우는 CREATE INDEX 또는 유사한 스키마 변경이 발생하면 명령문이 더 빨리 실행하는 데 도움이 될 수 있지만 조작의 정확성에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b95c82eece8cdb232cd3c969e9f714560a3483ed" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, jump to instruction P2.</source>
          <target state="translated">P2가 0이 아니면 명령어 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="624ae34f34a46b97a6ede8c6928e2854d808cc50" translate="yes" xml:space="preserve">
          <source>If P2 is not zero, then it is a register holding a string which is the file into which the result of vacuum should be written. When P2 is zero, the vacuum overwrites the original database.</source>
          <target state="translated">P2가 0이 아닌 경우, 진공 결과를 기록 할 파일 인 문자열을 보유하는 레지스터입니다. P2가 0이면 진공이 원본 데이터베이스를 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="4101c4124c3fe6e483990efc85814b11a364af14" translate="yes" xml:space="preserve">
          <source>If P2!=0 then the coroutine implementation immediately follows this opcode. So jump over the coroutine implementation to address P2.</source>
          <target state="translated">P2! = 0이면 코 루틴 구현은이 opcode 바로 뒤에옵니다. 따라서 코 루틴 구현을 뛰어 넘어 P2를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="95acd6cd81e68312a7b3f200adb71394407e2187" translate="yes" xml:space="preserve">
          <source>If P2==1 then no insert is performed. argv[0] is the rowid of a row to delete.</source>
          <target state="translated">P2 == 1이면 삽입이 수행되지 않습니다. argv [0]은 삭제할 행의 rowid입니다.</target>
        </trans-unit>
        <trans-unit id="4b3305a3179f27393cd2b3c6dff28468fd2e27f2" translate="yes" xml:space="preserve">
          <source>If P3 is not zero and the content of register P3 is equal to P5, then the datatype of the register P2 is converted to BLOB. The content is the same sequence of bytes, it is merely interpreted as a BLOB instead of a string, as if it had been CAST. In other words:</source>
          <target state="translated">P3이 0이 아니고 레지스터 P3의 내용이 P5와 같으면 레지스터 P2의 데이터 유형이 BLOB로 변환됩니다. 내용은 동일한 바이트 시퀀스이며 마치 마치 CAST 인 것처럼 문자열 대신 BLOB로 해석됩니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="7b12a88585bcaf8799451da77eaddd8eae80e136" translate="yes" xml:space="preserve">
          <source>If P3 is not zero, then it is an address to jump to if an SQLITE_CORRUPT error is encountered.</source>
          <target state="translated">P3이 0이 아니면 SQLITE_CORRUPT 오류가 발생하면 바로 이동할 주소입니다.</target>
        </trans-unit>
        <trans-unit id="c8b8a297f15c969bf51cec7bd085ee38d68f8af2" translate="yes" xml:space="preserve">
          <source>If P3!=0 then the content of the P2 register is unsuitable for use in OP_Result and any OP_Result will invalidate the P2 register content. The P2 register content is invalidated by opcodes like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; or by any use of another cursor pointing to the same table.</source>
          <target state="translated">P3! = 0이면 P2 레지스터의 내용이 OP_Result에서 사용하기에 적합하지 않으며 OP_Result가 P2 레지스터 내용을 무효화합니다. P2 레지스터 내용은 &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; 과 같은 opcode 또는 동일한 테이블을 가리키는 다른 커서를 사용하여 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0e377e900f9f81e14b13484040277f239153040" translate="yes" xml:space="preserve">
          <source>If P3!=0 then this opcode is allowed to make an ephemeral pointer into the database page. That means that the content of the output register will be invalidated as soon as the cursor moves - including moves caused by other cursors that &quot;save&quot; the current cursors position in order that they can write to the same table. If P3==0 then a copy of the data is made into memory. P3!=0 is faster, but P3==0 is safer.</source>
          <target state="translated">P3! = 0이면이 opcode는 데이터베이스 페이지에 임시 포인터를 만들 수 있습니다. 즉, 커서가 동일한 테이블에 쓸 수 있도록 현재 커서 위치를 &quot;저장&quot;하는 다른 커서로 인한 이동을 포함하여 커서가 이동하자마자 출력 레지스터의 내용이 무효화됩니다. P3 == 0이면 데이터 사본이 메모리에 작성됩니다. P3! = 0이 빠르지 만 P3 == 0이 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="261dff5d4c60a753fca80ceb7a30b1ccde835d53" translate="yes" xml:space="preserve">
          <source>If P3&amp;gt;0 then P3 is a register in the root frame of this VDBE that holds the largest previously generated record number. No new record numbers are allowed to be less than this value. When this value reaches its maximum, an SQLITE_FULL error is generated. The P3 register is updated with the ' generated record number. This P3 mechanism is used to help implement the AUTOINCREMENT feature.</source>
          <target state="translated">P3&amp;gt; 0이면 P3은이 VDBE의 루트 프레임에있는 레지스터로, 이전에 생성 된 가장 큰 레코드 번호를 보유합니다. 새 레코드 번호는이 값보다 작을 수 없습니다. 이 값이 최대 값에 도달하면 SQLITE_FULL 오류가 생성됩니다. P3 레지스터는 생성 된 레코드 번호로 업데이트됩니다. 이 P3 메커니즘은 AUTOINCREMENT 기능을 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b537aafa079e151774c7dbac498d69a9800ce496" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==0 then r[P2] := r[P1] IS TRUE</source>
          <target state="translated">P3 == 0이고 P4 == 0이면 r [P2] : = r [P1]은 참</target>
        </trans-unit>
        <trans-unit id="4abb01d048e9054de1718b2c97d7bca8f72ca3fd" translate="yes" xml:space="preserve">
          <source>If P3==0 and P4==1 then r[P2] := r[P1] IS NOT TRUE</source>
          <target state="translated">P3 == 0이고 P4 == 1이면 r [P2] : = r [P1]이 참이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e0f5592c3dfac53b5b17bcf906b1b3d9b28a160a" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==0 then r[P2] := r[P1] IS NOT FALSE</source>
          <target state="translated">P3 == 1이고 P4 == 0이면 r [P2] : = r [P1]은 거짓이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ec92d66dd345ec321132b256dce88d1a72413c5f" translate="yes" xml:space="preserve">
          <source>If P3==1 and P4==1 then r[P2] := r[P1] IS FALSE</source>
          <target state="translated">P3 == 1이고 P4 == 1이면 r [P2] : = r [P1]은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="ec8063043e0a9cad56cc57c55e1e58a5f2b9e719" translate="yes" xml:space="preserve">
          <source>If P4 is NULL then all index fields have the affinity BLOB.</source>
          <target state="translated">P4가 NULL이면 모든 인덱스 필드는 선호도 BLOB를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="0409d4d0ae010acb4eb82b5c67e7d26a4e78a377" translate="yes" xml:space="preserve">
          <source>If P4 is not NULL then it points to a Table object. In this case either the update or pre-update hook, or both, may be invoked. The P1 cursor must have been positioned using &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; prior to invoking this opcode in this case. Specifically, if one is configured, the pre-update hook is invoked if P4 is not NULL. The update-hook is invoked if one is configured, P4 is not NULL, and the OPFLAG_NCHANGE flag is set in P2.</source>
          <target state="translated">P4가 NULL이 아니면 Table 객체를 가리 킵니다. 이 경우 업데이트 또는 사전 업데이트 후크 또는 둘 다 호출 될 수 있습니다. 이 경우이 opcode를 호출하기 전에 &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound를&lt;/a&gt; 사용하여 P1 커서를 배치해야합니다 . 특히 하나가 구성된 경우 P4가 NULL이 아닌 경우 사전 업데이트 후크가 호출됩니다. 업데이트 훅이 구성되고 P4가 NULL이 아니고 OPFLAG_NCHANGE 플래그가 P2에 설정된 경우 업데이트 훅이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="833039fcfc9ba1341a8bac648d6011bebc9ef640" translate="yes" xml:space="preserve">
          <source>If P4 is not null then it is an error message string.</source>
          <target state="translated">P4가 널이 아니면 오류 메시지 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="323b07c0a29678efca20be714e85be9034012831" translate="yes" xml:space="preserve">
          <source>If P4 is not zero, then it is the number of values in the unpacked key of reg(P2). In that case, P3 is the index of the first register for the unpacked key. The availability of the unpacked key can sometimes be an optimization.</source>
          <target state="translated">P4가 0이 아닌 경우 압축 해제 된 reg (P2) 키의 값 수입니다. 이 경우 P3은 압축 해제 된 키에 대한 첫 번째 레지스터의 인덱스입니다. 압축 해제 된 키의 가용성은 때때로 최적화 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f6b94d7be2c05fd8f0bc6b7de40e344824f8d5b" translate="yes" xml:space="preserve">
          <source>If P4==0 then register P3 holds a blob constructed by &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;. If P4&amp;gt;0 then register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">P4 == 0 인 경우 레지스터 P3은 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord로&lt;/a&gt; 구성된 Blob을 보유합니다 . P4&amp;gt; 0이면 레지스터 P3은 압축 해제 된 레코드를 형성하는 P4 레지스터 중 첫 번째입니다.</target>
        </trans-unit>
        <trans-unit id="ea0d786e8193b3191b8e71dcd7cd40efa9daf92e" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_APPEND bit set, that is a hint to the b-tree layer that this insert is likely to be an append.</source>
          <target state="translated">P5에 OPFLAG_APPEND 비트가 설정되어 있으면 b- 트리 레이어에이 힌트가 추가 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b63e95392a3322ead1cda4df48bfef1df78fcfb5" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_NCHANGE bit set, then the change counter is incremented by this instruction. If the OPFLAG_NCHANGE bit is clear, then the change counter is unchanged.</source>
          <target state="translated">P5에 OPFLAG_NCHANGE 비트가 설정되어 있으면이 명령에 의해 변경 카운터가 증가합니다. OPFLAG_NCHANGE 비트가 지워지면 변경 카운터는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ea732c0486f9121ffc851f241dea7753a429516" translate="yes" xml:space="preserve">
          <source>If P5 has the OPFLAG_PERMUTE bit set, then the order of comparison is determined by the most recent &lt;a href=&quot;opcode#Permutation&quot;&gt;Permutation&lt;/a&gt; operator. If the OPFLAG_PERMUTE bit is clear, then register are compared in sequential order.</source>
          <target state="translated">P5에 OPFLAG_PERMUTE 비트가 설정되어 있으면 비교 순서는 가장 최근 &lt;a href=&quot;opcode#Permutation&quot;&gt;순열&lt;/a&gt; 연산자에 의해 결정됩니다 . OPFLAG_PERMUTE 비트가 지워지면 레지스터가 순차적으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d566e20d0304652ba9b826870e3331951b73f1a1" translate="yes" xml:space="preserve">
          <source>If P5 is non-zero, then recursive program invocation is enabled.</source>
          <target state="translated">P5가 0이 아닌 경우 재귀 프로그램 호출이 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8cc4989073012226802ebb0b0b0287d0ebbc4c24" translate="yes" xml:space="preserve">
          <source>If P5 is not zero and P4 is NULL, then everything after the &quot;:&quot; is omitted.</source>
          <target state="translated">P5가 0이 아니고 P4가 NULL이면 &quot;:&quot;뒤의 모든 항목이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="6140b6bc786ef6328163c583ea74afbbf1b0203f" translate="yes" xml:space="preserve">
          <source>If P5 is not zero, the check is done on the auxiliary database file, not the main database file.</source>
          <target state="translated">P5가 0이 아닌 경우 점검은 기본 데이터베이스 파일이 아닌 보조 데이터베이스 파일에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f3d5e8ef0f60d316b59356518575a2f176eb4d7" translate="yes" xml:space="preserve">
          <source>If P5 is positive and the jump is taken, then event counter number P5-1 in the prepared statement is incremented.</source>
          <target state="translated">P5가 양수이고 점프가 수행되면 준비된 명령문의 이벤트 카운터 번호 P5-1이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="6d64a234f707179617701bb23c32b6ab90539344" translate="yes" xml:space="preserve">
          <source>If P5!=0 then this opcode also checks the schema cookie against P3 and the schema generation counter against P4. The cookie changes its value whenever the database schema changes. This operation is used to detect when that the cookie has changed and that the current process needs to reread the schema. If the schema cookie in P3 differs from the schema cookie in the database header or if the schema generation counter in P4 differs from the current generation counter, then an SQLITE_SCHEMA error is raised and execution halts. The sqlite3_step() wrapper function might then reprepare the statement and rerun it from the beginning.</source>
          <target state="translated">P5! = 0이면이 opcode는 P3에 대한 스키마 쿠키와 P4에 대한 스키마 생성 카운터도 검사합니다. 쿠키는 데이터베이스 스키마가 변경 될 때마다 값을 변경합니다. 이 작업은 쿠키가 변경된시기와 현재 프로세스가 스키마를 다시 읽어야하는 시점을 감지하는 데 사용됩니다. P3의 스키마 쿠키가 데이터베이스 헤더의 스키마 쿠키와 다르거 나 P4의 스키마 생성 카운터가 현재 생성 카운터와 다른 경우 SQLITE_SCHEMA 오류가 발생하고 실행이 중지됩니다. sqlite3_step () 랩퍼 함수는 명령문을 다시 준비하고 처음부터 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79b8df381ad1ae2bdf21bac462376aead762296f" translate="yes" xml:space="preserve">
          <source>If RBU is used to update a large BLOB value within a target database, it may be more efficient to store a patch or delta that can be used to modify the existing BLOB instead of an entirely new value within the RBU database. RBU allows deltas to be specified in two ways:</source>
          <target state="translated">RBU를 사용하여 대상 데이터베이스 내에서 큰 BLOB 값을 업데이트하는 경우 RBU 데이터베이스 내에서 완전히 새로운 값 대신 기존 BLOB를 수정하는 데 사용할 수있는 패치 또는 델타를 저장하는 것이 더 효율적일 수 있습니다. RBU를 사용하면 델타를 두 가지 방법으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f32404d913415ab312a2d32bca5267050dc55433" translate="yes" xml:space="preserve">
          <source>If SQLITE_DEFAULT_WAL_SYNCHRONOUS differs from SQLITE_DEFAULT_SYNCHRONOUS, and if the application has not modified the synchronous setting for the database file using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; statement, then the synchronous setting is changed to value defined by SQLITE_DEFAULT_WAL_SYNCHRONOUS when the database connection switches into WAL mode for the first time. If the SQLITE_DEFAULT_WAL_SYNCHRONOUS value is not overridden at compile-time, then it will always be the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and so no automatic synchronous setting changes will ever occur.</source>
          <target state="translated">SQLITE_DEFAULT_WAL_SYNCHRONOUS가 SQLITE_DEFAULT_SYNCHRONOUS와 다르고 응용 프로그램이 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 명령문을 사용하여 데이터베이스 파일의 동기 설정을 수정하지 않은 경우 데이터베이스 연결이 처음으로 WAL 모드로 전환 될 때 동기 설정은 SQLITE_DEFAULT_WAL_SYNCHRONOUS에 의해 정의 된 값으로 변경됩니다. SQLITE_DEFAULT_WAL_SYNCHRONOUS 값이 컴파일시 재정의되지 않으면 항상 &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; 와 동일 하므로 자동 동기 설정 변경이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35daf76480440bed2a0456819e4a2256b8e77c1e" translate="yes" xml:space="preserve">
          <source>If SQLITE_NULLEQ is set in P5 then the result of comparison is always either true or false and is never NULL. If both operands are NULL then the result of comparison is true. If either operand is NULL then the result is false. If neither operand is NULL the result is the same as it would be if the SQLITE_NULLEQ flag were omitted from P5.</source>
          <target state="translated">SQLITE_NULLEQ가 P5에 설정되면 비교 결과는 항상 true 또는 false이며 절대 NULL이 아닙니다. 두 피연산자가 모두 NULL이면 비교 결과는 true입니다. 피연산자 중 하나가 NULL이면 결과는 false입니다. 피연산자가 NULL이 아니면 결과는 SQLITE_NULLEQ 플래그가 P5에서 생략 된 경우와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b5e1e68a469214facd1d655d6dbff18739ace55a" translate="yes" xml:space="preserve">
          <source>If SQLite discovers that the sqlite_sequence table has any other format, it returns the SQLITE_CORRUPT_SEQUENCE error.</source>
          <target state="translated">SQLite가 sqlite_sequence 테이블에 다른 형식이 있음을 발견하면 SQLITE_CORRUPT_SEQUENCE 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="015569a0e55d69ecf2d3dec3d6ece8f0bde61846" translate="yes" xml:space="preserve">
          <source>If SQLite ever returns SQLITE_MISUSE from any interface, that means that the application is incorrectly coded and needs to be fixed. Do not ship an application that sometimes returns SQLITE_MISUSE from a standard SQLite interface because that application contains potentially serious bugs.</source>
          <target state="translated">SQLite가 인터페이스에서 SQLITE_MISUSE를 반환하면 응용 프로그램이 잘못 코딩되어 수정되어야 함을 의미합니다. 표준 SQLite 인터페이스에서 SQLITE_MISUSE를 반환하는 응용 프로그램은 해당 응용 프로그램에 잠재적으로 심각한 버그가있을 수 있으므로 제공하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="60b69a270887c8a40e3999f62767f4e29079be3d" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the parser_trace pragma can be used to turn on tracing for the SQL parser used internally by SQLite. This feature is used for debugging SQLite itself.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션 으로 컴파일 된 경우 parser_trace pragma를 사용하여 SQLite가 내부적으로 사용하는 SQL 파서에 대한 추적을 설정할 수 있습니다. 이 기능은 SQLite 자체를 디버깅하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e93855bd0fdb13d2772a4cf88fefeb516093bf0" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_addoptrace pragma can be used to cause a complete VDBE opcodes to be displayed as they are created during code generation. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션 으로 컴파일 된 경우 vdbe_addoptrace pragma를 사용하여 코드 생성 중에 완전한 VDBE opcode가 작성 될 때 표시 될 수 있습니다. 이 기능은 SQLite 자체를 디버깅하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ed1cfc408ef29e4c5084ed94c91a1453ae1e7d68" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_debug pragma is a shorthand for three other debug-only pragmas: vdbe_addoptrace, vdbe_listing, and vdbe_trace. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션 으로 컴파일 된 경우 , vdbe_debug pragma는 vdbe_addoptrace, vdbe_listing 및 vdbe_trace의 세 가지 다른 디버그 전용 pragma의 약어입니다. 이 기능은 SQLite 자체를 디버깅하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1e32eb3dd2a790d29e0b70974d295922571079df" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_listing pragma can be used to cause a complete listing of the virtual machine opcodes to appear on standard output as each statement is evaluated. With listing is on, the entire content of a program is printed just prior to beginning execution. The statement executes normally after the listing is printed. This feature is used for debugging SQLite itself. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션 으로 컴파일 된 경우 , vdbe_listing pragma를 사용하여 각 명령문이 평가 될 때 가상 머신 opcode의 전체 목록을 표준 출력에 표시 할 수 있습니다. 리스팅이 켜져 있으면 프로그램의 전체 내용이 실행을 시작하기 직전에 인쇄됩니다. 목록은 인쇄 된 후에 정상적으로 실행됩니다. 이 기능은 SQLite 자체를 디버깅하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cefc8fedb890f68ef15ff1358f045bdc3b72901b" translate="yes" xml:space="preserve">
          <source>If SQLite has been compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, then the vdbe_trace pragma can be used to cause virtual machine opcodes to be printed on standard output as they are evaluated. This feature is used for debugging SQLite. See the &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE documentation&lt;/a&gt; for more information.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션 으로 컴파일 된 경우 vdbe_trace pragma를 사용하여 가상 머신 opcode가 평가 될 때 표준 출력에 인쇄되도록 할 수 있습니다. 이 기능은 SQLite를 디버깅하는 데 사용됩니다. 자세한 내용은 &lt;a href=&quot;vdbe#trace&quot;&gt;VDBE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5153e53873f4aff61d1f8d367f68545fed69c0e7" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_complete16 ()&lt;/a&gt; 을 호출하기 전에 sqlite3_initialize ()를 사용하여 SQLite를 초기화하지 않은 경우 sqlite3_initialize ()는 sqlite3_complete16 ()에 의해 자동으로 호출됩니다. 초기화에 실패하면 sqlite3_complete16 ()의 리턴 값은 입력 SQL의 완료 여부에 관계없이 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3c965f677e7c54456f9a69dea9325df1caaec3d9" translate="yes" xml:space="preserve">
          <source>If SQLite has not been initialized using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; prior to invoking sqlite3_complete16() then sqlite3_initialize() is invoked automatically by sqlite3_complete16(). If that initialization fails, then the return value from sqlite3_complete16() will be non-zero regardless of whether or not the input SQL is complete.</source>
          <target state="translated">&lt;a href=&quot;initialize&quot;&gt;sqlite3_complete16 ()&lt;/a&gt; 을 호출하기 전에 sqlite3_initialize ()를 사용하여 SQLite를 초기화하지 않은 경우 sqlite3_initialize ()는 sqlite3_complete16 ()에 의해 자동으로 호출됩니다. 초기화에 실패하면 sqlite3_complete16 ()의 리턴 값은 입력 SQL의 완료 여부에 관계없이 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6d6bbb3059e334920732ba9450708b663008dcc7" translate="yes" xml:space="preserve">
          <source>If SQLite is built with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option then the syntax of the UPDATE statement is extended with optional ORDER BY and LIMIT clauses as follows:</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 컴파일 시간 옵션으로 빌드 된 경우 UPDATE 문의 구문은 다음과 같이 선택적 ORDER BY 및 LIMIT 절로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="44ff2e47de1d4a52252bdf0898ff4b68826c3d7a" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled for Windows with the &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; compile-time option, then a different, thin wrapper is used around HeapAlloc(), HeapReAlloc(), and HeapFree(). The thin wrapper uses the configured SQLite heap, which will be different from the default process heap if the &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; compile-time option is used. In addition, when an allocation is made or freed, HeapValidate() will be called if SQLite is compiled with assert() enabled and the &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; compile-time option.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#win32_malloc&quot;&gt;SQLITE_WIN32_MALLOC&lt;/a&gt; 컴파일 타임 옵션으로 Windows 용으로 컴파일 된 경우 HeapAlloc (), HeapReAlloc () 및 HeapFree () 주위에 다른 얇은 래퍼가 사용됩니다. 씬 랩퍼는 구성된 SQLite 힙을 사용하며, &lt;a href=&quot;compile#win32_heap_create&quot;&gt;SQLITE_WIN32_HEAP_CREATE&lt;/a&gt; 컴파일 타임 옵션이 사용되는 경우 기본 프로세스 힙과 다릅니다 . 또한 할당이 이루어 지거나 해제되면 SQLite가 assert ()를 사용하도록 설정되고 &lt;a href=&quot;compile#win32_malloc_validate&quot;&gt;SQLITE_WIN32_MALLOC_VALIDATE&lt;/a&gt; 컴파일 시간 옵션 이 컴파일 된 경우 HeapValidate ()가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="517e1af932491e30c32e06c4fd9e534300edd652" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; then another zero-malloc memory allocator, similar to memsys5, is included in the source tree. The memsys3 allocator, like memsys5, must be activated by a call to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). Memsys3 uses the memory buffer supplied as its source for all memory allocations. The difference between memsys3 and memsys5 is that memsys3 uses a different memory allocation algorithm that seems to work well in practice, but which does not provide mathematical guarantees against memory fragmentation and breakdown. Memsys3 was a predecessor to memsys5. The SQLite developers now believe that memsys5 is superior to memsys3 and that all applications that need a zero-malloc memory allocator should use memsys5 in preference to memsys3. Memsys3 is considered both experimental and deprecated and will likely be removed from the source tree in a future release of SQLite.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#enable_memsys3&quot;&gt;SQLITE_ENABLE_MEMSYS3&lt;/a&gt; 으로 컴파일되면 memsys5 와 유사한 또 다른 zero-malloc 메모리 할당자가 소스 트리에 포함됩니다. memsys5와 같은 memsys3 할당자는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config를&lt;/a&gt; 호출하여 활성화해야합니다 ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;, ...). Memsys3는 모든 메모리 할당을 위해 소스로 제공된 메모리 버퍼를 사용합니다. memsys3와 memsys5의 차이점은 memsys3가 실제로는 잘 작동하는 것처럼 보이지만 메모리 조각화 및 분석에 대해 수학적인 보장을 제공하지 않는 다른 메모리 할당 알고리즘을 사용한다는 것입니다. Memsys3은 memsys5의 전신입니다. SQLite 개발자는 이제 memsys5가 memsys3보다 우수하며, 말로 메모리 할당자가 필요한 모든 응용 프로그램은 memsys3보다 memsys5를 사용해야한다고 생각합니다. Memsys3는 실험용 및 폐기 된 것으로 간주되며 향후 SQLite 릴리스에서 소스 트리에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a20ff9c15584045a4ca98d16d24d41c5ba218767" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; compile-time option, then the syntax of the DELETE statement is extended by the addition of optional ORDER BY and LIMIT clauses:</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 선택적 ORDER BY 및 LIMIT 절을 추가하여 DELETE 문의 구문이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="0e66b56024c7560826b0783e73206c696c2fa3db" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; compile-time option, then a different, heavy wrapper is used around system malloc(), realloc(), and free(). The heavy wrapper allocates around 100 bytes of extra space with each allocation. The extra space is used to place sentinel values at both ends of the allocation returned to the SQLite core. When an allocation is freed, these sentinels are checked to make sure the SQLite core did not overrun the buffer in either direction. When the system library is GLIBC, the heavy wrapper also makes use of the GNU backtrace() function to examine the stack and record the ancestor functions of the malloc() call. When running the SQLite test suite, the heavy wrapper also records the name of the current test case. These latter two features are useful for tracking down the source of memory leaks detected by the test suite.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#memdebug&quot;&gt; SQLITE_MEMDEBUG&lt;/a&gt;컴파일 타임 옵션 다음 시스템 malloc (), realloc () 및 free () 주위에 다른 무거운 래퍼가 사용됩니다. 무거운 래퍼는 각 할당마다 약 100 바이트의 추가 공간을 할당합니다. 여분의 공간은 SQLite 코어에 반환 된 할당의 양쪽 끝에 센티넬 값을 배치하는 데 사용됩니다. 할당이 해제되면이 센티넬을 검사하여 SQLite 코어가 버퍼를 어느 방향 으로든 오버런하지 않았는지 확인합니다. 시스템 라이브러리가 GLIBC 인 경우, 무거운 래퍼는 GNU backtrace () 함수를 사용하여 스택을 검사하고 malloc () 호출의 조상 함수를 기록합니다. SQLite 테스트 스위트를 실행할 때 무거운 래퍼도 현재 테스트 케이스의 이름을 기록합니다. 이 두 가지 기능은 테스트 스위트가 감지 한 메모리 누수 소스를 추적하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bdb5f255b340a7c8ea5f9ec1a27271eaa4afef49" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; option, then the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; is omitted and replaced by a stub memory allocator that never allocates any memory. Any calls to the stub memory allocator will report back that no memory is available.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; 옵션으로 컴파일 된 경우 , &lt;a href=&quot;malloc#defaultalloc&quot;&gt;기본 메모리 할당자는&lt;/a&gt; 생략되고 메모리를 할당하지 않는 스텁 메모리 할당 자로 대체됩니다. 스텁 메모리 할당 자에 대한 모든 호출은 사용 가능한 메모리가 없음을 다시보고합니다.</target>
        </trans-unit>
        <trans-unit id="a81969949fdea82f85b5652d9dfeed54c87f7d37" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">SQLite가 SQLITE_MUTEX_APPDEF 프리 프로세서 매크로가 정의 된 ( &quot;-DSQLITE_MUTEX_APPDEF = 1&quot;로) 컴파일 된 경우 뮤텍스 구현이 라이브러리에 포함되지 않습니다. 이 경우 응용 프로그램은 sqlite3_initialize () 또는 sqlite3_initialize ()를 호출하는 다른 공개 sqlite3_ 함수를 호출하기 전에 sqlite3_config () 함수 의 &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 옵션을 사용하여 사용자 정의 mutex 구현을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3612fbeb4e5912d3519c058afb830d2ca96819e8" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the SQLITE_MUTEX_APPDEF preprocessor macro defined (with &quot;-DSQLITE_MUTEX_APPDEF=1&quot;), then no mutex implementation is included with the library. In this case the application must supply a custom mutex implementation using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option of the sqlite3_config() function before calling sqlite3_initialize() or any other public sqlite3_ function that calls sqlite3_initialize().</source>
          <target state="translated">SQLite가 SQLITE_MUTEX_APPDEF 프리 프로세서 매크로가 정의 된 ( &quot;-DSQLITE_MUTEX_APPDEF = 1&quot;로) 컴파일 된 경우 뮤텍스 구현이 라이브러리에 포함되지 않습니다. 이 경우 응용 프로그램은 sqlite3_initialize () 또는 sqlite3_initialize ()를 호출하는 다른 공개 sqlite3_ 함수를 호출하기 전에 sqlite3_config () 함수 의 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 옵션을 사용하여 사용자 정의 mutex 구현을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3e4d7ea4d24bcad6503f112a75cb8cf3b594762c" translate="yes" xml:space="preserve">
          <source>If SQLite is compiled with the THREADSAFE preprocessor macro set to 1, then it is safe to use SQLite from two or more threads of the same process at the same time. But each thread should have its own &lt;b&gt;sqlite*&lt;/b&gt; pointer returned from &lt;b&gt;sqlite_open&lt;/b&gt;. It is never safe for two or more threads to access the same &lt;b&gt;sqlite*&lt;/b&gt; pointer at the same time.</source>
          <target state="translated">THREADSAFE 전 처리기 매크로를 1로 설정하여 SQLite를 컴파일하면 같은 프로세스의 두 개 이상의 스레드에서 동시에 SQLite를 사용하는 것이 안전합니다. 그러나 각 스레드에는 &lt;b&gt;sqlite_open&lt;/b&gt; 에서 반환 된 자체 &lt;b&gt;sqlite *&lt;/b&gt; 포인터가 &lt;b&gt;있어야&lt;/b&gt; 합니다. 둘 이상의 스레드가 동일한 &lt;b&gt;sqlite *&lt;/b&gt; 포인터에 동시에 액세스하는 것은 결코 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="710dfc358000c04c6f29b5a8b9d1e58f09170c01" translate="yes" xml:space="preserve">
          <source>If SQLite is working with multiple databases at the same time (using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command) then each database has its own rollback journal. But there is also a separate aggregate journal called the &lt;em&gt;master journal&lt;/em&gt;. The master journal does not contain page data used for rolling back changes. Instead the master journal contains the names of the individual database rollback journals for each of the ATTACHed databases. Each of the individual database rollback journals also contain the name of the master journal. If there are no ATTACHed databases (or if none of the ATTACHed database is participating in the current transaction) no master journal is created and the normal rollback journal contains an empty string in the place normally reserved for recording the name of the master journal.</source>
          <target state="translated">SQLite가 동시에 여러 데이터베이스에서 작업하는 경우 ( &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령 사용) 각 데이터베이스에는 고유 한 롤백 저널이 있습니다. 그러나 &lt;em&gt;마스터 저널&lt;/em&gt; 이라는 별도의 집계 저널도 있습니다 . 마스터 분개에는 변경 사항을 롤백하는 데 사용되는 페이지 데이터가 없습니다. 대신 마스터 저널에는 각 첨부 된 데이터베이스에 대한 개별 데이터베이스 롤백 저널의 이름이 포함됩니다. 각 개별 데이터베이스 롤백 저널에는 마스터 저널의 이름도 포함됩니다. 첨부 된 데이터베이스가 없거나 (또는 ​​현재 트랜잭션에 참여하는 첨부 된 데이터베이스가없는 경우) 마스터 저널이 작성되지 않으며 일반 롤백 저널에는 일반적으로 마스터 저널의 이름을 기록하기 위해 예약 된 곳에 빈 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5896c61835dd6f9792c99d8e8f334dcf5e7f29e5" translate="yes" xml:space="preserve">
          <source>If SQLite needs a page-cache entry that is larger than &quot;sz&quot; bytes or if it needs more than N entries, it falls back to using the general-purpose memory allocator.</source>
          <target state="translated">SQLite에 &quot;sz&quot;바이트보다 큰 페이지 캐시 항목이 필요하거나 N 개보다 많은 항목이 필요한 경우 범용 메모리 할당자를 사용하는 것으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="4aa68767277ee1001967243f3227f1d8f761e4eb" translate="yes" xml:space="preserve">
          <source>If SQLite recognizes a table as a shadow table, and if the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set, then the shadow table is read-only for ordinary SQL statements. The shadow table can still be written, but only by SQL that is invoked from within one of the methods of some virtual table implementation.</source>
          <target state="translated">SQLite가 테이블을 새도우 테이블로 인식하고 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 설정된 경우 새도우 테이블은 일반 SQL 문에 대해 읽기 전용입니다. 새도우 테이블은 여전히 ​​쓸 수 있지만 일부 가상 테이블 구현의 메소드 중 하나에서 호출 된 SQL에 의해서만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c334cbe953204cf334f3f0300d4576308ac4cfdc" translate="yes" xml:space="preserve">
          <source>If URI filenames are recognized when the database connection is originally opened, then URI filenames will also be recognized on &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. Similarly, if URI filenames are not recognized when the database connection is first opened, they will not be recognized by &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">데이터베이스 연결이 처음 열렸을 때 URI 파일 이름이 인식되면 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서도 URI 파일 이름이 인식됩니다 . 마찬가지로 데이터베이스 연결을 처음 열 때 URI 파일 이름이 인식되지 않으면 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH에서&lt;/a&gt; 인식하지 못합니다 .</target>
        </trans-unit>
        <trans-unit id="20f2ccdd4e7b5b66dd50ba0f757be7113d0c9526" translate="yes" xml:space="preserve">
          <source>If W is AND-connected terms and X is OR-connected terms and if any term of W appears as a term of X, then the partial index is usable.</source>
          <target state="translated">W가 AND로 연결된 항이고 X가 OR로 연결된 항이고 W의 항이 X의 항으로 나타나면 부분 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee5624c5ac84e77c145fe142470f12976a4d91a" translate="yes" xml:space="preserve">
          <source>If X is a memory allocation previously obtained from sqlite3_malloc(), sqlite3_malloc64(), sqlite3_realloc(), or sqlite3_realloc64(), then sqlite3_msize(X) returns the size of that memory allocation in bytes. The value returned by sqlite3_msize(X) might be larger than the number of bytes requested when X was allocated. If X is a NULL pointer then sqlite3_msize(X) returns zero. If X points to something that is not the beginning of memory allocation, or if it points to a formerly valid memory allocation that has now been freed, then the behavior of sqlite3_msize(X) is undefined and possibly harmful.</source>
          <target state="translated">X가 sqlite3_malloc (), sqlite3_malloc64 (), sqlite3_realloc () 또는 sqlite3_realloc64 ()에서 이전에 얻은 메모리 할당 인 경우 sqlite3_msize (X)는 해당 메모리 할당 크기를 바이트 단위로 리턴합니다. sqlite3_msize (X)에 의해 리턴 된 값은 X가 할당 될 때 요청 된 바이트 수보다 클 수 있습니다. X가 NULL 포인터이면 sqlite3_msize (X)는 0을 반환합니다. X가 메모리 할당의 시작이 아닌 것을 가리 키거나 현재 해제 된 이전의 유효한 메모리 할당을 가리키는 경우 sqlite3_msize (X)의 동작은 정의되지 않았으며 유해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b66964d31ddb28c71bf027a0d38468bda02bb0" translate="yes" xml:space="preserve">
          <source>If X is greater than or equal to zero, go back to step 3.</source>
          <target state="translated">X가 0보다 크거나 같은 경우 3 단계로 돌아가십시오.</target>
        </trans-unit>
        <trans-unit id="b3fb68847c867d6e5aec8b5513dabb7e57278079" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">X가 0이 아닌 경우 가상 테이블 구현은 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 가 &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT를&lt;/a&gt; 리턴 하면 내부 또는 지속적 데이터 구조를 수정하기 전에이를 수행함을 보장합니다 . 는 IF &lt;a href=&quot;../lang_conflict&quot;&gt;ON 충돌&lt;/a&gt; 모드가 ABORT, FAIL이고, 무시하거나 ROLLBACK은, SQLite는 성명 또는 데이터베이스 트랜잭션을 롤백하고 포기 또는 적절한 현재 SQL 문을 계속 처리 할 수 있습니다. ON CONFLICT 모드가 REPLACE이고 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드가 &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT를&lt;/a&gt; 리턴 하면 SQLite는 ON CONFLICT 모드가 ABORT 인 것처럼이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="c0b29678a870c29e379cb0f8c76e93d5c6f694fd" translate="yes" xml:space="preserve">
          <source>If X is non-zero, then the virtual table implementation guarantees that if &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, it will do so before any modifications to internal or persistent data structures have been made. If the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is ABORT, FAIL, IGNORE or ROLLBACK, SQLite is able to roll back a statement or database transaction, and abandon or continue processing the current SQL statement as appropriate. If the ON CONFLICT mode is REPLACE and the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, SQLite handles this as if the ON CONFLICT mode had been ABORT.</source>
          <target state="translated">X가 0이 아닌 경우 가상 테이블 구현은 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 가 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT를&lt;/a&gt; 리턴 하면 내부 또는 지속적 데이터 구조를 수정하기 전에이를 수행함을 보장합니다 . 는 IF &lt;a href=&quot;lang_conflict&quot;&gt;ON 충돌&lt;/a&gt; 모드가 ABORT, FAIL이고, 무시하거나 ROLLBACK은, SQLite는 성명 또는 데이터베이스 트랜잭션을 롤백하고 포기 또는 적절한 현재 SQL 문을 계속 처리 할 수 있습니다. ON CONFLICT 모드가 REPLACE이고 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드가 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT를&lt;/a&gt; 리턴 하면 SQLite는 ON CONFLICT 모드가 ABORT 인 것처럼이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="90405f680f9fd6c0b9fd6e8fd54aba076154778a" translate="yes" xml:space="preserve">
          <source>If X starts a transaction that will initially only read but X knows it will eventually want to write and does not want to be troubled with possible SQLITE_BUSY_SNAPSHOT errors that arise because another connection jumped ahead of it in line, then X can issue &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; to start its transaction instead of just an ordinary BEGIN. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command goes ahead and starts a write transaction, and thus blocks all other writers. If the &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; operation succeeds, then no subsequent operations in that transaction will ever fail with an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">X가 처음에는 읽기만하는 트랜잭션을 시작하지만 X는 결국 쓰기를 원하고 다른 연결이 줄을 넘어서 발생하여 발생할 수있는 SQLITE_BUSY_SNAPSHOT 오류로 문제를 일으키고 싶지 않다는 것을 알고 있으면 X는 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; 를 발행 하여 시작할 수 있습니다. 평범한 BEGIN 대신 거래. 는 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt; 명령은 모든 다른 작가를 강행하고 쓰기 트랜잭션을 시작하고, 따라서 블록. (가) 경우 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt; 작업이 성공, 그 거래의 후속 작업은 이제까지와 함께 실패하지 않습니다 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY의&lt;/a&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="0eea241e4d0bdc37c50e93c325fbb23bd791a257" translate="yes" xml:space="preserve">
          <source>If a &quot;*&quot; character follows a string within an FTS expression, then the final token extracted from the string is marked as a &lt;b&gt;prefix token&lt;/b&gt;. As you might expect, a prefix token matches any document token of which it is a prefix. For example, the first two queries in the following block will match any document that contains the token &quot;one&quot; immediately followed by the token &quot;two&quot; and then any token that begins with &quot;thr&quot;.</source>
          <target state="translated">&quot;*&quot;문자가 FTS 표현식 내의 문자열 뒤에 오는 경우 문자열에서 추출 된 최종 토큰은 접 &lt;b&gt;두부 token으로&lt;/b&gt; 표시됩니다 . 예상 한대로 접두사 토큰은 접두사 인 모든 문서 토큰과 일치합니다. 예를 들어, 다음 블록의 처음 두 쿼리는 &quot;one&quot;토큰 바로 다음에 &quot;two&quot;토큰과 &quot;thr&quot;로 시작하는 토큰이 포함 된 모든 문서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3fc71a5654e7dbcda099553445308929a409041e" translate="yes" xml:space="preserve">
          <source>If a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; SQL command is executed, and the same database connection currently has one or more actively executing SELECT statements, then SQLITE_LOCKED is returned. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called in this case, then the specified callback will be invoked immediately. Re-attempting the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement will return another SQLITE_LOCKED error. In the implementation of sqlite3_blocking_step() shown to the left, this could cause an infinite loop.</source>
          <target state="translated">&quot;DROP TABLE&quot;또는 &quot;DROP INDEX&quot;SQL 명령이 실행되고 동일한 데이터베이스 연결에 현재 하나 이상의 활성 SELECT 문이있는 경우 SQLITE_LOCKED가 리턴됩니다. 이 경우 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 가 호출되면 지정된 콜백이 즉시 호출됩니다. &quot;DROP TABLE&quot;또는 &quot;DROP INDEX&quot;문을 다시 시도하면 다른 SQLITE_LOCKED 오류가 반환됩니다. 왼쪽에 표시된 sqlite3_blocking_step () 구현에서 무한 루프가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12bc34a5236123febe1cd1188da174890c26f97b" translate="yes" xml:space="preserve">
          <source>If a &quot;^&quot; character appears immediately before a phrase that is not part of a NEAR query, then that phrase only matches a document only if it starts at the first token in a column. The &quot;^&quot; syntax may be combined with a &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;column filter&lt;/a&gt;, but may not be inserted into the middle of a phrase.</source>
          <target state="translated">&quot;^&quot;문자가 NEAR 쿼리의 일부가 아닌 문구 바로 앞에 나타나는 경우 해당 문구는 문서가 열의 첫 번째 토큰에서 시작하는 경우에만 문서와 일치합니다. &quot;^&quot;구문은 &lt;a href=&quot;fts5#fts5_column_filters&quot;&gt;열 필터&lt;/a&gt; 와 결합 할 수 있지만 구문 중간에 삽입 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="73147d85cef7d3f5b1649d52c7fae3bdc6d30054" translate="yes" xml:space="preserve">
          <source>If a &quot;create file&quot; operation is executed by SQLite, and then the created file</source>
          <target state="translated">&quot;파일 작성&quot;조작이 SQLite에 의해 실행 된 후 작성된 파일</target>
        </trans-unit>
        <trans-unit id="84d99b586ac4808874504752037c1f68b1dc681c" translate="yes" xml:space="preserve">
          <source>If a &quot;truncate file&quot; operation is executed by SQLite, and then the truncated file</source>
          <target state="translated">&quot;파일 잘라 내기&quot;작업이 SQLite에 의해 실행 된 다음 잘린 파일</target>
        </trans-unit>
        <trans-unit id="a177cd3b97251df1bda061d91a729d6e25be393e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;../wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">모든 데이터베이스 연결을 닫은 후 ( &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;file_control&quot;&gt;파일 제어를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하지 않고 데이터베이스를 마지막으로 열었던 프로세스가 종료 되었기 때문에) &lt;a href=&quot;../wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; 이 디스크에 남아 있는 경우 해당 데이터베이스 에서 새 연결이 열린 후 &lt;a href=&quot;../wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; , &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스는 WAL 파일에 다른 유효한 트랜잭션이 포함되어 있어도 WAL 파일에 추가 된 마지막 트랜잭션 만 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce5e78d94d5947b9e328c1516e3f265b0f48637a" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is generated from &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; then the statement is automatically re-prepared if the schema changes, up to &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; times (default: 50). The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will only return SQLITE_SCHEMA back to the application if the failure persists after these many retries.</source>
          <target state="translated">경우 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 에서 생성됩니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 다음 문은 준비된 자동으로 다시 경우 최대 스키마 변경, &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY의&lt;/a&gt; 시간 (기본값 : 50). &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 응용 프로그램에 SQLITE_SCHEMA 백을 반환하는 경우 이러한 많은 시도 후 실패 지속됩니다.</target>
        </trans-unit>
        <trans-unit id="3249186023e31b2ef81a917670edb42184c4e1e6" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; operation occurs on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as a pending read or write, then the pending read or write may fail with an SQLITE_ABORT or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error.</source>
          <target state="translated">경우 &lt;a href=&quot;lang_transaction&quot;&gt;롤백&lt;/a&gt; 작업이 동일한에서 발생 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 보류중인 읽기 또는 쓰기로하고 보류중인 읽기 나 쓰기는 SQLITE_ABORT 또는 실패 할 수 있습니다 &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK의&lt;/a&gt; 오류입니다.</target>
        </trans-unit>
        <trans-unit id="a092e1c1463db0502720c4f04f6df73156ddbd46" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt; remains on disk after all database connections close (either through the use of the &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;file control&lt;/a&gt; or because the last process to have the database opened exited without calling &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;) and a new connection is subsequently opened on that database and &lt;a href=&quot;wal#walfile&quot;&gt;WAL file&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt; interface will only be able to open the last transaction added to the WAL file even though the WAL file contains other valid transactions.</source>
          <target state="translated">모든 데이터베이스 연결을 닫은 후 ( &lt;a href=&quot;#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL &lt;/a&gt;&lt;a href=&quot;#sqlite3_file_control&quot;&gt;파일 제어를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하지 않고 데이터베이스를 마지막으로 열었던 프로세스가 종료 되었기 때문에) &lt;a href=&quot;wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; 이 디스크에 남아 있는 경우 해당 데이터베이스 에서 새 연결이 열린 후 &lt;a href=&quot;wal#walfile&quot;&gt;WAL 파일&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 인터페이스는 WAL 파일에 다른 유효한 트랜잭션이 포함되어 있어도 WAL 파일에 추가 된 마지막 트랜잭션 만 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0658f406309a7c36c783a199e98aa7bfe2c3be" translate="yes" xml:space="preserve">
          <source>If a BEFORE UPDATE or BEFORE DELETE trigger modifies or deletes a row that was to have been updated or deleted, then the result of the subsequent update or delete operation is undefined. Furthermore, if a BEFORE trigger modifies or deletes a row, then it is undefined whether or not AFTER triggers that would have otherwise run on those rows will in fact run.</source>
          <target state="translated">BEFORE UPDATE 또는 BEFORE DELETE 트리거가 업데이트되거나 삭제 된 행을 수정하거나 삭제하면 후속 업데이트 또는 삭제 조작의 결과가 정의되지 않습니다. 또한 BEFORE 트리거가 행을 수정 또는 삭제하는 경우 해당 행에서 실행 된 AFTER 트리거가 실제로 실행 될지 여부는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3ab52a71f2c1fab71f9f4f7d4dd870ab7b02c55" translate="yes" xml:space="preserve">
          <source>If a COMMIT statement (or the RELEASE of a transaction SAVEPOINT) fails because the database is currently in a state that violates a deferred foreign key constraint and there are currently &lt;a href=&quot;lang_savepoint&quot;&gt;nested savepoints&lt;/a&gt;, the nested savepoints remain open.</source>
          <target state="translated">데이터베이스가 현재 지연된 외래 키 제약 조건을 위반하는 상태에 있고 현재 &lt;a href=&quot;lang_savepoint&quot;&gt;중첩 된 저장 점이&lt;/a&gt; 있으므로 COMMIT 문 (또는 트랜잭션 SAVEPOINT의 RELEASE)이 실패 하면 중첩 된 저장 점이 계속 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="4862567128635ae0bf91b3eee8827f7e081e0187" translate="yes" xml:space="preserve">
          <source>If a DELETE statement has a LIMIT clause, the maximum number of rows that will be deleted is found by evaluating the accompanying expression and casting it to an integer value. If the result of the evaluating the LIMIT clause cannot be losslessly converted to an integer value, it is an error. A negative LIMIT value is interpreted as &quot;no limit&quot;. If the DELETE statement also has an OFFSET clause, then it is similarly evaluated and cast to an integer value. Again, it is an error if the value cannot be losslessly converted to an integer. If there is no OFFSET clause, or the calculated integer value is negative, the effective OFFSET value is zero.</source>
          <target state="translated">DELETE 문에 LIMIT 절이 있으면 삭제 될 최대 행 수는 수반되는 표현식을 평가하고이를 정수 값으로 캐스트하여 찾습니다. LIMIT 절을 평가 한 결과를 손실없이 정수 값으로 변환 할 수 없으면 오류입니다. 음의 LIMIT 값은 &quot;제한 없음&quot;으로 해석됩니다. DELETE 문에도 OFFSET 절이 있으면, 유사하게 평가되어 정수 값으로 캐스트됩니다. 값을 손실없이 정수로 변환 할 수없는 경우 오류가 다시 발생합니다. OFFSET 절이 없거나 계산 된 정수 값이 음수이면 유효 OFFSET 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a8ebe41fb4265f7abee56db5ee7b5c4f78f4ea2f" translate="yes" xml:space="preserve">
          <source>If a FILTER clause is provided, then only rows for which the</source>
          <target state="translated">FILTER 절이 제공되는 경우</target>
        </trans-unit>
        <trans-unit id="94816fac33b04eac89bfe331f82f9493ef356c93" translate="yes" xml:space="preserve">
          <source>If a FROM clause is specified, the data on which a simple SELECT query operates comes from the one or more tables or subqueries (SELECT statements in parentheses) specified following the FROM keyword. A subquery specified in the table-or-subquery following the FROM clause in a simple SELECT statement is handled as if it was a table containing the data returned by executing the subquery statement. Each column of the subquery has the &lt;a href=&quot;datatype3#collation&quot;&gt;collation sequence&lt;/a&gt; and &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the corresponding expression in the subquery statement.</source>
          <target state="translated">FROM 절이 지정된 경우 단순 SELECT 조회가 작동하는 데이터는 FROM 키워드 다음에 지정된 하나 이상의 테이블 또는 서브 쿼리 (괄호 안의 SELECT 문)에서 가져옵니다. 단순 SELECT 문에서 FROM 절 다음에 테이블 또는 서브 쿼리에 지정된 서브 쿼리는 서브 쿼리 명령문을 실행하여 리턴 된 데이터를 포함하는 테이블 인 것처럼 처리됩니다. 서브 쿼리의 각 컬럼은 서브 쿼리 명령문에서 해당 표현식 의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 및 &lt;a href=&quot;datatype3#affinity&quot;&gt;선호도&lt;/a&gt; 를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="257e2a863a3526135a72b7350cb70ec4620d0ce5" translate="yes" xml:space="preserve">
          <source>If a HAVING clause is specified, it is evaluated once for each group of rows as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. If the result of evaluating the HAVING clause is false, the group is discarded. If the HAVING clause is an aggregate expression, it is evaluated across all rows in the group. If a HAVING clause is a non-aggregate expression, it is evaluated with respect to an arbitrarily selected row from the group. The HAVING expression may refer to values, even aggregate functions, that are not in the result.</source>
          <target state="translated">HAVING 절이 지정되면 각 행 그룹에 대해 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식&lt;/a&gt; 으로 한 번 평가 됩니다. HAVING 절 평가 결과가 false이면 그룹이 삭제됩니다. HAVING 절이 집계 표현식 인 경우 그룹의 모든 행에서 평가됩니다. HAVING 절이 집계되지 않은 표현식 인 경우 그룹에서 임의로 선택된 행과 관련하여 평가됩니다. HAVING 표현식은 결과에없는 값, 집계 함수까지도 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30445e74b001ab802719baf4ad36071ade7519f0" translate="yes" xml:space="preserve">
          <source>If a LIMIT clause is present, it might be possible to avoid scanning the entire table.</source>
          <target state="translated">LIMIT 절이 존재하면 전체 테이블을 스캔하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="948b4ac14d2baa3362d0ca28f059b73564c6f3e7" translate="yes" xml:space="preserve">
          <source>If a Linux &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt;ext3&lt;/a&gt; filesystem is mounted without the &quot;barrier=1&quot; option in the &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/etc/fstab&lt;/a&gt; and the disk drive write cache is enabled then filesystem corruption can occur following a power loss or OS crash. Whether or not corruption can occur depends on the details of the disk control hardware; corruption is more likely with inexpensive consumer-grade disks and less of a problem for enterprise-class storage devices with advanced features such as non-volatile write caches. Various ext3 experts &lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; confirm this behavior&lt;/a&gt;. We are told that most Linux distributions do not use barrier=1 and do not disable the write cache so most Linux distributions are vulnerable to this problem. Note that this is an operating system and hardware issue and that there is nothing that SQLite can do to work around it. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt; Other database engines&lt;/a&gt; have also run into this same problem.</source>
          <target state="translated">리눅스라면 &lt;a href=&quot;http://en.wikipedia.org/wiki/Ext3&quot;&gt; ext3&lt;/a&gt; 파일 시스템이 &lt;a href=&quot;http://en.wikipedia.org/wiki/fstab&quot;&gt;/ etc / fstab&lt;/a&gt; 에서 &quot;barrier = 1&quot;옵션없이 마운트 되고 디스크 드라이브 쓰기 캐시가 활성화 된 경우 전원 손실 또는 OS 충돌로 인해 파일 시스템 손상이 발생할 수 있습니다. 손상이 발생할 수 있는지 여부는 디스크 제어 하드웨어의 세부 사항에 따라 다릅니다. 저렴한 소비자 급 디스크로 인해 손상이 발생할 가능성이 높으며 비 휘발성 쓰기 캐시와 같은 고급 기능을 갖춘 엔터프라이즈 급 스토리지 장치에서는 문제가 적습니다. 다양한 ext3 전문가&lt;a href=&quot;http://www.redhat.com/archives/ext3-users/2010-July/msg00001.html&quot;&gt; 가이 동작을 확인합니다&lt;/a&gt;. 대부분의 Linux 배포판은 barrier = 1을 사용하지 않고 쓰기 캐시를 비활성화하지 않으므로 대부분의 Linux 배포판은이 문제에 취약합니다. 이것은 운영 체제 및 하드웨어 문제이며 SQLite가이 문제를 해결하기 위해 수행 할 수있는 작업이 없습니다. &lt;a href=&quot;http://ozlabs.org/~rusty/index.cgi/tech/2009-10-20.html&quot;&gt;다른 데이터베이스 엔진&lt;/a&gt; 도 같은 문제가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="99b0a8e8602a0a06983153315092cfd9796ad41e" translate="yes" xml:space="preserve">
          <source>If a NOT NULL constraint is specified, then the column must have a default value other than NULL.</source>
          <target state="translated">NOT NULL 제약 조건이 지정되면 열의 기본값은 NULL 이외의 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="55be5a331b8cf28f9f746d3f7eb6341aa17eff02" translate="yes" xml:space="preserve">
          <source>If a SELECT query contains an ORDER BY, GROUP BY or DISTINCT clause, SQLite may need to use a temporary b-tree structure to sort the output rows. Or, it might &lt;a href=&quot;queryplanner#sorting&quot;&gt;use an index&lt;/a&gt;. Using an index is almost always much more efficient than performing a sort. If a temporary b-tree is required, a record is added to the EXPLAIN QUERY PLAN output with the &quot;detail&quot; field set to a string value of the form &quot;USE TEMP B-TREE FOR xxx&quot;, where xxx is one of &quot;ORDER BY&quot;, &quot;GROUP BY&quot; or &quot;DISTINCT&quot;. For example:</source>
          <target state="translated">SELECT 쿼리에 ORDER BY, GROUP BY 또는 DISTINCT 절이 포함 된 경우 SQLite는 임시 b- 트리 구조를 사용하여 출력 행을 정렬해야 할 수 있습니다. 또는 &lt;a href=&quot;queryplanner#sorting&quot;&gt;색인을 사용할&lt;/a&gt; 수도 있습니다 . 인덱스를 사용하는 것이 정렬을 수행하는 것보다 거의 항상 훨씬 효율적입니다. 임시 b- 트리가 필요한 경우 &quot;detail&quot;필드를 &quot;USE TEMP B-TREE FOR xxx&quot;형식의 문자열 값으로 설정하여 EXPLAIN QUERY PLAN 출력에 레코드가 추가됩니다. 여기서 xxx는 &quot;ORDER 중 하나입니다. BY &quot;,&quot;GROUP BY &quot;또는&quot;DISTINCT &quot;. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b44dbe4fb9e1c6ef0606b8af702048ca0e438cc" translate="yes" xml:space="preserve">
          <source>If a SELECT statement that returns more than one row does not have an ORDER BY clause, the order in which the rows are returned is undefined. Or, if a SELECT statement does have an ORDER BY clause, then the list of expressions attached to the ORDER BY determine the order in which rows are returned to the user.</source>
          <target state="translated">둘 이상의 행을 리턴하는 SELECT 문에 ORDER BY 절이 없으면 행이 리턴되는 순서가 정의되지 않습니다. 또는 SELECT 문에 ORDER BY 절이있는 경우 ORDER BY에 첨부 된 표현식 목록에 따라 행이 사용자에게 리턴되는 순서가 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="1b3cef981ef6c33ad4faa712cdaf3b903f15861f" translate="yes" xml:space="preserve">
          <source>If a UNION operator connects the initial-select with the recursive-select, then only add rows to the queue if no identical row has been previously added to the queue. Repeated rows are discarded before being added to the queue even if the repeated rows have already been extracted from the queue by the recursion step. If the operator is UNION ALL, then all rows generated by both the initial-select and the recursive-select are always added to the queue even if they are repeats. When determining if a row is repeated, NULL values compare equal to one another and not equal to any other value.</source>
          <target state="translated">UNION 연산자가 초기 선택을 재귀 선택과 연결하는 경우 이전에 대기열에 동일한 행이 추가되지 않은 경우에만 행을 대기열에 추가하십시오. 반복 된 행이 재귀 단계에 의해 큐에서 이미 추출 된 경우에도 반복 된 행은 큐에 추가되기 전에 삭제됩니다. 연산자가 UNION ALL이면 초기 선택과 재귀 선택에 의해 생성 된 모든 행이 반복 되더라도 항상 큐에 추가됩니다. 행이 반복되는지 판별 할 때 NULL 값은 서로 같고 다른 값과 같지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56d92b47e4081e5a6e548ebb6f898e186d052899" translate="yes" xml:space="preserve">
          <source>If a WHEN clause is supplied, the SQL statements specified are only executed if the WHEN clause is true. If no WHEN clause is supplied, the SQL statements are executed every time the trigger fires.</source>
          <target state="translated">WHEN 절이 제공되면 지정된 SQL 문은 WHEN 절이 true 인 경우에만 실행됩니다. WHEN 절이 제공되지 않으면 트리거가 실행될 때마다 SQL 문이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="85a070271019d9b24039a7b30649256cb4c49fd9" translate="yes" xml:space="preserve">
          <source>If a WHERE clause is specified, the WHERE expression is evaluated for each row in the input data as a &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt;. Only rows for which the WHERE clause expression evaluates to true are included from the dataset before continuing. Rows are excluded from the result if the WHERE clause evaluates to either false or NULL.</source>
          <target state="translated">WHERE 절이 지정되면 WHERE 표현식은 입력 데이터의 각 행에 대해 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식으로 평가&lt;/a&gt; 됩니다. 계속하기 전에 WHERE 절 표현식이 true로 평가되는 행만 데이터 세트에 포함됩니다. WHERE 절이 false 또는 NULL로 평가되면 행이 결과에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="99314068471e46954e8f897765afda682981e6bc" translate="yes" xml:space="preserve">
          <source>If a build of SQLite does not include the FTS modules, then any attempt to prepare an SQL statement to create an FTS3 or FTS4 table or to drop or access an existing FTS table in any way will fail. The error message returned will be similar to &quot;no such module: ftsN&quot; (where N is either 3 or 4).</source>
          <target state="translated">SQLite 빌드에 FTS 모듈이 포함되어 있지 않으면 FTS3 또는 FTS4 테이블을 작성하거나 어떤 식 으로든 기존 FTS 테이블을 삭제하거나 액세스하기 위해 SQL 문을 준비하려는 시도가 실패합니다. 반환 된 오류 메시지는 &quot;no such module : ftsN&quot;과 유사합니다 (여기서 N은 3 또는 4 임).</target>
        </trans-unit>
        <trans-unit id="c07dc39ee71e6a6e8537165278b706aabd6e81bd" translate="yes" xml:space="preserve">
          <source>If a call to sqlite3_step() that attempts to write to a database table returns SQLITE_LOCKED, then more than one other connection may be holding a read-lock on the database table in question. In this case SQLite simply selects one of those other connections arbitrarily and issues the unlock-notify callback when that connection's transaction is finished. Whether the call to sqlite3_step() was blocked by one or many connections, when the corresponding unlock-notify callback is issued it is not guaranteed that the required lock is available, only that it may be.</source>
          <target state="translated">데이터베이스 테이블에 쓰려고 시도하는 sqlite3_step () 호출이 SQLITE_LOCKED를 리턴하면, 하나 이상의 다른 연결이 해당 데이터베이스 테이블에 대한 읽기 잠금을 보유 할 수 있습니다. 이 경우 SQLite는 단순히 다른 연결 중 하나를 임의로 선택하고 해당 연결의 트랜잭션이 완료되면 잠금 해제 알림 콜백을 발행합니다. sqlite3_step ()에 대한 호출이 하나 이상의 연결에 의해 차단되었는지 여부에 따라 해당 잠금 해제 알림 콜백이 발행 될 때 필요한 잠금이 사용 가능하다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="12e866adc40a794d5a50cd7647771628a0fe472b" translate="yes" xml:space="preserve">
          <source>If a character specified as part of the argument to &quot;tokenchars=&quot; is considered to be a token character by default, it is ignored. This is true even if it has been marked as a separator by an earlier &quot;separators=&quot; option. Similarly, if a character specified as part of a &quot;separators=&quot; option is treated as a separator character by default, it is ignored. If multiple &quot;tokenchars=&quot; or &quot;separators=&quot; options are specified, all are processed. For example:</source>
          <target state="translated">&quot;tokenchars =&quot;에 대한 인수의 일부로 지정된 문자가 기본적으로 토큰 문자로 간주되면 무시됩니다. 이전의 &quot;separators =&quot;옵션에 의해 구분자로 표시되어 있어도 마찬가지입니다. 마찬가지로 &quot;separators =&quot;옵션의 일부로 지정된 문자가 기본적으로 구분 문자로 취급되는 경우 무시됩니다. &quot;tokenchars =&quot;또는 &quot;separators =&quot;옵션이 여러 개 지정된 경우 모두 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4047a69992390b90bb1e651abb363899dad3ce20" translate="yes" xml:space="preserve">
          <source>If a collating function fails any of the above constraints and that collating function is registered and used, then the behavior of SQLite is undefined.</source>
          <target state="translated">조합 함수가 위의 제한 조건 중 하나에 실패하고 해당 조합 함수가 등록되어 사용되면 SQLite의 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a25d30fe6f01a94e32b9a3c4b8ab96f2806f18f" translate="yes" xml:space="preserve">
          <source>If a column datatype contains the special keyword &quot;HIDDEN&quot; (in any combination of upper and lower case letters) then that keyword it is omitted from the column datatype name and the column is marked as a hidden column internally. A hidden column differs from a normal column in three respects:</source>
          <target state="translated">열 데이터 유형에 특수 키워드 &quot;HIDDEN&quot;(대문자와 소문자 조합)이 포함 된 경우 해당 키워드는 열 데이터 유형 이름에서 생략되고 열은 내부적으로 숨겨진 열로 표시됩니다. 숨겨진 열은 세 가지 측면에서 일반 열과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4a3060f5f06633a8fd81221c196cda03a0efe5c5" translate="yes" xml:space="preserve">
          <source>If a column filter specification is preceded by a &quot;-&quot; character, then it is interpreted as a list of column not to match against. For example:</source>
          <target state="translated">열 필터 스펙 앞에 &quot;-&quot;문자가 있으면 일치하지 않는 열 목록으로 해석됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4784be250e1d29a9c62d93440a67186e8f2d433e" translate="yes" xml:space="preserve">
          <source>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the largest possible ROWID has previously been inserted, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error. Only ROWID values from previous transactions that were committed are considered. ROWID values that were rolled back are ignored and can be reused.</source>
          <target state="translated">컬럼에 INTEGER PRIMARY KEY AUTOINCREMENT 유형이 있으면 약간 다른 ROWID 선택 알고리즘이 사용됩니다. 새 행에 대해 선택된 ROWID는 이전에 동일한 테이블에 존재했던 가장 큰 ROWID보다 하나 이상 큽니다. 테이블에 데이터가 포함 된 적이 없으면 ROWID 1이 사용됩니다. 가장 큰 가능한 ROWID가 이전에 삽입 된 경우 새 INSERT가 허용되지 않으며 새 행을 삽입하려는 시도는 SQLITE_FULL 오류와 함께 실패합니다. 커밋 된 이전 트랜잭션의 ROWID 값만 고려됩니다. 롤백 된 ROWID 값은 무시되며 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85779fa11fd249fc0a9433b1c9e912b143d1abd7" translate="yes" xml:space="preserve">
          <source>If a column-name list follows the view-name, then that list determines the names of the columns for the view. If the column-name list is omitted, then the names of the columns in the view are derived from the names of the result-set columns in the &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;. The use of column-name list is recommended. Or, if column-name list is omitted, then the result columns in the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that defines the view should have well-defined names using the &quot;&lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt;&quot; syntax. SQLite allows you to create views that depend on automatically generated column names, but you should avoid using them since the rules used to generate column names are not a defined part of the interface and might change in future releases of SQLite.</source>
          <target state="translated">열 이름 목록이 view-name 뒤에 오면 해당 목록이보기의 열 이름을 결정합니다. column-name 목록이 생략되면 뷰의 열 이름은 &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; 의 결과 집합 열 이름에서 파생됩니다 . 열 이름 목록을 사용하는 것이 좋습니다. 또는 column-name list를 생략 하면 뷰를 정의하는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 열에 &quot; &lt;a href=&quot;syntax/result-column&quot;&gt;AS column-alias&lt;/a&gt; &quot;구문을 사용하여 잘 정의 된 이름이 있어야 합니다. SQLite를 사용하면 자동으로 생성 된 열 이름에 의존하는 뷰를 만들 수 있지만 열 이름을 생성하는 데 사용되는 규칙은 인터페이스의 정의 된 부분이 아니며 향후 SQLite 릴리스에서 변경 될 수 있으므로 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="7f7aaafed42977493a2413f4303512821df4e3b2" translate="yes" xml:space="preserve">
          <source>If a conflict handler returns this value no special action is taken. The change that caused the conflict is not applied. The session module continues to the next change in the changeset.</source>
          <target state="translated">충돌 핸들러가이 값을 리턴하면 특별한 조치가 수행되지 않습니다. 충돌을 일으킨 변경 사항이 적용되지 않습니다. 세션 모듈은 다음 변경 세트에서 계속 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="a40b2d39f56dad1b134a26af2fe2ae696281adc1" translate="yes" xml:space="preserve">
          <source>If a covering index can be used for a query, then the multiple rowid lookups can be avoided and the cost of the query drops dramatically.</source>
          <target state="translated">커버링 인덱스를 쿼리에 사용할 수 있으면 여러 rowid 조회를 피할 수 있고 쿼리 비용이 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="653b4381ff1ad3607fbc3061d7b4f5d80ed74deb" translate="yes" xml:space="preserve">
          <source>If a crash or power failure occurs and results in a hot journal but that journal is deleted, the next process to open the database will not know that it contains changes that need to be rolled back. The rollback will not occur and the database will be left in an inconsistent state. Rollback journals might be deleted for any number of reasons:</source>
          <target state="translated">충돌 또는 전원 장애가 발생하여 저널이 뜨거워 지지만 해당 저널이 삭제 된 경우, 데이터베이스를 여는 다음 프로세스는 롤백해야하는 변경 사항이 포함되어 있음을 알 수 없습니다. 롤백이 발생하지 않고 데이터베이스가 일관성이없는 상태로 남아 있습니다. 롤백 저널은 여러 가지 이유로 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbc53ced19579b45a05b723b3063167292a44232" translate="yes" xml:space="preserve">
          <source>If a crash or power loss does occur and a hot journal is left on the disk, it is essential that the original database file and the hot journal remain on disk with their original names until the database file is opened by another SQLite process and rolled back. During recovery at &lt;a href=&quot;#section_4_2&quot;&gt;step 4.2&lt;/a&gt; SQLite locates the hot journal by looking for a file in the same directory as the database being opened and whose name is derived from the name of the file being opened. If either the original database file or the hot journal have been moved or renamed, then the hot journal will not be seen and the database will not be rolled back.</source>
          <target state="translated">충돌 또는 전원 손실이 발생하고 핫 저널이 디스크에 남아있는 경우 데이터베이스 파일이 다른 SQLite 프로세스에 의해 열리고 롤백 될 때까지 원본 데이터베이스 파일 및 핫 저널이 원래 이름으로 디스크에 남아 있어야합니다. . &lt;a href=&quot;#section_4_2&quot;&gt;4.2 단계&lt;/a&gt; 에서 복구하는 동안 SQLite는 열려는 데이터베이스와 동일한 디렉토리에서 파일을 찾아서 열 저널을 찾습니다. 원본 데이터베이스 파일 또는 핫 저널이 이동되거나 이름이 바뀐 경우 핫 저널이 표시되지 않고 데이터베이스가 롤백되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb8183919d1fc07417b2707b8092ba7a7a08090d" translate="yes" xml:space="preserve">
          <source>If a crash or power loss occurs in the middle of a transaction, then the rollback journal file is left on disk. The next time another application attempts to open the database file, it notices the presence of the abandoned rollback journal (we call it a &quot;hot journal&quot; in this circumstance) and uses the information in the journal to restore the database to its state prior to the start of the incomplete transaction. This is how SQLite implements atomic commit.</source>
          <target state="translated">트랜잭션 도중에 충돌 또는 전원 손실이 발생하면 롤백 저널 파일이 디스크에 남아 있습니다. 다음에 다른 응용 프로그램에서 데이터베이스 파일을 열려고하면이 롤백 된 저널 저널 (이 상황에서는 &quot;핫 저널&quot;이라고 함)이 있음을 확인하고 저널의 정보를 사용하여 데이터베이스를 이전 상태로 복원합니다. 불완전한 거래의 시작 이것이 SQLite가 원자 커밋을 구현하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ac9f0e2592a2df4c51e939a4b5d49b41b7d7ebcb" translate="yes" xml:space="preserve">
          <source>If a database connection is opened with the &quot;-uri 1&quot; option, then &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are honored by the &quot;backup&quot; and &quot;restore&quot; commands.</source>
          <target state="translated">&quot;-uri 1&quot;옵션을 사용하여 데이터베이스 연결을 열면 &quot;backup&quot;및 &quot;restore&quot;명령이 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d5923feff2a2aef8fc7abf4f600aff34fc785066" translate="yes" xml:space="preserve">
          <source>If a database connection is operating in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; or in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; (PRAGMA journal_mode=persist) then after committing a transaction the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file may remain in the file-system. This increases performance for subsequent transactions since overwriting an existing file is faster than append to a file, but it also consumes file-system space. After a large transaction (e.g. a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), the rollback journal file may consume a very large amount of space.</source>
          <target state="translated">데이터베이스 연결이 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드&lt;/a&gt; 또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;지속적 저널 모드&lt;/a&gt; (PRAGMA journal_mode = persist)에서 작동하는 경우 트랜잭션을 커밋 한 후 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 파일이 파일 시스템에 남아있을 수 있습니다. 기존 파일을 덮어 쓰는 것이 파일에 추가하는 것보다 빠르기 때문에 후속 트랜잭션의 성능이 향상되지만 파일 시스템 공간도 소비합니다. 큰 트랜잭션 (예 : &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; ) 후에 롤백 저널 파일은 매우 많은 공간을 소비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f55f04439258c2d344a35f29269aa9db3e5202b" translate="yes" xml:space="preserve">
          <source>If a database file is accessed using 8+3 naming rather than the default long filename, then it must be consistently accessed using 8+3 naming by every database connection every time it is opened, or else there is a risk of database corruption. The auxiliary &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; and &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; files are essential to SQLite for being about to recover from a crash. If an application is using 8+3 names and crashes, then the information needed to safely recover from the crash is stored in files with the &quot;&lt;code&gt;.nal&lt;/code&gt;&quot; or &quot;&lt;code&gt;.wal&lt;/code&gt;&quot; extension. If the next application to open the database does not specify the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; URI parameter, then SQLite will use the long filenames to try to locate the rollback journal or write-ahead log files. It will not find them, since they were saved using 8+3 names by the application that crashed, and hence the database will not be properly recovered and will likely go corrupt.</source>
          <target state="translated">기본 긴 파일 이름이 아닌 8 + 3 이름을 사용하여 데이터베이스 파일에 액세스하는 경우 파일을 열 때마다 모든 데이터베이스 연결에서 8 + 3 이름을 사용하여 일관되게 액세스해야합니다. 그렇지 않으면 데이터베이스가 손상 될 위험이 있습니다. 보조 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 및 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 파일은 SQLite가 충돌로부터 복구 되려면 필수적입니다. 응용 프로그램이 8 + 3 이름을 사용하고 충돌하는 경우 충돌에서 안전하게 복구하는 데 필요한 정보는 &quot; &lt;code&gt;.nal&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;.wal&lt;/code&gt; &quot;확장자를 가진 파일에 저장됩니다 . 다음에 데이터베이스를 열 응용 프로그램이 &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; 을 지정하지 않은 경우&quot;URI 매개 변수를 사용하면 SQLite는 긴 파일 이름을 사용하여 롤백 저널 또는 미리 쓰기 로그 파일을 찾습니다. 충돌 한 응용 프로그램에서 8 + 3 이름을 사용하여 저장했기 때문에 데이터베이스를 찾지 못하므로 데이터베이스를 찾지 못합니다. 제대로 복구되지 않고 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd70a20b8f5f47bbbe011a3bee3a583fecc50caa" translate="yes" xml:space="preserve">
          <source>If a database is written by SQLite version 3.7.0 or later and then written again by SQLite version 3.6.23 or earlier in such a way as to make the size of the database file decrease, then the next time that SQLite version 3.7.0 access the database file, it might report that the database file is corrupt. The database file is not really corrupt, however. Version 3.7.0 was simply being overly zealous in its corruption detection.</source>
          <target state="translated">데이터베이스가 SQLite 버전 3.7.0 이상에서 작성된 후 데이터베이스 파일의 크기를 줄 이도록 SQLite 버전 3.6.23 이하에서 다시 작성된 경우 다음 번에 해당 SQLite 버전 3.7.0 데이터베이스 파일에 액세스하면 데이터베이스 파일이 손상되었다고보고 할 수 있습니다. 그러나 데이터베이스 파일은 실제로 손상되지 않았습니다. 버전 3.7.0은 손상 감지에서 지나치게 열성적이었습니다.</target>
        </trans-unit>
        <trans-unit id="c0e8b12ff7ad15986137c5d5f01f4e0ef949a4a6" translate="yes" xml:space="preserve">
          <source>If a database were originally created using SQLite version 3.7.0, then written by SQLite version 3.6.23.1 such that the size of the database file increased, then written again by SQLite version 3.7.0, the database file could go corrupt.</source>
          <target state="translated">데이터베이스가 원래 SQLite 버전 3.7.0을 사용하여 작성된 후 SQLite 버전 3.6.23.1로 데이터베이스 파일의 크기가 증가한 다음 SQLite 버전 3.7.0으로 다시 작성된 경우 데이터베이스 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f861f58b781638426cc97ad65bbe6addfa6a62" translate="yes" xml:space="preserve">
          <source>If a keyword in double quotes (ex: &lt;b&gt;&quot;key&quot;&lt;/b&gt; or &lt;b&gt;&quot;glob&quot;&lt;/b&gt;) is used in a context where it cannot be resolved to an identifier but where a string literal is allowed, then the token is understood to be a string literal instead of an identifier.</source>
          <target state="translated">큰 따옴표로 묶인 키워드 (예 : &lt;b&gt;&quot;key&quot;&lt;/b&gt; 또는 &lt;b&gt;&quot;glob&quot;&lt;/b&gt; )가 식별자로 해석 될 수 없지만 문자열 리터럴이 허용되는 컨텍스트에서 사용되는 경우 토큰은 대신 문자열 리터럴로 이해됩니다. 식별자.</target>
        </trans-unit>
        <trans-unit id="ff734731d1dd61e745b8c19a93e379fd051ea7fb" translate="yes" xml:space="preserve">
          <source>If a keyword in single quotes (ex: &lt;b&gt;'key'&lt;/b&gt; or &lt;b&gt;'glob'&lt;/b&gt;) is used in a context where an identifier is allowed but where a string literal is not allowed, then the token is understood to be an identifier instead of a string literal.</source>
          <target state="translated">작은 따옴표 (예 : &lt;b&gt;'key'&lt;/b&gt; 또는 &lt;b&gt;'glob'&lt;/b&gt; )로 된 키워드 가 식별자는 허용되지만 문자열 리터럴은 허용되지 않는 컨텍스트에서 사용되는 경우 토큰은 문자열 리터럴 대신 식별자로 이해됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd8582b07f28c43cf6305e6462fb4a6db23b8ea7" translate="yes" xml:space="preserve">
          <source>If a matchable phrase is part of a series of phrases connected by NEAR operators in the FTS query expression, then each phrase match must be sufficiently close to other phrase matches of the relevant types to satisfy the NEAR condition.</source>
          <target state="translated">일치하는 문구가 FTS 쿼리 표현식에서 NEAR 연산자로 연결된 일련의 문구의 일부인 경우, 각 문구 일치는 NEAR 조건을 충족시키기 위해 관련 유형의 다른 문구 일치에 충분히 근접해야합니다.</target>
        </trans-unit>
        <trans-unit id="16ba62507a795aad87688bd7a66b598560ff99c0" translate="yes" xml:space="preserve">
          <source>If a named virtual table that uses the dbstat module is desired, then the recommended way to create an instance of the dbstat virtual table is as follows:</source>
          <target state="translated">dbstat 모듈을 사용하는 이름 지정된 가상 테이블이 필요한 경우 dbstat 가상 테이블의 인스턴스를 작성하는 권장 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0a2ba4a4cc7d08c018b4dbe8137dc10439214b7" translate="yes" xml:space="preserve">
          <source>If a numeric literal has a decimal point or an exponentiation clause or if its magnitude is less than -9223372036854775808 or greater than 9223372036854775807, then it is a floating point literal. Otherwise is it is an integer literal. The &quot;E&quot; character that begins the exponentiation clause of a floating point literal can be either upper or lower case. The &quot;.&quot; character is always used as the decimal point even if the locale setting specifies &quot;,&quot; for this role - the use of &quot;,&quot; for the decimal point would result in syntactic ambiguity.</source>
          <target state="translated">숫자 리터럴에 소수점 또는 지수 절이 있거나 크기가 -9223372036854775808보다 작거나 9223372036854775807보다 큰 경우 부동 소수점 리터럴입니다. 그렇지 않으면 정수 리터럴입니다. 부동 소수점 리터럴의 지수 절을 시작하는 &quot;E&quot;문자는 대문자 또는 소문자 일 수 있습니다. &quot;.&quot; 로케일 설정이이 역할에 &quot;,&quot;를 지정하더라도 문자는 항상 소수점으로 사용됩니다. 소수점에 &quot;,&quot;를 사용하면 구문 상 모호함이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8cf3813aebca15b6b5e1583aeffa06f6925412e6" translate="yes" xml:space="preserve">
          <source>If a page contains no cells (which is only possible for a root page of a table that contains no rows) then the offset to the cell content area will equal the page size minus the bytes of reserved space. If the database uses a 65536-byte page size and the reserved space is zero (the usual value for reserved space) then the cell content offset of an empty page wants to be 65536. However, that integer is too large to be stored in a 2-byte unsigned integer, so a value of 0 is used in its place.</source>
          <target state="translated">페이지에 셀이없는 경우 (행이없는 테이블의 루트 페이지에만 가능) 셀 내용 영역에 대한 오프셋은 페이지 크기에서 예약 된 공간의 바이트를 뺀 값과 같습니다. 데이터베이스가 65536 바이트 페이지 크기를 사용하고 예약 된 공간이 0 (예약 된 공간의 일반적인 값) 인 경우 빈 페이지의 셀 내용 오프셋은 65536이 되려고합니다. 그러나 해당 정수가 너무 커서 부호없는 2 바이트 정수이므로 0 대신 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c99e07bc95c7e7eeb5ce8d8ce056128a45cab0ab" translate="yes" xml:space="preserve">
          <source>If a parameter name begins with a &quot;:&quot;, then it is assumed to be a value to bind to the SQL statement before executing it. The value is always bound as text. It is an error if the specified SQL parameter does not exist. For example:</source>
          <target state="translated">매개 변수 이름이 &quot;:&quot;으로 시작하면 실행하기 전에 SQL 문에 바인드 할 값으로 간주됩니다. 값은 항상 텍스트로 바인딩됩니다. 지정된 SQL 매개 변수가 없으면 오류입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3a6677c34d1c31ace005a4fa6f3930c2040066e" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system crash occurs at this point, the transaction will not rollback when the system reboots even though there are rollback journals present. The difference is the master journal pathname in the header of the rollback journal. Upon restart, SQLite only considers a journal to be hot and will only playback the journal if there is no master journal filename in the header (which is the case for a single-file commit) or if the master journal file still exists on disk.</source>
          <target state="translated">이 시점에서 정전 또는 운영 체제 충돌이 발생하면 롤백 저널이 있어도 시스템을 재부팅 할 때 트랜잭션이 롤백되지 않습니다. 차이점은 롤백 저널의 헤더에있는 마스터 저널 경로 이름입니다. 다시 시작하면 SQLite는 저널이 핫한 것으로 간주하고 헤더에 마스터 저널 파일 이름이 없거나 (단일 파일 커밋의 경우) 마스터 저널 파일이 디스크에 여전히 존재하는 경우에만 저널을 재생합니다.</target>
        </trans-unit>
        <trans-unit id="f031e4113363c1780559d56fb503c736f7031cb4" translate="yes" xml:space="preserve">
          <source>If a power failure or operating system failure occurs while copying the database file the backup database may be corrupted following system recovery.</source>
          <target state="translated">데이터베이스 파일을 복사하는 동안 정전 또는 운영 체제 오류가 발생하면 시스템 복구 후 백업 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d63fd60747c59caf947d214389cf965d0e528d08" translate="yes" xml:space="preserve">
          <source>If a query contains an ORDER BY clause with multiple terms, it might be that SQLite can use indices to cause rows to come out in the order of some prefix of the terms in the ORDER BY but that later terms in the ORDER BY are not satisfied. In that case, SQLite does block sorting. Suppose the ORDER BY clause has four terms and the natural order of the query results in rows appearing in order of the first two terms. As each row is output by the query engine and enters the sorter, the outputs in the current row corresponding to the first two terms of the ORDER BY are compared against the previous row. If they have changed, the current sort is finished and output and a new sort is started. This results in a slightly faster sort. But the bigger advantages are that many fewer rows need to be held in memory, reducing memory requirements, and outputs can begin to appear before the core query has run to completion.</source>
          <target state="translated">쿼리에 여러 용어가 포함 된 ORDER BY 절이 포함 된 경우 SQLite는 인덱스를 사용하여 ORDER BY에있는 용어의 접두사 순서대로 행이 나오지만 ORDER BY의 이후 용어는 충족되지 않을 수 있습니다. . 이 경우 SQLite는 정렬을 차단합니다. ORDER BY 절에 4 개의 용어가 있고 쿼리의 자연 순서가 처음 두 용어의 순서로 행을 표시한다고 가정하십시오. 각 행이 쿼리 엔진에 의해 출력되고 분류기에 들어가면 ORDER BY의 처음 두 항에 해당하는 현재 행의 출력이 이전 행과 비교됩니다. 변경된 경우 현재 정렬이 완료되고 출력되고 새로운 정렬이 시작됩니다. 이것은 약간 더 빠른 정렬을 초래합니다. 그러나 더 큰 장점은 메모리에 적은 수의 행을 유지하여 메모리 요구 사항을 줄이며핵심 쿼리가 완료되기 전에 출력이 나타나기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf63c23188158127b26cd2c4807de45ccf6dea6" translate="yes" xml:space="preserve">
          <source>If a query contains no aggregate functions at all, then a GROUP BY clause can be added as a substitute of DISTINCT ON clause. In other words, output rows are filtered so that only one row is shows for each distinct set of values in the GROUP BY clause. If two or more output rows would have otherwise had the same set of values for the GROUP BY columns, then one of the rows is chosen arbitrarily.</source>
          <target state="translated">쿼리에 집계 함수가 전혀 없으면 DISTINCT ON 절 대신 GROUP BY 절을 추가 할 수 있습니다. 다시 말해, 출력 행은 필터링되어 GROUP BY 절의 각 고유 값 세트에 대해 하나의 행만 표시됩니다. 두 개 이상의 출력 행에 GROUP BY 열에 대해 동일한 값 세트가있는 경우 행 중 하나가 임의로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="cab66c0bca9a377eb02b4b0ac5090404c2d874c0" translate="yes" xml:space="preserve">
          <source>If a read/write client invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) prior to shutdown, then at shutdown a checkpoint is still run, but the shm file and wal file are not deleted. This allows subsequent read-only clients to connect to and read the database.</source>
          <target state="translated">읽기 / 쓰기 클라이언트가 종료 전에 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; )을 호출하면 종료시 체크 포인트는 여전히 실행되지만 shm 파일 및 wal 파일은 삭제되지 않습니다. 따라서 후속 읽기 전용 클라이언트가 데이터베이스에 연결하여 데이터베이스를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="337133b7d09a387cf87665a4c7d79ff39c533386" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">기본 키 값이 일치하는 행을 찾았지만 하나 이상의 수정 된 기본이 아닌 키 필드 중 하나 이상이 변경 세트에 저장된 원래 행 값과 다른 값을 포함하는 경우 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 를 두 번째 인수로 사용하여 충돌 핸들러 함수가 호출됩니다. . UPDATE 변경 사항에는 수정 될 기본이 아닌 키 필드의 값만 포함되므로 SQLITE_CHANGESET_DATA 충돌 핸들러 콜백을 피하기 위해 해당 필드 만 원래 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="35c7138a2b7260bc49d6f60cf430df710c00202b" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the modified non-primary key fields contains a value different from an original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. Since UPDATE changes only contain values for non-primary key fields that are to be modified, only those fields need to match the original values to avoid the SQLITE_CHANGESET_DATA conflict-handler callback.</source>
          <target state="translated">기본 키 값이 일치하는 행을 찾았지만 하나 이상의 수정 된 기본이 아닌 키 필드 중 하나 이상이 변경 세트에 저장된 원래 행 값과 다른 값을 포함하는 경우 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 를 두 번째 인수로 사용하여 충돌 핸들러 함수가 호출됩니다. . UPDATE 변경 사항에는 수정 될 기본이 아닌 키 필드의 값만 포함되므로 SQLITE_CHANGESET_DATA 충돌 핸들러 콜백을 피하기 위해 해당 필드 만 원래 값과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b234b4b89cfdd9943a23340845cb2723771c58a" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">기본 키 값이 일치하는 행을 찾았지만 기본 키가 아닌 하나 이상의 필드에 변경 세트에 저장된 원래 행 값과 다른 값이 포함 된 경우 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 를 두 번째 인수로 사용하여 충돌 핸들러 함수가 호출됩니다 . 데이터베이스 테이블에 변경 세트에 기록 된 것보다 많은 열이있는 경우 기본이 아닌 키 필드의 값만 현재 데이터베이스 내용과 비교되며 후행 데이터베이스 테이블 열은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3b8d6b7470e9a00b63341bcac487b0076109fe" translate="yes" xml:space="preserve">
          <source>If a row with matching primary key values is found, but one or more of the non-primary key fields contains a value different from the original row value stored in the changeset, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; as the second argument. If the database table has more columns than are recorded in the changeset, only the values of those non-primary key fields are compared against the current database contents - any trailing database table columns are ignored.</source>
          <target state="translated">기본 키 값이 일치하는 행을 찾았지만 기본 키가 아닌 하나 이상의 필드에 변경 세트에 저장된 원래 행 값과 다른 값이 포함 된 경우 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 를 두 번째 인수로 사용하여 충돌 핸들러 함수가 호출됩니다 . 데이터베이스 테이블에 변경 세트에 기록 된 것보다 많은 열이있는 경우 기본이 아닌 키 필드의 값만 현재 데이터베이스 내용과 비교되며 후행 데이터베이스 테이블 열은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e400ae567f256dbdcc0abe528516e66e2c791942" translate="yes" xml:space="preserve">
          <source>If a schema name is specified as part of an object reference, it must be either &quot;main&quot;, or &quot;temp&quot; or the schema-name of an attached database. Like other SQL identifiers, schema names are case-insensitive. If a schema name is specified, then only that one schema is searched for the named object.</source>
          <target state="translated">스키마 이름이 객체 참조의 일부로 지정된 경우 &quot;main&quot;또는 &quot;temp&quot;또는 연결된 데이터베이스의 스키마 이름이어야합니다. 다른 SQL 식별자와 마찬가지로 스키마 이름은 대소 문자를 구분하지 않습니다. 스키마 이름이 지정되면 해당 스키마에서만 이름 지정된 오브젝트를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="a287d9b64545db85e7dfa26422162809454f183b" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, it must be either &quot;main&quot;, &quot;temp&quot;, or the name of an &lt;a href=&quot;lang_attach&quot;&gt;attached database&lt;/a&gt;. In this case the new table is created in the named database. If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs between the &quot;CREATE&quot; and &quot;TABLE&quot; then the new table is created in the temp database. It is an error to specify both a schema-name and the TEMP or TEMPORARY keyword, unless the schema-name is &quot;temp&quot;. If no schema name is specified and the TEMP keyword is not present then the table is created in the main database.</source>
          <target state="translated">schema-name이 지정된 경우 &quot;main&quot;, &quot;temp&quot;또는 &lt;a href=&quot;lang_attach&quot;&gt;연결된 데이터베이스&lt;/a&gt; 이름이어야 합니다 . 이 경우 새 테이블이 명명 된 데이터베이스에 생성됩니다. &quot;CREATE&quot;와 &quot;TABLE&quot;사이에 &quot;TEMP&quot;또는 &quot;TEMPORARY&quot;키워드가 발생하면 임시 데이터베이스에 새 테이블이 작성됩니다. schema-name이 &quot;temp&quot;가 아닌 경우 schema-name과 TEMP 또는 TEMPORARY 키워드를 모두 지정하면 오류가 발생합니다. 스키마 이름을 지정하지 않고 TEMP 키워드가 없으면 테이블이 기본 데이터베이스에 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d186fac3c43b0ebe9fb52f2e0bcd9b8dc9321942" translate="yes" xml:space="preserve">
          <source>If a schema-name is specified, then the view is created in the specified database. It is an error to specify both a schema-name and the TEMP keyword on a VIEW, unless the schema-name is &quot;temp&quot;. If no schema name is specified, and the TEMP keyword is not present, the VIEW is created in the main database.</source>
          <target state="translated">schema-name을 지정하면 지정된 데이터베이스에보기가 작성됩니다. schema-name이 &quot;temp&quot;가 아닌 한 VIEW에서 schema-name과 TEMP 키워드를 모두 지정하면 오류가 발생합니다. 스키마 이름을 지정하지 않고 TEMP 키워드가 없으면 기본 데이터베이스에 VIEW가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="5a3b25f9ef77a5c2a55ede994e4212a6c3bae634" translate="yes" xml:space="preserve">
          <source>If a search token (on the right-hand side of the MATCH operator) in &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; begins with &quot;^&quot; then that token must be the first in its field of the document. &lt;b&gt;** Potentially Incompatible Change **&lt;/b&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 의 검색 토큰 (MATCH 연산자의 오른쪽에 있음) 이 &quot;^&quot;로 시작하면 해당 토큰은 문서 필드에서 첫 번째 토큰이어야합니다. &lt;b&gt;** 잠재적으로 호환되지 않는 변경 **&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e0b0e745b5660b6e63d47617f06b59c6fe2aec60" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 가 실행되는 동안 별도의 스레드가 동일한 데이터베이스 연결을 변경하면 반환 된 값을 예측할 수없고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e161385bf705ff3ca3325998e8904218252e0a24" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 가 실행되는 동안 별도의 스레드가 동일한 데이터베이스 연결을 변경하면 반환 된 값을 예측할 수없고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="48949b30f7cc8dfe518df452770028dcf8268e04" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;changes&quot;&gt;sqlite3_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 가 실행되는 동안 별도의 스레드가 동일한 데이터베이스 연결을 변경하면 반환 된 값을 예측할 수없고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e69017ebf8db42f4c918537142f058b4e1e4b99c" translate="yes" xml:space="preserve">
          <source>If a separate thread makes changes on the same database connection while &lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; is running then the value returned is unpredictable and not meaningful.</source>
          <target state="translated">&lt;a href=&quot;total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 가 실행되는 동안 별도의 스레드가 동일한 데이터베이스 연결을 변경하면 반환 된 값을 예측할 수없고 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67e0dff317f2ea719a9272889d4afc4730b1b5fc" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수가 실행되는 동안 별도의 스레드 가 동일한 데이터베이스 연결에서 새 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 를 수행 하여 마지막 삽입 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 변경하면 &lt;a href=&quot;last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()에&lt;/a&gt; 의해 리턴 된 값을 예측할 수없고 이전 또는 새로운 마지막 값과 같지 않을 수 있습니다 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid를&lt;/a&gt; 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8a05ae1d1d14adcdf537d4865ddc934cf60a0a4" translate="yes" xml:space="preserve">
          <source>If a separate thread performs a new &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; on the same database connection while the &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function is running and thus changes the last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, then the value returned by &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; is unpredictable and might not equal either the old or the new last insert &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수가 실행되는 동안 별도의 스레드 가 동일한 데이터베이스 연결에서 새 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 를 수행 하여 마지막 삽입 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 변경하면 &lt;a href=&quot;#sqlite3_last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()에&lt;/a&gt; 의해 리턴 된 값을 예측할 수없고 이전 또는 새로운 마지막 값과 같지 않을 수 있습니다 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid를&lt;/a&gt; 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c0a40f4902327b395568a304aa57a5c4039b9e5" translate="yes" xml:space="preserve">
          <source>If a single database file has multiple links (either hard or soft links) then that is just another way of saying that the file has multiple names. If two or more processes open the database using different names, then they will use different rollback journals and WAL files. That means that if one process crashes, the other process will be unable to recover the transaction in progress because it will be looking in the wrong place for the appropriate journal.</source>
          <target state="translated">단일 데이터베이스 파일에 여러 개의 링크 (하드 또는 소프트 링크)가있는 경우 파일 이름이 여러 개인 것입니다. 둘 이상의 프로세스가 다른 이름을 사용하여 데이터베이스를 열면 다른 롤백 저널 및 WAL 파일을 사용합니다. 즉, 한 프로세스가 충돌하면 다른 프로세스가 해당 저널에 대해 잘못된 위치를 찾고 있기 때문에 진행중인 트랜잭션을 복구 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="54992194ecdfbf1a36948d0111a0401fc51b1ec9" translate="yes" xml:space="preserve">
          <source>If a single row is affected by more than one operation within a session, then the change is considered indirect if all operations meet the criteria for an indirect change above, or direct otherwise.</source>
          <target state="translated">단일 행이 세션 내에서 둘 이상의 작업에 의해 영향을받는 경우 모든 작업이 위의 간접 변경 기준을 충족하면 변경이 간접적 인 것으로 간주되거나 그렇지 않으면 직접 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8aed35bc8fc658c89e5539bc9b828e9558656314" translate="yes" xml:space="preserve">
          <source>If a statement modifies the contents of the database so that an immediate foreign key constraint is in violation at the conclusion the statement, an exception is thrown and the effects of the statement are reverted. By contrast, if a statement modifies the contents of the database such that a deferred foreign key constraint is violated, the violation is not reported immediately. Deferred foreign key constraints are not checked until the transaction tries to &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;. For as long as the user has an open transaction, the database is allowed to exist in a state that violates any number of deferred foreign key constraints. However, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will fail as long as foreign key constraints remain in violation.</source>
          <target state="translated">명령문이 결론을 내릴 때 즉시 외래 키 제한 조건이 위반되도록 명령문이 데이터베이스의 컨텐츠를 수정하면 예외가 발생하고 명령문의 영향이 되돌려집니다. 반대로, 지연된 외래 키 제약 조건을 위반하도록 명령문이 데이터베이스의 내용을 수정하면 위반이 즉시보고되지 않습니다. 트랜잭션이 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 하려고 시도 할 때까지 지연된 외래 키 제한 조건이 점검되지 않습니다 . 사용자에게 공개 트랜잭션이있는 한 지연된 외래 키 제약 조건을 위반하는 상태로 데이터베이스가 존재할 수 있습니다. 그러나 외래 키 제약 조건을 위반하지 않으면 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="4a9fe68ac2f3c48ea32a43f2c5cf9be89d342ee4" translate="yes" xml:space="preserve">
          <source>If a subquery cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; into the outer query, it might still be possible to enhance performance by &quot;pushing down&quot; WHERE clause terms from the outer query into the subquery. Consider an example:</source>
          <target state="translated">하위 쿼리를 외부 쿼리 로 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합&lt;/a&gt; 할 수없는 경우 WHERE 절 용어를 외부 쿼리에서 하위 쿼리로 &quot;푸시 다운&quot;하여 성능을 향상시킬 수 있습니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="cfbdc72faddc3dd92eaf2d66d72d9166e0ce65e3" translate="yes" xml:space="preserve">
          <source>If a system failure occurs at any time after a &quot;delete file&quot; operation (call to the VFS xDelete() method) returns successfully, it is assumed that the file-system will not contain the deleted file following system recovery.</source>
          <target state="translated">&quot;파일 삭제&quot;조작 (VFS xDelete () 메소드 호출)이 성공적으로 리턴 된 후 시스템 장애가 발생하면 시스템 복구 후 파일 시스템에 삭제 된 파일이 포함되지 않는 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c32e1e0b557aefde59c28d931cf3e5d6733099fd" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during a &quot;delete file&quot; operation, it is assumed that following system recovery the file-system will either contain the file being deleted in the state it was in before the operation was attempted, or not contain the file at all. It is assumed that it is not possible for the file to have become corrupted purely as a result of a failure occurring during a &quot;delete file&quot; operation.</source>
          <target state="translated">&quot;파일 삭제&quot;작업 중 시스템 오류가 발생하면 시스템 복구 후 파일 시스템에 작업을 시도하기 전의 상태에서 삭제중인 파일이 포함되거나 파일이 전혀 포함되지 않은 것으로 가정합니다. . &quot;파일 삭제&quot;조작 중에 발생하는 실패로 인해 파일이 완전히 손상된 것은 불가능하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="91f96ef24748138cdd82c09ceabe7f648ae9cf43" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;create file&quot; operation, but before the created file has been</source>
          <target state="translated">&quot;파일 작성&quot;조작 중 또는 이후, 그러나 작성된 파일이 작성되기 전에 시스템 장애가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="1fcfee495c57582bc4c6e63019680717056464ec" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;truncate file&quot; operation, but before the truncated file has been</source>
          <target state="translated">&quot;파일 자르기&quot;조작 중 또는 후에 시스템이 잘 리거나 잘린 파일 이전에 시스템 장애가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="e3c60bc044d7ebf2be0e926e292ed7263d6ed54a" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation that causes the file to grow, but before the corresponding file has been</source>
          <target state="translated">&quot;파일 쓰기&quot;조작 중 또는 후에 시스템 장애가 발생하여 파일이 커지지 만 해당 파일이 커지기 전에</target>
        </trans-unit>
        <trans-unit id="0de8e98595413448f2b535870f8da207b8048237" translate="yes" xml:space="preserve">
          <source>If a system failure occurs during or after a &quot;write file&quot; operation, but before the corresponding file has been</source>
          <target state="translated">&quot;파일 쓰기&quot;작업 중 또는 이후에 해당 파일이 실행되기 전에 시스템 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="12d84c274c03171c71b26275c99f75f3392362a6" translate="yes" xml:space="preserve">
          <source>If a system failure occurs on a system that supports the</source>
          <target state="translated">시스템을 지원하는 시스템에서 시스템 오류가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="70f739b455c168080412690c97f5940222b8f766" translate="yes" xml:space="preserve">
          <source>If a system supports</source>
          <target state="translated">시스템이 지원하는 경우</target>
        </trans-unit>
        <trans-unit id="ec9800aa0fd4fbf6e94d5e57566c8304e2f2782b" translate="yes" xml:space="preserve">
          <source>If a system supports the</source>
          <target state="translated">시스템이</target>
        </trans-unit>
        <trans-unit id="16f55a3959edd0a92c0395b9cf4c3468da074f4f" translate="yes" xml:space="preserve">
          <source>If a table contains a column of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then that column becomes an alias for the ROWID. You can then access the ROWID using any of four different names, the original three names described above or the name given to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column. All these names are aliases for one another and work equally well in any context.</source>
          <target state="translated">테이블에 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 유형의 열이 포함 된 경우 해당 열은 ROWID의 별명이됩니다. 그런 다음 네 가지 다른 이름, 위에서 설명한 원래 세 가지 이름 또는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열에 지정된 이름을 사용하여 ROWID에 액세스 할 수 있습니다 . 이 모든 이름은 서로의 별명이며 모든 상황에서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a73b6736040e74c7d625fd213eca9757c75eee19" translate="yes" xml:space="preserve">
          <source>If a table has a single column primary key and the declared type of that column is &quot;INTEGER&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, then the column is known as an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;. See &lt;a href=&quot;lang_createtable#rowid&quot;&gt;below&lt;/a&gt; for a description of the special properties and behaviors associated with an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;.</source>
          <target state="translated">테이블에 단일 컬럼 기본 키가 있고 해당 컬럼의 선언 된 유형이 &quot;INTEGER&quot;이고 테이블이 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아닌 경우 컬럼을 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY라고&lt;/a&gt; 합니다. &lt;a href=&quot;lang_createtable#rowid&quot;&gt;정수 PRIMARY KEY&lt;/a&gt; 와 관련된 특수 속성 및 동작에 대한 설명은 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e353db8a7a970978b864076f23349bbe29b3cd1" translate="yes" xml:space="preserve">
          <source>If a term in X is of the form &quot;z IS NOT NULL&quot; and if a term in W is a comparison operator on &quot;z&quot; other than &quot;IS&quot;, then those terms match.</source>
          <target state="translated">X의 용어가 &quot;z IS NOT NULL&quot;형식이고 W의 용어가 &quot;IS&quot;이외의 &quot;z&quot;의 비교 연산자 인 경우 해당 용어가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="d7704041f8ff8a11a4c662eef3d671025a3e5ebe" translate="yes" xml:space="preserve">
          <source>If a term of the WHERE clause is of the following form:</source>
          <target state="translated">WHERE 절의 용어가 다음 형식 인 경우 :</target>
        </trans-unit>
        <trans-unit id="e5d671a1040d0448cbcd3997833359da102571a4" translate="yes" xml:space="preserve">
          <source>If a transaction involves multiple databases, then a more complex commit sequence is used, as follows:</source>
          <target state="translated">트랜잭션에 여러 데이터베이스가 포함 된 경우 다음과 같이 더 복잡한 커밋 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b08d45fd51c4591fce14d3b424e9dccc579bef5" translate="yes" xml:space="preserve">
          <source>If a transaction is aborted due to an application crash, an operating system crash, or a hardware power failure or crash, then the database may be left in an inconsistent state. The next time SQLite attempts to open the database file, the presence of the rollback journal file will be detected and the journal will be automatically played back to restore the database to its state at the start of the incomplete transaction.</source>
          <target state="translated">응용 프로그램 충돌, 운영 체제 충돌 또는 하드웨어 정전 또는 충돌로 인해 트랜잭션이 중단되면 데이터베이스가 일관성이없는 상태로 남아있을 수 있습니다. 다음에 SQLite가 데이터베이스 파일을 열려고 시도하면 롤백 저널 파일이 있는지 감지하고 저널이 자동으로 재생되어 데이터베이스가 불완전한 트랜잭션이 시작될 때의 상태로 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="b139c7ece8944c0ce3ad448cfb0c14ea14a36c67" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; 인터페이스가 호출 될 때 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 쓰기 트랜잭션이 열린 경우 현재 사용 중이 아닌 pager-cache의 더티 페이지는 디스크에 기록됩니다. 활성 SQL 문으로 작성된 데이터베이스 커서가이를 읽거나 데이터베이스 파일의 1 페이지 인 경우 (1 페이지는 항상 &quot;사용 중&quot;) 더티 페이지가 사용 중일 수 있습니다. &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; 인터페이스는 모든 스키마에 대한 캐시를 플러시 - &quot;주&quot;, &quot;온도&quot;, 및 &lt;a href=&quot;lang_attach&quot;&gt;부착&lt;/a&gt; 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="94598ac271e5cdca4a0d9c950ece2e2fde3c85ae" translate="yes" xml:space="preserve">
          <source>If a write-transaction is open on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when the &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface invoked, any dirty pages in the pager-cache that are not currently in use are written out to disk. A dirty page may be in use if a database cursor created by an active SQL statement is reading from it, or if it is page 1 of a database file (page 1 is always &quot;in use&quot;). The &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush(D)&lt;/a&gt; interface flushes caches for all schemas - &quot;main&quot;, &quot;temp&quot;, and any &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; databases.</source>
          <target state="translated">&lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; 인터페이스가 호출 될 때 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 쓰기 트랜잭션이 열린 경우 현재 사용 중이 아닌 pager-cache의 더티 페이지는 디스크에 기록됩니다. 활성 SQL 문으로 작성된 데이터베이스 커서가이를 읽거나 데이터베이스 파일의 1 페이지 인 경우 (1 페이지는 항상 &quot;사용 중&quot;) 더티 페이지가 사용 중일 수 있습니다. &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush (D)&lt;/a&gt; 인터페이스는 모든 스키마에 대한 캐시를 플러시 - &quot;주&quot;, &quot;온도&quot;, 및 &lt;a href=&quot;../lang_attach&quot;&gt;부착&lt;/a&gt; 데이터베이스.</target>
        </trans-unit>
        <trans-unit id="9d687ea67d2673f11d5b429c0195a169c2caa77a" translate="yes" xml:space="preserve">
          <source>If a write-transaction is started and the Vdbe.usesStmtJournal flag is true (this flag is set if the Vdbe may modify more than one row and may throw an ABORT exception), a statement transaction may also be opened. More specifically, a statement transaction is opened iff the database connection is currently not in autocommit mode, or if there are other active statements. A statement transaction allows the changes made by this VDBE to be rolled back after an error without having to roll back the entire transaction. If no error is encountered, the statement transaction will automatically commit when the VDBE halts.</source>
          <target state="translated">쓰기 트랜잭션이 시작되고 Vdbe.usesStmtJournal 플래그가 true 인 경우 (이 플래그는 Vdbe가 둘 이상의 행을 수정하고 ABORT 예외를 발생시킬 수있는 경우 설정 됨) 명령문 트랜잭션도 열 수 있습니다. 보다 구체적으로, 데이터베이스 연결이 현재 자동 커미트 모드가 아니거나 다른 활성 명령문이있는 경우 명령문 트랜잭션이 열립니다. 명령문 트랜잭션을 사용하면 전체 트랜잭션을 롤백 할 필요없이 오류가 발생한 후이 VDBE에 의해 작성된 변경 사항을 롤백 할 수 있습니다. 오류가 발생하지 않으면 VDBE가 중지 될 때 명령문 트랜잭션이 자동으로 커미트됩니다.</target>
        </trans-unit>
        <trans-unit id="7e874d6b40d57619d9fa5fb8dd75a92de53ed059" translate="yes" xml:space="preserve">
          <source>If all three of the steps enumerated above are executed successfully, then it is safe to modify the content of the</source>
          <target state="translated">위에 열거 된 세 단계가 모두 성공적으로 실행되면 내용을 수정하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="76124bb023821e31ac6f5cbf1f8b54083a3ec643" translate="yes" xml:space="preserve">
          <source>If an &quot;ALTER TABLE ... RENAME TO&quot; command is used to rename a table that is the parent table of one or more foreign key constraints, the definitions of the foreign key constraints are modified to refer to the parent table by its new name. The text of the child CREATE TABLE statement or statements stored in the sqlite_master table are modified to reflect the new parent table name.</source>
          <target state="translated">&quot;ALTER TABLE ... RENAME TO&quot;명령을 사용하여 하나 이상의 외래 키 제약 조건의 부모 테이블 인 테이블의 이름을 바꾸면 외래 키 제약 조건의 정의가 새 이름으로 부모 테이블을 참조하도록 수정됩니다. . 자식 CREATE TABLE 문의 텍스트 또는 sqlite_master 테이블에 저장된 명령문은 새 부모 테이블 이름을 반영하도록 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="7603e9a69b7a72c62bbc679327133633953ff9aa" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">는 IF &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를&lt;/a&gt; 트랜잭션이 열려있는 동안 개체가 소멸 트랜잭션이 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="53a3481d0fa9e30b2f0d27a6044ee94e1a62bb9b" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">경우 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT는&lt;/a&gt; 트리거 내에서 발생하는 다음이 루틴은 반환 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 한 트리거가 실행되는 삽입 된 행의를. 트리거 프로그램이 종료되면이 루틴이 리턴 한 값이 트리거가 시작되기 전의 값으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="877e1b4a7430ba11b48b32c5598ad0c65dc34442" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; occurs within a trigger then this routine will return the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the inserted row as long as the trigger is running. Once the trigger program ends, the value returned by this routine reverts to what it was before the trigger was fired.</source>
          <target state="translated">경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT는&lt;/a&gt; 트리거 내에서 발생하는 다음이 루틴은 반환 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 한 트리거가 실행되는 삽입 된 행의를. 트리거 프로그램이 종료되면이 루틴이 리턴 한 값이 트리거가 시작되기 전의 값으로 되돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="b95cb40fc8352b696796b3bff79e2f006b1ce07a" translate="yes" xml:space="preserve">
          <source>If an &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is destroyed while a transaction is open, the transaction is automatically rolled back.</source>
          <target state="translated">는 IF &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를&lt;/a&gt; 트랜잭션이 열려있는 동안 개체가 소멸 트랜잭션이 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="9f62d9384e44621989efc3c00f1a3ba721b2e39d" translate="yes" xml:space="preserve">
          <source>If an FTS5 table is configured with columnsize=0 but is not a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the xColumnSize API function still works, but runs much more slowly. In this case, instead of reading the value to return directly from the database, it reads the text value itself and count the tokens within it on demand.</source>
          <target state="translated">FTS5 테이블이 columnsize = 0으로 구성되었지만 컨텐츠가없는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;테이블&lt;/a&gt; 이 아닌 경우 xColumnSize API 함수는 여전히 작동하지만 훨씬 느리게 실행됩니다. 이 경우 데이터베이스에서 직접 리턴 할 값을 읽는 대신 텍스트 값 자체를 읽고 요청시 해당 값 내의 토큰을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a593df8166351f80d07eb58cb262614d9dbc8634" translate="yes" xml:space="preserve">
          <source>If an INSERT statement attempts to insert a NULL value into a rowid or integer primary key column, the system chooses an integer value to use as the rowid automatically. A detailed description of how this is done is provided &lt;a href=&quot;autoinc&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">INSERT 문이 rowid 또는 integer 기본 키 열에 NULL 값을 삽입하려고 시도하면 시스템은 rowid로 자동 사용할 정수 값을 선택합니다. 이 작업을 수행하는 방법에 대한 자세한 설명은 &lt;a href=&quot;autoinc&quot;&gt;별도로&lt;/a&gt; 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba4158b1467dce3a1f2ceab9abb8de00b0fe4463" translate="yes" xml:space="preserve">
          <source>If an ORDER BY clause is present, it determines the order in which rows are extracted from the queue in step 2a. If there is no ORDER BY clause, then the order in which rows are extracted is undefined. (In the current implementation, the queue becomes a FIFO if the ORDER BY clause is omitted, but applications should not depend on that fact since it might change.)</source>
          <target state="translated">ORDER BY 절이 존재하면 2a 단계에서 큐에서 행이 추출되는 순서를 판별합니다. ORDER BY 절이 없으면 행이 추출되는 순서가 정의되지 않습니다. 현재 구현에서 ORDER BY 절을 생략하면 대기열이 FIFO가되지만 응용 프로그램은 변경 될 수 있으므로 해당 사실에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="22141c686821647d4155d6b151a8d8fa154cd1a8" translate="yes" xml:space="preserve">
          <source>If an SQL operation is very nearly finished at the time when sqlite3_interrupt() is called, then it might not have an opportunity to be interrupted and might continue to completion.</source>
          <target state="translated">sqlite3_interrupt ()가 호출 될 때 SQL 조작이 거의 완료된 경우 중단 될 기회가없고 계속 완료 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="923eabd2cf996c975383b0dccd3e5fb8dc063dde" translate="yes" xml:space="preserve">
          <source>If an SQL statement is limited to be a million bytes in length, then obviously you will not be able to insert multi-million byte strings by embedding them as literals inside of INSERT statements. But you should not do that anyway. Use host &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; for your data. Prepare short SQL statements like this:</source>
          <target state="translated">SQL 문의 길이가 백만 바이트로 제한되면 수백만 바이트 문자열을 INSERT 문에 리터럴로 삽입하여 삽입 할 수 없습니다. 그러나 어쨌든 그렇게해서는 안됩니다. 데이터에 호스트 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 를 사용하십시오 . 다음과 같은 짧은 SQL 문을 준비하십시오.</target>
        </trans-unit>
        <trans-unit id="a519000750401db43c985f6fefc862d71c74bede" translate="yes" xml:space="preserve">
          <source>If an SQL table is created using the &quot;WITHOUT ROWID&quot; clause at the end of its CREATE TABLE statement, then that table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and uses a different on-disk representation. A WITHOUT ROWID table uses an index b-tree rather than a table b-tree for storage. The key for each entry in the WITHOUT ROWID b-tree is a record composed of the columns of the PRIMARY KEY followed by all remaining columns of the table. The primary key columns appear in the order they they were declared in the PRIMARY KEY clause and the remaining columns appear in the order they occur in the CREATE TABLE statement.</source>
          <target state="translated">CREATE TABLE 문 끝에서 &quot;WITHOUT ROWID&quot;절을 사용하여 SQL 테이블을 작성하는 경우 해당 테이블은 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이며 다른 디스크 상 표현을 사용합니다. WITHOUT ROWID 테이블은 저장을 위해 테이블 ​​b- 트리 대신 인덱스 b- 트리를 사용합니다. WITHOUT ROWID b- 트리의 각 항목에 대한 키는 PRIMARY KEY의 열과 테이블의 나머지 열이 모두 포함 된 레코드입니다. 기본 키 열은 PRIMARY KEY 절에서 선언 된 순서대로 나타나고 나머지 열은 CREATE TABLE 문에서 나타나는 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7a1f15ef308e23ec2fc80a29e25882265ebf0786" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement attempts to set an integer primary key or rowid column to a NULL or blob value, or to a string or real value that cannot be losslessly converted to an integer, a &quot;datatype mismatch&quot; error occurs and the statement is aborted. If an INSERT statement attempts to insert a blob value, or a string or real value that cannot be losslessly converted to an integer into an integer primary key or rowid column, a &quot;datatype mismatch&quot; error occurs and the statement is aborted.</source>
          <target state="translated">UPDATE 문이 정수 기본 키 또는 rowid 열을 NULL 또는 BLOB 값으로 설정하거나 손실없이 정수로 변환 할 수없는 문자열 또는 실수 값으로 설정하려고하면 &quot;데이터 유형 불일치&quot;오류가 발생하고 명령문이 중단됩니다. INSERT 문이 정수로 정수로 변환 할 수없는 BLOB 값 또는 문자열 또는 실수 값을 정수 기본 키 또는 rowid 열에 삽입하려고하면 &quot;데이터 유형 불일치&quot;오류가 발생하고 명령문이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="284b34da69fbf9cd89926df318af7634184253b9" translate="yes" xml:space="preserve">
          <source>If an UPDATE statement has a LIMIT clause, the maximum number of rows that will be updated is found by evaluating the accompanying expression and casting it to an integer value. A negative value is interpreted as &quot;no limit&quot;.</source>
          <target state="translated">UPDATE 문에 LIMIT 절이 있으면 갱신 될 최대 행 수는 수반되는 표현식을 평가하고이를 정수 값으로 캐스트하여 찾습니다. 음수 값은 &quot;제한 없음&quot;으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="35654cca0e06875d8f71c06cdb825a502007ac27" translate="yes" xml:space="preserve">
          <source>If an application issues a SELECT statement on a single table like &quot;</source>
          <target state="translated">응용 프로그램이 &quot;와 같은 단일 테이블에서 SELECT 문을 발행하는 경우</target>
        </trans-unit>
        <trans-unit id="3c9847a3fc8345f21ef2aae877b6da29936db6dc" translate="yes" xml:space="preserve">
          <source>If an application puts SQLite in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; using the pragma:</source>
          <target state="translated">애플리케이션이 pragma를 사용하여 SQLite를 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드로 설정&lt;/a&gt; 하는 경우 :</target>
        </trans-unit>
        <trans-unit id="16930c87a89e5aa4dacec21b97a534c286412312" translate="yes" xml:space="preserve">
          <source>If an application using asynchronous IO executes transactions in quick succession, other database users may be effectively locked out of the database. This is because when a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; is executed, a database lock is established immediately. But when the corresponding COMMIT or ROLLBACK occurs, the lock is not released until the relevant part of the write-queue has been flushed through. As a result, if a COMMIT is followed by a BEGIN before the write-queue is flushed through, the database is never unlocked,preventing other processes from accessing the database.</source>
          <target state="translated">비동기 IO를 사용하는 응용 프로그램이 트랜잭션을 빠르게 연속으로 실행하면 다른 데이터베이스 사용자가 데이터베이스에서 효과적으로 잠길 수 있습니다. &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 이 실행될 때 데이터베이스 잠금이 즉시 설정되기 때문입니다. 그러나 해당 COMMIT 또는 ROLLBACK이 발생하면 쓰기 큐의 관련 부분이 비워 질 때까지 잠금이 해제되지 않습니다. 결과적으로 쓰기 큐를 비우기 전에 COMMIT 다음에 BEGIN이 오는 경우 데이터베이스가 잠금 해제되지 않으므로 다른 프로세스가 데이터베이스에 액세스하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="dec67a679cc10b4fb4ca0df679f1b42a8a809bf0" translate="yes" xml:space="preserve">
          <source>If an attempt to acquire a</source>
          <target state="translated">취득하려는 경우</target>
        </trans-unit>
        <trans-unit id="ae2dad7a2ac6f9639d4f707a82a9b585c9a56bd8" translate="yes" xml:space="preserve">
          <source>If an attempt to upgrade to an</source>
          <target state="translated">로 업그레이드하려는 경우</target>
        </trans-unit>
        <trans-unit id="0f4ee50fd2b5b886cf93345554e2cb331273f09d" translate="yes" xml:space="preserve">
          <source>If an error (e.g. an OOM condition) occurs within this function, the auxiliary data is set to NULL and an error code returned. If the xDelete parameter was not NULL, it is invoked on the auxiliary data pointer before returning.</source>
          <target state="translated">이 기능 내에서 오류 (예 : OOM 조건)가 발생하면 보조 데이터가 NULL로 설정되고 오류 코드가 반환됩니다. xDelete 매개 변수가 NULL이 아닌 경우, 리턴하기 전에 보조 데이터 포인터에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8045cc0ef3fd13ca44d5e4369a94674b9f7300cd" translate="yes" xml:space="preserve">
          <source>If an error occurs in any of the three main backup API routines then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and &lt;a href=&quot;c3ref/errcode&quot;&gt;message&lt;/a&gt; are attached to the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Additionally, if &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; encounters an error, then the &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned by both the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; call itself, and by the subsequent call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;. So a call to &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; does not overwrite an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; stored in the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt;. This feature is used in the example code to reduce amount of error handling required. The return values of the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt; calls are ignored and the error code indicating the success or failure of the copy operation collected from the destination &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; afterward.</source>
          <target state="translated">세 가지 기본 백업 API 루틴 중 하나에서 오류가 발생하면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 및 &lt;a href=&quot;c3ref/errcode&quot;&gt;메시지&lt;/a&gt; 가 대상 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 첨부됩니다 . 또한 경우 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()는&lt;/a&gt; 에러 발생 후, &lt;a href=&quot;rescode&quot;&gt;에러 코드&lt;/a&gt; 모두에서 반환 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 자신을 호출 한 이후에 호출 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; . 를 호출 그래서 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()는&lt;/a&gt; 덮어 쓰기하지 않는 &lt;a href=&quot;rescode&quot;&gt;오류 코드가&lt;/a&gt; 대상에 저장된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 의한 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;) (sqlite3_backup_step를&lt;/a&gt;. 이 기능은 예제 코드에서 필요한 오류 처리량을 줄이기 위해 사용됩니다. &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; 호출 의 리턴 값 은 무시되고 이후에 대상 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 수집 된 복사 조작의 성공 또는 실패를 나타내는 오류 코드가 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8416d9f169797cd1d1df3d689a0f3981d1e1914" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">sqlite3_exec ()에 전달 된 SQL 문을 평가하는 동안 오류가 발생하면 현재 명령문의 실행이 중지되고 후속 명령문은 건너 뜁니다. sqlite3_exec ()에 대한 5 번째 매개 변수가 NULL이 아니면 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 오류 메시지가 기록되고 5 번째 매개 변수를 통해 다시 전달됩니다. 메모리 누수를 피하려면 오류 메시지 문자열이 더 이상 필요하지 않은 후 응용 프로그램은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_exec ()&lt;/a&gt; 의 다섯 번째 매개 변수를 통해 리턴 된 오류 메시지 문자열에서 sqlite3_free () 를 호출해야 합니다. sqlite3_exec ()에 대한 5 번째 매개 변수가 NULL이 아니고 오류가 발생하지 않으면 sqlite3_exec ()는 5 번째 매개 변수의 포인터를 리턴하기 전에 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="67c739deca1fc659fe9011cffdf430f71e9a737b" translate="yes" xml:space="preserve">
          <source>If an error occurs while evaluating the SQL statements passed into sqlite3_exec(), then execution of the current statement stops and subsequent statements are skipped. If the 5th parameter to sqlite3_exec() is not NULL then any error message is written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and passed back through the 5th parameter. To avoid memory leaks, the application should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on error message strings returned through the 5th parameter of sqlite3_exec() after the error message string is no longer needed. If the 5th parameter to sqlite3_exec() is not NULL and no errors occur, then sqlite3_exec() sets the pointer in its 5th parameter to NULL before returning.</source>
          <target state="translated">sqlite3_exec ()에 전달 된 SQL 문을 평가하는 동안 오류가 발생하면 현재 명령문의 실행이 중지되고 후속 명령문은 건너 뜁니다. sqlite3_exec ()에 대한 5 번째 매개 변수가 NULL이 아니면 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 오류 메시지가 기록되고 5 번째 매개 변수를 통해 다시 전달됩니다. 메모리 누수를 피하려면 오류 메시지 문자열이 더 이상 필요하지 않은 후 응용 프로그램은 &lt;a href=&quot;free&quot;&gt;sqlite3_exec ()&lt;/a&gt; 의 다섯 번째 매개 변수를 통해 리턴 된 오류 메시지 문자열에서 sqlite3_free () 를 호출해야 합니다. sqlite3_exec ()에 대한 5 번째 매개 변수가 NULL이 아니고 오류가 발생하지 않으면 sqlite3_exec ()는 5 번째 매개 변수의 포인터를 리턴하기 전에 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="194a0b44e46a56e474b265407cd79a961ab1ee3b" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">sqlite3_backup_init (D, N, S, M) 내에서 오류가 발생하면 NULL이 리턴되고 오류 코드 및 오류 메시지가 대상 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D에 저장됩니다. sqlite3_backup_init ()에 대한 호출 실패에 대한 오류 코드 및 메시지는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; 함수를 사용하여 검색 됩니다. sqlite3_backup_init ()를 성공적으로 호출하면 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체에 대한 포인터가 반환 됩니다. &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup의&lt;/a&gt; 목적은 특정 백업 작업을 수행 할 sqlite3_backup_step () 및 sqlite3_backup_finish () 함수를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="1200818faf5a8fe2f6854c6a6851d33b2f623b3d" translate="yes" xml:space="preserve">
          <source>If an error occurs within sqlite3_backup_init(D,N,S,M), then NULL is returned and an error code and error message are stored in the destination &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. The error code and message for the failed call to sqlite3_backup_init() can be retrieved using the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt;, &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;, and/or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; functions. A successful call to sqlite3_backup_init() returns a pointer to an &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object may be used with the sqlite3_backup_step() and sqlite3_backup_finish() functions to perform the specified backup operation.</source>
          <target state="translated">sqlite3_backup_init (D, N, S, M) 내에서 오류가 발생하면 NULL이 리턴되고 오류 코드 및 오류 메시지가 대상 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D에 저장됩니다. sqlite3_backup_init ()에 대한 호출 실패에 대한 오류 코드 및 메시지는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; , &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 / 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt; 함수를 사용하여 검색 됩니다. sqlite3_backup_init ()를 성공적으로 호출하면 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체에 대한 포인터가 반환 됩니다. &lt;a href=&quot;backup&quot;&gt;sqlite3_backup의&lt;/a&gt; 목적은 특정 백업 작업을 수행 할 sqlite3_backup_step () 및 sqlite3_backup_finish () 함수를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="100ded69e0a780b44961df68d1032c0e7c075797" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned and the output variables (*pnData) and (*ppData) are set to 0. Otherwise, SQLITE_OK is returned and the output variables are set to the size of and a pointer to the output buffer, respectively. In this case it is the responsibility of the caller to eventually free the buffer using a call to sqlite3_free().</source>
          <target state="translated">오류가 발생하면 SQLite 오류 코드가 리턴되고 출력 변수 (* pnData) 및 (* ppData)가 0으로 설정됩니다. 그렇지 않으면 SQLITE_OK가 리턴되고 출력 변수가 크기 및 출력에 대한 포인터로 설정됩니다. 버퍼. 이 경우 호출자는 sqlite3_free () 호출을 사용하여 버퍼를 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="622e26e115262f02ac7f60da2462323cdc540b9f" translate="yes" xml:space="preserve">
          <source>If an error occurs, an SQLite error code is returned. Possible error codes include SQLITE_CORRUPT (if the changeset buffer is corrupt) or SQLITE_NOMEM.</source>
          <target state="translated">오류가 발생하면 SQLite 오류 코드가 리턴됩니다. 가능한 오류 코드에는 SQLITE_CORRUPT (변경 세트 버퍼가 손상된 경우) 또는 SQLITE_NOMEM이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e455ebdd54ae8a16893e6de74ee6f1db7c5e35d7" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">에러는 sqlite3changeset_xxx () 함수 호출 (예를 들면 내에서 발생했을 경우 &lt;a href=&quot;../rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 에 &lt;a href=&quot;sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 에서 &lt;a href=&quot;sqlite3changeset_new&quot;&gt;() sqlite3changeset_new&lt;/a&gt; ) 그 에러에 대응하는 에러 코드는이 함수에 의해 리턴된다. 그렇지 않으면 SQLITE_OK가 리턴됩니다. 다음 패턴 (의사 코드)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1bc5bca387ff960fe9687401573a47507a4fa49f" translate="yes" xml:space="preserve">
          <source>If an error was encountered within a call to an sqlite3changeset_xxx() function (for example an &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next()&lt;/a&gt; or an &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; in &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt;) then an error code corresponding to that error is returned by this function. Otherwise, SQLITE_OK is returned. This is to allow the following pattern (pseudo-code):</source>
          <target state="translated">에러는 sqlite3changeset_xxx () 함수 호출 (예를 들면 내에서 발생했을 경우 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 에 &lt;a href=&quot;#sqlite3changeset_next&quot;&gt;sqlite3changeset_next ()&lt;/a&gt; 또는 &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 에서 &lt;a href=&quot;#sqlite3changeset_new&quot;&gt;() sqlite3changeset_new&lt;/a&gt; ) 그 에러에 대응하는 에러 코드는이 함수에 의해 리턴된다. 그렇지 않으면 SQLITE_OK가 리턴됩니다. 다음 패턴 (의사 코드)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="1b680ceb7d64040ce2b6564485c5ca5b1c9689a0" translate="yes" xml:space="preserve">
          <source>If an fts5vocab table is created in the temp database, it may be associated with an FTS5 table in any attached database. In order to attach the fts5vocab table to an FTS5 table located in a database other than &quot;temp&quot;, the name of the database is inserted before the FTS5 table name in the CREATE VIRTUAL TABLE arguments. For example:</source>
          <target state="translated">fts5vocab 테이블이 임시 데이터베이스에 작성되면 연결된 데이터베이스의 FTS5 테이블과 연관 될 수 있습니다. fts5vocab 테이블을 &quot;temp&quot;이외의 데이터베이스에있는 FTS5 테이블에 첨부하기 위해 데이터베이스 이름이 CREATE VIRTUAL TABLE 인수에서 FTS5 테이블 이름 앞에 삽입됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3334fd5a8f49d3b3b23387e0ded39340f08eab83" translate="yes" xml:space="preserve">
          <source>If an index is available on the ORDER BY column, that index can be used for sorting. Consider the request for all items sorted by &quot;fruit&quot;:</source>
          <target state="translated">ORDER BY 열에서 인덱스를 사용할 수있는 경우 해당 인덱스를 사용하여 정렬 할 수 있습니다. &quot;과일&quot;로 정렬 된 모든 품목에 대한 요청을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7ff3ecb138d9749f1bf1bb734a03098e601b851c" translate="yes" xml:space="preserve">
          <source>If an index is created using a statement like this:</source>
          <target state="translated">다음과 같은 명령문을 사용하여 색인을 작성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="19ed5776fff64746115879da20e80724a2114442" translate="yes" xml:space="preserve">
          <source>If an instance-list grows so large that it exceeds the &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; limit, FTS3/4 is unable to handle it. FTS5 does not have this problem.</source>
          <target state="translated">인스턴스 목록이 너무 커서 &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 제한을 초과하면 FTS3 / 4가이를 처리 할 수 ​​없습니다. FTS5에는이 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e669868d5fcfe552cb1dbbc9c2998f5505f629e6" translate="yes" xml:space="preserve">
          <source>If an interface fails with SQLITE_MISUSE, that means the interface was invoked incorrectly by the application. In that case, the error code and message may or may not be set.</source>
          <target state="translated">SQLITE_MISUSE로 인터페이스가 실패하면 응용 프로그램이 인터페이스를 잘못 호출했음을 의미합니다. 이 경우 오류 코드와 메시지가 설정되거나 설정되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="582fb0780f4838faf9f9c1524bd108b2fc64370c" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">메모리 부족 오류가 발생하면 이러한 루틴의 리턴 값은 열에 SQL NULL 값이 포함 된 것과 같습니다. 유효한 SQL NULL 리턴은 의심되는 리턴 값을 얻은 직후와 동일한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 다른 SQLite 인터페이스를 호출하기 전에 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 를 호출하여 메모리 부족 오류와 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5851016a3fb15ec26147b80722e832005884d3e4" translate="yes" xml:space="preserve">
          <source>If an out-of-memory error occurs, then the return value from these routines is the same as if the column had contained an SQL NULL value. Valid SQL NULL returns can be distinguished from out-of-memory errors by invoking the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; immediately after the suspect return value is obtained and before any other SQLite interface is called on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">메모리 부족 오류가 발생하면 이러한 루틴의 리턴 값은 열에 SQL NULL 값이 포함 된 것과 같습니다. 유효한 SQL NULL 리턴은 의심되는 리턴 값을 얻은 직후와 동일한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 다른 SQLite 인터페이스를 호출하기 전에 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 를 호출하여 메모리 부족 오류와 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53a860ff4ceaa780f514879a263f3e2bd7a64b45" translate="yes" xml:space="preserve">
          <source>If an sqlite3_exec() callback returns non-zero, the sqlite3_exec() routine returns SQLITE_ABORT without invoking the callback again and without running any subsequent SQL statements.</source>
          <target state="translated">sqlite3_exec () 콜백이 0이 아닌 값을 리턴하면, sqlite3_exec () 루틴은 콜백을 다시 호출하지 않고 후속 SQL 문을 실행하지 않고 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="86f2a1856f49f287cef6815b989e3bcfc9f7c019" translate="yes" xml:space="preserve">
          <source>If an update is only partially applied to the target database by the time sqlite3rbu_close() is called, state information is saved within the state database if it exists, or otherwise in the RBU database. This allows subsequent processes to automatically resume the RBU update from where it left off. If state information is stored in the RBU database, it can be removed by dropping all tables whose names begin with &quot;rbu_&quot;.</source>
          <target state="translated">sqlite3rbu_close ()가 호출 될 때까지 업데이트가 대상 데이터베이스에만 부분적으로 적용되는 경우 상태 정보는 상태 데이터베이스 (있는 경우) 또는 RBU 데이터베이스에 저장됩니다. 이를 통해 후속 프로세스는 중단 된 위치에서 RBU 업데이트를 자동으로 재개 할 수 있습니다. 상태 정보가 RBU 데이터베이스에 저장된 경우 이름이 &quot;rbu_&quot;로 시작하는 모든 테이블을 삭제하여 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd175412c5f187514ee87168844f1bedfa975635" translate="yes" xml:space="preserve">
          <source>If an xToken() callback returns any value other than SQLITE_OK, then the tokenization should be abandoned and the xTokenize() method should immediately return a copy of the xToken() return value. Or, if the input buffer is exhausted, xTokenize() should return SQLITE_OK. Finally, if an error occurs with the xTokenize() implementation itself, it may abandon the tokenization and return any error code other than SQLITE_OK or SQLITE_DONE.</source>
          <target state="translated">xToken () 콜백이 SQLITE_OK 이외의 다른 값을 리턴하면 토큰 화가 취소되고 xTokenize () 메소드가 즉시 xToken () 리턴 값의 사본을 리턴해야합니다. 또는 입력 버퍼가 소진되면 xTokenize ()는 SQLITE_OK를 반환해야합니다. 마지막으로, xTokenize () 구현 자체에서 오류가 발생하면 토큰 화를 포기하고 SQLITE_OK 또는 SQLITE_DONE 이외의 오류 코드를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0be452758cf5838f411f1a08b26770962254070e" translate="yes" xml:space="preserve">
          <source>If and only if the previously described conversion of OR to an IN operator does not work, the second OR-clause optimization is attempted. Suppose the OR clause consists of multiple subterms as follows:</source>
          <target state="translated">이전에 설명 된 OR의 IN 연산자로의 변환이 작동하지 않는 경우에만 두 번째 OR 절 최적화가 시도됩니다. OR 절이 다음과 같이 여러 하위 용어로 구성되어 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1d92fd7f31be8d1f3061a17050b41ab1479f4bcd" translate="yes" xml:space="preserve">
          <source>If another database connection has the database mode open in &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; then all queries against the database will return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. Both Chrome and Firefox open their database files in exclusive locking mode, so attempts to read Chrome or Firefox databases while the applications are running will run into this problem, for example.</source>
          <target state="translated">다른 데이터베이스 연결의 데이터베이스 모드가 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드&lt;/a&gt; 로 열린 경우 데이터베이스에 대한 모든 쿼리는 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 반환 합니다 . Chrome과 Firefox는 모두 독점 잠금 모드로 데이터베이스 파일을 열므로 응용 프로그램이 실행되는 동안 Chrome 또는 Firefox 데이터베이스를 읽으려고하면이 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52c07a908a81f106b3dd1bc1b1492081c7a35d47" translate="yes" xml:space="preserve">
          <source>If another thread changes the autocommit status of the database connection while this routine is running, then the return value is undefined.</source>
          <target state="translated">이 루틴이 실행되는 동안 다른 스레드가 데이터베이스 연결의 자동 커미트 상태를 변경하면 리턴 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8503a498072091f7cabc2db6a10e976de9bc12b1" translate="yes" xml:space="preserve">
          <source>If another thread or process writes to the source database while this function is sleeping, then SQLite detects this and usually restarts the backup process when sqlite3_backup_step() is next called. There is one exception to this rule: If the source database is not an in-memory database, and the write is performed from within the same process as the backup operation and uses the same database handle (pDb), then the destination database (the one opened using connection pFile) is automatically updated along with the source. The backup process may then be continued after the sqlite3_sleep() call returns as if nothing had happened.</source>
          <target state="translated">이 함수가 휴면 상태 인 동안 다른 스레드 또는 프로세스가 소스 데이터베이스에 쓰면 SQLite는이를 감지하여 다음에 sqlite3_backup_step ()이 호출 될 때 백업 프로세스를 다시 시작합니다. 이 규칙에는 한 가지 예외가 있습니다. 소스 데이터베이스가 메모리 내 데이터베이스가 아니고 쓰기가 백업 조작과 동일한 프로세스 내에서 수행되고 동일한 데이터베이스 핸들 (pDb)을 사용하는 경우 대상 데이터베이스 ( 연결 pFile을 사용하여 열린 파일)은 소스와 함께 자동으로 업데이트됩니다. 그런 다음 sqlite3_sleep () 호출이 아무 일도없는 것처럼 리턴 된 후에 백업 프로세스가 계속 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9f8be087686590dab771595e5bd54b7d246dba5" translate="yes" xml:space="preserve">
          <source>If any errors are encountered during compilation, an error message is written into memory obtained from &lt;b&gt;malloc&lt;/b&gt; and the 5th parameter is made to point to that memory. If the 5th parameter is NULL, then no error message is generated. If the 5th parameter is not NULL, then the calling function should dispose of the memory containing the error message by calling &lt;b&gt;sqlite_freemem&lt;/b&gt;.</source>
          <target state="translated">컴파일 중에 오류가 발생하면 &lt;b&gt;malloc&lt;/b&gt; 에서 확보 한 메모리에 오류 메시지가 작성되고 5 번째 매개 변수는 해당 메모리를 가리 키도록 만들어집니다. 5 번째 매개 변수가 NULL이면 오류 메시지가 생성되지 않습니다. 5 번째 매개 변수가 NULL이 아니면 호출 함수는 &lt;b&gt;sqlite_freemem&lt;/b&gt; 을 호출하여 오류 메시지가 포함 된 메모리를 &lt;b&gt;삭제해야&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="83125f64332cc16259858298cfafac27aca598bf" translate="yes" xml:space="preserve">
          <source>If any of the special-case entries shows above are omitted, then the value of 100 is used for insertion and deletion and 150 is used for substitution. To disable the default insertion, deletion, and/or substitution set their respective cost to 10000 or more.</source>
          <target state="translated">위에 표시된 특수 사례 항목 중 하나라도 생략하면 값 100은 삽입 및 삭제에 사용되고 150은 대체에 사용됩니다. 기본 삽입, 삭제 및 / 또는 대체를 비활성화하려면 각각의 비용을 10000 이상으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8b09289d91105f4036d96455156f97ad8f84efdf" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">sqlite3_bind 중 하나가 _ * () 루틴이에 대한 NULL 포인터로 호출하는 경우 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; 이나되는 준비된 문 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 보다 더 최근에 호출 된 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , 다음 호출이 반환됩니다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE을&lt;/a&gt; . sqlite3_bind_ () 루틴 에 완료된 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 전달 되면 결과는 정의되지 않으며 아마도 유해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d6ffdf1dd2e882d0d92b18297a217958bf3b943" translate="yes" xml:space="preserve">
          <source>If any of the sqlite3_bind_*() routines are called with a NULL pointer for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; or with a prepared statement for which &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has been called more recently than &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, then the call will return &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt;. If any sqlite3_bind_() routine is passed a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that has been finalized, the result is undefined and probably harmful.</source>
          <target state="translated">sqlite3_bind 중 하나가 _ * () 루틴이에 대한 NULL 포인터로 호출하는 경우 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; 이나되는 준비된 문 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 보다 더 최근에 호출 된 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , 다음 호출이 반환됩니다 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE을&lt;/a&gt; . sqlite3_bind_ () 루틴 에 완료된 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 전달 되면 결과는 정의되지 않으며 아마도 유해 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecc451199e804c2d9bbaab7eeb8ae7260c861c03" translate="yes" xml:space="preserve">
          <source>If any of these options are defined, then the same set of SQLITE_OMIT_* options must also be defined when using the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; tool to generate the parse.c file and when compiling the 'mkkeywordhash' tool which generates the keywordhash.h file. Because of this, these options may only be used when the library is built from canonical source, not from the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Some SQLITE_OMIT_* options might work, or appear to work, when used with the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. But this is not guaranteed. In general, always compile from canonical sources in order to take advantage of SQLITE_OMIT_* options.</source>
          <target state="translated">이러한 옵션 중 하나라도 정의 된 경우 &lt;a href=&quot;lemon&quot;&gt;레몬 구문 분석기 생성기&lt;/a&gt; 도구를 사용하여 parse.c 파일을 생성 할 때와 keywordhash.h 파일을 생성하는 'mkkeywordhash'도구를 컴파일 할 때 동일한 SQLITE_OMIT_ * 옵션 세트도 정의해야 합니다. 이 때문에 이러한 옵션은 라이브러리가 &lt;a href=&quot;amalgamation&quot;&gt;합병이&lt;/a&gt; 아닌 표준 소스로 빌드 된 경우에만 사용할 수 있습니다 . &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; 과 함께 사용하면 일부 SQLITE_OMIT_ * 옵션이 작동하거나 작동하는 것처럼 보일 수 있습니다 . 그러나 이것이 보장되지는 않습니다. 일반적으로 SQLITE_OMIT_ * 옵션을 이용하려면 항상 표준 소스에서 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="066af8ac5653f5f78e3e77b86a9535152f8106eb" translate="yes" xml:space="preserve">
          <source>If any other constraint violation occurs while applying a change (i.e. a UNIQUE, CHECK or NOT NULL constraint), the conflict handler is invoked with CHANGESET_CONSTRAINT as the second argument.</source>
          <target state="translated">변경 사항을 적용하는 동안 다른 제약 조건 위반 (예 : UNIQUE, CHECK 또는 NOT NULL 제약 조건)이 발생하면 충돌 처리기는 두 번째 인수로 CHANGESET_CONSTRAINT를 사용하여 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c1ffcbd8edc1e59c920bc1e42ef8ae6a08f1c489" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">더티 페이지를 디스크로 플러시하는 동안 다른 오류가 발생하면 (예 : IO 오류 또는 메모리 부족 상태) 처리가 중단되고 SQLite &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 즉시 호출자에게 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="547159ba42f3dd194cd2ac6c73df9dfb51226b89" translate="yes" xml:space="preserve">
          <source>If any other error occurs while flushing dirty pages to disk (for example an IO error or out-of-memory condition), then processing is abandoned and an SQLite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned to the caller immediately.</source>
          <target state="translated">더티 페이지를 디스크로 플러시하는 동안 다른 오류가 발생하면 (예 : IO 오류 또는 메모리 부족 상태) 처리가 중단되고 SQLite &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 즉시 호출자에게 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ed9a42f661215804821abb386ff5f31ffa1294e2" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">sqlite3_str X에서 동적 문자열을 구성하는 동안 이전 오류가 발생한 경우 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 메소드는 적절한 오류 코드를 리턴합니다. &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 메소드가 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 어떤 메모리 부족 오류가 다음 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG은&lt;/a&gt; 동적 문자열의 크기를 초과하는 경우 &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK을&lt;/a&gt; 오류가 없었을 경우.</target>
        </trans-unit>
        <trans-unit id="2797997123bd9f48d4b03d213989316f5ee2db3a" translate="yes" xml:space="preserve">
          <source>If any prior errors have occurred while constructing the dynamic string in sqlite3_str X, then the &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method will return an appropriate error code. The &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt; method returns &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; following any out-of-memory error, or &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; if the size of the dynamic string exceeds &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;, or &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if there have been no errors.</source>
          <target state="translated">sqlite3_str X에서 동적 문자열을 구성하는 동안 이전 오류가 발생한 경우 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 메소드는 적절한 오류 코드를 리턴합니다. &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 메소드가 반환 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 어떤 메모리 부족 오류가 다음 또는 &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG은&lt;/a&gt; 동적 문자열의 크기를 초과하는 경우 &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; , 또는 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK을&lt;/a&gt; 오류가 없었을 경우.</target>
        </trans-unit>
        <trans-unit id="8cf62e1e5822970ab1a0772544bba1f6a9886bdb" translate="yes" xml:space="preserve">
          <source>If any views refer to table X in a way that is affected by the schema change, then drop those views using &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; and recreate them with whatever changes are necessary to accommodate the schema change using &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;.</source>
          <target state="translated">뷰가 스키마 변경의 영향을받는 방식으로 테이블 X를 참조하는 경우 &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW를&lt;/a&gt; 사용하여 해당 뷰를 삭제하고 &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW를&lt;/a&gt; 사용하여 스키마 변경을 수용하는 데 필요한 변경 사항으로 다시 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4bcba20e82a98be0954f7a995f190f8be3b9e76" translate="yes" xml:space="preserve">
          <source>If argument P3 is non-zero, then it indicates that the sorter may assume that a stable sort considering the first P3 fields of each key is sufficient to produce the required results.</source>
          <target state="translated">인수 P3이 0이 아닌 경우 분류기는 각 키의 첫 번째 P3 필드를 고려하여 안정적인 정렬이 필요한 결과를 생성하기에 충분하다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35693c95846989c47eb6a922b6389598e5e5c2ef" translate="yes" xml:space="preserve">
          <source>If argument pnCol is not NULL, then *pnCol is set to the number of columns in the table.</source>
          <target state="translated">인수 pnCol이 NULL이 아닌 경우 * pnCol은 테이블의 열 수로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6eebf7ee5a909998cdac6e1af93d8bf0c4b9e6a9" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">pzTab 인수가 NULL이 아닌 경우, * pzTab은 현재 변경의 영향을받는 테이블 이름을 포함하는 널 종료 utf-8 인코딩 문자열을 가리 키도록 설정됩니다. 버퍼는 반복자에서 sqlite3changeset_next ()가 호출 될 때까지 또는 충돌 핸들러 함수가 리턴 될 때까지 유효합니다. pnCol이 NULL이 아닌 경우 * pnCol은 변경의 영향을받는 테이블의 열 수로 설정됩니다. pbIndirect가 NULL이 아니면 변경이 간접 변경 인 경우 * pbIndirect가 true (1)로 설정되고 그렇지 않으면 false (0)로 설정됩니다. 직접 및 간접 변경에 대한 설명은 &lt;a href=&quot;#sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; 설명서를 참조하십시오 . 마지막으로 pOp가 NULL이 아닌 경우 * pOp는 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 중 하나로 설정됩니다.반복자가 현재 가리키는 변경 유형에 따라</target>
        </trans-unit>
        <trans-unit id="eeb423ada7e3f3af8ece536280a90cde13ccf0f0" translate="yes" xml:space="preserve">
          <source>If argument pzTab is not NULL, then *pzTab is set to point to a nul-terminated utf-8 encoded string containing the name of the table affected by the current change. The buffer remains valid until either sqlite3changeset_next() is called on the iterator or until the conflict-handler function returns. If pnCol is not NULL, then *pnCol is set to the number of columns in the table affected by the change. If pbIndirect is not NULL, then *pbIndirect is set to true (1) if the change is an indirect change, or false (0) otherwise. See the documentation for &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect()&lt;/a&gt; for a description of direct and indirect changes. Finally, if pOp is not NULL, then *pOp is set to one of &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; or &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the type of change that the iterator currently points to.</source>
          <target state="translated">pzTab 인수가 NULL이 아닌 경우, * pzTab은 현재 변경의 영향을받는 테이블 이름을 포함하는 널 종료 utf-8 인코딩 문자열을 가리 키도록 설정됩니다. 버퍼는 반복자에서 sqlite3changeset_next ()가 호출 될 때까지 또는 충돌 핸들러 함수가 리턴 될 때까지 유효합니다. pnCol이 NULL이 아닌 경우 * pnCol은 변경의 영향을받는 테이블의 열 수로 설정됩니다. pbIndirect가 NULL이 아니면 변경이 간접 변경 인 경우 * pbIndirect가 true (1)로 설정되고 그렇지 않으면 false (0)로 설정됩니다. 직접 및 간접 변경에 대한 설명은 &lt;a href=&quot;sqlite3session_indirect&quot;&gt;sqlite3session_indirect ()&lt;/a&gt; 설명서를 참조하십시오 . 마지막으로 pOp가 NULL이 아닌 경우 * pOp는 &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;../c3ref/c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 중 하나로 설정됩니다.반복자가 현재 가리키는 변경 유형에 따라</target>
        </trans-unit>
        <trans-unit id="012db9d404feeb7b242a5f104e807e9ebcf5e6cc" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">zTab 인수가 NULL이 아닌 경우, 첫 번째 인수로 전달 된 세션 오브젝트에 첨부 할 테이블의 이름입니다. 세션 개체가 활성화 된 동안 테이블에 대한 모든 후속 변경 사항이 기록됩니다. 자세한 내용은 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="1874355cfa55a648a95d55d6cc4ad4d5d5a5435f" translate="yes" xml:space="preserve">
          <source>If argument zTab is not NULL, then it is the name of a table to attach to the session object passed as the first argument. All subsequent changes made to the table while the session object is enabled will be recorded. See documentation for &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; for further details.</source>
          <target state="translated">zTab 인수가 NULL이 아닌 경우, 첫 번째 인수로 전달 된 세션 오브젝트에 첨부 할 테이블의 이름입니다. 세션 개체가 활성화 된 동안 테이블에 대한 모든 후속 변경 사항이 기록됩니다. 자세한 내용은 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="21fcaf7a804fb18a6bdf460073dabd9a55d816ad" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 0 (false). In other words, a prior r[P2] value will not be overwritten by 1 (true).</source>
          <target state="translated">SQLITE_STOREP2 및 SQLITE_KEEPNULL 플래그가 모두 설정되면 r [P2]의 내용은 새 값이 NULL 또는 0 (false) 인 경우에만 변경됩니다. 즉, 이전 r [P2] 값은 1 (true)로 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f091230c98fc9fb42f84687fff668e2e8782487e" translate="yes" xml:space="preserve">
          <source>If both SQLITE_STOREP2 and SQLITE_KEEPNULL flags are set then the content of r[P2] is only changed if the new value is NULL or 1 (true). In other words, a prior r[P2] value will not be overwritten by 0 (false).</source>
          <target state="translated">SQLITE_STOREP2 및 SQLITE_KEEPNULL 플래그가 둘 다 설정되면 r [P2]의 내용은 새 값이 NULL 또는 1 (true) 인 경우에만 변경됩니다. 즉, 이전 r [P2] 값을 0 (거짓)으로 덮어 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b35b42f8226135f60e30979149548acecdb3cd9a" translate="yes" xml:space="preserve">
          <source>If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</source>
          <target state="translated">If both pragmas &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; are OFF then case (2) applies.</target>
        </trans-unit>
        <trans-unit id="c1ea5de7bdcea197233ed39232910d2d33159cd2" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">다중 명령문 트랜잭션 내의 명령문에서 특정 종류의 오류가 발생하면 ( &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 및 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 포함 오류 ) 트랜잭션이 자동으로 롤백 될 수 있습니다. 오류 후 SQLite가 트랜잭션을 자동으로 롤백했는지 여부를 확인하는 유일한 방법은이 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="063cf3d6b1f8d89a285c8317271a90d08b9bd66c" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur on a statement within a multi-statement transaction (errors including &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt;, &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, and &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;) then the transaction might be rolled back automatically. The only way to find out whether SQLite automatically rolled back the transaction after an error is to use this function.</source>
          <target state="translated">다중 명령문 트랜잭션 내의 명령문에서 특정 종류의 오류가 발생하면 ( &lt;a href=&quot;../rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; , &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 및 &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 포함 오류 ) 트랜잭션이 자동으로 롤백 될 수 있습니다. 오류 후 SQLite가 트랜잭션을 자동으로 롤백했는지 여부를 확인하는 유일한 방법은이 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="65b57925e204e3ebe11c23e15127d898a0e33ca6" translate="yes" xml:space="preserve">
          <source>If certain kinds of errors occur within a transaction, the transaction may or may not be rolled back automatically. The errors that can cause an automatic rollback include:</source>
          <target state="translated">트랜잭션 내에서 특정 종류의 오류가 발생하면 트랜잭션이 자동으로 롤백되거나 롤백되지 않을 수 있습니다. 자동 롤백을 유발할 수있는 오류는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="debbf4ee0f449f15f2b2fad59057f8a4eccd847a" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then it is undefined whether or not the query will see those changes.</source>
          <target state="translated">쿼리 실행이 시작된 후 쿼리가 완료되기 전에 동일한 데이터베이스 연결에서 변경이 발생하면 쿼리에 해당 변경 내용이 표시되는지 여부는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92abf58210ebaa6ec510b645429d6e91e6ca04d8" translate="yes" xml:space="preserve">
          <source>If changes occur on the same database connection after a query starts running but before the query completes, then the query might return a changed row more than once, or it might return a row that was previously deleted.</source>
          <target state="translated">쿼리 실행이 시작된 후 쿼리가 완료되기 전에 동일한 데이터베이스 연결에서 변경이 발생하면 쿼리는 변경된 행을 두 번 이상 반환하거나 이전에 삭제 된 행을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="437112dad4bafb7626f6351c41b7b34b2abfaca6" translate="yes" xml:space="preserve">
          <source>If changing into or out of WAL mode the procedure is more complicated.</source>
          <target state="translated">WAL 모드로 들어가거나 나가면 절차가 더 복잡해집니다.</target>
        </trans-unit>
        <trans-unit id="f754396c33d700ad2fd9dbdfe823fd9ae27672f4" translate="yes" xml:space="preserve">
          <source>If column names are explicitly provided for the FTS table as part of the CREATE VIRTUAL TABLE statement, then a datatype name may be optionally specified for each column. This is pure syntactic sugar, the supplied typenames are not used by FTS or the SQLite core for any purpose. The same applies to any constraints specified along with an FTS column name - they are parsed but not used or recorded by the system in any way.</source>
          <target state="translated">CREATE VIRTUAL TABLE 문의 일부로 FTS 테이블에 열 이름이 명시 적으로 제공되는 경우 각 열에 대해 데이터 유형 이름을 선택적으로 지정할 수 있습니다. 이것은 순수한 구문 설탕이며 제공된 유형 이름은 FTS 또는 SQLite 코어에서 어떤 목적으로도 사용되지 않습니다. FTS 열 이름과 함께 지정된 모든 제약 조건에도 동일하게 적용됩니다. 구문 분석은하지만 시스템에서 어떤 식 으로든 사용하거나 기록하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ec154d4b803f19da5aae8c26059349f5ffc0b8b" translate="yes" xml:space="preserve">
          <source>If conflict is with a remote UPDATE and the resolution is OMIT, then the old.* values are rebased using the new.* values in the remote change. Or, if the resolution is REPLACE, then the change is copied into the rebased changeset with updates to columns also updated by the conflicting remote UPDATE removed. If this means no columns would be updated, the change is omitted.</source>
          <target state="translated">충돌이 원격 UPDATE와 충돌하고 해상도가 OMIT 인 경우, old. * 값은 원격 변경의 new. * 값을 사용하여 리베이스됩니다. 또는 해결 방법이 REPLACE 인 경우 충돌하는 원격 UPDATE에 의해 업데이트 된 열에 대한 업데이트가 제거 된 상태에서 변경 사항이 rebased changeset에 복사됩니다. 이 경우 열이 업데이트되지 않으면 변경이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="eacad9fb0a3ce1ea1edfa735ab3f942dbf9e8cd8" translate="yes" xml:space="preserve">
          <source>If cursor P1 is an index, then the content is the key of the row. If cursor P2 is a table, then the content extracted is the data.</source>
          <target state="translated">커서 P1이 인덱스이면 내용이 행의 키입니다. 커서 P2가 테이블이면 추출 된 컨텐츠가 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="b0e0c624719d0c72631b398ea85cd293212feef6" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as a key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">커서 P1이 SQL 테이블 (정수 키를 사용하는 B- 트리)을 참조하는 경우 레지스터 P3의 값을 키로 사용하십시오. 커서 P1이 SQL 인덱스를 참조하면 P3은 압축 해제 된 인덱스 키로 사용되는 P4 레지스터 배열에서 첫 번째입니다.</target>
        </trans-unit>
        <trans-unit id="eed3ade81291c8b1e43812aa13b2f866776f9f36" translate="yes" xml:space="preserve">
          <source>If cursor P1 refers to an SQL table (B-Tree that uses integer keys), use the value in register P3 as the key. If cursor P1 refers to an SQL index, then P3 is the first in an array of P4 registers that are used as an unpacked index key.</source>
          <target state="translated">커서 P1이 SQL 테이블 (정수 키를 사용하는 B- 트리)을 참조하는 경우 레지스터 P3의 값을 키로 사용하십시오. 커서 P1이 SQL 인덱스를 참조하면 P3은 압축 해제 된 인덱스 키로 사용되는 P4 레지스터 배열에서 첫 번째입니다.</target>
        </trans-unit>
        <trans-unit id="b9a382b280888652763d650554446d773be05c07" translate="yes" xml:space="preserve">
          <source>If data is of type &lt;b&gt;text&lt;/b&gt; then the comparison is determined by the standard C data comparison functions &lt;b&gt;memcmp()&lt;/b&gt; or &lt;b&gt;strcmp()&lt;/b&gt;. The comparison looks at bytes from two inputs one by one and returns the first non-zero difference. Strings are '\000' terminated so shorter strings sort before longer strings, as you would expect.</source>
          <target state="translated">데이터가 &lt;b&gt;text&lt;/b&gt; 유형 인 경우 표준 C 데이터 비교 함수 &lt;b&gt;memcmp ()&lt;/b&gt; 또는 &lt;b&gt;strcmp ()에&lt;/b&gt; 의해 비교가 결정됩니다 . 비교는 두 입력의 바이트를 하나씩보고 0이 아닌 첫 번째 차이를 반환합니다. 문자열은 '\ 000'으로 끝나므로 짧은 문자열은 더 긴 문자열보다 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="0120d2592940874456695d5517c48510978290bc" translate="yes" xml:space="preserve">
          <source>If database zDb is the name of an attached database that is not in WAL mode, SQLITE_OK is returned and both *pnLog and *pnCkpt set to -1. If zDb is not NULL (or a zero length string) and is not the name of any attached database, SQLITE_ERROR is returned to the caller.</source>
          <target state="translated">데이터베이스 zDb가 WAL 모드가 아닌 접속 된 데이터베이스의 이름 인 경우 SQLITE_OK가 리턴되고 * pnLog 및 * pnCkpt가 -1로 설정됩니다. zDb가 NULL (또는 길이가 0 인 문자열)이 아니고 접속 된 데이터베이스의 이름이 아닌 경우 SQLITE_ERROR가 호출자에게 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ed9f3d01c8cb63f65cf1f8cb1ada863d801c5821" translate="yes" xml:space="preserve">
          <source>If defined, support for sub-selects and the IN() operator are omitted.</source>
          <target state="translated">정의 된 경우 하위 선택 및 IN () 연산자에 대한 지원은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="5f4710e921e7c9706b1a7d0affff80c102083b4a" translate="yes" xml:space="preserve">
          <source>If desired, you can verify the new database by running this command:</source>
          <target state="translated">원하는 경우 다음 명령을 실행하여 새 데이터베이스를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0b0b6a44b8709f88072f86b2bad9194c580b896" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is 0 (false) then the result is 0 even if the other input is NULL. A NULL and true or two NULLs give a NULL output.</source>
          <target state="translated">P1 또는 P2가 0 (거짓)이면 다른 입력이 NULL 인 경우에도 결과는 0입니다. NULL 및 true 또는 두 개의 NULL은 NULL 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0c5f4e14888f22c44de9608417d3500cbb09c876" translate="yes" xml:space="preserve">
          <source>If either P1 or P2 is nonzero (true) then the result is 1 (true) even if the other input is NULL. A NULL and false or two NULLs give a NULL output.</source>
          <target state="translated">P1 또는 P2가 0이 아닌 경우 (true) 다른 입력이 NULL 인 경우에도 결과는 1입니다 (true). NULL 및 false 또는 두 개의 NULL은 NULL 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f718f36fc0872a36f2f90015ef098011701953fd" translate="yes" xml:space="preserve">
          <source>If either P3 or the sorter contains a NULL in one of their significant fields (not counting the P4 fields at the end which are ignored) then the comparison is assumed to be equal.</source>
          <target state="translated">P3 또는 정렬 기가 중요한 필드 중 하나에 NULL을 포함하는 경우 (끝의 P4 필드는 무시되지 않음) 비교는 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="cb70cc2d7081446ae1bd92c809ed77dcb6489c40" translate="yes" xml:space="preserve">
          <source>If either X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; or X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; are non-numeric, then the boundary is the first row for which the expression &quot;X&lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X&lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt;&quot; is true.</source>
          <target state="translated">X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; 또는 X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; 가 숫자가 아닌 경우 경계는 표현식 &quot;X &lt;sub&gt;&lt;small&gt;i&lt;/small&gt;&lt;/sub&gt; IS X &lt;sub&gt;&lt;small&gt;c&lt;/small&gt;&lt;/sub&gt; &quot;가 참인 첫 번째 행입니다 .</target>
        </trans-unit>
        <trans-unit id="40afda50342c1866ef5c9245fe131f4faa8b196a" translate="yes" xml:space="preserve">
          <source>If either operand has an explicit collating function assignment using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the explicit collating function is used for comparison, with precedence to the collating function of the left operand.</source>
          <target state="translated">두 피연산자에 postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 를 사용하여 명시 적 조합 함수가 지정된 경우, 명시 적 조합 함수가 왼쪽 피연산자의 조합 함수보다 우선하여 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="55672cdef058eed493a94d268600f0dc4cf6e695" translate="yes" xml:space="preserve">
          <source>If either operand is a column, then the collating function of that column is used with precedence to the left operand. For the purposes of the previous sentence, a column name preceded by one or more unary &quot;+&quot; operators and/or CAST operators is still considered a column name.</source>
          <target state="translated">피연산자 중 하나가 열인 경우 해당 열의 조합 함수가 왼쪽 피연산자에 우선하여 사용됩니다. 이전 문장의 목적을 위해 열 이름 앞에는 하나 이상의 단항 &quot;+&quot;연산자 및 / 또는 CAST 연산자가 여전히 열 이름으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c6ebcbeab69b86f653a3410afabe08a544dcaea8" translate="yes" xml:space="preserve">
          <source>If either the current value or the highwater mark is too large to be represented by a 32-bit integer, then the values returned by sqlite3_status() are undefined.</source>
          <target state="translated">현재 값 또는 상위 워터 마크가 너무 커서 32 비트 정수로 표시 할 수없는 경우 sqlite3_status ()에 의해 리턴되는 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10b7374ac7ffa60e3b709049b312d9aea49ec9de" translate="yes" xml:space="preserve">
          <source>If file-locking is enabled (it is enabled by default), then connections from multiple processes may also read and write the database file. However concurrency is reduced as follows:</source>
          <target state="translated">파일 잠금이 활성화 된 경우 (기본적으로 활성화되어 있음) 여러 프로세스의 연결에서 데이터베이스 파일을 읽고 쓸 수도 있습니다. 그러나 동시성은 다음과 같이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="d3ef8fd536a105baf87d357ae62955ed380fa9cf" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled when it is prepared, the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; command performs an implicit &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; to remove all rows from the table before dropping it. The implicit DELETE does not cause any SQL triggers to fire, but may invoke foreign key actions or constraint violations. If an immediate foreign key constraint is violated, the DROP TABLE statement fails and the table is not dropped. If a deferred foreign key constraint is violated, then an error is reported when the user attempts to commit the transaction if the foreign key constraint violations still exist at that point. Any &quot;foreign key mismatch&quot; errors encountered as part of an implicit DELETE are ignored.</source>
          <target state="translated">외래 키 제한 조건이 준비 될 때 사용 가능하면 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령은 내재적 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 를 수행 하여 테이블에서 모든 행을 삭제하기 전에 테이블에서 삭제합니다. 암시 적 DELETE는 SQL 트리거를 발생시키지 않지만 외래 키 동작 또는 제약 조건 위반을 호출 할 수 있습니다. 즉시 외래 키 제약 조건을 위반하면 DROP TABLE 문이 실패하고 테이블이 삭제되지 않습니다. 지연된 외래 키 제약 조건을 위반하면 해당 시점에 외래 키 제약 조건 위반이 여전히 존재하는 경우 사용자가 트랜잭션을 커밋하려고 시도 할 때 오류가보고됩니다. 암시 적 DELETE의 일부로 발생한 &quot;외부 키 불일치&quot;오류는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4f44f3a8f93f85a791245b413bb9ad1095b808f6" translate="yes" xml:space="preserve">
          <source>If foreign key constraints are enabled, disable them using &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;.</source>
          <target state="translated">외래 키 제약 조건이 활성화 된 경우 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = OFF를&lt;/a&gt; 사용하여 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1eb421ae6f8eb8b7414f3ba7bf623bab8ed0c1" translate="yes" xml:space="preserve">
          <source>If foreign key constraints were originally enabled then run &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; to verify that the schema change did not break any foreign key constraints.</source>
          <target state="translated">외래 키 제약 조건이 원래 활성화 된 경우 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 를 실행 하여 스키마 변경으로 외래 키 제약 조건이 깨지지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="c13741cd4626e3d89fe66c4aae10d469f36c6a45" translate="yes" xml:space="preserve">
          <source>If foreign key handling is enabled, and applying a changeset leaves the database in a state containing foreign key violations, the conflict handler is invoked with CHANGESET_FOREIGN_KEY as the second argument exactly once before the changeset is committed. If the conflict handler returns CHANGESET_OMIT, the changes, including those that caused the foreign key constraint violation, are committed. Or, if it returns CHANGESET_ABORT, the changeset is rolled back.</source>
          <target state="translated">외래 키 처리가 활성화되어 있고 변경 세트를 적용하면 데이터베이스가 외래 키 위반이 포함 된 상태로 유지되는 경우 변경 세트가 커밋되기 직전에 CHANGESET_FOREIGN_KEY를 두 번째 인수로 충돌 핸들러가 호출됩니다. 충돌 처리기가 CHANGESET_OMIT를 반환하면 외래 키 제약 조건 위반의 원인을 포함하여 변경 내용이 커밋됩니다. 또는 CHANGESET_ABORT를 반환하면 변경 집합이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="664ed429f3e8a71469131f1cf927d67cea7224ef" translate="yes" xml:space="preserve">
          <source>If foreign keys constraints were originally enabled, reenable them now.</source>
          <target state="translated">외래 키 제약 조건이 원래 활성화 된 경우 지금 다시 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="ae0d6d454ce848e119fe19c9d3921a6301be3ccd" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 아직 첨부되지 않은 경우이 함수는 &lt;a href=&quot;#sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; 함수 와 동일한 방식으로 테이블 zTbl을 첨부합니다 . zTbl이 없거나 기본 키가없는 경우이 기능은 작동하지 않습니다 (그러나 오류를 리턴하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="b18e9847f65d260e65a6581d1c54f05d17b07506" translate="yes" xml:space="preserve">
          <source>If it is not already attached to the session object passed as the first argument, this function attaches table zTbl in the same manner as the &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; function. If zTbl does not exist, or if it does not have a primary key, this function is a no-op (but does not return an error).</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 아직 첨부되지 않은 경우이 함수는 &lt;a href=&quot;sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; 함수 와 동일한 방식으로 테이블 zTbl을 첨부합니다 . zTbl이 없거나 기본 키가없는 경우이 기능은 작동하지 않습니다 (그러나 오류를 리턴하지는 않습니다).</target>
        </trans-unit>
        <trans-unit id="a8c1f9f82d9d1138df42ada4c0e8d4ac1b13017c" translate="yes" xml:space="preserve">
          <source>If many threads and/or processes need to write the database at the same instant (and they cannot queue up and take turns) then it is best to select a database engine that supports that capability, which always means a client/server database engine.</source>
          <target state="translated">많은 스레드 및 / 또는 프로세스가 같은 순간에 데이터베이스를 작성해야하는 경우 (대기열 및 전환을 수행 할 수없는 경우) 해당 기능을 지원하는 데이터베이스 엔진을 선택하는 것이 가장 좋습니다. 이는 항상 클라이언트 / 서버 데이터베이스 엔진을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="277d800367bb442a2e4d79fba0d9ab386719bb03" translate="yes" xml:space="preserve">
          <source>If mmap_size is set to N then all current implementations map the first N bytes of the database file and use legacy xRead() calls for any content beyond N bytes. If the database file is smaller than N bytes, then the entire file is mapped. In the future, new OS interfaces could, in theory, map regions of the file other than the first N bytes, but no such implementation currently exists.</source>
          <target state="translated">mmap_size가 N으로 설정되면 모든 현재 구현은 데이터베이스 파일의 첫 번째 N 바이트를 맵핑하고 N 바이트 이상의 컨텐츠에 대해 레거시 xRead () 호출을 사용합니다. 데이터베이스 파일이 N 바이트보다 작은 경우 전체 파일이 맵핑됩니다. 앞으로 새로운 OS 인터페이스는 이론상 처음 N 바이트 이외의 파일 영역을 매핑 할 수 있지만 현재는 그러한 구현이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44cd764c270354ba3be43d380aabce5d77a1bc54" translate="yes" xml:space="preserve">
          <source>If more than one such fragment can be found, then fragments that contain a larger number of &quot;extra&quot; phrase matches are favored. The start of the selected text fragment may be moved a few tokens forward or backward to attempt to concentrate the phrase matches toward the center of the fragment.</source>
          <target state="translated">하나 이상의 그러한 단편이 발견 될 경우, 더 많은 수의 &quot;추가&quot;문구 일치를 포함하는 단편이 선호된다. 선택된 텍스트 프래그먼트의 시작은 프래그먼트의 중심을 향해 구문 일치를 집중 시키려고 몇 개의 토큰을 앞뒤로 움직일 수있다.</target>
        </trans-unit>
        <trans-unit id="26cb5f0f4343465953038f56daf635f7d45d2d33" translate="yes" xml:space="preserve">
          <source>If multi-threaded processing is enabled via the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; setting, then sort operations will attempt to start helper threads when the amount of content to be sorted exceeds the minimum of the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; and PMA Size determined by the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. This compile-time option sets the default value for the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option. The default value is 250.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA 스레드&lt;/a&gt; 설정을 통해 다중 스레드 처리를 사용하는 경우 정렬 할 컨텐츠의 양이 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; 시작 시간 옵션에 의해 결정된 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; 및 PMA 크기 의 최소값을 초과하면 정렬 조작이 헬퍼 스레드를 시작하려고 시도합니다 . 이 컴파일 시간 옵션은 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; 시작 시간 옵션 의 기본값을 설정합니다 . 기본값은 250입니다.</target>
        </trans-unit>
        <trans-unit id="180acf91f65a788cf692bf4d0ecd25eb3f41224e" translate="yes" xml:space="preserve">
          <source>If multiple commands are being executed against the same SQLite database connection at the same time, the autocommit is deferred until the very last command completes. For example, if a SELECT statement is being executed, the execution of the command will pause as each row of the result is returned. During this pause other INSERT, UPDATE, or DELETE commands can be executed against other tables in the database. But none of these changes will commit until the original SELECT statement finishes.</source>
          <target state="translated">동일한 SQLite 데이터베이스 연결에 대해 여러 명령을 동시에 실행중인 경우 마지막 명령이 완료 될 때까지 자동 커밋이 연기됩니다. 예를 들어, SELECT 문이 실행중인 경우 결과의 각 행이 리턴 될 때 명령 실행이 일시 정지됩니다. 이 일시 정지 중에 데이터베이스의 다른 테이블에 대해 다른 INSERT, UPDATE 또는 DELETE 명령을 실행할 수 있습니다. 그러나 원래 SELECT 문이 완료 될 때까지 이러한 변경 사항은 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02760b51331cbab337a4b4abdc9926115fb4b89f" translate="yes" xml:space="preserve">
          <source>If neither of these two query strategies can be used, all queries on FTS tables are implemented using a linear scan of the entire table. If the table contains large amounts of data, this may be an impractical approach (the first example on this page shows that a linear scan of 1.5 GB of data takes around 30 seconds using a modern PC).</source>
          <target state="translated">이 두 가지 쿼리 전략 중 어느 것도 사용할 수없는 경우 FTS 테이블의 모든 쿼리는 전체 테이블의 선형 스캔을 사용하여 구현됩니다. 테이블에 많은 양의 데이터가 포함 된 경우 이는 실용적이지 않을 수 있습니다 (이 페이지의 첫 번째 예는 최신 PC를 사용하여 1.5GB의 데이터를 선형 스캔하는 데 약 30 초가 걸린다는 것을 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="46d15914a8966b2144fb307d96a3896b83eea8f4" translate="yes" xml:space="preserve">
          <source>If no</source>
          <target state="translated">그렇지 않다면</target>
        </trans-unit>
        <trans-unit id="d80775017369d9f582b22c2b8463af70c053cb1a" translate="yes" xml:space="preserve">
          <source>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. If the largest ROWID is equal to the largest possible integer (9223372036854775807) then the database engine starts picking positive candidate ROWIDs at random until it finds one that is not previously used. If no unused ROWID can be found after a reasonable number of attempts, the insert operation fails with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. If no negative ROWID values are inserted explicitly, then automatically generated ROWID values will always be greater than zero.</source>
          <target state="translated">삽입에 ROWID가 지정되지 않았거나 지정된 ROWID의 값이 NULL이면 적절한 ROWID가 자동으로 작성됩니다. 일반적인 알고리즘은 새로 생성 된 행에 삽입 전에 테이블에서 가장 큰 ROWID보다 큰 ROWID를 제공하는 것입니다. 테이블이 처음에 비어 있으면 ROWID 1이 사용됩니다. 가장 큰 ROWID가 가능한 가장 큰 정수 (9223372036854775807)와 같으면 데이터베이스 엔진은 이전에 사용되지 않은 것을 찾을 때까지 긍정적 인 후보 ROWID를 임의로 선택하기 시작합니다. 적당한 횟수의 시도 후에 사용되지 않은 ROWID를 찾을 수 없으면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 와 함께 삽입 조작이 실패합니다 . 음의 ROWID 값이 명시 적으로 삽입되지 않으면 자동으로 생성 된 ROWID 값은 항상 0보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="e2deadd7a9c793e3167a0e629e8b9b96ff70f176" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned.</source>
          <target state="translated">오류가 발생하지 않으면 SQLITE_OK가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="8e5398b47308ea9ae66110e9bb05403692680696" translate="yes" xml:space="preserve">
          <source>If no error occurs, SQLITE_OK is returned. If an error does occur, an SQLite error code is returned. The values of the output variables may not be trusted in this case.</source>
          <target state="translated">오류가 발생하지 않으면 SQLITE_OK가 리턴됩니다. 오류가 발생하면 SQLite 오류 코드가 리턴됩니다. 이 경우 출력 변수의 값을 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8dd386d2569bc5457aac9dba2010126d7a04d7d" translate="yes" xml:space="preserve">
          <source>If no master journal is involved, then a journal is hot if it exists and has a non-zero header and its corresponding database file does not have a RESERVED lock. If a master journal is named in the file journal, then the file journal is hot if its master journal exists and there is no RESERVED lock on the corresponding database file. It is important to understand when a journal is hot so the preceding rules will be repeated in bullets:</source>
          <target state="translated">마스터 저널이 포함되지 않은 경우 저널이 존재하고 0이 아닌 헤더가 있고 해당 데이터베이스 파일에 RESERVED 잠금이 없으면 저널이 뜨겁습니다. 마스터 저널이 파일 저널에 이름이 지정된 경우 마스터 저널이 있고 해당 데이터베이스 파일에 예약 된 잠금이 없으면 파일 저널이 뜨겁습니다. 저널이 뜨거울 때이를 이해하여 앞의 규칙이 글 머리 기호로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="e9ec2ab3e066aabbb424ce10a035adf5f5270552" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">기본 키 값과 일치하는 행이 데이터베이스에 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;없으면&lt;/a&gt; 충돌 핸들러 함수가 두 번째 인수로 전달 된 SQLITE_CHANGESET_NOTFOUND 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="532395f09f545a6e9963ddaa843af136eeb8913b" translate="yes" xml:space="preserve">
          <source>If no row with matching primary key values is found in the database, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_NOTFOUND&lt;/a&gt; passed as the second argument.</source>
          <target state="translated">기본 키 값과 일치하는 행이 데이터베이스에 &lt;a href=&quot;c_changeset_conflict&quot;&gt;없으면&lt;/a&gt; 충돌 핸들러 함수가 두 번째 인수로 전달 된 SQLITE_CHANGESET_NOTFOUND 와 함께 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="5795a39454965fb21426bc7bb9e2147672f5e177" translate="yes" xml:space="preserve">
          <source>If none of the strings above occur anywhere in the type declaration, then the datatype is numeric. Note in particular that the datatype for columns with an empty type declaration is numeric.</source>
          <target state="translated">위의 문자열 중 어느 것도 형식 선언의 어느 곳에서도 발생하지 않으면 데이터 형식은 숫자입니다. 특히 빈 형식 선언이있는 열의 데이터 형식은 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="5b0f610d4827d05770d8c3809730eca324b8d352" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. Blob의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcc2dad992498753f10de4ee979d37a3e30daa67" translate="yes" xml:space="preserve">
          <source>If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. If N or iOffset is less than zero, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is read. The size of the blob (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface.</source>
          <target state="translated">BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터를 읽지 않습니다. Blob의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e41507fc7f4f5f8ed7f1f9f86f50446d711b557" translate="yes" xml:space="preserve">
          <source>If one operand has INTEGER, REAL or NUMERIC affinity and the other operand has TEXT or BLOB or no affinity then NUMERIC affinity is applied to other operand.</source>
          <target state="translated">한 피연산자에 INTEGER, REAL 또는 NUMERIC 선호도가 있고 다른 피연산자가 TEXT 또는 BLOB이거나 선호도가없는 경우 NUMERIC 선호도가 다른 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="316990fa091894331a5bfab80d20b7d7b8a1b17a" translate="yes" xml:space="preserve">
          <source>If one operand has TEXT affinity and the other has no affinity, then TEXT affinity is applied to the other operand.</source>
          <target state="translated">한 피연산자가 TEXT 선호도를 갖고 다른 피연산자가 선호도를 가지지 않으면 TEXT 선호도가 다른 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a746052c71f7cca567e925f8568ed0089126b0e" translate="yes" xml:space="preserve">
          <source>If one or more of the column values in the row inserted by the new change differ from those in the row deleted by the existing change, the existing DELETE is replaced by an UPDATE within the changegroup. Otherwise, if the inserted row is exactly the same as the deleted row, the existing DELETE is simply discarded.</source>
          <target state="translated">새 변경에 의해 삽입 된 행의 하나 이상의 열 값이 기존 변경에 의해 삭제 된 행의 열 값과 다른 경우 기존 DELETE는 변경 그룹 내의 UPDATE로 바뀝니다. 그렇지 않으면, 삽입 된 행이 삭제 된 행과 정확히 동일한 경우 기존 DELETE는 단순히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb903a0b2fa794db9f8ce5d76be92c6e8ad13da" translate="yes" xml:space="preserve">
          <source>If ownership of the pointer is passed into SQLite by providing a non-NULL D parameter to &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; or &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; then the ownership remains with SQLite until the object is destroyed. There is no way to transfer ownership out of SQLite and back into the application again.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; NULL이 아닌 D 매개 변수를 제공하여 포인터 소유권이 SQLite로 전달 되면 소유권이 개체가 손상 될 때까지 SQLite로 유지됩니다. 소유권을 SQLite에서 다시 애플리케이션으로 다시 전송할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8503abe821374258f98c6ba5585311ca76bf6ece" translate="yes" xml:space="preserve">
          <source>If page 1 data is read as required by H35230, then the value of the</source>
          <target state="translated">H35230에서 요구하는대로 1 페이지 데이터를 읽는 경우</target>
        </trans-unit>
        <trans-unit id="017b230392006407b67880da521173469a1b31d0" translate="yes" xml:space="preserve">
          <source>If parameter iCol is greater than or equal to the number of columns in the table, SQLITE_RANGE is returned. Or, if an error occurs (e.g. an OOM condition or IO error), an appropriate SQLite error code is returned.</source>
          <target state="translated">iCol 매개 변수가 테이블의 열 수보다 크거나 같으면 SQLITE_RANGE가 리턴됩니다. 또는 오류 (예 : OOM 조건 또는 IO 오류)가 발생하면 적절한 SQLite 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c373aca4c319795b45d2c1f0dc2245e638666f60" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the FTS5 table. Or, if iCol is non-negative but less than the number of columns in the table, return the total number of tokens in column iCol, considering all rows in the FTS5 table.</source>
          <target state="translated">iCol 매개 변수가 0보다 작은 경우 출력 변수 * pnToken을 FTS5 테이블의 총 토큰 수로 설정하십시오. 또는 iCol이 음수가 아니지만 테이블의 열 수보다 적은 경우 FTS5 테이블의 모든 행을 고려하여 iCol 열의 총 토큰 수를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="686ce79e8e629eea956f529880e81a4b9a406c30" translate="yes" xml:space="preserve">
          <source>If parameter iCol is less than zero, set output variable *pnToken to the total number of tokens in the current row. Or, if iCol is non-negative but less than the number of columns in the table, set *pnToken to the number of tokens in column iCol of the current row.</source>
          <target state="translated">iCol 매개 변수가 0보다 작은 경우 출력 변수 * pnToken을 현재 행의 총 토큰 수로 설정하십시오. 또는 iCol이 음수가 아니지만 테이블의 열 수보다 적은 경우 * pnToken을 현재 행의 열 iCol에있는 토큰 수로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="88577f66da407130b6c2fbcee7dc6e283e2a74d7" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;../lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">ZDB는 NULL 또는 0 길이 문자열 점이다 매개 변수 다음 지정된 작업은 모든 WAL 데이터베이스에 시도하면 &lt;a href=&quot;../lang_attach&quot;&gt;연결&lt;/a&gt; 에 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; dB. 이 경우 출력 매개 변수 * pnLog 및 * pnCkpt에 기록 된 값은 정의되지 않습니다. 하나 이상의 연결된 WAL 데이터베이스를 처리 할 때 SQLITE_BUSY 오류가 발생하면 나머지 연결된 데이터베이스에서 작업이 계속 시도되고 끝에 SQLITE_BUSY가 반환됩니다. 연결된 데이터베이스를 처리하는 동안 다른 오류가 발생하면 처리가 중단되고 오류 코드가 즉시 호출자에게 반환됩니다. 연결된 데이터베이스를 처리하는 동안 오류 (SQLITE_BUSY 또는 기타)가 발생하지 않으면 SQLITE_OK가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="83e25a419f885754ebe2acacb05d4faa8a67cc7b" translate="yes" xml:space="preserve">
          <source>If parameter zDb is NULL or points to a zero length string, then the specified operation is attempted on all WAL databases &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; to &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; db. In this case the values written to output parameters *pnLog and *pnCkpt are undefined. If an SQLITE_BUSY error is encountered when processing one or more of the attached WAL databases, the operation is still attempted on any remaining attached databases and SQLITE_BUSY is returned at the end. If any other error occurs while processing an attached database, processing is abandoned and the error code is returned to the caller immediately. If no error (SQLITE_BUSY or otherwise) is encountered while processing the attached databases, SQLITE_OK is returned.</source>
          <target state="translated">ZDB는 NULL 또는 0 길이 문자열 점이다 매개 변수 다음 지정된 작업은 모든 WAL 데이터베이스에 시도하면 &lt;a href=&quot;lang_attach&quot;&gt;연결&lt;/a&gt; 에 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; dB. 이 경우 출력 매개 변수 * pnLog 및 * pnCkpt에 기록 된 값은 정의되지 않습니다. 하나 이상의 연결된 WAL 데이터베이스를 처리 할 때 SQLITE_BUSY 오류가 발생하면 나머지 연결된 데이터베이스에서 작업이 계속 시도되고 끝에 SQLITE_BUSY가 반환됩니다. 연결된 데이터베이스를 처리하는 동안 다른 오류가 발생하면 처리가 중단되고 오류 코드가 즉시 호출자에게 반환됩니다. 연결된 데이터베이스를 처리하는 동안 오류 (SQLITE_BUSY 또는 기타)가 발생하지 않으면 SQLITE_OK가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d5e79777c8fc72c43d9863555c6ca53f645883e2" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">pnLog가 NULL이 아닌 경우, * pnLog는 로그 파일의 총 프레임 수로 설정되거나 오류로 인해 또는 데이터베이스가 &lt;a href=&quot;../wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않아 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다 . pnCkpt가 NULL이 아닌 경우 * pnCkpt는 로그 파일에서 체크 포인트 된 총 프레임 수 (함수가 호출되기 전에 이미 체크 포인트 된 프레임 포함)로 설정되거나 오류로 인해 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다. 데이터베이스가 WAL 모드가 아니기 때문입니다. SQLITE_CHECKPOINT_TRUNCATE를 성공적으로 완료하면 로그 파일이 0 바이트로 잘 리므로 * pnLog 및 * pnCkpt는 모두 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d64232e8314def054a53cca48179ce0748631809" translate="yes" xml:space="preserve">
          <source>If pnLog is not NULL, then *pnLog is set to the total number of frames in the log file or to -1 if the checkpoint could not run because of an error or because the database is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If pnCkpt is not NULL,then *pnCkpt is set to the total number of checkpointed frames in the log file (including any that were already checkpointed before the function was called) or to -1 if the checkpoint could not run due to an error or because the database is not in WAL mode. Note that upon successful completion of an SQLITE_CHECKPOINT_TRUNCATE, the log file will have been truncated to zero bytes and so both *pnLog and *pnCkpt will be set to zero.</source>
          <target state="translated">pnLog가 NULL이 아닌 경우, * pnLog는 로그 파일의 총 프레임 수로 설정되거나 오류로 인해 또는 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않아 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다 . pnCkpt가 NULL이 아닌 경우 * pnCkpt는 로그 파일에서 체크 포인트 된 총 프레임 수 (함수가 호출되기 전에 이미 체크 포인트 된 프레임 포함)로 설정되거나 오류로 인해 체크 포인트를 실행할 수없는 경우 -1로 설정됩니다. 데이터베이스가 WAL 모드가 아니기 때문입니다. SQLITE_CHECKPOINT_TRUNCATE를 성공적으로 완료하면 로그 파일이 0 바이트로 잘 리므로 * pnLog 및 * pnCkpt는 모두 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="41dd1bdb1c62f1c1fa9eb1f2a9f608c75f290fb8" translate="yes" xml:space="preserve">
          <source>If present, output a more verbose report for each query analyzed.</source>
          <target state="translated">있는 경우 분석 된 각 쿼리에 대해 더 자세한 보고서를 출력하십시오.</target>
        </trans-unit>
        <trans-unit id="dfd446567083de1e9ebdea0d18573182ac68033b" translate="yes" xml:space="preserve">
          <source>If pzTail is not NULL then *pzTail is made to point to the first byte past the end of the first SQL statement in zSql. These routines only compile the first statement in zSql, so *pzTail is left pointing to what remains uncompiled.</source>
          <target state="translated">pzTail이 NULL이 아닌 경우 * pzTail은 zSql의 첫 번째 SQL 문 끝을지나 첫 번째 바이트를 가리 키도록합니다. 이 루틴은 zSql의 첫 번째 명령문 만 컴파일하므로 * pzTail은 컴파일되지 않은 상태를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="daeeadf12f9cfe6f720cf3d4bdd4fb456397cc60" translate="yes" xml:space="preserve">
          <source>If r[P3] is zero or negative, that means there is no OFFSET and r[P2] is set to be the value of the LIMIT, r[P1].</source>
          <target state="translated">r [P3]이 0 또는 음수 인 경우, 이는 OFFSET이없고 r [P2]가 LIMIT, r [P1]의 값으로 설정되어 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6c50ebdc1c9d5314285662a0bf55da3e625fe7b5" translate="yes" xml:space="preserve">
          <source>If register P1 holds an integer convert it to a real value.</source>
          <target state="translated">레지스터 P1에 정수가 있으면 실수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="24add31372893a82dd86705b4a5c1cbba71ea8ec" translate="yes" xml:space="preserve">
          <source>If required to truncate a database page from the end of the database file, the associated</source>
          <target state="translated">데이터베이스 파일의 끝에서 데이터베이스 페이지를 잘라야하는 경우</target>
        </trans-unit>
        <trans-unit id="3939be1758da993faac1647e5a0238d1c34fd401" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">&lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 실행중인 경우 애플리케이션은 백업이 실행되는 동안 대상 데이터베이스가 사용하는 공유 캐시에 액세스하지 않도록해야합니다. 실제로 이것은 응용 프로그램이 백업중인 디스크 파일이 sqlite3_backup_init ()에 전달 된 특정 연결뿐만 아니라 프로세스 내의 모든 연결에 의해 액세스되지 않도록 보장해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="91671997be6a1d6d67488b4259ddff989b286fc6" translate="yes" xml:space="preserve">
          <source>If running in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, the application must guarantee that the shared cache used by the destination database is not accessed while the backup is running. In practice this means that the application must guarantee that the disk file being backed up to is not accessed by any connection within the process, not just the specific connection that was passed to sqlite3_backup_init().</source>
          <target state="translated">&lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 실행중인 경우 애플리케이션은 백업이 실행되는 동안 대상 데이터베이스가 사용하는 공유 캐시에 액세스하지 않도록해야합니다. 실제로 이것은 응용 프로그램이 백업중인 디스크 파일이 sqlite3_backup_init ()에 전달 된 특정 연결뿐만 아니라 프로세스 내의 모든 연결에 의해 액세스되지 않도록 보장해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="813ffbbe7a10f587c30164e3c760a93f923869e0" translate="yes" xml:space="preserve">
          <source>If set to 1, then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE. If omitted or set to 0 then the default &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is NORMAL.</source>
          <target state="translated">1로 설정하면 기본 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; 가 EXCLUSIVE로 설정됩니다. 생략하거나 0으로 설정하면 기본 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; 는 NORMAL입니다.</target>
        </trans-unit>
        <trans-unit id="8dd726c58400329230cb7ffbb590015b7fc272ad" translate="yes" xml:space="preserve">
          <source>If single-thread mode has not been selected at compile-time or start-time, then individual database connections can be created as either multi-thread or serialized. It is not possible to downgrade an individual database connection to single-thread mode. Nor is it possible to escalate an individual database connection if the compile-time or start-time mode is single-thread.</source>
          <target state="translated">컴파일 타임 또는 시작시 단일 스레드 모드를 선택하지 않은 경우 개별 데이터베이스 연결을 다중 스레드 또는 직렬화로 작성할 수 있습니다. 개별 데이터베이스 연결을 단일 스레드 모드로 다운 그레이드 할 수 없습니다. 컴파일 타임 또는 시작 타임 모드가 단일 스레드 인 경우 개별 데이터베이스 연결을 에스컬레이션 할 수도 없습니다.</target>
        </trans-unit>
        <trans-unit id="297fbafe0f12618a3892916307ed5e193747b9f8" translate="yes" xml:space="preserve">
          <source>If single-thread mode is selected at compile-time, then critical mutexing logic is omitted from the build and it is impossible to enable either multi-thread or serialized modes at start-time or run-time.</source>
          <target state="translated">컴파일 타임에 단일 스레드 모드를 선택하면 빌드에서 중요한 뮤팅 논리가 생략되고 시작 시간 또는 런타임에 멀티 스레드 또는 직렬 모드를 활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc15b1addaaecdb30cb643e4374238a5f983835b" translate="yes" xml:space="preserve">
          <source>If some future version of SQLite adds new ALTER TABLE capabilities, those capabilities will very likely use one of the two procedures outlined above.</source>
          <target state="translated">향후 버전의 SQLite에 새로운 ALTER TABLE 기능이 추가되면 해당 기능은 위에서 설명한 두 절차 중 하나를 사용할 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="a247ea4cd25be5ebc1e3446b36da4e3d6e48aaf1" translate="yes" xml:space="preserve">
          <source>If some other error occurs (e.g. an OOM condition), an SQLite error code is returned and *ppValue is set to NULL.</source>
          <target state="translated">다른 오류 (예 : OOM 조건)가 발생하면 SQLite 오류 코드가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e277177a9a5ad8b0a8ae8ddf4692ab5b1cd48938" translate="yes" xml:space="preserve">
          <source>If specified, interpret all relative paths as relative to DIR, instead of the current working directory.</source>
          <target state="translated">지정된 경우, 모든 작업 경로를 현재 작업 디렉토리 대신 DIR을 기준으로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="c10bbb5923a9a453a504ada2ef95db3b448455c2" translate="yes" xml:space="preserve">
          <source>If specified, use file FILE as the archive. Otherwise, assume that the current &quot;main&quot; database is the archive to be operated on.</source>
          <target state="translated">지정된 경우 FILE 파일을 아카이브로 사용하십시오. 그렇지 않으면 현재 &quot;기본&quot;데이터베이스가 작동 할 아카이브라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="781f0c1e44a6d5e4cbc382e01b2a73157527db47" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">sqlite3_backup_step ()이 필요한 파일 시스템 잠금을 확보 할 수 없으면 사용 &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;중 핸들러 기능&lt;/a&gt; 이 호출됩니다 (지정된 경우). 잠금이 사용 가능하기 전에 통화 중 핸들러가 0이 아닌 값을 리턴하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 호출자에게 리턴됩니다. 이 경우 나중에 sqlite3_backup_step ()에 대한 호출을 재 시도 할 수 있습니다. sqlite3_backup_step ()이 호출 될 때 소스 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 사용하여 소스 데이터베이스에 쓰는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;중이면 SQLITE_LOCKED&lt;/a&gt; 가 즉시 리턴됩니다. 이 경우에도 sqlite3_backup_step ()에 대한 호출은 나중에 다시 시도 할 수 있습니다. 만약 &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;이 반환되면 sqlite3_backup_step ()에 대한 호출을 다시 시도 할 필요가 없습니다. 이러한 오류는 치명적인 것으로 간주됩니다. 애플리케이션은 백업 조작이 실패했음을 승인하고 백업 조작 핸들을 sqlite3_backup_finish ()에 전달하여 연관된 자원을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="97664464d7946d7d0d5f82dbee0724dc2319f847" translate="yes" xml:space="preserve">
          <source>If sqlite3_backup_step() cannot obtain a required file-system lock, then the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler function&lt;/a&gt; is invoked (if one is specified). If the busy-handler returns non-zero before the lock is available, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned to the caller. In this case the call to sqlite3_backup_step() can be retried later. If the source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used to write to the source database when sqlite3_backup_step() is called, then &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; is returned immediately. Again, in this case the call to sqlite3_backup_step() can be retried later on. If &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt;, &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;, or &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; is returned, then there is no point in retrying the call to sqlite3_backup_step(). These errors are considered fatal. The application must accept that the backup operation has failed and pass the backup operation handle to the sqlite3_backup_finish() to release associated resources.</source>
          <target state="translated">sqlite3_backup_step ()이 필요한 파일 시스템 잠금을 확보 할 수 없으면 사용 &lt;a href=&quot;busy_handler&quot;&gt;중 핸들러 기능&lt;/a&gt; 이 호출됩니다 (지정된 경우). 잠금이 사용 가능하기 전에 통화 중 핸들러가 0이 아닌 값을 리턴하면 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 호출자에게 리턴됩니다. 이 경우 나중에 sqlite3_backup_step ()에 대한 호출을 재 시도 할 수 있습니다. sqlite3_backup_step ()이 호출 될 때 소스 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 사용하여 소스 데이터베이스에 쓰는 &lt;a href=&quot;../rescode#locked&quot;&gt;중이면 SQLITE_LOCKED&lt;/a&gt; 가 즉시 리턴됩니다. 이 경우에도 sqlite3_backup_step ()에 대한 호출은 나중에 다시 시도 할 수 있습니다. 만약 &lt;a href=&quot;../rescode#ioerr_access&quot;&gt;SQLITE_IOERR_XXX&lt;/a&gt; , &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; , 또는 &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;이 반환되면 sqlite3_backup_step ()에 대한 호출을 다시 시도 할 필요가 없습니다. 이러한 오류는 치명적인 것으로 간주됩니다. 애플리케이션은 백업 조작이 실패했음을 승인하고 백업 조작 핸들을 sqlite3_backup_finish ()에 전달하여 연관된 자원을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="416d4d371ff0cd3598d43dc30a0639c13aed646a" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">sqlite3_deserialize (D, S, P, N, M, F)가 어떤 이유로 인해 실패하고 SQLITE_DESERIALIZE_FREEONCLOSE 비트가 인수 F에 설정된 경우 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 리턴하기 전에 인수 P에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cec31d664476098d45397cb4e64acc667d8c0501" translate="yes" xml:space="preserve">
          <source>If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; is invoked on argument P prior to returning.</source>
          <target state="translated">sqlite3_deserialize (D, S, P, N, M, F)가 어떤 이유로 인해 실패하고 SQLITE_DESERIALIZE_FREEONCLOSE 비트가 인수 F에 설정된 경우 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 는 리턴하기 전에 인수 P에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="aeea9650fe067179f154dc4c0a23753bc2cbcaea" translate="yes" xml:space="preserve">
          <source>If sqlite3_malloc() fails during the processing of either routine (for example during a conversion from UTF-8 to UTF-16) then a NULL pointer is returned.</source>
          <target state="translated">루틴 처리 중 (예 : UTF-8에서 UTF-16으로 변환 중) sqlite3_malloc ()이 실패하면 NULL 포인터가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cac2f36b365eeaba945df88aa0f1da7631750708" translate="yes" xml:space="preserve">
          <source>If sqlite3_unlock_notify() is called in a multi-threaded application, there is a chance that the blocking connection will have already concluded its transaction by the time sqlite3_unlock_notify() is invoked. If this happens, then the specified callback is invoked immediately, from within the call to sqlite3_unlock_notify().</source>
          <target state="translated">다중 스레드 응용 프로그램에서 sqlite3_unlock_notify ()가 호출되면, sqlite3_unlock_notify ()가 호출 될 때까지 블로킹 연결이 이미 트랜잭션을 종료했을 가능성이 있습니다. 이 경우 sqlite3_unlock_notify ()에 대한 호출 내에서 지정된 콜백이 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d3dbf8613ad9cf5c029072fff340e1a64123138d" translate="yes" xml:space="preserve">
          <source>If state database S does not exist when sqlite3rbu_vacuum() is invoked, it is automatically created and populated with the single table used to store the state of an RBU vacuum - &quot;rbu_state&quot;. If an ongoing RBU vacuum is suspended, this table is populated with state data. The next time sqlite3rbu_vacuum() is called with the same S parameter, it detects this data and attempts to resume the suspended vacuum operation. When an RBU vacuum operation is completed or encounters an error, RBU automatically deletes the contents of the rbu_state table. In this case, the next call to sqlite3rbu_vacuum() starts an entirely new vacuum operation from scratch.</source>
          <target state="translated">sqlite3rbu_vacuum ()을 호출 할 때 상태 데이터베이스 S가 존재하지 않으면 RBU 진공 상태를 저장하는 데 사용되는 단일 테이블 ( &quot;rbu_state&quot;)이 자동으로 작성되어 채워집니다. 진행중인 RBU 진공이 일시 중단되면이 테이블은 상태 데이터로 채워집니다. 다음에 같은 S 매개 변수로 sqlite3rbu_vacuum ()을 호출하면이 데이터를 감지하고 일시 중단 된 진공 작동을 재개하려고 시도합니다. RBU 진공 작업이 완료되거나 오류가 발생하면 RBU는 rbu_state 테이블의 내용을 자동으로 삭제합니다. 이 경우 sqlite3rbu_vacuum ()에 대한 다음 호출은 완전히 새로운 진공 작업을 처음부터 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9b583cb7d9f730fb38a0d4c0658d985458639786" translate="yes" xml:space="preserve">
          <source>If step 1 was successful, an attempt is made to read the</source>
          <target state="translated">1 단계가 완료되면 다음을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="95b4922965cf280511e54a7e6a975a3cf943cead" translate="yes" xml:space="preserve">
          <source>If successful, a pointer to a buffer containing the inverted changeset is stored in *ppOut, the size of the same buffer is stored in *pnOut, and SQLITE_OK is returned. If an error occurs, both *pnOut and *ppOut are zeroed and an SQLite error code returned.</source>
          <target state="translated">성공하면 반전 된 변경 세트를 포함하는 버퍼에 대한 포인터가 * ppOut에 저장되고 동일한 버퍼의 크기가 * pnOut에 저장되며 SQLITE_OK가 리턴됩니다. 오류가 발생하면 * pnOut 및 * ppOut이 모두 0이고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2d2a26797b61cd3892af9cbfe95715fb203e64ff" translate="yes" xml:space="preserve">
          <source>If successful, this function returns SQLITE_OK and populates (*pp) with a pointer to a new sqlite3_changegroup object before returning. The caller should eventually free the returned object using a call to sqlite3changegroup_delete(). If an error occurs, an SQLite error code (i.e. SQLITE_NOMEM) is returned and *pp is set to NULL.</source>
          <target state="translated">성공하면이 함수는 SQLITE_OK를 리턴하고 리턴하기 전에 새 sqlite3_changegroup 오브젝트에 대한 포인터로 (* pp)를 채 웁니다. 호출자는 sqlite3changegroup_delete () 호출을 사용하여 반환 된 객체를 해제해야합니다. 오류가 발생하면 SQLite 오류 코드 (예 : SQLITE_NOMEM)가 리턴되고 * pp가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="25d0330551ddd2fa16bdd016ab08a130f3f7634f" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the &quot;conflicting row&quot; associated with the current conflict-handler callback and returns SQLITE_OK.</source>
          <target state="translated">성공하면이 함수는 * ppValue를 설정하여 현재 충돌 처리기 콜백과 연관된 &quot;충돌 행&quot;의 iVal'th 값을 포함하는 보호 된 sqlite3_value 객체를 가리키고 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fa261183bb429d753dbe1a765227df127f987423" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of new row values stored as part of the UPDATE or INSERT change and returns SQLITE_OK. If the change is an UPDATE and does not include a new value for the requested column, *ppValue is set to NULL and SQLITE_OK returned. The name of the function comes from the fact that this is similar to the &quot;new.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">성공하면이 함수는 * ppValue가 UPDATE 또는 INSERT 변경의 일부로 저장된 새 행 값의 벡터에서 iVal'th 값을 포함하는 보호 된 sqlite3_value 오브젝트를 가리 키도록 설정하고 SQLITE_OK를 리턴합니다. 변경이 UPDATE이고 요청 된 열에 대한 새 값을 포함하지 않으면 * ppValue가 NULL로 설정되고 SQLITE_OK가 리턴됩니다. 함수의 이름은 트리거를 업데이트하거나 삭제하는 데 사용할 수있는 &quot;new. *&quot;열과 유사하다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="8a04e15ae358710d2ad80e6a9a9c13bb73faba6b" translate="yes" xml:space="preserve">
          <source>If successful, this function sets *ppValue to point to a protected sqlite3_value object containing the iVal'th value from the vector of original row values stored as part of the UPDATE or DELETE change and returns SQLITE_OK. The name of the function comes from the fact that this is similar to the &quot;old.*&quot; columns available to update or delete triggers.</source>
          <target state="translated">성공하면이 함수는 * ppValue가 UPDATE 또는 DELETE 변경의 일부로 저장된 원래 행 값의 벡터에서 iVal'th 값을 포함하는 보호 된 sqlite3_value 오브젝트를 가리 키도록 설정하고 SQLITE_OK를 리턴합니다. 함수의 이름은 트리거를 업데이트하거나 삭제하는 데 사용할 수있는 &quot;old. *&quot;열과 유사하다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="5f323dfa9043b9e0668bb0be64be173c0214f5b4" translate="yes" xml:space="preserve">
          <source>If successful, xCreateFunction() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">성공하면 xCreateFunction ()은 SQLITE_OK를 반환합니다. 그렇지 않으면 SQLite 오류 코드를 반환합니다. 이 경우 xDestroy 함수가 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="0c5491699943eedd46aaea7dc769af1705417f26" translate="yes" xml:space="preserve">
          <source>If successful, xCreateTokenizer() returns SQLITE_OK. Otherwise, it returns an SQLite error code. In this case the xDestroy function is &lt;b&gt;not&lt;/b&gt; invoked.</source>
          <target state="translated">성공하면 xCreateTokenizer ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 SQLite 오류 코드를 반환합니다. 이 경우 xDestroy 함수가 호출 &lt;b&gt;되지 않습니다&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="128b9faf8d31130c2470e9c58674eddd1a9c50a3" translate="yes" xml:space="preserve">
          <source>If such a text fragment can be found, it is returned with the following modifications:</source>
          <target state="translated">이러한 텍스트 조각을 찾을 수 있으면 다음과 같이 수정하여 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">만약</target>
        </trans-unit>
        <trans-unit id="2b388f659392c2a3dcc9c7c0db559bd88cf8ff51" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have a &quot;-x&quot; argument, that causes them to accumulate output as Comma-Separated-Values (CSV) in a temporary file, then invoke the default system utility for viewing CSV files (usually a spreadsheet program) on the result. This is a quick way of sending the result of a query to a spreadsheet for easy viewing:</source>
          <target state="translated">&quot;.output&quot;또는 &quot;.once&quot;명령에 &quot;-x&quot;인수가 있으면 임시 파일에서 출력을 CSV (Comma-Separated-Values)로 누적하고 CSV 파일을보기위한 기본 시스템 유틸리티를 호출하십시오. 결과에 (보통 스프레드 시트 프로그램). 다음은 쿼리 결과를 스프레드 시트로 전송하여 쉽게 볼 수있는 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b4746f29b85def95350d80c6bb29ef47dac1ca98" translate="yes" xml:space="preserve">
          <source>If the &quot;.output&quot; or &quot;.once&quot; commands have an argument of &quot;-e&quot; then output is collected into a temporary file and the system text editor is invoked on that text file. Thus, the command &quot;.once -e&quot; achieves the same result as &quot;.once '|open -f'&quot; but with the benefit of being portable across all systems.</source>
          <target state="translated">&quot;.output&quot;또는 &quot;.once&quot;명령에 &quot;-e&quot;인수가 있으면 출력이 임시 파일로 수집되고 해당 텍스트 파일에서 시스템 텍스트 편집기가 호출됩니다. 따라서 &quot;.once -e&quot;명령은 &quot;.once '| open -f'&quot;와 동일한 결과를 얻지 만 모든 시스템에서 이식 가능하다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3daa35758772f94d91f7bd83ab5f9ceb0840b773" translate="yes" xml:space="preserve">
          <source>If the &quot;.recover&quot; command recovers one or more rows that it cannot attribute to any database table, the output script creates a &quot;lost_and_found&quot; table to store the orphaned rows. The schema of the lost_and_found table is as follows:</source>
          <target state="translated">&quot;.recover&quot;명령이 데이터베이스 테이블에 속할 수없는 하나 이상의 행을 복구하는 경우 출력 스크립트는 &quot;lost_and_found&quot;테이블을 작성하여 분리 된 행을 저장합니다. lost_and_found 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ddf7f749d8128e48a3bd895bfea3bcecad29d40" translate="yes" xml:space="preserve">
          <source>If the &quot;CREATE VIRTUAL TABLE&quot; statement specifies module FTS4 (not FTS3), then special directives - FTS4 options - similar to the &quot;tokenize=*&quot; option may also appear in place of column names. An FTS4 option consists of the option name, followed by an &quot;=&quot; character, followed by the option value. The option value may optionally be enclosed in single or double quotes, with embedded quote characters escaped in the same way as for SQL literals. There may not be whitespace on either side of the &quot;=&quot; character. For example, to create an FTS4 table with the value of option &quot;matchinfo&quot; set to &quot;fts3&quot;:</source>
          <target state="translated">&quot;CREATE VIRTUAL TABLE&quot;문이 FTS3이 아닌 모듈 FTS4를 지정하면, &quot;tokenize = *&quot;옵션과 유사한 특수 지시문-FTS4 옵션이 열 이름 대신 나타날 수도 있습니다. FTS4 옵션은 옵션 이름, &quot;=&quot;문자, 옵션 값으로 구성됩니다. 옵션 값은 선택적으로 작은 따옴표 나 큰 따옴표로 묶을 수 있으며, 포함 된 따옴표 문자는 SQL 리터럴과 같은 방식으로 이스케이프됩니다. &quot;=&quot;문자의 양쪽에 공백이 없을 수 있습니다. 예를 들어, &quot;matchinfo&quot;옵션의 값이 &quot;fts3&quot;으로 설정된 FTS4 테이블을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="77546b3dd108217dd30ccb1edbd6835383de8523" translate="yes" xml:space="preserve">
          <source>If the &quot;TEMP&quot; or &quot;TEMPORARY&quot; keyword occurs in between &quot;CREATE&quot; and &quot;VIEW&quot; then the view that is created is only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; that created it and is automatically deleted when the database connection is closed.</source>
          <target state="translated">&quot;CREATE&quot;와 &quot;VIEW&quot;사이에 &quot;TEMP&quot;또는 &quot;TEMPORARY&quot;키워드가 발생하면 작성된보기는 해당보기를 작성한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서만 볼 수 있으며 데이터베이스 연결이 닫히면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e15eb31b4ca840d3439ac476fb29777eeeba453d" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the number of rows of the FTS table that contain at least one instance of the term (in any column). If col contains an integer value, then this column contains the number of rows of the FTS table that contain at least one instance of the term in the column identified by the col value. As usual, the columns of the FTS table are numbered from left to right, starting with zero.</source>
          <target state="translated">&quot;col&quot;열에 값 '*'이 포함 된 경우이 열에는 FTS 테이블의 하나 이상의 인스턴스 (모든 열)를 포함하는 행 수가 포함됩니다. col에 정수 값이 포함 된 경우이 열에는 col 값으로 식별되는 열에 하나 이상의 용어 인스턴스가 포함 된 FTS 테이블의 행 수가 포함됩니다. 일반적으로 FTS 테이블의 열은 0부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="be0668162f080a59b68a89416d5dac39edc657f3" translate="yes" xml:space="preserve">
          <source>If the &quot;col&quot; column contains the value '*', then this column contains the total number of instances of the term in all rows of the FTS table (in any column). Otherwise, if col contains an integer value, then this column contains the total number of instances of the term that appear in the FTS table column identified by the col value.</source>
          <target state="translated">&quot;col&quot;열에 값 '*'이 포함 된 경우이 열에는 FTS 테이블의 모든 행 (모든 열)에있는 용어의 총 인스턴스 수가 포함됩니다. 그렇지 않으면 col에 정수 값이 포함 된 경우이 열에는 col 값으로 식별되는 FTS 테이블 열에 나타나는 총 용어 인스턴스 수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f99db6ea5060e99b5afec54227ba46139ccc5e7b" translate="yes" xml:space="preserve">
          <source>If the &quot;schema&quot; is omitted, it defaults to the primary database (usually called 'main', unless renamed using &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;). Hence, the following two queries are normally equivalent:</source>
          <target state="translated">&quot;스키마&quot;가 생략되면 기본 데이터베이스 (기본적으로 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME을&lt;/a&gt; 사용하여 이름을 바꾸지 않는 한 'main'이라고 함)로 기본 설정됩니다 . 따라서 다음 두 쿼리는 일반적으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9f6d4e5f223a311e53834767137885dbc0d539c8" translate="yes" xml:space="preserve">
          <source>If the &quot;unordered&quot; argument is present, then the query planner assumes that the index is unordered and will not use the index for a range query or for sorting.</source>
          <target state="translated">&quot;정렬되지 않은&quot;인수가 있으면 쿼리 플래너는 인덱스가 정렬되지 않은 것으로 가정하고 범위 쿼리 또는 정렬에 인덱스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8751a71ff20c3c0ca54298560e238a1beb92d451" translate="yes" xml:space="preserve">
          <source>If the $bigstring variable has both a string and a &quot;bytearray&quot; representation, then TCL inserts the value as a string. If it has only a &quot;bytearray&quot; representation, then the value is inserted as a BLOB. To force a value to be inserted as a BLOB even if it also has a text representation, use a &quot;@&quot; character to in place of the &quot;$&quot;. Like this:</source>
          <target state="translated">$ bigstring 변수에 문자열과 &quot;바이트 배열&quot;표현이 모두 있으면 TCL은 값을 문자열로 삽입합니다. &quot;바이트 배열&quot;표현 만있는 경우 값이 BLOB으로 삽입됩니다. 텍스트 표현이있는 경우에도 BLOB로 값을 강제로 삽입하려면 &quot;$&quot;대신 &quot;@&quot;문자를 사용하십시오. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="0c3adca9fee497a14e9991dafc4be56e1a6347bb" translate="yes" xml:space="preserve">
          <source>If the %Q formatting option is used instead of %q, like this:</source>
          <target state="translated">다음과 같이 % q 대신 % Q 형식 옵션을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="0d1bfccef6e7ea95fdaf4eab71d72c15d5446d0c" translate="yes" xml:space="preserve">
          <source>If the --vtab option is passed to sqldiff.exe, then it ignores all underlying shadow tables belonging to an FTS3, FTS5 or rtree virtual table and instead includes the virtual table differences directly.</source>
          <target state="translated">--vtab 옵션이 sqldiff.exe로 전달되면 FTS3, FTS5 또는 rtree 가상 테이블에 속하는 모든 기본 섀도우 테이블을 무시하고 가상 테이블 차이를 직접 포함합니다.</target>
        </trans-unit>
        <trans-unit id="07a5d9f4ebefe616bbce2e1699c303419392f340" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter actually contains two or more statements of SQL, only the first statement is compiled. (This is different from the behavior of &lt;b&gt;sqlite_exec&lt;/b&gt; which executes all SQL statements in its input string.) The 3rd parameter to &lt;b&gt;sqlite_compile&lt;/b&gt; is made to point to the first character beyond the end of the first statement of SQL in the input. If the 2nd parameter contains only a single SQL statement, then the 3rd parameter will be made to point to the '\000' terminator at the end of the 2nd parameter.</source>
          <target state="translated">두 번째 매개 변수에 실제로 두 개 이상의 SQL 문이 포함 된 경우 첫 번째 명령문 만 컴파일됩니다. (이는 입력 문자열에서 모든 SQL 문을 실행 하는 &lt;b&gt;sqlite_exec&lt;/b&gt; 의 동작과 &lt;b&gt;다릅니다&lt;/b&gt; .) &lt;b&gt;sqlite_compile&lt;/b&gt; 의 세 번째 매개 변수 는 입력에서 SQL의 첫 번째 명령문 끝을 넘어 첫 번째 문자를 가리 키도록 만들어집니다. 두 번째 매개 변수에 단일 SQL 문만 포함 된 경우 세 번째 매개 변수는 두 번째 매개 변수 끝에서 '\ 000'종결자를 가리 키도록 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="ace6723edaabac46df7516bfbb37cb232ed631b4" translate="yes" xml:space="preserve">
          <source>If the 2nd parameter to sqlite3_exec() is a NULL pointer, a pointer to an empty string, or a pointer that contains only whitespace and/or SQL comments, then no SQL statements are evaluated and the database is not changed.</source>
          <target state="translated">sqlite3_exec ()에 대한 두 번째 매개 변수가 NULL 포인터, 빈 문자열에 대한 포인터 또는 공백 및 / 또는 SQL 주석 만 포함 된 포인터 인 경우 SQL 문이 평가되지 않고 데이터베이스가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c83d25737a958db458bb466d715ef1df1385742b" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2 ()에 대한 세 번째 매개 변수가 위에 표시된 조합 중 하나가 아닌 다른 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_ * 비트&lt;/a&gt; 와 선택적으로 결합 되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1fab614cdb3090bc486b1f93bb2bcc48a6de130" translate="yes" xml:space="preserve">
          <source>If the 3rd parameter to sqlite3_open_v2() is not one of the combinations shown above optionally combined with other &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_* bits&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">sqlite3_open_v2 ()에 대한 세 번째 매개 변수가 위에 표시된 조합 중 하나가 아닌 다른 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_ * 비트&lt;/a&gt; 와 선택적으로 결합 되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c05ef78416159159b83c40de507c749c65acd9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 플래그가 설정되어, 데이터베이스 연결은 멀티 스레드에서 열립니다 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 컴파일 시간 또는 시작 시간이 긴 단일 스레드 모드로하지 않았다 세트로. &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; 플래그가 설정 되면 컴파일 타임 또는 시작시 단일 스레드를 이전에 선택하지 않은 경우 데이터베이스 연결이 직렬화 된 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 에서 열립니다 . &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE의&lt;/a&gt; 플래그가 데이터베이스 연결을 사용할 자격이됩니다 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드를&lt;/a&gt; 여부에 관계없이 공유 캐시의 사용 활성화, &lt;a href=&quot;#sqlite3_enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache을 ()&lt;/a&gt; . &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;플래그는 데이터베이스 연결 이 사용 가능하더라도 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드에&lt;/a&gt; 참여하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="f124aef410c3a3a5452b1a6fa293c0baf98a2590" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">만약 &lt;a href=&quot;#sqlite3_blob&quot;&gt;&lt;/a&gt;첫 번째 인수로 전달 BLOB 핸들 이 쓰기 위해 열리지 않은 경우 ( &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 플래그 매개 변수 가 0 임)이 함수는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b097a680522bfef6d5db94910e22cbe0a87ca6c4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">는 IF &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen의&lt;/a&gt; 방법이 아닌 NULL 포인터에 sqlite3_file.pMethods 요소를 설정 한 다음 sqlite3_io_methods.xClose 방법도 경우 호출 할 수 있습니다&lt;a href=&quot;#sqlite3vfsxopen&quot;&gt; sqlite3_vfs.xOpen는&lt;/a&gt; 그것이 실패했다고보고했다. 실패한 다음 xClose에 대한 호출을 방지 할 수있는 유일한 방법 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen은&lt;/a&gt; 입니다 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen이&lt;/a&gt; NULL로 sqlite3_file.pMethods 요소를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4075392a6aa7bc2b0c022c207b5beef854359fa" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE의&lt;/a&gt; 연산 코드가 SQLITE_OK를 반환 한 다음 파일 기술자는 이후의 모든 쓰기 작업이 연기하고 다음에 원자 적으로 수행된다는 것을 의미합니다 &quot;일괄 쓰기 모드&quot;에 배치됩니다 &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . 배치 원자 쓰기를 지원하지 않는 시스템은 SQLITE_NOTFOUND를 리턴합니다. 성공적인 SQLITE_FCNTL_BEGIN_ATOMIC_WRITE 전에 마감에 따라 &lt;a href=&quot;#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; 또는 &lt;a href=&quot;#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite는 같은에는 VFS 인터페이스를 호출 할 것 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file의&lt;/a&gt; xWrite 방법과 함께 xFileControl 방법에 대한 호출을 제외한 파일 설명 &lt;a href=&quot;#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadccb78851e96452064935ca6338980e2d4c8f7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">는 IF &lt;a href=&quot;../vtab#xcolumn&quot;&gt;Xcolumn에는의&lt;/a&gt; 열이 UPDATE 문에 의해 변경되지 않도록 방법은 sqlite3_vtab_nochange () 및 발견을 호출 한 다음 Xcolumn에는 방법은 선택적 중 하나를 호출하지 않고, 그 결과를 설정하지 않고 반환 할 수 있습니다&lt;a href=&quot;result_blob&quot;&gt; sqlite3_result_xxxxx () 인터페이스&lt;/a&gt; . 이 경우 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 는 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 의 동일한 열에 대해 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a8a1933767ab95a99c4ac8ef45461802121a0a08" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; passed as the first argument was not opened for writing (the flags parameter to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; was zero), this function returns &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt;첫 번째 인수로 전달 이 쓰기 위해 열리지 않은 경우 ( &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 플래그 매개 변수 가 0 임)이 함수는 &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b723e9fc3d49332b65d60edda223c8ec9ca4d696" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface is used to override the glob(X,Y) function with an alternative implementation then the &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator will invoke the alternative implementation.</source>
          <target state="translated">만약 &lt;a href=&quot;c3ref/create_function&quot;&gt; sqlite3_create_function ()&lt;/a&gt; 인터페이스는 다른 실시하여 글로브 (X, Y) 기능을 대체하는 데 사용되는 다음 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB의&lt;/a&gt; 오퍼레이터는 다른 구현을 호출한다.</target>
        </trans-unit>
        <trans-unit id="3092cc5ebddb90376d018bb6c31fa51fc5b9d178" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; opcode returns SQLITE_OK, then the file descriptor is placed in &quot;batch write mode&quot;, which means all subsequent write operations will be deferred and done atomically at the next &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt;. Systems that do not support batch atomic writes will return SQLITE_NOTFOUND. Following a successful SQLITE_FCNTL_BEGIN_ATOMIC_WRITE and prior to the closing &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; or &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt;, SQLite will make no VFS interface calls on the same &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; file descriptor except for calls to the xWrite method and the xFileControl method with &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot; id=&quot;sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE의&lt;/a&gt; 연산 코드가 SQLITE_OK를 반환 한 다음 파일 기술자는 이후의 모든 쓰기 작업이 연기하고 다음에 원자 적으로 수행된다는 것을 의미합니다 &quot;일괄 쓰기 모드&quot;에 배치됩니다 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; . 배치 원자 쓰기를 지원하지 않는 시스템은 SQLITE_NOTFOUND를 리턴합니다. 성공적인 SQLITE_FCNTL_BEGIN_ATOMIC_WRITE 전에 마감에 따라 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; 또는 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlrollbackatomicwrite&quot;&gt;SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE&lt;/a&gt; , SQLite는 같은에는 VFS 인터페이스를 호출 할 것 &lt;a href=&quot;file&quot;&gt;sqlite3_file의&lt;/a&gt; xWrite 방법과 함께 xFileControl 방법에 대한 호출을 제외한 파일 설명 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlsizehint&quot;&gt;SQLITE_FCNTL_SIZE_HINT을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26aea5eaba4882a7f57e469fe581e38b779b7c63" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag is set, then the database connection opens in the multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; as long as the single-thread mode has not been set at compile-time or start-time. If the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag is set then the database connection opens in the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; unless single-thread was previously selected at compile-time or start-time. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag causes the database connection to be eligible to use &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, regardless of whether or not shared cache is enabled using &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. The &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flag causes the database connection to not participate in &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; even if it is enabled.</source>
          <target state="translated">는 IF &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 플래그가 설정되어, 데이터베이스 연결은 멀티 스레드에서 열립니다 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 컴파일 시간 또는 시작 시간이 긴 단일 스레드 모드로하지 않았다 세트로. &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; 플래그가 설정 되면 컴파일 타임 또는 시작시 단일 스레드를 이전에 선택하지 않은 경우 데이터베이스 연결이 직렬화 된 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 에서 열립니다 . &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE의&lt;/a&gt; 플래그가 데이터베이스 연결을 사용할 자격이됩니다 &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드를&lt;/a&gt; 여부에 관계없이 공유 캐시의 사용 활성화, &lt;a href=&quot;enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache을 ()&lt;/a&gt; . &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;플래그는 데이터베이스 연결 이 사용 가능하더라도 &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드에&lt;/a&gt; 참여하지 않도록 합니다.</target>
        </trans-unit>
        <trans-unit id="3d6b9e280cf3c9ed4800b321c18f34c5a4956d1e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; option is used, then SQLite is capable of using 8+3 filenames but that capabilities is disabled and must be enabled separately for each database connection by using using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; when &lt;a href=&quot;c3ref/open&quot;&gt;opening&lt;/a&gt; or &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ing&lt;/a&gt; the database files and include the &quot;&lt;code&gt;8_3_names=1&lt;/code&gt;&quot; query parameter in the URI. If SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt; then 8+3 filenames are enabled by default and this step can be skipped.</source>
          <target state="translated">는 IF &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; 옵션을 사용하고 SQLite는 8 + 3 파일 이름을 사용 할 수 있지만 기능은 사용할 수 없으며 사용하여 사용하여 각 데이터베이스 연결에 대해 개별적으로 활성화해야합니다 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 때 &lt;a href=&quot;c3ref/open&quot;&gt;개방&lt;/a&gt; 또는 &lt;a href=&quot;lang_attach&quot;&gt;- 보내고 ATTACH&lt;/a&gt; 데이터베이스 파일과 포함 &quot; &lt;code&gt;8_3_names=1&lt;/code&gt; URI의 8_3_names = 1 &quot;쿼리 매개 변수 SQLite가 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt; 로 컴파일되면 기본적으로 8 + 3 개의 파일 이름이 활성화 되므로이 단계를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f14f4e625a540ecf3e1de270c88730b0b55cfa0f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies disk storage for temporary files, then override that decision and use memory storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">는 IF &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 임시 파일에 대한 컴파일 시간 매개 변수를 지정 디스크에 저장 한 후 대신 그 결정과 사용 메모리 저장 장치를 대체합니다. 그렇지 않으면 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 의 권장 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="cc4e5ad04a8f404976f4ea549e621889ed4a2406" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter specifies memory storage for temporary files, then override that decision and use disk storage instead. Otherwise follow the recommendation of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">는 IF &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 임시 파일에 대한 컴파일 시간 매개 변수를 지정 메모리 저장 후 대신 그 결정과 사용 디스크 스토리지보다 우선합니다. 그렇지 않으면 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 의 권장 사항을 따르십시오 .</target>
        </trans-unit>
        <trans-unit id="c75f136169c511a3f8a8fd887440953a9ba6fdef" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of a column is REAL and that column contains a value that can be converted to an integer without loss of information (if the value contains no fractional part and is not too large to be represented as an integer) then the column may be stored in the record as an integer. SQLite will convert the value back to floating point when extracting it from the record.</source>
          <target state="translated">만약 &lt;a href=&quot;datatype3#affinity&quot;&gt; 친화&lt;/a&gt; 열이 REAL하며 (값은 더 소수 부분을 포함하지 않고 정수로 표현하기에 너무 크지 않은 경우) 그 열은 정보의 손실없이 정수로 변환 될 수있는 값을 포함 후 컬럼 일 수있다 레코드에 정수로 저장됩니다. SQLite는 레코드에서 값을 추출 할 때 값을 부동 소수점으로 다시 변환합니다.</target>
        </trans-unit>
        <trans-unit id="6bdd9340a9dcd6ebb4b2136a687baf206a35c611" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; is not aliased by &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; then it is not persistent and might change. In particular the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will change rowids for tables that do not declare an INTEGER PRIMARY KEY. Therefore, applications should not normally access the rowid directly, but instead use an INTEGER PRIMARY KEY.</source>
          <target state="translated">행 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ID&lt;/a&gt; 가 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY에&lt;/a&gt; 의해 별명 지정 되지 않으면 지속적이지 않으며 변경 될 수 있습니다. 특히&lt;a href=&quot;lang_vacuum&quot;&gt; VACUUM&lt;/a&gt; 명령은 INTEGER PRIMARY KEY를 선언하지 않은 테이블의 rowid를 변경합니다. 따라서 응용 프로그램은 일반적으로 rowid에 직접 액세스하지 말고 대신 INTEGER PRIMARY KEY를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="96317212b202d64aa994eed839385d463798a08e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt; opcode is being used to fetch the value of an unchanging column during an UPDATE operation, then the P5 value is OPFLAG_NOCHNG. This will cause the sqlite3_vtab_nochange() function to return true inside the xColumn method of the virtual table implementation. The P5 column might also contain other bits (OPFLAG_LENGTHARG or OPFLAG_TYPEOFARG) but those bits are unused by &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn의&lt;/a&gt; 연산 코드가 갱신 동작 동안에 불변 열의 값을 취득하는 데 사용되고, 그 값은 P5 OPFLAG_NOCHNG이다. 그러면 sqlite3_vtab_nochange () 함수가 가상 테이블 구현의 xColumn 메소드 내에서 true를 리턴합니다. P5 열에는 다른 비트 (OPFLAG_LENGTHARG 또는 OPFLAG_TYPEOFARG)도 포함될 수 있지만 해당 비트는 &lt;a href=&quot;opcode#VColumn&quot;&gt;VColumn에서&lt;/a&gt; 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2b4eaedd5855ff13b903e656d850adc325c12c79" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is used on a subquery in the FROM clause of a SELECT statement, that effectively merges the subquery into the outer query. The output of EXPLAIN QUERY PLAN reflects this, as in the following example:</source>
          <target state="translated">경우 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화가&lt;/a&gt; SELECT 문의 FROM 절에서 서브 쿼리에 사용되며, 그 효과적으로 외부 쿼리에 하위 쿼리를 병합합니다. EXPLAIN QUERY PLAN의 출력은 다음 예와 같이이를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="6110f6d9f2445ffa2d331ca1dfcaf53aa3a365b6" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS&lt;/a&gt; pragma is set to ON and the result of a query is an empty set, then the callback is invoked once with the third parameter (argv) set to 0. In other words</source>
          <target state="translated">만약 &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt; EMPTY_RESULT_CALLBACKS의&lt;/a&gt; 프라그는 ON으로 설정하고, 쿼리 결과는 다음 콜백 말하면 0 세번째 파라미터 (ARGV) 세트로 한번 호출 공집합이다되고</target>
        </trans-unit>
        <trans-unit id="b1c24c8f45d6339d5389a76337c9e88f41b5e36a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; flag is set, then the F_FULLFSYNC syncing method is used for all sync operations and the checkpoint_fullfsync setting is irrelevant.</source>
          <target state="translated">전체 &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;동기화&lt;/a&gt; 플래그가 설정된 후 F_FULLFSYNC 동기화 방법은 모든 동기화 작업에 사용하고 checkpoint_fullfsync 설정은 무관하다.</target>
        </trans-unit>
        <trans-unit id="a73873febe6d7de1338d537c333841d126c81b5b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; pragma is ON, then the name of the result is the name of the source table column without the source table name prefix: COLUMN.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names 인&lt;/a&gt; 경우 COLUMN : 프라그가 ON, 결과의 이름은 소스 테이블 이름 접두사가없는 소스 테이블 컬럼의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1069754e926abbbcc7551f7b3c103d01ced65dbe" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method sets the sqlite3_file.pMethods element to a non-NULL pointer, then the sqlite3_io_methods.xClose method may be invoked even if the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; reported that it failed. The only way to prevent a call to xClose following a failed &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; is for the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; to set the sqlite3_file.pMethods element to NULL.</source>
          <target state="translated">는 IF &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen의&lt;/a&gt; 방법이 아닌 NULL 포인터에 sqlite3_file.pMethods 요소를 설정 한 다음 sqlite3_io_methods.xClose 방법은 경우에도 호출 할 수 있습니다&lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt; sqlite3_vfs.xOpen는&lt;/a&gt; 그것이 실패했다고보고했다. 실패한 다음 xClose에 대한 호출을 방지 할 수있는 유일한 방법 &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen은&lt;/a&gt; 입니다 &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen이&lt;/a&gt; NULL로 sqlite3_file.pMethods 요소를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e03a0f37d058bb5a34bec7fac575235294acd0da" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method calls sqlite3_vtab_nochange() and finds that the column is not changed by the UPDATE statement, then the xColumn method can optionally return without setting a result, without calling any of the &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_xxxxx() interfaces&lt;/a&gt;. In that case, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; will return true for the same column in the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method.</source>
          <target state="translated">경우] &lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumn에는에&lt;/a&gt; 메소드 호출은 열이 UPDATE 문에 의해 변경되지 않도록 sqlite3_vtab_nochange ()를 찾은 후 Xcolumn에는 방법은 선택적으로 임의의 호출하지 않고, 그 결과를 설정하지 않고 반환 할&lt;a href=&quot;#sqlite3_result_blob&quot;&gt; sqlite3_result_xxxxx () 인터페이스&lt;/a&gt; . 이 경우 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 는 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 의 동일한 열에 대해 true를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="6aba978070ccc979bd49ef28d0ef204e751d91d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method in a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation returns an error message using &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error()&lt;/a&gt; then give that error message preference over internally-generated messages.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드가 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error ()&lt;/a&gt; 를 사용하여 오류 메시지를 리턴하면 내부 생성 메시지보다 해당 오류 메시지 우선 순위를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="a18d90fb5154dfedaa1471558060511dc56cfb54" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method is NULL, then &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statements are prohibited for that virtual table, and the virtual table is an &quot;eponymous-only virtual table&quot;. Eponymous-only virtual tables are useful as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate의&lt;/a&gt; 방법이 NULL, 다음 &lt;a href=&quot;lang_createvtab&quot;&gt;가상 테이블의 CREATE&lt;/a&gt; 문이 가상 테이블 금지하고, 가상 테이블은 &quot;시조 전용 가상 테이블&quot;입니다. 시상 전용 가상 테이블은 다음과 같이 유용합니다.&lt;a href=&quot;vtab#tabfunc2&quot;&gt; 테이블 반환 함수 합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e36f28038a4ddd30d8f77a7f397ce33837d3478d" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; method for the virtual table is defined, and if xFindFunction() sometimes returns &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; or larger, then the constraints might also be of the form:</source>
          <target state="translated">는 IF &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; 가상 테이블에 대한 메소드가 정의되고, xFindFunction ()는 때로는 반환하는 경우 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION을&lt;/a&gt; 이상을, 그 제약은 형식이 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="89b6cc463721d8831624d29f70a88929969774cd" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;), this pragma causes a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation to run on database</source>
          <target state="translated">경우 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 합니다 (를 통해 사용할 수 있습니다 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode 프라그&lt;/a&gt; )이 pragma는 원인 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 데이터베이스에서 실행하는 작업을</target>
        </trans-unit>
        <trans-unit id="fa30bb229e0ba6c16b036d0680166f4c0e969175" translate="yes" xml:space="preserve">
          <source>If the &lt;b&gt;header&lt;/b&gt; argument is true then the first row of the CSV file to be treated as a header rather than as data. The second line of the CSV file becomes the first row of content. If the &lt;b&gt;schema=&lt;/b&gt; options is omitted, then the first line of the CSV file determines the names of the columns.</source>
          <target state="translated">경우 &lt;b&gt;헤더&lt;/b&gt; 인수가 true 다음 CSV 파일의 첫 번째 행은 헤더로서가 아닌 데이터로 취급합니다. CSV 파일의 두 번째 줄은 첫 번째 내용 행이됩니다. 는 IF &lt;b&gt;스키마 =&lt;/b&gt; 옵션을 생략 한 다음 CSV 파일의 첫 번째 행은 열 이름을 판단한다.</target>
        </trans-unit>
        <trans-unit id="c1cfb6451556f25af13b7b368489aadb6eb20ce2" translate="yes" xml:space="preserve">
          <source>If the AUTOINCREMENT keyword appears after INTEGER PRIMARY KEY, that changes the automatic ROWID assignment algorithm to prevent the reuse of ROWIDs over the lifetime of the database. In other words, the purpose of AUTOINCREMENT is to prevent the reuse of ROWIDs from previously deleted rows.</source>
          <target state="translated">INTEGER PRIMARY KEY 뒤에 AUTOINCREMENT 키워드가 나타나면 데이터베이스 수명 동안 ROWID를 재사용하지 못하도록 자동 ROWID 할당 알고리즘이 변경됩니다. 즉, AUTOINCREMENT의 목적은 이전에 삭제 된 행에서 ROWID를 재사용하지 못하게하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e7ae8b25bf55713a14aa930c0d079c55585a0c82" translate="yes" xml:space="preserve">
          <source>If the C version of the &lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU library&lt;/a&gt; is available, then FTS may also be compiled with the SQLITE_ENABLE_ICU pre-processor macro defined. Compiling with this macro enables an FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; that uses the ICU library to split a document into terms (words) using the conventions for a specified language and locale.</source>
          <target state="translated">&lt;a href=&quot;http://site.icu-project.org/&quot;&gt;ICU 라이브러리&lt;/a&gt; 의 C 버전 이 사용 가능한 경우 FTS는 정의 된 SQLITE_ENABLE_ICU 전 처리기 매크로로 컴파일 될 수도 있습니다. 이 매크로로 컴파일하면 FTS &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저가&lt;/a&gt; 활성화됩니다 하면 ICU 라이브러리를 사용하여 지정된 언어 및 로캘의 규칙을 사용하여 문서를 용어 (단어)로 분할 를 사용할 .</target>
        </trans-unit>
        <trans-unit id="aade338ead72cd83806851289f36afe9ffee6390" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">DELETE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 (외래 키 제한 조건을 위반 한 경우에만 발생할 수 있음) 충돌 핸들러 함수가 두 번째 인수로 전달 된 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; 와 함께 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 DELETE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4726b3dbe2c58403328aff3054192714f5fc075" translate="yes" xml:space="preserve">
          <source>If the DELETE operation is attempted, but SQLite returns SQLITE_CONSTRAINT (which can only happen if a foreign key constraint is violated), the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the DELETE operation is attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">DELETE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 (외래 키 제한 조건을 위반 한 경우에만 발생할 수 있음) 충돌 핸들러 함수가 두 번째 인수로 전달 된 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; 와 함께 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 DELETE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="a02c654b3d70302948f2081631be3edc27671a93" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has an ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are sorted according to the ORDER BY. The first</source>
          <target state="translated">DELETE 문에 ORDER BY 절이 있으면 LIMIT 절이 없을 때 삭제 될 모든 행이 ORDER BY에 따라 정렬됩니다. 첫번째</target>
        </trans-unit>
        <trans-unit id="63547bac31e35c719e75fc46ff0cebecf92fd269" translate="yes" xml:space="preserve">
          <source>If the DELETE statement has no ORDER BY clause, then all rows that would be deleted in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine the subset that are actually deleted.</source>
          <target state="translated">DELETE 문에 ORDER BY 절이없는 경우 LIMIT 절이 없을 때 삭제 될 모든 행은 LIMIT 및 OFFSET 절을 적용하기 전에 임의의 순서로 어셈블되어 실제로 삭제되는 서브 세트를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="20e8eb12f584aa2a2c71da9ffe10b6bc6f97692b" translate="yes" xml:space="preserve">
          <source>If the ESCAPE option is used, the ESCAPE character must be ASCII, or a single-byte character in UTF-8.</source>
          <target state="translated">ESCAPE 옵션을 사용하는 경우 ESCAPE 문자는 ASCII이거나 UTF-8의 1 바이트 문자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="7f76a2496ff32a61cee2f76ed3e0830800bfd787" translate="yes" xml:space="preserve">
          <source>If the FROM clause is omitted from a simple SELECT statement, then the input data is implicitly a single row zero columns wide (i.e.</source>
          <target state="translated">FROM 절이 간단한 SELECT 문에서 생략되면 입력 데이터는 암시 적으로 너비가 0 인 단일 행입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="408ec930c8db59ef8bcaccad18026b5e15f9eaec" translate="yes" xml:space="preserve">
          <source>If the FTS table is an FTS4 table (not FTS3), a token may also be prefixed with a &quot;^&quot; character. In this case, in order to match the token must appear as the very first token in any column of the matching row. Examples:</source>
          <target state="translated">FTS 테이블이 FTS4 테이블 (FTS3 아님) 인 경우 토큰 앞에 &quot;^&quot;문자가 붙을 수도 있습니다. 이 경우 토큰을 일치 시키려면 일치하는 행의 모든 ​​열에서 첫 번째 토큰으로 나타나야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="93fd7e443f86d05e9fc567cfba4cc2ea3b224813" translate="yes" xml:space="preserve">
          <source>If the FTS5 table is created with the 'detail' option set to 'col', then the</source>
          <target state="translated">'세부 사항'옵션을 'col'로 설정하여 FTS5 테이블을 작성하면</target>
        </trans-unit>
        <trans-unit id="99ee296e09aab46dd06e0a5f1c140a90b72606e3" translate="yes" xml:space="preserve">
          <source>If the HAVE_FDATASYNC compile-time option is true, then the default &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unix systems will attempt to use fdatasync() instead of fsync() where appropriate. If this flag is missing or false, then fsync() is always used.</source>
          <target state="translated">HAVE_FDATASYNC 컴파일 타임 옵션이 true 인 경우, 유닉스 시스템 의 기본 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 적절한 경우 fsync () 대신 fdatasync ()를 사용하려고 시도합니다. 이 플래그가 없거나 false이면 fsync ()가 항상 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e31d6de70624cd3258a7c666db7d8624e2234e9" translate="yes" xml:space="preserve">
          <source>If the HAVE_GMTIME_R option is true and if &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is true, then the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords will use the threadsafe &quot;gmtime_r()&quot; interface rather than &quot;gmtime()&quot;. In the usual case where &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; is not defined or is false, then the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt; are used to implement the CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP keywords and neither gmtime_r() nor gmtime() is ever called.</source>
          <target state="translated">HAVE_GMTIME_R 옵션이 true이고 &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; 가 true 인 경우 CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP 키워드는 &quot;gmtime ()&quot;대신 스레드 안전 &quot;gmtime_r ()&quot;인터페이스를 사용합니다. &lt;a href=&quot;compile#omit_datetime_funcs&quot;&gt;SQLITE_OMIT_DATETIME_FUNCS&lt;/a&gt; 가 정의되지 않았거나 false 인 일반적인 경우 , 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 는 CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP 키워드를 구현하는 데 사용되며 gmtime_r () 또는 gmtime ()은 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40cdcf3ade2687218b791686ca4436d6b3c5cfba" translate="yes" xml:space="preserve">
          <source>If the HAVE_ISNAN option is true, then SQLite invokes the system library isnan() function to determine if a double-precision floating point value is a NaN. If HAVE_ISNAN is undefined or false, then SQLite substitutes its own home-grown implementation of isnan().</source>
          <target state="translated">HAVE_ISNAN 옵션이 true이면 SQLite는 시스템 라이브러리 isnan () 함수를 호출하여 배정 밀도 부동 소수점 값이 NaN인지 판별합니다. HAVE_ISNAN이 정의되지 않았거나 false이면 SQLite는 자체 개발 한 isnan () 구현을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="153cb2536cd91084b29b41e9d14f8a7ef310cc61" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_R option is true, then SQLite uses the threadsafe localtime_r() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">HAVE_LOCALTIME_R 옵션이 true 인 경우 SQLite는 localtime () 대신 스레드 안전 localtime_r () 라이브러리 루틴을 사용 하여 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 에 대해 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime 수정자를&lt;/a&gt; 구현하는 데 도움을줍니다 .</target>
        </trans-unit>
        <trans-unit id="0c4b14956847344de7b5a6ccb25e5f358e368735" translate="yes" xml:space="preserve">
          <source>If the HAVE_LOCALTIME_S option is true, then SQLite uses the threadsafe localtime_s() library routine instead of localtime() to help implement the &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime modifier&lt;/a&gt; to the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">HAVE_LOCALTIME_S 옵션이 true 인 경우 SQLite는 localtime () 대신 스레드 안전 localtime_s () 라이브러리 루틴을 사용 하여 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 에 대해 &lt;a href=&quot;lang_datefunc#localtime&quot;&gt;localtime 수정자를&lt;/a&gt; 구현하는 데 도움을줍니다 .</target>
        </trans-unit>
        <trans-unit id="997bea68ec053527286253926a4446e11225f13c" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is omitted or is false, then SQLite uses a wrapper around system malloc() and realloc() that enlarges each allocation by 8 bytes and writes the size of the allocation in the initial 8 bytes, and then SQLite also implements its own home-grown version of malloc_usable_size() that consults that 8-byte prefix to find the allocation size. This approach works but it is suboptimal. Applications are encouraged to use HAVE_MALLOC_USABLE_SIZE whenever possible.</source>
          <target state="translated">HAVE_MALLOC_USABLE_SIZE 옵션이 생략되거나 false 인 경우 SQLite는 시스템 malloc () 및 realloc () 주위의 랩퍼를 사용하여 각 할당을 8 바이트 씩 확대하고 할당 크기를 초기 8 바이트로 기록한 다음 SQLite도 구현합니다. 8 바이트 접두사를 참조하여 할당 크기를 찾는 고유 한 malloc_usable_size () 버전. 이 방법은 효과가 있지만 차선책입니다. 응용 프로그램은 가능할 때마다 HAVE_MALLOC_USABLE_SIZE를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="55308f0ca78c87c49d7100dbf1e1e1adc1d30409" translate="yes" xml:space="preserve">
          <source>If the HAVE_MALLOC_USABLE_SIZE option is true, then SQLite tries uses the malloc_usable_size() interface to find the size of a memory allocation obtained from the standard-library malloc() or realloc() routines. This option is only applicable if the standard-library malloc() is used. On Apple systems, &quot;zone malloc&quot; is used instead, and so this option is not applicable. And, of course, if the application supplies its own malloc implementation using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; then this option has no effect.</source>
          <target state="translated">HAVE_MALLOC_USABLE_SIZE 옵션이 true이면 SQLite는 malloc_usable_size () 인터페이스를 사용하여 표준 라이브러리 malloc () 또는 realloc () 루틴에서 얻은 메모리 할당 크기를 찾습니다. 이 옵션은 표준 라이브러리 malloc ()을 사용하는 경우에만 적용 할 수 있습니다. Apple 시스템에서는 &quot;zone malloc&quot;이 대신 사용되므로이 옵션은 적용 할 수 없습니다. 물론 애플리케이션 이 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 을 사용하여 자체 malloc 구현을 제공하는 경우이 옵션은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3344d140659472562fd4dea21990938229ddf3ec" translate="yes" xml:space="preserve">
          <source>If the HAVE_STRCHRNUL option is true, then SQLite uses the strchrnul() library function. If this option is missing or false, then SQLite substitutes its own home-grown implementation of strchrnul().</source>
          <target state="translated">HAVE_STRCHRNUL 옵션이 true이면 SQLite는 strchrnul () 라이브러리 함수를 사용합니다. 이 옵션이 없거나 false이면 SQLite는 자체 개발 한 strchrnul () 구현을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="08d8894136dfc0e284f285c182990a928235abdc" translate="yes" xml:space="preserve">
          <source>If the HAVE_USLEEP option is true, then the default unix VFS uses the usleep() system call to implement the xSleep method. If this option is undefined or false, then xSleep on unix is implemented using sleep() which means that &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; will have a minimum wait interval of 1000 milliseconds regardless of its argument.</source>
          <target state="translated">HAVE_USLEEP 옵션이 true 인 경우, 기본 유닉스 VFS는 usleep () 시스템 호출을 사용하여 xSleep 메소드를 구현합니다. 이 옵션이 정의되지 않거나 false 인 경우 유닉스에서 xSleep은 sleep ()을 사용하여 구현됩니다. 즉 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 은 인수에 관계없이 최소 대기 간격이 1000 밀리 초입니다.</target>
        </trans-unit>
        <trans-unit id="538ccd48ed8bd61407504bbf28bbe6d0ffe8bf96" translate="yes" xml:space="preserve">
          <source>If the HAVE_UTIME option is true, then the built-in but non-standard &quot;unix-dotfile&quot; VFS will use the utime() system call, instead of utimes(), to set the last access time on the lock file.</source>
          <target state="translated">HAVE_UTIME 옵션이 true 인 경우 내장 된 비표준 &quot;unix-dotfile&quot;VFS는 utimes () 대신 utime () 시스템 호출을 사용하여 잠금 파일의 마지막 액세스 시간을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="7cab5093752cc9a8b0a63442b0923931057ad2d6" translate="yes" xml:space="preserve">
          <source>If the INTO clause is included, then the original database file is unchanged and a new database is created in the filename given by the argument to the INTO clause. The new database will contain the same logical content as the original database, fully vacuumed.</source>
          <target state="translated">INTO 절이 포함 된 경우, 원래 데이터베이스 파일은 변경되지 않으며 INTO 절에 대한 인수가 제공 한 파일 이름에 새 데이터베이스가 작성됩니다. 새 데이터베이스에는 원래 데이터베이스와 동일한 논리적 내용이 포함되며 완전히 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e0bffd82940bcd9134c72373f0af179d9c5474" translate="yes" xml:space="preserve">
          <source>If the LIMIT expression evaluates to non-negative value</source>
          <target state="translated">LIMIT 표현식이 음수가 아닌 값으로 평가되는 경우</target>
        </trans-unit>
        <trans-unit id="f61e07bad4e222ccefd74ac63dc52c1ed3c63a8f" translate="yes" xml:space="preserve">
          <source>If the NATURAL keyword is in the join-operator then an implicit USING clause is added to the join-constraints. The implicit USING clause contains each of the column names that appear in both the left and right-hand input datasets. If the left and right-hand input datasets feature no common column names, then the NATURAL keyword has no effect on the results of the join. A USING or ON clause may not be added to a join that specifies the NATURAL keyword.</source>
          <target state="translated">NATURAL 키워드가 join-operator에 있으면 내재 된 USING 절이 join-constraints에 추가됩니다. 내재 된 USING 절에는 왼쪽 및 오른쪽 입력 데이터 세트 모두에 나타나는 각 열 이름이 포함됩니다. 왼쪽 및 오른쪽 입력 데이터 집합에 공통 열 이름이없는 경우 NATURAL 키워드는 조인 결과에 영향을 미치지 않습니다. NATURAL 키워드를 지정하는 조인에 USING 또는 ON 절을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a2b9577c2b86e52c07b264eb7017d085b143b677" translate="yes" xml:space="preserve">
          <source>If the Nth column returned by the statement is an expression or subquery and is not a column value, then all of these functions return NULL. These routine might also return NULL if a memory allocation error occurs. Otherwise, they return the name of the attached database, table, or column that query result column was extracted from.</source>
          <target state="translated">명령문이 리턴 한 N 번째 컬럼이 표현식 또는 서브 쿼리이고 컬럼 값이 아닌 경우 이러한 모든 함수는 NULL을 리턴합니다. 메모리 할당 오류가 발생하면이 루틴은 NULL을 리턴 할 수도 있습니다. 그렇지 않으면 쿼리 결과 열이 추출 된 연결된 데이터베이스, 테이블 또는 열의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f987b1e749686c5439c4369e9509e69172835e8f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_AUXDELETE bit is set on P5, that indicates that this delete one of several associated with deleting a table row and all its associated index entries. Exactly one of those deletes is the &quot;primary&quot; delete. The others are all on OPFLAG_FORDELETE cursors or else are marked with the AUXDELETE flag.</source>
          <target state="translated">OPFLAG_AUXDELETE 비트가 P5에 설정된 경우 이는 테이블 행 및 연관된 모든 인덱스 항목 삭제와 연관된 여러 항목 중 하나가 삭제됨을 나타냅니다. 이러한 삭제 중 하나는 &quot;1 차&quot;삭제입니다. 다른 것은 모두 OPFLAG_FORDELETE 커서에 있거나 AUXDELETE 플래그로 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e0584b25ae53697595c710240b674cfcd931b66" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set in P2, then P3 contains the address of the memory cell that contains the value that the rowid of the row will be set to by the update.</source>
          <target state="translated">OPFLAG_ISUPDATE 플래그가 P2에 설정된 경우, P3은 행의 rowid가 갱신에 의해 설정 될 값을 포함하는 메모리 셀의 주소를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="85453347b772792d0ef83ca6247504c978601416" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an UPDATE operation. Otherwise (if the flag is clear) then this opcode is part of an INSERT operation. The difference is only important to the update hook.</source>
          <target state="translated">OPFLAG_ISUPDATE 플래그가 설정되면이 opcode는 UPDATE 조작의 일부입니다. 그렇지 않으면 (플래그가 명확한 경우)이 opcode는 INSERT 조작의 일부입니다. 차이점은 업데이트 후크에만 중요합니다.</target>
        </trans-unit>
        <trans-unit id="358930ea0c0cb3bf8ddbac06391138cf9e1e9b1f" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_LENGTHARG and OPFLAG_TYPEOFARG bits are set on P5 then the result is guaranteed to only be used as the argument of a length() or typeof() function, respectively. The loading of large blobs can be skipped for length() and all content loading can be skipped for typeof().</source>
          <target state="translated">OPFLAG_LENGTHARG 및 OPFLAG_TYPEOFARG 비트가 P5에 설정되면 결과는 각각 length () 또는 typeof () 함수의 인수로만 사용되도록 보장됩니다. length ()의 경우 큰 얼룩의로드를 건너 뛸 수 있고 typeof ()의 경우 모든 내용로드를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b673a87eca1e30fb0e05ce7b3a0e2e621baf2f1c" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P2 (NB: P2 not P5) is set, then the row change count is incremented (otherwise not).</source>
          <target state="translated">P2의 OPFLAG_NCHANGE 플래그 (NB : P2 not P5)가 설정되면 행 변경 계수가 증가합니다 (그렇지 않으면).</target>
        </trans-unit>
        <trans-unit id="8006bf0580f0ceee7abfbb502ff0bc2738a32586" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is incremented (otherwise not). If the OPFLAG_LASTROWID flag of P5 is set, then rowid is stored for subsequent return by the sqlite3_last_insert_rowid() function (otherwise it is unmodified).</source>
          <target state="translated">P5의 OPFLAG_NCHANGE 플래그가 설정되면, 행 변경 계수가 증가합니다 (그렇지 않으면). P5의 OPFLAG_LASTROWID 플래그가 설정되면, sqlite3_last_insert_rowid () 함수에 의한 후속 리턴을 위해 rowid가 저장됩니다 (그렇지 않으면 수정되지 않음).</target>
        </trans-unit>
        <trans-unit id="0464f564c819708fc95ba0ca873e884f00c0c5ec" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_SAVEPOSITION bit of the P5 parameter is set, then the cursor will be left pointing at either the next or the previous record in the table. If it is left pointing at the next record, then the next &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will be a no-op. As a result, in this case it is ok to delete a record from within a &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; loop. If OPFLAG_SAVEPOSITION bit of P5 is clear, then the cursor will be left in an undefined state.</source>
          <target state="translated">P5 매개 변수의 OPFLAG_SAVEPOSITION 비트가 설정되면 커서는 테이블에서 다음 또는 이전 레코드를 가리 키도록 남습니다. 다음 레코드를 가리키고 있으면 다음 &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 명령어는 작동하지 않습니다. 결과적으로이 경우에는 &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 루프 내에서 레코드를 삭제해도됩니다 . P5의 OPFLAG_SAVEPOSITION 비트가 지워지면 커서는 정의되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b8443bd622375a798ed2a10b2bb936621afb5e73" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equal to P3.</source>
          <target state="translated">P5의 OPFLAG_USESEEKRESULT 플래그가 설정되면, 커서 P1에 대한 불필요한 탐색을 피함으로써 구현이 더 빠르게 실행될 수 있습니다. 그러나 OPFLAG_USESEEKRESULT 플래그는 커서에 대한 사전 탐색이 없거나 가장 최근 탐색이 P3과 같은 키를 사용한 경우에만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="24d1994d6156f999d1ee517ed391edb59d48c618" translate="yes" xml:space="preserve">
          <source>If the OPFLAG_USESEEKRESULT flag of P5 is set, the implementation might run faster by avoiding an unnecessary seek on cursor P1. However, the OPFLAG_USESEEKRESULT flag must only be set if there have been no prior seeks on the cursor or if the most recent seek used a key equivalent to P2.</source>
          <target state="translated">P5의 OPFLAG_USESEEKRESULT 플래그가 설정되면, 커서 P1에 대한 불필요한 탐색을 피함으로써 구현이 더 빠르게 실행될 수 있습니다. 그러나 OPFLAG_USESEEKRESULT 플래그는 커서에 대한 사전 탐색이 없거나 가장 최근 탐색이 P2와 동등한 키를 사용한 경우에만 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f2be7bea7738f3621eca4267ce81f09d41a2e23" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is a constant integer K then the expression is considered an alias for the K-th column of the result set (columns are numbered from left to right starting with 1).</source>
          <target state="translated">ORDER BY 표현식이 상수 정수 K 인 경우 표현식은 결과 세트의 K 번째 열에 대한 별명으로 간주됩니다 (열은 1부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨 짐).</target>
        </trans-unit>
        <trans-unit id="54b7818868eb0e39bd8ddbed56195f5499a4600b" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is an identifier that corresponds to the alias of one of the output columns, then the expression is considered an alias for that column.</source>
          <target state="translated">ORDER BY 표현식이 출력 열 중 하나의 별명에 해당하는 식별자 인 경우 표현식은 해당 열의 별명으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="00fdbe0ee21cda19b4a8ae7897474539b1f0a75c" translate="yes" xml:space="preserve">
          <source>If the ORDER BY expression is assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the specified collation sequence is used.</source>
          <target state="translated">ORDER BY 표현식에 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용하여 데이터 정렬 시퀀스가 ​​지정된 경우 지정된 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d77a3e5eca6240aa4cf73a2d563a4460d778268d" translate="yes" xml:space="preserve">
          <source>If the P1 cursor must be pointing to a valid row (not a NULL row) of a real table, not a pseudo-table.</source>
          <target state="translated">P1 커서가 의사 테이블이 아닌 실제 테이블의 유효한 행 (NULL 행이 아님)을 가리켜 야하는 경우.</target>
        </trans-unit>
        <trans-unit id="1f5366d1e68bed932cc9eadcf38bc5c4aed05e24" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 크거나 같은 경우 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="eb12e9cd16de01f1875169ba7dbce89a734843ad" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is greater than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 큰 경우 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="dbe830f25814f54ccec56a9eb14db5b310130922" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than or equal to the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 작거나 같은 경우 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="a25915e27b156d98cb891f738fe575b0c439ae6a" translate="yes" xml:space="preserve">
          <source>If the P1 index entry is less than the key value then jump to P2. Otherwise fall through to the next instruction.</source>
          <target state="translated">P1 색인 항목이 키 값보다 작 으면 P2로 이동하십시오. 그렇지 않으면 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="64d6010c68c3d803b2d20f7d66e38f73be2fb061" translate="yes" xml:space="preserve">
          <source>If the P1 value is non-zero, then also set the MEM_Cleared flag so that NULL values will not compare equal even if SQLITE_NULLEQ is set on &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; or &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt;.</source>
          <target state="translated">P1 값이 0이 아닌 경우, SQLITE_NULLEQ가 &lt;a href=&quot;opcode#Ne&quot;&gt;Ne&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; 에 설정되어 있어도 NULL 값이 동일하게 비교되지 않도록 MEM_Cleared 플래그도 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14a9a47b078e93cd304b6691cdab49407396c8d" translate="yes" xml:space="preserve">
          <source>If the P3 value is non-zero, then the table referred to must be an intkey table (an SQL table, not an index). In this case the row change count is incremented by the number of rows in the table being cleared. If P3 is greater than zero, then the value stored in register P3 is also incremented by the number of rows in the table being cleared.</source>
          <target state="translated">P3 값이 0이 아닌 경우 참조되는 테이블은 intkey 테이블 (인덱스가 아닌 SQL 테이블)이어야합니다. 이 경우, 행 변경 계수는 지워지는 테이블의 행 수만큼 증가합니다. P3이 0보다 크면 레지스터 P3에 저장된 값도 지워지는 테이블의 행 수만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d8742c4d987b7b8bb8b01f7cdaee658b0bce0f67" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is followed by a collation-sequence name, then all indices in all attached databases that use the named collation sequences are recreated.</source>
          <target state="translated">REINDEX 키워드 뒤에 데이터 정렬 시퀀스 이름이 있으면 이름 지정된 데이터 정렬 시퀀스를 사용하는 연결된 모든 데이터베이스의 모든 인덱스가 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="89611a3566f7e2d206b997930c668d8b59f61d02" translate="yes" xml:space="preserve">
          <source>If the REINDEX keyword is not followed by a collation-sequence or database object identifier, then all indices in all attached databases are rebuilt.</source>
          <target state="translated">REINDEX 키워드 뒤에 데이터 정렬 순서 또는 데이터베이스 오브젝트 ID가 없으면 첨부 된 모든 데이터베이스의 모든 색인이 재 빌드됩니다.</target>
        </trans-unit>
        <trans-unit id="95360c5e4a315542249137c79e8a2d6b511f7fdc" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;a non-aggregate query&lt;/b&gt;, then each expression in the result expression list is evaluated for each row in the dataset filtered by the WHERE clause.</source>
          <target state="translated">SELECT 문이 &lt;b&gt;집계되지 않은 조회&lt;/b&gt; 인 경우 결과 표현식 목록의 각 표현식은 WHERE 절로 필터링 된 데이터 세트의 각 행에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="869026a04188f9191fbf03ed77ea46ac1ecc8cb4" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query with a GROUP BY&lt;/b&gt; clause, then each of the expressions specified as part of the GROUP BY clause is evaluated for each row of the dataset. Each row is then assigned to a &quot;group&quot; based on the results; rows for which the results of evaluating the GROUP BY expressions are the same get assigned to the same group. For the purposes of grouping rows, NULL values are considered equal. The usual rules for &lt;a href=&quot;datatype3#collation&quot;&gt;selecting a collation sequence&lt;/a&gt; with which to compare text values apply when evaluating expressions in a GROUP BY clause. The expressions in the GROUP BY clause do &lt;em&gt;not&lt;/em&gt; have to be expressions that appear in the result. The expressions in a GROUP BY clause may not be aggregate expressions.</source>
          <target state="translated">SELECT 문이 &lt;b&gt;GROUP BY&lt;/b&gt; 절이 &lt;b&gt;있는 집계 쿼리 인 경우 GROUP BY&lt;/b&gt; 절의 일부로 지정된 각 표현식은 데이터 세트의 각 행에 대해 평가됩니다. 그런 다음 각 행은 결과에 따라 &quot;그룹&quot;에 할당됩니다. GROUP BY 표현식 평가 결과가 동일한 행이 동일한 그룹에 지정됩니다. 행을 그룹화하기 위해 NULL 값은 동일한 것으로 간주됩니다. GROUP BY 절에서 표현식을 평가할 때 텍스트 값을 비교할 &lt;a href=&quot;datatype3#collation&quot;&gt;데이터 정렬 순서&lt;/a&gt; 를 선택하는 일반적인 규칙이 적용됩니다. GROUP BY 절의 표현식은 결과에 나타나는 표현식 일 필요는 &lt;em&gt;없습니다&lt;/em&gt; . GROUP BY 절의 표현식은 집계 표현식이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f32b910ff370c514af729f0255dcd885c666376" translate="yes" xml:space="preserve">
          <source>If the SELECT statement is &lt;b&gt;an aggregate query without a GROUP BY&lt;/b&gt; clause, then each aggregate expression in the result-set is evaluated once across the entire dataset. Each non-aggregate expression in the result-set is evaluated once for an arbitrarily selected row of the dataset. The same arbitrarily selected row is used for each non-aggregate expression. Or, if the dataset contains zero rows, then each non-aggregate expression is evaluated against a row consisting entirely of NULL values.</source>
          <target state="translated">SELECT 문이 &lt;b&gt;GROUP BY&lt;/b&gt; 절이 &lt;b&gt;없는 집계 쿼리 인&lt;/b&gt; 경우 결과 집합의 각 집계 식은 전체 데이터 집합에서 한 번 평가됩니다. 결과 집합의 각 집계되지 않은 식은 임의로 선택된 데이터 집합의 행에 대해 한 번 평가됩니다. 각 집계되지 않은 식에 대해 임의로 임의로 선택한 행이 사용됩니다. 또는 데이터 집합에 0 개의 행이 포함 된 경우 집계되지 않은 각 식은 모두 NULL 값으로 구성된 행에 대해 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="14209330d1f571e7543dcd8d5633bd2d841dd6e1" translate="yes" xml:space="preserve">
          <source>If the SELECT statement specified as part of the CREATE VIRTUAL TABLE command returns five columns, then the final column is used for application context only. Swarmvtab does not use this value at all, except that it is passed after &amp;lt;database-name&amp;gt; to both the openclose and missing functions, if specified. In other words, instead of invoking the functions as described above, if the &quot;context&quot; column is present swarmvtab instead invokes:</source>
          <target state="translated">CREATE VIRTUAL TABLE 명령의 일부로 지정된 SELECT 문이 5 개의 열을 리턴하면 최종 열은 응용 프로그램 컨텍스트에만 사용됩니다. Swarmvtab은이 값이 &amp;lt;database-name&amp;gt; 다음에 지정된 경우 openclose 및 missing 함수 둘 다에 전달된다는 점을 제외하고는이 값을 전혀 사용하지 않습니다. 즉, 위에서 설명한대로 함수를 호출하는 대신 &quot;컨텍스트&quot;열이 있으면 swarmvtab이 대신 호출합니다.</target>
        </trans-unit>
        <trans-unit id="40411dedc1ef7864197c263597ddfac1b246cd97" translate="yes" xml:space="preserve">
          <source>If the SQL COMMIT command turns autocommit on and the autocommit logic then tries to commit change but fails because some other process is holding a SHARED lock, then autocommit is turned back off automatically. This allows the user to retry the COMMIT at a later time after the SHARED lock has had an opportunity to clear.</source>
          <target state="translated">SQL COMMIT 명령이 자동 커미트를 켜고 자동 커미트 논리가 변경을 커미트하려고 시도하지만 다른 프로세스가 SHARED 잠금을 보유하여 실패하면 자동 커미트가 자동으로 다시 꺼집니다. 이를 통해 사용자는 SHARED 잠금이 해제 된 후 나중에 COMMIT를 재 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="507b41df5b9644d0a599bc2c2ba64c3ea6d21fd9" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">실행중인 SQL 문이 데이터를 리턴하면 호출자가 새 데이터 행을 처리 할 준비가 될 때마다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 가 리턴됩니다. &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;열 액세스 기능을&lt;/a&gt; 사용하여 값에 액세스 할 수 있습니다 . 다음 데이터 행을 검색하기 위해 sqlite3_step ()이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ae2787ab5fa2a6425b73b07a4b0ad6b9f341262a" translate="yes" xml:space="preserve">
          <source>If the SQL statement being executed returns any data, then &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; is returned each time a new row of data is ready for processing by the caller. The values may be accessed using the &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt;. sqlite3_step() is called again to retrieve the next row of data.</source>
          <target state="translated">실행중인 SQL 문이 데이터를 리턴하면 호출자가 새 데이터 행을 처리 할 준비가 될 때마다 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 가 리턴됩니다. &lt;a href=&quot;column_blob&quot;&gt;열 액세스 기능을&lt;/a&gt; 사용하여 값에 액세스 할 수 있습니다 . 다음 데이터 행을 검색하기 위해 sqlite3_step ()이 다시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="95d391fa1b14c12c13b7ff2232dd79f1ad704028" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">SQL 문이 현재 유효한 행을 가리 키지 않거나 열 색인이 범위를 벗어나면 결과가 정의되지 않습니다. 이 루틴은 가장 최근에 호출 할 때만 호출 할 수 있습니다.&lt;a href=&quot;#sqlite3_step&quot;&gt; sqlite3_step ()에&lt;/a&gt;&lt;a href=&quot;#SQLITE_ABORT&quot;&gt; SQLITE_ROW&lt;/a&gt; 를 리턴 하고 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 이후에 호출 되지 않은 . &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 이후 또는 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 이외의 것을 리턴 한 후 이러한 루틴이 호출 되면 결과가 정의되지 않습니다. 만약 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는&lt;a href=&quot;#sqlite3_finalize&quot;&gt; sqlite3_finalize ()&lt;/a&gt;이 루틴 중 하나가 보류중인 동안 다른 스레드에서 호출 된 후 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34c305f0b8de32e5d504a58326a82216502c31ad" translate="yes" xml:space="preserve">
          <source>If the SQL statement does not currently point to a valid row, or if the column index is out of range, the result is undefined. These routines may only be called when the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; and neither &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; nor &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; have been called subsequently. If any of these routines are called after &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or after &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; has returned something other than &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, the results are undefined. If &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; are called from a different thread while any of these routines are pending, then the results are undefined.</source>
          <target state="translated">SQL 문이 현재 유효한 행을 가리 키지 않거나 열 색인이 범위를 벗어나면 결과가 정의되지 않습니다. 이 루틴은 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 가장 최근 호출이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 를 리턴 한 경우에만 호출 될 수 있습니다. 하지도 및&lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 가 이후에 호출 되지 . &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 이후 또는 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 이외의 것을 리턴 한 후 이러한 루틴이 호출 되면 결과가 정의되지 않습니다. 만약 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는&lt;a href=&quot;finalize&quot;&gt; sqlite3_finalize ()&lt;/a&gt;이 루틴 중 하나가 보류중인 동안 다른 스레드에서 호출 된 후 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="975432fbe3b7571414ef3444c9bae0dbbb675815" translate="yes" xml:space="preserve">
          <source>If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will invoke sqlite3_free() on the serialization buffer when the database connection closes. If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then SQLite will try to increase the buffer size using sqlite3_realloc64() if writes on the database cause it to grow larger than M bytes.</source>
          <target state="translated">SQLITE_DESERIALIZE_FREEONCLOSE 비트가 F로 설정된 경우, SQLite는 데이터베이스 연결이 닫힐 때 직렬화 버퍼에서 sqlite3_free ()를 호출합니다. SQLITE_DESERIALIZE_RESIZEABLE 비트가 설정되면 SQLite는 sqlite3_realloc64 ()를 사용하여 버퍼 크기를 늘리려 고 시도합니다. 데이터베이스에 쓰면 M 바이트보다 커집니다.</target>
        </trans-unit>
        <trans-unit id="ea23bbe6e0f5cd400c470a465a873018f1aa3b8b" translate="yes" xml:space="preserve">
          <source>If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or reg(P3) is NULL then the take the jump. If the SQLITE_JUMPIFNULL bit is clear then fall through if either operand is NULL.</source>
          <target state="translated">P5의 SQLITE_JUMPIFNULL 비트가 설정되고 reg (P1) 또는 reg (P3)이 NULL이면 점프를 수행합니다. SQLITE_JUMPIFNULL 비트가 지워지면 피연산자 중 하나가 NULL이면 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="d13a5c515dea25bad07a7535880df286b04090a5" translate="yes" xml:space="preserve">
          <source>If the SQLite library is compiled without the NDEBUG preprocessor macro, then the PRAGMA &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace &lt;/a&gt; causes the VDBE to trace the execution of programs. Though this feature was originally intended for testing and debugging, it can also be useful in learning about how the VDBE operates. Use &quot;&lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt;&quot; to turn tracing on and &quot;&lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt;&quot; to turn tracing back off. Like this:</source>
          <target state="translated">SQLite 라이브러리가 &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;NDEBUG&lt;/a&gt; 프리 프로세서 매크로없이 컴파일 된 경우 PRAGMA vdbe_trace 는 VDBE가 프로그램 실행을 추적하게합니다. 이 기능은 원래 테스트 및 디버깅을위한 것이었지만 VDBE 작동 방식을 배우는 데 유용 할 수도 있습니다. &quot; &lt;code&gt;PRAGMA vdbe_trace=ON;&lt;/code&gt; &quot;을 사용하여 추적을 켜고 &quot; &lt;code&gt;PRAGMA vdbe_trace=OFF&lt;/code&gt; &quot;를 사용하여 추적을 다시 끕니다. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="2b55abf3573b260c179e3130856801dc205be5f3" translate="yes" xml:space="preserve">
          <source>If the UNIQUE keyword appears between CREATE and INDEX then duplicate index entries are not allowed. Any attempt to insert a duplicate entry will result in an error. For the purposes of unique indices, all NULL values are considered different from all other NULL values and are thus unique. This is one of the two possible interpretations of the SQL-92 standard (the language in the standard is ambiguous) and is the interpretation followed by PostgreSQL, MySQL, Firebird, and Oracle. Informix and Microsoft SQL Server follow the other interpretation of the standard.</source>
          <target state="translated">CREATE와 INDEX 사이에 UNIQUE 키워드가 나타나면 중복 인덱스 항목이 허용되지 않습니다. 중복 항목을 삽입하려고하면 오류가 발생합니다. 고유 인덱스의 목적으로, 모든 NULL 값은 다른 모든 NULL 값과 다른 것으로 간주되므로 고유합니다. 이것은 SQL-92 표준에 대한 두 가지 가능한 해석 중 하나이며 (표준의 언어는 모호합니다) PostgreSQL, MySQL, Firebird 및 Oracle이 따르는 해석입니다. Informix 및 Microsoft SQL Server는 표준의 다른 해석을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="302753955d8021d9d751890a4a62678a7bd1dc4c" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">UPDATE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 충돌 처리기 함수가 두 번째 인수로 전달 된 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; 와 함께 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴 한 후 UPDATE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="40c8985574cc4136a7a40f15001ace597cd448e0" translate="yes" xml:space="preserve">
          <source>If the UPDATE operation is attempted, but SQLite returns SQLITE_CONSTRAINT, the conflict-handler function is invoked with &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt; passed as the second argument. This includes the case where the UPDATE operation is attempted after an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">UPDATE 조작이 시도되었지만 SQLite가 SQLITE_CONSTRAINT를 리턴하면 충돌 핸들러 함수가 다음과 같이 호출됩니다. &lt;a href=&quot;c_changeset_conflict&quot;&gt;&lt;/a&gt;두 번째 인수로 전달 된 SQLITE_CHANGESET_CONSTRAINT. 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴 한 후 UPDATE 조작이 시도 된 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="751229ce68d5f9fb206ae67bb99718de4be423dd" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement does not have a WHERE clause, all rows in the table are modified by the UPDATE. Otherwise, the UPDATE affects only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression is true&lt;/a&gt;. It is not an error if the WHERE clause does not evaluate to true for any row in the table - this just means that the UPDATE statement affects zero rows.</source>
          <target state="translated">UPDATE 문에 WHERE 절이 없으면 테이블의 모든 행이 UPDATE에 의해 수정됩니다. 그렇지 않으면 UPDATE는 WHERE 절 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식이 true 인&lt;/a&gt; 행에만 영향을줍니다 . WHERE 절이 테이블의 행에 대해 true로 평가되지 않으면 오류가 아닙니다. 이는 UPDATE 문이 0 개의 행에 영향을 준다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="074562fe8dfabc7ba122942fddf559f05fa48e31" translate="yes" xml:space="preserve">
          <source>If the UPDATE statement has no ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are assembled in an arbitrary order before applying the LIMIT and OFFSET clauses to determine which are actually updated.</source>
          <target state="translated">UPDATE 문에 ORDER BY 절이없는 경우 LIMIT 절이 없을 때 갱신 될 모든 행은 LIMIT 및 OFFSET 절을 적용하기 전에 임의의 순서로 어셈블되어 실제로 갱신되는 행을 판별합니다.</target>
        </trans-unit>
        <trans-unit id="0ee1b94b95429e744f462704efa364a50f2413f6" translate="yes" xml:space="preserve">
          <source>If the WAL-index is implemented as a memory-mapped file and that file is read-only to the first thread to connect, then that thread creates an private heap-memory ersazt WAL-index and runs the recovery routine to populate that private WAL-index. The same data results, but it is held privately rather that being written into the public shared memory area.</source>
          <target state="translated">WAL- 인덱스가 메모리 매핑 된 파일로 구현되고 해당 파일이 연결할 첫 번째 스레드에 대해 읽기 전용 인 경우 해당 스레드는 개인 힙 메모리 ersazt WAL- 인덱스를 작성하고 복구 루틴을 실행하여 해당 개인 WAL을 채 웁니다. -인덱스. 동일한 데이터가 생성되지만 공용 공유 메모리 영역에 기록되는 것이 아니라 개인적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7648c2d70dafce18f6cb4ef634247a503d61eeca" translate="yes" xml:space="preserve">
          <source>If the WHERE clause evaluates to FALSE, then skip the steps that follow and continue to the next record.</source>
          <target state="translated">WHERE 절이 FALSE로 평가되면 다음 단계를 건너 뛰고 다음 레코드로 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="37f61285fabc2a1caf8acf5c9c00c9ccc80b5f28" translate="yes" xml:space="preserve">
          <source>If the WHERE clause is not present, all records in the table are deleted. If a WHERE clause is supplied, then only those rows for which the WHERE clause &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;boolean expression&lt;/a&gt; is true are deleted. Rows for which the expression is false or NULL are retained.</source>
          <target state="translated">WHERE 절이 없으면 테이블의 모든 레코드가 삭제됩니다. WHERE 절이 제공되면 WHERE 절이 &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;부울 표현식 인&lt;/a&gt; 행만 이 true 인 삭제됩니다. 표현식이 false이거나 NULL 인 행은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7ecdfb78c909bf7386760f4b8a9af44a0acb2a2c" translate="yes" xml:space="preserve">
          <source>If the WHERE clause of a query contains an OR expression, then SQLite might use the &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; strategy (also known as the &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR optimization&lt;/a&gt;). In this case there will be single top-level record for the search, with two sub-records, one for each index:</source>
          <target state="translated">쿼리의 WHERE 절에 OR 표현식이 포함 된 경우 SQLite는 &lt;a href=&quot;queryplanner#or_in_where&quot;&gt;&quot;OR by union&quot;&lt;/a&gt; 전략 ( &lt;a href=&quot;optoverview#or_opt&quot;&gt;OR 최적화&lt;/a&gt; 라고도 함)을 사용할 수 있습니다. )을 사용할 수 있습니다. 이 경우 검색을위한 단일 최상위 레코드가 있고 각 색인마다 하나씩 두 개의 하위 레코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="74877c4dea96c98f4b3c0b669711d0dd7770d2b9" translate="yes" xml:space="preserve">
          <source>If the _HAVE_SQLITE_CONFIG_H macro is defined then the SQLite source code will attempt to #include a file named &quot;config.h&quot;. The &quot;config.h&quot; file usually contains other configuration options, especially &quot;HAVE_</source>
          <target state="translated">_HAVE_SQLITE_CONFIG_H 매크로가 정의되면 SQLite 소스 코드는 &quot;config.h&quot;라는 파일을 #include 시도합니다. &quot;config.h&quot;파일에는 일반적으로 다른 구성 옵션, 특히 &quot;HAVE_</target>
        </trans-unit>
        <trans-unit id="558abcd908b311140ea78da82869118d13cb3c75" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">조치 코드가 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; 이고 콜백이 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하는 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴 된 경우 읽었던 테이블 컬럼 대신 NULL 값을 대체 하도록 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 명령문이 구성됩니다 . &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 복귀 테이블의 개별 컬럼 신뢰되지 않은 사용자 액세스를 거부 할 수있다. 테이블이 &lt;a href=&quot;lang_select&quot;&gt;SELECT에&lt;/a&gt; 의해 참조 되지만 해당 테이블에서 열 값이 추출되지 않는 경우 (예 : &quot;SELECT count (*) FROM 탭&quot;과 같은 쿼리) &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_READ&lt;/a&gt; 해당 테이블에 대해 열 이름이 권한 부 여기 콜백이 한 번 호출됩니다. 빈 문자열입니다. 조치 코드가 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE 인 경우&lt;/a&gt;콜백이 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 반환 하면 &lt;a href=&quot;lang_delete&quot;&gt;DELETE &lt;/a&gt; 조작이 진행되지만&lt;a href=&quot;lang_delete#truncateopt&quot;&gt;자르기 최적화&lt;/a&gt; 가 비활성화되고 모든 행이 개별적으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="551e501bb088fee5fee1641a8f77e7fc3633f5dd" translate="yes" xml:space="preserve">
          <source>If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; statement is constructed to substitute a NULL value in place of the table column that would have been read if &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; had been returned. The &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; return can be used to deny an untrusted user access to individual columns of a table. When a table is referenced by a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; but no column values are extracted from that table (for example in a query like &quot;SELECT count(*) FROM tab&quot;) then the &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; authorizer callback is invoked once for that table with a column name that is an empty string. If the action code is &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; and the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; then the &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; operation proceeds but the &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;truncate optimization&lt;/a&gt; is disabled and all rows are deleted individually.</source>
          <target state="translated">조치 코드가 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; 이고 콜백이 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하는 경우 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴 된 경우 읽었던 테이블 컬럼 대신 NULL 값을 대체 하도록 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 명령문이 구성됩니다 . &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 복귀 테이블의 개별 컬럼 신뢰되지 않은 사용자 액세스를 거부 할 수있다. 테이블이 &lt;a href=&quot;../lang_select&quot;&gt;SELECT에&lt;/a&gt; 의해 참조 되지만 해당 테이블에서 열 값이 추출되지 않는 경우 (예 : &quot;SELECT count (*) FROM 탭&quot;과 같은 쿼리에서) 해당 테이블에 대해 열 이름이 있는 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_READ&lt;/a&gt; 권한 부 여기 콜백이 한 번 호출됩니다. 빈 문자열입니다. 조치 코드가 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE 인 경우&lt;/a&gt;콜백이 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하면 &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 조작이 진행되지만 &lt;a href=&quot;../lang_delete#truncateopt&quot;&gt;절단 최적화&lt;/a&gt; 는 사용 불가능하고 모든 행이 개별적으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="e48946c22fc154fe87cb537c121e425dbb9574d0" translate="yes" xml:space="preserve">
          <source>If the application does not use triggers or views, then disable the unused capabilities using:</source>
          <target state="translated">애플리케이션이 트리거 또는보기를 사용하지 않는 경우 다음을 사용하여 사용하지 않는 기능을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="f5d26d8716b0cdd9f988973fac2e73b815006603" translate="yes" xml:space="preserve">
          <source>If the application does use triggers or views, then use queries to scan the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table to verify that the triggers and views found there are expected, that there are no surplus triggers or views, existing triggers and views have not been tampered with, and that no existing ordinary tables have been replaced by malicious views.</source>
          <target state="translated">애플리케이션이 트리거 또는 뷰를 사용하는 경우 쿼리를 사용하여 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; 테이블 을 스캔하여 트리거 및 뷰가 예상되고, 여분의 트리거 또는 뷰가 없는지, 기존 트리거 및 뷰가 변경되지 않았으며, 기존의 일반 테이블은 악성 뷰로 대체되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2469e0f7ca599347e4594642b1d8b0b3f0287081" translate="yes" xml:space="preserve">
          <source>If the application invokes &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt;) on the database connection prior to closing, then the final checkpoint is still run but the WAL and WAL-index files are not deleted as they normally would be. This leaves the database in a state that allows other processes without write permission on the database, WAL, or WAL-index files to open the database read-only. If the WAL and WAL-index files are missing, then a process that lacks permission to create and initialize those files will not be able to open the database, unless the database is designated as immutable using the &lt;a href=&quot;uri#uriimmutable&quot;&gt;immutable query parameter&lt;/a&gt;.</source>
          <target state="translated">애플리케이션 이 닫기 전에 데이터베이스 연결에서 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpersistwal&quot;&gt;SQLITE_FCNTL_PERSIST_WAL&lt;/a&gt; )을 호출 하면 최종 체크 포인트는 여전히 실행되지만 WAL 및 WAL 색인 파일은 정상적으로 삭제되지 않습니다. 이렇게하면 데이터베이스, WAL 또는 WAL- 인덱스 파일에 대한 쓰기 권한이없는 다른 프로세스가 데이터베이스를 읽기 전용으로 열 수있는 상태가됩니다. WAL 및 WAL- 인덱스 파일이 누락 된 경우, &lt;a href=&quot;uri#uriimmutable&quot;&gt;불변 쿼리 매개 변수를&lt;/a&gt; 사용하여 데이터베이스를 불변으로 지정하지 않으면 해당 파일을 작성하고 초기화 할 권한이없는 프로세스는 데이터베이스를 열 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0623d9575995bdb9d6c267b0da83f975d16d83ea" translate="yes" xml:space="preserve">
          <source>If the application is designed to manage data in small pieces, then the database should never contain any large strings or BLOBs and hence element 1 above should not be a factor. If the database does contain large strings or BLOBs, they should be read using &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; and rows that contain the large strings or BLOBs should never be update by any means other than &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt;. Otherwise, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; routine will need to read the entire row into contiguous memory at some point, and that will involve at least one large memory allocation.</source>
          <target state="translated">응용 프로그램이 작은 조각으로 데이터를 관리하도록 설계된 경우 데이터베이스는 큰 문자열이나 BLOB를 포함해서는 안되므로 위의 요소 1은 요소가되어서는 안됩니다. 데이터베이스에 큰 문자열 또는 BLOB가 포함 된 경우 &lt;a href=&quot;c3ref/blob&quot;&gt;증분 BLOB I / O를&lt;/a&gt; 사용하여 읽어야 하며 큰 문자열 또는 BLOB를 포함하는 행은 &lt;a href=&quot;c3ref/blob&quot;&gt;증분 BLOB I / O&lt;/a&gt; 이외의 다른 방법으로 업데이트해서는 안됩니다 . 그렇지 않으면, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 루틴은 어느 시점에서 전체 행을 연속 메모리로 읽어야하며, 이는 적어도 하나의 큰 메모리 할당을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d0ebb1eaae39f6046644fb7a5c8e50db080966a3" translate="yes" xml:space="preserve">
          <source>If the application or host computer crashes before the transaction completes, then the rollback journal or write-ahead log contains information needed to restore the main database file to a consistent state. When a rollback journal or write-ahead log contains information necessary for recovering the state of the database, they are called a &quot;hot journal&quot; or &quot;hot WAL file&quot;. Hot journals and WAL files are only a factor during error recovery scenarios and so are uncommon, but they are part of the state of an SQLite database and so cannot be ignored. This document defines the format of a rollback journal and the write-ahead log file, but the focus is on the main database file.</source>
          <target state="translated">트랜잭션이 완료되기 전에 응용 프로그램 또는 호스트 컴퓨터가 충돌하면 롤백 저널 또는 미리 쓰기 로그에는 기본 데이터베이스 파일을 일관된 상태로 복원하는 데 필요한 정보가 포함됩니다. 롤백 저널 또는 미리 쓰기 로그에 데이터베이스 상태를 복구하는 데 필요한 정보가 포함 된 경우이를 &quot;핫 저널&quot;또는 &quot;핫 WAL 파일&quot;이라고합니다. 핫 저널 및 WAL 파일은 오류 복구 시나리오의 한 요인 일 뿐이므로 드문 일이지만 SQLite 데이터베이스 상태의 일부이므로 무시할 수 없습니다. 이 문서는 롤백 저널 및 미리 쓰기 로그 파일의 형식을 정의하지만 주요 데이터베이스 파일에 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="2a5d41f54973dce5874420b1200abe91d1314dc8" translate="yes" xml:space="preserve">
          <source>If the application uses &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; that have side effects, then it is recommended to set the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag on those SQL functions to prevent them from being used inside triggers and views. To illustrate the importance of this flag, consider an application that implements an SQL function &quot;send_money(...)&quot;. Without the SQLITE_DIRECTONLY flag, an attacker might be able to add a trigger or view that uses that custom function, then trick a high-privilege application to run an otherwise harmless query that invokes that malicious trigger or view. The SQLITE_DIRECTONLY flag prevents the attack by requiring the &quot;send_money()&quot; function to be invoked directly by the application, rather than indirectly through a trigger or view.</source>
          <target state="translated">애플리케이션 이 부작용이있는 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 를 사용하는 경우 해당 SQL 함수 에서 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 플래그 를 설정하여 트리거 및 뷰에서 사용되지 않도록하는 것이 좋습니다 . 이 플래그의 중요성을 설명하기 위해 SQL 함수 &quot;send_money (...)&quot;를 구현하는 응용 프로그램을 고려하십시오. SQLITE_DIRECTONLY 플래그가 없으면 공격자는 해당 사용자 지정 함수를 사용하는 트리거 또는보기를 추가 한 다음 높은 권한의 응용 프로그램을 속여 악의적 인 트리거 또는보기를 호출하는 무해한 쿼리를 실행할 수 있습니다. SQLITE_DIRECTONLY 플래그는 &quot;send_money ()&quot;함수를 트리거 또는 뷰를 통해 간접적으로 실행하지 않고 애플리케이션에서 직접 호출하도록하여 공격을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d6f9cd1b9ea5044b899607d0f8509b7399b72066" translate="yes" xml:space="preserve">
          <source>If the application wanted to keep all content in memory, it could continue reading and parsing the other pages using a background thread after drawing the first page. Or, since reading from SQLite is so efficient, the application might instead choose to reduce its memory footprint and only keep a single slide in memory at a time. Or maybe it keeps the current slide and the next slide in memory, to facility rapid transitions to the next slide.</source>
          <target state="translated">응용 프로그램이 모든 내용을 메모리에 유지하려는 경우 첫 번째 페이지를 그린 후 백그라운드 스레드를 사용하여 다른 페이지를 읽고 구문 분석 할 수 있습니다. 또는 SQLite에서 읽는 것이 매우 효율적이기 때문에 응용 프로그램은 메모리 공간을 줄이고 한 번에 한 슬라이드 만 메모리에 유지하도록 선택할 수 있습니다. 또는 현재 슬라이드와 다음 슬라이드를 메모리에 유지하여 다음 슬라이드로 빠르게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8569a113bc3212a8fdd578bf6c990f890a161761" translate="yes" xml:space="preserve">
          <source>If the argument N is positive then the suggested cache size is set to N. If the argument N is negative, then the number of cache pages is adjusted to be a number of pages that would use approximately abs(N*1024) bytes of memory based on the current page size. SQLite remembers the number of pages in the page cache, not the amount of memory used. So if you set the cache size using a negative number and subsequently change the page size (using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command) then the maximum amount of cache memory will go up or down in proportion to the change in page size.</source>
          <target state="translated">인수 N이 양수이면 제안 된 캐시 크기는 N으로 설정됩니다. 인수 N이 음수이면 캐시 페이지 수는 대략 abs (N * 1024) 바이트의 메모리를 사용하는 페이지 수로 조정됩니다. 현재 페이지 크기를 기준으로합니다. SQLite는 사용 된 메모리 양이 아니라 페이지 캐시의 페이지 수를 기억합니다. 따라서 음수를 사용하여 캐시 크기를 설정 한 다음 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; 명령을 사용하여 페이지 크기를 변경 하면 최대 캐시 메모리 양이 페이지 크기 변경에 비례하여 증가 또는 감소합니다.</target>
        </trans-unit>
        <trans-unit id="333007bde9d13022c1e70f3f252829b77ea3504a" translate="yes" xml:space="preserve">
          <source>If the argument N is zero then the soft heap limit is disabled.</source>
          <target state="translated">인수 N이 0이면 소프트 힙 한계가 사용 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="0910062f14fed63da9341471516f0b8c2feb398e" translate="yes" xml:space="preserve">
          <source>If the argument X to json(X) contains JSON objects with duplicate labels, then it is undefined whether or not the duplicates are preserved. The current implementation preserves duplicates. However, future enhancements to this routine may choose to silently remove duplicates.</source>
          <target state="translated">X ~ json (X) 인수에 중복 레이블이있는 JSON 오브젝트가 포함 된 경우 중복이 보존되는지 여부는 정의되지 않습니다. 현재 구현은 중복을 유지합니다. 그러나이 루틴에 대한 향후 개선 사항은 중복을 자동으로 제거하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f833aefc23dc66bc8a11fd873780dad93c32799" translate="yes" xml:space="preserve">
          <source>If the argument is an empty string then the authorizer is disabled. If the argument is omitted, then the current authorizer is returned.</source>
          <target state="translated">인수가 빈 문자열이면 권한 부여 프로그램이 비활성화됩니다. 인수가 생략되면 현재 권한 부여자가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="db2e11d8e987617a2ede3ca5cb77cc0207ab30da" translate="yes" xml:space="preserve">
          <source>If the argument to %Q is a null pointer then the output is an unquoted &quot;NULL&quot;. In other words, a null pointer generates an SQL NULL, and a non-null pointer generates a valid SQL string literal. If the argument to %q is a null pointer then no output is generated. Thus a null-pointer to %q is the same as an empty string.</source>
          <target state="translated">% Q에 대한 인수가 널 포인터 인 경우 출력은 인용되지 않은 &quot;NULL&quot;입니다. 즉, 널 포인터는 SQL NULL을 생성하고 널이 아닌 포인터는 유효한 SQL 문자열 리터럴을 생성합니다. % q에 대한 인수가 널 포인터이면 출력이 생성되지 않습니다. 따라서 % q에 대한 널 포인터는 빈 문자열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="34bfefe0d198d1d0315cf64a45912620ff3af0d6" translate="yes" xml:space="preserve">
          <source>If the argument to &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; is negative N, that means to use approximately -1024*N bytes of memory for the page cache regardless of the page size.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size에&lt;/a&gt; 대한 인수가 가 음수 N이면 페이지 크기에 관계없이 페이지 캐시에 약 -1024 * N 바이트의 메모리를 사용한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="ad1260c6e1a01baa74d5f905fe5850603affd484" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_enter(), sqlite3_mutex_try(), or sqlite3_mutex_leave() is a NULL pointer, then all three routines behave as no-ops.</source>
          <target state="translated">sqlite3_mutex_enter (), sqlite3_mutex_try () 또는 sqlite3_mutex_leave ()에 대한 인수가 NULL 포인터이면 세 루틴 모두 no-ops로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0142caf16fb3155af68268c72b44fbf8e770bbff" translate="yes" xml:space="preserve">
          <source>If the argument to sqlite3_mutex_held() is a NULL pointer then the routine should return 1. This seems counter-intuitive since clearly the mutex cannot be held if it does not exist. But the reason the mutex does not exist is because the build is not using mutexes. And we do not want the assert() containing the call to sqlite3_mutex_held() to fail, so a non-zero return is the appropriate thing to do. The sqlite3_mutex_notheld() interface should also return 1 when given a NULL pointer.</source>
          <target state="translated">sqlite3_mutex_held ()에 대한 인수가 NULL 포인터 인 경우 루틴은 1을 리턴해야합니다. 뮤텍스가 존재하지 않으면 명확하게 보유 할 수 없으므로 반 직관적으로 보입니다. 그러나 뮤텍스가 존재하지 않는 이유는 빌드가 뮤텍스를 사용하지 않기 때문입니다. 그리고 sqlite3_mutex_held ()에 대한 호출을 포함하는 assert ()가 실패하는 것을 원하지 않으므로 0이 아닌 리턴이 적절합니다. sqlite3_mutex_notheld () 인터페이스는 NULL 포인터가 주어지면 1을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a14ce7fd473c10953375f9ccbf76e06b28005ef4" translate="yes" xml:space="preserve">
          <source>If the array variable name is omitted or is the empty string, then the value of each column is stored in a variable with the same name as the column itself. For example:</source>
          <target state="translated">배열 변수 이름이 생략되거나 빈 문자열 인 경우 각 열의 값은 열 자체와 이름이 같은 변수에 저장됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac696fda1c1264eced84b7c7d2919bb500892965" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">다른 제한 조건 위반 (예 : NOT NULL 또는 UNIQUE)으로 인해 행 삽입 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONSTRAINT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_CHANGESET_ABORT&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 INSERT 조작이 재 시도되는 경우가 여기에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="00b4296a5ab760c82790fc716c15427ea1f6520d" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because of some other constraint violation (e.g. NOT NULL or UNIQUE), the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT&lt;/a&gt;. This includes the case where the INSERT operation is re-attempted because an earlier call to the conflict handler function returned &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE&lt;/a&gt;.</source>
          <target state="translated">다른 제한 조건 위반 (예 : NOT NULL 또는 UNIQUE)으로 인해 행 삽입 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONSTRAINT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 . 충돌 핸들러 함수에 대한 이전 호출이 &lt;a href=&quot;c_changeset_abort&quot;&gt;SQLITE_CHANGESET_REPLACE를&lt;/a&gt; 리턴했기 때문에 INSERT 조작이 재 시도되는 경우가 여기에 포함됩니다..</target>
        </trans-unit>
        <trans-unit id="1a0b7bf9240c877d42c55de96b224187eca54a50" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 동일한 기본 키 값을 가진 행이 이미 포함되어 행을 삽입하려는 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="86e563d45d385632baebf3e72388be8c4af6aec3" translate="yes" xml:space="preserve">
          <source>If the attempt to insert the row fails because the database already contains a row with the same primary key values, the conflict handler function is invoked with the second argument set to &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;.</source>
          <target state="translated">데이터베이스에 동일한 기본 키 값을 가진 행이 이미 포함되어 행을 삽입하려는 시도가 실패하면 두 번째 인수가 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT로&lt;/a&gt; 설정되어 충돌 핸들러 함수가 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3629ea18c991de1dc5f5b9e0680718c68964bd44" translate="yes" xml:space="preserve">
          <source>If the bClear argument is non-zero, then the auxiliary data is cleared (set to NULL) before this function returns. In this case the xDelete, if any, is not invoked.</source>
          <target state="translated">bClear 인수가 0이 아닌 경우이 함수가 리턴되기 전에 보조 데이터가 지워집니다 (NULL로 설정 됨). 이 경우 xDelete가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85be6aa821286c3a809817d29ac82866a6650696" translate="yes" xml:space="preserve">
          <source>If the backup process is restarted frequently enough it may never run to completion and the backupDb() function may never return.</source>
          <target state="translated">백업 프로세스가 충분히 자주 다시 시작되면 완료 될 때까지 실행되지 않으며 backupDb () 함수가 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3ecd64439c51685da70c45077d54474b903f89" translate="yes" xml:space="preserve">
          <source>If the base expression is NULL then the result of the CASE is always the result of evaluating the ELSE expression if it exists, or NULL if it does not.</source>
          <target state="translated">기본 표현식이 NULL 인 경우 CASE의 결과는 ELSE 표현식이있는 경우이를 평가 한 결과이며, 그렇지 않은 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="8a427aa0dc34d2b046c1ad51ad7573c594257eb3" translate="yes" xml:space="preserve">
          <source>If the base window has an ORDER BY clause, it is copied into the new window. In this case the new window must not specify an ORDER BY clause. If the base window has no ORDER BY clause, one may be specified as part of the new window definition.</source>
          <target state="translated">기본 창에 ORDER BY 절이 있으면 새 창에 복사됩니다. 이 경우 새 창에 ORDER BY 절을 지정해서는 안됩니다. 기본 창에 ORDER BY 절이 없으면 새 창 정의의 일부로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="119dee4cbf58f5993be5ffddf2563e1e23c3d8e2" translate="yes" xml:space="preserve">
          <source>If the blob handle being closed was opened for read-write access, and if the database is in auto-commit mode and there are no other open read-write blob handles or active write statements, the current transaction is committed. If an error occurs while committing the transaction, an error code is returned and the transaction rolled back.</source>
          <target state="translated">닫힌 blob 핸들이 읽기 / 쓰기 액세스를 위해 열려 있고 데이터베이스가 자동 커미트 모드에 있고 다른 열린 읽기 / 쓰기 blob 핸들이나 활성 쓰기 명령문이없는 경우 현재 트랜잭션이 커미트됩니다. 트랜잭션을 커밋하는 동안 오류가 발생하면 오류 코드가 반환되고 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="a888511d0d42c7a009b52c11f52254e39a8e8777" translate="yes" xml:space="preserve">
          <source>If the blocked connection is attempting to obtain a write-lock on a shared-cache table, and more than one other connection currently holds a read-lock on the same table, then SQLite arbitrarily selects one of the other connections to use as the blocking connection.</source>
          <target state="translated">차단 된 연결이 공유 캐시 테이블에서 쓰기 잠금을 얻으려고 시도하고 있고 하나 이상의 다른 연결이 현재 동일한 테이블에서 읽기 잠금을 보유하는 경우 SQLite는 다른 연결 중 하나를 임의로 차단으로 사용하도록 선택합니다. 연결.</target>
        </trans-unit>
        <trans-unit id="b15e015a6e8222ac8277a814fcfbbc84b5b7b2fa" translate="yes" xml:space="preserve">
          <source>If the branch instruction that implements the &quot;c!=0&quot; test on line 58 is changed into a no-op, then the while-loop will loop forever and the test suite will fail with a time-out. But if that branch is changed into an unconditional jump, then the hash function will always return 0. The problem is that 0 is a valid hash. A hash function that always returns 0 still works in the sense that SQLite still always gets the correct answer. The table-name hash table degenerates into a linked-list and so the table-name lookups that occur while parsing SQL statements might be a little slower, but the end result will be the same.</source>
          <target state="translated">58 행에서 &quot;c! = 0&quot;테스트를 구현하는 분기 명령어가 no-op로 변경되면 while 루프는 영원히 반복되며 테스트 스위트는 시간 초과로 실패합니다. 그러나 해당 분기가 무조건 점프로 변경되면 해시 함수는 항상 0을 반환합니다. 문제는 0이 유효한 해시라는 것입니다. 항상 0을 반환하는 해시 함수는 여전히 SQLite가 항상 정답을 얻는다는 의미에서 작동합니다. 테이블 이름 해시 테이블은 링크 된 목록으로 생성되므로 SQL 문을 구문 분석하는 동안 발생하는 테이블 이름 조회는 약간 느려질 수 있지만 최종 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d10a175cfd1fe16985e295daacc2dcfb3f2982ad" translate="yes" xml:space="preserve">
          <source>If the buffer contains a patchset, then all prior calls to this function on the same changegroup object must also have specified patchsets. Or, if the buffer contains a changeset, so must have the earlier calls to this function. Otherwise, SQLITE_ERROR is returned and no changes are added to the changegroup.</source>
          <target state="translated">버퍼에 패치 세트가 포함 된 경우 동일한 변경 그룹 오브젝트에서이 함수에 대한 모든 이전 호출에도 지정된 패치 세트가 있어야합니다. 또는 버퍼에 변경 세트가 포함 된 경우이 함수에 대한 이전 호출이 있어야합니다. 그렇지 않으면 SQLITE_ERROR가 리턴되고 변경 사항이 변경 그룹에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cba5e39badf94f78fab97af6a07c73e6243cd28" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">통화 중 콜백이 NULL이면 잠금이 발생하면 즉시 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 리턴됩니다. 통화 중 콜백이 NULL이 아닌 경우 두 개의 인수를 사용하여 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b0bd17ec528127c481fd60daa34e2af13ea7150" translate="yes" xml:space="preserve">
          <source>If the busy callback is NULL, then &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; is returned immediately upon encountering the lock. If the busy callback is not NULL, then the callback might be invoked with two arguments.</source>
          <target state="translated">통화 중 콜백이 NULL이면 잠금이 발생하면 즉시 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 가 리턴됩니다. 통화 중 콜백이 NULL이 아닌 경우 두 개의 인수를 사용하여 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afcbf1f3e790adb1bb6040c89a071eb5f4f5a2b5" translate="yes" xml:space="preserve">
          <source>If the busy method is invoked without an argument, the name of the callback procedure last set by the busy method is returned. If no callback procedure has been set, an empty string is returned.</source>
          <target state="translated">busy 메소드가 인수없이 호출되면 busy 메소드가 마지막으로 설정 한 콜백 프로 시저의 이름이 리턴됩니다. 콜백 프로 시저가 설정되지 않은 경우 빈 문자열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="85f5b0357119cb8e1c6a774de7f6ae30085546fa" translate="yes" xml:space="preserve">
          <source>If the cache validate procedure prescribed by H35040 is required and does not prove that the</source>
          <target state="translated">H35040에서 규정 한 캐시 유효성 검사 절차가 필요하지만</target>
        </trans-unit>
        <trans-unit id="854ac2efa118a1d9433a97bc97dd8176f442561c" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35140 fails (due to an IO error or similar), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35140에 의해 요구되는 xAccess () 호출이 실패하면 (IO 오류 또는 이와 유사한 이유로) SQLite는 열려고 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="1c9becc9db0bbc14b6323875b3f39aa5c2a244e7" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35490에 필요한 xAccess () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려고 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="7bd0a091025aae3680b1db643d16d28c98cc6e9b" translate="yes" xml:space="preserve">
          <source>If the call to xAccess() required by H35490 reveals that the journal file is no longer present in the file system, then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35490에 필요한 xAccess () 호출로 저널 파일이 더 이상 파일 시스템에 존재하지 않는 것으로 밝혀지면 SQLite는</target>
        </trans-unit>
        <trans-unit id="3c3c8cf623e8c157f82c9c8bd8de3ce49f6292d0" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35160에 필요한 xCheckReservedLock () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려고 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="527cca95e4fd8fdc84a2ca6b5f00a7e854482d28" translate="yes" xml:space="preserve">
          <source>If the call to xCheckReservedLock() required by H35160 indicates that some other</source>
          <target state="translated">H35160에 필요한 xCheckReservedLock () 호출이 다른 것으로 표시되는 경우</target>
        </trans-unit>
        <trans-unit id="b6b7e886a7c9cbfdadb1dc23e73d315693f496ee" translate="yes" xml:space="preserve">
          <source>If the call to xDelete() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35450에 필요한 xDelete () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는</target>
        </trans-unit>
        <trans-unit id="5af5d373c56bb9dcd62ea184e1e76437bf4a9601" translate="yes" xml:space="preserve">
          <source>If the call to xFileSize() required by H35450 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35450에 필요한 xFileSize () 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려고하는 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="2a548d9a4e673897d73f6b03d7eb848a11645c48" translate="yes" xml:space="preserve">
          <source>If the call to xOpen() required by H35440 fails (due to an IO or other internal VFS error), then SQLite shall abandon the attempt to open a</source>
          <target state="translated">H35440에 의해 요구되는 xOpen ()에 대한 호출이 실패하면 (IO 또는 기타 내부 VFS 오류로 인해) SQLite는 열려는 시도를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="d1ec650a833c11cb6d8b04d5f0bcc10f45ba6aa9" translate="yes" xml:space="preserve">
          <source>If the callback function returns any value other than SQLITE_OK, the query is abandoned and the xQueryPhrase function returns immediately. If the returned value is SQLITE_DONE, xQueryPhrase returns SQLITE_OK. Otherwise, the error code is propagated upwards.</source>
          <target state="translated">콜백 함수가 SQLITE_OK 이외의 값을 반환하면 쿼리가 취소되고 xQueryPhrase 함수가 즉시 반환됩니다. 리턴 된 값이 SQLITE_DONE 인 경우 xQueryPhrase는 SQLITE_OK를 리턴합니다. 그렇지 않으면 오류 코드가 위쪽으로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="e7031b92fb19c04c6b57152812c2809849a4f000" translate="yes" xml:space="preserve">
          <source>If the callback function to &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; returns non-zero, then sqlite3_exec() will return SQLITE_ABORT.</source>
          <target state="translated">&lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()에&lt;/a&gt; 대한 콜백 함수가 0이 아닌 값을 리턴하면 sqlite3_exec ()는 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a386306ee9feeed2835e0b935d9f3858fdfe7719" translate="yes" xml:space="preserve">
          <source>If the change to table X also affects other tables or indexes or triggers are views within schema, then run &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements to modify those other tables indexes and views too. For example, if the name of a column changes, all FOREIGN KEY constraints, triggers, indexes, and views that refer to that column must be modified.</source>
          <target state="translated">테이블 X에 대한 변경 사항이 다른 테이블 또는 인덱스에 영향을 미치거나 트리거가 스키마 내의 뷰인 경우 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 하여 다른 테이블 인덱스 및 뷰도 수정하십시오. 예를 들어 열 이름이 변경되면 해당 열을 참조하는 모든 FOREIGN KEY 제약 조건, 트리거, 인덱스 및 뷰를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f32e1ca273326c7edb692e7f8fb897873c86b6d" translate="yes" xml:space="preserve">
          <source>If the columns of your result set are named by AS clauses, then SQLite is guaranteed to use the identifier to the right of the AS keyword as the column name. If the result set does not use an AS clause, then SQLite is free to name the column anything it wants. See the &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name()&lt;/a&gt; documentation for further information.</source>
          <target state="translated">결과 세트의 열 이름이 AS 절로 명명 된 경우 SQLite는 AS 키워드의 오른쪽에있는 식별자를 열 이름으로 사용합니다. 결과 세트가 AS 절을 사용하지 않으면 SQLite는 원하는대로 열 이름을 자유롭게 지정할 수 있습니다. 자세한 내용은 &lt;a href=&quot;c3ref/column_name&quot;&gt;sqlite3_column_name ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f6ac289e0c179705fc9860a15b31aba8aa6dfe9" translate="yes" xml:space="preserve">
          <source>If the compression method for the record is either 0 or 8 (see below), then the uncompressed data associated with the zip file entry. Or, if the compression method is not 0 or 8, this column contains a NULL value.</source>
          <target state="translated">레코드의 압축 방법이 0 또는 8 (아래 참조) 인 경우 압축 파일 항목과 연관된 압축되지 않은 데이터입니다. 또는 압축 방법이 0 또는 8이 아닌 경우이 열에는 NULL 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6d7fff8b9b0e80fbe64f6ffbfb79c99106754efa" translate="yes" xml:space="preserve">
          <source>If the content is compressed, then such an &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; database is &lt;a href=&quot;affcase1#smaller&quot;&gt;the same size&lt;/a&gt; (&amp;plusmn;1%) as an equivalent ZIP archive, and it has the advantage of being able to update individual &quot;files&quot; without rewriting the entire document.</source>
          <target state="translated">내용이 압축되면 이러한 &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; 데이터베이스는 동등한 ZIP 아카이브 &lt;a href=&quot;affcase1#smaller&quot;&gt;와 동일한 크기&lt;/a&gt; (&amp;plusmn; 1 %)이며 전체 문서를 다시 쓰지 않고도 개별 &quot;파일&quot;을 업데이트 할 수 있다는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="07d4949504c6ebefef1a44e834288b1c17ef2c29" translate="yes" xml:space="preserve">
          <source>If the content of a subquery might need to be visited more than once, then the use of a co-routine is undesirable, as the co-routine would then have to compute the data more than once. And if the subquery cannot be flattened, that means the subquery must be manifested into a transient table.</source>
          <target state="translated">서브 쿼리의 내용을 두 번 이상 방문해야 할 경우, 코 루틴은 데이터를 두 번 이상 계산해야하므로 코 루틴을 사용하는 것은 바람직하지 않습니다. 하위 쿼리를 병합 할 수없는 경우 하위 쿼리를 임시 테이블에 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="c4de8e7a63ccfd940999297f77703800e91edb69" translate="yes" xml:space="preserve">
          <source>If the content option is used along with the languageid option, then the named languageid column must exist in the content= table (subject to the usual rules - if a query never needs to read the content table then this restriction does not apply).</source>
          <target state="translated">contentid 옵션을 languageid 옵션과 함께 사용하는 경우 명명 된 languageid 열이 content = 테이블에 존재해야합니다 (일반 규칙에 따라-쿼리가 내용 테이블을 읽을 필요가없는 경우에는이 제한이 적용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="69c4116a662051610d482a3763e629de02d91b0e" translate="yes" xml:space="preserve">
          <source>If the coroutine that is launched by this instruction ends with &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; or &lt;a href=&quot;opcode#Return&quot;&gt;Return&lt;/a&gt; then continue to the next instruction. But if the coroutine launched by this instruction ends with &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;, then jump to P2 rather than continuing with the next instruction.</source>
          <target state="translated">이 명령으로 시작된 코 루틴이 &lt;a href=&quot;opcode#Yield&quot;&gt;수율&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Return&quot;&gt;리턴으로&lt;/a&gt; 끝나면 다음 명령으로 계속 진행하십시오. 그러나이 명령어로 실행 된 코 루틴이 &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine으로&lt;/a&gt; 끝나면 다음 명령어를 계속 진행하지 않고 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d90236a26f30bb94fe93491f2ee7d8229a45dcb7" translate="yes" xml:space="preserve">
          <source>If the covering index is used for the scan, the &quot;fruit&quot; column will appear naturally in the correct order, but when there are two or more rows with the same fruit, the price might be out of order. When this occurs, SQLite does many small sorts, one sort for each distinct value of fruit, rather than one large sort. Figure 22 below illustrates the concept.</source>
          <target state="translated">커버링 인덱스가 스캔에 사용되면 &quot;과일&quot;열이 올바른 순서로 자연스럽게 나타나지만 같은 과일을 가진 두 개 이상의 행이 있으면 가격이 잘못되었을 수 있습니다. 이런 일이 발생하면 SQLite는 하나의 큰 종류가 아닌 과일의 각 고유 한 가치에 대해 하나의 작은 종류를 많이 수행합니다. 아래의 그림 22는 개념을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9c6f80849dfd69b57ae6014cb409620e08c9388e" translate="yes" xml:space="preserve">
          <source>If the current statement is not inside an explicit transaction (a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;/&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; block), then an implicit transaction is committed as soon as the statement has finished executing. In this case deferred constraints behave the same as immediate constraints.</source>
          <target state="translated">현재 명령문이 명시 적 트랜잭션 ( &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; / &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 블록) 내에없는 경우 명령문 실행이 완료되는 즉시 내재적 트랜잭션이 커미트됩니다. 이 경우 지연된 제한 조건은 즉각적인 제한 조건과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="392488489ea8e86894e96e98c9d528e435e44b99" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.8.2 or greater, the estimatedRows field may be set to an estimate of the number of rows returned by the proposed query plan. If this value is not explicitly set, the default estimate of 25 rows is used.</source>
          <target state="translated">현재 버전의 SQLite가 3.8.2 이상인 경우 추정 행 필드는 제안 된 쿼리 계획에서 리턴 된 행 수의 추정치로 설정 될 수 있습니다. 이 값을 명시 적으로 설정하지 않으면 기본 추정치 25 행이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d14a622439a8b842f388bc686b9c68da678476ab" translate="yes" xml:space="preserve">
          <source>If the current version of SQLite is 3.9.0 or greater, the idxFlags field may be set to SQLITE_INDEX_SCAN_UNIQUE to indicate that the virtual table will return only zero or one rows given the input constraints. Additional bits of the idxFlags field might be understood in later versions of SQLite.</source>
          <target state="translated">SQLite의 현재 버전이 3.9.0 이상인 경우 idxFlags 필드는 SQLITE_INDEX_SCAN_UNIQUE로 설정되어 가상 테이블이 입력 제한 조건이 주어지면 0 개 또는 1 개의 행만 리턴 함을 표시 할 수 있습니다. idxFlags 필드의 추가 비트는 이후 버전의 SQLite에서 이해 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ead26894e06c87e567f28556505a47feb41761a" translate="yes" xml:space="preserve">
          <source>If the cursor P1 is already opened on an ephemeral table, the table is cleared (all content is erased).</source>
          <target state="translated">임시 테이블에서 커서 P1이 이미 열려 있으면 테이블이 지워집니다 (모든 내용이 지워짐).</target>
        </trans-unit>
        <trans-unit id="4895543ee94b53e62d72914bc8c347747fb66179" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">OPFLAG_SEEKEQ 플래그를 사용하여 커서 P1을 연 경우이 opcode는 항상 키와 같은 레코드에 도달하거나 즉시 P2로 점프합니다. 커서가 OPFLAG_SEEKEQ 인 경우이 opcode 뒤에 동일한 인수를 가진 &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE&lt;/a&gt; opcode 가 와야합니다 . &lt;a href=&quot;opcode#IdxGE&quot;&gt;IdxGE의&lt;/a&gt; 연산 코드는이 연산 코드가 성공하면 생략하지만됩니다&lt;a href=&quot;opcode#IdxGE&quot;&gt; IdxGE의&lt;/a&gt; 연산 코드는 다음 루프 반복에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="77bb6e8019c4e57a173df053565a659dee60ffeb" translate="yes" xml:space="preserve">
          <source>If the cursor P1 was opened using the OPFLAG_SEEKEQ flag, then this opcode will always land on a record that equally equals the key, or else jump immediately to P2. When the cursor is OPFLAG_SEEKEQ, this opcode must be followed by an &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode with the same arguments. The &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be skipped if this opcode succeeds, but the &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode will be used on subsequent loop iterations.</source>
          <target state="translated">OPFLAG_SEEKEQ 플래그를 사용하여 커서 P1을 연 경우이 opcode는 항상 키와 같은 레코드에 도달하거나 즉시 P2로 점프합니다. 커서가 OPFLAG_SEEKEQ 인 경우이 opcode 뒤에 동일한 인수를 가진 &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; opcode 가 와야합니다 . &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE의&lt;/a&gt; 연산 코드는이 연산 코드가 성공하면 생략하지만됩니다 &lt;a href=&quot;opcode#IdxLE&quot;&gt;IdxLE&lt;/a&gt; 연산 코드는 다음 루프 반복에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9c34174e24836739ad2de38f328a95e6bd8361fd" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">데이터베이스 연결이 완료되지 않은 준비된 명령문 또는 완료되지 않은 sqlite3_backup 오브젝트와 연관된 경우 sqlite3_close ()는 데이터베이스 연결을 열린 상태로두고 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 합니다 . sqlite3_close_v2 ()가 완료되지 않은 준비된 명령문 및 / 또는 완료되지 않은 sqlite3_backups와 함께 호출 된 경우, 데이터베이스 연결은 사용할 수없는 &quot;좀비&quot;가되어 마지막 준비된 명령문이 완료되거나 마지막 sqlite3_backup이 완료 될 때 자동으로 할당이 해제됩니다. sqlite3_close_v2 () 인터페이스는 가비지 수집되고 소멸자가 호출되는 순서가 임의 인 호스트 언어와 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a86fbb2e17cc862733085ba2da83a55d59e3eb0" translate="yes" xml:space="preserve">
          <source>If the database connection is associated with unfinalized prepared statements or unfinished sqlite3_backup objects then sqlite3_close() will leave the database connection open and return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. If sqlite3_close_v2() is called with unfinalized prepared statements and/or unfinished sqlite3_backups, then the database connection becomes an unusable &quot;zombie&quot; which will automatically be deallocated when the last prepared statement is finalized or the last sqlite3_backup is finished. The sqlite3_close_v2() interface is intended for use with host languages that are garbage collected, and where the order in which destructors are called is arbitrary.</source>
          <target state="translated">데이터베이스 연결이 완료되지 않은 준비된 명령문 또는 완료되지 않은 sqlite3_backup 오브젝트와 연관된 경우 sqlite3_close ()는 데이터베이스 연결을 열린 상태로두고 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 합니다 . sqlite3_close_v2 ()가 완료되지 않은 준비된 명령문 및 / 또는 완료되지 않은 sqlite3_backups와 함께 호출 된 경우, 데이터베이스 연결은 사용할 수없는 &quot;좀비&quot;가되어 마지막 준비된 명령문이 완료되거나 마지막 sqlite3_backup이 완료 될 때 자동으로 할당이 해제됩니다. sqlite3_close_v2 () 인터페이스는 가비지 수집되고 소멸자가 호출되는 순서가 임의 인 호스트 언어와 함께 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb1362fb98673ef522db1a6a32001f7f2b59540f" translate="yes" xml:space="preserve">
          <source>If the database connection is newly opened, make sure it has read the database schema by preparing then discarding some query against the database, or calling sqlite3_table_column_metadata(), ignoring any errors. This step is only necessary if the application desires to keep the database in WAL mode after the reset if it was in WAL mode before the reset.</source>
          <target state="translated">데이터베이스 연결이 새로 열린 경우 데이터베이스에 대해 일부 쿼리를 준비한 다음 폐기하거나 sqlite3_table_column_metadata ()를 호출하여 오류를 무시하여 데이터베이스 스키마를 읽었는지 확인하십시오. 이 단계는 재설정 전에 WAL 모드에있는 경우 응용 프로그램이 재설정 후 데이터베이스를 WAL 모드로 유지하려는 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1e3e236bab50bdd2cf247016c21c0818a0ad15df" translate="yes" xml:space="preserve">
          <source>If the database file has aliases (hard or soft links) and the file is opened by a different alias than the one used to create the journal, then the journal will not be found. To avoid this problem, you should not create links to SQLite database files.</source>
          <target state="translated">데이터베이스 파일에 별명 (하드 또는 소프트 링크)이 있고 저널을 작성하는 데 사용 된 것과 다른 별명으로 파일이 열리면 저널을 찾을 수 없습니다. 이 문제점을 피하려면 SQLite 데이터베이스 파일에 대한 링크를 작성하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b5462897225632e86adf2dda0274ca8b010e12de" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">데이터베이스 스키마가 변경되면 항상 사용했던대로 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 를 리턴하는 대신 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 SQL 문을 자동으로 다시 컴파일하고 다시 실행하려고합니다. 많은으로 &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY의&lt;/a&gt; ) (재 시도가 sqlite3_step 전에 발생합니다 오류를 포기하고 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="589bc4cd8d0a621a42dc8c997193ae6380bd4790" translate="yes" xml:space="preserve">
          <source>If the database schema changes, instead of returning &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; as it always used to do, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will automatically recompile the SQL statement and try to run it again. As many as &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; retries will occur before sqlite3_step() gives up and returns an error.</source>
          <target state="translated">데이터베이스 스키마가 변경되면 항상 사용했던대로 &lt;a href=&quot;../rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 를 리턴하는 대신 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 SQL 문을 자동으로 다시 컴파일하고 다시 실행하려고합니다. 많은으로 &lt;a href=&quot;../compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY의&lt;/a&gt; ) (재 시도가 sqlite3_step 전에 발생합니다 오류를 포기하고 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="66c44f3be0c0d8ad85eed52612c2f2c579f73474" translate="yes" xml:space="preserve">
          <source>If the database schema contains foreign key errors that require looking at more than one table definition to identify, then those errors are not detected when the tables are created. Instead, such errors prevent the application from preparing SQL statements that modify the content of the child or parent tables in ways that use the foreign keys. Errors reported when content is changed are &quot;DML errors&quot; and errors reported when the schema is changed are &quot;DDL errors&quot;. So, in other words, misconfigured foreign key constraints that require looking at both the child and parent are DML errors. The English language error message for foreign key DML errors is usually &quot;foreign key mismatch&quot; but can also be &quot;no such table&quot; if the parent table does not exist. Foreign key DML errors are reported if:</source>
          <target state="translated">데이터베이스 스키마에 식별하기 위해 둘 이상의 테이블 정의를 조사해야하는 외래 키 오류가 포함 된 경우 테이블을 작성할 때 해당 오류가 감지되지 않습니다. 대신 이러한 오류는 응용 프로그램이 외부 키를 사용하는 방식으로 하위 또는 상위 테이블의 컨텐츠를 수정하는 SQL 문을 준비하지 못하게합니다. 내용이 변경 될 때보고 된 오류는 &quot;DML 오류&quot;이고 스키마가 변경 될 때보고되는 오류는 &quot;DDL 오류&quot;입니다. 즉, 자식 및 부모를 모두 확인해야하는 잘못 구성된 외래 키 제약 조건은 DML 오류입니다. 외래 키 DML 오류에 대한 영어 오류 메시지는 일반적으로 &quot;외래 키 불일치&quot;이지만 부모 테이블이없는 경우 &quot;해당 테이블이 없음&quot;일 수도 있습니다. 다음과 같은 경우 외래 키 DML 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8302ec0e25c3b92c0aa14eef9d1503f836a94585" translate="yes" xml:space="preserve">
          <source>If the declared type contains the string &quot;INT&quot; then it is assigned INTEGER affinity.</source>
          <target state="translated">선언 된 유형에 &quot;INT&quot;문자열이 포함되면 INTEGER 선호도가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9bb6b49e698e48cc0bb2b3442b91fd7f7d66dd5e" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains any of the strings &quot;REAL&quot;, &quot;FLOA&quot;, or &quot;DOUB&quot; then the column has REAL affinity.</source>
          <target state="translated">열에 선언 된 유형에 문자열 &quot;REAL&quot;, &quot;FLOA&quot;또는 &quot;DOUB&quot;이 포함 된 경우 열에 REAL 선호도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f28b903cf6eed2606240e84c579a7053774d3dee" translate="yes" xml:space="preserve">
          <source>If the declared type for a column contains the string &quot;BLOB&quot; or if no type is specified then the column has affinity BLOB.</source>
          <target state="translated">열에 선언 된 유형에 문자열 &quot;BLOB&quot;이 포함되거나 유형이 지정되지 않으면 열의 선호도가 BLOB입니다.</target>
        </trans-unit>
        <trans-unit id="ee88c791daf6e99faa6560e540692aa5bc2c800f" translate="yes" xml:space="preserve">
          <source>If the declared type of the column contains any of the strings &quot;CHAR&quot;, &quot;CLOB&quot;, or &quot;TEXT&quot; then that column has TEXT affinity. Notice that the type VARCHAR contains the string &quot;CHAR&quot; and is thus assigned TEXT affinity.</source>
          <target state="translated">선언 된 유형의 열에 문자열 &quot;CHAR&quot;, &quot;CLOB&quot;또는 &quot;TEXT&quot;가 포함 된 경우 해당 열의 선호도는 TEXT입니다. VARCHAR 유형은 &quot;CHAR&quot;문자열을 포함하므로 TEXT 선호도가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="de0d2c280ce73b7cd6a79e09cb8d9ab5ce1c8380" translate="yes" xml:space="preserve">
          <source>If the default entry point &quot;sqlite3_extension_init&quot; is not present in the loadable extension, also try an entry point &quot;sqlite3_X_init&quot; where &quot;X&quot; is based on the shared library filename. This allows every extension to have a different entry point, which allows them to be statically linked with no code changes.</source>
          <target state="translated">기본 진입 점 &quot;sqlite3_extension_init&quot;가로드 가능한 확장에없는 경우 진입 점 &quot;sqlite3_X_init&quot;도 시도하십시오. 여기서 &quot;X&quot;는 공유 라이브러리 파일 이름을 기반으로합니다. 이를 통해 모든 확장에 다른 진입 점이있을 수 있으므로 코드 변경없이 정적으로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f1570bf7cd89b0efb998b886e0a28b989f79bba" translate="yes" xml:space="preserve">
          <source>If the default value of a column is CURRENT_TIME, CURRENT_DATE or CURRENT_TIMESTAMP, then the value used in the new row is a text representation of the current UTC date and/or time. For CURRENT_TIME, the format of the value is &quot;HH:MM:SS&quot;. For CURRENT_DATE, &quot;YYYY-MM-DD&quot;. The format for CURRENT_TIMESTAMP is &quot;YYYY-MM-DD HH:MM:SS&quot;.</source>
          <target state="translated">열의 기본값이 CURRENT_TIME, CURRENT_DATE 또는 CURRENT_TIMESTAMP 인 경우 새 행에 사용 된 값은 현재 UTC 날짜 및 / 또는 시간의 텍스트 표현입니다. CURRENT_TIME의 경우 값 형식은 &quot;HH : MM : SS&quot;입니다. CURRENT_DATE의 경우 &quot;YYYY-MM-DD&quot; CURRENT_TIMESTAMP의 형식은 &quot;YYYY-MM-DD HH : MM : SS&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="763669d7f38746d95d771edeb8a196a32d9d9e41" translate="yes" xml:space="preserve">
          <source>If the default value of a column is an expression in parentheses, then the expression is evaluated once for each row inserted and the results used in the new row.</source>
          <target state="translated">열의 기본값이 괄호 안에있는 표현식 인 경우 삽입 된 각 행과 새 행에 사용 된 결과에 대해 표현식이 한 번 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="f9fe1ed106b11da1d5f4cf451a970a2b10eba0b4" translate="yes" xml:space="preserve">
          <source>If the default value of the column is a constant NULL, text, blob or signed-number value, then that value is used directly in the new row.</source>
          <target state="translated">열의 기본값이 상수 NULL, 텍스트, 얼룩 또는 부호있는 숫자 값이면 해당 값은 새 행에서 직접 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6072ed5efdb78dd0e13242a8b605916b880d7376" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;column&lt;/b&gt;, then for each term the FTS index records the rowid and column number only, omitting the term offset information. This results in the following restrictions:</source>
          <target state="translated">detail 옵션이 &lt;b&gt;column&lt;/b&gt; 으로 설정된 경우 각 항에 대해 FTS 인덱스는 항 오프셋 정보를 생략하고 rowid 및 열 번호 만 기록합니다. 결과적으로 다음과 같은 제한이 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e6f14be9765a087a59fad069383360a3c524d64a" translate="yes" xml:space="preserve">
          <source>If the detail option is set to &lt;b&gt;none&lt;/b&gt;, then for each term the FTS index records just the rowid is stored. Both column and offset information are omitted. As well as the restrictions itemized above for detail=column mode, this imposes the following extra limitations:</source>
          <target state="translated">detail 옵션이 &lt;b&gt;none&lt;/b&gt; 으로 설정되면 각 용어에 대해 FTS 인덱스는 rowid 만 저장합니다. 열 및 오프셋 정보는 모두 생략됩니다. detail = column 모드에 대해 위에서 설명한 제한 사항 외에도 다음과 같은 추가 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b004cd1f197d0bb3d8b70f7d3071c3e7d65b08" translate="yes" xml:space="preserve">
          <source>If the file-size is not zero bytes and the page cache does not contain valid data for the first page of the database, then the data for the first page must be read from the database.</source>
          <target state="translated">파일 크기가 0 바이트가 아니고 페이지 캐시에 데이터베이스의 첫 번째 페이지에 대한 유효한 데이터가 포함되어 있지 않으면 첫 번째 페이지의 데이터를 데이터베이스에서 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="7d40fd66a8466c922e947b1b7af920a75a0b5408" translate="yes" xml:space="preserve">
          <source>If the filename argument to the shell is a ZIP archive rather than an SQLite database, then the shell automatically opens that ZIP archive using the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">쉘의 파일 이름 인수가 SQLite 데이터베이스가 아닌 ZIP 아카이브 인 경우 쉘은 &lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블을&lt;/a&gt; 사용하여 해당 ZIP 아카이브를 자동으로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="ae3dbad88e43cb04cd5afd00c461d318a7360e00" translate="yes" xml:space="preserve">
          <source>If the filename is &quot;:memory:&quot;, then a private, temporary in-memory database is created for the connection. This in-memory database will vanish when the database connection is closed. Future versions of SQLite might make use of additional special filenames that begin with the &quot;:&quot; character. It is recommended that when a database filename actually does begin with a &quot;:&quot; character you should prefix the filename with a pathname such as &quot;./&quot; to avoid ambiguity.</source>
          <target state="translated">파일 이름이 &quot;: memory :&quot;이면 연결을위한 개인 임시 인 메모리 데이터베이스가 작성됩니다. 이 인 메모리 데이터베이스는 데이터베이스 연결이 닫히면 사라집니다. 이후 버전의 SQLite는 &quot;:&quot;문자로 시작하는 추가 특수 파일 이름을 사용할 수 있습니다. 데이터베이스 파일 이름이 실제로 &quot;:&quot;문자로 시작하는 경우 모호성을 피하기 위해 파일 이름 앞에 &quot;./&quot;와 같은 경로 이름을 붙여야합니다.</target>
        </trans-unit>
        <trans-unit id="62f7e60cb107b276af1d9e468c997800e50e0c47" translate="yes" xml:space="preserve">
          <source>If the filename is an empty string, then a private, temporary on-disk database will be created. This private database will be automatically deleted as soon as the database connection is closed.</source>
          <target state="translated">파일 이름이 빈 문자열이면 개인용 임시 온 디스크 데이터베이스가 작성됩니다. 이 개인 데이터베이스는 데이터베이스 연결이 종료되는 즉시 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="32dd493cb01796f1b19bb91ce938cad16395b6df" translate="yes" xml:space="preserve">
          <source>If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</source>
          <target state="translated">If the final parameter to sqlite3_create_function_v2() or sqlite3_create_window_function() is not NULL, then it is destructor for the application data pointer. The destructor is invoked when the function is deleted, either by being overloaded or when the database connection closes. The destructor is also invoked if the call to sqlite3_create_function_v2() fails. When the destructor callback is invoked, it is passed a single argument which is a copy of the application data pointer which was the fifth parameter to sqlite3_create_function_v2().</target>
        </trans-unit>
        <trans-unit id="a0307f53fcf484b466b65b063fa221cd6f594f91" translate="yes" xml:space="preserve">
          <source>If the first character of the &quot;.output&quot; or &quot;.once&quot; filename is a pipe symbol (&quot;|&quot;) then the remaining characters are treated as a command and the output is sent to that command. This makes it easy to pipe the results of a query into some other process. For example, the &quot;open -f&quot; command on a Mac opens a text editor to display the content that it reads from standard input. So to see the results of a query in a text editor, one could type:</source>
          <target state="translated">&quot;.output&quot;또는 &quot;.once&quot;파일 이름의 첫 문자가 파이프 기호 ( &quot;|&quot;)이면 나머지 문자는 명령으로 처리되고 출력은 해당 명령으로 전송됩니다. 따라서 쿼리 결과를 다른 프로세스로 쉽게 파이프 할 수 있습니다. 예를 들어, Mac에서 &quot;open -f&quot;명령은 텍스트 편집기를 열어 표준 입력에서 읽은 내용을 표시합니다. 따라서 텍스트 편집기에서 쿼리 결과를 보려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="f6248b44ea5d1fc55c81c80463d285a1931abd4d" translate="yes" xml:space="preserve">
          <source>If the flags parameter is non-zero, then the BLOB is opened for read and write access. If the flags parameter is zero, the BLOB is opened for read-only access.</source>
          <target state="translated">flags 매개 변수가 0이 아닌 경우 BLOB는 읽기 및 쓰기 액세스를 위해 열립니다. flags 매개 변수가 0이면 BLOB은 읽기 전용 액세스를 위해 열립니다.</target>
        </trans-unit>
        <trans-unit id="42e53a5898ca221d8e5453208404df16340c520e" translate="yes" xml:space="preserve">
          <source>If the frame type is RANGE or GROUPS, then rows with the same values for all ORDER BY expressions are considered &quot;peers&quot;. Or, if there are no ORDER BY terms, all rows are peers. Peers are always within the same frame.</source>
          <target state="translated">프레임 유형이 RANGE 또는 GROUPS 인 경우 모든 ORDER BY 표현식에 대해 동일한 값을 가진 행은 &quot;피어&quot;로 간주됩니다. 또는 ORDER BY 용어가 없으면 모든 행이 피어입니다. 동료는 항상 같은 프레임 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aa0a21905f32bbcafa3289b7a629a809ef523ab" translate="yes" xml:space="preserve">
          <source>If the full-text index is consistent with the contents of the table, the INSERT used to invoke the integrity-check command succeeds. Or, if any discrepancy is found, it fails with an &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; error.</source>
          <target state="translated">전체 텍스트 인덱스가 테이블의 내용과 일치하면 무결성 검사 명령을 호출하는 데 사용 된 INSERT가 성공합니다. 또는 불일치가 발견되면 &lt;a href=&quot;rescode#corrupt_vtab&quot;&gt;SQLITE_CORRUPT_VTAB&lt;/a&gt; 오류 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="f22af0b11cea33d685991d206d7069a56eda1b2e" translate="yes" xml:space="preserve">
          <source>If the function is registered using the sqlite3_collation_needed() API, then it is passed the names of undefined collation sequences as strings encoded in UTF-8. If sqlite3_collation_needed16() is used, the names are passed as UTF-16 in machine native byte order. A call to either function replaces the existing collation-needed callback.</source>
          <target state="translated">sqlite3_collation_needed () API를 사용하여 함수를 등록하면 정의되지 않은 데이터 정렬 시퀀스의 이름이 UTF-8로 인코딩 된 문자열로 전달됩니다. sqlite3_collation_needed16 ()을 사용하는 경우 이름은 머신 기본 바이트 순서로 UTF-16으로 전달됩니다. 두 함수 중 하나를 호출하면 기존 데이터 정렬이 필요한 콜백이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="6a62bcf0e73dbd9b64d823a84e324e7b03ef33b0" translate="yes" xml:space="preserve">
          <source>If the hard upper bound on mmap_size is non-zero at compilation time, it may still be reduced or zeroed at start-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;,X,Y) interface. The X and Y parameters must both be 64-bit signed integers. The X parameter is the default mmap_size of the process and the Y is the new hard upper bound. The hard upper bound cannot be increased above its compile-time setting using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; but it can be reduced or zeroed.</source>
          <target state="translated">mmap_size의 하드 상한이 컴파일 시간에 0이 아닌 경우 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt; , X, Y) 인터페이스를 사용하여 시작시 여전히 감소하거나 제로화 될 수 있습니다 . X 및 Y 매개 변수는 모두 64 비트 부호있는 정수 여야합니다. X 매개 변수는 프로세스의 기본 mmap_size이고 Y는 새로운 하드 상한입니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE를&lt;/a&gt; 사용하여 컴파일 시간 설정보다 하드 상한을 늘릴 수는 없지만 줄이거 나 0으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3c788b80a3fc760cf36b37df86e977c5bf4e82" translate="yes" xml:space="preserve">
          <source>If the initial value of register P1 is less than 1, then the value is unchanged and control passes through to the next instruction.</source>
          <target state="translated">레지스터 P1의 초기 값이 1보다 작 으면 값이 변경되지 않고 제어가 다음 명령으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="c6c2836bf573a577c3b9e85be740fd6180f2bc75" translate="yes" xml:space="preserve">
          <source>If the insert operation would cause the uniqueness constraint identified by the conflict-target clause to fail, then the insert is omitted and either the DO NOTHING or DO UPDATE operation is performed instead. In the case of a multi-row insert, this decision is made separately for each row of the insert.</source>
          <target state="translated">삽입 조작으로 인해 충돌 대상 절로 식별 된 고유성 제한 조건이 실패하면 삽입이 생략되고 DO NOTHING 또는 DO UPDATE 조작이 대신 수행됩니다. 다중 행 삽입의 경우이 결정은 삽입의 각 행에 대해 별도로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="5cd79e7c31e9806cd77deff0cb0e96d9ab910562" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid DELETE or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old()&lt;/a&gt; API may be used to obtain the old.* values within the change payload.</source>
          <target state="translated">반복자가 유효한 DELETE 또는 UPDATE 항목을 가리키는 경우, &lt;a href=&quot;session/sqlite3changeset_old&quot;&gt;sqlite3changeset_old ()&lt;/a&gt; API를 사용하여 변경 페이로드 내에서 old. * 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3c7141c41f848703cade5e408485ed848edf925" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid INSERT or UPDATE entry, the &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new()&lt;/a&gt; API may be used to obtain the new.* values within the change payload.</source>
          <target state="translated">반복자가 유효한 INSERT 또는 UPDATE 항목을 가리키는 경우, &lt;a href=&quot;session/sqlite3changeset_new&quot;&gt;sqlite3changeset_new ()&lt;/a&gt; API를 사용하여 변경 페이로드 내에서 new. * 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27b2873f49d5b86c6645b602757d6284a617e429" translate="yes" xml:space="preserve">
          <source>If the iterator points to a valid entry, the &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op()&lt;/a&gt; API may be used to determine the type of change (INSERT, UPDATE or DELETE) that the iterator points to. Additionally, the same API can be used to obtain the name of the table the change applies to and its expected number of columns and primary key columns.</source>
          <target state="translated">반복자가 유효한 항목을 가리키는 경우 &lt;a href=&quot;session/sqlite3changeset_op&quot;&gt;sqlite3changeset_op ()&lt;/a&gt; API를 사용하여 반복자가 가리키는 변경 유형 (INSERT, UPDATE 또는 DELETE)을 판별 할 수 있습니다. 또한 동일한 API를 사용하여 변경 사항이 적용되는 테이블 이름과 예상되는 열 수 및 기본 키 열을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e43f90e3097e7ba0e1ecf1e86b3e41e586eb695" translate="yes" xml:space="preserve">
          <source>If the join-operator is &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot; or a comma (&quot;,&quot;) and there is no ON or USING clause, then the result of the join is simply the cartesian product of the left and right-hand datasets. If join-operator does have ON or USING clauses, those are handled according to the following bullet points:</source>
          <target state="translated">조인 연산자가 &quot;CROSS JOIN&quot;, &quot;INNER JOIN&quot;, &quot;JOIN&quot;또는 쉼표 ( &quot;,&quot;)이고 ON 또는 USING 절이없는 경우 조인 결과는 단순히 왼쪽의 데카르트 곱입니다. 그리고 오른 손잡이 데이터 세트. join-operator에 ON 또는 USING 절이있는 경우 다음 글 머리 기호에 따라 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e1fb18a5273cd27a264734974f9f02d1710aa767" translate="yes" xml:space="preserve">
          <source>If the join-operator is a &quot;LEFT JOIN&quot; or &quot;LEFT OUTER JOIN&quot;, then after the ON or USING filtering clauses have been applied, an extra row is added to the output for each row in the original left-hand input dataset that corresponds to no rows at all in the composite dataset (if any). The added rows contain NULL values in the columns that would normally contain values copied from the right-hand input dataset.</source>
          <target state="translated">조인 연산자가 &quot;LEFT JOIN&quot;또는 &quot;LEFT OUTER JOIN&quot;인 경우 ON 또는 USING 필터링 절을 적용한 후 원래 왼쪽 입력 데이터 세트의 각 행에 대한 출력에 추가 행이 추가됩니다. 복합 데이터 세트에 행이 전혀없는 경우 (있는 경우) 추가 된 행에는 일반적으로 오른쪽 입력 데이터 집합에서 복사 한 값이 포함 된 열에 NULL 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="76658faf4e1e99248322d20ab1af06451a7269ae" translate="yes" xml:space="preserve">
          <source>If the json_remove(X) function is called with no path arguments, then it returns the input X reformatted, with excess whitespace removed.</source>
          <target state="translated">json_remove (X) 함수가 경로 인수없이 호출되면 초과 공백이 제거 된 상태로 재 입력 된 입력 X를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b094bdd6dfc46d4028fcd23aee2c781ab15d0c15" translate="yes" xml:space="preserve">
          <source>If the last client using the database shuts down cleanly by calling &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;, then a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; is run automatically in order to transfer all information from the wal file over into the main database, and both the shm file and the wal file are unlinked. Thus, when the database is not in use by any client, it is usually the case that only the main database file exists on disk. However, if the last client did not call &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; before it shut down, or if the last client to disconnect was a read-only client, then the final cleanup operation does not occur and the shm and wal files may still exist on disk even when the database is not in use.</source>
          <target state="translated">마지막 클라이언트가 호출에 의해 아래로 깨끗하게 데이터베이스 닫힌다를 사용하는 경우 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close를 ()&lt;/a&gt; , 다음 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트는&lt;/a&gt; 주요 데이터베이스에 걸쳐 월마트 파일에서 모든 정보를 전송하기 위해 자동으로 실행되고, SHM 파일과 월마트 파일을 모두 연결이 해제된다. 따라서 클라이언트가 데이터베이스를 사용하지 않는 경우 일반적으로 주 데이터베이스 파일 만 디스크에 존재합니다. 그러나 마지막 클라이언트가 종료되기 전에 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 를 호출하지 않았 거나 연결을 끊을 마지막 클라이언트가 읽기 전용 클라이언트 인 경우 최종 정리 작업이 수행되지 않고 shm 및 wal 파일이 디스크에 여전히 존재할 수 있습니다 데이터베이스를 사용하지 않는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="4f7a9d6c2807cb225b7b7ab46b05552f481cc42e" translate="yes" xml:space="preserve">
          <source>If the last connection to a database crashed, then the first new connection to open the database will start a recovery process. An exclusive lock is held during recovery. So if a third database connection tries to jump in and query while the second connection is running recovery, the third connection will get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">데이터베이스에 대한 마지막 연결이 중단 된 경우 데이터베이스를 열기위한 첫 번째 새 연결이 복구 프로세스를 시작합니다. 복구 중에는 독점 잠금이 유지됩니다. 따라서 두 번째 연결이 복구를 실행하는 동안 세 번째 데이터베이스 연결이 점프하여 쿼리를 시도하면 세 번째 연결에 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37b7298e57bd67e9cd0305c3baee9cc81b8dbc9d" translate="yes" xml:space="preserve">
          <source>If the lastname and firstname on the bottom row of the previous screen are bound to ?1 and ?2, then the query above computes the next 7 rows. And, assuming there is an appropriate index, it does so very efficiently &amp;mdash; much more efficiently than OFFSET.</source>
          <target state="translated">이전 화면의 맨 아래 행에있는 성 및 이름이? 1 및? 2에 바인딩 된 경우 위의 쿼리는 다음 7 개의 행을 계산합니다. 또한 적절한 인덱스가 있다고 가정하면 OFFSET보다 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4e01c1ab95f2a00094ec0341f6411fa5bdba3e3d" translate="yes" xml:space="preserve">
          <source>If the library is not configured for UTF-8 and the Tcl library is one of the newer ones that uses UTF-8 internally, then a conversion from UTF-8 to iso8859 and back again is done inside the TCL interface.</source>
          <target state="translated">라이브러리가 UTF-8에 대해 구성되지 않고 Tcl 라이브러리가 내부적으로 UTF-8을 사용하는 최신 라이브러리 중 하나 인 경우, UTF-8에서 iso8859 로의 변환 및 TCL 인터페이스 내부에서 다시 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e9f32c50cc50b5c20674f65e05651f4083f0b21f" translate="yes" xml:space="preserve">
          <source>If the locking mode is EXCLUSIVE when first entering &lt;a href=&quot;wal&quot;&gt;WAL journal mode&lt;/a&gt;, then the locking mode cannot be changed to NORMAL until after exiting WAL journal mode. If the locking mode is NORMAL when first entering WAL journal mode, then the locking mode can be changed between NORMAL and EXCLUSIVE and back again at any time and without needing to exit WAL journal mode.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WAL 저널 모드를&lt;/a&gt; 처음 시작할 때 잠금 모드가 독점 인 경우 WAL 저널 모드 를 종료 한 후에야 잠금 모드를 NORMAL로 변경할 수 없습니다. WAL 저널 모드에 처음 들어갈 때 잠금 모드가 NORMAL이면 잠금 모드는 NORMAL과 EXCLUSIVE 사이에서 변경되었다가 언제라도 WAL 저널 모드를 종료하지 않고도 다시 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5f5f76a7fce4a19ed7250628145b10beef7a78" translate="yes" xml:space="preserve">
          <source>If the matchable phrase in the FTS query is restricted to matching data in a specified FTS table column, then only phrase matches that occur within that column are considered.</source>
          <target state="translated">FTS 쿼리의 일치 구문이 지정된 FTS 테이블 열의 데이터 일치로 제한되면 해당 열 내에서 발생하는 구문 일치 만 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="e74ad1dee292520ae801328610398f65c1bd2944" translate="yes" xml:space="preserve">
          <source>If the memory allocation subsystems within SQLite are configured for breakdown-free operation but the actual memory usage exceeds design limits set by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;, SQLite will usually continue to operate normally. The &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; automatically failover to the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; general-purpose memory allocator. And it is usually the case that the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator will continue to function without fragmentation even if &lt;b&gt;M&lt;/b&gt; and/or &lt;b&gt;n&lt;/b&gt; exceeds the limits imposed by the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt;. The &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; shows that it is possible for a memory allocation to break down and fail in this circumstance, but such a failure requires an especially despicable sequence of allocations and deallocations - a sequence that SQLite has never been observed to follow. So in practice it is usually the case that the limits imposed by Robson can be exceeded by a considerable margin with no ill effect.</source>
          <target state="translated">SQLite 내의 메모리 할당 하위 시스템이 무중단 작동을 위해 구성되었지만 실제 메모리 사용량이 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof에&lt;/a&gt; 의해 설정된 설계 한계를 초과하는 경우 SQLite는 일반적으로 계속 정상적으로 작동합니다. &lt;a href=&quot;malloc#pagecache&quot;&gt;페이지 캐시 메모리 할당&lt;/a&gt; 과 &lt;a href=&quot;malloc#lookaside&quot;&gt;색인 (lookaside) 메모리 할당&lt;/a&gt; 을 자동 페일 오버받는 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 범용 메모리 할당. 그리고 일반적으로 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; 메모리 할당자는 &lt;b&gt;M&lt;/b&gt; 및 / 또는 &lt;b&gt;n&lt;/b&gt; 이 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson 증거&lt;/a&gt; 에 의해 부과 된 한계를 초과 하더라도 조각화없이 계속 작동 합니다. 그만큼&lt;a href=&quot;malloc#nofrag&quot;&gt; 롭슨 증거&lt;/a&gt;이 상황에서 메모리 할당이 중단되고 실패 할 수 있지만 이러한 실패에는 특히 비열한 할당 및 할당 해제 순서가 필요합니다 (SQLite가 따르지 않는 순서). 따라서 실제로 Robson에 의해 부과 된 한계가 악영향없이 상당한 마진을 초과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc13fed0f9a7a53b6beaefda251b5fe55a5b377" translate="yes" xml:space="preserve">
          <source>If the missing function returns an error, then the database is not opened and the error returned to the user. If an openclose function is configured, then a &quot;close&quot; invocation is issued at this point to match the earlier &quot;open&quot;. The following pseudo-code illustrates the procedure used by a swarmvtab instance with both missing and openclose functions configured when a component database is opened.</source>
          <target state="translated">누락 된 함수가 오류를 리턴하면 데이터베이스가 열리지 않고 오류가 사용자에게 리턴됩니다. openclose 기능이 구성된 경우이 시점에서 이전 &quot;open&quot;과 일치하도록 &quot;close&quot;호출이 발행됩니다. 다음 의사 코드는 구성 요소 데이터베이스를 열 때 누락 및 openclose 기능이 모두 구성된 swarmvtab 인스턴스가 사용하는 프로 시저를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="da30913cd33d5b91e0a650b018579fde9dd09c23" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 오류를 표시 한 경우 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="40013c6ef594b13a3f8340842450df9d33bd6702" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 하거나 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 가 S 에서 호출 된 적이없는 경우 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0cc58a427f7c8746f7e6e3f5425c1b7c73b16876" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S indicated an error, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 오류를 표시 한 경우 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 적절한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="36afaf441091086a1762a1226de0f8218bd283bf" translate="yes" xml:space="preserve">
          <source>If the most recent call to &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; or &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or if &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; has never before been called on S, then &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt; returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; S에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)에&lt;/a&gt; 대한 가장 최근 호출이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴 하거나 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 가 S 에서 호출 된 적이없는 경우 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset (S)&lt;/a&gt; 는 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bd08063b2d67d7c5aa3fda6b30f29f4f613d2690" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 와 연관된 가장 최근의 sqlite3_ * API 호출이 실패한 경우 sqlite3_errcode (D) 인터페이스는 해당 API 호출에 대한 숫자 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 를 리턴합니다 . sqlite3_extended_errcode () 인터페이스는 확장 결과 코드가 비활성화 된 경우에도 항상 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드를&lt;/a&gt; 반환한다는 점을 제외하면 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="02b382e95c5f6b3f587125cf8455da646274a1ae" translate="yes" xml:space="preserve">
          <source>If the most recent sqlite3_* API call associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D failed, then the sqlite3_errcode(D) interface returns the numeric &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; for that API call. The sqlite3_extended_errcode() interface is the same except that it always returns the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result code&lt;/a&gt; even when extended result codes are disabled.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 와 연관된 가장 최근의 sqlite3_ * API 호출이 실패한 경우 sqlite3_errcode (D) 인터페이스는 해당 API 호출에 대한 숫자 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 를 리턴합니다 . sqlite3_extended_errcode () 인터페이스는 확장 결과 코드가 비활성화 된 경우에도 항상 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드를&lt;/a&gt; 반환한다는 점을 제외하면 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5550b629f440ed23b3241e812f943180a93fdc19" translate="yes" xml:space="preserve">
          <source>If the nByte argument is negative, then zSql is read up to the first zero terminator. If nByte is positive, then it is the number of bytes read from zSql. If nByte is zero, then no prepared statement is generated. If the caller knows that the supplied string is nul-terminated, then there is a small performance advantage to passing an nByte parameter that is the number of bytes in the input string</source>
          <target state="translated">nByte 인수가 음수이면 zSql은 첫 번째 0 종결 자까지 읽습니다. nByte가 양수이면 zSql에서 읽은 바이트 수입니다. nByte가 0이면 준비된 명령문이 생성되지 않습니다. 호출자가 제공된 문자열이 널 종료됨을 알고 있으면 입력 문자열의 바이트 수인 nByte 매개 변수를 전달하면 약간의 성능 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e34afe39a4a88dd3fd33f4104d3959b3a21962af" translate="yes" xml:space="preserve">
          <source>If the name of the database is an empty string, open a new database in a temporary file that is automatically deleted when the database is closed.</source>
          <target state="translated">데이터베이스 이름이 빈 문자열 인 경우 데이터베이스를 닫을 때 자동으로 삭제되는 임시 파일에서 새 데이터베이스를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="4c3da3e28f6b46a881fb905c79f9b554244037e3" translate="yes" xml:space="preserve">
          <source>If the new changeset contains changes to a table that is already present in the changegroup, then the number of columns and the position of the primary key columns for the table must be consistent. If this is not the case, this function fails with SQLITE_SCHEMA. If the input changeset appears to be corrupt and the corruption is detected, SQLITE_CORRUPT is returned. Or, if an out-of-memory condition occurs during processing, this function returns SQLITE_NOMEM. In all cases, if an error occurs the final contents of the changegroup is undefined.</source>
          <target state="translated">새 변경 세트에 변경 그룹에 이미 존재하는 테이블에 대한 변경 사항이 포함 된 경우 테이블의 열 수와 기본 키 열의 위치가 일치해야합니다. 그렇지 않은 경우이 함수는 SQLITE_SCHEMA와 함께 실패합니다. 입력 변경 세트가 손상된 것으로 보이고 손상이 감지되면 SQLITE_CORRUPT가 리턴됩니다. 또는 처리 중에 메모리 부족 조건이 발생하면이 함수는 SQLITE_NOMEM을 리턴합니다. 모든 경우에 오류가 발생하면 변경 그룹의 최종 내용이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="27ef56041d2d705e25a721ff1b854e81e350859e" translate="yes" xml:space="preserve">
          <source>If the new limit is a negative number, the limit is unchanged. For each limit category SQLITE_LIMIT_</source>
          <target state="translated">새 한계가 음수이면 한계는 변경되지 않습니다. 각 제한 범주 SQLITE_LIMIT_에 대해</target>
        </trans-unit>
        <trans-unit id="dbc989a098eb2be336e5500ea022b41d17fc93aa" translate="yes" xml:space="preserve">
          <source>If the number of output rows is K, then the time needed to sort is proportional to KlogK. If K is small, the sorting time is usually not a factor, but in a query such as the above where K==N, the time needed to sort can be much greater than the time needed to do a full table scan. Furthermore, the entire output is accumulated in temporary storage (which might be either in main memory or on disk, depending on various compile-time and run-time settings) which can mean that a lot of temporary storage is required to complete the query.</source>
          <target state="translated">출력 행의 수가 K 인 경우 정렬에 필요한 시간은 KlogK에 비례합니다. K가 작은 경우 정렬 시간은 일반적으로 요인이 아니지만 K == N 인 위와 같은 쿼리에서 정렬에 필요한 시간은 전체 테이블 스캔에 필요한 시간보다 훨씬 클 수 있습니다. 또한 전체 출력은 임시 저장소 (다양한 컴파일 타임 및 런타임 설정에 따라 주 메모리 또는 디스크에있을 수 있음)에 누적되므로 쿼리를 완료하는 데 많은 임시 저장소가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c9314fcd77821589cea840c1fc80043331e7d710" translate="yes" xml:space="preserve">
          <source>If the operating system does not support sleep requests with millisecond time resolution, then the time will be rounded up to the nearest second. The number of milliseconds of sleep actually requested from the operating system is returned.</source>
          <target state="translated">운영 체제가 밀리 초 시간 해상도로 휴면 요청을 지원하지 않으면 시간은 가장 가까운 초로 반올림됩니다. 운영 체제에서 실제로 요청한 대기 시간 (밀리 초)이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="13ac5ae90471727393e9b13c70a7b1b4bc52ca60" translate="yes" xml:space="preserve">
          <source>If the operating system returns an I/O error while attempting to obtain a certain lock on shared memory in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; then SQLite might fail to reset its cache, which could lead to database corruption if subsequent writes are attempted.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 공유 메모리의 특정 잠금을 확보하려고 시도하는 동안 운영 체제가 I / O 오류를 리턴하면 SQLite가 캐시를 재설정하지 못하여 후속 쓰기를 시도 할 경우 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="387f85a0f9d5d2d59fdee2093a34c406de18ba33" translate="yes" xml:space="preserve">
          <source>If the operation successful, SQLITE_OK is returned. Otherwise, an SQLite error code. In this case, if argument pzErrMsg is not NULL, *pzErrMsg may be set to point to a buffer containing an English language error message. It is the responsibility of the caller to free this buffer using sqlite3_free().</source>
          <target state="translated">조작이 성공하면 SQLITE_OK가 리턴됩니다. 그렇지 않으면 SQLite 오류 코드입니다. 이 경우 pzErrMsg 인수가 NULL이 아닌 경우 * pzErrMsg는 영어 오류 메시지가 포함 된 버퍼를 가리 키도록 설정 될 수 있습니다. sqlite3_free ()를 사용하여이 버퍼를 해제하는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="64ab9d2da26c1826cadd00ea1395a9af67e21893" translate="yes" xml:space="preserve">
          <source>If the optional ESCAPE clause is present, then the expression following the ESCAPE keyword must evaluate to a string consisting of a single character. This character may be used in the LIKE pattern to include literal percent or underscore characters. The escape character followed by a percent symbol (%), underscore (_), or a second instance of the escape character itself matches a literal percent symbol, underscore, or a single escape character, respectively.</source>
          <target state="translated">선택적 ESCAPE 절이 존재하면 ESCAPE 키워드 다음의 표현식은 단일 문자로 구성된 문자열로 평가되어야합니다. 이 문자는 LIKE 패턴에서 리터럴 백분율 또는 밑줄 문자를 포함하는 데 사용될 수 있습니다. 이스케이프 문자 뒤에 백분율 기호 (%), 밑줄 (_) 또는 이스케이프 문자 자체의 두 번째 인스턴스는 각각 리터럴 백분율 기호, 밑줄 또는 단일 이스케이프 문자와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="3874cddaea0653331a0794c8eb1dd76401bd55b2" translate="yes" xml:space="preserve">
          <source>If the optional IF NOT EXISTS clause is present and another index with the same name already exists, then this command becomes a no-op.</source>
          <target state="translated">선택적 IF NOT EXISTS 절이 존재하고 동일한 이름을 가진 다른 색인이 이미 존재하면이 명령은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="65cace3a0d2d4d6370079a8ce7f587fee8e20bbc" translate="yes" xml:space="preserve">
          <source>If the outer query is an aggregate, then the subquery may not contain ORDER BY.</source>
          <target state="translated">외부 쿼리가 집계이면 하위 쿼리에 ORDER BY가 포함되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b950d8e0107ea7fe292918a7624ecc4c5105550" translate="yes" xml:space="preserve">
          <source>If the outer query is part of a compound select, then the subquery may not have a LIMIT clause.</source>
          <target state="translated">외부 쿼리가 복합 선택의 일부인 경우 하위 쿼리에 LIMIT 절이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ec4e583fb2aac08c6ef7929f12a08ccd0d23acd" translate="yes" xml:space="preserve">
          <source>If the output parameters (ppRebase) and (pnRebase) are non-NULL and the input is a changeset (not a patchset), then sqlite3changeset_apply_v2() may set (*ppRebase) to point to a &quot;rebase&quot; that may be used with the sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase) is set to the size of the buffer in bytes. It is the responsibility of the caller to eventually free any such buffer using sqlite3_free(). The buffer is only allocated and populated if one or more conflicts were encountered while applying the patchset. See comments surrounding the sqlite3_rebaser APIs for further details.</source>
          <target state="translated">출력 매개 변수 (ppRebase) 및 (pnRebase)가 NULL이 아니고 입력이 변경 세트 (패치 세트가 아님) 인 경우 sqlite3changeset_apply_v2 ()는 (* ppRebase)가 &quot;rebase&quot;를 가리 키도록 설정할 수 있습니다. sqlite3_rebaser API는 리턴하기 전에 버퍼링합니다. 이 경우 (* pnRebase)는 버퍼 크기 (바이트)로 설정됩니다. sqlite3_free ()를 사용하여 그러한 버퍼를 결국 해제하는 것은 호출자의 책임입니다. 패치 세트를 적용하는 동안 하나 이상의 충돌이 발생한 경우에만 버퍼가 할당되고 채워집니다. 자세한 내용은 sqlite3_rebaser API를 둘러싼 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9ff399a5e615a33dc8fa9681024351734065387" translate="yes" xml:space="preserve">
          <source>If the parameter is a positive value, B-tree structures are only eligible for merging if one of the following is true:</source>
          <target state="translated">매개 변수가 양수이면 B-tree 구조는 다음 중 하나에 해당하는 경우에만 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60b6cd8e8d3dd19980d55457d739967fca11e05a" translate="yes" xml:space="preserve">
          <source>If the parameter is named, then its name appears in P4. The P4 value is used by sqlite3_bind_parameter_name().</source>
          <target state="translated">매개 변수의 이름이 지정된 경우 해당 이름이 P4에 나타납니다. P4 값은 sqlite3_bind_parameter_name ()에 의해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b51f3bd8d197cc75de48b64a5587d9918566615a" translate="yes" xml:space="preserve">
          <source>If the parameter is negative, and there are B-tree structures on more than one level within the FTS index, all B-tree structures are assigned to the same level before the merge operation is commenced. Additionally, if the parameter is negative, the value of the usermerge configuration option is not respected - as few as two b-trees from the same level may be merged together.</source>
          <target state="translated">매개 변수가 음수이고 FTS 인덱스 내에 둘 이상의 레벨에 B- 트리 구조가있는 경우 병합 조작이 시작되기 전에 모든 B- 트리 구조가 동일한 레벨로 지정됩니다. 또한 매개 변수가 음수이면 usermerge 구성 옵션의 값이 존중되지 않습니다. 같은 수준의 b- 트리가 몇 개나 병합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff1e8b8711836cc88e8f7bc11a03808c27d6ff91" translate="yes" xml:space="preserve">
          <source>If the paths are sorted using the BINARY collation sequence, then the overflow pages associated with a cell will appear earlier in the sort-order than its child page:</source>
          <target state="translated">경로가 BINARY 조합 순서를 사용하여 정렬되면 셀과 연관된 오버 플로우 페이지가 하위 페이지보다 정렬 순서에서 더 일찍 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e58cd97227118f50b919227b576a1a6d96943367" translate="yes" xml:space="preserve">
          <source>If the process that wants to write is unable to obtain a RESERVED lock, it must mean that another process already has a RESERVED lock. In that case, the write attempt fails and returns SQLITE_BUSY.</source>
          <target state="translated">쓰려는 프로세스가 RESERVED 잠금을 확보 할 수없는 경우 다른 프로세스에 이미 RESERVED 잠금이 있음을 의미해야합니다. 이 경우 쓰기 시도가 실패하고 SQLITE_BUSY를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="406129ab5d2092b3ea22acba195d09ec62e01cc6" translate="yes" xml:space="preserve">
          <source>If the progress callback returns non-zero, the operation is interrupted. This feature can be used to implement a &quot;Cancel&quot; button on a GUI progress dialog box.</source>
          <target state="translated">progress 콜백이 0이 아닌 값을 반환하면 작업이 중단됩니다. 이 기능은 GUI 진행 대화 상자에서 &quot;취소&quot;버튼을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab297d564d935b4268428b382c93fe0d78c1a7ca" translate="yes" xml:space="preserve">
          <source>If the query contains an ORDER BY clause or a GROUP BY clause or if the query uses the DISTINCT keyword then it is advantageous to select a path through the graph that causes rows to naturally appear in sorted order, so that no separate sorting step is required. Automatic elimination of ORDER BY clauses can make a large performance difference, so this is another factor that needs to be considered in a complete implementation.</source>
          <target state="translated">쿼리에 ORDER BY 절이나 GROUP BY 절이 포함되어 있거나 쿼리에서 DISTINCT 키워드를 사용하는 경우 행을 정렬 된 순서대로 자연스럽게 표시하는 그래프를 통해 경로를 선택하면 별도의 정렬 단계가 필요하지 않습니다. . ORDER BY 절을 자동으로 제거하면 성능이 크게 달라질 수 있으므로 이는 완전한 구현에서 고려해야 할 또 다른 요소입니다.</target>
        </trans-unit>
        <trans-unit id="4359b51a903396b955ce1a84240a1385d5c4cd97" translate="yes" xml:space="preserve">
          <source>If the query runs to completion without incident, SQLITE_OK is returned. Or, if some error occurs before the query completes or is aborted by the callback, an SQLite error code is returned.</source>
          <target state="translated">사건없이 쿼리가 완료되면 SQLITE_OK가 반환됩니다. 또는 쿼리가 완료되거나 콜백에 의해 중단되기 전에 오류가 발생하면 SQLite 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="78d49d24ce74dae451d0ef728d6bf465dbd467e9" translate="yes" xml:space="preserve">
          <source>If the reason for writing to the database file is because the memory cache was full, then the writer will not commit right away. Instead, the writer might continue to make changes to other pages. Before subsequent changes are written to the database file, the rollback journal must be flushed to disk again. Note also that the EXCLUSIVE lock that the writer obtained in order to write to the database initially must be held until all changes are committed. That means that no other processes are able to access the database from the time the memory cache first spills to disk until the transaction commits.</source>
          <target state="translated">데이터베이스 파일에 쓰는 이유가 메모리 캐시가 가득 찼기 때문에 기록기가 즉시 커밋하지 않습니다. 대신 작성자가 다른 페이지를 계속 변경할 수 있습니다. 후속 변경 사항이 데이터베이스 파일에 기록되기 전에 롤백 저널을 디스크로 다시 플러시해야합니다. 기록기가 데이터베이스에 처음 쓰기 위해 얻은 EXCLUSIVE 잠금은 모든 변경 사항이 커밋 될 때까지 유지되어야합니다. 이는 메모리 캐시가 처음으로 유출 된 시점부터 트랜잭션이 커밋 될 때까지 다른 프로세스가 데이터베이스에 액세스 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f4de1a28535def0f53f335b0aa1ec084bfb958b6" translate="yes" xml:space="preserve">
          <source>If the record contains fewer than P2 fields, then extract a NULL. Or, if the P4 argument is a P4_MEM use the value of the P4 argument as the result.</source>
          <target state="translated">레코드에 P2보다 적은 필드가 포함 된 경우 NULL을 추출하십시오. 또는 P4 인수가 P4_MEM 인 경우 P4 인수의 값을 결과로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a233c4347f5d21c12355351382fcf901413d7e49" translate="yes" xml:space="preserve">
          <source>If the recovered database schema already contains a table named &quot;lost_and_found&quot;, the &quot;.recover&quot; command uses the name &quot;lost_and_found0&quot;. If the name &quot;lost_and_found0&quot; is also already taken, &quot;lost_and_found1&quot;, and so on. The default name &quot;lost_and_found&quot; may be overridden by invoking &quot;.recover&quot; with the --lost-and-found switch. For example, to have the output script call the table &quot;orphaned_rows&quot;:</source>
          <target state="translated">복구 된 데이터베이스 스키마에 이미 &quot;lost_and_found&quot;라는 테이블이 포함 된 경우 &quot;.recover&quot;명령은 &quot;lost_and_found0&quot;이라는 이름을 사용합니다. &quot;lost_and_found0&quot;이라는 이름도 이미 사용중인 경우 &quot;lost_and_found1&quot;등입니다. 기본 이름 &quot;lost_and_found&quot;는 --lost-and-found 스위치로 &quot;.recover&quot;를 호출하여 재정의 될 수 있습니다. 예를 들어, 출력 스크립트가 &quot;분리 된 행&quot;테이블을 호출하도록하려면</target>
        </trans-unit>
        <trans-unit id="872cffdf6d4bf05d01de18a6904e492aef161446" translate="yes" xml:space="preserve">
          <source>If the requested page is already in the page cache, then the page cache implementation must return a pointer to the page buffer with its content intact. If the requested page is not already in the cache, then the cache implementation should use the value of the createFlag parameter to help it determined what action to take:</source>
          <target state="translated">요청 된 페이지가 이미 페이지 캐시에있는 경우 페이지 캐시 구현은 내용이 그대로있는 페이지 버퍼에 대한 포인터를 리턴해야합니다. 요청 된 페이지가 아직 캐시에 없으면 캐시 구현은 createFlag 매개 변수의 값을 사용하여 수행 할 조치를 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="db0bc69173aefab4964d855c64d49581690da543" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-16 문자열 인 경우 sqlite3_column_bytes16 () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-8 문자열 인 경우 sqlite3_column_bytes16 ()은 문자열을 UTF-16으로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes16 ()은 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-16 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes16 ()은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b44d7bd1746ffad7cf756ce26aeea67c4d49e66" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-16 string then the sqlite3_column_bytes16() routine returns the number of bytes in that BLOB or string. If the result is a UTF-8 string, then sqlite3_column_bytes16() converts the string to UTF-16 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes16() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-16 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes16() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-16 문자열 인 경우 sqlite3_column_bytes16 () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-8 문자열 인 경우 sqlite3_column_bytes16 ()은 문자열을 UTF-16으로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes16 ()은 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-16 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes16 ()은 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a04fb4ab27b4007fb1a3789b739c65a862ccba9" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-8 문자열 인 경우 sqlite3_column_bytes () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-16 문자열 인 경우 sqlite3_column_bytes ()는 문자열을 UTF-8로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes ()는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-8 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes ()는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="97aa0401915ee07da3fcfb4b2dd9b95ffff68377" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or UTF-8 string then the sqlite3_column_bytes() routine returns the number of bytes in that BLOB or string. If the result is a UTF-16 string, then sqlite3_column_bytes() converts the string to UTF-8 and then returns the number of bytes. If the result is a numeric value then sqlite3_column_bytes() uses &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; to convert that value to a UTF-8 string and returns the number of bytes in that string. If the result is NULL, then sqlite3_column_bytes() returns zero.</source>
          <target state="translated">결과가 BLOB 또는 UTF-8 문자열 인 경우 sqlite3_column_bytes () 루틴은 해당 BLOB 또는 문자열의 바이트 수를 리턴합니다. 결과가 UTF-16 문자열 인 경우 sqlite3_column_bytes ()는 문자열을 UTF-8로 변환 한 다음 바이트 수를 리턴합니다. 결과가 숫자 값인 경우 sqlite3_column_bytes ()는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 사용 하여 해당 값을 UTF-8 문자열로 변환하고 해당 문자열의 바이트 수를 리턴합니다. 결과가 NULL이면 sqlite3_column_bytes ()는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cce95bf5c0bc98e89e8fc40f80872857badf8433" translate="yes" xml:space="preserve">
          <source>If the result is a BLOB or a TEXT string, then the sqlite3_column_bytes() or sqlite3_column_bytes16() interfaces can be used to determine the size of that BLOB or string.</source>
          <target state="translated">결과가 BLOB 또는 TEXT 문자열 인 경우 sqlite3_column_bytes () 또는 sqlite3_column_bytes16 () 인터페이스를 사용하여 해당 BLOB 또는 문자열의 크기를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd9c1a162239f42f97865bf762c6375eed8fe6fe" translate="yes" xml:space="preserve">
          <source>If the result is a general expression, not a just the name of a source table column, then the name of the result is a copy of the expression text.</source>
          <target state="translated">결과가 소스 테이블 열의 이름이 아니라 일반 표현식 인 경우 결과 이름은 표현식 텍스트의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="57f0dbb6f6834911f1360c14b63d681228556516" translate="yes" xml:space="preserve">
          <source>If the result set of a query is empty, then by default &lt;b&gt;sqlite_get_table&lt;/b&gt; will set nrow to 0 and leave its result parameter is set to NULL. But if the EMPTY_RESULT_CALLBACKS pragma is ON then the result parameter is initialized to the names of the columns only. For example, consider this query which has an empty result set:</source>
          <target state="translated">쿼리 결과 집합이 비어 있으면 기본적으로 &lt;b&gt;sqlite_get_table&lt;/b&gt; 은 nrow를 0으로 설정하고 결과 매개 변수는 NULL로 설정합니다. 그러나 EMPTY_RESULT_CALLBACKS pragma가 ON이면 결과 매개 변수는 열 이름으로 만 초기화됩니다. 예를 들어 빈 결과 집합이있는이 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d816ce55af3aa1bc324149c293eb2742dfc0c53d" translate="yes" xml:space="preserve">
          <source>If the right-hand side of an IN operator can be list of values as in the following:</source>
          <target state="translated">IN 연산자의 오른쪽이 다음과 같이 값 목록이 될 수있는 경우 :</target>
        </trans-unit>
        <trans-unit id="b287ebc787ae1fe1352a6696e98abccff05e37e6" translate="yes" xml:space="preserve">
          <source>If the row comes from a WITHOUT ROWID table, this column contains NULL. Otherwise, it contains the 64-bit integer rowid value for the row.</source>
          <target state="translated">행이 WITHOUT ROWID 테이블에서 오는 경우이 열에는 NULL이 포함됩니다. 그렇지 않으면 행에 대한 64 비트 정수 rowid 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="489be44720b2f1c706095444d825988cba31b9db" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">BLOB 핸들이 가리키는 행이 &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 부작용으로 수정 되면 BLOB 핸들이 &quot;만료 됨&quot;으로 표시됩니다. BLOB 핸들이 열려있는 열 이외의 열을 포함하여 행의 열이 변경된 경우에도 마찬가지입니다. 만료 된 BLOB 핸들에 대한 &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 호출 은 리턴 코드 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 로 실패 합니다. BLOB 만료 전에 BLOB에 기록 된 변경 사항은 BLOB 만료에 의해 롤백되지 않습니다. 트랜잭션이 계속 완료되면 이러한 변경 사항이 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="855918a93d6aa4472f75825b61dee9d03ea7eab1" translate="yes" xml:space="preserve">
          <source>If the row that a BLOB handle points to is modified by an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or by &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; side-effects then the BLOB handle is marked as &quot;expired&quot;. This is true if any column of the row is changed, even a column other than the one the BLOB handle is open on. Calls to &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; for an expired BLOB handle fail with a return code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Changes written into a BLOB prior to the BLOB expiring are not rolled back by the expiration of the BLOB. Such changes will eventually commit if the transaction continues to completion.</source>
          <target state="translated">BLOB 핸들이 가리키는 행이 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 부작용으로 수정 되면 BLOB 핸들이 &quot;만료 됨&quot;으로 표시됩니다. BLOB 핸들이 열려있는 열 이외의 열을 포함하여 행의 열이 변경된 경우에도 마찬가지입니다. 만료 된 BLOB 핸들에 대한 &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 호출 은 리턴 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; 로 실패 합니다. BLOB 만료 전에 BLOB에 기록 된 변경 사항은 BLOB 만료에 의해 롤백되지 않습니다. 트랜잭션이 계속 완료되면 이러한 변경 사항이 커밋됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad667b790a078db1e6c6968fc928120e549e94b" translate="yes" xml:space="preserve">
          <source>If the same database is being read and written using two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; (two different &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; objects returned by separate calls to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;) and the two database connections do not have a &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, then the reader is only able to see complete committed transactions from the writer. Partial changes by the writer that have not been committed are invisible to the reader. This is true regardless of whether the two database connections are in the same thread, in different threads of the same process, or in different processes. This is the usual and expected behavior for SQL database systems.</source>
          <target state="translated">두 개의 서로 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; ( &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 에 대한 개별 호출로 리턴 된 두 개의 서로 다른 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; 객체)을 사용하여 동일한 데이터베이스를 읽고 쓰는 중이고 두 데이터베이스 연결에 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 가없는 경우 독자는 완결 된 커밋 만 볼 수 있습니다 작가의 거래. 커밋되지 않은 라이터의 부분 변경은 독자에게 보이지 않습니다. 이는 두 데이터베이스 연결이 동일한 스레드, 동일한 프로세스의 다른 스레드 또는 다른 프로세스에 있는지 여부에 관계없이 적용됩니다. 이것은 SQL 데이터베이스 시스템에서 일반적으로 예상되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="2e0132de71fd47828befdd8cddea786393211a76" translate="yes" xml:space="preserve">
          <source>If the savepoint-name in a RELEASE command does not match any savepoint currently in the transaction stack, then no savepoints are released, the database is unchanged, and the RELEASE command returns an error.</source>
          <target state="translated">RELEASE 명령의 저장 점 이름이 현재 트랜잭션 스택에있는 저장 점과 일치하지 않으면 저장 점이 해제되지 않고 데이터베이스가 변경되지 않으며 RELEASE 명령이 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0e8e411b07fe2c001323f612676b1abf9cd50210" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">두 번째 매개 변수 (zDbName)가 열려있는 데이터베이스 파일의 이름과 일치하지 않으면 SQLITE_ERROR가 리턴됩니다. 이 오류 코드는 기억되지 않으며 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()에&lt;/a&gt; 의해 호출되지 않습니다 . 기본 xFileControl 메소드는 SQLITE_ERROR를 리턴 할 수도 있습니다. 기본 xFileControl 메소드에서 잘못된 zDbName과 SQLITE_ERROR 리턴을 구별 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0a6c4ada949c40cb1aa6d07b25694fd6c11c1796" translate="yes" xml:space="preserve">
          <source>If the second parameter (zDbName) does not match the name of any open database file, then SQLITE_ERROR is returned. This error code is not remembered and will not be recalled by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;. The underlying xFileControl method might also return SQLITE_ERROR. There is no way to distinguish between an incorrect zDbName and an SQLITE_ERROR return from the underlying xFileControl method.</source>
          <target state="translated">두 번째 매개 변수 (zDbName)가 열려있는 데이터베이스 파일의 이름과 일치하지 않으면 SQLITE_ERROR가 리턴됩니다. 이 오류 코드는 기억되지 않으며 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()에&lt;/a&gt; 의해 호출되지 않습니다 . 기본 xFileControl 메소드는 SQLITE_ERROR를 리턴 할 수도 있습니다. 기본 xFileControl 메소드에서 잘못된 zDbName과 SQLITE_ERROR 리턴을 구별 할 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b78c0101bf92e2df502819dbd3877a0d27dbb142" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be greater than zero bytes by a query required by H35450, then SQLite shall attempt to upgrade the</source>
          <target state="translated">H35450에 필요한 쿼리에 의해 잠재적으로 핫 저널 파일의 크기가 0 바이트보다 큰 것으로 밝혀지면 SQLite는</target>
        </trans-unit>
        <trans-unit id="84a94aa97953d8f31911d07edfb705a8ac22630d" translate="yes" xml:space="preserve">
          <source>If the size of a potentially hot journal file is revealed to be zero bytes by a query required by H35450, then SQLite shall close the file handle opened on the journal file and delete the journal file using a call to the VFS xDelete() method. In this case SQLite shall conclude that there is no</source>
          <target state="translated">H35450에 의해 요구되는 쿼리에 의해 잠재적으로 핫 저널 파일의 크기가 0 바이트로 밝혀지면, SQLite는 저널 파일에서 열린 파일 핸들을 닫고 VFS xDelete () 메소드 호출을 사용하여 저널 파일을 삭제해야합니다. 이 경우 SQLite는</target>
        </trans-unit>
        <trans-unit id="8775f72effd63665f56849704eebc4e3eb03a777" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE 절에서 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;호스트 매개 변수&lt;/a&gt; 에 바인드 된 특정 값 이 명령문에 대한 쿼리 계획의 선택에 영향을 줄 수있는 경우, 스키마 변경이 발생한 것처럼 변경 후 첫 번째 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출 에서 명령문이 자동으로 재 컴파일됩니다. 해당 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 에 . WHERE-clause &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 특정 값은 매개 변수가 &lt;a href=&quot;../lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 의 왼쪽 이거나 매개 변수가 색인화 된 컬럼과 비교되고 &lt;a href=&quot;../compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 시간 옵션이 사용 가능한 경우 쿼리 계획의 선택에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b5aede3751869315efb1ad0c6228b799d6377d" translate="yes" xml:space="preserve">
          <source>If the specific value bound to &lt;a href=&quot;lang_expr#varparam&quot;&gt;host parameter&lt;/a&gt; in the WHERE clause might influence the choice of query plan for a statement, then the statement will be automatically recompiled, as if there had been a schema change, on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call following any change to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bindings&lt;/a&gt; of that &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt;. The specific value of WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; might influence the choice of query plan if the parameter is the left-hand side of a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; or &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operator or if the parameter is compared to an indexed column and the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is enabled.</source>
          <target state="translated">WHERE 절에서 &lt;a href=&quot;lang_expr#varparam&quot;&gt;호스트 매개 변수&lt;/a&gt; 에 바인드 된 특정 값 이 명령문에 대한 쿼리 계획의 선택에 영향을 줄 수있는 경우, 스키마 변경이 발생한 것처럼 변경 후 첫 번째 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출 에서 명령문이 자동으로 재 컴파일됩니다. 해당 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 에 . WHERE-clause &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 의 특정 값은 매개 변수가 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 또는 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자 의 왼쪽 이거나 매개 변수가 색인화 된 컬럼과 비교되고 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일 시간 옵션이 사용 가능한 경우 쿼리 계획의 선택에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e1ce97d9fc0705c3229e21c8809d3855d59efd3" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">지정된 열이 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;이고 테이블이 &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아니고 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열이 명시 적으로 선언 된 경우 명시 적으로 선언 된 열에 대해 출력 매개 변수가 설정됩니다. &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열 이 없으면 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 의 출력은 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8f350a11b8322175a383ceadb167cdbb00955970" translate="yes" xml:space="preserve">
          <source>If the specified column is &quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot; and the table is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column has been explicitly declared, then the output parameters are set for the explicitly declared column. If there is no &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, then the outputs for the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; are set as follows:</source>
          <target state="translated">지정된 열이 &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;이고 테이블이 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아니고 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열이 명시 적으로 선언 된 경우 명시 적으로 선언 된 열에 대해 출력 매개 변수가 설정됩니다. &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열 이 없으면 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 의 출력은 다음과 같이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f3164e0e380d4749ee94c4239d71835f6ebe7294" translate="yes" xml:space="preserve">
          <source>If the specified compress or uncompress functions do not exist, the table may still be created. An error is not returned until the FTS4 table is read (if the uncompress function does not exist) or written (if it is the compress function that does not exist).</source>
          <target state="translated">지정된 압축 또는 압축 해제 기능이 없으면 테이블이 여전히 작성 될 수 있습니다. FTS4 테이블을 읽거나 (압축 해제 기능이 존재하지 않는 경우) 존재하지 않는 압축 기능인 경우에는 오류가 리턴되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63eb5c5c72bb1ff543038003d7ef2fd45c2837fe" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">지정된 테이블이 실제로 뷰인 경우 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ce9d8284bfd79645e82900ecac60c2249827b2a4" translate="yes" xml:space="preserve">
          <source>If the specified table is actually a view, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">지정된 테이블이 실제로 뷰인 경우 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="7fece2731796046aa37a6f47896457da35d0048d" translate="yes" xml:space="preserve">
          <source>If the specified value is an integer (or text that looks like an integer), it is inserted verbatim. If the value is not a valid UNIX mode, some programs may behave unexpectedly when extracting files from the archive.</source>
          <target state="translated">지정된 값이 정수 (또는 정수처럼 보이는 텍스트)이면 그대로 삽입됩니다. 값이 유효한 UNIX 모드가 아닌 경우 일부 프로그램은 아카이브에서 파일을 추출 할 때 예기치 않게 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4f3a6c8e56d6f7f8102c0223dc18717b78218c4" translate="yes" xml:space="preserve">
          <source>If the specified view cannot be found and the IF EXISTS clause is not present, it is an error. If the specified view cannot be found and an IF EXISTS clause is present in the DROP VIEW statement, then the statement is a no-op.</source>
          <target state="translated">지정된보기를 찾을 수없고 IF EXISTS 절이 없으면 오류입니다. 지정된보기를 찾을 수없고 IF EXISTS 절이 DROP VIEW 문에 존재하면 명령문은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90a8c9a64f685446aa6aabbcaddc7d44c89fc5a1" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">sqlite3_vtab_nochange (X) 루틴이 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드 내에서 호출 되면 열 값이 변경되지 않는 UPDATE 조작의 일부로 열을 페치하는 경우에만 true를 리턴합니다. 응용 프로그램은이를 사용하여 계산 비용이 덜 들고 해당 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메서드가 &quot;변경 없음&quot;값으로 이해 되는 반환 값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="589f84e6663e321a54522d9b6141cb9b22a8427e" translate="yes" xml:space="preserve">
          <source>If the sqlite3_vtab_nochange(X) routine is called within the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, then it returns true if and only if the column is being fetched as part of an UPDATE operation during which the column value will not change. Applications might use this to substitute a return value that is less expensive to compute and that the corresponding &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method understands as a &quot;no-change&quot; value.</source>
          <target state="translated">sqlite3_vtab_nochange (X) 루틴이 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드 내에서 호출 되면 열 값이 변경되지 않는 UPDATE 조작의 일부로 열을 페치하는 경우에만 true를 리턴합니다. 응용 프로그램은이를 사용하여 계산 비용이 덜 들고 해당 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메서드가 &quot;변경 없음&quot;값으로 이해 되는 반환 값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aeaddc8619c2a7f7c9c53fa9fbcf5b7907cc4bc7" translate="yes" xml:space="preserve">
          <source>If the sqlite_stat1.idx column is NULL, then the sqlite_stat1.stat column contains a single integer which is the approximate number of rows in the table identified by sqlite_stat1.tbl. If the sqlite_stat1.idx column is the same as the sqlite_stat1.tbl column, then the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table and the sqlite_stat1.stat field contains information about the index btree that implements the WITHOUT ROWID table.</source>
          <target state="translated">sqlite_stat1.idx 컬럼이 NULL 인 경우, sqlite_stat1.stat 컬럼은 sqlite_stat1.tbl에 의해 식별 된 테이블의 대략적인 행 수인 단일 정수를 포함합니다. sqlite_stat1.idx 열이 sqlite_stat1.tbl 열과 동일한 경우 테이블은 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이고 sqlite_stat1.stat 필드에는 WITHOUT ROWID 테이블을 구현하는 인덱스 btree에 대한 정보가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef8812fff06e258ef45bbe3080d7b83145fdfcb" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound SELECT, then</source>
          <target state="translated">하위 쿼리가 복합 SELECT 인 경우</target>
        </trans-unit>
        <trans-unit id="95d8d057928b20b8273091a81f8f75e5dc26f5b2" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then all terms of the ORDER by clause of the parent must be simple references to columns of the sub-query.</source>
          <target state="translated">하위 쿼리가 복합 선택 인 경우 상위의 ORDER by 절의 모든 용어는 하위 쿼리의 열에 대한 간단한 참조 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cfa26eb2d70555062705f5059521f66db3517508" translate="yes" xml:space="preserve">
          <source>If the sub-query is a compound select, then it must not use an ORDER BY clause.</source>
          <target state="translated">부속 조회가 복합 선택 인 경우 ORDER BY 절을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="a41d547f4cfa21fa6c9e383332bb2ccbe73488d1" translate="yes" xml:space="preserve">
          <source>If the subquery is the right operand of a LEFT JOIN then</source>
          <target state="translated">하위 쿼리가 LEFT JOIN의 오른쪽 피연산자 인 경우</target>
        </trans-unit>
        <trans-unit id="9251592b196cd1f8e1c4b9db367256eca51eaf76" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT then the outer query may not have a WHERE clause.</source>
          <target state="translated">부속 조회가 LIMIT를 사용하는 경우 외부 조회에 WHERE 절이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3915c5066778c0e52bdae49ad9f9428a2640f7be" translate="yes" xml:space="preserve">
          <source>If the subquery uses LIMIT, then the outer query may not be DISTINCT.</source>
          <target state="translated">부속 조회가 LIMIT를 사용하는 경우 외부 조회는 DISTINCT가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ca99915e9f2329a546bdb9b1fd10bf3cea382c2" translate="yes" xml:space="preserve">
          <source>If the table has 32 or fewer columns, a single unsigned integer is output for each phrase in the query. The least significant bit of the integer is set if the phrase appears at least once in column 0. The second least significant bit is set if the phrase appears once or more in column 1. And so on.</source>
          <target state="translated">테이블에 열이 32 개 이하인 경우 쿼리의 각 구에 대해 단일 부호없는 정수가 출력됩니다. 문구가 열 0에 적어도 한 번 나타날 경우 정수의 최하위 비트가 설정됩니다. 문구가 열 1에 한 번 이상 나타나면 두 번째 최하위 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="721c91e5cd9182aa981b27d672f91c90481093e6" translate="yes" xml:space="preserve">
          <source>If the table has more than 32 columns, an extra integer is added to the output of each phrase for each extra 32 columns or part thereof. Integers corresponding to the same phrase are clumped together. For example, if a table with 45 columns is queried for two phrases, 4 integers are output. The first corresponds to phrase 0 and columns 0-31 of the table. The second integer contains data for phrase 0 and columns 32-44, and so on.</source>
          <target state="translated">테이블에 32 개가 넘는 열이 있으면 추가 32 개 열 또는 그 일부에 대한 각 구의 출력에 추가 정수가 추가됩니다. 같은 문구에 해당하는 정수는 함께 모입니다. 예를 들어, 두 개의 구에 대해 45 개의 열이있는 테이블을 쿼리하면 4 개의 정수가 출력됩니다. 첫 번째는 테이블의 구 0과 열 0-31에 해당합니다. 두 번째 정수에는 구 0과 열 32-44 등의 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dd1a6a322a6da8501607606cd285b56e7643fea3" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xInstCount, xInst, xPhraseFirst and xPhraseNext APIs behave as if the current row contains no phrase matches at all (i.e. xInstCount() returns 0).</source>
          <target state="translated">테이블이 또한 내용이없는 테이블 인 경우 xInstCount, xInst, xPhraseFirst 및 xPhraseNext API는 현재 행에 구문이 일치하지 않는 것처럼 동작합니다 (즉, xInstCount ()는 0을 반환 함).</target>
        </trans-unit>
        <trans-unit id="6fe44f3588c5a2857dcbb9370708a1c62e0664e1" translate="yes" xml:space="preserve">
          <source>If the table is also a contentless table, the xPhraseFirstColumn and xPhraseNextColumn APIs behave as if the current row contains no phrase matches at all (i.e. xPhraseFirstColumn() sets the iterator to EOF).</source>
          <target state="translated">테이블이 내용이없는 테이블 인 경우 xPhraseFirstColumn 및 xPhraseNextColumn API는 현재 행에 구문이 일치하지 않는 것처럼 동작합니다 (즉, xPhraseFirstColumn ()은 반복자를 EOF로 설정합니다).</target>
        </trans-unit>
        <trans-unit id="8fa583fa8336ae813a54303aa49ca52aa9df3514" translate="yes" xml:space="preserve">
          <source>If the tables are not compatible, SQLITE_SCHEMA is returned. If the tables are compatible but do not have any PRIMARY KEY columns, it is not an error but no changes are added to the session object. As with other session APIs, tables without PRIMARY KEYs are simply ignored.</source>
          <target state="translated">테이블이 호환되지 않으면 SQLITE_SCHEMA가 리턴됩니다. 테이블이 호환 가능하지만 PRIMARY KEY 컬럼이없는 경우 오류는 아니지만 세션 오브젝트에 변경 사항이 추가되지 않습니다. 다른 세션 API와 마찬가지로 PRIMARY KEY가없는 테이블은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="39d5998574043194036193b1ccfe1d960d708066" translate="yes" xml:space="preserve">
          <source>If the target database table has an INTEGER PRIMARY KEY, it is not possible to insert a NULL value into the IPK column. Attempting to do so results in an SQLITE_MISMATCH error.</source>
          <target state="translated">대상 데이터베이스 테이블에 INTEGER PRIMARY KEY가 있으면 IPK 열에 NULL 값을 삽입 할 수 없습니다. 이렇게하면 SQLITE_MISMATCH 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c95a9c982f66790e65014b945cf26e39c71b898" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table that has no PRIMARY KEY declaration, the data_% table must also contain a column named &quot;rbu_rowid&quot;. The rbu_rowid column is mapped to the tables &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. For example, if the target database contains either of the following:</source>
          <target state="translated">대상 데이터베이스 테이블이 가상 테이블이거나 PRIMARY KEY 선언이없는 테이블 인 경우 data_ % 테이블에도 &quot;rbu_rowid&quot;라는 열이 포함되어야합니다. rbu_rowid 컬럼은 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 테이블에 맵핑됩니다 . 예를 들어, 대상 데이터베이스에 다음 중 하나가 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="fbd25358ffefdc6dc4f80487cafab05d3b5b26ee" translate="yes" xml:space="preserve">
          <source>If the target database table is a virtual table or a table with no PRIMARY KEY, the rbu_control value should not include a character corresponding to the rbu_rowid value. For example, this:</source>
          <target state="translated">대상 데이터베이스 테이블이 가상 테이블이거나 PRIMARY KEY가없는 테이블 인 경우 rbu_control 값은 rbu_rowid 값에 해당하는 문자를 포함하지 않아야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01af3a5676cb2f1557deacfea75c22d3ec69c112" translate="yes" xml:space="preserve">
          <source>If the text fragment does not begin at the start of a column value, the &quot;ellipses&quot; text is prepended to it.</source>
          <target state="translated">텍스트 조각이 열 값의 시작 부분에서 시작되지 않으면 &quot;ellipses&quot;텍스트가 앞에 붙습니다.</target>
        </trans-unit>
        <trans-unit id="c5699be55281fc6c124864de2ed79fa2e78862fa" translate="yes" xml:space="preserve">
          <source>If the text fragment does not finish at the end of a column value, the &quot;ellipses&quot; text is appended to it.</source>
          <target state="translated">텍스트 조각이 열 값의 끝에서 끝나지 않으면 &quot;ellipses&quot;텍스트가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9b02a2cc603460380751e873e7881c3872500434" translate="yes" xml:space="preserve">
          <source>If the third parameter (the pointer to the sqlite3_module object) is NULL then no new module is create and any existing modules with the same name are dropped.</source>
          <target state="translated">세 번째 매개 변수 (sqlite3_module 객체에 대한 포인터)가 NULL이면 새 모듈이 작성되지 않고 동일한 이름을 가진 기존 모듈이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="1fb42f686bdf0ae2d9460cba55a33f179256de59" translate="yes" xml:space="preserve">
          <source>If the two snapshot handles are not associated with the same database file, the result of the comparison is undefined.</source>
          <target state="translated">두 개의 스냅 샷 핸들이 동일한 데이터베이스 파일과 연관되지 않은 경우 비교 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e40d631505df75eada1d7356f623733efe0e7e84" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">값 N이 범위를 벗어 났거나 N 번째 매개 변수에 이름이 없으면 NULL이 리턴됩니다. 이름 지정된 매개 변수가 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 에서 원래 UTF-16으로 지정된 경우에도 리턴 된 문자열은 항상 UTF-8 인코딩 입니다.</target>
        </trans-unit>
        <trans-unit id="345b60970d744b5b63e874a6cd2300d092b35eca" translate="yes" xml:space="preserve">
          <source>If the value N is out of range or if the N-th parameter is nameless, then NULL is returned. The returned string is always in UTF-8 encoding even if the named parameter was originally specified as UTF-16 in &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">값 N이 범위를 벗어 났거나 N 번째 매개 변수에 이름이 없으면 NULL이 리턴됩니다. 이름 지정된 매개 변수가 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 에서 원래 UTF-16으로 지정된 경우에도 리턴 된 문자열은 항상 UTF-8 인코딩 입니다.</target>
        </trans-unit>
        <trans-unit id="d68928282b4992ea60ac59e231acaeb89700dde0" translate="yes" xml:space="preserve">
          <source>If the value being substituted is larger than the width, then full value is added to the output. In other words, the width is the minimum width of the value as it is rendered in the output.</source>
          <target state="translated">대체되는 값이 너비보다 크면 전체 값이 출력에 추가됩니다. 즉, 너비는 출력에서 ​​렌더링 될 때 값의 최소 너비입니다.</target>
        </trans-unit>
        <trans-unit id="c4b0ded1a1deef22b5fab46f3c6efeda2921b5b8" translate="yes" xml:space="preserve">
          <source>If the value of</source>
          <target state="translated">값이</target>
        </trans-unit>
        <trans-unit id="6f9d3eb4af97233320c8cb8d005d76e733f1eb82" translate="yes" xml:space="preserve">
          <source>If the value of a path/value pair is an SQLite TEXT value, then it is normally inserted as a quoted JSON string, even if the string looks like valid JSON. However, if the value is the result of another json1 function (such as &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; or &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; or &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt;) then it is interpreted as JSON and is inserted as JSON retaining all of its substructure.</source>
          <target state="translated">경로 / 값 쌍의 값이 SQLite TEXT 값인 경우 문자열이 유효한 JSON처럼 보이더라도 인용 된 JSON 문자열로 삽입됩니다. 그러나 값이 다른 json1 함수 (예 : &lt;a href=&quot;json1#jmini&quot;&gt;json ()&lt;/a&gt; 또는 &lt;a href=&quot;json1#jarray&quot;&gt;json_array ()&lt;/a&gt; 또는 &lt;a href=&quot;json1#jobj&quot;&gt;json_object ()&lt;/a&gt; )의 결과 인 경우 JSON으로 해석되고 모든 하위 구조를 보유하는 JSON으로 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="b32ac49b143ce73b794453377ce559efe5961df7" translate="yes" xml:space="preserve">
          <source>If the value of the zString variable is NULL, the generated SQL will look like the following:</source>
          <target state="translated">zString 변수의 값이 NULL이면 생성 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8161ccbb4f6a18f526e60b92f180512b88485f22" translate="yes" xml:space="preserve">
          <source>If the values &quot;inserted&quot; into the text columns as part of a 'delete' command are not the same as those currently stored within the table, the results may be unpredictable.</source>
          <target state="translated">'삭제'명령의 일부로 텍스트 열에 &quot;삽입 된&quot;값이 현재 테이블에 저장된 값과 동일하지 않으면 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="59bbe3f4e62b07925a07b5a183754aca1009b0a0" translate="yes" xml:space="preserve">
          <source>If the variable does not have a bytearray representation, then &quot;@&quot; works just like &quot;$&quot;. Note that &quot;:&quot; works like &quot;$&quot; in all cases so the following is another way to express the same statement:</source>
          <target state="translated">변수에 바이트 배열 표현이 없으면 &quot;@&quot;은 &quot;$&quot;와 같이 작동합니다. &quot;:&quot;는 모든 경우에 &quot;$&quot;와 같이 작동하므로 다음은 동일한 문장을 표현하는 또 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="967912701ccde0cf6890cfdea463d69721e44f33" translate="yes" xml:space="preserve">
          <source>If the virtual machine is unable to open the database file because it is locked by another thread or process, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_BUSY. The calling function should do some other activity, or sleep, for a short amount of time to give the lock a chance to clear, then invoke &lt;b&gt;sqlite_step&lt;/b&gt; again. This can be repeated as many times as desired.</source>
          <target state="translated">가상 머신이 다른 스레드 또는 프로세스에 의해 잠겨 있기 때문에 데이터베이스 파일을 열 수없는 경우 &lt;b&gt;sqlite_step&lt;/b&gt; 은 SQLITE_BUSY를 리턴합니다. 호출 함수는 잠금을 해제 할 기회를주기 위해 짧은 시간 동안 다른 활동 또는 휴면을 수행 한 다음 &lt;b&gt;sqlite_step을&lt;/b&gt; 다시 호출 해야합니다. 이것은 원하는만큼 반복 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d0cab5be9268823b532780f4620139e0b2493eda" translate="yes" xml:space="preserve">
          <source>If the virtual table contains one or more rows that match the search criteria, then the cursor must be left point at the first row. Subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero). If there are no rows match, then the cursor must be left in a state that will cause the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; to return true (non-zero). The SQLite engine will use the &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; and &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; methods to access that row content. The &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; method will be used to advance to the next row.</source>
          <target state="translated">가상 테이블에 검색 기준과 일치하는 하나 이상의 행이 포함 된 경우 커서는 첫 번째 행에서 왼쪽을 가리켜 야합니다. &lt;a href=&quot;vtab#xeof&quot;&gt;xEof에 대한&lt;/a&gt; 후속 호출 은 false를 반환해야합니다. 일치하는 행이 없으면 &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; 가 true (0이 아님)를 리턴 하는 상태로 커서를 두어야합니다 . SQLite 엔진은 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 및 &lt;a href=&quot;vtab#xrowid&quot;&gt;xRowid&lt;/a&gt; 메서드를 사용하여 해당 행 내용에 액세스합니다. &lt;a href=&quot;vtab#xnext&quot;&gt;Xnext를의&lt;/a&gt; 방법은 다음 행으로 진행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0d9be234c914ee5ff307719c3b70dd43c84d33" translate="yes" xml:space="preserve">
          <source>If the virtual table will output rows in the order specified by the ORDER BY clause, then the orderByConsumed flag may be set to true. If the output is not automatically in the correct order then orderByConsumed must be left in its default false setting. This will indicate to the SQLite core that it will need to do a separate sorting pass over the data after it comes out of the virtual table.</source>
          <target state="translated">가상 테이블이 ORDER BY 절에 지정된 순서대로 행을 출력하는 경우 orderByConsumed 플래그가 true로 설정 될 수 있습니다. 출력이 자동으로 올바른 순서가 아닌 경우 orderByConsumed를 기본 false 설정으로 두어야합니다. 이것은 가상 테이블에서 나온 데이터에 대해 별도의 정렬 패스를 수행해야한다는 것을 SQLite 코어에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="40852f77f22b22d25b15aa100b0b83a4fb17d34c" translate="yes" xml:space="preserve">
          <source>If the width is a single &quot;*&quot; character instead of a number, then the actual width value is read as an integer from the argument list. If the value read is negative, then the absolute value is used for the width and the value is left-justified as if the &quot;-&quot; flag were present.</source>
          <target state="translated">너비가 숫자 대신 단일 &quot;*&quot;문자 인 경우 실제 너비 값은 인수 목록에서 정수로 읽습니다. 읽은 값이 음수이면 너비에 절대 값이 사용되고 &quot;-&quot;플래그가있는 것처럼 값이 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5f665397e9a7b0fe05142c4eb0f952c2d738840c" translate="yes" xml:space="preserve">
          <source>If the xAccess() query required by H35490 reveals that the journal file is still present in the file system, then SQLite shall conclude that the journal file is a</source>
          <target state="translated">H35490에 의해 요구 된 xAccess () 쿼리가 저널 파일이 여전히 파일 시스템에 있음을 나타내면 SQLite는 저널 파일이</target>
        </trans-unit>
        <trans-unit id="2ece4dc60c85bd0f6370651e04aa59f231e6a232" translate="yes" xml:space="preserve">
          <source>If the xColumn method implementation calls none of the functions above, then the value of the column defaults to an SQL NULL.</source>
          <target state="translated">xColumn 메소드 구현이 위의 함수를 호출하지 않으면 열 값의 기본값은 SQL NULL입니다.</target>
        </trans-unit>
        <trans-unit id="df9512eb02b352fc76419bfac69b024afe92a594" translate="yes" xml:space="preserve">
          <source>If the xCreate method is omitted (left as a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;. New instances of the virtual table cannot be created using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; and the virtual table can only be used via its module name. Note that SQLite versions prior to 3.9.0 (2015-10-14) do not understand eponymous-only virtual tables and will segfault if an attempt is made to &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; on an eponymous-only virtual table because the xCreate method was not checked for null.</source>
          <target state="translated">xCreate 메소드가 생략되면 (NULL 포인터로 남음) 가상 테이블은 시상 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 입니다. &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE을&lt;/a&gt; 사용하여 가상 테이블의 새 인스턴스를 작성할 수 없으며 가상 테이블은 해당 모듈 이름을 통해서만 사용할 수 있습니다. 3.9.0 (2015-10-14) 이전의 SQLite 버전은 eponymous-only 가상 테이블을 이해하지 못하며 xCreate 메소드가 검사되지 않았기 때문에 eponymous-only 가상 테이블에서 &lt;a href=&quot;lang_createvtab&quot;&gt;VIRTUAL TABLE&lt;/a&gt; 을 작성하려고 시도하면 segfault가 발생합니다. null의 경우</target>
        </trans-unit>
        <trans-unit id="2621a8e3fdadffc723f38e49d09955e1039ab97f" translate="yes" xml:space="preserve">
          <source>If the xCreate method is the exact same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, that indicates that the virtual table does not need to initialize backing store. Such a virtual table can be used as an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; or as a named virtual table using &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; or both.</source>
          <target state="translated">xCreate 메소드가 xConnect 메소드와 정확히 동일한 포인터 인 경우 &lt;a href=&quot;vtab#xconnect&quot;&gt;이는&lt;/a&gt; 가상 테이블이 백업 저장소를 초기화 할 필요가 없음을 나타냅니다. 이러한 가상 테이블은 &lt;a href=&quot;vtab#epovtab&quot;&gt;시상 가상 테이블&lt;/a&gt; 또는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 또는 둘 다를 사용하여 명명 된 가상 테이블 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ea6013e86112c06dab3e4770a560b43808bcc0c" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">xEntryPoint 루틴에 오류가 발생하면 * pzErrMsg가 적절한 오류 메시지 ( &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻음)를 가리키고 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야 합니다 . SQLite는 xEntryPoint ()를 호출하기 전에 * pzErrMsg가 NULL인지 확인합니다. SQLite는 xEntryPoint ()가 리턴 된 후 * pzErrMsg에서 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출 합니다. xEntryPoint ()가 오류를 반환하면 xEntryPoint ()를 유발 한 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f84dff46c33beaf54e0ca4079880cc37a3fce130" translate="yes" xml:space="preserve">
          <source>If the xEntryPoint routine encounters an error, it should make *pzErrMsg point to an appropriate error message (obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt;) and return an appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;. SQLite ensures that *pzErrMsg is NULL before calling the xEntryPoint(). SQLite will invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on *pzErrMsg after xEntryPoint() returns. If any xEntryPoint() returns an error, the &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that provoked the xEntryPoint() will fail.</source>
          <target state="translated">xEntryPoint 루틴에 오류가 발생하면 * pzErrMsg가 적절한 오류 메시지 ( &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻음)를 가리키고 적절한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야 합니다 . SQLite는 xEntryPoint ()를 호출하기 전에 * pzErrMsg가 NULL인지 확인합니다. SQLite는 xEntryPoint ()가 리턴 된 후 * pzErrMsg에서 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출 합니다. xEntryPoint ()가 오류를 반환하면 xEntryPoint ()를 유발 한 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="74fa84b64e4977d1c29908e0f6708d6d082c0af7" translate="yes" xml:space="preserve">
          <source>If the xUpdate method is performing an UPDATE, then &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; can be used to discover which columns of the virtual table were actually modified by the UPDATE statement. The &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange(X)&lt;/a&gt; interface returns true for columns that do not change. On every UPDATE, SQLite will first invoke &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; separately for each unchanging column in the table to obtain the value for that column. The &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method can check to see if the column is unchanged at the SQL level by invoking &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt;. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; sees that the column is not being modified, it should return without setting a result using one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces. Only in that case &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; will be true within the xUpdate method. If &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; does invoke one or more &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx()&lt;/a&gt; interfaces, then SQLite understands that as a change in the value of the column and the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; call for that column within xUpdate will return false.</source>
          <target state="translated">xUpdate 메소드가 UPDATE를 수행하는 경우 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 를 사용하여 UPDATE 문에 의해 실제로 수정 된 가상 테이블의 열을 발견 할 수 있습니다. &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange (X)&lt;/a&gt; 변경하지 않는 열에 대한 진정한 인터페이스로 돌아갑니다. 모든 UPDATE에서 SQLite는 먼저 테이블의 변경되지 않은 각 열에 대해 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn을&lt;/a&gt; 개별적으로 호출 하여 해당 열의 값을 얻습니다. &lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumn에는의&lt;/a&gt; 방법은 열이 호출하여 SQL 레벨 그대로 있는지 확인할 수 &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange을 ()&lt;/a&gt; . 경우 &lt;a href=&quot;vtab#xcolumn&quot;&gt;Xcolumn에는이&lt;/a&gt; 열이 수정되지 않는 것을보고, 그 중 하나를 사용하여 결과를 설정하지 않고 리턴한다 &lt;a href=&quot;c3ref/result_blob&quot;&gt;) (을 sqlite3_result_xxxxx&lt;/a&gt;인터페이스. 이 경우에만 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; 가 xUpdate 메소드 내에서 true가됩니다. &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 이 하나 이상의 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_xxxxx ()&lt;/a&gt; 인터페이스를 호출하는 경우 SQLite 는 xUpdate 내 에서 열 값과 해당 열에 대한 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; 호출이 false로 리턴됨을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="7b85064db380f0c3b1175d1e7fe24a5bdf881bd8" translate="yes" xml:space="preserve">
          <source>If the xUpdate method violates some constraint of the virtual table (including, but not limited to, attempting to store a value of the wrong datatype, attempting to store a value that is too large or too small, or attempting to change a read-only value) then the xUpdate must fail with an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">xUpdate 메소드가 가상 테이블의 일부 제한 조건을 위반하는 경우 (잘못된 데이터 유형의 값 저장 시도, 너무 크거나 너무 작은 값 저장 시도 또는 읽기 전용 변경 시도 포함) xUpdate는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드로&lt;/a&gt; 실패해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9a7985513fccd145b507f142e6f37dfce68e7177" translate="yes" xml:space="preserve">
          <source>If the zString variable holds text like &quot;Hello&quot;, then this statement will work just fine. But suppose the user enters a string like &quot;Hi y'all!&quot;. The SQL statement generated reads as follows:</source>
          <target state="translated">zString 변수에 &quot;Hello&quot;와 같은 텍스트가 있으면이 명령문이 제대로 작동합니다. 그러나 사용자가 &quot;Hi y'all!&quot;과 같은 문자열을 입력한다고 가정하십시오. 생성 된 SQL 문은 다음과 같이 읽습니다.</target>
        </trans-unit>
        <trans-unit id="38c9c0042a5b1d208534216bf07dfb6099f9ebb4" translate="yes" xml:space="preserve">
          <source>If there are many client programs sending SQL to the same database over a network, then use a client/server database engine instead of SQLite. SQLite will work over a network filesystem, but because of the latency associated with most network filesystems, performance will not be great. Also, file locking logic is buggy in many network filesystem implementations (on both Unix and Windows). If file locking does not work correctly, two or more clients might try to modify the same part of the same database at the same time, resulting in corruption. Because this problem results from bugs in the underlying filesystem implementation, there is nothing SQLite can do to prevent it.</source>
          <target state="translated">네트워크를 통해 동일한 데이터베이스로 SQL을 전송하는 클라이언트 프로그램이 많은 경우 SQLite 대신 클라이언트 / 서버 데이터베이스 엔진을 사용하십시오. SQLite는 네트워크 파일 시스템을 통해 작동하지만 대부분의 네트워크 파일 시스템과 관련된 대기 시간으로 인해 성능이 좋지 않습니다. 또한 파일 잠금 로직은 많은 네트워크 파일 시스템 구현에서 유닉스와 Windows 모두에서 버그가 있습니다. 파일 잠금이 제대로 작동하지 않으면 둘 이상의 클라이언트가 동일한 데이터베이스의 동일한 부분을 동시에 수정하려고 시도하여 손상 될 수 있습니다. 이 문제는 기본 파일 시스템 구현의 버그로 인해 발생하므로이를 방지하기 위해 SQLite가 할 수있는 일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="36f4c3a2fda5cf31617c5fabae95e90bafd39057" translate="yes" xml:space="preserve">
          <source>If there are multiple (hard or symbolic) links to a database file, the journal will be created using the name of the link through which the file was opened. If a crash occurs and the database is opened again using a different link, the hot journal will not be located and no rollback will occur.</source>
          <target state="translated">데이터베이스 파일에 대한 여러 (하드 또는 기호) 링크가있는 경우 파일을 여는 링크의 이름을 사용하여 저널이 작성됩니다. 충돌이 발생하고 다른 링크를 사용하여 데이터베이스를 다시 열면 핫 저널이없고 롤백이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11044e3b942016886a776e1bab1892306cb966d9" translate="yes" xml:space="preserve">
          <source>If there are still more pages to copy from database pDb, then the function sleeps for 250 milliseconds (using the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; utility) and then returns to step 2.</source>
          <target state="translated">데이터베이스 pDb에서 복사 할 페이지가 여전히 더 있으면이 함수는 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 유틸리티를 사용하여 250 밀리 초 동안 휴면 한 다음 2 단계로 돌아갑니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
