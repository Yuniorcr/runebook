<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">기본적으로 자동이지만 응용 프로그램 개발자가 염두에 두어야 할 추가 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; 및 &lt;code&gt;-wal&lt;/code&gt; 파일을 작성할 수 있도록 데이터베이스가 포함 된 디렉토리에 대한 쓰기 권한 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">차단 된 연결로 등록 된 최대 하나의 잠금 해제 알림 콜백이있을 수 있습니다. 차단 된 연결에 이미 등록 된 잠금 해제 알림 콜백이있을 때 sqlite3_unlock_notify ()가 호출되면 새 콜백이 이전 콜백을 대체합니다. sqlite3_unlock_notify ()가 두 번째 인수로 NULL 포인터를 사용하여 호출되면 기존 잠금 해제 알림 콜백이 취소됩니다. &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 차단 된 연결을 닫으면 차단 된 연결 잠금 해제 알림 콜백도 취소 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">차단 된 연결로 등록 된 최대 하나의 잠금 해제 알림 콜백이있을 수 있습니다. 차단 된 연결에 이미 등록 된 잠금 해제 알림 콜백이있을 때 sqlite3_unlock_notify ()가 호출되면 새 콜백이 이전 콜백을 대체합니다. sqlite3_unlock_notify ()가 두 번째 인수로 NULL 포인터를 사용하여 호출되면 기존 잠금 해제 알림 콜백이 취소됩니다. &lt;a href=&quot;close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 차단 된 연결을 닫으면 차단 된 연결 잠금 해제 알림 콜백도 취소 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">병합 충돌이있을 수 있습니다. 즉, (2)에서 (3)으로 변경 한 내용이 (1)에서 (4)로 변경 한 내용과 호환되지 않을 수 있습니다. 이 경우 관리자는 충돌을 수동으로 해결해야합니다. 바라건대 갈등이 자주 일어나지 않을 것입니다. 개인 편집 내용을 최소로 유지하면 충돌이 발생할 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">가상 테이블 인스턴스 및 xUpdate 메소드가 호출 될 때 가상 테이블의 행에서 하나 이상의 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; 오브젝트가 열려 있고 사용 중일 수 있습니다. 다른 기존 커서에서 테이블의 행을 삭제하거나 수정하려는 경우 xUpdate 구현을 준비해야합니다. 가상 테이블이 그러한 변경을 수용 할 수없는 경우 xUpdate 메소드는 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">이 명령어를 실행하기 전에 데이터베이스에 읽기 잠금이 있어야합니다 (트랜잭션을 시작해야하거나 열린 커서가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">union-vtab의 다양한 테이블에 대한 rowid 밴드에는 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">SQL 문이 리턴 한 행에 겹치는 rowid 범위가 없어야합니다. 있으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">데이터베이스 연결 D의 스키마 S에서 열려있는 쓰기 트랜잭션이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">sqlite3_backup_init ()를 성공적으로 호출 할 때마다 sqlite3_backup_finish ()를 정확히 한 번 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">인덱싱 된 테이블에서 SQLite가 제대로 수행되지 않았다는보고가있었습니다. 이 테스트는 최근 그 소문을 반증하기 위해 추가되었습니다. SQLite가 다른 엔진처럼 새 인덱스 항목을 만드는 데 빠르지는 않지만 (아래 테스트 6 참조) 전체 속도는 여전히 낫습니다.</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">이 API는 라이브러리가 &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C 프리 프로세서 기호 로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">이 API는 라이브러리가 &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C 프리 프로세서 기호 로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">이 조치 코드 값은 어떤 종류의 조작이 권한 부여되는지를 나타냅니다. 권한 부여 콜백 함수의 3 번째 및 4 번째 매개 변수는 두 번째 매개 변수로 사용되는 코드에 따라 매개 변수 또는 NULL입니다. 권한 부 여자 콜백에 대한 다섯 번째 매개 변수는 해당되는 경우 데이터베이스 이름 ( &quot;main&quot;, &quot;temp&quot;등)입니다. 권한 부 여자 콜백의 6 번째 매개 변수는 액세스 시도를 담당하는 가장 안쪽 트리거 또는보기의 이름이거나이 액세스 시도가 최상위 SQL 코드에서 직접 수행 된 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">이러한 구문 및 기타 유사한 구문 제한 사항은 텍스트에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">이는 SQLite를 응용 프로그램 파일 형식으로 사용함으로써 얻을 수있는 이점 중 일부입니다. OpenOffice와 같은 응용 프로그램의 사용자 경험을 향상시킬 가능성이 가장 높습니다. 다른 응용 프로그램은 다른 방식으로 SQLite를 활용할 수 있습니다. 추가 아이디어 는 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; 와 같은 루틴에 최종 인수로 전달되는 소멸자에 대한 특수 값입니다 . 소멸자 인수가 SQLITE_STATIC 인 경우 컨텐츠 포인터가 일정하고 변경되지 않음을 의미합니다. 파괴 할 필요가 없습니다. SQLITE_TRANSIENT 값은 가까운 시일 내에 컨텐츠가 변경 될 가능성이 있으며 SQLite는 리턴하기 전에 자체 컨텐츠 사본을 작성해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; 와 같은 루틴에 최종 인수로 전달되는 소멸자에 대한 특수 값입니다 . 소멸자 인수가 SQLITE_STATIC 인 경우 컨텐츠 포인터가 일정하고 변경되지 않음을 의미합니다. 파괴 할 필요가 없습니다. SQLITE_TRANSIENT 값은 가까운 시일 내에 컨텐츠가 변경 될 가능성이 있으며 SQLite는 리턴하기 전에 자체 컨텐츠 사본을 작성해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">지원되는 8 개의 잠금 장치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b356241fa91bdf09876f0517086180731227ee47" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">이들은 &lt;a href=&quot;../vfs&quot;&gt;사용자 정의 VFS 구현에&lt;/a&gt; 유용한 유틸리티 루틴으로, 데이터베이스 파일이 특정 쿼리 매개 변수를 포함하는 URI인지 확인하고, 그렇다면 해당 쿼리 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="56ef0cc4c32969ca19f4793dd10614a44d9a509c" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">이들은 &lt;a href=&quot;vfs&quot;&gt;사용자 정의 VFS 구현에&lt;/a&gt; 유용한 유틸리티 루틴으로, 데이터베이스 파일이 특정 쿼리 매개 변수를 포함하는 URI인지 확인하고, 그렇다면 해당 쿼리 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">이들은 VFS 구현에 유용한 유틸리티 루틴으로, 데이터베이스 파일이 특정 쿼리 매개 변수를 포함하는 URI인지 확인하여 해당 쿼리 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">이 비트 값은 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스에 대한 세 번째 매개 변수 및 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드 에 대한 네 번째 매개 변수에서 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">이 비트 값은 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스에 대한 세 번째 매개 변수 및 &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드 에 대한 네 번째 매개 변수에서 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">SQLite의 기본 동작에서 이러한 변경 사항은 호환성이 아닙니다. 모든 레거시 데이터베이스 파일은 최신 버전의 SQLite에서 계속 읽고 쓸 수 있으며 새로 작성된 모든 데이터베이스 파일은 레거시 버전의 SQLite 라이브러리에서 계속 읽고 쓸 수 있습니다. 변경되는 유일한 것은 일부 기본 설정입니다. 이로 인해 많은 응용 프로그램의 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">이 상수는 SQLite가 지원하는 다양한 텍스트 인코딩을 나타내는 정수 코드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">이 상수는 각 유형에 대한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 에 의해 리턴되어 평가중인 SQL 문에 대한 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드가 무엇인지 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 에 의해 리턴되어 평가중인 SQL 문에 대한 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드가 무엇인지 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 &quot;verbs&quot;입니다 .</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 &quot;verbs&quot;입니다 .</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스에 첫 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스에 첫 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 의 첫 번째 인수로 사용 된 유효한 작업 코드 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 의 첫 번째 인수로 사용 된 유효한 작업 코드 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스에 세 번째 매개 변수로 전달 된 &quot;체크 포인트 모드&quot;에 유효한 모든 값을 정의합니다 . 이러한 각 검사 점 모드의 의미에 대한 자세한 내용은 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스에 세 번째 매개 변수로 전달 된 &quot;체크 포인트 모드&quot;에 유효한 모든 값을 정의합니다 . 이러한 각 검사 점 모드의 의미에 대한 자세한 내용은 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 인터페이스 의 &quot;prepFlags&quot;매개 변수로 전달 될 수있는 다양한 플래그를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 및 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 인터페이스 의 &quot;prepFlags&quot;매개 변수로 전달 될 수있는 다양한 플래그를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 런타임에 낮출 수있는 다양한 성능 한계를 정의 합니다. 다양한 한계의 의미에 대한 개요는 다음과 같습니다. 추가 정보는 &lt;a href=&quot;limits&quot;&gt;SQLite의 한계에서&lt;/a&gt; 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 런타임에 낮출 수있는 다양한 성능 한계를 정의 합니다. 다양한 한계의 의미에 대한 개요는 다음과 같습니다. 추가 정보는 &lt;a href=&quot;../limits&quot;&gt;SQLite의 한계에서&lt;/a&gt; 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 추적 논리를 사용하여 모니터링 할 수있는 이벤트 클래스를 식별 합니다. &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 (D, M, X, P)&lt;/a&gt; 에 대한 M 인수 는 다음 상수 중 하나 이상의 OR 조합입니다. 추적 콜백에 대한 첫 번째 인수는 다음 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 추적 논리를 사용하여 모니터링 할 수있는 이벤트 클래스를 식별 합니다. &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 (D, M, X, P)&lt;/a&gt; 에 대한 M 인수 는 다음 상수 중 하나 이상의 OR 조합입니다. 추적 콜백에 대한 첫 번째 인수는 다음 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2 ()에&lt;/a&gt; 대한 네 번째 인수로 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;선호하는 텍스트 인코딩&lt;/a&gt; 과 함께 OR 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; , &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 또는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2 ()에&lt;/a&gt; 대한 네 번째 인수로 &lt;a href=&quot;c_any&quot;&gt;선호하는 텍스트 인코딩&lt;/a&gt; 과 함께 OR 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">이러한 함수 (통칭하여 &quot;함수 작성 루틴&quot;이라고 함)는 SQL 함수 또는 집계를 추가하거나 기존 SQL 함수 또는 집계의 동작을 재정의하는 데 사용됩니다. 세 가지 &quot;sqlite3_create_function *&quot;루틴의 유일한 차이점은 두 번째 매개 변수에 대해 예상되는 텍스트 인코딩 (작성중인 함수의 이름)과 애플리케이션 데이터 포인터에 대한 소멸자 콜백의 존재 여부입니다. sqlite3_create_window_function () 함수는 비슷하지만 사용자가 &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;집계 창 함수에&lt;/a&gt; 필요한 추가 콜백 함수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">이러한 함수 (통칭하여 &quot;함수 작성 루틴&quot;이라고 함)는 SQL 함수 또는 집계를 추가하거나 기존 SQL 함수 또는 집계의 동작을 재정의하는 데 사용됩니다. 세 가지 &quot;sqlite3_create_function *&quot;루틴의 유일한 차이점은 두 번째 매개 변수에 대해 예상되는 텍스트 인코딩 (작성중인 함수의 이름)과 애플리케이션 데이터 포인터에 대한 소멸자 콜백의 존재 여부입니다. sqlite3_create_window_function () 함수는 비슷하지만 사용자가 &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;집계 창 함수에&lt;/a&gt; 필요한 추가 콜백 함수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">이 함수 는 첫 번째 인수로 지정된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 관련된 &lt;a href=&quot;../datatype3#collation&quot;&gt;데이터 정렬을&lt;/a&gt; 추가, 제거 또는 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">이 함수 는 첫 번째 인수로 지정된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 관련된 &lt;a href=&quot;datatype3#collation&quot;&gt;데이터 정렬을&lt;/a&gt; 추가, 제거 또는 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;capi3ref&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; . 이전 코드와의 호환성을 유지하기 위해 이러한 기능은 계속 지원됩니다. 그러나 새 응용 프로그램에서는 이러한 기능을 사용하지 않아야합니다. 프로그래머가 이러한 기능을 피하도록 장려하기 위해 우리는 그 기능을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;experimental&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; . 이전 코드와의 호환성을 유지하기 위해 이러한 기능은 계속 지원됩니다. 그러나 새 응용 프로그램에서는 이러한 기능을 사용하지 않아야합니다. 프로그래머가 이러한 기능을 피하도록 장려하기 위해 우리는 그 기능을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">이러한 함수는 (비 집계) SQL 함수에서 메타 데이터를 인수 값과 연결하는 데 사용할 수 있습니다. 쿼리 실행 중 동일한 값이 동일한 SQL 함수의 여러 호출에 전달되면 일부 상황에서 관련 메타 데이터가 보존 될 수 있습니다. 이것이 유용한 곳의 예는 정규식 일치 함수입니다. 정규식의 컴파일 된 버전은 패턴 문자열과 연관된 메타 데이터로 저장 될 수 있습니다. 그런 다음 패턴 문자열이 동일하게 유지되는 한 컴파일 된 정규식을 동일한 함수의 여러 호출에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">이 함수는 0000-01-01 00:00:00과 9999-12-31 23:59:59 사이의 날짜에만 작동합니다 (줄리아 일수 1721059.5 ~ 5373484.5). 해당 범위를 벗어난 날짜의 경우 이러한 함수의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05e896fbaa59935c0c643898daaa4791cc7323f5" translate="yes" xml:space="preserve">
          <source>These functions respectively add, subtract, and multiply their arguments and return a new text string that is the decimal representation of the result. There is no division operator at this time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">이러한 함수 는 준비된 명령문에서 값을 호스트 매개 변수에 바인드하는 데 사용되는 함수의 함수 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 함수 와 매우 유사합니다 . 추가 정보 는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">이러한 함수 는 준비된 명령문에서 값을 호스트 매개 변수에 바인드하는 데 사용되는 함수의 함수 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 함수 와 매우 유사합니다 . 추가 정보 는 &lt;a href=&quot;bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xFileControl 메소드 및 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스의 opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xFileControl 메소드 및 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스의 opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xAccess 메서드에 대한 세 번째 매개 변수로 사용할 수 있습니다 . 그들은 xAccess 메소드가 어떤 종류의 권한을 찾고 있는지 결정합니다. SQLITE_ACCESS_EXISTS를 사용하면 xAccess 메소드는 단순히 파일이 존재하는지 여부를 확인합니다. SQLITE_ACCESS_READWRITE를 사용하여 xAccess 메소드는 이름 지정된 디렉토리가 읽기 가능하고 쓰기 가능한지 여부를 확인합니다 (즉, 디렉토리 내에서 파일을 추가, 제거 및 이름을 바꿀 수있는 경우). SQLITE_ACCESS_READWRITE 상수는 현재 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; 에서만 사용됩니다., 향후 SQLite 릴리스에서 변경 될 수 있습니다. SQLITE_ACCESS_READ를 사용하여 xAccess 메소드는 파일을 읽을 수 있는지 여부를 확인합니다. SQLITE_ACCESS_READ 상수는 현재 사용되지 않지만 향후 SQLite 릴리스에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xAccess 메서드에 대한 세 번째 매개 변수로 사용할 수 있습니다 . 그들은 xAccess 메소드가 어떤 종류의 권한을 찾고 있는지 결정합니다. SQLITE_ACCESS_EXISTS를 사용하면 xAccess 메소드는 단순히 파일이 존재하는지 여부를 확인합니다. SQLITE_ACCESS_READWRITE를 사용하여 xAccess 메소드는 이름 지정된 디렉토리가 읽기 가능하고 쓰기 가능한지 여부를 확인합니다 (즉, 디렉토리 내에서 파일을 추가, 제거 및 이름을 바꿀 수있는 경우). SQLITE_ACCESS_READWRITE 상수는 현재 &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; 에서만 사용됩니다., 향후 SQLite 릴리스에서 변경 될 수 있습니다. SQLITE_ACCESS_READ를 사용하여 xAccess 메소드는 파일을 읽을 수 있는지 여부를 확인합니다. SQLITE_ACCESS_READ 상수는 현재 사용되지 않지만 향후 SQLite 릴리스에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드가 허용하는 다양한 잠금 조작을 정의합니다 . 다음은 xShmLock 메소드에 대한 플래그의 올바른 조합입니다.</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드가 허용하는 다양한 잠금 조작을 정의합니다 . 다음은 xShmLock 메소드에 대한 플래그의 올바른 조합입니다.</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()에&lt;/a&gt; 의해 리턴 될 수있는 다양한 런타임 상태 매개 변수를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;status&quot;&gt;sqlite3_status ()에&lt;/a&gt; 의해 리턴 될 수있는 다양한 런타임 상태 매개 변수를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">이러한 인터페이스는 &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; 에서 이전에 얻은 sqlite3_str 객체에 내용을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">이러한 인터페이스는 &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; 에서 이전에 얻은 sqlite3_str 객체에 내용을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">이 인터페이스는 Windows에서만 사용 가능합니다. &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스는 관련된 값으로 설정하는 데 사용되는 &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; type 매개 변수의 값에 따라 zValue하는 변수. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt; 를 통해 이전 값을 해제하려면 zValue 매개 변수가 NULL이어야합니다 . NULL이 아닌 값은 사용하기 전에 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 복사 됩니다. &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; , 성공을 표시하는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 유형이 지원되지 않는 경우, 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;메모리를 할당 할 수없는 경우 &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 변수 의 값은 해당 개념이 존재하지 않는 Win32의 하위 플랫폼 (예 : WinRT 및 UWP)에서 현재 디렉토리를 대체하는 역할을합니다. &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; 문자열 파라미터 인터페이스 sqlite3_win32_set_directory 제외한 각각 UTF-8 또는 UTF-16가되어야하므로, 인터페이스 똑같은 동작.</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">이 인터페이스는 Windows에서만 사용 가능합니다. &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스는 관련된 값으로 설정하는 데 사용되는 &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 또는 &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; type 매개 변수의 값에 따라 zValue하는 변수. &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; 를 통해 이전 값을 해제하려면 zValue 매개 변수가 NULL이어야합니다 . NULL이 아닌 값은 사용하기 전에 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 복사 됩니다. &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스 반환 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; , 성공을 표시하는 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 유형이 지원되지 않는 경우, 또는 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;메모리를 할당 할 수없는 경우 &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 변수 의 값은 해당 개념이 존재하지 않는 Win32의 하위 플랫폼 (예 : WinRT 및 UWP)에서 현재 디렉토리를 대체하는 역할을합니다. &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; 및 &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; 문자열 파라미터 인터페이스 sqlite3_win32_set_directory 제외한 각각 UTF-8 또는 UTF-16가되어야하므로, 인터페이스 똑같은 동작.</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">이러한 인터페이스는 SQLite가 &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; 컴파일 시간 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">이러한 인터페이스는 SQLite가 &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; 컴파일 시간 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">이 인터페이스는 SQLite의 성능에 대한 런타임 상태 정보를 검색하고 선택적으로 다양한 상한 표시를 재설정하는 데 사용됩니다. 첫 번째 인수는 측정 할 특정 매개 변수의 정수 코드입니다. 인식되는 정수 코드는 &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt; 형식 입니다. 매개 변수의 현재 값은 * pCurrent로 리턴됩니다. 기록 된 최고 값은 * pHighwater로 리턴됩니다. resetFlag가 true이면 * pHighwater가 기록 된 후 가장 높은 레코드 값이 재설정됩니다. 일부 매개 변수는 가장 높은 값을 기록하지 않습니다. 이러한 매개 변수의 경우 * pHighwater에 아무것도 기록되지 않으며 resetFlag는 무시됩니다. 다른 매개 변수는 현재 값이 아닌 최고 사용 표시 점 만 기록합니다. 후자의 매개 변수의 경우 * pCurrent에 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">이 인터페이스는 SQLite의 성능에 대한 런타임 상태 정보를 검색하고 선택적으로 다양한 상한 표시를 재설정하는 데 사용됩니다. 첫 번째 인수는 측정 할 특정 매개 변수의 정수 코드입니다. 인식되는 정수 코드는 &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt; 형식 입니다. 매개 변수의 현재 값은 * pCurrent로 리턴됩니다. 기록 된 최고 값은 * pHighwater로 리턴됩니다. resetFlag가 true이면 * pHighwater가 기록 된 후 가장 높은 레코드 값이 재설정됩니다. 일부 매개 변수는 가장 높은 값을 기록하지 않습니다. 이러한 매개 변수의 경우 * pHighwater에 아무것도 기록되지 않으며 resetFlag는 무시됩니다. 다른 매개 변수는 현재 값이 아닌 최고 사용 표시 점 만 기록합니다. 후자의 매개 변수의 경우 * pCurrent에 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">이러한 인터페이스는 응용 프로그램에서 SQLite가 사용중인 메모리 양을 모니터링하는 데 사용할 수 있습니다. &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 으로 돌아 간다 현재 사용중인 메모리의 바이트 수와 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 최대 순간 메모리 사용을 반환합니다. 어느 루틴도 메모리 할당 자와 관련된 오버 헤드를 포함하지 않습니다. 이 루틴은 응용 프로그램에서 사용하기 위해 제공됩니다. SQLite는 결코 그들 자신을 호출하지 않습니다. 따라서 애플리케이션이 자체 메모리 할당 서브 시스템을 제공하는 경우 원하는 경우 이러한 인터페이스를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6bfb4cf13a4a1ec7a21d1345619d3a829697d4" translate="yes" xml:space="preserve">
          <source>These interfaces impose limits on the amount of heap memory that will be by all database connections within a single process.</source>
          <target state="translated">이러한 인터페이스는 단일 프로세스 내의 모든 데이터베이스 연결에 사용되는 힙 메모리 양을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">이 인터페이스는 같은 정보를 제공 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; , &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER을&lt;/a&gt; 하고 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전처리 매크로하지만 라이브러리 대신 헤더 파일과 연결되어 있습니다. 신중한 프로그래머는 응용 프로그램에 assert () 문을 포함하여 이러한 인터페이스에서 반환 된 값이 헤더의 매크로와 일치하는지 확인하여 응용 프로그램이 일치하는 라이브러리 및 헤더 파일로 컴파일되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">이 인터페이스는 같은 정보를 제공 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; , &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER을&lt;/a&gt; 하고 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전처리 매크로하지만 라이브러리 대신 헤더 파일과 연결되어 있습니다. 신중한 프로그래머는 응용 프로그램에 assert () 문을 포함하여 이러한 인터페이스에서 반환 된 값이 헤더의 매크로와 일치하는지 확인하여 응용 프로그램이 일치하는 라이브러리 및 헤더 파일로 컴파일되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 의 현재 상태를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 의 현재 상태를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0bd4a9c1d8ef359db205ab90399688f58e57b40f" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;../vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edf2097b32647c30069fed117ef937baf26e2654" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="translated">이러한 interfces는 &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; 구현 에서 사용하기 위해 제공되며 해당 컨텍스트 외부에서는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">이 매크로는 Windows에서만 사용할 수 있습니다. 형식 인수에 허용되는 값을 &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스에 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">이 매크로는 Windows에서만 사용할 수 있습니다. 형식 인수에 허용되는 값을 &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스에 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a53b463320023e1da4e50fb5fb587f4bc7e0b044" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이러한 매크로는 &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의합니다 . 각 값은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에있는 제약 조건의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="285af12f9b73f8c383619a138a0750effc7e59e8" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이러한 매크로는 &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의합니다 . 각 값은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에있는 제약 조건의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">이 매크로 는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현이 동작을 사용자 정의하고 최적화하는 데 사용할 수 있는 &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; 인터페이스에 대한 다양한 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">이 매크로 는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현이 동작을 사용자 정의하고 최적화하는 데 사용할 수 있는 &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; 인터페이스에 대한 다양한 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의했습니다 . 각 값은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에서 제약 조건 용어의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의했습니다 . 각 값은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에서 제약 조건 용어의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 결과 코드를 리턴하지 않습니다. 오류가 발생하면 해당 사실은 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 기록되며 후속 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 호출로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 결과 코드를 리턴하지 않습니다. 오류가 발생하면 해당 사실은 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 기록되며 후속 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 호출로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">이러한 메소드는 가상 테이블 구현에 중첩 트랜잭션을 구현할 수있는 기회를 제공합니다. 이들은 항상 선택적이며 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;버전 3.7.7&lt;/a&gt; (2011-06-23) 이상 에서만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">이러한 작업은 섹션에 자세히 설명되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않으며 새 코드에서 사용해서는 안됩니다. 이전 버전과의 호환성을 위해 유지되지만 이제는 운영 체제가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">이 페이지는 정확하고 자세한 사양으로 작성되었습니다. 튜토리얼 소개는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">이러한 매개 변수 및 의미는 예고없이 변경 될 수 있습니다. 이 값은 테스트 목적으로 만 사용됩니다. 응용 프로그램은 이러한 매개 변수 또는 &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 인터페이스를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">이러한 매개 변수 및 의미는 예고없이 변경 될 수 있습니다. 이 값은 테스트 목적으로 만 사용됩니다. 응용 프로그램은 이러한 매개 변수 또는 &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 인터페이스를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">이 pragma는 비표준 컴파일 시간 옵션을 사용하는 빌드에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">이 pragma는 SQLite 테스트에 사용되며 응용 프로그램에서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">이러한 전 처리기 매크로는 &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스 와 관련된 카운터 값의 이름을 지정하는 정수 코드를 정의합니다 . 다양한 카운터의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">이러한 전 처리기 매크로는 &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스 와 관련된 카운터 값의 이름을 지정하는 정수 코드를 정의합니다 . 다양한 카운터의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1d52a4f9ee56f3e7a3ab55d8ba1b413dd3cccc36" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c705c2e0cd7b6320d8503e4412e5e99c6ba613d2" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="translated">이러한 루틴은 기본 데이터베이스 파일, 저널 파일 및 WAL 파일 간의 파일 이름을 변환 &lt;a href=&quot;vfs&quot;&gt;하기&lt;/a&gt; 위해 사용자 지정 VFS 구현 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">이 루틴은 더 이상 사용되지 않습니다. 사용 &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 루틴은 여기에 설명 대신 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">이 루틴은 더 이상 사용되지 않습니다. 사용 &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 루틴은 여기에 설명 대신 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">이 루틴은 SQL 함수 및 집계를 구현하는 xFunc 또는 xFinal 콜백에서 사용됩니다. 추가 정보는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">이 루틴은 SQL 함수 및 집계를 구현하는 xFunc 또는 xFinal 콜백에서 사용됩니다. 추가 정보는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">이 루틴은 새로운 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 이름 을 등록하는 데 사용됩니다 . 모듈을 사용하여 새 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 작성하기 전에 그리고 모듈에 대해 기존 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용 하기 전에 모듈 이름을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">이 루틴은 새로운 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 이름 을 등록하는 데 사용됩니다 . 모듈을 사용하여 새 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 작성하기 전에 그리고 모듈에 대해 기존 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용 하기 전에 모듈 이름을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">이 루틴은 명령 행 입력 중에 현재 입력 한 텍스트가 완전한 SQL 문을 형성하는 것으로 보이는지 또는 구문 분석을 위해 텍스트를 SQLite로 보내기 전에 추가 입력이 필요한지 판별하는 데 유용합니다. 입력 문자열이 완전한 SQL 문인 경우이 루틴은 1을 리턴합니다. 명령문은 세미콜론 토큰으로 끝나고 올바르게 구성된 CREATE TRIGGER 문의 접 두부가 아닌 경우 완료된 것으로 판단됩니다. 문자열 리터럴 또는 인용 된 식별자 이름 또는 주석 내에 포함 된 세미콜론은 독립적 인 토큰이 아니며 (포함 된 토큰의 일부 임) 명령문 종결 자로 계산되지 않습니다. 마지막 세미콜론 뒤에 나오는 공백과 주석은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">이러한 루틴은 표준 C 라이브러리의 &quot;printf ()&quot;함수 제품군과 유사합니다. 이 루틴은 표준 라이브러리 printf () 및 일부 비표준 형식 ( &lt;a href=&quot;../printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;../printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;../printf#percentw&quot;&gt;% w&lt;/a&gt; 및 &lt;a href=&quot;../printf#percentz&quot;&gt;% z&lt;/a&gt; ) 의 일반적인 형식 옵션 대부분을 이해 합니다. 자세한 내용은 &lt;a href=&quot;../printf&quot;&gt;내장 printf ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">이러한 루틴은 표준 C 라이브러리의 &quot;printf ()&quot;함수 제품군과 유사합니다. 이 루틴은 표준 라이브러리 printf () 및 일부 비표준 형식 ( &lt;a href=&quot;printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;printf#percentw&quot;&gt;% w&lt;/a&gt; 및 &lt;a href=&quot;printf#percentz&quot;&gt;% z&lt;/a&gt; ) 의 일반적인 형식 옵션 대부분을 이해 합니다. 자세한 내용은 &lt;a href=&quot;printf&quot;&gt;내장 printf ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">이 루틴은 SQL 문을 구문 분석하지 않으므로 구문 상 올바르지 않은 SQL을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서 유형, 크기 및 컨텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 오브젝트는 매개 변수 정보를 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;vtab&quot;&gt;가상 테이블의&lt;/a&gt; 구현으로 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="780ed181ddbb53bd0cd75f887c1efe5a712dae77" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 개체 에서 유형, 크기 및 콘텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 객체는 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 구현하는 함수로 매개 변수 정보를 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서 유형, 크기 및 컨텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 오브젝트는 매개 변수 정보를 &lt;a href=&quot;create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블의&lt;/a&gt; 구현으로 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="080e4929a8edf88eab58f3131b66975c555d313b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 개체 에서 유형, 크기 및 콘텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 객체는 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 구현하는 함수로 매개 변수 정보를 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt; 매개 변수 를 제공 한 SQL 함수와 동일한 스레드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt; 매개 변수 를 제공 한 SQL 함수와 동일한 스레드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">이 루틴은 SQL 함수가 실행중인 동일한 스레드에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">이 루틴은 filename 인수로 지정된대로 SQLite 데이터베이스 파일을 엽니 다. filename 인수는 sqlite3_open () 및 sqlite3_open_v2 ()의 경우 UTF-8로, sqlite3_open16 ()의 기본 바이트 순서에서 UTF-16으로 해석됩니다. &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들은 일반적으로 오류가 발생하는 경우에도 * ppDb에 반환됩니다. 유일한 예외는 SQLite는이 개최 메모리를 할당 할 수없는 경우이다 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체를하는 NULL은 포인터 대신 * ppDb에 기록 될 것입니다 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체입니다. 데이터베이스가 성공적으로 열리거나 작성되면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴됩니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다. &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt;루틴은 sqlite3_open () 루틴이 실패한 후 오류에 대한 영어 설명을 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">이 루틴은 filename 인수로 지정된대로 SQLite 데이터베이스 파일을 엽니 다. filename 인수는 sqlite3_open () 및 sqlite3_open_v2 ()의 경우 UTF-8로, sqlite3_open16 ()의 기본 바이트 순서에서 UTF-16으로 해석됩니다. &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들은 일반적으로 오류가 발생하는 경우에도 * ppDb에 반환됩니다. 유일한 예외는 SQLite는이 개최 메모리를 할당 할 수없는 경우이다 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체를하는 NULL은 포인터 대신 * ppDb에 기록 될 것입니다 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체입니다. 데이터베이스가 성공적으로 열리거나 작성되면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴됩니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다. &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt;루틴은 sqlite3_open () 루틴이 실패한 후 오류에 대한 영어 설명을 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문 에서 특정 결과 컬럼의 원점 인 데이터베이스, 테이블 및 테이블 컬럼을 판별하는 수단을 제공합니다 . 데이터베이스 또는 테이블 또는 열의 이름은 UTF-8 또는 UTF-16 문자열로 리턴 될 수 있습니다. _database_ 루틴은 데이터베이스 이름을 리턴하고 _table_ 루틴은 테이블 이름을 리턴하며 origin_ 루틴은 컬럼 이름을 리턴합니다. 리턴 된 문자열은 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 삭제 될 때까지 또는 특정 실행에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 동일한 정보가 다른 인코딩으로 다시 요청 될 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문 에서 특정 결과 컬럼의 원점 인 데이터베이스, 테이블 및 테이블 컬럼을 판별하는 수단을 제공합니다 . 데이터베이스 또는 테이블 또는 열의 이름은 UTF-8 또는 UTF-16 문자열로 리턴 될 수 있습니다. _database_ 루틴은 데이터베이스 이름을 리턴하고 _table_ 루틴은 테이블 이름을 리턴하며 origin_ 루틴은 컬럼 이름을 리턴합니다. 리턴 된 문자열은 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 삭제 될 때까지 또는 특정 실행에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 동일한 정보가 다른 인코딩으로 다시 요청 될 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">이 루틴은 SQLite가 인식하는 SQL 언어 키워드 세트에 대한 액세스를 제공합니다. 응용 프로그램은 이러한 루틴을 사용하여 구문 분석기를 혼동하지 않도록 특정 식별자를 이스케이프해야하는지 여부를 결정합니다 (예 : 큰 따옴표로 묶음).</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">이 루틴을 통해 Wagner Edit-Distance 기능 버전에 직접 액세스 할 수있어 편집 작업시 애플리케이션 정의 가중치를 사용할 수 있습니다. 이 함수의 처음 두 형태는 패턴 P를 단어 W와 비교하고 편집 거리를 반환합니다. 첫 번째 함수에서 langid는 0으로 가정하고 두 번째 함수에서는 langid가 L 매개 변수로 제공됩니다. 이 함수의 세 번째 형식은 T로 명명 ​​된 테이블에서 편집 거리 계수를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">이 루틴은 SQL 문 실행 추적 및 프로파일 링에 사용할 수있는 콜백 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">명령문이 완료되지 않으면이 루틴은 0을 리턴합니다. 메모리 할당이 실패하면 SQLITE_NOMEM이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 조회의 현재 결과 행의 단일 열에 대한 정보를 리턴합니다. 모든 경우에 첫 번째 인수는 평가중인 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; ( &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 해당 변형 중 하나 에서 리턴 된 sqlite3_stmt &lt;a href=&quot;#sqlite3_stmt&quot;&gt;*&lt;/a&gt; )에 대한 포인터 이고 두 번째 인수는 정보를 리턴 할 열의 색인입니다. . 결과 집합의 가장 왼쪽 열에는 인덱스 0이 있습니다. 결과의 열 수는 &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count ()를&lt;/a&gt; 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 조회의 현재 결과 행의 단일 열에 대한 정보를 리턴합니다. 모든 경우에 첫 번째 인수는 평가중인 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; ( &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 해당 변형 중 하나 에서 리턴 된 sqlite3_stmt &lt;a href=&quot;stmt&quot;&gt;*&lt;/a&gt; )에 대한 포인터 이고 두 번째 인수는 정보를 리턴 할 열의 색인입니다. . 결과 집합의 가장 왼쪽 열에는 인덱스 0이 있습니다. 결과의 열 수는 &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count ()를&lt;/a&gt; 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 세트에서 특정 열에 지정된 이름을 리턴합니다 . sqlite3_column_name () 인터페이스는 0으로 끝나는 UTF-8 문자열에 대한 포인터를 반환하고 sqlite3_column_name16 ()은 0으로 끝나는 UTF-16 문자열에 대한 포인터를 반환합니다. 첫 번째 매개 변수는 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문 을 구현하는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 입니다 . 두 번째 매개 변수는 열 번호입니다. 가장 왼쪽 열은 숫자 0입니다.</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 세트에서 특정 열에 지정된 이름을 리턴합니다 . sqlite3_column_name () 인터페이스는 0으로 끝나는 UTF-8 문자열에 대한 포인터를 반환하고 sqlite3_column_name16 ()은 0으로 끝나는 UTF-16 문자열에 대한 포인터를 반환합니다. 첫 번째 매개 변수는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문 을 구현하는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 입니다 . 두 번째 매개 변수는 열 번호입니다. 가장 왼쪽 열은 숫자 0입니다.</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">이 루틴은 인수의 뮤텍스가 호출 스레드에 의해 각각 보유 또는 보유되지 않은 경우 true를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">이러한 루틴은 첫 번째 JSON 인수의 형식이 올바르지 않거나 PATH 인수의 형식이 올바르지 않거나 인수가 BLOB 인 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">이러한 루틴 은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 포인터 및 정수 열 번호 대신 단일 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 오브젝트 포인터를 사용 한다는 점을 제외하고 해당 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;열 액세스 기능과&lt;/a&gt; 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">이러한 루틴 은 &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 포인터 및 정수 열 번호 대신 단일 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 오브젝트 포인터를 사용 한다는 점을 제외하고 해당 &lt;a href=&quot;column_blob&quot;&gt;열 액세스 기능과&lt;/a&gt; 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서만 작동 합니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 에서 이러한 루틴을 사용하려는 시도 는 스레드 안전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서만 작동 합니다. &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 에서 이러한 루틴을 사용하려는 시도 는 스레드 안전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">이 정적 뮤텍스는 SQLite에서 내부 용으로 예약되어 있으므로 응용 프로그램에서 사용해서는 안됩니다. 정적 뮤텍스는 모두 비재 귀적입니다.</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">이러한 기술은 SQLite를 사용하는 애플리케이션이 아니라 핵심 SQLite 라이브러리 자체를 이해하는 데 도움이되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">이러한 테스트는 상대적으로 작은 (약 14MB) 데이터베이스에서 수행됩니다. 데이터베이스 엔진이 더 큰 문제로 얼마나 잘 확장되는지 측정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">이러한 테스트에서는 다중 조인 및 하위 쿼리와 관련된 복잡한 쿼리의 다중 사용자 성능 또는 최적화를 측정하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">트랜잭션을 커밋하는이 세 가지 방법은 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; 의 DELETE, TRUNCATE 및 PERSIST 설정에 각각 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">이 두 규칙은이 글을 작성할 때 SQLite 용 쿼리 플래너가 어떻게 작동하는지 설명합니다 (2013-08-01). 그리고 위의 규칙은 항상 존중됩니다. 그러나 향후 버전의 SQLite는 W&amp;rArr;X가 참인 다른 경우를 찾을 수있는 더 나은 정리 증명을 통합 할 수 있으므로 부분 인덱스가 유용한 경우를 더 많이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">잘못 될 수있는 것</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">트리거 프로그램이 실행되는 동안 sqlite3_changes () 함수가 실행되면 상황이 더 복잡합니다. 프로그램이 &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes () SQL 함수&lt;/a&gt; 를 사용하거나 다른 콜백 함수가 sqlite3_changes ()를 직접 호출하는 경우에 발생할 수 있습니다. 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">트리거 프로그램이 실행되는 동안 sqlite3_changes () 함수가 실행되면 상황이 더 복잡합니다. 프로그램이 &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes () SQL 함수&lt;/a&gt; 를 사용하거나 다른 콜백 함수가 sqlite3_changes ()를 직접 호출하는 경우에 발생할 수 있습니다. 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">각 SQL 문을 별도의 컴퓨터 프로그램으로 생각하십시오. 원본 SQL 텍스트는 소스 코드입니다. 준비된 명령문 오브젝트는 컴파일 된 오브젝트 코드입니다. 실행하기 전에 모든 SQL을 준비된 명령문으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">각 SQL 문을 작은 컴퓨터 프로그램으로 생각하십시오. &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 의 목적은 해당 프로그램을 객체 코드로 컴파일하는 것입니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문은&lt;/a&gt; 오브젝트 코드입니다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 결과를 얻을 수있는 오브젝트 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">세 번째 개선 : 버전 관리</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">&quot;detail = none&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다. FTS5 테이블이 &quot;detail = none&quot; &quot;content =&quot;옵션으로 작성되면 (즉, 내용이없는 테이블 인 경우)이 API는 항상 빈 세트를 반복합니다 (xPhraseFirstColumn ()에 대한 모든 호출은 iCol을 -1로 설정) .</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">&quot;detail = none&quot;또는 &quot;detail = column&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">&quot;detail = none&quot;또는 &quot;detail = column&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다. FTS5 테이블이 &quot;detail = none&quot;또는 &quot;detail = column&quot;및 &quot;content =&quot;옵션 (즉, 내용이없는 테이블 인 경우)으로 작성되는 경우이 API는 항상 빈 세트 (xPhraseFirst ( ) iCol을 -1)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">&quot;detail = none&quot;또는 &quot;detail = column&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다. FTS5 테이블이 &quot;detail = none&quot;또는 &quot;detail = column&quot;및 &quot;content =&quot;옵션 (즉, 내용이없는 테이블 인 경우)으로 작성되면이 API는 항상 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">이 API 함수는 현재 쿼리의 문구 iPhrase에 대한 FTS 테이블을 쿼리하는 데 사용됩니다. 특히 다음과 같은 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">이 API는 라이브러리가 사전 프로세서 기호 &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS가&lt;/a&gt; 정의 된 상태로 빌드 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">이 API는 라이브러리가 사전 프로세서 기호 &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS가&lt;/a&gt; 정의 된 상태로 빌드 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 API는 특정 이름과 매개 변수 수를 가진 함수의 글로벌 버전이 존재하는지 확인합니다. 이 API가 호출되기 전에 그러한 함수가 존재하지 않으면 새로운 함수가 작성됩니다. 새 함수를 구현하면 항상 예외가 발생합니다. 따라서 새로운 기능은 그 자체로는 좋지 않습니다. 그것의 유일한 목적은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블에&lt;/a&gt; 의해 오버로드 될 수있는 자리 표시 자 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 API는 특정 이름과 매개 변수 수를 가진 함수의 글로벌 버전이 존재하는지 확인합니다. 이 API가 호출되기 전에 그러한 함수가 존재하지 않으면 새로운 함수가 작성됩니다. 새 함수를 구현하면 항상 예외가 발생합니다. 따라서 새로운 기능은 그 자체로는 좋지 않습니다. 그것의 유일한 목적은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블에&lt;/a&gt; 의해 오버로드 될 수있는 자리 표시 자 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">이 C 전처리 매크로는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; 구성 설정 의 기본 설정을 결정 합니다. 기본값은 1 (켜기)입니다. 즉, 가능한 경우 전체 인덱스 스캔에 커버링 인덱스가 사용되어 I / O를 줄이고 성능을 향상시킵니다. 그러나 전체 검색에 적용 인덱스를 사용하면 레거시와 다른 순서로 결과가 표시되어 일부 (올바르게 코딩 된) 레거시 응용 프로그램이 중단 될 수 있습니다. 따라서 레거시 응용 프로그램에서 오류가 노출 될 위험을 최소화 할 수있는 시스템에서 컴파일 타임에 커버링 인덱스 스캔 옵션을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="352e275c0ba546327eab38cacb1b8cfd047e40c3" translate="yes" xml:space="preserve">
          <source>This CVE identifies a bug in a development check-in of SQLite. The bug never appeared in any official SQLite release. &lt;a href=&quot;https://www.sqlite.org/src/info/6601da58032d18ae&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">이 DELETE 문은 &quot;examp&quot;테이블에서 &quot;two&quot;열이 50보다 작은 모든 레코드를 제거합니다.이를 수행하기 위해 생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">이를 통해 최적화가 가능합니다. (a) P4 == 0 인 경우 P3에 대해 RowSet 객체를 테스트 할 필요가 없습니다. 포함하지 않을 것이므로 (b) P4 ==-1 인 경우 값을 삽입 할 필요가 없습니다. (c) 집합 X의 일부인 값이 삽입 될 때 이전에 설정된 X의 일부로 동일한 값이 삽입되었는지 여부를 검색 할 필요가 없습니다. 이전에 다른 세트의 일부로 삽입 됨).</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">이를 통해 별도의 데이터베이스 연결이 동일한 인 메모리 데이터베이스를 공유 할 수 있습니다. 물론 인 메모리 데이터베이스를 공유하는 모든 데이터베이스 연결은 동일한 프로세스에 있어야합니다. 데이터베이스에 대한 마지막 연결이 닫히면 데이터베이스가 자동으로 삭제되고 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">또한이 기사에서는 &quot;바이트 코드 프로그램&quot;과 &quot;준비된 명령문&quot;이라는 용어를 같은 의미로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">이 기사에서는 SQLite의 한계와 특정 애플리케이션에 맞게 SQLite를 사용자 정의하는 방법을 정의합니다. 제한의 기본 설정은 일반적으로 거의 모든 응용 프로그램에 매우 크고 적절합니다. 일부 응용 프로그램은 여기 또는 여기에서 제한을 늘리기를 원할 수 있지만 그러한 요구는 드물 것으로 예상됩니다. 보다 일반적으로 응용 프로그램은 상위 SQL 문 생성기에서 버그가 발생할 경우 과도한 리소스 사용률을 피하거나 악의적 인 SQL 문을 주입하는 공격자를 막기 위해 훨씬 더 낮은 제한으로 SQLite를 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">이 기사에서는 SQLite 개발자가 CPU 사용량을 측정하는 방법, 이러한 측정의 실제 의미 및 SQLite 개발자가 SQLite 라이브러리의 CPU 사용량을 더 줄이기 위해 계속 노력하는 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">이 기사에서는 운영 체제 전반에서 이식성을 제공하는 SQLite 구현 스택의 맨 아래에있는 모듈 인 SQLite OS 이식성 계층 또는 &quot;VFS&quot;에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">이 기사에서는 SQLite가 원자 커밋의 환상을 만들기 위해 사용하는 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">이 기사는 SQLite가 만들고 사용하는 다양한 임시 파일을 설명합니다. 파일 작성시기, 삭제시기, 용도, 중요한 이유 및 임시 파일 작성 비용이 많이 드는 시스템에서 파일을 피하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">이 기사에는 SQLite를 컴파일하기위한 단계별 레시피가 포함되어 있지 않습니다. 각 개발 상황이 다르기 때문에 어려울 것입니다. 오히려이 기사는 SQLite 컴파일의 기본 원리를 설명하고 설명합니다. 일반적인 컴파일 명령은 응용 프로그램 개발자가 자신의 사용자 지정 컴파일 절차를 개발하기위한 지침으로 이러한 예제를 사용할 수있을 것으로 예상되는 예입니다. 즉,이 기사는 턴키 솔루션이 아니라 아이디어와 통찰력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">이 기사는 명확성을 개선하고 우려 사항과 오해를 해결하고 &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt; , &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; 및 &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt; 에서 식별 된 오류를 수정하기 위해 여러 번 개정되었습니다 . 전체 편집 내역은 &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt; 에서 확인할 수 있습니다 . (사용 힌트 : diff에 대한 그래프의 두 노드를 클릭하십시오.)</target>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">이 기사에서는 SQLite의 VDBE가 SQL 문을 구현하는 데 사용하는 모든 주요 기술을 검토했습니다. 도시되지 않은 것은 이들 기술의 대부분이 조합되어 적절히 복잡한 질의 문에 대한 코드를 생성 할 수 있다는 것이다. 예를 들어 간단한 쿼리에서 정렬이 수행되는 방식을 보여 주었고 복합 쿼리를 구현하는 방법을 보여주었습니다. 그러나 복합 쿼리에서 정렬하는 예는 제공하지 않았습니다. 복합 쿼리를 정렬 할 때 새로운 개념이 도입되지 않기 때문입니다. 동일한 VDBE 프로그램에서 이전의 두 가지 아이디어 (정렬 및 복합) 만 결합한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">이 기사는 화석과 Git의 비교 가 &lt;u&gt;아닙니다&lt;/u&gt; . 두 시스템의 비교는 &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; 를 참조 하십시오 . 다른 것도 있습니다.</target>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">이 기사에서는 Git에서 프로젝트를 전환한다고 주장 &lt;u&gt;하지 않습니다&lt;/u&gt; . 원하는 버전 제어 시스템을 사용할 수 있습니다. Git에 완벽하게 만족한다면 반드시 Git을 계속 사용하십시오. 그러나 더 좋은 것이 없는지 궁금하다면 아래 제시된 관점을 이해하려고 노력하십시오. 이렇게 얻은 통찰력을 사용하여 더 좋고 다른 버전 제어 시스템을 찾거나 작성하거나 Git 자체를 개선하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">이 기사는 VDBE의 작동 방식, 특히 다양한 VDBE 명령어 ( &lt;a href=&quot;opcode&quot;&gt;여기에 설명되어 있음&lt;/a&gt; )가 데이터베이스에서 유용한 작업을 수행 하는 방법에 대한 간략한 소개 입니다. 이 스타일은 간단한 작업부터 시작하여 더 복잡한 문제를 해결하기위한 자습서입니다. 그 과정에서 우리는 SQLite 라이브러리에서 대부분의 하위 모듈을 방문 할 것입니다. 이 학습서를 완료하면 SQLite의 작동 방식을 잘 이해하고 실제 소스 코드를 연구 할 준비가됩니다.</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">이 기사는 최하위 계층에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">이 기사는 가장 중요하고 가장 일반적으로 사용되는 SQLite 인터페이스에 대해서만 언급합니다. SQLite 라이브러리에는 여기에 설명되지 않은 유용한 기능을 구현하는 다른 많은 API가 포함되어 있습니다. SQLite 애플리케이션 프로그래밍 인터페이스를 구성 하는 &lt;a href=&quot;c3ref/funclist&quot;&gt;전체 기능 목록은 &lt;/a&gt;&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++ 인터페이스 사양에&lt;/a&gt; 있습니다. 모든 SQLite 인터페이스에 대한 완전하고 권위있는 정보는 해당 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">이 기사에서는 SQLite의 개인 브랜치를 공개 SQLite 소스 코드와 동기화하는 방법 중 하나를 설명합니다. 물론 개인 지점을 유지 관리하는 방법에는 여러 가지가 있습니다. 아무도 여기에 설명 된 방법을 사용하도록 강요 당하지 않습니다. 이 기사는 개인 브랜치의 관리자에게 특정 절차를 강요하지 않습니다. 이 기사의 요점은 각 개별 프로젝트의 상황에 가장 적합한 프로세스를 설계하기위한 템플리트로 사용될 수있는 개인 브랜치를 유지하기위한 하나의 프로세스의 예를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">이 문서에서는 쿼리 계획의 중요성을 설명하고 쿼리 계획에 내재 된 일부 문제에 대해 설명하고 NGQP가 이러한 문제를 해결하는 방법을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="edd2ab1205dd1a38d5ce29f020d2d454461aadbe" translate="yes" xml:space="preserve">
          <source>This article presents a technique using the SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface such that calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; block until the required locks are available instead of returning SQLITE_LOCKED immediately. If the sqlite3_blocking_step() or sqlite3_blocking_prepare_v2() functions presented to the left return SQLITE_LOCKED, this indicates that to block would deadlock the system.</source>
          <target state="translated">이 기사에서는 SQLite_LOCKED를 즉시 리턴하는 대신 필요한 잠금을 사용할 수있을 때까지 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 블록 을 호출하도록 SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스를 사용하는 기술을 설명합니다. 왼쪽에 제시된 sqlite3_blocking_step () 또는 sqlite3_blocking_prepare_v2 () 함수가 SQLITE_LOCKED를 리턴하면 시스템을 교착 상태로 막을 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9498c6cd8712f6376d65af391550cc9e3ffdabcd" translate="yes" xml:space="preserve">
          <source>This block of instruction cleans up the VDBE program. Three of these instructions aren't really required, but are generated by the SQLite parser from its code templates, which are designed to handle more complicated cases.</source>
          <target state="translated">이 명령어 블록은 VDBE 프로그램을 정리합니다. 이러한 명령어 중 3 개는 실제로 필요하지는 않지만 더 복잡한 경우를 처리하도록 설계된 코드 템플릿에서 SQLite 파서에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4a01a06f54367b20ad3750e286b70148e2c847d5" translate="yes" xml:space="preserve">
          <source>This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of</source>
          <target state="translated">이 내장 창 함수는 집계 창 함수와 같은 방식으로 각 행의 창 프레임을 계산합니다. 의 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="20ec5d83d88c2da3b16c3295bcff75c38125962e" translate="yes" xml:space="preserve">
          <source>This change is an exception to the version number rule described above in that it is neither forwards or backwards compatible. A complete reload of the database is required. This is the only exception.</source>
          <target state="translated">이 변경은 앞뒤로 호환되지 않는다는 점에서 위에서 설명한 버전 번호 규칙의 예외입니다. 데이터베이스를 완전히 다시로드해야합니다. 이것은 유일한 예외입니다.</target>
        </trans-unit>
        <trans-unit id="c6a5f96c5622bed501ea8661519073e0de4f52cd" translate="yes" xml:space="preserve">
          <source>This column also always contains an integer value greater than zero.</source>
          <target state="translated">이 열에는 항상 0보다 큰 정수 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fb0358a44a2292d9d05f4777b69d5f05939eb420" translate="yes" xml:space="preserve">
          <source>This column always contains an integer value greater than zero.</source>
          <target state="translated">이 열에는 항상 0보다 큰 정수 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1713bd9e06b77e4bbf5df2753a784a802e3933b6" translate="yes" xml:space="preserve">
          <source>This column determines which &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt; is used to extract vocabulary from the FTS3/4 table.</source>
          <target state="translated">이 열 은 FTS3 / 4 테이블에서 어휘를 추출하는 데 사용 되는 &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;언어&lt;/a&gt; ID를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="285c275d9591ca00ecba379d1be0f439e124856e" translate="yes" xml:space="preserve">
          <source>This column may contain either the text value '*' (i.e. a single character, U+002a) or an integer between 0 and N-1, where N is again the number of user-defined columns in the corresponding FTS table.</source>
          <target state="translated">이 열은 텍스트 값 '*'(즉, 단일 문자, U + 002a) 또는 0과 N-1 사이의 정수를 포함 할 수 있습니다. 여기서 N은 다시 해당 FTS 테이블의 사용자 정의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="65f82075152c89e2aff2366597dc220e2a3e5878" translate="yes" xml:space="preserve">
          <source>This column must be set to NULL. If a non-NULL value is inserted into this column, or if a new non-NULL value is provided using an UPDATE statement, it is an error.</source>
          <target state="translated">이 열은 NULL로 설정해야합니다. NULL이 아닌 값이이 열에 삽입되거나 UPDATE 문을 사용하여 새로운 NULL이 아닌 값이 제공되는 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="e9e3819e4d76ebe92176deabc7d0279eab9fbfc8" translate="yes" xml:space="preserve">
          <source>This column shows the phonetic hash prefix that was used to restrict the search. For any given query, this column should be the same for every row. This information is available for diagnostic purposes and is not normally considered useful in real applications.</source>
          <target state="translated">이 열에는 검색을 제한하는 데 사용 된 발음 해시 접두사가 표시됩니다. 주어진 쿼리에 대해이 열은 모든 행에서 동일해야합니다. 이 정보는 진단용으로 제공되며 일반적으로 실제 응용 프로그램에는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01288c4cfddc172d238625a965b9f1003be61617" translate="yes" xml:space="preserve">
          <source>This command both creates the new repository and populates it with all the latest SQLite code. You can then create a private branch as described in section 3.4.</source>
          <target state="translated">이 명령은 새 저장소를 작성하고 모든 최신 SQLite 코드로 채 웁니다. 그런 다음 섹션 3.4에 설명 된대로 개인 브랜치를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ca6b6ac38f5b817649e53a976402c687ab2fa8" translate="yes" xml:space="preserve">
          <source>This command causes SQLite to disconnect from the previous database and reattach to an in-memory database with the content in</source>
          <target state="translated">이 명령은 SQLite가 이전 데이터베이스에서 연결을 끊고 내용이 다음과 같이 메모리 내 데이터베이스에 다시 연결되도록합니다.</target>
        </trans-unit>
        <trans-unit id="52245829743ea4e1b3e2fa49a0972f85d14c8fbb" translate="yes" xml:space="preserve">
          <source>This command causes the &quot;callback&quot; script to be invoked whenever certain conditions occurs. The conditions are determined by the</source>
          <target state="translated">이 명령을 사용하면 특정 조건이 발생할 때마다 &quot;콜백&quot;스크립트가 호출됩니다. 조건은</target>
        </trans-unit>
        <trans-unit id="13f59d1cb3e06c83ff056103acea107f7910080d" translate="yes" xml:space="preserve">
          <source>This command first deletes the entire full-text index, then rebuilds it based on the contents of the table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">이 명령은 먼저 전체 전체 텍스트 인덱스를 삭제 한 다음 테이블 또는 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;컨텐츠 테이블&lt;/a&gt; 의 컨텐츠를 기반으로 인덱스를 다시 작성합니다 . 내용이없는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;테이블&lt;/a&gt; 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fe5638fc83b6cdbce8fdc02e570b8e2b10a1482f" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It deletes all entries from the full-text index.</source>
          <target state="translated">이 명령은에서만 사용할 수 있습니다 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 콘텐츠&lt;/a&gt; 와 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는&lt;/a&gt; 테이블. 전체 텍스트 인덱스에서 모든 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="7489ecbcacef562551b65244089f9307c364a891" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It is used to delete the index entries associated with a single row from the full-text index. This command and the &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; command are the only ways to remove entries from the full-text index of a contentless table.</source>
          <target state="translated">이 명령은에서만 사용할 수 있습니다 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 콘텐츠&lt;/a&gt; 와 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는&lt;/a&gt; 테이블. 전체 텍스트 인덱스에서 단일 행과 관련된 인덱스 항목을 삭제하는 데 사용됩니다. 이 명령과 &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; 명령은 내용이없는 테이블의 전체 텍스트 인덱스에서 항목을 제거하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a1d13a5c03e8731ed6d7cfb96b7277fb1a9eb4b2" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;pgsz&quot; option.</source>
          <target state="translated">이 명령은 지속적 &quot;pgsz&quot;옵션을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b39428042e588fc7d00e73c6e90326dc9e9ea85b" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;rank&quot; option.</source>
          <target state="translated">이 명령은 지속적 &quot;rank&quot;옵션을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85b16bab1c29894a0c668469c8830c0b869b0913" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;usermerge&quot; option.</source>
          <target state="translated">이 명령은 지속적 &quot;usermerge&quot;옵션을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3730a7c5668daaf6af3f627c894d5a241eb8942e" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is consistent with the contents of the FTS5 table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">이 명령은 전체 텍스트 인덱스가 FTS5 테이블 또는 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;내용 테이블&lt;/a&gt; 의 내용과 일치하는지 확인하는 데 사용됩니다 . 내용이없는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;테이블&lt;/a&gt; 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a574335749833522810d0e9deb16c3b1a8c4736" translate="yes" xml:space="preserve">
          <source>This command may also be used with ordinary FTS4 tables, for example if the implementation of the tokenizer changes. It is an error to attempt to rebuild the full-text index maintained by a contentless FTS4 table, since no content will be available to do the rebuilding.</source>
          <target state="translated">이 명령은 예를 들어 토크 나이저의 구현이 변경되는 경우 일반 FTS4 테이블과 함께 사용될 수도 있습니다. 컨텐츠를 다시 작성할 수있는 컨텐츠가 없으므로 컨텐츠가없는 FTS4 테이블에서 유지 보수하는 전체 텍스트 인덱스를 재 구축하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="61072f8fd085f0b1c6b3c6456d8203db4cf536aa" translate="yes" xml:space="preserve">
          <source>This command merges all individual b-trees that currently make up the full-text index into a single large b-tree structure. This ensures that the full-text index consumes the minimum space within the database and is in the fastest form to query.</source>
          <target state="translated">이 명령은 현재 전체 텍스트 인덱스를 구성하는 모든 개별 b- 트리를 하나의 큰 b- 트리 구조로 병합합니다. 이렇게하면 전체 텍스트 인덱스가 데이터베이스 내에서 최소 공간을 사용하고 쿼리하기 가장 빠른 형식으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="51ac15b2185be7d66cfb5466a048917c1313d8ae" translate="yes" xml:space="preserve">
          <source>This command merges b-tree structures together until roughly N pages of merged data have been written to the database, where N is the absolute value of the parameter specified as part of the 'merge' command. The size of each page is as configured by the &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz option&lt;/a&gt;.</source>
          <target state="translated">이 명령은 대략 N 페이지의 병합 된 데이터가 데이터베이스에 기록 될 때까지 b- 트리 구조를 병합합니다. 여기서 N은 'merge'명령의 일부로 지정된 매개 변수의 절대 값입니다. 각 페이지의 크기는 &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz 옵션&lt;/a&gt; 으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6ccb891d0018f34c8b539ed4ad53a6be49ac1c9" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;, which is a tremendous help in analyzing the aftermath of historical changes.</source>
          <target state="translated">이 명령 순서는 암기하고 입력하는 것이 많습니다. (빈번하게 사용된다면 bash 별명이나 짧은 쉘 스크립트를 만들고 싶을 것이다.) 게다가, 그것은 똑같지 않다. 위의 명령은 분기 구조를 보여주지 않고 자손 목록을 제공하며, 이는 발생한 일을 이해하는 데 중요합니다. 대조적으로, Fossil은 &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt; 와 같은 디스플레이를 제공하며 , 이는 역사적 변화의 여파를 분석하는 데 큰 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="309dfaa9b377c5a8af4ac33fa681865f1bffbfb3" translate="yes" xml:space="preserve">
          <source>This command will create a new branch named &quot;private&quot; (you can use a different name if you like) and assign it a background color of light blue (&quot;#add8e8&quot;). You can omit the background color if you want, though having a distinct background does make it easier to tell the branch from the &quot;trunk&quot; (the public branch) on timeline displays. You can change the background color of the private branch or of the public branch (the &quot;trunk&quot;) using the web interface if you like.</source>
          <target state="translated">이 명령은 &quot;private&quot;이라는 새 분기를 만들고 (원하는 경우 다른 이름을 사용할 수 있음) 연한 파랑의 배경색 ( &quot;# add8e8&quot;)을 지정합니다. 원하는 경우 배경색을 생략 할 수 있지만, 고유 한 배경을 사용하면 타임 라인 디스플레이의 &quot;트렁크&quot;(공개 지점)에서 분기를 쉽게 알 수 있습니다. 원하는 경우 웹 인터페이스를 사용하여 개인 지점 또는 공용 지점 ( &quot;트렁크&quot;)의 배경색을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db5e98e2fd20bba8ab658518e972deb34aab3ef" translate="yes" xml:space="preserve">
          <source>This command-line shell leaves unnamed parameters unbound, meaning that they will have a value of an SQL NULL, but named parameters might be assigned values. If there exists a TEMP table named &quot;sqlite_parameters&quot; with a schema like this:</source>
          <target state="translated">이 명령 줄 셸은 명명되지 않은 매개 변수를 바인딩되지 않은 상태로 둡니다. 즉, SQL NULL 값을 가지지 만 명명 된 매개 변수에는 값이 할당 될 수 있습니다. &quot;sqlite_parameters&quot;라는 TEMP 테이블이 다음과 같은 스키마가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="4c4b4e9517b3e559a4264bd38d883b4075b15dd6" translate="yes" xml:space="preserve">
          <source>This compile-time option affects the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator only and has no impact on the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface.</source>
          <target state="translated">이 컴파일 타임 옵션은 SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자에만 영향을 주며 &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; C 언어 인터페이스 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c67f3211a79226589052fa652c6121f10cd5b9d" translate="yes" xml:space="preserve">
          <source>This compile-time option causes the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator to always return False if either operand is a BLOB. The default behavior of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; is that BLOB operands are cast to TEXT before the comparison is done.</source>
          <target state="translated">이 컴파일 타임 옵션을 사용하면 피연산자 중 하나가 BLOB 인 경우 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자가 항상 False를 반환합니다. &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 의 기본 동작은 비교를 수행하기 전에 BLOB 피연산자가 TEXT로 캐스트되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b087b90d5f82c6cd11bb4d6150e1edc15e3c7080" translate="yes" xml:space="preserve">
          <source>This compile-time option changes the default setting of the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;. When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.</source>
          <target state="translated">이 컴파일 타임 옵션은 &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; 의 기본 설정을 변경합니다 . 이 옵션을 사용하지 않으면 secure_delete는 기본적으로 해제되어 있습니다. 이 옵션이 있으면 secure_delete의 기본값은 on입니다.</target>
        </trans-unit>
        <trans-unit id="ec3013abfee74643b8705338ad5e107049f5af6c" translate="yes" xml:space="preserve">
          <source>This compile-time option disables the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; command.</source>
          <target state="translated">이 컴파일 타임 옵션은 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; 명령을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="3400d01afcac3cfb7345138b17405acb7d27f932" translate="yes" xml:space="preserve">
          <source>This compile-time option enables SQLite to take advantage batch atomic write capabilities in the underlying filesystem. As of SQLite version 3.21.0 (2017-10-24) this is only supported on &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt;. However, the interface is implemented generically, using &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; so the capability can be added to other filesystem times in the future. When this option is enabled, SQLite automatically detects that the underlying filesystem supports batch atomic writes, and when it does so it avoids writing the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; for transaction control. This can make transactions over twice as fast, while simultaneously reducing wear on SSD storage devices.</source>
          <target state="translated">이 컴파일 타임 옵션을 통해 SQLite는 기본 파일 시스템에서 배치 원자 쓰기 기능을 활용할 수 있습니다. SQLite는 버전 3.21.0 (2017년 10월 24일) 현재이 만 지원됩니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt; . 그러나 인터페이스는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; 와 함께 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 을 사용하여 일반적으로 구현 되므로 나중에 다른 파일 시스템 시간에 기능을 추가 할 수 있습니다. 이 옵션이 활성화되면 SQLite는 기본 파일 시스템이 배치 원자 쓰기를 지원 하는지를 자동으로 감지하고, 그렇게하면 트랜잭션 제어를위한 쓰기를 피합니다 . 이는 SSD 저장 장치의 마모를 줄이면서 동시에 두 배 이상 빠른 트랜잭션을 수행 할 수 있습니다.&lt;a href=&quot;lockingv3#rollback&quot;&gt; 롤백 저널&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a47cb88e70b43c326cbb7cc659779aee23f98fe" translate="yes" xml:space="preserve">
          <source>This compile-time option enables the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; logic.</source>
          <target state="translated">이 컴파일 타임 옵션은 &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT 가상 테이블&lt;/a&gt; 로직을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="ff47a638485535b8abdf68c6579ec40497b2ae91" translate="yes" xml:space="preserve">
          <source>This compile-time option has been renamed to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;.</source>
          <target state="translated">이 컴파일 타임 옵션의 이름이 &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; 로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b75f253921594adb213c37bae38c55286027e5" translate="yes" xml:space="preserve">
          <source>This compile-time option is deprecated and untested.</source>
          <target state="translated">이 컴파일 타임 옵션은 더 이상 사용되지 않으며 테스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3be0a309752742e7707ae2403c4dadee6c132ddc" translate="yes" xml:space="preserve">
          <source>This compile-time option is no longer used.</source>
          <target state="translated">이 컴파일 타임 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4333e0a432302d984fdf33eabb1d1ed8fc11d61a" translate="yes" xml:space="preserve">
          <source>This compile-time option makes SQLite run more efficiently when processing queries that use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator, at the expense of breaking backwards compatibility. However, the backwards compatibility break may be only a technicality. There was a long-standing bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; processing logic (see &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;) that caused it to misbehavior for BLOB operands and nobody observed that bug in nearly 10 years of active use. So for more users, it is probably safe to enable this compile-time option and thereby save a little CPU time on LIKE queries.</source>
          <target state="translated">이 컴파일 타임 옵션을 사용하면 이전 버전과의 호환성을 유지하면서 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 를 사용하는 쿼리를 처리 할 때 SQLite를보다 효율적으로 실행할 수 있습니다 . 그러나 이전 버전과의 호환성 중단은 기술적 인 것일 수 있습니다. &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 처리 로직 ( &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f 참조&lt;/a&gt; ) 에 오랫동안 버그 가 발생하여 BLOB 피연산자에 대해 오작동을 일으켰으며 거의 ​​10 년 동안 활발하게 사용 된 버그는 아무도 관찰하지 못했습니다. . 따라서 더 많은 사용자의 경우이 컴파일 타임 옵션을 활성화하면 LIKE 쿼리에서 약간의 CPU 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65b9357f2e420dd3508c81b4ae3257d2786b19ca" translate="yes" xml:space="preserve">
          <source>This constraint arises from the fact that numbers do not sort in lexicographical order. For example: 9&amp;lt;10 but '9'&amp;gt;'10'.</source>
          <target state="translated">이 제약은 숫자가 사전 식 순서로 정렬되지 않기 때문에 발생합니다. 예를 들어 9 &amp;lt;10이지만 '9'&amp;gt; '10'입니다.</target>
        </trans-unit>
        <trans-unit id="187432feb7a09e6addc8b4c1a243d9ef78920104" translate="yes" xml:space="preserve">
          <source>This design note considers the database to be a collection of objects. Each SQL table is a class. Each row is an instance of that class. There are, of course, other ways to interpret an SQL database schema, and the techniques described here work equally well under alternative interpretations, but an object-oriented view seems be more natural to most contemporary programmers.</source>
          <target state="translated">이 디자인 노트에서는 데이터베이스를 객체 모음으로 간주합니다. 각 SQL 테이블은 클래스입니다. 각 행은 해당 클래스의 인스턴스입니다. 물론 SQL 데이터베이스 스키마를 해석하는 다른 방법이 있으며 여기에 설명 된 기술은 대체 해석에서도 동일하게 작동하지만 객체 지향적 관점은 대부분의 현대 프로그래머에게 더 자연스러운 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f5cd63f8a1306fc33b54e6f33d75fb0c8f5824b" translate="yes" xml:space="preserve">
          <source>This document describes SQLite internals. The information provided here is not needed for routine application development using SQLite. This document is intended for people who want to delve more deeply into the internal operation of SQLite.</source>
          <target state="translated">이 문서는 SQLite 내부를 설명합니다. 여기에 제공된 정보는 SQLite를 사용한 일상적인 응용 프로그램 개발에는 필요하지 않습니다. 이 문서는 SQLite의 내부 운영에 대해 더 깊이 탐구하고자하는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="29000c12ac32a9037c669c50606cdb73ab6f60c1" translate="yes" xml:space="preserve">
          <source>This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).</source>
          <target state="translated">이 문서는 버전 3.0.0 (2004-06-18) 이후의 모든 SQLite 릴리스에서 사용되는 디스크 내장 데이터베이스 파일 형식을 설명하고 정의합니다.</target>
        </trans-unit>
        <trans-unit id="dc53982e7fc871bc167dd841afd5d1fa7b1536a4" translate="yes" xml:space="preserve">
          <source>This document describes how to obtain the canonical source code for SQLite - the raw source files from which the amalgamation is built. See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page for additional information on what to do with the canonical source code once it is obtained.</source>
          <target state="translated">이 문서는 SQLite에 대한 표준 소스 코드 (아말감이 빌드 된 원시 소스 파일)를 얻는 방법을 설명합니다. 표준 소스 코드를 확보 한 후 수행 할 작업에 대한 추가 정보는 &lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일&lt;/a&gt; 하는 방법 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cb17c7b427d4b622c77f47d250d842b7e4339f9" translate="yes" xml:space="preserve">
          <source>This document describes in detail the way that SQLite uses the API provided by the VFS adaptor component to solve the problems and implement the strategies enumerated above. It also specifies the assumptions made about the properties of the system that the VFS adaptor provides access to. For example, specific assumptions about the extent of data corruption that may occur if a power failure occurs while a database file is being updated are presented in section</source>
          <target state="translated">이 문서는 SQLite가 VFS 어댑터 구성 요소가 제공하는 API를 사용하여 문제점을 해결하고 위에 열거 된 전략을 구현하는 방법을 자세히 설명합니다. 또한 VFS 어댑터가 액세스 할 수있는 시스템 특성에 대한 가정을 지정합니다. 예를 들어, 데이터베이스 파일을 업데이트하는 동안 정전이 발생하면 발생할 수있는 데이터 손상 정도에 대한 특정 가정이 섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da4581d4d5128e1ce5220b57b58fd4271a11dba" translate="yes" xml:space="preserve">
          <source>This document describes incompatibilities that have occurred in SQLite prior to 2004. Since 2004, there have been enhancements to SQLite such that newer database files are unreadable by older versions of the SQLite library. But the most recent versions of the SQLite library should be able to read and write any older SQLite database file without any problems.</source>
          <target state="translated">이 문서는 2004 년 이전의 SQLite에서 발생한 비 호환성에 대해 설명합니다. 2004 년 이후, 이전 버전의 SQLite 라이브러리에서 최신 데이터베이스 파일을 읽을 수 없도록 SQLite가 향상되었습니다. 그러나 최신 버전의 SQLite 라이브러리는 문제없이 이전 SQLite 데이터베이스 파일을 읽고 쓸 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="522199e4ebe6e710a972b890a7a5a64190cc5d3b" translate="yes" xml:space="preserve">
          <source>This document describes low-level details on how &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is implemented on unix and windows.</source>
          <target state="translated">이 문서는 유닉스와 윈도우에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 가 어떻게 구현 되는지에 대한 저수준 세부 사항을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="86876920b62069808dcd8a4f6cfa725666d13fe3" translate="yes" xml:space="preserve">
          <source>This document describes the architecture of the SQLite library. The information here is useful to those who want to understand or modify the inner workings of SQLite.</source>
          <target state="translated">이 문서는 SQLite 라이브러리의 아키텍처를 설명합니다. 여기에있는 정보는 SQLite의 내부 작업을 이해하거나 수정하려는 사람들에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d320774e9898d3525e4d8d7e2967bd5937be4b0" translate="yes" xml:space="preserve">
          <source>This document describes the support for SQL foreign key constraints introduced in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14).</source>
          <target state="translated">이 문서는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; (2009-10-14)에 도입 된 SQL 외래 키 제약 조건에 대한 지원을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc5a2a4190725779b47fa8957802675b43bcdcd" translate="yes" xml:space="preserve">
          <source>This document does not contain a full description of the syntax used to create foreign key constraints in SQLite. This may be found as part of the documentation for the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">이 문서에는 SQLite에서 외래 키 제약 조건을 만드는 데 사용되는 구문에 대한 자세한 설명이 없습니다. 이것은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에 대한 문서의 일부로 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a95f5bdc9ff03cc2aba9a9f1c4e965180076c32" translate="yes" xml:space="preserve">
          <source>This document does not specify the details of the interface that must be implemented by the VFS adaptor component, that is left to</source>
          <target state="translated">이 문서는 VFS 어댑터 구성 요소에 의해 구현되어야하는 인터페이스의 세부 사항을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4458da44ee2dc70541cbb9f7f722e55f2e9b165b" translate="yes" xml:space="preserve">
          <source>This document focuses on the NGQP. For a more general overview of the SQLite query planner that encompasses the entire history of SQLite, see the &quot;&lt;a href=&quot;optoverview&quot;&gt;The SQLite Query Optimizer Overview&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;queryplanner&quot;&gt;How Indexes Work&lt;/a&gt;&quot; documents.</source>
          <target state="translated">이 문서는 NGQP에 중점을 둡니다. 전체 SQLite 히스토리를 포함하는 SQLite 쿼리 플래너에 대한보다 일반적인 개요는 &quot; &lt;a href=&quot;optoverview&quot;&gt;SQLite Query Optimizer 개요&lt;/a&gt; &quot;및 &quot; &lt;a href=&quot;queryplanner&quot;&gt;인덱스 작동 방식&lt;/a&gt; &quot;문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da2a96113e96df4cba87ef0ebb6ecd70e207ec5c" translate="yes" xml:space="preserve">
          <source>This document gives an overview of the Tcl programming interface for SQLite.</source>
          <target state="translated">이 문서는 SQLite 용 Tcl 프로그래밍 인터페이스에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5a4e1d46e6e2a3f39086d506303b41bc25dcc9a" translate="yes" xml:space="preserve">
          <source>This document is a quick introduction to the changes for SQLite 3.0 for users who are already familiar with SQLite version 2.8.</source>
          <target state="translated">이 문서는 SQLite 버전 2.8에 이미 익숙한 사용자를위한 SQLite 3.0의 변경 사항에 대한 빠른 소개입니다.</target>
        </trans-unit>
        <trans-unit id="c1c02e760418d224f0c07cba5a70ec82e928ba41" translate="yes" xml:space="preserve">
          <source>This document is an introduction to the session extension. The details of the interface are in the separate &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C-language Interface&lt;/a&gt; document.</source>
          <target state="translated">이 문서는 세션 확장에 대한 소개입니다. 인터페이스의 세부 사항은 별도의 &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C 언어 인터페이스&lt;/a&gt; 문서에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff7ff01849be2d401b1d6230764460ab55eb57e" translate="yes" xml:space="preserve">
          <source>This document is concerned with the persistent state of the database file, and since the wal-index is a transient structure, no further information about the format of the wal-index will be provided here. Additional details on the format of the wal-index are contained in the separate &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; document.</source>
          <target state="translated">이 문서는 데이터베이스 파일의 지속 상태와 관련이 있으며 wal-index는 일시적인 구조이므로 wal-index 형식에 대한 추가 정보는 여기에 제공되지 않습니다. wal-index 형식에 대한 자세한 내용은 별도의 &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; 문서에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce4f9d4c36f7d70e8b9276d0825d097968bc414d" translate="yes" xml:space="preserve">
          <source>This document is created by a script which scans comments in the source code file sqlite3session.h.</source>
          <target state="translated">이 문서는 소스 코드 파일 sqlite3session.h에서 주석을 스캔하는 스크립트로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d12748856fa96aaf8fec02bb978ea061f37e25d7" translate="yes" xml:space="preserve">
          <source>This document is still sometimes used as a &quot;Code of Conduct&quot; on supplier registration forms. But it is not a Code of Conduct in the same sense that many communities mean a Code of Conduct. Rather, this document describes the ethical principles upon which SQLite is based. Another way to look at this document is as a succinct description of the SQLite Founder's idea of what it means to be &quot;virtuous&quot;.</source>
          <target state="translated">이 문서는 여전히 공급 업체 등록 양식에서 &quot;행동 강령&quot;으로 사용되기도합니다. 그러나 많은 공동체가 행동 강령을 의미하는 것과 같은 의미에서 행동 강령이 아닙니다. 오히려이 문서는 SQLite의 기반이되는 윤리적 원칙을 설명합니다. 이 문서를 보는 또 다른 방법은 SQLite Founder가 &quot;가상&quot;이라는 의미에 대한 간결한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="6ead8dcfb3bc7787acee358a9c3c6b55198ad643" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 사용을 제안 하지만 &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;모노톤&lt;/a&gt; 또는 &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;수은&lt;/a&gt; (일명 &quot;hg&quot;) 또는 &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; 과 같은 다른 분산 소프트웨어 구성 관리 시스템 도 사용할 수 있습니다. 절차의 세부 사항은 다양하지만 개념은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="98d1415d454d0b20f9e20df74b68698917685b9f" translate="yes" xml:space="preserve">
          <source>This document provides an overview of dynamic memory allocation within SQLite. The target audience is software engineers who are tuning their use of SQLite for peak performance in demanding environments. Nothing in this document is required knowledge for using SQLite. The default settings and configuration for SQLite will work well in most applications. However, the information contained in this document may be useful to engineers who are tuning SQLite to comply with special requirements or to run under unusual circumstances.</source>
          <target state="translated">이 문서는 SQLite 내 동적 메모리 할당에 대한 개요를 제공합니다. 대상 고객은 까다로운 환경에서 최고의 성능을 위해 SQLite 사용을 조정하는 소프트웨어 엔지니어입니다. 이 문서의 어느 것도 SQLite 사용에 필요한 지식이 없습니다. SQLite의 기본 설정 및 구성은 대부분의 응용 프로그램에서 잘 작동합니다. 그러나이 문서에 포함 된 정보는 SQLite를 특별 요구 사항을 준수하거나 특수한 상황에서 실행하도록 조정하는 엔지니어에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c06afae30b0b7293df04fe27c7c538132693e4c6" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the query planner and optimizer for SQLite works.</source>
          <target state="translated">이 문서는 쿼리 플래너 및 SQLite 용 최적화 프로그램의 작동 방식에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="54a3569b4cf066b2b50e3e942ef2c48ddc1b1732" translate="yes" xml:space="preserve">
          <source>This document provides background information about how the SQLite query planner and query engine work. Programmers can use this information to help create better indexes, and provide hints to help the query planner when needed.</source>
          <target state="translated">이 문서는 SQLite 쿼리 플래너 및 쿼리 엔진의 작동 방식에 대한 배경 정보를 제공합니다. 프로그래머는이 정보를 사용하여 더 나은 색인을 작성하고 필요할 때 조회 계획자를 돕는 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db48c0715525eb5ade6fdd8bc0b1d41936f8012f" translate="yes" xml:space="preserve">
          <source>This document strives to highlight the principal differences between SQLite and other SQL implementations, as an aid to developers that are porting to or from SQLite or who are trying to build a system that works across multiple database engines.</source>
          <target state="translated">이 문서는 SQLite로 포팅하거나 SQLite를 포팅하거나 여러 데이터베이스 엔진에서 작동하는 시스템을 구축하려는 개발자에게 도움이되도록 SQLite와 다른 SQL 구현의 주요 차이점을 강조하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="499e5ba33e0583ef7d40d010da72b3c26c5f57b3" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created (in a slightly different format) for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by various minor clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a specific technical meaning within many software development communities, a meaning which was at odds with the intent of this document. Hence, this document is now renamed and replaced by a &lt;a href=&quot;codeofconduct&quot;&gt;Code of Conduct&lt;/a&gt; that does comply with the specific technical requirements was inserted in the place of the old name.</source>
          <target state="translated">이 문서는 원래 &quot;행동 강령&quot;이라고하며, 다양한 소규모 클라이언트가 SQLite 개발자에게 제출 한 &quot;공급자 등록&quot;양식에 대한 상자를 작성하기 위해 작성되었습니다 (약간 다른 형식). 그러나 &quot;행동 강령&quot;은 많은 소프트웨어 개발 커뮤니티 내에서 특정한 기술적 의미를 지니고 있으며 이는 본 문서의 의도와 상충되는 의미입니다. 따라서이 문서의 이름이 바뀌고 &lt;a href=&quot;codeofconduct&quot;&gt;행동 강령으로&lt;/a&gt; 대체되었습니다. 특정 기술 요구 사항을 준수하는 .</target>
        </trans-unit>
        <trans-unit id="9f4b3397370025bf1fdba593094ae6486be0fecb" translate="yes" xml:space="preserve">
          <source>This document was originally created in early 2004 when SQLite version 2 was still in widespread use and was written to introduce the new concepts of SQLite version 3 to readers who were already familiar with SQLite version 2. But these days, most readers of this document have probably never seen SQLite version 2 and are only familiar with SQLite version 3. Nevertheless, this document continues to serve as an authoritative reference to how database file locking works in SQLite version 3.</source>
          <target state="translated">이 문서는 원래 2004 년 초에 SQLite 버전 2가 널리 보급되어 이미 SQLite 버전 2에 익숙한 독자들에게 SQLite 버전 3의 새로운 개념을 소개하기 위해 작성되었습니다. 그러나 오늘날이 문서의 독자 대부분은 SQLite 버전 2는 본 적이 없으며 SQLite 버전 3에만 익숙합니다. 그럼에도 불구하고이 문서는 데이터베이스 파일 잠금이 SQLite 버전 3에서 작동하는 방식에 대한 권위있는 참조로 계속 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="efa34a5056d6c01d0548b0f2be11ce7b6109059b" translate="yes" xml:space="preserve">
          <source>This experimental &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; provides information about a single &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; in a database file, such as the depth, and estimated number of pages and number of entries, and so forth.</source>
          <target state="translated">이 실험적인 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 는 데이터베이스 파일에서 깊이, 예상 페이지 수 및 항목 수 등과 같은 단일 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 에 대한 정보를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0902999854d1422342b1343c7db1457520c25f82" translate="yes" xml:space="preserve">
          <source>This facility is provided for WinRT which does not have an OS mechanism for reading or changing the current working directory. The use of this pragma in any other context is discouraged and may be disallowed in future releases.</source>
          <target state="translated">이 기능은 현재 작업 디렉토리를 읽거나 변경하기위한 OS 메커니즘이없는 WinRT에 제공됩니다. 다른 상황에서이 pragma를 사용하는 것은 권장되지 않으며 향후 릴리스에서는 허용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16ab751fe0e625eef00360bec04f5c6e2724bea" translate="yes" xml:space="preserve">
          <source>This feature could be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;information schema&lt;/a&gt; by first creating a separate schema using</source>
          <target state="translated">이 기능은 먼저 다음을 사용하여 별도의 스키마를 만들어 &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;정보 스키마&lt;/a&gt; 를 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc13030cdb5706fbe971e91e53cd50c5af469f0" translate="yes" xml:space="preserve">
          <source>This feature is experimental and is subject to change. Further documentation will become available if and when the table-valued functions for PRAGMAs feature becomes officially supported.</source>
          <target state="translated">이 기능은 실험용이며 변경 될 수 있습니다. PRAGMAs 기능에 대한 테이블 반환 함수가 공식적으로 지원되는 경우 추가 설명서를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18abc550835bcdb0029b1a86390eaca991d2351b" translate="yes" xml:space="preserve">
          <source>This field contains a checksum value, calculated based on the contents of the journaled database page data (the previous field) and the values stored in the</source>
          <target state="translated">이 필드에는 저널링 된 데이터베이스 페이지 데이터의 내용 (이전 필드)과</target>
        </trans-unit>
        <trans-unit id="e3760b531cd8fa332f7ee70ed518883a43ad81f8" translate="yes" xml:space="preserve">
          <source>This field contains the original data for the page, exactly as it appeared in the database file before the</source>
          <target state="translated">이 필드에는 페이지 이전의 데이터베이스 파일에 표시된대로 페이지의 원래 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae121150e2dd424e68324ff08f7e0c6c1d0a2a0" translate="yes" xml:space="preserve">
          <source>This field holds a phonetic code derived from coalesce(k1,word). Letters that have similar sounds are mapped into the same symbol. For example, all vowels and vowel clusters become the single symbol &quot;A&quot;. And the letters &quot;p&quot;, &quot;b&quot;, &quot;f&quot;, and &quot;v&quot; all become &quot;B&quot;. All nasal sounds are represented as &quot;N&quot;. And so forth. The mapping is based on ideas found in Soundex, Metaphone, and other long-standing phonetic matching systems. This key can be generated by the function spellfix1_phonehash(X). Hence: k2 = spellfix1_phonehash(coalesce(k1,word))</source>
          <target state="translated">이 필드는 coalesce (k1, word)에서 파생 된 음성 코드를 보유합니다. 비슷한 소리를 가진 글자는 같은 기호로 매핑됩니다. 예를 들어 모든 모음과 모음 클러스터는 단일 기호 &quot;A&quot;가됩니다. 문자 &quot;p&quot;, &quot;b&quot;, &quot;f&quot;및 &quot;v&quot;는 모두 &quot;B&quot;가됩니다. 모든 코 소리는 &quot;N&quot;으로 표시됩니다. 기타 등등. 매핑은 Soundex, Metaphone 및 기타 오랜 음성 일치 시스템에서 발견 된 아이디어를 기반으로합니다. 이 키는 spellfix1_phonehash (X) 함수로 생성 할 수 있습니다. 따라서 : k2 = spellfix1_phonehash (coalesce (k1, word))</target>
        </trans-unit>
        <trans-unit id="7981d385aa4b9ca4b4f9844539885d4afde0da8a" translate="yes" xml:space="preserve">
          <source>This field may contain either an integer or a text field consisting of two integers separated by a space character (unicode codepoint 0x20).</source>
          <target state="translated">이 필드는 정수 또는 공백 문자 (유니 코드 코드 포인트 0x20)로 구분 된 두 개의 정수로 구성된 텍스트 필드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de591efb54fdb80ffddf1b7c9525e6ab9978c95c" translate="yes" xml:space="preserve">
          <source>This field must be set one of integer values 0 and 8, or else to NULL.</source>
          <target state="translated">이 필드는 정수 값 0과 8 중 하나 또는 NULL로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e75b74f43def5b21dd19f54d176219e2332fba0" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;database page count&lt;/b&gt;, is set to the number of pages that the</source>
          <target state="translated">&lt;b&gt;데이터베이스 페이지&lt;/b&gt; 수인 이 필드는 &lt;b&gt;페이지 수로&lt;/b&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce138fa916045f081e00c343e7762b51298df38" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;locking page number&lt;/b&gt;, is always set to the page number of the database</source>
          <target state="translated">이 &lt;b&gt;페이지 인 잠금 페이지 번호&lt;/b&gt; 는 항상 데이터베이스의 페이지 번호로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="825eef8a444b33cb8e93566d91167c3eabd02df8" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;record count&lt;/b&gt;, is set to the number of</source>
          <target state="translated">이 필드 인 &lt;b&gt;레코드&lt;/b&gt; 수는</target>
        </trans-unit>
        <trans-unit id="f631e740c08280177f2a7f6f8390e6ab3758fda5" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;sector size&lt;/b&gt;, is set to the</source>
          <target state="translated">이 필드 인 &lt;b&gt;섹터 크기&lt;/b&gt; 는</target>
        </trans-unit>
        <trans-unit id="caf63c1c58b9f87489297844a819efb8d6633a40" translate="yes" xml:space="preserve">
          <source>This flag causes comma-separators to be added to the output of %d and %i substitutions, between every 3 digits from the left. This can help humans to more easily discern the magnitude of large integer values. For example, the value 2147483647 would be rendered as &quot;2147483647&quot; using &quot;%d&quot; but would appear as &quot;2,147,483,647&quot; with &quot;%,d&quot;. This flag is a non-standard extension.</source>
          <target state="translated">이 플래그는 쉼표로 구분자가 왼쪽에서 3 자리마다 % d 및 % i 대체의 출력에 추가되도록합니다. 이를 통해 인간은 큰 정수 값의 크기를 더 쉽게 식별 할 수 있습니다. 예를 들어, 값 2147483647은 &quot;% d&quot;를 사용하여 &quot;2147483647&quot;으로 렌더링되지만 &quot;%, d&quot;와 함께 &quot;2,147,483,647&quot;으로 나타납니다. 이 플래그는 비표준 확장입니다.</target>
        </trans-unit>
        <trans-unit id="a5b80382a268dfe85ecc58efaaccd407cc41e4b2" translate="yes" xml:space="preserve">
          <source>This function adds a set of changes to the session object that could be used to update the table in database zFrom (call this the &quot;from-table&quot;) so that its content is the same as the table attached to the session object (call this the &quot;to-table&quot;). Specifically:</source>
          <target state="translated">이 함수는 zFrom 데이터베이스에서 테이블을 업데이트하는 데 사용할 수있는 일련의 변경 사항을 세션 오브젝트에 추가하여 (이를 &quot;from-table&quot;이라고 함) 내용이 세션 오브젝트에 첨부 된 테이블과 동일하도록합니다 (이것을 호출하십시오) &quot;테이블까지&quot;). 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="3b5d7e99038e4d5b072061176057f97dc299323e" translate="yes" xml:space="preserve">
          <source>This function and xPhraseNextColumn() are similar to the xPhraseFirst() and xPhraseNext() APIs described above. The difference is that instead of iterating through all instances of a phrase in the current row, these APIs are used to iterate through the set of columns in the current row that contain one or more instances of a specified phrase. For example:</source>
          <target state="translated">이 함수 및 xPhraseNextColumn ()은 위에서 설명한 xPhraseFirst () 및 xPhraseNext () API와 유사합니다. 차이점은 현재 행에서 구의 모든 인스턴스를 반복하는 대신이 API를 사용하여 지정된 구의 하나 이상의 인스턴스를 포함하는 현재 행의 열 세트를 반복합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80988b461d2df6302b49f4dceec8b27b005d6908" translate="yes" xml:space="preserve">
          <source>This function attempts to retrieve the text of column iCol of the current document. If successful, (*pz) is set to point to a buffer containing the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters) of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite error code is returned and the final values of (*pz) and (*pn) are undefined.</source>
          <target state="translated">이 함수는 현재 문서의 iCol 열의 텍스트를 검색하려고 시도합니다. 성공하면 (* pz)가 utf-8 인코딩의 텍스트를 포함하는 버퍼를 가리 키도록 설정되고 (* pn)이 버퍼의 크기 (문자가 아닌)로 설정되고 SQLITE_OK가 리턴됩니다. 그렇지 않으면 오류가 발생하면 SQLite 오류 코드가 리턴되고 (* pz) 및 (* pn)의 최종 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28a6bb3de337284487682e360c8a725a543916e4" translate="yes" xml:space="preserve">
          <source>This function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.</source>
          <target state="translated">이 함수는 데이터베이스 핸들 db의 데이터베이스 zDb와 연관된 WAL 파일을 스캔하고 sqlite3_snapshot_open ()에서 유효한 모든 스냅 샷을 사용할 수있게합니다. 데이터베이스에 이미 읽기 트랜잭션이 열려 있거나 데이터베이스가 WAL 모드 데이터베이스가 아닌 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="27eaa9cd67b4a77bfd0fe868cf2e24b92591db2f" translate="yes" xml:space="preserve">
          <source>This function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.</source>
          <target state="translated">이 함수는 디스크에서 모든 데이터베이스 스키마를 읽고 구문 분석합니다 (아직 수행되지 않은 경우). 스키마를로드하는 동안 오류가 발생하면 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7d871089984a2a55cb6c89bf16fcd0bc4a023753" translate="yes" xml:space="preserve">
          <source>This function causes any pending database operation to abort and return at its earliest opportunity. This routine is typically called in response to a user action such as pressing &quot;Cancel&quot; or Ctrl-C where the user wants a long query operation to halt immediately.</source>
          <target state="translated">이 기능을 사용하면 보류중인 데이터베이스 작업이 최대한 빨리 중단되고 반환됩니다. 이 루틴은 일반적으로 사용자가 긴 쿼리 조작을 즉시 중지하려는 &quot;취소&quot;또는 Ctrl-C 누르기와 같은 사용자 조치에 대한 응답으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="84f0a277d8eb36da2c14763cce01f3221d3f3be5" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 닫습니다 . BLOB 핸들은 무조건 닫힙니다. 이 루틴이 오류 코드를 리턴하더라도 핸들은 여전히 ​​닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c52c6ec750ee5ca8bf8f3568aa703ede60385a7a" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 닫습니다 . BLOB 핸들은 무조건 닫힙니다. 이 루틴이 오류 코드를 리턴하더라도 핸들은 여전히 ​​닫힙니다.</target>
        </trans-unit>
        <trans-unit id="dcb5cb2e9c08e0b9f3037428dbe4920c74c2b405" translate="yes" xml:space="preserve">
          <source>This function combines the two input changesets using an sqlite3_changegroup object. Calling it produces similar results as the following code fragment:</source>
          <target state="translated">이 함수는 sqlite3_changegroup 객체를 사용하여 두 개의 입력 변경 세트를 결합합니다. 호출하면 다음 코드 조각과 유사한 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4624a9200d853f2e32a44b7a98a35021843efd43" translate="yes" xml:space="preserve">
          <source>This function does not change the order in which changes appear within the changeset. It merely reverses the sense of each individual change.</source>
          <target state="translated">이 기능은 변경 세트 내에서 변경이 나타나는 순서를 변경하지 않습니다. 그것은 단지 각각의 개별적인 변화의 감각을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="d7cbc42833b432d19d25054e50c1379caf39e23d" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 함수 가 리턴 한 데이터베이스 핸들 오류 코드 또는 메시지를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c015e6f1fde0378f350b940649e6bb977266a40" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 함수 가 리턴 한 데이터베이스 핸들 오류 코드 또는 메시지를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6303b7057e9914dac072c1b4a0b74b270e4dc698" translate="yes" xml:space="preserve">
          <source>This function fails with SQLITE_ERROR if any of the following are true:</source>
          <target state="translated">다음 중 하나에 해당하면이 함수는 SQLITE_ERROR와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="870ceb33e21de66e2ccc8a5ce1caa06026ee0a3c" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid () SQL 함수&lt;/a&gt; 를 통해 SQL 문에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ed24a06a5fab16f67d5f77a45744a9d31cdf2e0" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid () SQL 함수&lt;/a&gt; 를 통해 SQL 문에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba56f71e7eaf44d8bff350353ce98793aa844743" translate="yes" xml:space="preserve">
          <source>This function is expected to tokenize the nText byte string indicated by argument pText. pText may or may not be nul-terminated. The first argument passed to this function is a pointer to an Fts5Tokenizer object returned by an earlier call to xCreate().</source>
          <target state="translated">이 함수는 pText 인수로 표시되는 nText 바이트 문자열을 토큰 화해야합니다. pText는 널 종료되거나 종료되지 않을 수 있습니다. 이 함수에 전달 된 첫 번째 인수는 이전 xCreate () 호출로 반환 된 Fts5Tokenizer 객체에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c0f6fbfd19fbfc44b1560cfd2b05948b7fed7c50" translate="yes" xml:space="preserve">
          <source>This function is invoked to delete a tokenizer handle previously allocated using xCreate(). Fts5 guarantees that this function will be invoked exactly once for each successful call to xCreate().</source>
          <target state="translated">이 함수는 xCreate ()를 사용하여 이전에 할당 된 토크 나이저 핸들을 삭제하기 위해 호출됩니다. Fts5는 xCreate ()를 성공적으로 호출 할 때마다이 함수가 정확히 한 번만 호출되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fcde84651450f2b10b0843fe43cf87cdc47c8be9" translate="yes" xml:space="preserve">
          <source>This function is used to &quot;invert&quot; a changeset object. Applying an inverted changeset to a database reverses the effects of applying the uninverted changeset. Specifically:</source>
          <target state="translated">이 기능은 변경 세트 객체를 &quot;반전&quot;시키는 데 사용됩니다. 반전 된 변경 세트를 데이터베이스에 적용하면 반전되지 않은 변경 세트를 적용한 결과가 반대로됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="29ae82377275c7b1f1384fc8e2d212e8da0789d4" translate="yes" xml:space="preserve">
          <source>This function is used to allocate and initialize a tokenizer instance. A tokenizer instance is required to actually tokenize text.</source>
          <target state="translated">이 함수는 토크 나이저 인스턴스를 할당하고 초기화하는 데 사용됩니다. 텍스트를 실제로 토큰 화하려면 토크 나이저 인스턴스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24b74a85f4b47c195bc0b6fe21af9724e0d1ed94" translate="yes" xml:space="preserve">
          <source>This function is used to concatenate two changesets, A and B, into a single changeset. The result is a changeset equivalent to applying changeset A followed by changeset B.</source>
          <target state="translated">이 기능은 두 개의 변경 세트 A와 B를 단일 변경 세트로 연결하는 데 사용됩니다. 결과는 변경 세트 A를 적용한 다음 변경 세트 B를 적용하는 것과 동일한 변경 세트입니다.</target>
        </trans-unit>
        <trans-unit id="69eb445f771165e9cf3bdc2eef0ebd4932045f16" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()로&lt;/a&gt; 할당 된 반복자를 마무리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b35815e34122016382887fcb96a49b58070b37da" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()로&lt;/a&gt; 할당 된 반복자를 마무리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cfec4fd8864b11036478634ce0c848102b439e0" translate="yes" xml:space="preserve">
          <source>This function is used to find which columns comprise the PRIMARY KEY of the table modified by the change that iterator pIter currently points to. If successful, *pabPK is set to point to an array of nCol entries, where nCol is the number of columns in the table. Elements of *pabPK are set to 0x01 if the corresponding column is part of the tables primary key, or 0x00 if it is not.</source>
          <target state="translated">이 함수는 반복자 pIter가 현재 가리키는 변경에 의해 수정 된 테이블의 PRIMARY KEY를 구성하는 열을 찾는 데 사용됩니다. 성공하면 * pabPK는 nCol 항목의 배열을 가리 키도록 설정됩니다. 여기서 nCol은 테이블의 열 수입니다. * pabPK의 요소는 해당 컬럼이 테이블 기본 키의 일부인 경우 0x01로 설정되고 그렇지 않은 경우 0x00으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e114c8bad40f12de287f68c473424a8e6e66648d" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">이 함수는 기존 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 이동 하여 동일한 데이터베이스 테이블의 다른 행을 가리 키도록하는 데 사용됩니다 . 새 행은 두 번째 인수로 전달 된 rowid 값으로 식별됩니다. 행만 변경할 수 있습니다. Blob 핸들이 열려있는 데이터베이스, 테이블 및 열은 동일하게 유지됩니다. 기존 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 새 행으로 옮기는 것이 기존 핸들 을 닫고 새 핸들을 여는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="308c798f0a295eb0c4645e5b7f42fbabbc544780" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">이 함수는 기존 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 이동 하여 동일한 데이터베이스 테이블의 다른 행을 가리 키도록하는 데 사용됩니다 . 새 행은 두 번째 인수로 전달 된 rowid 값으로 식별됩니다. 행만 변경할 수 있습니다. Blob 핸들이 열려있는 데이터베이스, 테이블 및 열은 동일하게 유지됩니다. 기존 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 새 행으로 옮기는 것이 기존 핸들 을 닫고 새 핸들을 여는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4b885ede0001de9f5c638f038a437a23ced24dd6" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 호출자 제공 버퍼로 데이터를 읽는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 열린 BLOB에서 N 바이트의 데이터가 버퍼 Z에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="21272222209bb70a086675dada0f2b2f97f0f8e4" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 호출자 제공 버퍼로 데이터를 읽는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 열린 BLOB에서 N 바이트의 데이터가 버퍼 Z에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="9f3667d662139e493e6cf3b56b1b782512c8bc44" translate="yes" xml:space="preserve">
          <source>This function is used to retrieve the total number of rows in the table. In other words, the same value that would be returned by:</source>
          <target state="translated">이 함수는 테이블에서 총 행 수를 검색하는 데 사용됩니다. 즉, 다음과 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b651a758789810b674e3ae5146e089dc27672b54" translate="yes" xml:space="preserve">
          <source>This function is used to set, clear or query the session object indirect flag. If the second argument passed to this function is zero, then the indirect flag is cleared. If it is greater than zero, the indirect flag is set. Passing a value less than zero does not modify the current value of the indirect flag, and may be used to query the current state of the indirect flag for the specified session object.</source>
          <target state="translated">이 함수는 세션 객체 간접 플래그를 설정, 해제 또는 쿼리하는 데 사용됩니다. 이 함수에 전달 된 두 번째 인수가 0이면 간접 플래그가 지워집니다. 0보다 크면 간접 플래그가 설정됩니다. 0보다 작은 값을 전달해도 간접 플래그의 현재 값은 수정되지 않으며 지정된 세션 객체에 대한 간접 플래그의 현재 상태를 쿼리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a1761e9d0e1762347b4943de9494b5f2f5f8cc" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 호출자 제공 버퍼에서 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들에&lt;/a&gt; 데이터를 쓰는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 N 바이트의 데이터가 버퍼 Z에서 열린 BLOB으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="959745cc981e8eae46a52bb0e5894da3fa5cff9f" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 호출자 제공 버퍼에서 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들에&lt;/a&gt; 데이터를 쓰는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 N 바이트의 데이터가 버퍼 Z에서 열린 BLOB으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="1483892d5daffd0f4eda8275dee22e2f701b626d" translate="yes" xml:space="preserve">
          <source>This function is used, along with type Fts5PhraseIter and the xPhraseNext method, to iterate through all instances of a single query phrase within the current row. This is the same information as is accessible via the xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient to use, this API may be faster under some circumstances. To iterate through instances of phrase iPhrase, use the following code:</source>
          <target state="translated">이 함수는 Fts5PhraseIter 유형 및 xPhraseNext 메소드와 함께 사용되어 현재 행 내에서 단일 쿼리 구문의 모든 인스턴스를 반복합니다. 이는 xInstCount / xInst API를 통해 액세스 할 수있는 정보와 동일합니다. xInstCount / xInst API를 사용하는 것이 더 편리하지만 일부 상황에서는이 API가 더 빠를 수 있습니다. 문구 iPhrase의 인스턴스를 반복하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e540303404a447a74d8a0d678f9bad1c3c4058d" translate="yes" xml:space="preserve">
          <source>This function maps every page number into an integer between 0 and 8191 inclusive. The aHash field of each 32768-byte shm file unit maps P values into indexes of the aPgno field of the same unit as follows:</source>
          <target state="translated">이 함수는 모든 페이지 번호를 0에서 8191 사이의 정수로 매핑합니다. 각 32768 바이트 shm 파일 단위의 aHash 필드는 다음과 같이 P 값을 동일한 단위의 aPgno 필드 색인으로 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="b474b368c95d2db3e02f8d968fb517ea9f808a38" translate="yes" xml:space="preserve">
          <source>This function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.</source>
          <target state="translated">이 함수는 SQLITE_NOMEM을 반환 할 수도 있습니다. 자동 커미트 모드에서 데이터베이스 핸들로 호출되었지만 다른 이유로 실패한 경우 스키마 S에서 읽기 트랜잭션이 열리는 지 여부는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d107c7c4ed710ea3330eefcfd44db3b75a5ff363" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메소드에 의해 호출되어 가상 테이블 인터페이스의 다양한 측면을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436450a55b61a947a304f65e4e9be131ade57dc9" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메소드에 의해 호출되어 가상 테이블 인터페이스의 다양한 측면을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892823d34401462a7936657244cacf73ba9d16a7" translate="yes" xml:space="preserve">
          <source>This function may be quite inefficient if used with an FTS5 table created with the &quot;columnsize=0&quot; option.</source>
          <target state="translated">이 함수는 &quot;columnsize = 0&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하는 경우 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c728fb74daea7a42a0d0a89203b1fbf38464ae" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651e6e671ae629015a6ac3d4f4c461902dc827bb" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 INSERT 또는 UPDATE 조작에 대한 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 . 리턴 된 값은 &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt; , &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt; , &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는&lt;a href=&quot;c_fail&quot;&gt;&lt;/a&gt; 은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드에 대한 호출을 트리거 한 SQL 문의 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드 에 따라 SQLITE_REPLACE .</target>
        </trans-unit>
        <trans-unit id="a16a26f00d528f2a67fb084167cd62426f17fa64" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a48f675a9216b80779894ce906eb64bd5d832356" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 INSERT 또는 UPDATE 조작에 대한 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 . 리턴 된 값 은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드에 대한 호출을 트리거 한 SQL 문의 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드 에 따라 &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt; , &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는&lt;a href=&quot;#SQLITE_FAIL&quot;&gt; SQLITE_REPLACE&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="9f4b868b197498e92e7be98a22186e8a9d0ec008" translate="yes" xml:space="preserve">
          <source>This function may only be called with an iterator passed to an SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case it sets the output variable to the total number of known foreign key violations in the destination database and returns SQLITE_OK.</source>
          <target state="translated">이 함수는 반복자가 SQLITE_CHANGESET_FOREIGN_KEY 충돌 처리기 콜백으로 전달 된 경우에만 호출 할 수 있습니다. 이 경우 출력 변수를 대상 데이터베이스에서 알려진 외래 키 위반의 총 수로 설정하고 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6aefcc013460f98a7eaca0c2faea39955530e82b" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수로 작성된 반복자와 함께 만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러 콜백으로 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 리턴되고 호출은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b40997bef104535dd0852dc311c81d541b71952" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수로 작성된 반복자와 함께 만 사용할 수 있습니다 . &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러 콜백으로 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 리턴되고 호출은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81dcfaa530f9bc3b0cf4ff6ac3dd711bd8249deb" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수에 의해 생성 된 이터레이터에서만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 처리기 콜백에 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 반환되고 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2a7a3750664d2ff5967d620601e32e54729a198" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수에 의해 생성 된 이터레이터에서만 사용할 수 있습니다 . &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 처리기 콜백에 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 반환되고 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd3cebc479567b581aaea382b042cd658c5a6fd2" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">이 함수는 BLOB의 내용 만 수정할 수 있습니다. 이 API를 사용하여 BLOB의 크기를 늘릴 수는 없습니다. BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다. BLOB의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 . N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc4415e783325c61d6eb500d3a2195a9814914cb" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">이 함수는 BLOB의 내용 만 수정할 수 있습니다. 이 API를 사용하여 BLOB의 크기를 늘릴 수는 없습니다. BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다. BLOB의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 . N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e611001e69d55801c25d56986ec39153bc754108" translate="yes" xml:space="preserve">
          <source>This function returns SQLITE_OK if successful, or an SQLite error code otherwise.</source>
          <target state="translated">이 함수는 성공하면 SQLITE_OK를, 그렇지 않으면 SQLite 오류 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c2517d3cf09b0cdb52fd7581d781f148fee8f8f" translate="yes" xml:space="preserve">
          <source>This function returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter. Executing any other type of SQL statement does not modify the value returned by this function.</source>
          <target state="translated">이 함수는 유일한 매개 변수로 지정된 데이터베이스 연결에서 가장 최근에 완료된 INSERT, UPDATE 또는 DELETE 문에 의해 수정, 삽입 또는 삭제 된 행 수를 리턴합니다. 다른 유형의 SQL 문을 실행해도이 함수가 리턴 한 값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b76b4997f936492171845d7baebab3de049f79f" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">이 함수는 트리거 프로그램의 일부로 실행 된 행을 포함하여 데이터베이스 연결이 열린 후 완료된 모든 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 문에 의해 삽입, 수정 또는 삭제 된 총 행 수를 리턴합니다 . 다른 유형의 SQL 문을 실행해도 sqlite3_total_changes ()에 의해 리턴 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adf4834644160b8bd2e8b37a1e591e556b1afb6a" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">이 함수는 트리거 프로그램의 일부로 실행 된 행을 포함하여 데이터베이스 연결이 열린 후 완료된 모든 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문에 의해 삽입, 수정 또는 삭제 된 총 행 수를 리턴합니다 . 다른 유형의 SQL 문을 실행해도 sqlite3_total_changes ()에 의해 리턴 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8213d08301f09db1801edcdcc6b6898d5bedde17" translate="yes" xml:space="preserve">
          <source>This function sets the database handle error code and message.</source>
          <target state="translated">이 함수는 데이터베이스 핸들 오류 코드 및 메시지를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dc027be02604df0d93fb0c7fd87bd8fb650c8db3" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수를 사용하여 만든 반복자에서만 호출해야 합니다. 응용 프로그램에 의해 충돌 핸들러에 전달 반복자로이 함수를 호출하는 경우 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;) sqlite3changeset_apply (&lt;/a&gt; , &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE은&lt;/a&gt; 즉시 반환하고 통화는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2df7e3d1377d5e8297acef52974006d62b57703e" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수를 사용하여 만든 반복자에서만 호출해야 합니다. 응용 프로그램에 의해 충돌 핸들러에 전달 반복자로이 함수를 호출하는 경우 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;) sqlite3changeset_apply (&lt;/a&gt; , &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE은&lt;/a&gt; 즉시 반환하고 통화는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6644624c994928cadd1595cf7f165d3a9a2ca4f0" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; 에 의해 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; 를 사용하여 충돌 핸들러 콜백에 전달 된 반복자 객체에만 사용해야합니다 . 이 함수가 다른 반복자에서 호출되면 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="548141af0246ca4eef33b575f89c5796207c5a05" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; 에 의해 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 또는 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; 를 사용하여 충돌 핸들러 콜백에 전달 된 반복자 객체에만 사용해야합니다 . 이 함수가 다른 반복자에서 호출되면 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aabca26792420e3dedde38828f3aa35b5f3a0612" translate="yes" xml:space="preserve">
          <source>This generates a file named &lt;b&gt;ex1.dump.gz&lt;/b&gt; that contains everything you need to reconstruct the database at a later time, or on another machine. To reconstruct the database, just type:</source>
          <target state="translated">그러면 나중에 또는 다른 시스템에서 데이터베이스를 재구성하는 데 필요한 모든 것이 포함 된 &lt;b&gt;ex1.dump.gz&lt;/b&gt; 라는 파일이 생성 됩니다. 데이터베이스를 재구성하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="311cc4fab23f9723b1a4efe300a30ad45967a776" translate="yes" xml:space="preserve">
          <source>This graph is acyclic. And we assume that the mtime of every child checkin is no less than the mtime of all its parents. But unlike the earlier examples, this graph might have multiple paths of differing lengths between any two checkins.</source>
          <target state="translated">이 그래프는 비 주기적입니다. 그리고 우리는 모든 어린이 체크인의 mtime이 모든 부모의 mtime 이상이라고 가정합니다. 그러나 이전 예제와 달리이 그래프에는 두 체크인 사이에 길이가 다른 여러 경로가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0e2bf6a1863b49e18b3cb7db1999e03d428ead" translate="yes" xml:space="preserve">
          <source>This historical version numbering system used a two-, three-, or four-number version: W.X, W.X.Y, or W.X.Y.Z. W was the file format: 1 or 2 or 3. X was the major version. Y was the minor version. Z was used only for patch releases to fix bugs.</source>
          <target state="translated">이 히스토리 버전 번호 매기기 시스템은 2, 3 또는 4 번호 버전을 사용했습니다. WX, WXY 또는 WXYZ W는 파일 형식 : 1 또는 2 또는 3입니다. X는 주 버전입니다. Y는 부 버전이었습니다. Z는 버그를 수정하기 위해 패치 릴리스에만 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f4676d0afd51e8fa37c9aa0283801b026a1b72b" translate="yes" xml:space="preserve">
          <source>This instruction causes the VM to halt.</source>
          <target state="translated">이 명령으로 인해 VM이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc444b74a87e964e8bcc2b42a370bbc5df69c15" translate="yes" xml:space="preserve">
          <source>This instruction makes a deep copy of the value. A duplicate is made of any string or blob constant. See also &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;.</source>
          <target state="translated">이 명령어는 값의 깊은 사본을 만듭니다. 문자열이나 얼룩 상수로 복제됩니다. &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dad5db056b0ca8e5a487c8ab6c8e6dc7e0f2672" translate="yes" xml:space="preserve">
          <source>This instruction makes a shallow copy of the value. If the value is a string or blob, then the copy is only a pointer to the original and hence if the original changes so will the copy. Worse, if the original is deallocated, the copy becomes invalid. Thus the program must guarantee that the original will not change during the lifetime of the copy. Use &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; to make a complete copy.</source>
          <target state="translated">이 명령어는 값의 얕은 사본을 만듭니다. 값이 문자열 또는 얼룩 인 경우 사본은 원본에 대한 포인터 일 뿐이므로 원본이 변경되면 사본도 변경됩니다. 게다가 원본을 할당 해제하면 사본이 유효하지 않게됩니다. 따라서 프로그램은 사본의 수명 동안 원본이 변경되지 않도록 보장해야합니다. 전체 &lt;a href=&quot;opcode#Copy&quot;&gt;복사&lt;/a&gt; 를 하려면 복사 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df251f100bd98635ac20986854a4f9d3558bf05" translate="yes" xml:space="preserve">
          <source>This instruction only works for indices. The equivalent instruction for tables is &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;.</source>
          <target state="translated">이 지침은 인덱스에만 적용됩니다. 테이블에 해당하는 명령어는 &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="724c5d92359b2812711bd98fdbbd0ee48ff16933" translate="yes" xml:space="preserve">
          <source>This instruction only works on tables. The equivalent instruction for indices is &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;.</source>
          <target state="translated">이 명령어는 테이블에서만 작동합니다. 인덱스에 해당하는 명령어는 &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc342418f5a1b7e3edc039b6124a9b746a56c8e5" translate="yes" xml:space="preserve">
          <source>This instruction throws an error if the memory cell is not initially an integer.</source>
          <target state="translated">메모리 셀이 처음에 정수가 아닌 경우이 명령어는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b8399072455bb3b6ee2757655f5f7b2af59230c1" translate="yes" xml:space="preserve">
          <source>This instruction works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it opens the cursor in read/write mode.</source>
          <target state="translated">이 명령어 는 커서를 읽기 / 쓰기 모드로 여는 &lt;a href=&quot;opcode#OpenRead&quot;&gt;것을&lt;/a&gt; 제외하고 OpenRead 와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="849ae2eb4b736949542c4487e7de5222b770b0b6" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">이 인터페이스를 사용하면 다양한 구성의 크기를 연결별로 연결별로 제한 할 수 있습니다. 첫 번째 매개 변수는 한계를 설정하거나 조회 할 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 두 번째 매개 변수는 구조 클래스를 크기 제한으로 정의하는 &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;제한 범주&lt;/a&gt; 중 하나입니다 . 세 번째 매개 변수는 해당 구성에 대한 새로운 한계입니다.</target>
        </trans-unit>
        <trans-unit id="6687035e8ed6fa147345334bd3634ec9e7ff5918" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;c_limit_attached&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">이 인터페이스를 사용하면 다양한 구성의 크기를 연결별로 연결별로 제한 할 수 있습니다. 첫 번째 매개 변수는 한계를 설정하거나 조회 할 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 두 번째 매개 변수는 구조 클래스를 크기 제한으로 정의하는 &lt;a href=&quot;c_limit_attached&quot;&gt;제한 범주&lt;/a&gt; 중 하나입니다 . 세 번째 매개 변수는 해당 구성에 대한 새로운 한계입니다.</target>
        </trans-unit>
        <trans-unit id="9256e21c25ccdf9db985fbb93738819f3d6d967d" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">이 인터페이스는 애플리케이션이 연결하는 SQLite 버전이 원하는 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 매크로 설정으로 컴파일되었는지 확인하기 위해 애플리케이션에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32dc361b08c9c60505d75103bdc36b57584e9fcf" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">이 인터페이스는 애플리케이션이 연결하는 SQLite 버전이 원하는 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 매크로 설정으로 컴파일되었는지 확인하기 위해 애플리케이션에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25ebb19095f954c7ae8a2ed499bdbfed83aadaa6" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; 와 함께 사용하여 재설정이 필요한 데이터베이스 연결과 연관된 모든 준비된 명령문을 찾을 수 있습니다 . 예를 들어, 진단 루틴에서 트랜잭션을 열린 상태로 준비된 명령문을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d607ef96133a79a067aeb3d80e9e814bdda87569" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; 와 함께 사용하여 재설정이 필요한 데이터베이스 연결과 연관된 모든 준비된 명령문을 찾을 수 있습니다 . 예를 들어, 진단 루틴에서 트랜잭션을 열린 상태로 준비된 명령문을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d798abdc7bea34806f312f897736975cfc379c7c" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">이 인터페이스 는 작성된 새 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 마다 xEntryPoint () 함수가 호출되도록합니다 . 여기서 xEntryPoint ()는 모든 새 데이터베이스 연결에 자동으로로드 되는 정적으로 링크 된 &lt;a href=&quot;loadext&quot;&gt;SQLite 확장의&lt;/a&gt; 시작점 이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a18b59c5465abea2190a535937651aa6f4f67fb4" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">이 인터페이스 는 작성된 새 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 마다 xEntryPoint () 함수가 호출되도록합니다 . 여기서 xEntryPoint ()는 모든 새 데이터베이스 연결에 자동으로로드 되는 정적으로 링크 된 &lt;a href=&quot;../loadext&quot;&gt;SQLite 확장의&lt;/a&gt; 시작점 이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9786ef1ecb8c77d789971c3f849525761d5d38c2" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension ()을&lt;/a&gt; 사용하여 이전에 등록 된 모든 자동 확장을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2b9c0cbd974b30f6431515e1186211476ca08e78" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension ()을&lt;/a&gt; 사용하여 이전에 등록 된 모든 자동 확장을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="8736a85b1a1bcc4c800c4ff7d229eb677c9e2f70" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">이 인터페이스는 C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 및 SQL 함수 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()을&lt;/a&gt; 모두 활성화하거나 비활성화합니다 . 사용 &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (dB, &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION는&lt;/a&gt; ..)을 사용하거나 사용하지 않도록 설정에만 C-API입니다.</target>
        </trans-unit>
        <trans-unit id="ab1cdc93fe51f37fdae78544827ec5e365f941a3" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">이 인터페이스는 C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 및 SQL 함수 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()을&lt;/a&gt; 모두 활성화하거나 비활성화합니다 . 사용 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (dB, &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION는&lt;/a&gt; ..)을 사용하거나 사용하지 않도록 설정에만 C-API입니다.</target>
        </trans-unit>
        <trans-unit id="737d038457ffc2dd705bbf7d3e67fd74eca8f49b" translate="yes" xml:space="preserve">
          <source>This interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.</source>
          <target state="translated">이 인터페이스는 응용 프로그램에서 사용하지 않습니다. SQLite 라이브러리의 올바른 작동을 확인하기 위해서만 존재합니다. SQLite 라이브러리가 컴파일되는 방법에 따라이 인터페이스가 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec74db456b76b7c855d3cb1358c040acad3ef05" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="5c93fb0edc37eb4be652a31e1dc573b6923060cf" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="17b0e4d3f046d7d363af1d959e76e0c4d41dedec" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f287e88e4474f60d3222ad14486a836ab2470ef3" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="a689b67f9c0bc2c193b97b5db4c5c4f5c1e2370b" translate="yes" xml:space="preserve">
          <source>This interface is similar except that it takes a pointer to a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as its first argument and returns statistics about that one object rather than about the entire SQLite library. The &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface currently only recognizes a single verb &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED&lt;/a&gt;, though additional verbs may be added in the future.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 포인터를 첫 번째 인수로 사용하고 전체 SQLite 라이브러리가 아닌 해당 객체에 대한 통계를 반환 한다는 점을 제외하면 비슷 합니다. &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스는 현재 하나의 동사 인식 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasideused&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_USED을&lt;/a&gt; 추가 동사는 향후에 추가 될 수 있지만,.</target>
        </trans-unit>
        <trans-unit id="6dbf3e0af679b24ae953bf947ba5e6b711370c31" translate="yes" xml:space="preserve">
          <source>This interface is threadsafe on processors where writing a 32-bit integer is atomic.</source>
          <target state="translated">이 인터페이스는 32 비트 정수를 쓰는 것이 원자적인 프로세서에서 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="107b6df452544e21fe27c0a26828c70050b20ba8" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에서 카운터 값을 검색하고 재설정하는 데 사용됩니다 . 첫 번째 인수는 조사 할 준비된 명령문 오브젝트입니다. 두 번째 인수는 특정 &lt;a href=&quot;#SQLITE_STMTSTATUS%20counter&quot;&gt;SQLITE_STMTSTATUS 카운터&lt;/a&gt; 를 조사하기 위한 정수 코드입니다 . 요청 된 카운터의 현재 값이 반환됩니다. resetFlg가 true이면이 인터페이스 호출이 리턴 된 후 카운터가 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="459a2b79d755add49b63bbc4196d838dcdf41bd6" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve and reset counter values from a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The first argument is the prepared statement object to be interrogated. The second argument is an integer code for a specific &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS counter&lt;/a&gt; to be interrogated. The current value of the requested counter is returned. If the resetFlg is true, then the counter is reset to zero after this interface call returns.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에서 카운터 값을 검색하고 재설정하는 데 사용됩니다 . 첫 번째 인수는 조사 할 준비된 명령문 오브젝트입니다. 두 번째 인수는 특정 &lt;a href=&quot;c_stmtstatus_counter&quot;&gt;SQLITE_STMTSTATUS 카운터&lt;/a&gt; 를 조사하기 위한 정수 코드입니다 . 요청 된 카운터의 현재 값이 반환됩니다. resetFlg가 true이면이 인터페이스 호출이 리턴 된 후 카운터가 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4800232e2d56454f4af979f9b03af1383971aa52" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">이 인터페이스는 단일 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대한 런타임 상태 정보를 검색하는 데 사용됩니다 . 첫 번째 인수는 조사 할 데이터베이스 연결 개체입니다. 두 번째 인수는 &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS 옵션&lt;/a&gt; 세트에서 가져온 정수 상수로, 조사 할 매개 변수를 결정합니다. &lt;a href=&quot;#SQLITE_DBSTATUS%20options&quot;&gt;SQLITE_DBSTATUS 옵션&lt;/a&gt; 세트는 향후 SQLite 릴리스에서 증가 할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc3302201d2b7cd437db8ee6aa036bac03658d0" translate="yes" xml:space="preserve">
          <source>This interface is used to retrieve runtime status information about a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument is the database connection object to be interrogated. The second argument is an integer constant, taken from the set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt;, that determines the parameter to interrogate. The set of &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS options&lt;/a&gt; is likely to grow in future releases of SQLite.</source>
          <target state="translated">이 인터페이스는 단일 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대한 런타임 상태 정보를 검색하는 데 사용됩니다 . 첫 번째 인수는 조사 할 데이터베이스 연결 개체입니다. 두 번째 인수는 &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS 옵션&lt;/a&gt; 세트에서 가져온 정수 상수로, 조사 할 매개 변수를 결정합니다. &lt;a href=&quot;c_dbstatus_options&quot;&gt;SQLITE_DBSTATUS 옵션&lt;/a&gt; 세트는 향후 SQLite 릴리스에서 증가 할 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0177c23c0459f643a4c9d13247ce19efb1a18257" translate="yes" xml:space="preserve">
          <source>This interface loads an SQLite extension library from the named file.</source>
          <target state="translated">이 인터페이스는 명명 된 파일에서 SQLite 확장 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="8179bad6a4aa6b903a52e81e492e1156f601b09e" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 플래그 의 컴파일 타임 뮤텍스 설정에 대해서만보고합니다 . SQLite가 SQLITE_THREADSAFE = 1 또는 = 2로 컴파일 된 경우 뮤텍스는 기본적으로 사용 가능하지만 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 또는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; 동사 를 사용하여 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출을 사용하여 뮤텍스를 완전히 또는 부분적으로 사용하지 않을 수 있습니다 . sqlite3_threadsafe () 함수의 반환 값은 스레드 안전의 컴파일 타임 설정 만 표시하며 sqlite3_config ()에 의해 설정된 설정에 대한 런타임 변경은 표시하지 않습니다. 즉, sqlite3_threadsafe ()의 반환 값은 sqlite3_config ()를 호출해도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f1c5432e18dc84d0ab872e79f78a9b49a5ab932" translate="yes" xml:space="preserve">
          <source>This interface only reports on the compile-time mutex setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; flag. If SQLite is compiled with SQLITE_THREADSAFE=1 or =2 then mutexes are enabled by default but can be fully or partially disabled using a call to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; with the verbs &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt;, or &lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;. The return value of the sqlite3_threadsafe() function shows only the compile-time setting of thread safety, not any run-time changes to that setting made by sqlite3_config(). In other words, the return value from sqlite3_threadsafe() is unchanged by calls to sqlite3_config().</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 플래그 의 컴파일 타임 뮤텍스 설정에 대해서만보고합니다 . SQLite가 SQLITE_THREADSAFE = 1 또는 = 2로 컴파일 된 경우 뮤텍스는 기본적으로 사용 가능하지만 &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 또는 &lt;a href=&quot;#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; 동사 를 사용하여 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출을 사용하여 뮤텍스를 완전히 또는 부분적으로 사용하지 않을 수 있습니다 . sqlite3_threadsafe () 함수의 반환 값은 스레드 안전의 컴파일 타임 설정 만 표시하며 sqlite3_config ()에 의해 설정된 설정에 대한 런타임 변경은 표시하지 않습니다. 즉, sqlite3_threadsafe ()의 반환 값은 sqlite3_config ()를 호출해도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e88b1695c7d666ba2e7d53c0b55a6d5efcc55d7" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 가 직렬화 될 때 인수에 제공된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 액세스를 직렬화 하는 &lt;a href=&quot;#sqlite3_mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 오브젝트에 대한 포인터를 리턴합니다 . 는 IF &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드는&lt;/a&gt; 단일 스레드 또는 다중 스레드 다음이 루틴은 NULL 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1fc22f71a3cec256b724ef1c90f879b1fc5cc86" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer the &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object that serializes access to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; given in the argument when the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Serialized. If the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is Single-thread or Multi-thread then this routine returns a NULL pointer.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 가 직렬화 될 때 인수에 제공된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 액세스를 직렬화 하는 &lt;a href=&quot;mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 오브젝트에 대한 포인터를 리턴합니다 . 는 IF &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드는&lt;/a&gt; 단일 스레드 또는 다중 스레드 다음이 루틴은 NULL 포인터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="293e65533b2e0bf802333580611e0758a28818fb" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; pDb 와 연관된 pStmt 다음에 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된&lt;/a&gt; 다음 명령문에 대한 포인터를 리턴합니다 . pStmt가 NULL이면이 인터페이스는 데이터베이스 연결 pDb와 연관된 첫 번째 준비된 명령문에 대한 포인터를 리턴합니다. 준비된 명령문이이 루틴의 조건을 만족하지 않으면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="298da08b2fcbf608e155bad7e295f53eb1526e44" translate="yes" xml:space="preserve">
          <source>This interface returns a pointer to the next &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; after pStmt associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; pDb. If pStmt is NULL then this interface returns a pointer to the first prepared statement associated with the database connection pDb. If no prepared statement satisfies the conditions of this routine, it returns NULL.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; pDb 와 연관된 pStmt 다음에 &lt;a href=&quot;stmt&quot;&gt;준비된&lt;/a&gt; 다음 명령문에 대한 포인터를 리턴합니다 . pStmt가 NULL이면이 인터페이스는 데이터베이스 연결 pDb와 연관된 첫 번째 준비된 명령문에 대한 포인터를 리턴합니다. 준비된 명령문이이 루틴의 조건을 만족하지 않으면 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e0779d667db00a554725939028269aca490f34bf" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;../lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">이 인터페이스는 pStmt의 예측 및 측정 성능에 대한 정보를 리턴합니다. 고급 애플리케이션은이 인터페이스를 사용하여 예측 된 성능과 측정 된 성능을 비교하고 경고를 발행하거나 불일치가 발견 된 경우 &lt;a href=&quot;../lang_analyze&quot;&gt;분석을&lt;/a&gt; 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85a4493d9adb4944292a15518241fee7e748e502" translate="yes" xml:space="preserve">
          <source>This interface returns information about the predicted and measured performance for pStmt. Advanced applications can use this interface to compare the predicted and the measured performance and issue warnings and/or rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; if discrepancies are found.</source>
          <target state="translated">이 인터페이스는 pStmt의 예측 및 측정 성능에 대한 정보를 리턴합니다. 고급 애플리케이션은이 인터페이스를 사용하여 예측 된 성능과 측정 된 성능을 비교하고 경고를 발행하거나 불일치가 발견 된 경우 &lt;a href=&quot;lang_analyze&quot;&gt;분석을&lt;/a&gt; 다시 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb0500a44659bfdd838f99dddff5b2745a24fd7" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 검사 점이 발생하는 유일한 방법이었습니다. 그러나 새롭고 강력한 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스가 추가되었습니다. 이 인터페이스는 이전 버전과의 호환성을 위해 유지되며 콜백을 수동으로 시작해야하지만 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 의 전체 전력 (및 해당 합병증)이 필요하지 않은 응용 프로그램의 편의를 위해 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f8650a908576cbf78aafa5f2c01220a648b07e6e" translate="yes" xml:space="preserve">
          <source>This interface used to be the only way to cause a checkpoint to occur. But then the newer and more powerful &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface was added. This interface is retained for backwards compatibility and as a convenience for applications that need to manually start a callback but which do not need the full power (and corresponding complication) of &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 검사 점이 발생하는 유일한 방법이었습니다. 그러나 새롭고 강력한 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스가 추가되었습니다. 이 인터페이스는 이전 버전과의 호환성을 위해 유지되며 콜백을 수동으로 시작해야하지만 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 의 전체 전력 (및 해당 합병증)이 필요하지 않은 응용 프로그램의 편의를 위해 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f7d4c03d6a4b6a9f5c9aedcc9b701719388f47dd" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;#sqlite3_blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">이 인터페이스 는 데이터베이스 zDb의 iRow 행, zColumn 열, zTable 테이블에있는 BLOB에 대한 &lt;a href=&quot;#sqlite3_blob&quot;&gt;핸들&lt;/a&gt; 을 엽니 다 . 즉, 다음과 같은 방법으로 선택되는 동일한 BLOB입니다.</target>
        </trans-unit>
        <trans-unit id="d56bad6a2645b8e7253284f59e7a63eae875fa74" translate="yes" xml:space="preserve">
          <source>This interfaces opens a &lt;a href=&quot;blob&quot;&gt;handle&lt;/a&gt; to the BLOB located in row iRow, column zColumn, table zTable in database zDb; in other words, the same BLOB that would be selected by:</source>
          <target state="translated">이 인터페이스 는 데이터베이스 zDb의 iRow 행, zColumn 열, zTable 테이블에있는 BLOB에 대한 &lt;a href=&quot;blob&quot;&gt;핸들&lt;/a&gt; 을 엽니 다 . 즉, 다음과 같은 방법으로 선택되는 동일한 BLOB입니다.</target>
        </trans-unit>
        <trans-unit id="13a6b9699070bd3ee5f0499a2e1cddf56e4de906" translate="yes" xml:space="preserve">
          <source>This is a convenience method. It saves the user from having to do a &quot;&lt;code&gt;[lindex ... 0]&lt;/code&gt;&quot; on the results of an &quot;eval&quot; in order to extract a single column result.</source>
          <target state="translated">이것은 편리한 방법입니다. 단일 열 결과를 추출하기 위해 &quot;eval&quot;결과에 대해 &quot; &lt;code&gt;[lindex ... 0]&lt;/code&gt; &quot; 을 수행하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="38e166d44e718495aa683d7ad0a1c631f4c6b59a" translate="yes" xml:space="preserve">
          <source>This is a deferred seek. Nothing actually happens until the cursor is used to read a record. That way, if no reads occur, no unnecessary I/O happens.</source>
          <target state="translated">이것은 지연된 탐색입니다. 커서를 사용하여 레코드를 읽을 때까지 실제로 아무 일도 일어나지 않습니다. 이렇게하면 읽기가 발생하지 않으면 불필요한 I / O가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2382322bd7fe40fc2a51108a576a294144a75f00" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">이것은 &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 의 더 이상 사용되지 않는 버전입니다 . 이 루틴은 기록 호환성을 위해서만 제공됩니다. 모든 새로운 애플리케이션은 이 인터페이스가 아닌 &lt;a href=&quot;#sqlite3_hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a3322a19f5183f0c0a12dac751f8fe80d74d2317" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">이것은 &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 의 더 이상 사용되지 않는 버전입니다 . 이 루틴은 이전 버전과의 호환성을 위해서만 제공됩니다. 모든 새로운 응용 프로그램은 이 인터페이스 대신 &lt;a href=&quot;#sqlite3_soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="549ad021f1f25c6ff9bbe6ad516bdc1aab2d979c" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">이것은 &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 의 더 이상 사용되지 않는 버전입니다 . 이 루틴은 기록 호환성을 위해서만 제공됩니다. 모든 새로운 애플리케이션은 이 인터페이스가 아닌 &lt;a href=&quot;hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="83b5b2c4751d7d27636c7987b515f0e77b9f539e" translate="yes" xml:space="preserve">
          <source>This is a deprecated version of the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface. This routine is provided for historical compatibility only. All new applications should use the &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface rather than this one.</source>
          <target state="translated">이것은 &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스 의 더 이상 사용되지 않는 버전입니다 . 이 루틴은 이전 버전과의 호환성을 위해서만 제공됩니다. 모든 새로운 응용 프로그램은 이 인터페이스 대신 &lt;a href=&quot;soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3265de0d01aec05a2acca7ad5cf1ffeadb61ea03" translate="yes" xml:space="preserve">
          <source>This is a feature, not a bug. SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. It does not enforce data type constraints. Data of any type can (usually) be inserted into any column. You can put arbitrary length strings into integer columns, floating point numbers in boolean columns, or dates in character columns. The &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; you assign to a column in the CREATE TABLE command does not restrict what data can be put into that column. Every column is able to hold an arbitrary length string. (There is one exception: Columns of type &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; may only hold a 64-bit signed integer. An error will result if you try to put anything other than an integer into an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column.)</source>
          <target state="translated">이것은 버그가 아닌 기능입니다. SQLite는 &lt;a href=&quot;datatype3&quot;&gt;동적 타이핑을&lt;/a&gt; 사용합니다 . 데이터 형식 제약 조건을 적용하지 않습니다. 모든 유형의 데이터는 (보통) 모든 열에 삽입 될 수 있습니다. 임의의 길이의 문자열을 정수 열, 부울 열의 부동 소수점 숫자 또는 문자 열의 날짜에 넣을 수 있습니다. CREATE TABLE 명령에서 열에 할당 한 &lt;a href=&quot;datatype3&quot;&gt;데이터 유형&lt;/a&gt; 은 해당 열에 넣을 수있는 데이터를 제한하지 않습니다. 모든 열은 임의의 길이 문자열을 보유 할 수 있습니다. (한 가지 예외가 있습니다. &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 유형의 열은 64 비트 부호있는 정수만 보유 할 수 있습니다. 정수 이외의 다른 것을 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열에 넣으려고하면 오류가 발생합니다 .)</target>
        </trans-unit>
        <trans-unit id="5c1fa1ef2dde20cd88e16281d01dfa503bb7906f" translate="yes" xml:space="preserve">
          <source>This is a function with powerful side-effects. Most programmers would be naturally cautious about using it, but probably would not see the harm in merely having it available. But there is great risk in merely defining such a function, even if the application itself never invokes it!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7d02094df3f3fda475c3c0669d010669d55439e" translate="yes" xml:space="preserve">
          <source>This is a legacy interface that is preserved for backwards compatibility. Use of this interface is not recommended.</source>
          <target state="translated">이전 버전과의 호환성을 위해 유지되는 레거시 인터페이스입니다. 이 인터페이스는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5f257f6218e523212322ebfdf81d8c0135554419" translate="yes" xml:space="preserve">
          <source>This is a limitation of the R-Tree extension only. Ordinary tables in SQLite are able to read and write at the same time. Other virtual tables might (or might not) also that capability. And R-Tree can appear to read and write at the same time in some circumstances, if it can figure out how to reliably run the query to completion before starting the update. But you shouldn't count on that for every query. Generally speaking, it is best to avoid running queries and updates to the same R-Tree at the same time.</source>
          <target state="translated">이것은 R-Tree 확장의 제한 사항입니다. SQLite의 일반 테이블은 동시에 읽고 쓸 수 있습니다. 다른 가상 테이블도 해당 기능을 사용할 수 있습니다. 그리고 R-Tree는 업데이트를 시작하기 전에 쿼리를 안정적으로 실행하여 완료하는 방법을 파악할 수있는 경우 일부 상황에서 동시에 읽고 쓰는 것처럼 보일 수 있습니다. 그러나 모든 쿼리에 대해이를 신뢰해서는 안됩니다. 일반적으로 동일한 R-Tree에 대한 쿼리와 업데이트를 동시에 실행하지 않는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5d61b35431e03f12c702f21bbd7e7a511e4a6548" translate="yes" xml:space="preserve">
          <source>This is a maintenance release only. Various minor bugs have been fixed and some portability enhancements are added.</source>
          <target state="translated">이것은 유지 관리 릴리스입니다. 다양한 사소한 버그가 수정되었으며 일부 이식성 향상이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="899c3e8633e96cd6aefa72bc202abc232fd0022d" translate="yes" xml:space="preserve">
          <source>This is an edit distance or Levenshtein distance going from the pattern to the word.</source>
          <target state="translated">패턴에서 단어로 이동하는 편집 거리 또는 Levenshtein 거리입니다.</target>
        </trans-unit>
        <trans-unit id="910e8aa32c8839104ce5280b502b0fcc013f6738" translate="yes" xml:space="preserve">
          <source>This is an optimized version of &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; that works only for integer values.</source>
          <target state="translated">이것은 정수 값에 대해서만 작동 하는 최적화 된 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="801748b6bec70348d36bd30ab9aa7d8d99ebf0cc" translate="yes" xml:space="preserve">
          <source>This is done by using the file locking facilities provided by the VFS adaptor to serialize writers (write transactions) and preventing readers (read transactions) from accessing database files while writers are midway through updating them.</source>
          <target state="translated">이는 VFS 어댑터가 제공하는 파일 잠금 기능을 사용하여 기록기를 직렬화 (쓰기 트랜잭션)하고 기록기 (데이터를 읽는 중)가 읽는 동안 판독기 (읽기 트랜잭션)가 데이터베이스 파일에 액세스하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="8da36cedfb4232a176b408433fde7c4fd7207c97" translate="yes" xml:space="preserve">
          <source>This is not a trivial point. A clear, concise, and easy to understand file format is a crucial part of any application design. Fred Brooks, in his all-time best-selling computer science text,</source>
          <target state="translated">이것은 사소한 점이 아닙니다. 명확하고 간결하며 이해하기 쉬운 파일 형식은 모든 응용 프로그램 디자인의 중요한 부분입니다. 프레드 브룩스 (Fred Brooks)는 그의 베스트셀러 컴퓨터 과학 텍스트에서</target>
        </trans-unit>
        <trans-unit id="1c13d43de084b1c54ea28d7db810dbdc504863cc" translate="yes" xml:space="preserve">
          <source>This is not to say that CVEs are useless. CVEs do still (mostly) report actual bugs. But in most cases the bugs are not true vulnerabilities, in the sense that they do not contribute to data loss or compromise in and of themselves. It is good that bugs are reported and fixed. But not every bug is accessible from every application. In the case of SQLite, most of the bugs reported by CVEs are inaccessible in most applications. Upgrading to the latest version of SQLite is always a good plan, but it need not be an emergency just because an anonymous grey-hat on the internet wrote up a CVE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71f131e03503ae5c8b8ced0f182cb10a7090642b" translate="yes" xml:space="preserve">
          <source>This is not valid SQL because of the apostrophe in the word &quot;y'all&quot;. But if the %q formatting option is used instead of %s, like this:</source>
          <target state="translated">&quot;y'all&quot;이라는 단어의 아포스트로피로 인해 유효한 SQL이 아닙니다. 그러나 % s 대신 % q 형식 지정 옵션을 사용하는 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b10e12e9a12481ea13f1cbdd991de65338cc882f" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-1&quot; flag. For %g and %G substitutions, this causes trailing zeros to be removed. This flag forces a decimal point to appear for all floating-point substitutions. For %o, %x, and %X substitutions, the alternate-form-1 flag cause the value to be prepended with &quot;0&quot;, &quot;0x&quot;, or &quot;0X&quot;, respectively.</source>
          <target state="translated">&quot;alternate-form-1&quot;플래그입니다. % g 및 % G 대체의 경우 후행 0이 제거됩니다. 이 플래그는 모든 부동 소수점 대체에 소수점을 강제로 표시합니다. % o, % x 및 % X 대체의 경우 alternate-form-1 플래그는 값 앞에 각각 &quot;0&quot;, &quot;0x&quot;또는 &quot;0X&quot;를 붙입니다.</target>
        </trans-unit>
        <trans-unit id="63cb4b6d9fe02ab2deb206f8aa9f5671d078c8f3" translate="yes" xml:space="preserve">
          <source>This is the &quot;alternate-form-2 flag. For string substitutions, this flag causes the width and precision to be understand in terms of characters rather than bytes. For floating point substitutions, the alternate-form-2 flag increases the maximum number of significant digits displayed from 16 to 26, forces the display of the decimal point and causes at least one digit to appear after the decimal point.</source>
          <target state="translated">이것은 &quot;alternate-form-2 플래그입니다. 문자열 대체의 경우이 플래그는 너비가 아니라 문자의 관점에서 너비와 정밀도를 이해합니다. 부동 소수점 대체의 경우 alternate-form-2 플래그는 최대 수를 증가시킵니다. 16에서 26 사이의 유효 숫자는 소수점을 강제로 표시하고 소수점 다음에 하나 이상의 숫자가 표시되도록합니다.</target>
        </trans-unit>
        <trans-unit id="bc902c483a7876a1b0deb3582a89dafeb4cea481" translate="yes" xml:space="preserve">
          <source>This is the Quality Management Plan for SQLite.</source>
          <target state="translated">SQLite에 대한 품질 관리 계획입니다.</target>
        </trans-unit>
        <trans-unit id="67d77b8b0173c35f0fc8ffa751afcfc454c71889" translate="yes" xml:space="preserve">
          <source>This is the approximate number of bytes of heap memory used to store the prepared statement. This value is not actually a counter, and so the resetFlg parameter to sqlite3_stmt_status() is ignored when the opcode is SQLITE_STMTSTATUS_MEMUSED.</source>
          <target state="translated">준비된 명령문을 저장하는 데 사용되는 대략적인 힙 메모리 바이트 수입니다. 이 값은 실제로 카운터가 아니므로 opcode가 SQLITE_STMTSTATUS_MEMUSED이면 sqlite3_stmt_status ()에 대한 resetFlg 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f605b9bb40dfe0763a4e4919a2589f9005f3a1" translate="yes" xml:space="preserve">
          <source>This is the language-id of the word. All queries are against a single language-id, which defaults to 0. For any given query this value is the same on all rows.</source>
          <target state="translated">이것은 단어의 언어 ID입니다. 모든 쿼리는 단일 language-id에 대해 있으며 기본값은 0입니다. 주어진 쿼리에 대해이 값은 모든 행에서 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9fdc70ab1d09ee31e6a0831adfe5fa272a3194e2" translate="yes" xml:space="preserve">
          <source>This is the number of rows inserted into transient indices that were created automatically in order to help joins run faster. A non-zero value in this counter may indicate an opportunity to improvement performance by adding permanent indices that do not need to be reinitialized each time the statement is run.</source>
          <target state="translated">조인 실행 속도를 높이기 위해 자동으로 생성 된 임시 인덱스에 삽입 된 행 수입니다. 이 카운터에서 0이 아닌 값은 명령문을 실행할 때마다 다시 초기화 할 필요가없는 영구 색인을 추가하여 성능을 향상시킬 수있는 기회를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5491db23237dd3c1b297335729c93feb9329fe" translate="yes" xml:space="preserve">
          <source>This is the number of sort operations that have occurred. A non-zero value in this counter may indicate an opportunity to improvement performance through careful use of indices.</source>
          <target state="translated">발생한 정렬 작업 수입니다. 이 카운터에서 0이 아닌 값은 신중하게 인덱스를 사용하여 성능을 향상시킬 수있는 기회를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6022b63855545d987e1fb6ed3574f3dde788d4f" translate="yes" xml:space="preserve">
          <source>This is the number of times that SQLite has stepped forward in a table as part of a full table scan. Large numbers for this counter may indicate opportunities for performance improvement through careful use of indices.</source>
          <target state="translated">이것은 전체 테이블 스캔의 일부로 SQLite가 테이블에서 단계적으로 증가한 횟수입니다. 이 카운터의 숫자가 많으면 인덱스를 신중하게 사용하여 성능을 향상시킬 수있는 기회를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2d5cd35f18306585fb3833a8437cb1c68463de" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">이는 쿼리 계획에 영향을 줄 수있는 스키마 변경 또는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;바인드 매개 변수&lt;/a&gt; 변경으로 인해 준비 명령문이 자동으로 재생성 된 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="89a19ef4023707e912e6bb81167cc9edbf3dbf2a" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or change to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">이는 쿼리 계획에 영향을 줄 수있는 스키마 변경 또는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인드 매개 변수&lt;/a&gt; 변경으로 인해 준비 명령문이 자동으로 재생성 된 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="ad8da654215d27127f1f2f4f4e254bee11f6c200" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">쿼리 계획에 영향을 줄 수있는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;바인드 된 매개 변수의&lt;/a&gt; 변경 또는 스키마 변경으로 인해 prepare 문이 자동으로 다시 생성 된 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="b13313031c39949951f19dcc69954d4d1da9fef4" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepare statement has been automatically regenerated due to schema changes or changes to &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; that might affect the query plan.</source>
          <target state="translated">쿼리 계획에 영향을 줄 수있는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인드 된 매개 변수의&lt;/a&gt; 변경 또는 스키마 변경으로 인해 prepare 문이 자동으로 다시 생성 된 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="1fb615d618780dfbede44490d9c1ccf7fc81bcec" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">준비된 명령문이 실행 된 횟수입니다. 이 카운터의 목적을 위해 하나의 &quot;실행&quot;은 하나 이상의 전화입니다 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 를 호출 다음에 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . 카운터는 각 사이클 의 첫 번째 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="02a22b1b5a6d045d2732a9c5f17c43be586d3ec0" translate="yes" xml:space="preserve">
          <source>This is the number of times that the prepared statement has been run. A single &quot;run&quot; for the purposes of this counter is one or more calls to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; followed by a call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. The counter is incremented on the first &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each cycle.</source>
          <target state="translated">준비된 명령문이 실행 된 횟수입니다. 이 카운터의 목적을 위해 하나의 &quot;실행&quot;은 하나 이상의 전화입니다 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 를 호출 다음에 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . 카운터는 각 사이클 의 첫 번째 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="dac86b21d034a44083d19f0648edfd3d6aee1a04" translate="yes" xml:space="preserve">
          <source>This is the number of virtual machine operations executed by the prepared statement if that number is less than or equal to 2147483647. The number of virtual machine operations can be used as a proxy for the total work done by the prepared statement. If the number of virtual machine operations exceeds 2147483647 then the value returned by this statement status code is undefined.</source>
          <target state="translated">준비된 명령문이 2147483647 이하인 경우 준비된 명령문에 의해 실행되는 가상 머신 조작의 수입니다. 가상 머신 조작의 수는 준비된 명령문이 수행 한 전체 작업의 프록시로 사용될 수 있습니다. 가상 머신 조작 수가 2147483647을 초과하면이 명령문 상태 코드가 리턴 한 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd780664af2f5e88c09d027911d10ff2fa28ed11" translate="yes" xml:space="preserve">
          <source>This is the query that solves the puzzle:</source>
          <target state="translated">이것은 퍼즐을 해결하는 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="68e28408e53f654e22a7d4b5e13087b011ad015a" translate="yes" xml:space="preserve">
          <source>This is the rank of the word, as specified in the original INSERT statement.</source>
          <target state="translated">이것은 원래 INSERT 문에 지정된 단어의 순위입니다.</target>
        </trans-unit>
        <trans-unit id="3c347af279705ccb7203ae88698186539d78c1bc" translate="yes" xml:space="preserve">
          <source>This is the same as &quot;&amp;lt;expr&amp;gt; PRECEDING&quot; except that the boundary is &amp;lt;expr&amp;gt; units after the current rather than before the current row.</source>
          <target state="translated">이것은 현재 행 이전이 아니라 현재 행 이후의 경계가 &amp;lt;expr&amp;gt; 단위라는 점을 제외하고 &quot;&amp;lt;expr&amp;gt; PRECEDING&quot;과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b5b506e660f5afa226074ab8a993cee25ea85c25" translate="yes" xml:space="preserve">
          <source>This key is then limited to &quot;scope&quot; characters. The default scope value is 4, but an alternative scope can be specified using the &quot;scope=N&quot; term in the WHERE clause. After the key has been truncated, the edit distance is run against every term in the vocabulary that has a k2 value that begins with the abbreviated key.</source>
          <target state="translated">그런 다음이 키는 &quot;범위&quot;문자로 제한됩니다. 기본 범위 값은 4이지만 WHERE 절에서 &quot;scope = N&quot;용어를 사용하여 대체 범위를 지정할 수 있습니다. 키가 잘린 후에는 약어 키로 시작하는 k2 값을 가진 어휘의 모든 항에 대해 편집 거리가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="09f3f2089114bd06180ad8313e37ae120cabb71b" translate="yes" xml:space="preserve">
          <source>This kind of problem comes up all the time when dealing with floating point binary numbers. The general rule to remember is that most fractional numbers that have a finite representation in decimal (a.k.a &quot;base-10&quot;) do not have a finite representation in binary (a.k.a &quot;base-2&quot;). And so they are approximated using the closest binary number available. That approximation is usually very close, but it will be slightly off and in some cases can cause your results to be a little different from what you might expect.</source>
          <target state="translated">부동 소수점 이진수를 처리 할 때 이런 종류의 문제가 항상 발생합니다. 기억해야 할 일반적인 규칙은 10 진수로 유한 표현 (일명 &quot;base-10&quot;)을 갖는 대부분의 분수는 이진수 (일명 &quot;base-2&quot;)로 유한 표현을하지 않는다는 것입니다. 따라서 가장 가까운 이진수를 사용하여 근사값을 구합니다. 이 근사값은 일반적으로 매우 가깝지만 약간 어긋날 수 있으며 경우에 따라 결과가 예상과 약간 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a135a2763d0f0112ca15bcc48e7dbab83e04271e" translate="yes" xml:space="preserve">
          <source>This last code will give the following output:</source>
          <target state="translated">이 마지막 코드는 다음과 같은 출력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47d19850010695a0ad5164e9f6289137fa74e392" translate="yes" xml:space="preserve">
          <source>This later query generates exactly the same &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; as the previous scalar formulation, but using syntax that it cleaner and easier to read.</source>
          <target state="translated">이 쿼리 는 이전 스칼라 공식과 정확히 동일한 &lt;a href=&quot;opcode&quot;&gt;바이트 코드&lt;/a&gt; 를 생성 하지만 구문이 명확하고 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="ee338f99e5b2a8dc89eb5fd7e38f440a68b4f663" translate="yes" xml:space="preserve">
          <source>This limit is only functional if memory usage statistics are available via the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt;) interfaces. Without that memory usage information, SQLite has no way of knowing when it is about to go over the limit, and thus is unable to prevent the excess memory allocation. Memory usage tracking is turned on by default, but can be disabled at compile-time using the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; option, or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;).</source>
          <target state="translated">이 한계는 메모리 사용 통계가 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusmemoryused&quot;&gt;SQLITE_STATUS_MEMORY_USED&lt;/a&gt; ) 인터페이스 를 통해 사용 가능한 경우에만 작동합니다 . 메모리 사용량 정보가 없으면 SQLite는 언제 한계를 넘을 것인지 알 수 없으므로 과도한 메모리 할당을 막을 수 없습니다. 메모리 사용량 추적은 기본적으로 켜져 있지만 &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; 옵션을 사용하여 컴파일시 또는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; )를 사용하여 시작 시 사용하지 않도록 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13ca9d3dd4559d964cbe8a24d9fb9dfdfb2e704d" translate="yes" xml:space="preserve">
          <source>This loop does the actual deleting. It is organized differently from the one in the UPDATE example. The ListRead instruction plays the role that the Next did in the INSERT loop, but because it jumps to P2 on failure, and Next jumps on success, we put it at the start of the loop instead of the end. This means that we have to put a Goto at the end of the loop to jump back to the loop test at the beginning. So this loop has the form of a C while(){...} loop, while the loop in the INSERT example had the form of a do{...}while() loop. The Delete instruction fills the role that the callback function did in the preceding examples.</source>
          <target state="translated">이 루프는 실제 삭제를 수행합니다. UPDATE 예제와는 다르게 구성됩니다. ListRead 명령어는 INSERT 루프에서 Next가했던 역할을 수행하지만, 실패시 P2로 점프하고 Next가 성공하면 점프 대신 루프의 시작 부분에 배치합니다. 이것은 루프의 시작 부분에 Goto를 넣어서 루프 테스트로 돌아 가야한다는 것을 의미합니다. 따라서이 루프는 C while () {...} 루프의 형식을 가지지 만 INSERT 예제의 루프는 do {...} while () 루프의 형식을가집니다. Delete 명령어는 이전 예제에서 콜백 함수의 역할을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="43be1340da3a9e761d1e60e5b0cf2fe23b219f5a" translate="yes" xml:space="preserve">
          <source>This macro determines if SQLite creates databases with the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; flag set by default to OFF (0), FULL (1), or INCREMENTAL (2). The default value is 0 meaning that databases are created with auto-vacuum turned off. In any case the compile-time default may be overridden by the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; command.</source>
          <target state="translated">이 매크로는 SQLite가 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 플래그를 기본적으로 OFF (0), FULL (1) 또는 INCREMENTAL (2)로 설정하여 데이터베이스를 작성하는지 판별합니다 . 기본값은 0입니다. 즉, 자동 진공을 끈 상태에서 데이터베이스가 작성됩니다. 어쨌든 컴파일 타임 기본값은 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;PRAGMA auto_vacuum&lt;/a&gt; 명령 으로 무시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce1cd413cb1e6bc64251da855027734d62907557" translate="yes" xml:space="preserve">
          <source>This macro determines the default value for the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; setting. If no alternative is specified, the trusted-schema setting defaults to ON (a value of 1) for legacy compatibility. However, for best security, systems that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and/or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; should consider changing the default to OFF.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; 설정 의 기본값을 결정합니다 . 대안이 지정되지 않은 경우, 트러스트 된 스키마 설정은 레거시 호환성을 위해 기본적으로 ON (값 1)으로 설정됩니다. 그러나 최상의 보안을 위해 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 / 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 구현하는 시스템 은 기본값을 OFF로 변경하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="490e529c008d3db9d5367e44a026855e51e6b03f" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting for database files that open in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. If not overridden at compile-time, this value is the same as &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt;.</source>
          <target state="translated">이 매크로 는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 열리는 데이터베이스 파일에 대한 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 설정 의 기본값을 결정 합니다 . 컴파일시 재정의되지 않은 경우이 값은 &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8336b743e8d9803a85ebb0e91376530edf711cf6" translate="yes" xml:space="preserve">
          <source>This macro determines the default value of the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; setting. If not overridden at compile-time, the default setting is 2 (FULL).</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 설정 의 기본값을 결정합니다 . 컴파일 타임에 재정의되지 않은 경우 기본 설정은 2 (FULL)입니다.</target>
        </trans-unit>
        <trans-unit id="f58f286fe549400b3ffb2a0508013420e777661c" translate="yes" xml:space="preserve">
          <source>This macro determines the default values for &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt;, which in turn how SQLite handles each &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt;. The &quot;DQS&quot; name stands for &quot;&lt;u&gt;D&lt;/u&gt;ouble-&lt;u&gt;Q&lt;/u&gt;uoted &lt;u&gt;S&lt;/u&gt;tring&quot;. The</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; 의 기본값을 결정하며 , 이는 SQLite가 각 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴을&lt;/a&gt; 처리하는 방법 입니다. 은 &quot;DQS&quot;이름 &quot;의 약자 &lt;u&gt;D&lt;/u&gt; ouble- &lt;u&gt;Q는&lt;/u&gt; uoted &lt;u&gt;S가&lt;/u&gt; 트링&quot;. 그만큼</target>
        </trans-unit>
        <trans-unit id="522e09ca43264c4a7b51fc0648da718f31a48474" translate="yes" xml:space="preserve">
          <source>This macro determines the initial setting for &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt; for newly opened &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. For all versions of SQLite through 3.7.17, automatic indices are normally enabled for new database connections if this compile-time option is omitted. However, that might change in future releases of SQLite.</source>
          <target state="translated">이 매크로 는 새로 열린 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 &lt;a href=&quot;pragma#pragma_automatic_index&quot;&gt;PRAGMA automatic_index&lt;/a&gt; 의 초기 설정을 결정합니다 . 모든 컴파일 버전의 SQLite 3.7.17에서이 컴파일 타임 옵션이 생략되면 일반적으로 새 데이터베이스 연결에 자동 인덱스가 사용됩니다. 그러나 이후 릴리스의 SQLite에서는 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fa0389d41296c7a84b787e330c502e72d66ebe7" translate="yes" xml:space="preserve">
          <source>This macro determines the number of pages initially allocated by the page cache module when &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; configuration option is not use and memory for the page cache is obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; instead. The number of pages set by this macro are allocated in a single allocation, which reduces the load on the memory allocator.</source>
          <target state="translated">이 매크로 는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 구성 옵션을 사용하지 않고 대신 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 페이지 캐시 메모리를 확보 할 때 페이지 캐시 모듈에 의해 처음 할당 된 페이지 수를 결정합니다 . 이 매크로가 설정 한 페이지 수는 단일 할당으로 할당되므로 메모리 할당 기의로드가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="559bc66ac71c6e41021ef2b91f75b46c2b3b9325" translate="yes" xml:space="preserve">
          <source>This macro determines whether enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is enabled or disabled by default for new database connections. Each database connection can always turn enforcement of foreign key constraints on and off and run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt;. Enforcement of foreign key constraints is normally off by default, but if this compile-time parameter is set to 1, enforcement of foreign key constraints will be on by default.</source>
          <target state="translated">이 매크로 는 새 데이터베이스 연결에 기본적 으로 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 적용을 활성화할지 비활성화 할지 결정합니다 . 각 데이터베이스 연결은 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma를&lt;/a&gt; 사용하여 외래 키 제약 조건의 시행을 항상 켜고 끌 수 있습니다 . 외래 키 제약 조건의 적용은 일반적으로 기본적으로 해제되어 있지만이 컴파일 타임 매개 변수가 1로 설정되어 있으면 외래 키 제약 조건의 적용이 기본적으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="226608496184b7fdf2d8299d14ed30387d3f4541" translate="yes" xml:space="preserve">
          <source>This macro identifies an externally visible interface for SQLite. This macro is sometimes set to &quot;extern&quot;. But the definition is compiler-specific.</source>
          <target state="translated">이 매크로는 SQLite에 대해 외부 적으로 보이는 인터페이스를 식별합니다. 이 매크로는 때때로 &quot;extern&quot;으로 설정됩니다. 그러나 정의는 컴파일러마다 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0de6453c343098370301ec003932dc6266aca99a" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by operating system interfaces for target the platform for an SQLite build. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__stdcall&quot;.</source>
          <target state="translated">이 매크로는 운영 체제 인터페이스에서 SQLite 빌드를위한 플랫폼을 대상으로하는 호출 규칙을 식별합니다. 이 매크로는 일반적으로 아무것도 아닌 것으로 정의되지만 Windows 빌드에서는 &quot;__stdcall&quot;로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b44c726a2553acb75e5ed795a28d472290ceb29" translate="yes" xml:space="preserve">
          <source>This macro identifies the calling convention used by public interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">이 매크로는 SQLite의 공용 인터페이스 루틴이 사용하는 호출 규칙을 식별합니다. 이 매크로는 일반적으로 아무것도 아닌 것으로 정의되지만 Windows 빌드에서는 &quot;__cdecl&quot;또는 &quot;__stdcall&quot;로 설정 될 수 있습니다. &quot;__cdecl&quot;설정이 기본값이지만 &quot;__stdcall&quot;은 SQLite가 Windows 시스템 라이브러리로 컴파일 될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b1a94429c7fe64a39ff03aac291075f1fc53f3f7" translate="yes" xml:space="preserve">
          <source>This macro is used to determine whether or not the features enabled and disabled using the SQLITE_CONFIG_MEMSTATUS argument to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; are available by default. The default value is 1 (&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; related features enabled).</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 SQLITE_CONFIG_MEMSTATUS 인수를 사용하여 사용 가능 및 사용 불가능한 기능 이 기본적으로 사용 가능한지 여부를 판별하는 데 사용됩니다 . 기본값은 1입니다 ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 관련 기능 사용).</target>
        </trans-unit>
        <trans-unit id="6f913dad07b84381374f393818e5b17603014056" translate="yes" xml:space="preserve">
          <source>This macro is used to omit support for UTF16 text encoding. When this is defined all API functions that return or accept UTF16 encoded text are unavailable. These functions can be identified by the fact that they end with '16', for example &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16()&lt;/a&gt; and &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 UTF16 텍스트 인코딩 지원을 생략하는 데 사용됩니다. 이것이 정의되면 UTF16 인코딩 텍스트를 리턴하거나 승인하는 모든 API 함수를 사용할 수 없습니다. 이러한 함수는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_text16 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text16 ()&lt;/a&gt; 과 같이 '16'으로 끝나는 사실로 식별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="345c1823c22673f2e2116c52a9629c25f967676c" translate="yes" xml:space="preserve">
          <source>This macro is used to set the default page-size used when a database is created. The value assigned must be a power of 2. The default value is 4096. The compile-time default may be overridden at runtime by the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; command.</source>
          <target state="translated">이 매크로는 데이터베이스를 만들 때 사용되는 기본 페이지 크기를 설정하는 데 사용됩니다. 할당 된 값은 2의 거듭 제곱이어야합니다. 기본값은 4096입니다. 컴파일 타임 기본값은 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; 명령으로 런타임에 재정의 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7c4d127d6e65cd3ab45a035f901ed93fb97bfdbf" translate="yes" xml:space="preserve">
          <source>This macro may not be used in combination with any of &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt;, &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt;, or &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt;.</source>
          <target state="translated">이 매크로의 임의의 조합으로 사용할 수 없다 &lt;a href=&quot;compile#apicall&quot;&gt;SQLITE_APICALL&lt;/a&gt; , &lt;a href=&quot;compile#callback&quot;&gt;SQLITE_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#cdecl&quot;&gt;SQLITE_CDECL&lt;/a&gt; 또는 &lt;a href=&quot;compile#syscall&quot;&gt;SQLITE_SYSCALL&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="419ea570d98b36b74bab8426d78c04933a0304df" translate="yes" xml:space="preserve">
          <source>This macro sets a hard upper bound on the amount of address space that can be used by any single database for memory-mapped I/O. Setting this value to 0 completely disables memory-mapped I/O and causes logic associated with memory-mapped I/O to be omitted from the build. This option does change the default memory-mapped I/O address space size (set by &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; or sqlite3_config(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE&lt;/a&gt;) or the run-time memory-mapped I/O address space size (set by sqlite3_file_control(&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt;) or &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;) as long as those other settings are less than the maximum value defined here.</source>
          <target state="translated">이 매크로는 메모리 매핑 된 I / O를 위해 단일 데이터베이스에서 사용할 수있는 주소 공간의 양에 대한 상한을 설정합니다. 이 값을 0으로 설정하면 메모리 매핑 된 I / O가 완전히 비활성화되고 메모리 매핑 된 I / O와 관련된 논리가 빌드에서 생략됩니다. 이 옵션은 기본 메모리 맵핑 I / O 주소 공간 크기 ( &lt;a href=&quot;compile#default_mmap_size&quot;&gt;SQLITE_DEFAULT_MMAP_SIZE&lt;/a&gt; 또는 sqlite3_config ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmmapsize&quot;&gt;SQLITE_CONFIG_MMAP_SIZE로 설정&lt;/a&gt; ) 또는 런타임 메모리 맵핑 I / O 주소 공간 크기 (sqlite3_file_control ( &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlmmapsize&quot;&gt;SQLITE_FCNTL_MMAP_SIZE&lt;/a&gt; ) 또는 &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; )를 변경합니다. 다른 설정이 여기에 정의 된 최대 값보다 작은 한.</target>
        </trans-unit>
        <trans-unit id="145e78ac1776ccd32943f854f10f2f9b0fb6393c" translate="yes" xml:space="preserve">
          <source>This macro sets the default limit on the amount of memory that will be used for memory-mapped I/O for each open database file. If the</source>
          <target state="translated">이 매크로는 열려있는 각 데이터베이스 파일의 메모리 매핑 된 I / O에 사용될 메모리 양의 기본 제한을 설정합니다. 만약</target>
        </trans-unit>
        <trans-unit id="6ae2df8a2127ec82caea89871c84ffb977c2588f" translate="yes" xml:space="preserve">
          <source>This macro sets the default maximum size of the page-cache for each attached database. A positive value means that the limit is N page. If N is negative that means to limit the cache size to -N*1024 bytes. The suggested maximum cache size can be overridden by the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; command. The default value is -2000, which translates into a maximum of 2048000 bytes per cache.</source>
          <target state="translated">이 매크로는 연결된 각 데이터베이스에 대한 페이지 캐시의 기본 최대 크기를 설정합니다. 양수 값은 한계가 N 페이지임을 의미합니다. N이 음수이면 캐시 크기를 -N * 1024 바이트로 제한한다는 의미입니다. &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; 명령으로 제안 된 최대 캐시 크기를 대체 할 수 있습니다 . 기본값은 -2000이며, 캐시 당 최대 2048000 바이트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="069102b338eefceeca656d056762e6d78be6422a" translate="yes" xml:space="preserve">
          <source>This macro sets the default page count for the &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;automatic checkpointing&lt;/a&gt; feature. If unspecified, the default page count is 1000.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;wal&quot;&gt;WAL &lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;자동 검사 점&lt;/a&gt; 기능 의 기본 페이지 수를 설정합니다 . 지정되지 않은 경우 기본 페이지 수는 1000입니다.</target>
        </trans-unit>
        <trans-unit id="40e8768dd2f7f8b92849cd1662a4c1ca65d4e334" translate="yes" xml:space="preserve">
          <source>This macro sets the default value for the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter. The &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; parameter sets the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will launch to assist it with a query. If not specified, the default maximum is 0. The value set here cannot be more than &lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; 매개 변수 의 기본값을 설정합니다 . &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; 한 것을 보조 스레드의 최대 수를 설정 매개 변수 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문은&lt;/a&gt; 쿼리와 함께 지원하기 위해 시작됩니다. 지정되지 않은 경우 기본 최대 값은 0입니다. 여기에 설정된 값은 &lt;a href=&quot;compile#max_worker_threads&quot;&gt;SQLITE_MAX_WORKER_THREADS&lt;/a&gt; 보다 클 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7f1a3a8e3c666c19a28c715230f239e6dc92f408" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the LALR(1) stack used by the SQL parser within SQLite. The default value is 100. A typical application will use less than about 20 levels of the stack. Developers whose applications contain SQL statements that need more than 100 LALR(1) stack entries should seriously consider refactoring their SQL as it is likely to be well beyond the ability of any human to comprehend.</source>
          <target state="translated">이 매크로는 SQLite 내에서 SQL 파서가 사용하는 LALR (1) 스택의 최대 깊이를 설정합니다. 기본값은 100입니다. 일반적인 응용 프로그램은 약 20 단계 미만의 스택을 사용합니다. 응용 프로그램에 100 개 이상의 LALR (1) 스택 항목이 필요한 SQL 문이 포함 된 개발자는 SQL을 리팩토링하는 것이 인간의 이해 능력을 훨씬 능가 할 수 있으므로 심각하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="8108e74c0ea6d892451dd561e6365c3c14ad84ce" translate="yes" xml:space="preserve">
          <source>This macro sets the maximum depth of the search tree that corresponds to the right-hand side of the MATCH operator in an &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; or &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; full-text index. The full-text search uses a recursive algorithm, so the depth of the tree is limited to prevent using too much stack space. The default limit is 12. This limit is sufficient for up to 4095 search terms on the right-hand side of the MATCH operator and it holds stack space usage to less than 2000 bytes.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 또는 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 전체 텍스트 인덱스 에서 MATCH 연산자의 오른쪽에 해당하는 검색 트리의 최대 깊이를 설정합니다 . 전체 텍스트 검색은 재귀 알고리즘을 사용하므로 너무 많은 스택 공간을 사용하지 못하도록 트리 깊이가 제한됩니다. 기본 한계는 12입니다.이 한계는 MATCH 연산자의 오른쪽에있는 최대 4095 개의 검색어에 충분하며 스택 공간 사용량을 2000 바이트 미만으로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3f15f1a968a26e30aa2768ccc2b2f950c4faa629" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by callback pointers in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot; or &quot;__stdcall&quot;. The &quot;__cdecl&quot; setting is the default, but &quot;__stdcall&quot; is used when SQLite is intended to be compiled as a Windows system library.</source>
          <target state="translated">이 매크로는 SQLite의 콜백 포인터가 사용하는 호출 규칙을 지정합니다. 이 매크로는 일반적으로 아무것도 아닌 것으로 정의되지만 Windows 빌드에서는 &quot;__cdecl&quot;또는 &quot;__stdcall&quot;으로 설정 될 수 있습니다. &quot;__cdecl&quot;설정이 기본값이지만 &quot;__stdcall&quot;은 SQLite가 Windows 시스템 라이브러리로 컴파일 될 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2528260ddde8472dd8957f56284dfe7c74c79aa8" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by the &lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; library interface routines. This macro is not used by the SQLite core, but only by the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; and &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt;. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on TCL library interface routines which are always compiled as __cdecl, even on platforms that prefer to use __stdcall, so this macro should not be set to __stdcall unless the platform as a custom TCL library build that supports __stdcall.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;http://www.tcl.tk&quot;&gt;TCL&lt;/a&gt; 라이브러리 인터페이스 루틴이 사용하는 호출 규칙을 지정합니다 . 이 매크로는 SQLite 코어가 아니라 &lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 및 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트&lt;/a&gt; 에서만 사용됩니다 . 이 매크로는 일반적으로 아무것도 아닌 것으로 정의되지만 Windows 빌드에서는 때때로 &quot;__cdecl&quot;으로 설정 될 수 있습니다. 이 매크로는 __stdcall을 선호하는 플랫폼에서도 항상 __cdecl로 컴파일되는 TCL 라이브러리 인터페이스 루틴에서 사용되므로이 매크로는 __stdcall을 지원하는 사용자 정의 TCL 라이브러리 빌드 인 경우가 아니면 __stdcall로 설정하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bc472ae5f8b8a1fc9f763f0953cf89d622ce1417" translate="yes" xml:space="preserve">
          <source>This macro specifies the calling convention used by varargs interface routines in SQLite. This macro is normally defined to be nothing, though on Windows builds it can sometimes be set to &quot;__cdecl&quot;. This macro is used on varargs routines and so cannot be set to &quot;__stdcall&quot; since the __stdcall calling convention does not support varargs functions.</source>
          <target state="translated">이 매크로는 SQLite에서 varargs 인터페이스 루틴이 사용하는 호출 규칙을 지정합니다. 이 매크로는 일반적으로 아무것도 아닌 것으로 정의되지만 Windows 빌드에서는 때때로 &quot;__cdecl&quot;으로 설정 될 수 있습니다. 이 매크로는 varargs 루틴에서 사용되므로 __stdcall 호출 규칙은 varargs 함수를 지원하지 않으므로 &quot;__stdcall&quot;로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bc36de796d91df2f3c6874f4468e8054d8e3ac3e" translate="yes" xml:space="preserve">
          <source>This major version number X was historically incremented only for large and important changes to the code. What constituted &quot;large and important&quot; was subjective. The 3.6.23 to 3.7.0 change was a result of adding support for &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. The 3.7.17 to 3.8.0 change was a result of rewrite known as the &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt;.</source>
          <target state="translated">이 주요 버전 번호 X는 코드에 대한 크고 중요한 변경에 대해서만 역사적으로 증가했습니다. &quot;크고 중요한&quot;것은 주관적이었습니다. 3.6.23에서 3.7.0으로의 변경은 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 대한 지원을 추가 한 결과입니다 . 3.7.17에서 3.8.0으로의 변경은 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 로 알려진 재 작성의 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="5cef14b3410c92f823704c7230a809d3f5116354" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. If it conflicts with a DELETE, and the conflict resolution was OMIT, then the update is changed into an INSERT. Any undefined values in the new.* record from the update change are filled in using the old.* values from the conflicting DELETE. Or, if the conflict resolution was REPLACE, the UPDATE change is simply omitted from the rebased changeset.</source>
          <target state="translated">원격 UPDATE 또는 DELETE와 충돌 할 수 있습니다. DELETE와 충돌하고 충돌 해결이 OMIT 인 경우 업데이트가 INSERT로 변경됩니다. 업데이트 변경에서 new. * 레코드의 정의되지 않은 값은 충돌하는 DELETE의 old. * 값을 사용하여 채워집니다. 또는 충돌 해결이 REPLACE 인 경우 업데이트 된 변경 내용은 리베이스 된 변경 집합에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="250cc754fd71fa455b1171906aaea6df74adc895" translate="yes" xml:space="preserve">
          <source>This may conflict with a remote UPDATE or DELETE. In both cases the only possible resolution is OMIT. If the remote operation was a DELETE, then add no change to the rebased changeset. If the remote operation was an UPDATE, then the old.* fields of change are updated to reflect the new.* values in the UPDATE.</source>
          <target state="translated">원격 UPDATE 또는 DELETE와 충돌 할 수 있습니다. 두 경우 모두 가능한 해결 방법은 OMIT입니다. 원격 작업이 DELETE 인 경우 리베이스 된 변경 집합에 변경 사항을 추가하지 마십시오. 원격 조작이 UPDATE 인 경우 old. * 변경 필드가 UPDATE의 new. * 값을 반영하도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5037a58507a3656fe5eded6e14400ea7347e50" translate="yes" xml:space="preserve">
          <source>This may only conflict with a remote INSERT. If the conflict resolution was OMIT, then add an UPDATE change to the rebased changeset. Or, if the conflict resolution was REPLACE, add nothing to the rebased changeset.</source>
          <target state="translated">이것은 원격 INSERT 와만 충돌 할 수 있습니다. 충돌 해결이 OMIT 인 경우 리베이스 된 변경 세트에 UPDATE 변경 사항을 추가하십시오. 또는 충돌 해결이 REPLACE 인 경우 리베이스 된 변경 집합에 아무것도 추가하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="e86988ffb57c2ce2d0a24b3ed45d3fc0cd35e72c" translate="yes" xml:space="preserve">
          <source>This means that SQLite transactions are not atomic across multiple database files on a power-loss when the database files have synchronous turned off or when they are using journal modes of OFF, MEMORY, or WAL. For synchronous OFF and for journal_modes OFF and MEMORY, database will usually corrupt if a transaction commit is interrupted by a power loss. For &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, individual database files are updated atomically across a power-loss, but in the case of a multi-file transactions, some files might rollback while others roll forward after power is restored.</source>
          <target state="translated">이는 데이터베이스 파일이 동기식으로 꺼 졌거나 저널 모드가 OFF, MEMORY 또는 WAL 인 경우 SQLite 트랜잭션이 여러 데이터베이스 파일에서 원자 적이 지 않음을 의미합니다. 동기 OFF 및 journal_modes OFF 및 MEMORY의 경우 일반적으로 트랜잭션 커밋이 전원 손실로 중단되면 데이터베이스가 손상됩니다. 들어 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; , 개별 데이터베이스 파일은 전력 손실을 통해 원자 적으로 갱신되지만 전원이 복원 된 후 다른 사람들이 롤 포워드 동안 다중 파일 거래의 경우, 일부 파일이 롤백 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4d263eb72d44481bc6aecfbc23e6defa0aa1498" translate="yes" xml:space="preserve">
          <source>This means that actions that occur during sqlite3_prepare() are unaffected by EXPLAIN.</source>
          <target state="translated">이는 sqlite3_prepare () 중에 발생하는 작업은 EXPLAIN의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="607b25be39beb5f9bef58cd8962c20567dd55554" translate="yes" xml:space="preserve">
          <source>This means that for many common cases where the temporary tables and indices are small (small enough to fit into the page cache) no temporary files are created and no disk I/O occurs. Only when the temporary data becomes too large to fit in RAM does the information spill to disk.</source>
          <target state="translated">즉, 임시 테이블과 인덱스가 작을 때 (페이지 캐시에 맞출 정도로 작은) 많은 경우에 임시 파일이 작성되지 않고 디스크 I / O가 발생하지 않습니다. 임시 데이터가 너무 커서 RAM에 맞지 않을 때만 정보가 디스크에 유출됩니다.</target>
        </trans-unit>
        <trans-unit id="593fad237e8d234622c2a00c4634885f5c48bfa8" translate="yes" xml:space="preserve">
          <source>This means that if the changes() SQL function (or similar) is used by the first INSERT, UPDATE or DELETE statement within a trigger, it returns the value as set when the calling statement began executing. If it is used by the second or subsequent such statement within a trigger program, the value returned reflects the number of rows modified by the previous INSERT, UPDATE or DELETE statement within the same trigger.</source>
          <target state="translated">이는 트리거 내의 첫 번째 INSERT, UPDATE 또는 DELETE 문에서 changes () SQL 함수 (또는 이와 유사한)를 사용하는 경우 호출 명령문이 실행을 시작할 때 설정된 값을 리턴합니다. 트리거 프로그램 내에서 두 번째 또는 그 이후의 명령문에 의해 사용되는 경우, 리턴되는 값은 동일한 트리거 내에서 이전 INSERT, UPDATE 또는 DELETE 문에 의해 수정 된 행 수를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="47de8d4e850286135f1da838b319021d7542c6e4" translate="yes" xml:space="preserve">
          <source>This means that in order to keep an FTS in sync with an external content table, any UPDATE or DELETE operations must be applied first to the FTS table, and then to the external content table. For example:</source>
          <target state="translated">즉, FTS를 외부 컨텐츠 테이블과 동기화 상태로 유지하려면 먼저 UPDATE 또는 DELETE 조작을 FTS 테이블에 적용한 다음 외부 컨텐츠 테이블에 적용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5987b4f32ba7f13fcab7f6d474b93f549e8b5dd" translate="yes" xml:space="preserve">
          <source>This means that you should always call sqlite3_column_bytes() or sqlite3_column_bytes16() &lt;u&gt;before&lt;/u&gt; calling sqlite3_column_blob(), sqlite3_column_text(), or sqlite3_column_text16().</source>
          <target state="translated">이는 sqlite3_column_blob (), sqlite3_column_text () 또는 sqlite3_column_text16 () &lt;u&gt;을&lt;/u&gt; 호출 &lt;u&gt;하기 전에&lt;/u&gt; 항상 sqlite3_column_bytes () 또는 sqlite3_column_bytes16 () &lt;u&gt;을&lt;/u&gt; 호출 해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="a800932549bc1585500113c923ee38830d5bf518" translate="yes" xml:space="preserve">
          <source>This means, amongst other things, that if a row is inserted and then later deleted while a session object is active, neither the insert nor the delete will be present in the changeset. Or if a row is deleted and then later a row with the same primary key values inserted while a session object is active, the resulting changeset will contain an UPDATE change instead of a DELETE and an INSERT.</source>
          <target state="translated">이는 무엇보다도 세션 개체가 활성화 된 상태에서 행을 삽입 한 다음 나중에 삭제하면 삽입 또는 삭제가 변경 집합에 존재하지 않음을 의미합니다. 또는 행이 삭제 된 후 세션 오브젝트가 활성 상태 인 동안 동일한 기본 키 값이 삽입 된 행이 있으면 결과 변경 세트에 DELETE 및 INSERT 대신 UPDATE 변경 사항이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a00a0b75d114c0d51218afdcfc54870beb085cdd" translate="yes" xml:space="preserve">
          <source>This method begins a search of a virtual table. The first argument is a cursor opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The next two arguments define a particular search index previously chosen by &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt;. The specific meanings of idxNum and idxStr are unimportant as long as xFilter and xBestIndex agree on what that meaning is.</source>
          <target state="translated">이 방법은 가상 테이블 검색을 시작합니다. 첫 번째 인수는 &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen에&lt;/a&gt; 의해 열린 커서 입니다. 다음 두 인수는 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex가&lt;/a&gt; 이전에 선택한 특정 검색 색인을 정의합니다 . xFilter 및 xBestIndex가 해당 의미에 동의하는 한 idxNum 및 idxStr의 특정 의미는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="834bb1ed541ae4dfe20c9142ebec2a570acf7ecb" translate="yes" xml:space="preserve">
          <source>This method begins a transaction on a virtual table. This is method is optional. The xBegin pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">이 방법은 가상 테이블에서 트랜잭션을 시작합니다. 이 방법은 선택 사항입니다. &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 xBegin 포인터는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a08aaa3a7033e43137865bcb5ae5a8fbc061274b" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to commit. This is method is optional. The xCommit pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">이 메소드는 가상 테이블 트랜잭션을 커미트합니다. 이 방법은 선택 사항입니다. &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 xCommit 포인터는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35812c6906eecb5f5456d27817929132fa134b1e" translate="yes" xml:space="preserve">
          <source>This method causes a virtual table transaction to rollback. This is method is optional. The xRollback pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">이 방법을 사용하면 가상 테이블 트랜잭션이 롤백됩니다. 이 방법은 선택 사항입니다. &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 xRollback 포인터는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34e410d7a2b4537f1e469f9ac830727f0e9a19a0" translate="yes" xml:space="preserve">
          <source>This method is a destructor for a connection to the virtual table. Contrast this method with &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt;. The xDestroy is a destructor for the entire virtual table.</source>
          <target state="translated">이 방법은 가상 테이블에 연결하기위한 소멸자입니다. 이 방법을 &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; 와 대조하십시오 . xDestroy는 전체 가상 테이블의 소멸자입니다.</target>
        </trans-unit>
        <trans-unit id="fead0fa710dfed08f0c2973066d106e0409882fe" translate="yes" xml:space="preserve">
          <source>This method is always followed by one call to either the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; method. Virtual table transactions do not nest, so the xBegin method will not be invoked more than once on a single virtual table without an intervening call to either &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. Multiple calls to other methods can and likely will occur in between the xBegin and the corresponding &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;.</source>
          <target state="translated">이 메소드 뒤에는 항상 &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; 메소드 를 한 번 호출합니다 . 가상 테이블 트랜잭션은 중첩되지 않으므로 &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback에&lt;/a&gt; 대한 호출없이 단일 가상 테이블에서 xBegin 메소드가 두 번 이상 호출되지 않습니다 . xBegin과 해당 &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; 사이에서 다른 메소드에 대한 여러 번의 호출이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c5d6a9d04d0fa8516ae7c5f17b40f6d4c8afec" translate="yes" xml:space="preserve">
          <source>This method is called during &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; to give the virtual table implementation an opportunity to overload functions. This method may be set to NULL in which case no overloading occurs.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 중에 호출 되어 가상 테이블 구현에 함수를 오버로드 할 수있는 기회를 제공합니다. 오버로드가 발생하지 않으면이 메소드는 NULL로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="905580614d4d5c3d75c09c6cba74a2febc0c6255" translate="yes" xml:space="preserve">
          <source>This method is only invoked after call to the &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; method and prior to an &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; or &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt;. In order to implement two-phase commit, the xSync method on all virtual tables is invoked prior to invoking the &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; method on any virtual table. If any of the xSync methods fail, the entire transaction is rolled back.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;vtab#xBegin&quot;&gt;xBegin&lt;/a&gt; 메소드 를 호출 한 후 &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xrollback&quot;&gt;xRollback&lt;/a&gt; 이전에 호출됩니다 . 2 단계 구현하기 위해 커밋, 모든 가상 테이블에 xSync 방법은 호출하기 전에 호출 &lt;a href=&quot;vtab#xcommit&quot;&gt;xCommit의&lt;/a&gt; 가상 테이블에 방법을. xSync 메소드 중 하나라도 실패하면 전체 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="14ef93018d8fba942c0db9f44fa55460f6e9c76d" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to remove a row from the current window. The function arguments, if any, correspond to the row being removed.</source>
          <target state="translated">이 방법은 레거시 집계 함수 구현이 아닌 창 집계 함수 만 필요합니다. 현재 창에서 행을 제거하기 위해 호출됩니다. 함수 인수 (있는 경우)는 제거되는 행에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ce08d539ea8ee34ede5a43f0a8a17d5ea1cf7eda" translate="yes" xml:space="preserve">
          <source>This method is only required window aggregate functions, not legacy aggregate function implementations. It is invoked to return the current value of the aggregate. Unlike xFinal, the implementation should not delete any context.</source>
          <target state="translated">이 방법은 레거시 집계 함수 구현이 아닌 창 집계 함수 만 필요합니다. 집계의 현재 값을 리턴하기 위해 호출됩니다. xFinal과 달리 구현시 컨텍스트를 삭제해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="08d8cbadac9e2ea26500ba730130d1d2ea25cffc" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to add a row to the current window. The function arguments, if any, corresponding to the row being added are passed to the implementation of xStep.</source>
          <target state="translated">이 방법은 창 집계 및 레거시 집계 함수 구현 모두에 필요합니다. 현재 창에 행을 추가하기 위해 호출됩니다. 추가되는 행에 해당하는 함수 인수는 xStep의 구현으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9dd3404779d40aa0e18784dd6025c6e495214062" translate="yes" xml:space="preserve">
          <source>This method is required by both window aggregate and legacy aggregate function implementations. It is invoked to return the current value of the aggregate (determined by the contents of the current window), and to free any resources allocated by earlier calls to xStep.</source>
          <target state="translated">이 방법은 창 집계 및 레거시 집계 함수 구현 모두에 필요합니다. 집계의 현재 값 (현재 창의 내용으로 판별 됨)을 리턴하고 xStep에 대한 이전 호출에 의해 할당 된 자원을 해제하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="7eac31ed05b29ccf070b56974e9ebd5c94362b9d" translate="yes" xml:space="preserve">
          <source>This method is used to profile the execution of SQL statements run by the application. The syntax is as follows:</source>
          <target state="translated">이 메소드는 애플리케이션이 실행하는 SQL 문의 실행을 프로파일 링하는 데 사용됩니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ee8409951c2f3bc2e8906346a5b0b0340e5f814" translate="yes" xml:space="preserve">
          <source>This method maps to the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; C / C ++ 인터페이스에 맵핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="225a540a3967cae27a759b7346927a4c3dd4b89d" translate="yes" xml:space="preserve">
          <source>This method might decide to run a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; either itself or as a subsequent idle callback. Note that SQLite only allows a single WAL hook. By default this single WAL hook is used for the auto-checkpointing. If you set up an explicit WAL hook, then that one WAL hook must ensure that checkpoints are occurring since the auto-checkpointing mechanism will be disabled.</source>
          <target state="translated">이 메소드는 자체적으로 또는 후속 유휴 콜백으로 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 을 실행하도록 결정할 수 있습니다 . SQLite는 단일 WAL 후크 만 허용합니다. 기본적으로이 단일 WAL 후크는 자동 검사 점에 사용됩니다. 명시 적 WAL 후크를 설정하면 자동 검사 점 메커니즘이 비활성화되므로 하나의 WAL 후크가 검사 점이 발생하는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="eb481b19911bf534590dc3a5ac3a0d7a4a0b626e" translate="yes" xml:space="preserve">
          <source>This method must release all resources allocated by the corresponding xOpen call. The routine will not be called again even if it returns an error. The SQLite core will not use the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; again after it has been closed.</source>
          <target state="translated">이 메소드는 해당 xOpen 호출에 의해 할당 된 모든 자원을 해제해야합니다. 루틴은 오류를 리턴하더라도 다시 호출되지 않습니다. SQLite 코어는 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor를&lt;/a&gt; 닫은 후에 다시 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="055d0207ea9526f8fc1f47ff97e4b9e575a536d0" translate="yes" xml:space="preserve">
          <source>This method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if successful, or an sqlite &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if an error occurs.</source>
          <target state="translated">이 메소드는 성공하면 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; , 오류가 발생하면 sqlite &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b41b86554f48d4aba1d771ee8d8fecba032486ca" translate="yes" xml:space="preserve">
          <source>This method only functions if SQLite is compiled with -DSQLITE_ENABLE_DESERIALIZE</source>
          <target state="translated">이 메소드는 SQLite가 -DSQLITE_ENABLE_DESERIALIZE로 컴파일 된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="aca26a9b3273f84c2f90b69b02bbfb9f22a90825" translate="yes" xml:space="preserve">
          <source>This method opens a TCL channel that can be used to read or write into a preexisting BLOB in the database. The syntax is like this:</source>
          <target state="translated">이 메소드는 데이터베이스의 기존 BLOB를 읽거나 쓰는 데 사용할 수있는 TCL 채널을 엽니 다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7939d2d993e49eddf1cab2881c4166045801fa6" translate="yes" xml:space="preserve">
          <source>This method provides notification that the virtual table implementation that the virtual table will be given a new name. If this method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; then SQLite renames the table. If this method returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; then the renaming is prevented.</source>
          <target state="translated">이 방법은 가상 테이블에 새로운 이름이 부여 될 가상 테이블 구현에 대한 알림을 제공합니다. 이 메소드가 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴 하면 SQLite는 테이블 이름을 바꿉니다. 이 메소드가 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴 하면 이름 변경이 방지됩니다.</target>
        </trans-unit>
        <trans-unit id="a08efc90f97c033c6f3a136a45c2a7cd6eb3f466" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked after transaction commit when the database is in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. Two arguments are appended to the callback command before it is invoked:</source>
          <target state="translated">이 메소드는 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에있을 때 트랜잭션 커미트 후에 호출되는 콜백 루틴을 등록 합니다 . 콜백 명령이 호출되기 전에 두 개의 인수가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2920f36d10d056ba3578501d280b4d02be0b6e1d" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to commit changes to a database. If the callback throws an exception or returns a non-zero result, then the transaction rolls back rather than commit.</source>
          <target state="translated">이 메소드는 SQLite가 데이터베이스에 변경 사항을 커미트하기 직전에 호출되는 콜백 루틴을 등록합니다. 콜백에서 예외가 발생하거나 0이 아닌 결과를 반환하면 트랜잭션이 커밋이 아닌 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="20062984ae0be47aefc8270221280e0e79c3fbe2" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before SQLite tries to do a rollback. The script argument is run without change.</source>
          <target state="translated">이 메소드는 SQLite가 롤백을 시도하기 직전에 호출되는 콜백 루틴을 등록합니다. 스크립트 인수는 변경없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b68fa7e92d08c038d817ec9f0f1dc21053a80d3a" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked just before each row is modified by an UPDATE, INSERT, or DELETE statement. Four arguments are appended to the callback before it is invoked:</source>
          <target state="translated">이 메소드는 UPDATE, INSERT 또는 DELETE 문으로 각 행을 수정하기 직전에 호출되는 콜백 루틴을 등록합니다. 콜백이 호출되기 전에 네 개의 인수가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1de39dc4601511299a305e0af9ade7a304a3c689" translate="yes" xml:space="preserve">
          <source>This method registers a callback routine that is invoked when the SQLite engine needs a particular collating sequence but does not have that collating sequence registered. The callback can register the collating sequence. The callback is invoked with a single parameter which is the name of the needed collating sequence.</source>
          <target state="translated">이 메소드는 SQLite 엔진에 특정 조합 순서가 필요하지만 해당 조합 순서가 등록되지 않은 경우 호출되는 콜백 루틴을 등록합니다. 콜백은 조합 순서를 등록 할 수 있습니다. 콜백은 필요한 조합 순서의 이름 인 단일 매개 변수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="21ae789dba180ad8c87b4a2a750db64d49f46fa8" translate="yes" xml:space="preserve">
          <source>This method registers a callback that is invoked periodically during query processing. There are two arguments: the number of SQLite virtual machine opcodes between invocations, and the TCL command to invoke. Setting the progress callback to an empty string disables it.</source>
          <target state="translated">이 메소드는 쿼리 처리 중 주기적으로 호출되는 콜백을 등록합니다. 두 가지 인수가 있습니다 : 호출 사이의 SQLite 가상 머신 opcode 수와 호출 할 TCL 명령. 진행 콜백을 빈 문자열로 설정하면 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="2dc944f8c7fefbfebd13fd137f3e37227d9d5fa9" translate="yes" xml:space="preserve">
          <source>This method registers new text collating sequences. There are two arguments: the name of the collating sequence and the name of a TCL procedure that implements a comparison function for the collating sequence.</source>
          <target state="translated">이 방법은 새로운 텍스트 배열 순서를 등록합니다. 조합 순서의 이름과 조합 순서에 대한 비교 함수를 구현하는 TCL 프로 시저의 이름에는 두 가지 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6fd7472db353bf284142fd5894eee70bc3b8bf2" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table, just like the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; method, and it also destroys the underlying table implementation. This method undoes the work of &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; 메소드 와 마찬가지로 가상 테이블에 대한 연결을 해제 하고 기본 테이블 구현도 제거합니다. 이 메소드는 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 작업을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="ef832304ea34e78e50a8e321fbc11fd1e9032c28" translate="yes" xml:space="preserve">
          <source>This method releases a connection to a virtual table. Only the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object is destroyed. The virtual table is not destroyed and any backing store associated with the virtual table persists. This method undoes the work of &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt;.</source>
          <target state="translated">이 방법은 가상 테이블에 대한 연결을 해제합니다. &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 객체 만 파괴됩니다. 가상 테이블은 손상되지 않으며 가상 테이블과 관련된 모든 백업 저장소가 유지됩니다. 이 메소드는 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 작업을 취소합니다 .</target>
        </trans-unit>
        <trans-unit id="4227ff89f6190deba008640864f1fdb82c90a383" translate="yes" xml:space="preserve">
          <source>This method returns status information from the most recently evaluated SQL statement. The status method takes a single argument which should be either &quot;steps&quot; or &quot;sorts&quot;. If the argument is &quot;steps&quot;, then the method returns the number of full table scan steps that the previous SQL statement evaluated. If the argument is &quot;sorts&quot;, the method returns the number of sort operations. This information can be used to detect queries that are not using indices to speed search or sorting.</source>
          <target state="translated">이 메소드는 가장 최근에 평가 된 SQL 문에서 상태 정보를 리턴합니다. status 메소드는 &quot;steps&quot;또는 &quot;sorts&quot;여야하는 단일 인수를 사용합니다. 인수가 &quot;단계&quot;인 경우, 메소드는 이전 SQL 문이 평가 한 전체 테이블 스캔 단계 수를 리턴합니다. 인수가 &quot;정렬&quot;인 경우, 메소드는 정렬 조작 수를 리턴합니다. 이 정보는 색인을 사용하여 검색 또는 정렬 속도를 높이 지 않는 쿼리를 감지하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc50ec02b1fc52936f33c145dd76c2dbb1165ca" translate="yes" xml:space="preserve">
          <source>This method returns the numeric error code that resulted from the most recent SQLite operation.</source>
          <target state="translated">이 메소드는 가장 최근의 SQLite 조작으로 인한 숫자 오류 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f84b852e58521bbbf0fe6bd6ba3aaa76874ffba2" translate="yes" xml:space="preserve">
          <source>This method should return an integer value that is equivalent to an SQLite error code (usually 0 for SQLITE_OK in the case of success or 1 for SQLITE_ERROR if some error occurs). As in &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;, the results of returning an integer that does not correspond to an SQLite error code are undefined. If the value returned by the script cannot be interpreted as an integer value, or if the script throws a Tcl exception, no error is returned to SQLite but a Tcl background-error is raised.</source>
          <target state="translated">이 메소드는 SQLite 오류 코드와 동등한 정수 값을 리턴해야합니다 (일반적으로 성공한 경우 SQLITE_OK의 경우 0, 일부 오류가 발생하면 SQLITE_ERROR의 경우 1). 마찬가지로 &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()는&lt;/a&gt; , SQLite는 에러 코드에 대응하지 않는 정수를 반환 결과는 정의되지된다. 스크립트가 리턴 한 값을 정수 값으로 해석 할 수 없거나 스크립트가 Tcl 예외를 처리하면 SQLite에 오류가 리턴되지 않지만 Tcl 백그라운드 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="69d817508f731b9a1bddece3df659e773b266409" translate="yes" xml:space="preserve">
          <source>This method signals the start of a two-phase commit on a virtual table. This is method is optional. The xSync pointer of &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; may be NULL.</source>
          <target state="translated">이 방법은 가상 테이블에서 2 단계 커밋의 시작을 알립니다. 이 방법은 선택 사항입니다. &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 xSync 포인터는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1be99db4c515118ac04440359b90544a681fa330" translate="yes" xml:space="preserve">
          <source>This method takes a single boolean argument which will turn the extension loading functionality on or off.</source>
          <target state="translated">이 메소드는 확장로드 기능을 켜거나 끄는 단일 부울 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c561fc9f9d18e98c0c786b020b147ec37c718e8" translate="yes" xml:space="preserve">
          <source>This misfeature means that a misspelled double-quoted identifier will be interpreted as a string literal, rather than generating an error. It also lures developers who are new to the SQL language into the bad habit of using double-quoted string literals when they really need to learn to use the correct single-quoted string literal form.</source>
          <target state="translated">이 잘못된 기능은 철자가 틀린 큰 따옴표로 묶인 식별자가 오류를 생성하지 않고 문자열 리터럴로 해석됨을 의미합니다. 또한 올바른 작은 따옴표로 묶인 문자열 리터럴 양식을 사용하는 법을 배워야 할 때 큰 따옴표로 묶인 문자열 리터럴을 사용하는 나쁜 습관으로 SQL 언어를 처음 접하는 개발자를 유혹합니다.</target>
        </trans-unit>
        <trans-unit id="a7d7620eee00f67af5794e95b53ed251b900cca6" translate="yes" xml:space="preserve">
          <source>This mode blocks (invokes the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. FULL blocks concurrent writers while it is running, but readers can proceed.</source>
          <target state="translated">이 모드 는 데이터베이스 기록기가없고 모든 판독기가 최신 데이터베이스 스냅 샷에서 읽을 때까지 차단합니다 ( &lt;a href=&quot;c3ref/busy_handler&quot;&gt;통화 처리기 콜백 호출&lt;/a&gt; ). 그런 다음 로그 파일의 모든 프레임을 체크 포인트하고 데이터베이스 파일을 동기화합니다. FULL은 동시 작성기가 실행되는 동안 차단하지만 독자는 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4d4de2de6eaf1fc63ccde7eca3a1fd81c8366c2" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">이 모드 는 데이터베이스 기록기가없고 모든 독자가 최신 데이터베이스 스냅 샷을 읽을 때까지 차단합니다 ( &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;통화 처리기 콜백 호출&lt;/a&gt; ). 그런 다음 로그 파일의 모든 프레임을 체크 포인트하고 데이터베이스 파일을 동기화합니다. 이 모드는 보류중인 새 데이터베이스 작성자를 차단하지만 새 데이터베이스 리더는 방해받지 않고 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc26aa0e4889928aaca415a8d70e942682adf13" translate="yes" xml:space="preserve">
          <source>This mode blocks (it invokes the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until there is no database writer and all readers are reading from the most recent database snapshot. It then checkpoints all frames in the log file and syncs the database file. This mode blocks new database writers while it is pending, but new database readers are allowed to continue unimpeded.</source>
          <target state="translated">이 모드 는 데이터베이스 기록기가없고 모든 독자가 최신 데이터베이스 스냅 샷을 읽을 때까지 차단합니다 ( &lt;a href=&quot;busy_handler&quot;&gt;통화 처리기 콜백 호출&lt;/a&gt; ). 그런 다음 로그 파일의 모든 프레임을 체크 포인트하고 데이터베이스 파일을 동기화합니다. 이 모드는 보류중인 새 데이터베이스 작성자를 차단하지만 새 데이터베이스 리더는 방해받지 않고 계속할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3564356c049b3cc19954e75da9c3a3e14807a420" translate="yes" xml:space="preserve">
          <source>This mode works the same way as FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are finished with the log file. This ensures that the next client to write to the database file restarts the log file from the beginning. RESTART blocks concurrent writers while it is running, but allowed readers to proceed.</source>
          <target state="translated">이 모드는 로그 파일을 체크 포인트 한 후 모든 독자가 로그 파일을 마칠 때까지 로그 파일을 차단 (통화 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;처리기 콜백 호출&lt;/a&gt; ) 한다는 점에서 FULL과 동일하게 작동 합니다. 이렇게하면 데이터베이스 파일에 쓸 다음 클라이언트가 로그 파일을 처음부터 다시 시작합니다. RESTART는 동시 작성기가 실행되는 동안 차단하지만 독자는 계속 진행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fb881e2173a556242d04296f314a6e802d8d176" translate="yes" xml:space="preserve">
          <source>This mode works the same way as RESTART with the addition that the WAL file is truncated to zero bytes upon successful completion.</source>
          <target state="translated">이 모드는 성공적으로 완료되면 WAL 파일이 0 바이트로 잘린다는 점 외에 RESTART와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="94e1a681e057e0efd19e4f8568beb354e5ca747a" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">이 모드는 로그 파일을 체크 포인트 한 후 모든 독자가 데이터베이스 파일에서만 읽을 때까지 로그 파일을 검사 (통화 &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;처리기 콜백 호출&lt;/a&gt; ) 하는 SQLITE_CHECKPOINT_FULL과 동일한 방식으로 작동합니다 . 이렇게하면 다음 기록기가 처음부터 로그 파일을 다시 시작할 수 있습니다. SQLITE_CHECKPOINT_FULL과 마찬가지로이 모드는 새로운 데이터베이스 기록기 시도가 보류중인 동안 차단하지만 독자를 방해하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2565fbfb38de6ccb4881d6d5b4ff9625664b3e35" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_FULL with the addition that after checkpointing the log file it blocks (calls the &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt;) until all readers are reading from the database file only. This ensures that the next writer will restart the log file from the beginning. Like SQLITE_CHECKPOINT_FULL, this mode blocks new database writer attempts while it is pending, but does not impede readers.</source>
          <target state="translated">이 모드는 로그 파일을 체크 포인트 한 후 모든 독자가 데이터베이스 파일에서만 읽을 때까지 로그 파일을 검사 (통화 &lt;a href=&quot;busy_handler&quot;&gt;처리기 콜백 호출&lt;/a&gt; ) 하는 SQLITE_CHECKPOINT_FULL과 동일한 방식으로 작동합니다 . 이렇게하면 다음 기록기가 처음부터 로그 파일을 다시 시작할 수 있습니다. SQLITE_CHECKPOINT_FULL과 마찬가지로이 모드는 새로운 데이터베이스 기록기 시도가 보류중인 동안 차단하지만 독자를 방해하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="6553148329df03707f6ea6e001cc2a449f7036e8" translate="yes" xml:space="preserve">
          <source>This mode works the same way as SQLITE_CHECKPOINT_RESTART with the addition that it also truncates the log file to zero bytes just prior to a successful return.</source>
          <target state="translated">이 모드는 SQLITE_CHECKPOINT_RESTART와 동일한 방식으로 작동하며 성공적인 리턴 직전에 로그 파일을 0 바이트로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="5e17d751b95d394b7ad8a49ae12b1ba579b3059a" translate="yes" xml:space="preserve">
          <source>This new index can be used to implement a faster algorithm for the original &quot;Price of Peaches&quot; query.</source>
          <target state="translated">이 새로운 인덱스는 원래 &quot;Pache of Peaches&quot;쿼리에 대해 더 빠른 알고리즘을 구현하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7c2f3e95925f0342ad3f077f1f083b0da69c5fe" translate="yes" xml:space="preserve">
          <source>This new index contains all the columns of the original FruitsForSale table that are used by the query - both the search terms and the output. We call this a &quot;covering index&quot;. Because all of the information needed is in the covering index, SQLite never needs to consult the original table in order to find the price.</source>
          <target state="translated">이 새 인덱스에는 쿼리에 사용되는 원래 FruitsForSale 테이블의 모든 열 (검색어 및 출력)이 포함됩니다. 이것을 &quot;커버링 인덱스&quot;라고합니다. 필요한 모든 정보가 포함 인덱스에 있기 때문에 SQLite는 가격을 찾기 위해 원래 테이블을 참조 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="acf43845a5ea53f1f00ff4c11a6f5e1b8a8b33d3" translate="yes" xml:space="preserve">
          <source>This next query solves a Sudoku puzzle. The state of the puzzle is defined by an 81-character string formed by reading entries from the puzzle box row by row from left to right and then from top to bottom. Blank squares in the puzzle are denoted by a &quot;.&quot; character. Thus the input string:</source>
          <target state="translated">이 다음 쿼리는 스도쿠 퍼즐을 해결합니다. 퍼즐의 상태는 퍼즐 상자의 항목을 왼쪽에서 오른쪽으로, 위에서 아래로 읽어서 81 자 문자열로 정의됩니다. 퍼즐의 빈 사각형은 &quot;.&quot;로 표시됩니다. 캐릭터. 따라서 입력 문자열 :</target>
        </trans-unit>
        <trans-unit id="68714059b3f9385751b77bf5e71ea40721ded156" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">이 객체는 SQLite 인터페이스에서 한 곳에서만 사용됩니다. 구성 옵션이 &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 또는 &lt;a href=&quot;#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt; 인 경우이 오브젝트의 인스턴스에 대한 포인터는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 의 인수 입니다. 구성하는 동안 이 오브젝트의 인스턴스를 작성하여 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; )로 전달 함으로써 애플리케이션은 SQLite가 모든 동적 메모리 요구에 사용할 대체 메모리 할당 서브 시스템을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3560b833b5836cc3d10c63801ce7146372dee16e" translate="yes" xml:space="preserve">
          <source>This object is used in only one place in the SQLite interface. A pointer to an instance of this object is the argument to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; when the configuration option is &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt;. By creating an instance of this object and passing it to &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;) during configuration, an application can specify an alternative memory allocation subsystem for SQLite to use for all of its dynamic memory needs.</source>
          <target state="translated">이 객체는 SQLite 인터페이스에서 한 곳에서만 사용됩니다. 구성 옵션이 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 또는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmalloc&quot;&gt;SQLITE_CONFIG_GETMALLOC&lt;/a&gt; 인 경우이 오브젝트의 인스턴스에 대한 포인터는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 의 인수 입니다. 구성하는 동안 이 오브젝트의 인스턴스를 작성하여 &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; )로 전달 함으로써 애플리케이션은 SQLite가 모든 동적 메모리 요구에 사용할 대체 메모리 할당 서브 시스템을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1882a6d3fc0a0bded1e433917173d1858c24f074" translate="yes" xml:space="preserve">
          <source>This only works when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG로&lt;/a&gt; 컴파일 할 때만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="cfa6d4acc676d7ac09e89de67c072931e0df8cd6" translate="yes" xml:space="preserve">
          <source>This opcode (which only exists if SQLite was compiled with SQLITE_ENABLE_COLUMN_USED_MASK) identifies which columns of the table or index for cursor P1 are used. P4 is a 64-bit integer (P4_INT64) in which the first 63 bits are one for each of the first 63 columns of the table or index that are actually used by the cursor. The high-order bit is set if any column after the 64th is used.</source>
          <target state="translated">이 opcode (SQLite가 SQLITE_ENABLE_COLUMN_USED_MASK로 컴파일 된 경우에만 존재)는 커서 P1에 대한 테이블 또는 인덱스의 열을 사용합니다. P4는 64 비트 정수 (P4_INT64)입니다. 여기서 첫 63 비트는 커서가 실제로 사용하는 테이블 또는 인덱스의 첫 63 개 열 각각에 대해 1입니다. 64 번째 이후의 열이 사용되면 상위 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b79886bbc08237ffaab5449ea6dabdf7a84bb8eb" translate="yes" xml:space="preserve">
          <source>This opcode behaves like &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; if the seekHit flag is clear and it behaves like &lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt; if the seekHit flag is set.</source>
          <target state="translated">seekHit 플래그가 명확한 경우이 opcode는 &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; 처럼 작동 하고 seekHit 플래그가 설정된 경우 &lt;a href=&quot;opcode#Noop&quot;&gt;Noop&lt;/a&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e04269abd438fa3b7333edfe660e9856975a5dd0" translate="yes" xml:space="preserve">
          <source>This opcode does exactly the same thing as &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; except that it increments an undocumented global variable used for testing.</source>
          <target state="translated">이 opcode는 테스트에 사용되는 문서화되지 않은 전역 변수를 증가 시킨다는 점을 제외하고 &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; 와 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c8090fac6edb839ad1f5d93ed66a4501d0732691" translate="yes" xml:space="preserve">
          <source>This opcode implements the IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE operators.</source>
          <target state="translated">이 opcode는 IS TRUE, IS FALSE, IS NOT TRUE 및 IS NOT FALSE 연산자를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="80195a95c1d144667fff82486976a6e1af2d3b57" translate="yes" xml:space="preserve">
          <source>This opcode invokes the parser to create a new virtual machine, then runs the new virtual machine. It is thus a re-entrant opcode.</source>
          <target state="translated">이 opcode는 구문 분석기를 호출하여 새 가상 머신을 작성한 다음 새 가상 머신을 실행합니다. 따라서 재진입 opcode입니다.</target>
        </trans-unit>
        <trans-unit id="d5ae7a9a55b8c3387be81c142b3c731709ff4fb8" translate="yes" xml:space="preserve">
          <source>This opcode invokes the xFilter method on the virtual table specified by P1. The integer query plan parameter to xFilter is stored in register P3. Register P3+1 stores the argc parameter to be passed to the xFilter method. Registers P3+2..P3+1+argc are the argc additional parameters which are passed to xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.</source>
          <target state="translated">이 opcode는 P1에 의해 지정된 가상 테이블에서 xFilter 메소드를 호출합니다. xFilter에 대한 정수 쿼리 계획 매개 변수는 레지스터 P3에 저장됩니다. 레지스터 P3 + 1은 xFilter 메소드로 전달 될 argc 매개 변수를 저장합니다. 레지스터 P3 + 2..P3 + 1 + argc는 argc로 xFilter에 전달되는 argc 추가 매개 변수입니다. xFilter로 전달되면 레지스터 P3 + 2는 argv [0]이됩니다.</target>
        </trans-unit>
        <trans-unit id="b4696388c2a5ea95b129447ae7160a304f284c78" translate="yes" xml:space="preserve">
          <source>This opcode is an alias for &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; that is used for Sorter objects.</source>
          <target state="translated">이 opcode는 Sorter 객체에 사용되는 &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; and &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="2cd5c8a03dccaa1c2e173dfb77000d3f09963ffe" translate="yes" xml:space="preserve">
          <source>This opcode is initially coded as OP_AggStep0. On first evaluation, the FuncDef stored in P4 is converted into an sqlite3_context and the opcode is changed. In this way, the initialization of the sqlite3_context only happens once, instead of on each call to the step function.</source>
          <target state="translated">이 opcode는 처음에 OP_AggStep0으로 코딩됩니다. 첫 번째 평가에서 P4에 저장된 FuncDef가 sqlite3_context로 변환되고 opcode가 변경됩니다. 이런 식으로 sqlite3_context의 초기화는 단계 함수를 호출 할 때마다 한 번만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ccd042d8c20621b0ba115fbd962b688a465b7a1e" translate="yes" xml:space="preserve">
          <source>This opcode is normally use to move a record out of the sorter and into a register that is the source for a pseudo-table cursor created using &lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo&lt;/a&gt;. That pseudo-table cursor is the one that is identified by parameter P3. Clearing the P3 column cache as part of this opcode saves us from having to issue a separate &lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt; instruction to clear that cache.</source>
          <target state="translated">이 opcode는 일반적으로 레코드를 분류기에서 &lt;a href=&quot;opcode#OpenPseudo&quot;&gt;OpenPseudo를&lt;/a&gt; 사용하여 작성된 의사 테이블 커서의 소스 인 레지스터로 이동하는 데 사용 됩니다 . 그 의사 테이블 커서는 매개 변수 P3으로 식별되는 커서입니다. 이 opcode의 일부로 P3 열 캐시를 지우면 별도의 &lt;a href=&quot;opcode#NullRow&quot;&gt;NullRow&lt;/a&gt; 명령을 실행하여 해당 캐시를 지우지 않아도 됩니다.</target>
        </trans-unit>
        <trans-unit id="f368e74bed9bf6036c173d5ffc843879779adc0f" translate="yes" xml:space="preserve">
          <source>This opcode is only available if SQLite is compiled with the -DSQLITE_ENABLE_OFFSET_SQL_FUNC option.</source>
          <target state="translated">이 opcode는 SQLite가 -DSQLITE_ENABLE_OFFSET_SQL_FUNC 옵션으로 컴파일 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="cc6bc217f526f9cd459391c67d3dce0bbbb0723f" translate="yes" xml:space="preserve">
          <source>This opcode is only available in testing and debugging builds. It is not generated for release builds. The purpose of this opcode is to help validate the generated bytecode. This opcode does not actually contribute to computing an answer.</source>
          <target state="translated">이 opcode는 빌드 테스트 및 디버깅에서만 사용할 수 있습니다. 릴리스 빌드에 대해서는 생성되지 않습니다. 이 opcode의 목적은 생성 된 바이트 코드의 유효성을 검사하는 것입니다. 이 opcode는 실제로 답을 계산하는 데 기여하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dd0c6b395f56420b6f36502ce5f6e4b927e5a5c" translate="yes" xml:space="preserve">
          <source>This opcode is only ever present in sub-programs called via the &lt;a href=&quot;opcode#Program&quot;&gt;Program&lt;/a&gt; instruction. &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; a value currently stored in a memory cell of the calling (parent) frame to cell P2 in the current frames address space. This is used by trigger programs to access the new.* and old.* values.</source>
          <target state="translated">이 opcode는 &lt;a href=&quot;opcode#Program&quot;&gt;프로그램&lt;/a&gt; 명령을 통해 호출 된 서브 프로그램에만 존재 합니다. 호출하는 (부모) 프레임의 메모리 셀에 현재 저장된 값을 현재 프레임 주소 공간의 셀 P2에 &lt;a href=&quot;opcode#Copy&quot;&gt;복사&lt;/a&gt; 합니다. 트리거 프로그램에서 new. * 및 old. * 값에 액세스하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1edae59fc3236745f7fbf501252bcea75f5db5b9" translate="yes" xml:space="preserve">
          <source>This opcode is similar to &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; with the exceptions that the branch is always taken if any part of the search key input is NULL.</source>
          <target state="translated">이 opcode는 검색 키 입력의 일부가 NULL 인 경우 분기가 항상 수행된다는 점을 제외 하면 &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; 와 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="1074ea1e6510853bdec71ac78b6a534ca6039b57" translate="yes" xml:space="preserve">
          <source>This opcode is used in IN clause processing for a multi-column key. If an IN clause is attached to an element of the key other than the left-most element, and if there are no matches on the most recent seek over the whole key, then it might be that one of the key element to the left is prohibiting a match, and hence there is &quot;no hope&quot; of any match regardless of how many IN clause elements are checked. In such a case, we abandon the IN clause search early, using this opcode. The opcode name comes from the fact that the jump is taken if there is &quot;no hope&quot; of achieving a match.</source>
          <target state="translated">이 opcode는 다중 열 키에 대한 IN 절 처리에 사용됩니다. IN 절이 가장 왼쪽 요소 이외의 키 요소에 첨부되어 있고 전체 키에 대한 가장 최근 탐색에서 일치하는 항목이 없으면 왼쪽의 키 요소 중 하나 일 수 있습니다. IN을 금지하는 IN 절 요소 수에 관계없이 일치를 금지하므로 일치에 대한 &quot;희망이 없습니다&quot;. 이 경우이 opcode를 사용하여 IN 절 검색을 조기에 포기합니다. opcode 이름은 일치하는 &quot;희망&quot;이없는 경우 점프가 발생한다는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="8a560c644b1064348d0d21a9885c9e73f72f185e" translate="yes" xml:space="preserve">
          <source>This opcode is used to implement the integrity_check pragma.</source>
          <target state="translated">이 opcode는 integrity_check pragma를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="36b9014a68a8fcf60471eef29422a00680109ffb" translate="yes" xml:space="preserve">
          <source>This opcode is used when extracting information from a column that has REAL affinity. Such column values may still be stored as integers, for space efficiency, but after extraction we want them to have only a real value.</source>
          <target state="translated">이 opcode는 REAL 선호도가있는 열에서 정보를 추출 할 때 사용됩니다. 이러한 열 값은 공간 효율성을 위해 여전히 정수로 저장 될 수 있지만 추출 후 실제 값만 갖기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="cfa4b2533ec63a8dec1bee2b7cfac77ec376defc" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in forward order, from the beginning toward the end. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;, not &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;.</source>
          <target state="translated">이 opcode는 커서를 처음부터 끝까지 앞으로 이동하도록 구성되어 있습니다. 즉, 커서는 &lt;a href=&quot;opcode#Prev&quot;&gt;Prev가&lt;/a&gt; 아닌 &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; 를 사용하도록 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="9db9421c1851bc92812d2d99ea83270abb9a3281" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor configured to move in reverse order, from the end toward the beginning. In other words, the cursor is configured to use &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;, not &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt;.</source>
          <target state="translated">이 opcode는 커서를 끝에서 시작으로 역순으로 이동하도록 구성되어 있습니다. 즉, 커서는 &lt;a href=&quot;opcode#Next&quot;&gt;Next가&lt;/a&gt; 아니라 &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; 를 사용하도록 구성되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2f0cd72e4c85aa3ba21b6915cd7acce5e5760e8" translate="yes" xml:space="preserve">
          <source>This opcode leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes will not work following this opcode.</source>
          <target state="translated">이 opcode는 커서를 어느 방향 으로든 전진 할 수없는 상태로 둡니다. 즉,이 opcode &lt;a href=&quot;opcode#Next&quot;&gt;다음에 Next&lt;/a&gt; 및 &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e0f99ac32670b6df2ff48dc1552c8225ad687653" translate="yes" xml:space="preserve">
          <source>This opcode must follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. There can be zero or more OP_ReleaseReg opcodes intervening, but no other opcodes are allowed to occur between this instruction and the previous &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt;. Furthermore, the prior &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; must have the SQLITE_STOREP2 bit set in the P5 field.</source>
          <target state="translated">이 opcode는 &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; 비교 연산자를 따라야합니다 . 0 개 이상의 OP_ReleaseReg opcode가 개입 될 수 있지만이 명령어와 이전 &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; 사이에는 다른 opcode가 발생할 수 없습니다 . 또한 이전 &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; 에는 P5 필드에 SQLITE_STOREP2 비트가 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6db8b6773ccb389e7a96c1d48f5077207b71453" translate="yes" xml:space="preserve">
          <source>This opcode must immediately follow an &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; or &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; comparison operator. If result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the same two operands would have be NULL or false (0), then then jump to P2. If the result of an &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; comparison on the two previous operands would have been true (1), then fall through.</source>
          <target state="translated">이 opcode는 &lt;a href=&quot;opcode#Lt&quot;&gt;Lt&lt;/a&gt; 또는 &lt;a href=&quot;opcode#Gt&quot;&gt;Gt&lt;/a&gt; 비교 연산자를 즉시 따라야합니다 . 동일한 두 피연산자에 대한 &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; 비교 결과 가 NULL 또는 false (0)이면 P2로 건너 뜁니다. 이전의 두 피연산자에 대한 &lt;a href=&quot;opcode#Eq&quot;&gt;Eq&lt;/a&gt; 비교 결과 가 참 (1)이면 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="fe62ed3995127b50711c091c796c38839099f405" translate="yes" xml:space="preserve">
          <source>This opcode only works for cursors used for sorting and opened with &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; or &lt;a href=&quot;opcode#SorterOpen&quot;&gt;SorterOpen&lt;/a&gt;.</source>
          <target state="translated">이 opcode는 정렬에 사용되며 &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; 또는 &lt;a href=&quot;opcode#SorterOpen&quot;&gt;SorterOpen으로&lt;/a&gt; 열린 커서에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0a5cf188d3f8f57c9bc976279d8b9451f3af100d" translate="yes" xml:space="preserve">
          <source>This opcode performs a commonly used computation associated with LIMIT and OFFSET process. r[P1] holds the limit counter. r[P3] holds the offset counter. The opcode computes the combined value of the LIMIT and OFFSET and stores that value in r[P2]. The r[P2] value computed is the total number of rows that will need to be visited in order to complete the query.</source>
          <target state="translated">이 opcode는 LIMIT 및 OFFSET 프로세스와 관련하여 일반적으로 사용되는 계산을 수행합니다. r [P1]은 리미트 카운터를 유지합니다. r [P3]은 오프셋 카운터를 유지합니다. opcode는 LIMIT와 OFFSET의 결합 된 값을 계산하고 그 값을 r [P2]에 저장합니다. 계산 된 r [P2] 값은 쿼리를 완료하기 위해 방문해야하는 총 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="5c774d8b575a72465fcca20f5e30c011a493a27a" translate="yes" xml:space="preserve">
          <source>This opcode tests if a foreign key constraint-counter is currently zero. If so, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">이 opcode는 외래 키 제약 조건 카운터가 현재 0인지 테스트합니다. 그렇다면 지침 P2로 이동하십시오. 그렇지 않으면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="546c52afd639a2ac1b1f0294a0fa0ff8fad9df32" translate="yes" xml:space="preserve">
          <source>This opcode throws an error if there are any active reader VMs when it is invoked. This is done to avoid the difficulty associated with updating existing cursors when a root page is moved in an AUTOVACUUM database. This error is thrown even if the database is not an AUTOVACUUM db in order to avoid introducing an incompatibility between autovacuum and non-autovacuum modes.</source>
          <target state="translated">이 opcode는 호출 될 때 활성 판독기 VM이있는 경우 오류를 발생시킵니다. 이는 루트 페이지가 AUTOVACUUM 데이터베이스에서 이동 될 때 기존 커서 업데이트와 관련된 어려움을 피하기 위해 수행됩니다. autovacuum과 non-autovacuum 모드 간의 비 호환성을 피하기 위해 데이터베이스가 AUTOVACUUM db가 아닌 경우에도이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52667b3b8e58f7e2254dc2c69756775349787b29" translate="yes" xml:space="preserve">
          <source>This opcode works exactly like &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;. The only difference is in its name. This opcode is used in places where the function must be purely non-deterministic. Some built-in date/time functions can be either determinitic of non-deterministic, depending on their arguments. When those function are used in a non-deterministic way, they will check to see if they were called using &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt; instead of &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;, and if they were, they throw an error.</source>
          <target state="translated">이 opcode는 &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; 과 똑같이 작동합니다 . 유일한 차이점은 이름입니다. 이 opcode는 함수가 순전히 비 결정적이어야하는 곳에서 사용됩니다. 일부 내장 날짜 / 시간 함수는 인수에 따라 비 결정적 일 수 있습니다. 이러한 함수가 비 결정적 방식으로 사용 &lt;a href=&quot;opcode#PureFunc&quot;&gt;되면 &lt;/a&gt;&lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; 대신 PureFunc 를 사용하여 호출되었는지 확인하고 호출 된 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="480cdfb81d03d4678699e7e229cd926e397be01a" translate="yes" xml:space="preserve">
          <source>This opcode works just like &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; except that P1 must be a sorter object for which the &lt;a href=&quot;opcode#SorterSort&quot;&gt;SorterSort&lt;/a&gt; opcode has been invoked. This opcode advances the cursor to the next sorted record, or jumps to P2 if there are no more sorted records.</source>
          <target state="translated">이 opcode는 P1이 &lt;a href=&quot;opcode#SorterSort&quot;&gt;SorterSort&lt;/a&gt; opcode가 호출 된 sorter 오브젝트 여야한다는 점을 제외하고 &lt;a href=&quot;opcode#Next&quot;&gt;Next와&lt;/a&gt; 동일하게 작동 합니다 . 이 opcode는 커서를 다음 정렬 된 레코드로 이동 시키거나 정렬 된 레코드가 더 이상 없으면 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8c41d39eeb147c07c8acc288aca8d67aa65d5265" translate="yes" xml:space="preserve">
          <source>This opcode works like &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; except that it opens a transient index that is specifically designed to sort large tables using an external merge-sort algorithm.</source>
          <target state="translated">이 opcode 는 외부 병합 정렬 알고리즘을 사용하여 큰 테이블을 정렬하도록 특별히 설계된 임시 인덱스를 여는 것을 제외하고 &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; 과 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="1bd026a84c4b134c052fab965e0298249387c523" translate="yes" xml:space="preserve">
          <source>This opcode works the same as &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt;. It has a different name to distinguish its use. Tables created using by this opcode will be used for automatically created transient indices in joins.</source>
          <target state="translated">이 opcode는 &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; 과 동일하게 작동합니다 . 용도를 구별하기 위해 이름이 다릅니다. 이 opcode로 생성 된 테이블은 조인에서 자동으로 생성 된 임시 인덱스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aea3e0eadc6549a98e3f2a226a78969a9d9be0e4" translate="yes" xml:space="preserve">
          <source>This operation leaves the cursor in a state where it can be advanced in the forward direction. The &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; instruction will work, but not the &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; instruction.</source>
          <target state="translated">이 조작은 커서를 정방향으로 진행할 수있는 상태로 둡니다. &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 명령은 작동하지만하지 않습니다 &lt;a href=&quot;opcode#Prev&quot;&gt;이전의&lt;/a&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="674899f070471e538d8c615be60bc1cbfc82c6f5" translate="yes" xml:space="preserve">
          <source>This operation leaves the cursor in a state where it cannot be advanced in either direction. In other words, the &lt;a href=&quot;opcode#Next&quot;&gt;Next&lt;/a&gt; and &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcodes do not work after this operation.</source>
          <target state="translated">이 조작은 커서를 어느 방향 으로든 전진 할 수없는 상태로 둡니다. 즉, &lt;a href=&quot;opcode#Next&quot;&gt;다음&lt;/a&gt; 이 작업 후에 및 &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt; opcode가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="692e5e8e72323f3828134ed084c67a8aae1f6191" translate="yes" xml:space="preserve">
          <source>This option activates an optimization that reduces the memory required by the sorter at the cost of doing additional B-tree lookups after the sort has occurred.</source>
          <target state="translated">이 옵션은 정렬이 발생한 후 추가 B- 트리 조회를 수행하는 대신 정렬기에 필요한 메모리를 줄이는 최적화를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="e1b53eed6630caef9cfd2ca35ff19d694b6cd8e9" translate="yes" xml:space="preserve">
          <source>This option adds additional logic to the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and to the &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt; that can help SQLite to chose a better query plan under certain situations. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is enhanced to collect histogram data from all columns of every index and store that data in the &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; table. The query planner will then use the histogram data to help it make better index choices. The downside of this compile-time option is that it violates the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; making it more difficult to ensure consistent performance in mass-produced applications.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령과 &lt;a href=&quot;optoverview&quot;&gt;쿼리 플래너에&lt;/a&gt; 추가 로직을 추가 하여 특정 상황에서 SQLite가 더 나은 쿼리 계획을 선택할 수 있도록 도와줍니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령은 모든 인덱스마다의 열 및 저장소로부터 수집 한 히스토그램 데이터를 향상된다는 데이터 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4의&lt;/a&gt; 테이블. 그러면 쿼리 플래너는 히스토그램 데이터를 사용하여 더 나은 인덱스를 선택할 수 있습니다. 이 컴파일 타임 옵션의 단점은&lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt; 쿼리 플래너 안정성 보장&lt;/a&gt; 을 대량 생산 응용 프로그램에서 일관된 성능을 보장하기가 어렵다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d6209f0377358c783d1190518295961bb9d4da90" translate="yes" xml:space="preserve">
          <source>This option adds extra logic to SQLite that allows it to release unused memory upon request. This option must be enabled in order for the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface to work. If this compile-time option is not used, the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface is a no-op.</source>
          <target state="translated">이 옵션은 SQLite에 추가 로직을 추가하여 요청시 사용하지 않는 메모리를 해제 할 수 있습니다. &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 인터페이스가 작동 하려면이 옵션을 활성화해야합니다 . 이 컴파일 타임 옵션을 사용하지 않으면 &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="939f1a447a21a0874443461aacf8890bd098e69f" translate="yes" xml:space="preserve">
          <source>This option adds extra logic to SQLite that inserts comment text into the output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. These extra comments use extra memory, thus making &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; larger and very slightly slower, and so they are turned off by default and in most application. But some applications, such as the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for SQLite, value clarity of EXPLAIN output over raw performance and so this compile-time option is available to them. The SQLITE_ENABLE_EXPLAIN_COMMENTS compile-time option is also enabled automatically if &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; is enabled.</source>
          <target state="translated">이 옵션은 주석 텍스트를 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력에 삽입하는 추가 로직을 SQLite에 추가합니다 . 이러한 추가 주석은 추가 메모리를 사용하므로 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문이&lt;/a&gt; 더 크고 매우 느리므로 기본적으로 대부분의 응용 프로그램에서 해제됩니다. 그러나 SQLite 용 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 과 같은 일부 응용 프로그램 은 원시 성능에 비해 EXPLAIN 출력의 가치가 명확하므로이 컴파일 타임 옵션을 사용할 수 있습니다. &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 가 활성화 된 경우 SQLITE_ENABLE_EXPLAIN_COMMENTS 컴파일 타임 옵션도 자동으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c48faf6b414235fea882e17a937347af8cad6d7" translate="yes" xml:space="preserve">
          <source>This option builds SQLite without support for shared-cache mode. The &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; is omitted along with a fair amount of logic within the B-Tree subsystem associated with shared cache management.</source>
          <target state="translated">이 옵션은 공유 캐시 모드를 지원하지 않고 SQLite를 빌드합니다. &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; 공유 캐시 관리와 관련된 B-트리 서브 시스템 내에서 논리의 공정한 금액과 함께 생략하기로한다.</target>
        </trans-unit>
        <trans-unit id="b993563b54a3e7e57504381c57f5844eff0c8f71" translate="yes" xml:space="preserve">
          <source>This option builds a version of the SQLite library that contains no Writable Static Data (WSD). WSD is global variables and/or static variables. Some platforms do not support WSD, and this option is necessary in order for SQLite to work those platforms.</source>
          <target state="translated">이 옵션은 WSD (Writable Static Data)를 포함하지 않는 SQLite 라이브러리 버전을 빌드합니다. WSD는 전역 변수 및 / 또는 정적 변수입니다. 일부 플랫폼은 WSD를 지원하지 않으며 SQLite가 해당 플랫폼을 작동 시키려면이 옵션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="cc1dc5438a20aea7b771ebb862eeafa845ecba70" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to include support for the &lt;a href=&quot;rtree&quot;&gt;R*Tree index extension&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 SQLite가 &lt;a href=&quot;rtree&quot;&gt;R * Tree 인덱스 확장에&lt;/a&gt; 대한 지원을 포함하게 합니다. .</target>
        </trans-unit>
        <trans-unit id="d49b99c0ffb50444c0efac26b8174b7d62f63e18" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to issue extra &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; file controls to provide supplementary information to the VFS. The &quot;vfslog.c&quot; extension makes use of this to provide enhanced logs of VFS activity.</source>
          <target state="translated">이 옵션은 SQLite가 추가 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntltrace&quot;&gt;SQLITE_FCNTL_TRACE&lt;/a&gt; 를 발행 하게합니다. 파일 제어 하여 VFS에 보충 정보를 제공합니다. &quot;vfslog.c&quot;확장자는이를 사용하여 VFS 활동의 향상된 로그를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f48b901e533b97a7c255e13419b3b1ee589cd6a2" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for CHECK constraints. The parser will still accept CHECK constraints in SQL statements, they will just not be enforced.</source>
          <target state="translated">이 옵션은 SQLite가 CHECK 제한 조건에 대한 지원을 생략하게합니다. 파서는 여전히 SQL 문에서 CHECK 제약 조건을 수락하지만 적용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e8d6847f55a56b21f8cc66e6cb9b40222b5beea" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for interfaces marked as deprecated. This includes &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_aggregate_count()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_expired()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_transfer_bindings()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_global_recover()&lt;/a&gt;, &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup()&lt;/a&gt; and &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm()&lt;/a&gt; interfaces and &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA count_changes&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;PRAGMA data_store_directory&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;PRAGMA default_cache_size&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA empty_result_callbacks&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;PRAGMA full_column_names&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;PRAGMA short_column_names&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA temp_store_directory&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 SQLite가 더 이상 사용되지 않는 것으로 표시된 인터페이스에 대한 지원을 생략합니다. 여기에는 &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_aggregate_count ()&lt;/a&gt; , &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;(sqlite3_expired)&lt;/a&gt; , &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_transfer_bindings ()&lt;/a&gt; , &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_global_recover ()&lt;/a&gt; , &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_thread_cleanup ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/aggregate_count&quot;&gt;sqlite3_memory_alarm ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA의&lt;/a&gt; 문 &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;PRAGMA의 count_changes&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_data_store_directory&quot;&gt;PRAGMA의 data_store_directory&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_default_cache_size&quot;&gt;PRAGMA의 default_cache_size&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_empty_result_callbacks&quot;&gt;PRAGMA의 empty_result_callbacks&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;PRAGMA의 full_column_names&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;PRAGMA의 short_column_names&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;PRAGMA의 temp_store_directory을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3bc3317e6e04ba669cec1fd0969c97803605f228" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for the &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype()&lt;/a&gt; and &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype16()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 옵션은 SQLite가 &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/column_decltype&quot;&gt;sqlite3_column_decltype16 ()&lt;/a&gt; 인터페이스에 대한 지원을 생략하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="f5f11391f5a431c21a74cece861bb90184bcc1ca" translate="yes" xml:space="preserve">
          <source>This option causes SQLite to omit support for the CAST operator.</source>
          <target state="translated">이 옵션은 SQLite가 CAST 연산자에 대한 지원을 생략하게합니다.</target>
        </trans-unit>
        <trans-unit id="42e9c6736f13f3788e9996fc842184805b38c422" translate="yes" xml:space="preserve">
          <source>This option causes some extensions to link against the &lt;a href=&quot;https://zlib.net&quot;&gt;zlib compression library&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 사용하면 일부 확장이 &lt;a href=&quot;https://zlib.net&quot;&gt;zlib 압축 라이브러리&lt;/a&gt; 와 연결 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f9a553122464d073f41c1a4907a1e3a4d15ea05" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;c3ref/blob&quot;&gt;incremental BLOB I/O&lt;/a&gt; to be omitted.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;c3ref/blob&quot;&gt;증분 BLOB I / O&lt;/a&gt; 에 대한 지원 이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a5fb6aca1f0d6549bb7f87e1d2117bf9906d5faa" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; to be omitted.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_free_table ()&lt;/a&gt; 에 대한 지원 이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="81ad82489e08da7b33af60fe7dc85cf28f77189f" translate="yes" xml:space="preserve">
          <source>This option causes support for &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; to be omitted.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 에 대한 지원 이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="1d462d4f5baf96b5381e5a9efb9392dd8419bfa1" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; and &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete16()&lt;/a&gt; interfaces to be omitted.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete16 ()&lt;/a&gt; 인터페이스가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="c44c8eec11a8ae8049df43dc8d152025a2065bf2" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;International Components for Unicode&lt;/a&gt; or &quot;ICU&quot; extension to SQLite to be added to the build.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;유니 코드 용 국제 구성 요소&lt;/a&gt; 또는 SQLite에 대한 &quot;ICU&quot;확장이 빌드에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3e7ba1f2e4ecce44e2a9ed58760bf709eee38824" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; setting to be enabled by default. When enabled, &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that lack an ORDER BY clause will run in reverse order.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;PRAGMA reverse_unordered_selects&lt;/a&gt; 설정이 기본적으로 활성화됩니다. 사용 가능한 경우 ORDER BY 절이없는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문은 역순으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f5c90b7d8674897dce67771e2421445a44cf5d0f" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;query planner stability guarantee&lt;/a&gt; (QPSG) to be on by default. Normally the QPSG is off and must be activated at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;queryplanner-ng#qpstab&quot;&gt;쿼리 플래너 안정성 보장&lt;/a&gt; (QPSG)이 기본적으로 설정됩니다. 일반적으로 QPSG는 꺼져 있으며 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스에 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableqpsg&quot;&gt;SQLITE_DBCONFIG_ENABLE_QPSG&lt;/a&gt; 옵션을 사용하여 런타임시 활성화되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3e81e1ee9998eb2eded923b7975e23afc33d57f" translate="yes" xml:space="preserve">
          <source>This option causes the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; process logic to be enabled by default.</source>
          <target state="translated">이 옵션을 사용하면 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 프로세스 논리가 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="25841760348a4a05ca082684fc85caf48a8848ea" translate="yes" xml:space="preserve">
          <source>This option causes the LALR(1) parser stack depth to be tracked and reported using the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status&lt;/a&gt;(&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusparserstack&quot;&gt;SQLITE_STATUS_PARSER_STACK&lt;/a&gt;,...) interface. SQLite's LALR(1) parser has a fixed stack depth (determined at compile-time using the &lt;a href=&quot;compile#yystackdepth&quot;&gt;YYSTACKDEPTH&lt;/a&gt; options). This option can be used to help determine if an application is getting close to exceeding the maximum LALR(1) stack depth.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusparserstack&quot;&gt;SQLITE_STATUS_PARSER_STACK&lt;/a&gt; , ...) 인터페이스를 사용하여 LALR (1) 파서 스택 깊이를 추적하고보고합니다 . SQLite의 LALR (1) 파서에는 고정 스택 깊이가 있습니다 ( &lt;a href=&quot;compile#yystackdepth&quot;&gt;YYSTACKDEPTH&lt;/a&gt; 옵션을 사용하여 컴파일 타임에 결정 ). 이 옵션을 사용하면 응용 프로그램이 최대 LALR (1) 스택 깊이를 초과하는지를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32f86baa9c92a63548375cdf50ea0fd1c52ed044" translate="yes" xml:space="preserve">
          <source>This option changes the default assumption about &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; for the underlying filesystems for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;. Setting SQLITE_POWERSAFE_OVERWRITE to 1 causes SQLite to assume that application-level writes cannot changes bytes outside the range of bytes written even if the write occurs just before a power loss. With SQLITE_POWERSAFE_OVERWRITE set to 0, SQLite assumes that other bytes in the same sector with a written byte might be changed or damaged by a power loss.</source>
          <target state="translated">이 옵션 은 unix 및 windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 기본 파일 시스템에 대한 &lt;a href=&quot;psow&quot;&gt;전원 안전 덮어 쓰기에&lt;/a&gt; 대한 기본 가정을 변경합니다 . SQLITE_POWERSAFE_OVERWRITE를 1로 설정하면 전원 손실 직전에 쓰기가 발생하더라도 SQLite는 응용 프로그램 수준 쓰기가 쓰기 바이트 범위 밖의 바이트를 변경할 수 없다고 가정합니다. SQLITE_POWERSAFE_OVERWRITE를 0으로 설정하면 SQLite는 쓰기 된 바이트가있는 동일한 섹터의 다른 바이트가 전원 손실에 의해 변경되거나 손상 될 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="791fdd9bdb7ed68e09202021e5669277498343c1" translate="yes" xml:space="preserve">
          <source>This option controls whether or not code is included in SQLite to enable it to operate safely in a multithreaded environment. The default is SQLITE_THREADSAFE=1 which is safe for use in a multithreaded environment. When compiled with SQLITE_THREADSAFE=0 all mutexing code is omitted and it is unsafe to use SQLite in a multithreaded program. When compiled with SQLITE_THREADSAFE=2, SQLite can be used in a multithreaded program so long as no two threads attempt to use the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; (or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; derived from that database connection) at the same time.</source>
          <target state="translated">이 옵션은 코드가 다중 스레드 환경에서 안전하게 작동 할 수 있도록 SQLite에 포함되는지 여부를 제어합니다. 기본값은 SQLITE_THREADSAFE = 1이며 멀티 스레드 환경에서 사용하기에 안전합니다. SQLITE_THREADSAFE = 0으로 컴파일하면 모든 뮤텍스 코드가 생략되고 다중 스레드 프로그램에서 SQLite를 사용하는 것은 안전하지 않습니다. SQLITE_THREADSAFE = 2로 컴파일 할 때, 두 개의 스레드가 동일한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (또는 해당 데이터베이스 연결에서 파생 된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문)을&lt;/a&gt; 동시에 사용하려고 시도하지 않는 한 다중 스레드 프로그램에서 SQLite를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2db1e13a20e398e5992253ddd17146aa86ad317" translate="yes" xml:space="preserve">
          <source>This option controls whether temporary files are stored on disk or in memory. The meanings for various settings of this compile-time option are as follows:</source>
          <target state="translated">이 옵션은 임시 파일을 디스크 또는 메모리에 저장할지 여부를 제어합니다. 이 컴파일 타임 옵션의 다양한 설정에 대한 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f480e09e0e7a4b4c8eaae40f24ab8395889d63cf" translate="yes" xml:space="preserve">
          <source>This option disables the ability of SQLite to use an index together with terms of a WHERE clause connected by the OR operator.</source>
          <target state="translated">이 옵션은 SQLite가 OR 연산자로 연결된 WHERE 절의 용어와 함께 색인을 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="bf93493f8d0082c8b326cab559012b486b9691a3" translate="yes" xml:space="preserve">
          <source>This option disables the ability of SQLite to use indices to help resolve &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; and &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; operators in a WHERE clause.</source>
          <target state="translated">이 옵션은 SQLite가 인덱스를 사용 하여 WHERE 절에서 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 연산자를 해결하는 기능을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faffed503a7ff1447f6b122080398e29ed11b00e" translate="yes" xml:space="preserve">
          <source>This option disables the use of compiler-specific built-in functions such as __builtin_bswap32() and __builtin_add_overflow() in GCC and Clang, or _byteswap_ulong() and _ReadWriteBarrier() with MSVC.</source>
          <target state="translated">이 옵션은 GCC 및 Clang의 __builtin_bswap32 () 및 __builtin_add_overflow () 또는 MSVC와 함께 _byteswap_ulong () 및 _ReadWriteBarrier ()와 같은 컴파일러 관련 내장 함수 사용을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="30e5236a00b5a0e3f369da0d4ce09a34450e4f5d" translate="yes" xml:space="preserve">
          <source>This option disables the use of indices with WHERE clause terms that employ the BETWEEN operator.</source>
          <target state="translated">이 옵션은 BETWEEN 연산자를 사용하는 WHERE 절 용어에 인덱스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2b0cbc6ec1854f9e4c7dd19a372c4979cbe3657" translate="yes" xml:space="preserve">
          <source>This option enables &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;several new APIs&lt;/a&gt; that provide callbacks prior to any change to a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. The callbacks can be used to record the state of the row before the change occurs.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블을&lt;/a&gt; 변경하기 전에 콜백을 제공하는 &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;몇 가지 새로운 API&lt;/a&gt; 를 활성화 합니다 . 콜백을 사용하여 변경이 발생하기 전에 행의 상태를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f330069807dae4c09d6cca239bf6220ceecd386" translate="yes" xml:space="preserve">
          <source>This option enables additional logic in the OS interface layer for Mac OS X. The additional logic attempts to determine the type of the underlying filesystem and choose and alternative locking strategy that works correctly for that filesystem type. Five locking strategies are available:</source>
          <target state="translated">이 옵션은 Mac OS X 용 OS 인터페이스 계층에서 추가 논리를 활성화합니다. 추가 논리는 기본 파일 시스템의 유형을 결정하고 해당 파일 시스템 유형에 대해 올바르게 작동하는 대체 잠금 전략을 선택합니다. 5 가지 잠금 전략을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0cda88b35aef2718ccabbc509d1fe578d46ccac" translate="yes" xml:space="preserve">
          <source>This option enables an optimization that omits NULL columns at the ends of rows, for a space savings on disk.</source>
          <target state="translated">이 옵션은 디스크의 공간 절약을 위해 행 끝에서 NULL 열을 생략하는 최적화를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="6f83f444cc87212970d30b59ad548ac739a161e1" translate="yes" xml:space="preserve">
          <source>This option enables an optional ORDER BY and LIMIT clause on &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문 에서 선택적 ORDER BY 및 LIMIT 절을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="e69261024b835708d0d4847720c9f1cf32a794de" translate="yes" xml:space="preserve">
          <source>This option enables extra code (especially the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsqllog&quot;&gt;SQLITE_CONFIG_SQLLOG&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt;) that can be used to create logs of all SQLite processing performed by an application. These logs can be useful in doing off-line analysis of the behavior of an application, and especially for performance analysis. In order for the SQLITE_ENABLE_SQLLOG option to be useful, some extra code is required. The &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_sqllog.c&quot;&gt;&quot;test_sqllog.c&quot;&lt;/a&gt; source code file in the SQLite source tree is a working example of the required extra code. On unix and windows systems, a developer can append the text of the &quot;test_sqllog.c&quot; source code file to the end of an &quot;sqlite3.c&quot; amalgamation, recompile the application using the -DSQLITE_ENABLE_SQLLOG option, then control logging using environment variables. See the header comment on the &quot;test_sqllog.c&quot; source file for additional detail.</source>
          <target state="translated">이 옵션을 사용 하면 애플리케이션에서 수행 한 모든 SQLite 처리 로그를 작성하는 데 사용할 수있는 추가 코드 (특히 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsqllog&quot;&gt;SQLITE_CONFIG_SQLLOG&lt;/a&gt; 옵션 )를 사용할 수 있습니다. 이 로그는 응용 프로그램 동작의 오프라인 분석, 특히 성능 분석에 유용합니다. SQLITE_ENABLE_SQLLOG 옵션을 유용하게 사용하려면 몇 가지 추가 코드가 필요합니다. &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/test_sqllog.c&quot;&gt;&quot;test_sqllog.c&quot;&lt;/a&gt;SQLite 소스 트리의 소스 코드 파일은 필요한 추가 코드의 실제 예입니다. 유닉스 및 윈도우 시스템에서 개발자는 &quot;test_sqllog.c&quot;소스 코드 파일의 텍스트를 &quot;sqlite3.c&quot;통합의 끝에 추가하고 -DSQLITE_ENABLE_SQLLOG 옵션을 사용하여 애플리케이션을 다시 컴파일 한 다음 환경 변수를 사용하여 로깅을 제어 할 수 있습니다. 자세한 내용은 &quot;test_sqllog.c&quot;소스 파일의 헤더 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="274a5f8b5db607c52552d4637956a2899e2617fe" translate="yes" xml:space="preserve">
          <source>This option enables support for the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; SQL 함수를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="93022ac685f42e44c6bd7d7db98fb4366cf5def1" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;bytecodevtab&quot;&gt;bytecode and tables_used virtual tables&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;bytecodevtab&quot;&gt;bytecode 및 tables_used 가상 테이블을&lt;/a&gt; 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="d9a1787f4c945251b506136e6798154b2c122d60" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 인터페이스를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="be87642b57ced8abee8b1950b45aa93d46620bfd" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface is normally omitted from the build because it imposes a small performance penalty, even on statements that do not use the feature.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus ()&lt;/a&gt; 인터페이스를 활성화합니다 . &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus ()&lt;/a&gt; 는 작은 성능 저하를 부과하기 때문에 인터페이스는 일반적으로도이 기능을 사용하지 않는 문에, 빌드에서 생략된다.</target>
        </trans-unit>
        <trans-unit id="51d540f2703b7f49001660035d021722d40f355e" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface and its associated functionality. See the documentation titled &lt;a href=&quot;unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt; for additional information.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스 및 관련 기능을 활성화합니다 . 자세한 내용은 &lt;a href=&quot;unlock_notify&quot;&gt;SQLite 잠금 해제 알림 기능 사용&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d95741cd8a126d1cf356358b77e58a5cff687ae7" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;dbpage&quot;&gt;SQLITE_DBPAGE virtual table&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;dbpage&quot;&gt;SQLITE_DBPAGE 가상 테이블을&lt;/a&gt; 사용 가능하게 합니다 .</target>
        </trans-unit>
        <trans-unit id="67a232ef452eb71b2c364382991ea5fe843a8072" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블을&lt;/a&gt; 활성화 합니다 .</target>
        </trans-unit>
        <trans-unit id="263fe759843f50fd8ce96e059c3daf128b5aa902" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;lang_corefunc#soundex&quot;&gt;soundex() SQL function&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_corefunc#soundex&quot;&gt;soundex () SQL 함수를&lt;/a&gt; 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2f583d286c14b783ea80b9c826f07e649637eb7a" translate="yes" xml:space="preserve">
          <source>This option enables the &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;sessionintro&quot;&gt;세션 확장을&lt;/a&gt; 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="9acfdf9bd0e7a3663dc2bc3825b43b38a145c695" translate="yes" xml:space="preserve">
          <source>This option enables the code to support the &lt;a href=&quot;c3ref/snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; object and its related interfaces:</source>
          <target state="translated">이 옵션을 사용하면 코드에서 &lt;a href=&quot;c3ref/snapshot&quot;&gt;sqlite3_snapshot&lt;/a&gt; 객체 및 관련 인터페이스 를 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="223f501de382821eed41b9386a107ab95a98080f" translate="yes" xml:space="preserve">
          <source>This option enables the two-argument version of the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; interface. The second argument to fts3_tokenizer() is suppose to be a pointer to a function (encoded as a BLOB) that implements an application defined tokenizer. If hostile actors are able to run the two-argument version of fts3_tokenizer() with an arbitrary second argument, they could use crash or take control of the process.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 인터페이스 의 2 인수 버전을 활성화합니다 . fts3_tokenizer ()의 두 번째 인수는 응용 프로그램 정의 토크 나이저를 구현하는 함수 (BLOB로 인코딩 됨)에 대한 포인터라고 가정합니다. 적대 행위자가 임의의 두 번째 인수로 fts3_tokenizer ()의 2 인수 버전을 실행할 수 있으면 충돌을 사용하거나 프로세스를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cc48f6d5950f1e34bb75faacdf1cc192e5f2843" translate="yes" xml:space="preserve">
          <source>This option enables the use of the Windows Heap API functions for memory allocation instead of the standard library malloc() and free() routines.</source>
          <target state="translated">이 옵션을 사용하면 표준 라이브러리 malloc () 및 free () 루틴 대신 메모리 할당에 Windows 힙 API 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5a946f48226950dd966bd130e90484df7d66b6" translate="yes" xml:space="preserve">
          <source>This option forces the Win32 native memory allocator, when enabled, to create a private heap to hold all memory allocations.</source>
          <target state="translated">이 옵션은 Win32 기본 메모리 할당자가 활성화 된 경우 모든 메모리 할당을 보유 할 개인 힙을 작성하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a6e532ac60807302cf761f04099d7e9ae4df7d97" translate="yes" xml:space="preserve">
          <source>This option forces the Win32 native memory allocator, when enabled, to make strategic calls into the HeapValidate() function if assert() is also enabled.</source>
          <target state="translated">이 옵션은 활성화 된 경우 Win32 기본 메모리 할당자가 assert ()도 활성화 된 경우 HeapValidate () 함수를 전략적으로 호출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="38ef15a6ec83783f8e5342533553962834968880" translate="yes" xml:space="preserve">
          <source>This option has no affect on the SQLite core. It is only used by extensions. This is option is necessary for the compression and decompression functions that are part of &lt;a href=&quot;sqlar&quot;&gt;SQL Archive&lt;/a&gt; support in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 SQLite 코어에는 영향을 미치지 않습니다. 확장에서만 사용됩니다. 이 옵션은 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 &lt;a href=&quot;sqlar&quot;&gt;SQL 아카이브&lt;/a&gt; 지원의 일부인 압축 및 압축 해제 기능에 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="14c8af9768bd63293fd017249118cc8e97ccdc51" translate="yes" xml:space="preserve">
          <source>This option includes code in SQLite that implements an alternative memory allocator. This alternative memory allocator is only engaged when the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; is used to supply a large chunk of memory from which all memory allocations are taken. The MEMSYS3 memory allocator uses a hybrid allocation algorithm patterned after dlmalloc(). Only one of SQLITE_ENABLE_MEMSYS3 and SQLITE_ENABLE_MEMSYS5 may be enabled at once.</source>
          <target state="translated">이 옵션은 대체 메모리 할당자를 구현하는 SQLite의 코드를 포함합니다. 이 대체 메모리 할당자는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; 옵션을 사용하여 모든 메모리 할당이 수행되는 대량의 메모리 청크를 제공하는 경우에만 사용됩니다. MEMSYS3 메모리 할당자는 dlmalloc () 다음에 패턴 화 된 하이브리드 할당 알고리즘을 사용합니다. SQLITE_ENABLE_MEMSYS3 및 SQLITE_ENABLE_MEMSYS5 중 하나만 한 번에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec14e9ee089db4506386b040d7a0d29749f6e52a" translate="yes" xml:space="preserve">
          <source>This option includes code in SQLite that implements an alternative memory allocator. This alternative memory allocator is only engaged when the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; is used to supply a large chunk of memory from which all memory allocations are taken. The MEMSYS5 module rounds all allocations up to the next power of two and uses a first-fit, buddy-allocator algorithm that provides strong guarantees against fragmentation and breakdown subject to certain operating constraints.</source>
          <target state="translated">이 옵션은 대체 메모리 할당자를 구현하는 SQLite의 코드를 포함합니다. 이 대체 메모리 할당자는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; 옵션을 사용하여 모든 메모리 할당이 수행되는 대량의 메모리 청크를 제공하는 경우에만 사용됩니다. MEMSYS5 모듈은 모든 할당을 다음 2의 제곱으로 반올림하고 특정 작동 제약 조건에 따라 조각화 및 분류에 대해 강력한 보장을 제공하는 1 차 적합 버디 할당 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b2d0fc0af3baf2bb6313e04cb3b2c292231a6d89" translate="yes" xml:space="preserve">
          <source>This option is no longer used for anything. It is a no-op.</source>
          <target state="translated">이 옵션은 더 이상 어떤 용도로도 사용되지 않습니다. 이건 안돼.</target>
        </trans-unit>
        <trans-unit id="4f0d5394036aa4f4e95f3e2cab1f066c690e694f" translate="yes" xml:space="preserve">
          <source>This option is obsolete. It used to enable some extra some extra PRAGMA statements such as &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;, but those pragmas are now all enabled by default. See &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt; 와 같은 일부 추가 PRAGMA 문을 활성화하는 데 사용 되었지만 이제 해당 pragma는 모두 기본적으로 활성화되어 있습니다. &lt;a href=&quot;compile#omit_introspection_pragmas&quot;&gt;SQLITE_OMIT_INTROSPECTION_PRAGMAS를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d64e8ca0a51fe592b5c0aacc258d17bc062a414" translate="yes" xml:space="preserve">
          <source>This option is omits the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; feature. When this is macro is defined, columns declared as &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; AUTOINCREMENT&quot; behave in the same way as columns declared as &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;&quot; when a NULL is inserted. The sqlite_sequence system table is neither created, nor respected if it already exists.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 기능을 생략합니다 . 매크로가 정의되면 &quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; AUTOINCREMENT&quot;로 선언 된 열은 NULL이 삽입 될 때 &quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; &quot; 로 선언 된 열과 동일한 방식으로 작동합니다 . sqlite_sequence 시스템 테이블은 작성되지 않으며 이미 존재하는 경우 존중되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35532e84bec206bb40c52a637418126e7ac12604" translate="yes" xml:space="preserve">
          <source>This option is only available if sqlite is compiled with the &lt;a href=&quot;../compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt; pre-processor macro defined. The first argument should be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int). The second should be of type (void*). The callback is invoked by the library in three separate circumstances, identified by the value passed as the fourth parameter. If the fourth parameter is 0, then the database connection passed as the second argument has just been opened. The third argument points to a buffer containing the name of the main database file. If the fourth parameter is 1, then the SQL statement that the third parameter points to has just been executed. Or, if the fourth parameter is 2, then the connection being passed as the second parameter is being closed. The third parameter is passed NULL In this case. An example of using this configuration option can be seen in the &quot;test_sqllog.c&quot; source file in the canonical SQLite source tree.</source>
          <target state="translated">이 옵션은 sqlite가 &lt;a href=&quot;../compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG로&lt;/a&gt; 컴파일 된 경우에만 사용 가능합니다.전 처리기 매크로가 정의되었습니다. 첫 번째 인수는 void (*) (void *, sqlite3 *, const char *, int) 유형의 함수에 대한 포인터 여야합니다. 두 번째는 (void *) 유형이어야합니다. 콜백은 세 가지 개별 환경에서 라이브러리에 의해 호출되며 네 번째 매개 변수로 전달 된 값으로 식별됩니다. 네 번째 매개 변수가 0이면 두 번째 인수로 전달 된 데이터베이스 연결이 열린 것입니다. 세 번째 인수는 기본 데이터베이스 파일 이름이 포함 된 버퍼를 가리 킵니다. 네 번째 매개 변수가 1이면 세 번째 매개 변수가 가리키는 SQL 문이 방금 실행 된 것입니다. 또는 네 번째 매개 변수가 2이면 두 번째 매개 변수가 닫힐 때 연결이 전달됩니다. 이 경우 세 번째 매개 변수는 NULL로 전달됩니다. 이 구성 옵션을 사용하는 예는 &quot;test_sqllog.c&quot;에서 확인할 수 있습니다.표준 SQLite 소스 트리의 소스 파일</target>
        </trans-unit>
        <trans-unit id="3370b57f53a2cc0599282e4a4706bd9d78d8e68e" translate="yes" xml:space="preserve">
          <source>This option is only available if sqlite is compiled with the &lt;a href=&quot;compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG&lt;/a&gt; pre-processor macro defined. The first argument should be a pointer to a function of type void(*)(void*,sqlite3*,const char*, int). The second should be of type (void*). The callback is invoked by the library in three separate circumstances, identified by the value passed as the fourth parameter. If the fourth parameter is 0, then the database connection passed as the second argument has just been opened. The third argument points to a buffer containing the name of the main database file. If the fourth parameter is 1, then the SQL statement that the third parameter points to has just been executed. Or, if the fourth parameter is 2, then the connection being passed as the second parameter is being closed. The third parameter is passed NULL In this case. An example of using this configuration option can be seen in the &quot;test_sqllog.c&quot; source file in the canonical SQLite source tree.</source>
          <target state="translated">이 옵션은 sqlite가 &lt;a href=&quot;compile#enable_sqllog&quot;&gt;SQLITE_ENABLE_SQLLOG로&lt;/a&gt;전 처리기 매크로가 정의되었습니다. 첫 번째 인수는 void (*) (void *, sqlite3 *, const char *, int) 유형의 함수에 대한 포인터 여야합니다. 두 번째는 (void *) 유형이어야합니다. 콜백은 세 가지 개별 환경에서 라이브러리에 의해 호출되며 네 번째 매개 변수로 전달 된 값으로 식별됩니다. 네 번째 매개 변수가 0이면 두 번째 인수로 전달 된 데이터베이스 연결이 열린 것입니다. 세 번째 인수는 기본 데이터베이스 파일 이름이 포함 된 버퍼를 가리 킵니다. 네 번째 매개 변수가 1이면 세 번째 매개 변수가 가리키는 SQL 문이 방금 실행 된 것입니다. 또는 네 번째 매개 변수가 2이면 두 번째 매개 변수가 닫힐 때 연결이 전달됩니다. 이 경우 세 번째 매개 변수는 NULL로 전달됩니다. 이 구성 옵션을 사용하는 예는 &quot;test_sqllog.c&quot;에서 확인할 수 있습니다.표준 SQLite 소스 트리의 소스 파일</target>
        </trans-unit>
        <trans-unit id="dd9b28b9e3c685c0ebb9d5ffb873be86ed7e4a11" translate="yes" xml:space="preserve">
          <source>This option is typically used when building SQLite for an embedded platform with a custom operating system.</source>
          <target state="translated">이 옵션은 일반적으로 사용자 정의 운영 체제가있는 임베디드 플랫폼 용 SQLite를 빌드 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2457ea19543336e39ab5ad959ce6c6fc2134a1fe" translate="yes" xml:space="preserve">
          <source>This option is used to change the name of the &quot;main&quot; database schema. The sole argument is a pointer to a constant UTF8 string which will become the new schema name in place of &quot;main&quot;. SQLite does not make a copy of the new main schema name string, so the application must ensure that the argument passed into this DBCONFIG option is unchanged until after the database connection closes.</source>
          <target state="translated">이 옵션은 &quot;기본&quot;데이터베이스 스키마의 이름을 변경하는 데 사용됩니다. 유일한 인수는 상수 UTF8 문자열에 대한 포인터이며 &quot;main&quot;대신 새 스키마 이름이됩니다. SQLite는 새로운 기본 스키마 이름 문자열의 복사본을 만들지 않으므로 응용 프로그램은 데이터베이스 연결이 종료 될 때까지이 DBCONFIG 옵션에 전달 된 인수가 변경되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="39287b1bd3b31dd8abed9ad5de5fbf18b92fbab1" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable triggers, positive to enable triggers or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether triggers are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the trigger setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 를 활성화 또는 비활성화하는 데 사용 됩니다 . 두 개의 추가 인수가 있어야합니다. 첫 번째 인수는 트리거를 비활성화하려면 0이고, 트리거를 활성화하려면 양수, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는이 호출에 따라 트리거를 사용할 수 있는지 여부를 표시하기 위해 0 또는 1로 작성된 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며이 경우 트리거 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05b777e4219204f514426e561a55ff3f15bc7095" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;../lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../lang_createview&quot;&gt;보기&lt;/a&gt; 를 활성화 또는 비활성화하는 데 사용됩니다 . 두 개의 추가 인수가 있어야합니다. 첫 번째 인수는보기를 비활성화하려면 0이고,보기를 활성화하려면 양수, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는이 호출에 따라보기를 사용할 수 있는지 여부를 표시하기 위해 0 또는 1로 작성된 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며이 경우보기 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c7692bc9a975790e68229b265337d4ffba19ed3" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable triggers, positive to enable triggers or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether triggers are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the trigger setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 를 활성화 또는 비활성화하는 데 사용 됩니다 . 두 개의 추가 인수가 있어야합니다. 첫 번째 인수는 트리거를 비활성화하려면 0이고, 트리거를 활성화하려면 양수, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는이 호출에 따라 트리거를 사용할 수 있는지 여부를 표시하기 위해 0 또는 1로 작성된 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며이 경우 트리거 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a79afada1e049dc560306db03b875b605d30773" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable views, positive to enable views or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether views are disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the view setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_createview&quot;&gt;보기&lt;/a&gt; 를 활성화 또는 비활성화하는 데 사용됩니다 . 두 개의 추가 인수가 있어야합니다. 첫 번째 인수는보기를 비활성화하려면 0이고,보기를 활성화하려면 양수, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는이 호출에 따라보기를 사용할 수 있는지 여부를 표시하기 위해 0 또는 1로 작성된 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며이 경우보기 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1d1e7d85a436fe8e6a223e6a43f70bf20bcb28e" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface independently of the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function. The &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; API enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수와 독립적으로 &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스 를 활성화 또는 비활성화하는 데 사용됩니다 . &lt;a href=&quot;#sqlite3_enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; API는 비활성화 모두 C-API의 또는 수 &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 와 SQL 함수를&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt; ) (load_extension를&lt;/a&gt;. 두 개의 추가 인수가 있어야합니다. 이 인터페이스에 대한 첫 번째 인수가 1이면 C-API 만 사용 가능하고 SQL 기능은 사용 불가능하게 유지됩니다. 이 인터페이스의 첫 번째 인수가 0이면 C-API 및 SQL 함수가 모두 사용되지 않습니다. 첫 번째 인수가 -1이면 C-API 또는 SQL 함수의 상태가 변경되지 않습니다. 두 번째 매개 변수는 있는지 여부를 나타 내기 위해 0 또는 1로 쓰여지는 정수에 대한 포인터&lt;a href=&quot;#sqlite3_load_extension&quot;&gt;&lt;/a&gt;이 호출 후에 sqlite3_load_extension () 인터페이스가 비활성화되거나 활성화됩니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며,이 경우 새 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="053a078eadb0638cfc133802b1e15bd819ee981c" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;../fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function which is part of the &lt;a href=&quot;../fts3&quot;&gt;FTS3&lt;/a&gt; full-text search engine extension. There should be two additional arguments. The first argument is an integer which is 0 to disable fts3_tokenizer() or positive to enable fts3_tokenizer() or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../fts3&quot;&gt;FTS3&lt;/a&gt; 전체 텍스트 검색 엔진 확장의 일부인 &lt;a href=&quot;../fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 함수 를 활성화 또는 비활성화하는 데 사용됩니다 . 추가 인수가 두 개 있어야합니다. 첫 번째 인수는 fts3_tokenizer ()를 비활성화하려면 0이고, fts3_tokenizer ()를 활성화하려면 양수이거나 설정을 변경하지 않은 채로 음수 인 정수입니다. 두 번째 매개 변수는이 호출에 따라 fts3_tokenizer가 비활성화되어 있는지 여부를 나타 내기 위해 0 또는 1로 쓰여지는 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며,이 경우 새 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0aba264fcea35dcf7c8427203d720dc08ab19f9c" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function which is part of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; full-text search engine extension. There should be two additional arguments. The first argument is an integer which is 0 to disable fts3_tokenizer() or positive to enable fts3_tokenizer() or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether fts3_tokenizer is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 전체 텍스트 검색 엔진 확장의 일부인 &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 함수 를 활성화 또는 비활성화하는 데 사용됩니다 . 추가 인수가 두 개 있어야합니다. 첫 번째 인수는 fts3_tokenizer ()를 비활성화하려면 0이고, fts3_tokenizer ()를 활성화하려면 양수이거나 설정을 변경하지 않은 채로 음수 인 정수입니다. 두 번째 매개 변수는이 호출에 따라 fts3_tokenizer가 비활성화되어 있는지 여부를 나타 내기 위해 0 또는 1로 쓰여지는 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며,이 경우 새 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b4986571e9b0fde1f22dd6aa95c6a58bcc8dce7" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface independently of the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function. The &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; API enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. There should be two additional arguments. When the first argument to this interface is 1, then only the C-API is enabled and the SQL function remains disabled. If the first argument to this interface is 0, then both the C-API and the SQL function are disabled. If the first argument is -1, then no changes are made to state of either the C-API or the SQL function. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface is disabled or enabled following this call. The second parameter may be a NULL pointer, in which case the new setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()&lt;/a&gt; SQL 함수와 독립적으로 &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스 를 활성화 또는 비활성화하는 데 사용됩니다 . &lt;a href=&quot;enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; API는 비활성화 모두 C-API의 또는 수 &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 와 SQL 함수&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt; ) (load_extension를&lt;/a&gt;. 두 개의 추가 인수가 있어야합니다. 이 인터페이스에 대한 첫 번째 인수가 1이면 C-API 만 사용 가능하고 SQL 기능은 사용 불가능하게 유지됩니다. 이 인터페이스의 첫 번째 인수가 0이면 C-API 및 SQL 함수가 모두 사용되지 않습니다. 첫 번째 인수가 -1이면 C-API 또는 SQL 함수의 상태가 변경되지 않습니다. 두 번째 매개 변수는 이 호출에 따라 &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스가 비활성화되어 있는지 여부를 나타 내기 위해 0 또는 1로 쓰여지는 정수에 대한 포인터 입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며,이 경우 새 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7217434ff65eb94c32bf308c55b512fbfab6001b" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the enforcement of &lt;a href=&quot;../foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable FK enforcement, positive to enable FK enforcement or negative to leave FK enforcement unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether FK enforcement is off or on following this call. The second parameter may be a NULL pointer, in which case the FK enforcement setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;../foreignkeys&quot;&gt;외래 키 제약 조건을&lt;/a&gt; 적용하거나 해제하는 데 사용됩니다 . 추가 인수가 두 개 있어야합니다. 첫 번째 인수는 FK 시행을 비활성화하려면 0, FK 시행을 활성화하려면 양수, FK 시행을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는 FK 시행이 해제되어 있는지 여부를 나타 내기 위해 0 또는 1로 쓰여지는 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며,이 경우 FK 시행 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e9535dd92f396e0ccd9b1725779ad05f2042542" translate="yes" xml:space="preserve">
          <source>This option is used to enable or disable the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. There should be two additional arguments. The first argument is an integer which is 0 to disable FK enforcement, positive to enable FK enforcement or negative to leave FK enforcement unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether FK enforcement is off or on following this call. The second parameter may be a NULL pointer, in which case the FK enforcement setting is not reported back.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건을&lt;/a&gt; 적용하거나 해제하는 데 사용됩니다 . 추가 인수가 두 개 있어야합니다. 첫 번째 인수는 FK 시행을 비활성화하려면 0, FK 시행을 활성화하려면 양수, FK 시행을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는 FK 시행이 해제되어 있는지 여부를 나타 내기 위해 0 또는 1로 쓰여지는 정수에 대한 포인터입니다. 두 번째 매개 변수는 NULL 포인터 일 수 있으며,이 경우 FK 시행 설정이 다시보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b25224fdc16ddfe6de8238e7f19837e56d45d01c" translate="yes" xml:space="preserve">
          <source>This option is used to omit floating-point number support from the SQLite library. When specified, specifying a floating point number as a literal (i.e. &quot;1.01&quot;) results in a parse error.</source>
          <target state="translated">이 옵션은 SQLite 라이브러리에서 부동 소수점 숫자 지원을 생략하는 데 사용됩니다. 지정된 경우 부동 소수점 숫자를 리터럴 (예 : &quot;1.01&quot;)로 지정하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="299a6909399a8b4b26dc341e805951ee902fb9f9" translate="yes" xml:space="preserve">
          <source>This option is used to omit the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; functionality. See also: &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 색인&lt;/a&gt; 기능 을 생략하는 데 사용됩니다 . &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4b919b2428e6408085cdcd9e60a16588061b220" translate="yes" xml:space="preserve">
          <source>This option is used to omit the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; command from the library. Note that it is useful to define the macros that omit specific pragmas in addition to this, as they may also remove supporting code in other sub-systems. This macro removes the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; command only.</source>
          <target state="translated">이 옵션은 라이브러리에서 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 명령 을 생략하는 데 사용됩니다 . 다른 서브 시스템에서 지원 코드를 제거 할 수 있으므로이 외에도 특정 pragma를 생략하는 매크로를 정의하는 것이 유용합니다. 이 매크로는 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 명령 만 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="9c62439be8833757141bf29ba12fcdc5e143f4a3" translate="yes" xml:space="preserve">
          <source>This option is used to omit the compile-time option diagnostics available in SQLite, including the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ functions, the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions, and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get ()&lt;/a&gt; C / C ++ 함수, &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; SQL 함수 및 &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma를&lt;/a&gt; 포함하여 SQLite에서 사용 가능한 컴파일 시간 옵션 진단을 생략하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="38860900c0578b43980895e455bb7920237198bd" translate="yes" xml:space="preserve">
          <source>This option is used to omit the compound &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; functionality. &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements that use the UNION, UNION ALL, INTERSECT or EXCEPT compound SELECT operators will cause a parse error.</source>
          <target state="translated">이 옵션은 복합 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 기능 을 생략하는 데 사용됩니다 . UNION, UNION ALL, INTERSECT 또는 EXCEPT 복합 SELECT 연산자를 사용하는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문은 구문 분석 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1fef9193f2041138de94b7a55c6ac0d8866c0350" translate="yes" xml:space="preserve">
          <source>This option is used to specify additional unicode characters that should be considered as separator characters, even if they are token characters according to Unicode 6.1. All characters in the string that this option is set to are considered separators.</source>
          <target state="translated">이 옵션은 유니 코드 6.1에 따라 토큰 문자 인 경우에도 분리 문자로 간주되어야하는 추가 유니 코드 문자를 지정하는 데 사용됩니다. 이 옵션이 설정되어있는 문자열의 모든 문자는 구분 기호로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b4d01f5260497e72988e92e809b28f4e71ef175b" translate="yes" xml:space="preserve">
          <source>This option is used to specify additional unicode characters that should be considered token characters, even if they are white-space or punctuation characters according to Unicode 6.1. All characters in the string that this option is set to are considered token characters.</source>
          <target state="translated">이 옵션은 유니 코드 6.1에 따라 공백 또는 문장 부호 문자 인 경우에도 토큰 문자로 간주되어야하는 추가 유니 코드 문자를 지정하는 데 사용됩니다. 이 옵션이 설정되어있는 문자열의 모든 문자는 토큰 문자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c4a9266d00b4e2d968e68127ae9c3b66b98515c7" translate="yes" xml:space="preserve">
          <source>This option is used to specify the name of a column for which data is not indexed. Values stored in columns that are not indexed are not matched by MATCH queries. Nor are they recognized by auxiliary functions. A single CREATE VIRTUAL TABLE statement may have any number of notindexed options.</source>
          <target state="translated">이 옵션은 데이터가 색인화되지 않은 열 이름을 지정하는 데 사용됩니다. 인덱싱되지 않은 열에 저장된 값은 MATCH 쿼리와 일치하지 않습니다. 보조 기능으로 인식되지도 않습니다. 단일 CREATE VIRTUAL TABLE 문에는 여러 개의 색인화되지 않은 옵션이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4091aa76a32dd6eeb30d11ba0fc9616111651aa8" translate="yes" xml:space="preserve">
          <source>This option is used to specify the uncompress function. It is an error to specify an uncompress function without also specifying a compress function. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">이 옵션은 압축 해제 기능을 지정하는 데 사용됩니다. 압축 기능을 지정하지 않고 압축 해제 기능을 지정하면 오류가 발생합니다. &lt;a href=&quot;fts3#the_compress_and_uncompress_options&quot;&gt;자세한 내용은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="27d1b2d9a48342fb7ec198ba4551e4f29a4a7923" translate="yes" xml:space="preserve">
          <source>This option is useful for detecting when applications (incorrectly) assume that the order of rows in a SELECT without an ORDER BY clause will always be the same.</source>
          <target state="translated">이 옵션은 응용 프로그램이 ORDER BY 절이없는 SELECT의 행 순서가 항상 동일하다고 가정하는 경우를 감지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b8889fe26abbab5acf6f1b3b96ae4522f63cbd2c" translate="yes" xml:space="preserve">
          <source>This option limits the maximum width and precision of substitutions for the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; and the other C-language string formatting functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;. This is turn can prevent a hostile or malfunctioning script from using excessive memory by invoking a format such as: &quot;&lt;code&gt;printf('%*s',2147483647,'hi')&lt;/code&gt;&quot;. A value for</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf () SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; 와 같은 기타 C 언어 문자열 형식화 함수에 대한 대체의 최대 너비 및 정밀도를 제한합니다 . 이 차례는 &quot; &lt;code&gt;printf('%*s',2147483647,'hi')&lt;/code&gt; &quot; 와 같은 형식을 호출하여 적대적이거나 오작동하는 스크립트가 과도한 메모리를 사용하는 것을 방지 할 수 있습니다 . 가치</target>
        </trans-unit>
        <trans-unit id="543b32c3fbd0d24e0024e6fd7c7c17a61e1a7b3f" translate="yes" xml:space="preserve">
          <source>This option limits the total amount of memory that SQLite will request from malloc() to</source>
          <target state="translated">이 옵션은 SQLite가 malloc ()에서 요청할 메모리의 총량을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="0ff916221ebb2875958a4c995a621fdfe504377b" translate="yes" xml:space="preserve">
          <source>This option may be defined to omit the capability to issue &quot;progress&quot; callbacks during long-running SQL statements. The &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; API function is not present in the library.</source>
          <target state="translated">이 옵션은 장기 실행 SQL 문 중에 &quot;진행&quot;콜백을 발행하는 기능을 생략하도록 정의 될 수 있습니다. &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; API 함수는 라이브러리에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fec09e7b8a97b18d234467bbff1f92f5f877270a" translate="yes" xml:space="preserve">
          <source>This option may be set to a comma-separated list of positive non-zero integers. For each integer N in the list, a separate index is created in the database file to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; where the query term is N bytes in length, not including the '*' character, when encoded using UTF-8. &lt;a href=&quot;fts3#the_prefix_option&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">이 옵션은 0이 아닌 양의 정수로 쉼표로 구분 된 목록으로 설정 될 수 있습니다. 목록의 각 정수 N에 대해 UTF-8을 사용하여 인코딩 된 경우 쿼리 용어 길이가 '*'문자를 포함하지 않는 N 바이트 인 &lt;a href=&quot;fts3#termprefix&quot;&gt;접두어 쿼리&lt;/a&gt; 를 최적화하기 위해 데이터베이스 파일에 별도의 인덱스가 작성됩니다 . &lt;a href=&quot;fts3#the_prefix_option&quot;&gt;자세한 내용은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c9f3ac023e577c95d719f9b2c33d97d1a3da596" translate="yes" xml:space="preserve">
          <source>This option may be used to modify the set of Unicode general categories that are considered to correspond to token characters. The argument must consist of a space separated list of two-character general category abbreviations (e.g. &quot;Lu&quot; or &quot;Nd&quot;), or of the same with the second character replaced with an asterisk (&quot;*&quot;), interpreted as a glob pattern. The default value is &quot;L* N* Co&quot;.</source>
          <target state="translated">이 옵션은 토큰 문자에 해당하는 것으로 간주되는 유니 코드 일반 범주 세트를 수정하는 데 사용될 수 있습니다. 인수는 공백으로 구분 된 두 문자 일반 범주 약어 (예 : &quot;Lu&quot;또는 &quot;Nd&quot;) 목록으로 구성되거나 두 번째 문자와 별표 ( &quot;*&quot;)로 대체되어 동일 패턴으로 해석되어야합니다. . 기본값은 &quot;L * N * Co&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="9c262753dfc8e34d6477e70174470eb22dfb8f78" translate="yes" xml:space="preserve">
          <source>This option modifies the query pattern parser in FTS3 such that it supports operators AND and NOT (in addition to the usual OR and NEAR) and also allows query expressions to contain nested parenthesis.</source>
          <target state="translated">이 옵션은 FTS3에서 쿼리 패턴 파서를 수정하여 연산자 AND 및 NOT (일반적인 OR 및 NEAR 외에)을 지원하고 쿼리 식에 중첩 된 괄호를 포함 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="6d1184a1fad2aaee9c295bffada9d4dba260e364" translate="yes" xml:space="preserve">
          <source>This option omits all support for writing to the disk and forces databases to exist in memory only. This option has not been maintained and probably does not work with newer versions of SQLite.</source>
          <target state="translated">이 옵션은 디스크 쓰기에 대한 모든 지원을 생략하고 데이터베이스가 메모리에만 존재하도록합니다. 이 옵션은 유지 관리되지 않았으며 최신 버전의 SQLite에서는 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50a1abc30b4ee91bf9953df50f6ee0d6dc4cb18c" translate="yes" xml:space="preserve">
          <source>This option omits an alternative, faster B-Tree balancing routine. Using this option makes SQLite slightly smaller at the expense of making it run slightly slower.</source>
          <target state="translated">이 옵션은 더 빠른 대안 B-Tree 밸런싱 루틴을 생략합니다. 이 옵션을 사용하면 SQLite를 약간 느리게 실행하여 비용을 약간 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d570b3f8ad95b26858fd7fbeddae0dd0f1ac312a" translate="yes" xml:space="preserve">
          <source>This option omits both the &lt;a href=&quot;malloc#defaultalloc&quot;&gt;default memory allocator&lt;/a&gt; and the &lt;a href=&quot;malloc#memdebug&quot;&gt;debugging memory allocator&lt;/a&gt; from the build and substitutes a stub memory allocator that always fails. SQLite will not run with this stub memory allocator since it will be unable to allocate memory. But this stub can be replaced at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) or &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt;,...). So the net effect of this compile-time option is that it allows SQLite to be compiled and linked against a system library that does not support malloc(), free(), and/or realloc().</source>
          <target state="translated">이 옵션은 빌드에서 &lt;a href=&quot;malloc#defaultalloc&quot;&gt;기본 메모리 할당 자&lt;/a&gt; 와 &lt;a href=&quot;malloc#memdebug&quot;&gt;디버깅 메모리 할당 &lt;/a&gt;자를 모두 생략 하고 항상 실패하는 스텁 메모리 할당자를 대체합니다. SQLite는 메모리를 할당 할 수 없으므로이 스텁 메모리 할당 자와 함께 실행되지 않습니다. 그러나이 스텁은 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC를&lt;/a&gt; 사용하여 시작시 교체 할 수 있습니다. , ...) 또는 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; , ...)를 . 따라서이 컴파일 타임 옵션의 효과는 malloc (), free () 및 / 또는 realloc ()을 지원하지 않는 시스템 라이브러리에 대해 SQLite를 컴파일하고 링크 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5550296bc5b898d8389bff0bafe61564efcdf3d2" translate="yes" xml:space="preserve">
          <source>This option omits support for &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integer literals&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;lang_expr#hexint&quot;&gt;16 진 정수 리터럴에&lt;/a&gt; 대한 지원을 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="1f67843c3cb518fbe115dfafaf7514809b870ff9" translate="yes" xml:space="preserve">
          <source>This option omits support for &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_module_list&quot;&gt;PRAGMA module_list&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;pragma#pragma_function_list&quot;&gt;PRAGMA function_list에&lt;/a&gt; 대한 지원을 생략 합니다 .&lt;a href=&quot;pragma#pragma_module_list&quot;&gt; PRAGMA module_list&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_pragma_list&quot;&gt;PRAGMA pragma_list에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a55821b0db5795de6378b285741aad2fe64bd6fd" translate="yes" xml:space="preserve">
          <source>This option omits support for TEMP or TEMPORARY tables.</source>
          <target state="translated">이 옵션은 TEMP 또는 TEMPORARY 테이블에 대한 지원을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="75dd747eb6da7034a4b5f9d3b3a93668de880788" translate="yes" xml:space="preserve">
          <source>This option omits support for a subset of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands that query and set boolean properties.</source>
          <target state="translated">이 옵션은 하위 집합에 대한 지원을 생략합니다. &lt;a href=&quot;pragma#syntax&quot;&gt;&lt;/a&gt; 부울 특성을 조회하고 설정하는 PRAGMA 명령 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e296396a40210ed6c66f92e2002f5643c4f4856" translate="yes" xml:space="preserve">
          <source>This option omits support for optimizations that help statements of the form &quot;INSERT INTO ... SELECT ...&quot; run faster.</source>
          <target state="translated">이 옵션은 &quot;INSERT INTO ... SELECT ...&quot;형식의 명령문이 더 빠르게 실행되도록 도와주는 최적화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9bd65d56ee2206a853b54ac9d65ed0eaccc6228" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; and &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interfaces and their associated logic.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()에&lt;/a&gt; 대한 지원을 생략합니다. 인터페이스 및 관련 논리에 .</target>
        </trans-unit>
        <trans-unit id="a30f0d1d064421d344c9b42be2dca6717bf88cb6" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;c3ref/vtab&quot;&gt;Virtual Table&lt;/a&gt; mechanism in SQLite.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/vtab&quot;&gt;가상 테이블에&lt;/a&gt; 대한 지원을 생략합니다. SQLite에서 메커니즘에 .</target>
        </trans-unit>
        <trans-unit id="26d721f7d82f01b797a61e0e7e4801b3ecce9f78" translate="yes" xml:space="preserve">
          <source>This option omits support for the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma에&lt;/a&gt; 대한 지원을 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="39729a96f5a26c118c51c00f252de6a1bfa6274f" translate="yes" xml:space="preserve">
          <source>This option omits the &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; (a.k.a. &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;) capability.</source>
          <target state="translated">이 옵션은 &quot; &lt;a href=&quot;wal&quot;&gt;Write-Ahead Log&lt;/a&gt; &quot;(일명 &quot; &lt;a href=&quot;wal&quot;&gt;WAL)를&lt;/a&gt; 생략합니다. &quot;) 기능을 .</target>
        </trans-unit>
        <trans-unit id="7b6f231803998cf650a2af3d3a3a9b9230f13c79" translate="yes" xml:space="preserve">
          <source>This option omits the &quot;localtime&quot; modifier from the date and time functions. This option is sometimes useful when trying to compile the date and time functions on a platform that does not support the concept of local time.</source>
          <target state="translated">이 옵션은 날짜 및 시간 기능에서 &quot;localtime&quot;수정자를 생략합니다. 이 옵션은 현지 시간 개념을 지원하지 않는 플랫폼에서 날짜 및 시간 함수를 컴파일하려고 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d15a997b56bb6d2881d721f3ab9c998f9a495874" translate="yes" xml:space="preserve">
          <source>This option omits the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당자를&lt;/a&gt; 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="71559f53bbfd877c056bb7c4c6ba8f68a92f4b43" translate="yes" xml:space="preserve">
          <source>This option omits the entire extension loading mechanism from SQLite, including &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; and &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스를 포함하여 SQLite에서 전체 확장 로딩 메커니즘을 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="d584fb7ba86013ad6f07889a83d2808e572dd20a" translate="yes" xml:space="preserve">
          <source>This option sets the size limit on &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; files in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;persistent journal mode&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; and on the size of the write-ahead log file in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. When this compile-time option is omitted there is no upper bound on the size of the rollback journals or write-ahead logs. The journal file size limit can be changed at run-time using the &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma&lt;/a&gt;.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;지속적 저널 모드&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드의 &lt;/a&gt;&lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 파일 및 &lt;a href=&quot;wal&quot;&gt;WAL 모드의&lt;/a&gt; 미리 쓰기 로그 파일 의 크기 제한을 설정 합니다 . 이 컴파일 타임 옵션이 생략되면 롤백 저널 또는 미리 쓰기 로그의 크기에 상한이 없습니다. 저널 파일 크기 제한은 &lt;a href=&quot;pragma#pragma_journal_size_limit&quot;&gt;journal_size_limit pragma를&lt;/a&gt; 사용하여 런타임에 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ed22f566a23185b972efa8699f5831a4e8d150" translate="yes" xml:space="preserve">
          <source>This option should be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">이 옵션은 &quot;0&quot;, &quot;1&quot;또는 &quot;2&quot;로 설정해야합니다. 기본값은 &quot;1&quot;입니다. &quot;1&quot;또는 &quot;2&quot;로 설정되면 위에서 설명한대로 분음 부호가 라틴어 스크립트 문자에서 제거됩니다. 그러나 &quot;1&quot;로 설정하면 하나의 유니 코드 코드 포인트가 하나 이상의 분음 부호를 갖는 문자를 나타내는 데 사용되는 드문 경우에 분음 부호가 제거되지 않습니다. 예를 들어 분음 부호는 코드 포인트 0x1ED9에서 제거되지 않습니다 ( &quot;CIRCUMFLEX와 DOT 아래의 라틴 문자가 너무 작음&quot;). 이것은 기술적으로 버그이지만 이전 버전과의 호환성 문제를 일으키지 않으면 해결할 수 없습니다. 이 옵션을 &quot;2&quot;로 설정하면 분음 부호가 모든 라틴 문자에서 올바르게 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="feb5bc303a82732e4bebbca22fa198d9bb5a37e5" translate="yes" xml:space="preserve">
          <source>This option takes three additional arguments that determine the &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; configuration for the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument (the third parameter to &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is a pointer to a memory buffer to use for lookaside memory. The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb may be NULL in which case SQLite will allocate the lookaside buffer itself using &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The second argument is the size of each lookaside buffer slot. The third argument is the number of slots. The size of the buffer in the first argument must be greater than or equal to the product of the second and third arguments. The buffer must be aligned to an 8-byte boundary. If the second argument to SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally rounded down to the next smaller multiple of 8. The lookaside memory configuration for a database connection can only be changed when that connection is not currently using lookaside memory, or in other words when the &quot;current value&quot; returned by &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(D,&lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;,...) is zero. Any attempt to change the lookaside memory configuration when lookaside memory is in use leaves the configuration unchanged and returns &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">이 옵션 에는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 &lt;a href=&quot;../malloc#lookaside&quot;&gt;lookaside 메모리 할당 자&lt;/a&gt; 구성을 결정하는 세 개의 추가 인수가 필요합니다 . 첫 번째 인수 ( &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (의 세 번째 매개 변수 ) 는 lookaside 메모리에 사용할 메모리 버퍼에 대한 포인터입니다. SQLITE_DBCONFIG_LOOKASIDE 동사 다음의 첫 번째 인수는 NULL 일 수 있습니다.이 경우 SQLite는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()을&lt;/a&gt; 사용하여 lookaside 버퍼를 할당합니다.. 두 번째 인수는 각 lookaside 버퍼 슬롯의 크기입니다. 세 번째 인수는 슬롯 수입니다. 첫 번째 인수의 버퍼 크기는 두 번째 및 세 번째 인수의 곱보다 크거나 같아야합니다. 버퍼는 8 바이트 경계에 정렬되어야합니다. SQLITE_DBCONFIG_LOOKASIDE의 두 번째 인수가 8의 배수가 아닌 경우 내부적으로 8의 작은 배수로 내림됩니다. 데이터베이스 연결에 대한 lookaside 메모리 구성은 해당 연결이 현재 lookaside 메모리를 사용하지 않거나 즉 , &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status&lt;/a&gt; 에서 &quot;현재 값&quot;을 반환 한 경우 (D, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;, ...)는 0입니다. lookaside 메모리가 사용 중일 때 lookaside 메모리 구성을 변경하려고하면 구성이 변경되지 않고 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ae3ddbf7ef0dc412e99f290afefb3dbddaa1ab55" translate="yes" xml:space="preserve">
          <source>This option takes three additional arguments that determine the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; configuration for the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The first argument (the third parameter to &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; is a pointer to a memory buffer to use for lookaside memory. The first argument after the SQLITE_DBCONFIG_LOOKASIDE verb may be NULL in which case SQLite will allocate the lookaside buffer itself using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The second argument is the size of each lookaside buffer slot. The third argument is the number of slots. The size of the buffer in the first argument must be greater than or equal to the product of the second and third arguments. The buffer must be aligned to an 8-byte boundary. If the second argument to SQLITE_DBCONFIG_LOOKASIDE is not a multiple of 8, it is internally rounded down to the next smaller multiple of 8. The lookaside memory configuration for a database connection can only be changed when that connection is not currently using lookaside memory, or in other words when the &quot;current value&quot; returned by &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(D,&lt;a href=&quot;#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;,...) is zero. Any attempt to change the lookaside memory configuration when lookaside memory is in use leaves the configuration unchanged and returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">이 옵션 에는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자&lt;/a&gt; 구성을 결정하는 세 개의 추가 인수가 필요합니다 . 첫 번째 인수 ( &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (의 세 번째 매개 변수 ) 는 lookaside 메모리에 사용할 메모리 버퍼에 대한 포인터입니다. SQLITE_DBCONFIG_LOOKASIDE 동사 다음의 첫 번째 인수는 NULL 일 수 있습니다.이 경우 SQLite는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()을&lt;/a&gt; 사용하여 lookaside 버퍼를 할당합니다.. 두 번째 인수는 각 lookaside 버퍼 슬롯의 크기입니다. 세 번째 인수는 슬롯 수입니다. 첫 번째 인수의 버퍼 크기는 두 번째 및 세 번째 인수의 곱보다 크거나 같아야합니다. 버퍼는 8 바이트 경계에 정렬되어야합니다. SQLITE_DBCONFIG_LOOKASIDE의 두 번째 인수가 8의 배수가 아닌 경우 내부적으로 8의 작은 배수로 내림됩니다. 데이터베이스 연결에 대한 lookaside 메모리 구성은 해당 연결이 현재 lookaside 메모리를 사용하지 않거나 즉 , &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status&lt;/a&gt; 에서 &quot;현재 값&quot;을 반환 한 경우 (D, &lt;a href=&quot;#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;, ...)는 0입니다. lookaside 메모리가 사용 중일 때 lookaside 메모리 구성을 변경하려고하면 구성이 변경되지 않고 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ba38f20f7029807295f199c46762e2a8e9ec46b2" translate="yes" xml:space="preserve">
          <source>This page contains all C-language interface information in a single HTML file. The same information is also available broken out into &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;lots of small pages&lt;/a&gt; for easier viewing, if you prefer.</source>
          <target state="translated">이 페이지에는 모든 C 언어 인터페이스 정보가 단일 HTML 파일로 포함되어 있습니다. 원하는 경우 동일한 정보를 여러 &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;개의 작은 페이지&lt;/a&gt; 로 나눠서 쉽게 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c894452ecdb5719e75b3532de3158fbd553c90da" translate="yes" xml:space="preserve">
          <source>This page defines the C-language interface to the SQLite &lt;a href=&quot;sessionintro&quot;&gt;session extension&lt;/a&gt;. This is not a tutorial. These pages are designed to be precise, not easy to read. A tutorial is &lt;a href=&quot;sessionintro&quot;&gt;available separately&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 SQLite &lt;a href=&quot;sessionintro&quot;&gt;세션 확장에&lt;/a&gt; 대한 C 언어 인터페이스를 정의합니다 . 이것은 튜토리얼이 아닙니다. 이 페이지는 정확하고 읽기 쉽지 않습니다. 튜토리얼은 &lt;a href=&quot;sessionintro&quot;&gt;별도로 제공됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17b8a8f3cb3fe57cc88a96142bed282e75d22786" translate="yes" xml:space="preserve">
          <source>This page demonstrates how to use triggers to implement undo/redo logic for an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 트리거를 사용하여 SQLite를 &lt;a href=&quot;appfileformat&quot;&gt;애플리케이션 파일 형식&lt;/a&gt; 으로 사용하는 애플리케이션에 대해 실행 취소 / 다시 실행 로직을 구현하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="e34958625ac04bc1ac3a1a6e0735cfa01d4d7986" translate="yes" xml:space="preserve">
          <source>This page highlights some of the characteristics of SQLite that are unusual and which make SQLite different from many other SQL database engines.</source>
          <target state="translated">이 페이지는 비정상적이고 SQLite를 다른 많은 SQL 데이터베이스 엔진과 다르게 만드는 SQLite의 특징 중 일부를 강조합니다.</target>
        </trans-unit>
        <trans-unit id="c95782bb823ae8ab36f53a6f092ceeb01d076bbe" translate="yes" xml:space="preserve">
          <source>This page is intended to be a precise and detailed specification. For a tutorial introductions, see instead:</source>
          <target state="translated">이 페이지는 정확하고 자세한 사양으로 작성되었습니다. 튜토리얼 소개는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fbcb2c48721c5a151bcbee73ca17847e3bcd77c1" translate="yes" xml:space="preserve">
          <source>This page provides a high-level summary of changes to SQLite. For more detail, see the Fossil checkin logs at &lt;a href=&quot;http://www.sqlite.org/src/timeline&quot;&gt; http://www.sqlite.org/src/timeline&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/timeline?t=release&quot;&gt; http://www.sqlite.org/src/timeline?t=release&lt;/a&gt;. See the &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; a succinct listing of releases.</source>
          <target state="translated">이 페이지는 SQLite의 변경 사항에 대한 고급 요약을 제공합니다. 자세한 내용은 &lt;a href=&quot;http://www.sqlite.org/src/timeline&quot;&gt;http://www.sqlite.org/src/timeline&lt;/a&gt; 및 &lt;a href=&quot;http://www.sqlite.org/src/timeline?t=release&quot;&gt;http://www.sqlite.org/src/timeline?t=release&lt;/a&gt; 의 Fossil 체크인 로그를 참조 하십시오 . 간결한 릴리스 목록을 &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;연대기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5475000272cca06dc30e6a01a60b47e85642d9ec" translate="yes" xml:space="preserve">
          <source>This parameter is similar to DBSTATUS_CACHE_USED, except that if a pager cache is shared between two or more connections the bytes of heap memory used by that pager cache is divided evenly between the attached connections. In other words, if none of the pager caches associated with the database connection are shared, this request returns the same value as DBSTATUS_CACHE_USED. Or, if one or more or the pager caches are shared, the value returned by this call will be smaller than that returned by DBSTATUS_CACHE_USED. The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED_SHARED is always 0.</source>
          <target state="translated">이 매개 변수는 호출기 캐시가 둘 이상의 연결간에 공유되는 경우 해당 호출기 캐시에 사용되는 힙 메모리 바이트가 접속 된 연결간에 균등하게 분배된다는 점을 제외하면 DBSTATUS_CACHE_USED와 유사합니다. 즉, 데이터베이스 연결과 연관된 페이저 캐시가 공유되지 않으면이 요청은 DBSTATUS_CACHE_USED와 동일한 값을 리턴합니다. 또는 하나 이상의 호출기 캐시가 공유되는 경우이 호출에서 리턴 된 값은 DBSTATUS_CACHE_USED에서 리턴 된 값보다 작습니다. SQLITE_DBSTATUS_CACHE_USED_SHARED와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="45093e4716ae49eb14650b76fbdcb71b112d6752" translate="yes" xml:space="preserve">
          <source>This parameter is the current amount of memory checked out using &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, either directly or indirectly. The figure includes calls made to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; by the application and internal memory usage by the SQLite library. Auxiliary page-cache memory controlled by &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; is not included in this parameter. The amount returned is the sum of the allocation sizes as reported by the xSize method in &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()을&lt;/a&gt; 사용하여 직접 또는 간접적으로 체크 아웃 된 현재 메모리 양입니다 . 이 그림에는 응용 프로그램에 의한 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에 대한 호출 과 SQLite 라이브러리에 의한 내부 메모리 사용이 포함됩니다. &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 에 의해 제어되는 보조 페이지 캐시 메모리 는이 매개 변수에 포함되지 않습니다. 반환 된 양은 &lt;a href=&quot;#sqlite3_mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 의 xSize 메소드에 의해보고 된 할당 크기의 합입니다 .</target>
        </trans-unit>
        <trans-unit id="01bdf9cb94894d18cc4c5e31ed1dd67a9595bbe8" translate="yes" xml:space="preserve">
          <source>This parameter is the current amount of memory checked out using &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, either directly or indirectly. The figure includes calls made to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; by the application and internal memory usage by the SQLite library. Auxiliary page-cache memory controlled by &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; is not included in this parameter. The amount returned is the sum of the allocation sizes as reported by the xSize method in &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt;.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()을&lt;/a&gt; 사용하여 직접 또는 간접적으로 체크 아웃 된 현재 메모리 양입니다 . 이 그림에는 응용 프로그램에 의한 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에 대한 호출 과 SQLite 라이브러리에 의한 내부 메모리 사용이 포함됩니다. &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 에 의해 제어되는 보조 페이지 캐시 메모리 는이 매개 변수에 포함되지 않습니다. 반환 된 양은 &lt;a href=&quot;mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 의 xSize 메소드에 의해보고 된 할당 크기의 합입니다 .</target>
        </trans-unit>
        <trans-unit id="87bf008f327b3b848c63d8cad43c4d0127a86a19" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; (or their internal equivalents). Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()에&lt;/a&gt; 전달 된 가장 큰 메모리 할당 요청을 기록합니다 (또는 내부 동등 물). &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()에&lt;/a&gt; * pHighwater 매개 변수에 리턴 된 값만 관심이 있습니다. * pCurrent 매개 변수에 기록 된 값은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8177250f0bf5e0ac2bcf219826fc36ccb3e8b06" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache 메모리 할당 자&lt;/a&gt; 에게 전달 된 가장 큰 메모리 할당 요청을 기록합니다 . * pHighwater 매개 변수에서 &lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; 로 리턴 된 값만 관심이 있습니다. * pCurrent 매개 변수에 기록 된 값은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="393f3b702f2e6c0a4e019aad1ee82b57fe72cd84" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; (or their internal equivalents). Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()에&lt;/a&gt; 전달 된 가장 큰 메모리 할당 요청을 기록합니다 (또는 내부 동등 물). &lt;a href=&quot;status&quot;&gt;sqlite3_status ()에&lt;/a&gt; * pHighwater 매개 변수에 리턴 된 값만 관심이 있습니다. * pCurrent 매개 변수에 기록 된 값은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="564d1fbcfc60fdaedbed1032bf2fd462555b60f6" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache 메모리 할당 자&lt;/a&gt; 에게 전달 된 가장 큰 메모리 할당 요청을 기록합니다 . * pHighwater 매개 변수에서 &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; 로 리턴 된 값만 관심이 있습니다. * pCurrent 매개 변수에 기록 된 값은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64d736a9df1c88312c645f6820d596570b17758b" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to the &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache 메모리 할당 자&lt;/a&gt; 에게 전달 된 최대 메모리 할당 요청을 기록합니다 . &lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; 에 대한 * pHighwater 매개 변수에 반환 된 값만 중요합니다. * pCurrent 매개 변수에 기록 된 값이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="12f746ca9a95438a262dd8ecb82737decdd93a0a" translate="yes" xml:space="preserve">
          <source>This parameter records the largest memory allocation request handed to the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt;. Only the value returned in the *pHighwater parameter to &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; is of interest. The value written into the *pCurrent parameter is undefined.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache 메모리 할당 자&lt;/a&gt; 에게 전달 된 최대 메모리 할당 요청을 기록합니다 . &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; 에 대한 * pHighwater 매개 변수에 반환 된 값만 중요합니다. * pCurrent 매개 변수에 기록 된 값이 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="58e7936cbdee9e2eb1bb98fbfe6edbf522e37ef4" translate="yes" xml:space="preserve">
          <source>This parameter records the number of separate memory allocations currently checked out.</source>
          <target state="translated">이 매개 변수는 현재 체크 아웃 된 개별 메모리 할당 수를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="cf9c08cd996cbec55637b0a188d75a636f637583" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap and lookaside memory used by all prepared statements associated with the database connection. The highwater mark associated with SQLITE_DBSTATUS_STMT_USED is always 0.</source>
          <target state="translated">이 매개 변수는 데이터베이스 연결과 연관된 모든 준비된 명령문에서 사용 된 대략적인 힙 및 lookaside 메모리 바이트 수를 리턴합니다. SQLITE_DBSTATUS_STMT_USED와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="ec61ce5ecfd88d74d32d14b1a1a33c077c0d1415" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used by all pager caches associated with the database connection. The highwater mark associated with SQLITE_DBSTATUS_CACHE_USED is always 0.</source>
          <target state="translated">이 매개 변수는 데이터베이스 연결과 연관된 모든 페이저 캐시에서 사용 된 대략적인 힙 메모리 바이트 수를 리턴합니다. SQLITE_DBSTATUS_CACHE_USED와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="f3bc4fe0cf826c482abac176d6762a6d942bb530" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used to store the schema for all databases associated with the connection - main, temp, and any &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed databases. The full amount of memory used by the schemas is reported, even if the schema memory is shared with other database connections due to &lt;a href=&quot;../sharedcache&quot;&gt;shared cache mode&lt;/a&gt; being enabled. The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.</source>
          <target state="translated">이 매개 변수는 연결 (main, temp 및 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH 기반&lt;/a&gt; 데이터베이스)과 연관된 모든 데이터베이스에 대한 스키마를 저장하는 데 사용되는 대략적인 힙 메모리 바이트 수를 리턴 합니다. &lt;a href=&quot;../sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 가 활성화 되어 스키마 메모리가 다른 데이터베이스 연결과 공유 되더라도 스키마가 사용하는 전체 메모리 양이보고 됩니다. SQLITE_DBSTATUS_SCHEMA_USED와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="b848e7fbcecb9e3547155ffa2bb4d624a93e8ec6" translate="yes" xml:space="preserve">
          <source>This parameter returns the approximate number of bytes of heap memory used to store the schema for all databases associated with the connection - main, temp, and any &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed databases. The full amount of memory used by the schemas is reported, even if the schema memory is shared with other database connections due to &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; being enabled. The highwater mark associated with SQLITE_DBSTATUS_SCHEMA_USED is always 0.</source>
          <target state="translated">이 매개 변수는 연결 (main, temp 및 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH 기반&lt;/a&gt; 데이터베이스)과 연관된 모든 데이터베이스에 대한 스키마를 저장하는 데 사용되는 대략적인 힙 메모리 바이트 수를 리턴 합니다. &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 가 활성화 되어 스키마 메모리가 다른 데이터베이스 연결과 공유 되더라도 스키마가 사용하는 전체 메모리 양이보고 됩니다. SQLITE_DBSTATUS_SCHEMA_USED와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="a6814e9402bd718137686f1d55de51f53b7d680a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that might have been satisfied using lookaside memory but failed due to all lookaside memory already being in use. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">이 매개 변수는 lookaside 메모리를 사용하여 만족했지만 이미 사용중인 모든 lookaside 메모리로 인해 실패한 malloc 시도 횟수를 리턴합니다. 만수 값만 의미가 있습니다. 현재 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="a0c69cbe3d9c323ac8bc99255ae1a5f0fdf34b7a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that might have been satisfied using lookaside memory but failed due to the amount of memory requested being larger than the lookaside slot size. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">이 매개 변수는 lookaside 메모리를 사용하여 만족했지만 요청 된 메모리 양이 lookaside 슬롯 크기보다 커서 malloc 시도 횟수를 리턴합니다. 만수 값만 의미가 있습니다. 현재 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="784f52e8abbe06e6dd208856ce82a30603bacb4b" translate="yes" xml:space="preserve">
          <source>This parameter returns the number malloc attempts that were satisfied using lookaside memory. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">이 매개 변수는 lookaside 메모리를 사용하여 만족 한 malloc 시도 횟수를 리턴합니다. 만수 값만 의미가 있습니다. 현재 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="cc0e40686d40fc1dc39dc4ea777a5b751b8b8271" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of bytes of page cache allocation which could not be satisfied by the &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; buffer and where forced to overflow to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The returned value includes allocations that overflowed because they where too large (they were larger than the &quot;sz&quot; parameter to &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;) and allocations that overflowed because no space was left in the page cache.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 버퍼 가 충족 할 수없고 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 으로 오버 플로우 되는 페이지 캐시 할당 바이트 수를 리턴합니다 . 리턴 된 값에는 너무 큰 위치로 인해 오버 플로우 된 할당 ( &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에&lt;/a&gt; 대한 &quot;sz&quot;매개 변수보다 큼 ) 및 페이지 캐시에 공간이 남아 있지 않아 오버 플로우 된 할당이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1df7262bbdc4130b7cdd11ed7c458ceceae08c22" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of bytes of page cache allocation which could not be satisfied by the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; buffer and where forced to overflow to &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The returned value includes allocations that overflowed because they where too large (they were larger than the &quot;sz&quot; parameter to &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;) and allocations that overflowed because no space was left in the page cache.</source>
          <target state="translated">이 매개 변수는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 버퍼 가 충족 할 수없고 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 으로 오버 플로우 되는 페이지 캐시 할당 바이트 수를 리턴합니다 . 리턴 된 값에는 너무 큰 위치로 인해 오버 플로우 된 할당 ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE에&lt;/a&gt; 대한 &quot;sz&quot;매개 변수보다 큼 ) 및 페이지 캐시에 공간이 남아 있지 않아 오버 플로우 된 할당이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b382d85f918ffb35600f5c2612295ce2f5d3c59a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk in the middle of a transaction due to the page cache overflowing. Transactions are more efficient if they are written to disk all at once. When pages spill mid-transaction, that introduces additional overhead. This parameter can be used help identify inefficiencies that can be resolve by increasing the cache size.</source>
          <target state="translated">이 매개 변수는 페이지 캐시 오버 플로우로 인해 트랜잭션 중에 디스크에 기록 된 더티 캐시 항목 수를 리턴합니다. 트랜잭션을 디스크에 한 번에 작성하면보다 효율적입니다. 트랜잭션 중 페이지가 넘치면 추가 오버 헤드가 발생합니다. 이 매개 변수는 캐시 크기를 늘려서 해결할 수있는 비 효율성을 식별하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3475d60ae6206bcbd673ce958d5051acadbef20d" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk in the middle of a transaction due to the page cache overflowing. Transactions are more efficient if they are written to disk all at once. When pages spill mid-transaction, that introduces additional overhead. This parameter can be used help identify inefficiencies that can be resolved by increasing the cache size.</source>
          <target state="translated">이 매개 변수는 페이지 캐시 오버 플로우로 인해 트랜잭션 중간에 디스크에 기록 된 더티 캐시 항목의 수를 리턴합니다. 트랜잭션을 한 번에 디스크에 기록하면 더 효율적입니다. 페이지가 트랜잭션 중간에 넘치면 추가 오버 헤드가 발생합니다. 이 매개 변수는 캐시 크기를 늘려 해결할 수있는 비 효율성을 식별하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4add896ad21b8491b3b9cbc64b507c0e7d258f86" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of dirty cache entries that have been written to disk. Specifically, the number of pages written to the wal file in wal mode databases, or the number of pages written to the database file in rollback mode databases. Any pages written as part of transaction rollback or database recovery operations are not included. If an IO or other error occurs while writing a page to disk, the effect on subsequent SQLITE_DBSTATUS_CACHE_WRITE requests is undefined. The highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.</source>
          <target state="translated">이 매개 변수는 디스크에 작성된 더티 캐시 항목 수를 리턴합니다. 특히, wal 모드 데이터베이스에서 wal 파일에 기록 된 페이지 수 또는 롤백 모드 데이터베이스에서 데이터베이스 파일에 기록 된 페이지 수 트랜잭션 롤백 또는 데이터베이스 복구 작업의 일부로 작성된 페이지는 포함되지 않습니다. 페이지를 디스크에 쓰는 동안 IO 또는 기타 오류가 발생하면 후속 SQLITE_DBSTATUS_CACHE_WRITE 요청에 대한 영향은 정의되지 않습니다. SQLITE_DBSTATUS_CACHE_WRITE와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="69935728c544ae1a697199dc6c173a0425e6fda2" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of lookaside memory slots currently checked out.</source>
          <target state="translated">이 매개 변수는 현재 체크 아웃 된 lookaside 메모리 슬롯 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a266b665a2f2d9def7548328ed2be49c55b4af7e" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of malloc attempts that were satisfied using lookaside memory. Only the high-water value is meaningful; the current value is always zero.</source>
          <target state="translated">이 매개 변수는 lookaside 메모리를 사용하여 충족 된 malloc 시도 수를 리턴합니다. 높은 물 값만 의미가 있습니다. 현재 값은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="c8bdabdecaacb45640f2cbeb00ef8072cec5611a" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pager cache hits that have occurred. The highwater mark associated with SQLITE_DBSTATUS_CACHE_HIT is always 0.</source>
          <target state="translated">이 매개 변수는 발생한 호출기 캐시 적중 수를 리턴합니다. SQLITE_DBSTATUS_CACHE_HIT와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="a1a0936c69215c7750450f05188a928a77f51678" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pager cache misses that have occurred. The highwater mark associated with SQLITE_DBSTATUS_CACHE_MISS is always 0.</source>
          <target state="translated">이 매개 변수는 발생한 호출기 캐시 누락 수를 리턴합니다. SQLITE_DBSTATUS_CACHE_MISS와 관련된 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="62efb57b98feebe4577753d45e38ef4eace35cab" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pages used out of the &lt;a href=&quot;../malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; that was configured using &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The value returned is in pages, not in bytes.</source>
          <target state="translated">이 매개 변수는 밖으로 사용 된 페이지 수를 반환 &lt;a href=&quot;../malloc#pagecache&quot;&gt;페이지 캐시 메모리 할당&lt;/a&gt; 사용하여 구성되었다 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE을&lt;/a&gt; . 리턴 된 값은 바이트가 아니라 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="3d50e93c0353d6a987ae81a3f776523fd382a6cc" translate="yes" xml:space="preserve">
          <source>This parameter returns the number of pages used out of the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; that was configured using &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;. The value returned is in pages, not in bytes.</source>
          <target state="translated">이 매개 변수는 밖으로 사용 된 페이지 수를 반환 &lt;a href=&quot;malloc#pagecache&quot;&gt;페이지 캐시 메모리 할당&lt;/a&gt; 사용하여 구성되었다 &lt;a href=&quot;#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE을&lt;/a&gt; . 리턴 된 값은 바이트가 아니라 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="c53ec125616f6c12d3da713a54e88d2031114fcb" translate="yes" xml:space="preserve">
          <source>This parameter returns zero for the current value if and only if all foreign key constraints (deferred or immediate) have been resolved. The highwater mark is always 0.</source>
          <target state="translated">이 매개 변수는 모든 외래 키 제약 조건 (지연 또는 즉시)이 해결 된 경우에만 현재 값에 대해 0을 반환합니다. 최고 사용 표시 점은 항상 0입니다.</target>
        </trans-unit>
        <trans-unit id="a9b0527c8ca1034e0c3fe99b84c3e116d1b7eb73" translate="yes" xml:space="preserve">
          <source>This particular upper bound is untested since the developers do not have access to hardware capable of reaching this limit. However, tests do verify that SQLite behaves correctly and sanely when a database reaches the maximum file size of the underlying filesystem (which is usually much less than the maximum theoretical database size) and when a database is unable to grow due to disk space exhaustion.</source>
          <target state="translated">개발자가이 한계에 도달 할 수있는 하드웨어에 액세스 할 수 없으므로이 특정 상한은 테스트되지 않습니다. 그러나 테스트는 데이터베이스가 기본 파일 시스템의 최대 파일 크기 (일반적으로 최대 이론적 데이터베이스 크기보다 훨씬 작음)에 도달하고 디스크 공간 부족으로 인해 데이터베이스를 확장 할 수없는 경우 SQLite가 올바르게 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="81929be5939c881096cfb3fe31776e243ea07fe4" translate="yes" xml:space="preserve">
          <source>This pragma can be used to help the ANALYZE command run faster on large databases. The results of analysis are not as good when only part of each index is examined, but the results are usually good enough. Setting N to 100 or 1000 allows the ANALYZE command to run very quickly, even on multi-gigabyte database files. This pragma is particularly useful in combination with &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt;.</source>
          <target state="translated">이 pragma를 사용하면 ANALYZE 명령이 대규모 데이터베이스에서 더 빠르게 실행될 수 있습니다. 각 지수의 일부만 조사하면 분석 결과가 좋지 않지만 일반적으로 결과는 충분합니다. N을 100 또는 1000으로 설정하면 ANALYZE 명령이 멀티 기가 바이트 데이터베이스 파일에서도 매우 빠르게 실행됩니다. 이 pragma는 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 와 함께 사용할 때 특히 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="0657d8e0799efb6b3e706990d12dd141b3fb62ea" translate="yes" xml:space="preserve">
          <source>This pragma can only lower the heap limit, never raise it. The C-language interface &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; must be used to raise the heap limit.</source>
          <target state="translated">이 pragma는 힙 제한 만 낮출 수 있으며 절대 올리지 않습니다. 힙 한계를 높이려면 C 언어 인터페이스 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64 ()를&lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7efda67e025441ca7525899af5b6354ff74a512" translate="yes" xml:space="preserve">
          <source>This pragma causes the database connection on which it is invoked to free up as much memory as it can, by calling &lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 &lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory ()를&lt;/a&gt; 호출하여 호출 된 데이터베이스 연결이 가능한 한 많은 메모리를 비우도록 합니다.</target>
        </trans-unit>
        <trans-unit id="f69354dd852353205605bc71b9cf56c1b9de8e3e" translate="yes" xml:space="preserve">
          <source>This pragma does a low-level formatting and consistency check of the database. The integrity_check pragma look for:</source>
          <target state="translated">이 pragma는 데이터베이스의 저수준 형식화 및 일관성 검사를 수행합니다. integrity_check pragma는 다음을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="f777ea86721cabf6a34809d49c7198fa24090a8b" translate="yes" xml:space="preserve">
          <source>This pragma does an integrity check of the entire database. The integrity_check pragma looks for out-of-order records, missing pages, malformed records, missing index entries, and UNIQUE, CHECK, and NOT NULL constraint errors. If the integrity_check pragma finds problems, strings are returned (as multiple rows with a single column per row) which describe the problems. Pragma integrity_check will return at most</source>
          <target state="translated">이 pragma는 전체 데이터베이스의 무결성 검사를 수행합니다. integrity_check pragma는 비 순차적 레코드, 누락 된 페이지, 잘못된 레코드, 누락 된 색인 항목 및 UNIQUE, CHECK 및 NOT NULL 제한 조건 오류를 찾습니다. integrity_check pragma가 문제점을 발견하면 문제점을 설명하는 문자열이 리턴됩니다 (행당 하나의 열이있는 여러 행으로). Pragma integrity_check는 최대 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="d85860b039a63de256f402e6d6762d68de4406bf" translate="yes" xml:space="preserve">
          <source>This pragma enables or disables the enforcement of CHECK constraints. The default setting is off, meaning that CHECK constraints are enforced by default.</source>
          <target state="translated">이 pragma는 CHECK 제약 조건의 적용을 활성화 또는 비활성화합니다. 기본 설정은 해제되어 있습니다. 즉, CHECK 제약 조건이 기본적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c0f6dec458913f5b6b49b019227adc4aaee9eed" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and N is a positive integer that is less than the current hard heap limit. The hard_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64&lt;/a&gt;(-1) C-language function. That is to say, it always returns the value of the hard heap limit that is set after any changes imposed by this PRAGMA.</source>
          <target state="translated">이 pragma는 N이 지정되고 N이 현재 하드 힙 제한보다 작은 양의 정수인 경우 인수 N과 함께 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64 ()&lt;/a&gt; 인터페이스를 호출합니다 . hard_heap_limit pragma는 항상 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64&lt;/a&gt; (-1) C 언어 함수에서 반환하는 것과 동일한 정수를 반환 합니다. 즉, 항상이 PRAGMA에 의해 적용된 변경 후에 설정된 하드 힙 제한 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bc93e52c19bbd4f2114a2157aba5ec2280234488" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and is a non-negative integer. The soft_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;(-1) C-language function.</source>
          <target state="translated">이 pragma는 N이 지정되고 음이 아닌 정수인 경우 인수 N을 사용하여 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스를 호출합니다 . soft_heap_limit pragma는 항상 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt; (-1) C 언어 함수에서 반환되는 것과 동일한 정수를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="bacd85c546ef4ea41bfa44a9338d7347c9ec6db4" translate="yes" xml:space="preserve">
          <source>This pragma invokes the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface with the argument N, if N is specified and is a non-negative integer. The soft_heap_limit pragma always returns the same integer that would be returned by the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt;(-1) C-language function.</source>
          <target state="translated">이 pragma는 N이 지정되고 음이 아닌 정수인 경우 인수 N을 사용하여 &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스를 호출합니다 . soft_heap_limit pragma는 항상 &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64&lt;/a&gt; (-1) C 언어 함수에서 반환되는 것과 동일한 정수를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e5367a74af180a6816189a47cadfc307e646cf0c" translate="yes" xml:space="preserve">
          <source>This pragma is a no-op within a transaction; foreign key constraint enforcement may only be enabled or disabled when there is no pending &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; or &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 거래 내에서 no-op입니다. 대기 키 제약 조건 적용은 보류중인 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 또는 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 가없는 경우에만 활성화 또는 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7664f5360eeae6cb14733319d33c60e55709bd68" translate="yes" xml:space="preserve">
          <source>This pragma is a thin wrapper around the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) interface.</source>
          <target state="translated">이 pragma는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; , ...) 인터페이스 주위의 얇은 랩퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="db34d966e31d8d00cada3d5a5b19ca1db1e53aa4" translate="yes" xml:space="preserve">
          <source>This pragma is a wrapper around the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. All automatic checkpoints are &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint ()&lt;/a&gt; C 인터페이스를 감싸는 래퍼 입니다. 모든 자동 체크 포인트는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;수동&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="030bb1c5ea97fb7c877a4d85a6707ab503f61e3b" translate="yes" xml:space="preserve">
          <source>This pragma is intended for use when debugging SQLite itself. It is only available when the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">이 pragma는 SQLite 자체를 디버깅 할 때 사용하기위한 것입니다. &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션이 사용 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="e56acb3f3acf3108d2bcfa664b49bb38684bdece" translate="yes" xml:space="preserve">
          <source>This pragma is provided as a work-around for older programs that contain code that expect the incomplete behavior of &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; found in older versions of SQLite. New applications should leave this flag turned off.</source>
          <target state="translated">이 pragma는 이전 버전의 SQLite에서 발견 된 &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; 의 불완전한 동작을 예상하는 코드가 포함 된 이전 프로그램에 대한 임시 해결책으로 제공됩니다 . 새로운 응용 프로그램은이 플래그를 끈 상태로 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="da6399d7b11614d555263b7b5c1f6eeed6216d28" translate="yes" xml:space="preserve">
          <source>This pragma is usually a no-op or nearly so and is very fast. However if SQLite feels that performing database optimizations (such as running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; or creating new indexes) will improve the performance of future queries, then some database I/O may be done. Applications that want to limit the amount of work performed can set a timer that will invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; if the pragma goes on for too long.</source>
          <target state="translated">이 pragma는 일반적으로 거의 작동하지 않거나 거의 없으며 매우 빠릅니다. 그러나 SQLite가 데이터베이스 최적화 (예 : &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 실행 또는 새 인덱스 작성)를 수행하면 향후 쿼리 성능이 향상 될 것으로 생각되면 일부 데이터베이스 I / O가 수행 될 수 있습니다. 수행되는 작업량을 제한하려는 응용 프로그램 은 pragma가 너무 오래 지속되는 경우 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 를 호출하는 타이머를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eed3f0fa483000682a7d14c72650e371b0cd8ff1" translate="yes" xml:space="preserve">
          <source>This pragma is usually a no-op or nearly so and is very fast. However if SQLite feels that performing database optimizations (such as running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; or creating new indexes) will improve the performance of future queries, then some database I/O may be done. Applications that want to limit the amount of work performed can set a timer that will invoke &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt()&lt;/a&gt; if the pragma goes on for too long. Or, since SQLite 3.32.0, the application can use &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; for some small value of</source>
          <target state="translated">이 pragma는 일반적으로 작동하지 않거나 거의 작동하지 않으며 매우 빠릅니다. 그러나 SQLite가 데이터베이스 최적화 (예 : &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 실행 또는 새 인덱스 생성)를 수행하면 향후 쿼리의 성능이 향상 될 것이라고 생각하면 일부 데이터베이스 I / O가 수행 될 수 있습니다. 수행되는 작업량을 제한하려는 응용 프로그램 은 pragma가 너무 오래 지속되는 경우 &lt;a href=&quot;c3ref/interrupt&quot;&gt;sqlite3_interrupt ()&lt;/a&gt; 를 호출하는 타이머를 설정할 수 있습니다 . 또는 SQLite 3.32.0 이후 응용 프로그램은 &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit = &lt;i&gt;N&lt;/i&gt;&lt;/a&gt; 을 사용 하여</target>
        </trans-unit>
        <trans-unit id="7dc81b55aa5ba45ad453a6bcde0f0c60e0ee6240" translate="yes" xml:space="preserve">
          <source>This pragma no longer functions. It has become a no-op. The capabilities formerly provided by PRAGMA legacy_file_format are now available using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; C-language interface.</source>
          <target state="translated">이 pragma는 더 이상 작동하지 않습니다. 그것은 노옵이되었습니다. 이전에 PRAGMA legacy_file_format에서 제공 한 기능은 이제 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; C 언어 인터페이스에 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglegacyfileformat&quot;&gt;SQLITE_DBCONFIG_LEGACY_FILE_FORMAT&lt;/a&gt; 옵션을 사용하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa79296e3017bdd16ab4375742cc5d36bf545d0" translate="yes" xml:space="preserve">
          <source>This pragma only operates on the single database specified prior to the pragma name (or on the &quot;main&quot; database if no database is specified.) There is no way to change the journal size limit on all attached databases using a single PRAGMA statement. The size limit must be set separately for each attached database.</source>
          <target state="translated">이 pragma는 pragma 이름 이전에 지정된 단일 데이터베이스 (또는 데이터베이스가 지정되지 않은 경우 &quot;main&quot;데이터베이스)에서만 작동합니다. 단일 PRAGMA 문을 사용하여 연결된 모든 데이터베이스의 저널 크기 제한을 변경할 방법이 없습니다. 연결된 각 데이터베이스마다 크기 제한을 별도로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="aaba056a4862e01cda71d1b761b20e44b6644509" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;auto-checkpoint&lt;/a&gt; interval. When the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; is enabled (via the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;) a checkpoint will be run automatically whenever the write-ahead log equals or exceeds</source>
          <target state="translated">이 pragma는 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그 &lt;/a&gt;&lt;a href=&quot;wal#ckpt&quot;&gt;자동 검사 점&lt;/a&gt; 간격을 쿼리하거나 설정합니다 . 때 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 합니다 (를 통해 사용할 수 있습니다 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode 프라그&lt;/a&gt; ) 체크 포인트는 미리 쓰기 등호를 기록하거나 초과 할 때마다 자동으로 실행됩니다</target>
        </trans-unit>
        <trans-unit id="bfa75e14bfef32a3a2655c1f71aac8485fad888a" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the journal mode for databases associated with the current &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 현재 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 연관된 데이터베이스에 대한 저널 모드를 조회하거나 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d7c0c8e01f410012df8cd3104181fe89fb374fb3" translate="yes" xml:space="preserve">
          <source>This pragma queries or sets the suggested maximum number of pages of disk cache that will be allocated per open database file. The difference between this pragma and &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; is that the value set here persists across database connections. The value of the default cache size is stored in the 4-byte big-endian integer located at offset 48 in the header of the database file.</source>
          <target state="translated">이 pragma는 열린 데이터베이스 파일 당 할당 될 디스크 캐시의 최대 제안 페이지 수를 쿼리하거나 설정합니다. 이 pragma와 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size&lt;/a&gt; 의 차이점은 여기에 설정된 값이 데이터베이스 연결 전체에서 지속된다는 것입니다. 기본 캐시 크기의 값은 데이터베이스 파일의 헤더에서 오프셋 48에있는 4 바이트 빅 엔디안 정수에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1ef2565e895730d620c072e537d3e53ba600062b" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; modules registered with the database connection.</source>
          <target state="translated">이 pragma는 데이터베이스 연결에 등록 된 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 모듈 목록을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="761ef2eae4b7a8c11954de10636acd7a99ab380d" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of PRAGMA commands known to the database connection.</source>
          <target state="translated">이 pragma는 데이터베이스 연결에 알려진 PRAGMA 명령 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9ed8c879810cf3faa84c36c2770e39958fecd02f" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of SQL functions known to the database connection.</source>
          <target state="translated">이 pragma는 데이터베이스 연결에 알려진 SQL 함수 목록을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="0dc9b418a5af323c70ff0736fa3cf8ab37665f1f" translate="yes" xml:space="preserve">
          <source>This pragma returns a list of SQL functions known to the database connection. Each row of the result describes a single calling signature for a single SQL function. Some SQL functions will have multiple rows in the result set if they can (for example) be invoked with a varying number of arguments or can accept text in various encodings.</source>
          <target state="translated">이 pragma는 데이터베이스 연결에 알려진 SQL 함수 목록을 반환합니다. 결과의 각 행은 단일 SQL 함수에 대한 단일 호출 서명을 설명합니다. 일부 SQL 함수는 다양한 수의 인수를 사용하여 호출 할 수 있거나 다양한 인코딩으로 텍스트를 허용 할 수있는 경우 (예를 들어) 결과 집합에 여러 행을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="84be4457e11159e63d3d0bcb841125df9cb83de4" translate="yes" xml:space="preserve">
          <source>This pragma returns auxiliary information about tables and indices. The returned information is used during testing to help verify that the query planner is operating correctly. The format and meaning of this pragma will likely change from one release to the next. Because of its volatility, the behavior and output format of this pragma are deliberately undocumented.</source>
          <target state="translated">이 pragma는 테이블 및 인덱스에 대한 보조 정보를 리턴합니다. 리턴 된 정보는 테스트 중에 쿼리 플래너가 올바르게 작동하는지 확인하는 데 사용됩니다. 이 pragma의 형식과 의미는 릴리스마다 변경 될 수 있습니다. 변동성으로 인해이 pragma의 동작 및 출력 형식은 의도적으로 문서화되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c1dbb4a8fba94e2ded892c87199bba0f95f66bb" translate="yes" xml:space="preserve">
          <source>This pragma returns information about every column in an index. Unlike this &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt;, this pragma returns information about every column in the index, not just the key columns. (A key column is a column that is actually named in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; index statement or &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; that created the index. Auxiliary columns are additional columns needed to locate the table entry that corresponds to each index entry.)</source>
          <target state="translated">이 pragma는 인덱스의 모든 열에 대한 정보를 반환합니다. 이 &lt;a href=&quot;pragma#pragma_index_info&quot;&gt;index_info pragma&lt;/a&gt; 와 달리이 pragma는 키 열뿐만 아니라 인덱스의 모든 열에 대한 정보를 반환합니다. 키 열은 실제로 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 인덱스 문 또는 인덱스 를 생성 한 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE 제약 조건&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY 제약 &lt;/a&gt;조건에 명명 된 열입니다 . 보조 열은 각 인덱스 항목에 해당하는 테이블 항목을 찾는 데 필요한 추가 열입니다.</target>
        </trans-unit>
        <trans-unit id="a24a2d4f09014cb1eb0e92389ff660a1c3604451" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; created by a REFERENCES clause in the CREATE TABLE statement of table &quot;</source>
          <target state="translated">이 pragma는 테이블 &quot;의 CREATE TABLE 문에서 REFERENCES 절에 의해 작성된 각 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제한 조건&lt;/a&gt; 마다 하나의 행을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f5e8b048594bfe6e950f49e7a3df451544d23739" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each column in the named table, including &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in virtual tables. The output is the same as for &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; except that hidden columns are shown rather than being omitted.</source>
          <target state="translated">이 pragma는 가상 테이블의 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 을 포함하여 명명 된 테이블의 각 열에 대해 하나의 행을 반환합니다 . 숨겨진 열이 생략되지 않고 표시 &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;된다는&lt;/a&gt; 점을 제외하면 출력은 PRAGMA table_info와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0f2a61f261d82a90c74c33973c7e5e1738138e48" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each column in the named table. Columns in the result set include the column name, data type, whether or not the column can be NULL, and the default value for the column. The &quot;pk&quot; column in the result set is zero for columns that are not part of the primary key, and is the index of the column in the primary key for columns that are part of the primary key.</source>
          <target state="translated">이 pragma는 명명 된 테이블의 각 열에 대해 하나의 행을 반환합니다. 결과 집합의 열에는 열 이름, 데이터 형식, 열이 NULL 일 수 있는지 여부 및 열의 기본값이 포함됩니다. 기본 키의 일부가 아닌 열의 경우 결과 집합의 &quot;pk&quot;열이 0이고 기본 키의 일부인 열의 기본 키 열의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="843feda403cc5662c28514409a8476f790a07bc9" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each index associated with the given table.</source>
          <target state="translated">이 pragma는 주어진 테이블과 연관된 각 인덱스에 대해 하나의 행을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e15d06d79e2f134d82370610f854504fb7d9c9fb" translate="yes" xml:space="preserve">
          <source>This pragma returns one row for each key column in the named index. A key column is a column that is actually named in the &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; index statement or &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE constraint&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY constraint&lt;/a&gt; that created the index. Index entries also usually contain auxiliary columns that point back to the table row being indexed. The auxiliary index-columns are not shown by the index_info pragma, but they are listed by the &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo pragma&lt;/a&gt;.</source>
          <target state="translated">이 pragma는 명명 된 인덱스의 각 키 열에 대해 하나의 행을 반환합니다. 키 열은 실제로 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 인덱스 문 또는 인덱스 를 생성 한 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE 제약 조건&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY 제약 &lt;/a&gt;조건 에서 명명 된 열입니다 . 색인 항목에는 일반적으로 색인화되는 테이블 행을 다시 가리키는 보조 열도 포함됩니다. 보조 인덱스 열은 index_info pragma로 표시되지 않지만 &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;index_xinfo pragma&lt;/a&gt; 로 나열됩니다 .</target>
        </trans-unit>
        <trans-unit id="d1297e6852f3b4af2f7f71b997d91f96306d187f" translate="yes" xml:space="preserve">
          <source>This pragma returns the names of &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; used when building SQLite, one option per row. The &quot;SQLITE_&quot; prefix is omitted from the returned option names. See also the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ interface and the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions.</source>
          <target state="translated">이 pragma는 SQLite를 빌드 할 때 사용되는 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션&lt;/a&gt; 의 이름을 행당 하나의 옵션으로 반환합니다 . 리턴 된 옵션 이름에서 &quot;SQLITE_&quot;접 두부가 생략되었습니다. 또한 참조 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get ()&lt;/a&gt; C / C ++ 인터페이스와 &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; SQL 함수.</target>
        </trans-unit>
        <trans-unit id="1f4e86e6ac578887a9d6dbf11a796008c25a44d7" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the database connection locking-mode. The locking-mode is either NORMAL or EXCLUSIVE.</source>
          <target state="translated">이 pragma는 데이터베이스 연결 잠금 모드를 설정하거나 조회합니다. 잠금 모드는 NORMAL 또는 EXCLUSIVE입니다.</target>
        </trans-unit>
        <trans-unit id="bdaa228ea88957ef0c9ab9a688d3e7fea7b874a6" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the value of the legacy_alter_table flag. When this flag is on, the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command (for changing the name of a table) works as it did in SQLite 3.24.0 (2018-06-04) and earlier. More specifically, when this flag is on the &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; command only rewrites the initial occurrence of the table name in its &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement and in any associated &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; and &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statements. Other references to the table are unmodified, including:</source>
          <target state="translated">이 pragma는 legacy_alter_table 플래그의 값을 설정하거나 쿼리합니다. 이 플래그가 켜져 있으면 &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; 명령 (테이블 이름 변경)이 SQLite 3.24.0 (2018-06-04) 및 이전 버전에서와 같이 작동합니다. 보다 구체적으로,이 플래그가 &lt;a href=&quot;lang_altertable#altertabrename&quot;&gt;ALTER TABLE RENAME&lt;/a&gt; 명령에 있으면 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 및 연관된 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 및 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문 에서 테이블 이름의 초기 발생 만 다시 작성합니다 . 다음을 포함하여 테이블에 대한 다른 참조는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a05efbc35058ad10c4f2cd985fb255ec41f8221" translate="yes" xml:space="preserve">
          <source>This pragma sets or queries the value of the legacy_file_format flag. When this flag is on, new SQLite databases are created in a file format that is readable and writable by all versions of SQLite going back to 3.0.0. When the flag is off, new databases are created using the latest file format which might not be readable or writable by versions of SQLite prior to 3.3.0.</source>
          <target state="translated">이 pragma는 legacy_file_format 플래그의 값을 설정하거나 쿼리합니다. 이 플래그가 설정되면 새 SQLite 데이터베이스는 3.0.0으로 돌아가는 모든 버전의 SQLite에서 읽고 쓸 수있는 파일 형식으로 작성됩니다. 플래그가 해제되면 3.3.0 이전의 SQLite 버전에서 읽거나 쓸 수없는 최신 파일 형식을 사용하여 새 데이터베이스가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b26c49351792e86f1f1cf4afa447e502bc4e050e" translate="yes" xml:space="preserve">
          <source>This pragma tells the ANALYZE command to start a full scan of the index as it normally would. But when the number of rows visited reaches 1000 (or whatever other limit is specified by the pragma), the ANALYZE command will begin taking actions to stop the scan. If the left-most column of the index has changed at least once during the previous 1000 steps, then the analysis stops immediately. But if the left-most column has always been the same, then ANALYZE skips ahead to the first entry with a different left-most column and reads an additional 1000 rows before terminating.</source>
          <target state="translated">이 pragma는 ANALYZE 명령이 평소처럼 인덱스의 전체 스캔을 시작하도록 지시합니다. 그러나 방문한 행 수가 1000 개 (또는 pragma가 지정한 다른 제한)에 도달하면 ANALYZE 명령이 검색을 중지하는 작업을 시작합니다. 인덱스의 맨 왼쪽 열이 이전 1000 단계 동안 한 번 이상 변경된 경우 분석이 즉시 중지됩니다. 그러나 가장 왼쪽 열이 항상 동일하다면 ANALYZE는 가장 왼쪽 열이 다른 첫 번째 항목으로 건너 뛰고 종료하기 전에 추가로 1000 개의 행을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="a2256ef3045f9cad069bd18349bbc99a6efdd738" translate="yes" xml:space="preserve">
          <source>This pragma uses &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; to overload the LIKE and GLOB functions, which may override previous implementations of LIKE and GLOB registered by the application. This pragma only changes the behavior of the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator. It does not change the behavior of the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface, which is always case insensitive.</source>
          <target state="translated">이 pragma는 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 을 사용 하여 LIKE 및 GLOB 함수를 오버로드합니다.이 기능은 응용 프로그램에 의해 등록 된 LIKE 및 GLOB의 이전 구현을 대체 할 수 있습니다. 이 pragma는 SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 의 동작 만 변경합니다 . &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; C 언어 인터페이스 의 동작은 변경하지 않으며 항상 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="310b52d96c912ff71562ab1fd81b11654003b13d" translate="yes" xml:space="preserve">
          <source>This pragma was added in SQLite version 3.32.0 (2020-05-22). The current implementation only uses the lower 31 bits of the N value - higher order bits are silently ignored. Future versions of SQLite might begin using higher order bits.</source>
          <target state="translated">이 pragma는 SQLite 버전 3.32.0 (2020-05-22)에 추가되었습니다. 현재 구현에서는 N 값의 하위 31 비트 만 사용합니다. 상위 비트는 자동으로 무시됩니다. SQLite의 향후 버전은 고차 비트를 사용하기 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="447007d852fb19b826d2b7aaae3e67946a28d336" translate="yes" xml:space="preserve">
          <source>This pragma works like a query to return one row for each database attached to the current database connection. The second column is &quot;main&quot; for the main database file, &quot;temp&quot; for the database file used to store TEMP objects, or the name of the ATTACHed database for other database files. The third column is the name of the database file itself, or an empty string if the database is not associated with a file.</source>
          <target state="translated">이 pragma는 현재 데이터베이스 연결에 연결된 각 데이터베이스에 대해 하나의 행을 반환하는 쿼리처럼 작동합니다. 두 번째 열은 기본 데이터베이스 파일의 경우 &quot;main&quot;, TEMP 객체를 저장하는 데 사용되는 데이터베이스 파일의 경우 &quot;temp&quot;또는 다른 데이터베이스 파일의 ATTACHed 데이터베이스 이름입니다. 세 번째 열은 데이터베이스 파일 자체의 이름이거나 데이터베이스가 파일과 연결되지 않은 경우 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b7e6bffb05642d99fecc1f2c74da4ca842565145" translate="yes" xml:space="preserve">
          <source>This problem was discovered during internal testing and has never been observed in the wild. The problem was fixed on 2011-01-27 and in version 3.7.5.</source>
          <target state="translated">이 문제는 내부 테스트 중에 발견되었으며 결코 야생에서 관찰되지 않았습니다. 이 문제는 2011-01-27 및 버전 3.7.5에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="9438a6524ce2126c022c5e9ae1c6d3bb84977f28" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-08-04 for SQLite version 3.7.1.</source>
          <target state="translated">이 문제는 2010-08-04 SQLite 버전 3.7.1에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bba8168352d9cb374bc4be5ca367062ebf9277c" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-08-23 for SQLite version 3.7.2.</source>
          <target state="translated">이 문제는 2010-08-23 SQLite 버전 3.7.2에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="3eea872e5b7d7a7257a591147c473522673fa365" translate="yes" xml:space="preserve">
          <source>This problem was fixed on 2010-09-20 for SQLite version 3.7.3.</source>
          <target state="translated">이 문제는 2010 년 9 월 20 일 SQLite 버전 3.7.3에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="0ce7e9d811851c36704d972293b4f2237f7e1d64" translate="yes" xml:space="preserve">
          <source>This procedure works well in many scenarios and is usually very fast. However, this technique has the following shortcomings:</source>
          <target state="translated">이 절차는 많은 시나리오에서 잘 작동하며 일반적으로 매우 빠릅니다. 그러나이 기술에는 다음과 같은 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c414b9643d2b1eb4ae1c2d544d59015b0f98573" translate="yes" xml:space="preserve">
          <source>This program is essentially the same as the DELETE program except that the body of the second loop has been replace by a sequence of instructions (at addresses 17 through 26) that update the record rather than delete it. Most of this instruction sequence should already be familiar to you, but there are a couple of minor twists so we will go over it briefly. Also note that the order of some of the instructions before and after the 2nd loop has changed. This is just the way the SQLite parser chose to output the code using a different template.</source>
          <target state="translated">이 프로그램은 두 번째 루프의 본문이 레코드를 삭제하지 않고 업데이트하는 명령 시퀀스 (주소 17-26)로 대체되었다는 점을 제외하고는 DELETE 프로그램과 본질적으로 동일합니다. 이 명령 순서의 대부분은 이미 익숙 할 것입니다. 그러나 몇 가지 사소한 비틀기가 있으므로 간단히 살펴 보겠습니다. 또한 두 번째 루프 전후의 일부 명령 순서가 변경되었습니다. 이것은 SQLite 파서가 다른 템플릿을 사용하여 코드를 출력하기로 선택한 방식입니다.</target>
        </trans-unit>
        <trans-unit id="f54cc6d1386375f0cfa0eb855ce7f2e93f001461" translate="yes" xml:space="preserve">
          <source>This query asks for is all information about edges that go from nodes labeled &quot;alice&quot; to nodes labeled &quot;bob&quot;. The query optimizer in SQLite has basically two choices on how to implement this query. (There are actually six different choices, but we will only consider two of them here.) Pseudocode below demonstrating these two choices.</source>
          <target state="translated">이 쿼리는 &quot;alice&quot;로 표시된 노드에서 &quot;bob&quot;으로 표시된 노드로 이동하는 에지에 대한 모든 정보를 요청합니다. SQLite의 쿼리 최적화 프로그램은 기본적으로이 쿼리를 구현하는 방법에 대한 두 가지 선택 사항이 있습니다. (실제로 6 가지 선택이 있지만 여기서는 두 가지만 고려할 것입니다.) 아래 두 가지 선택을 보여주는 의사 코드는 아래입니다.</target>
        </trans-unit>
        <trans-unit id="7e3da084168a6f4b3ad897e2e46b6850a28945d4" translate="yes" xml:space="preserve">
          <source>This query first has to search the index B-Tree looking for any entry that contains the matching value for &quot;word&quot;. When an entry is found in the index, the rowid is extracted and used to search the main table. Then the &quot;cnt&quot; value is read out of the main table and returned. Hence, two separate binary searches are required to fulfill the request.</source>
          <target state="translated">이 쿼리는 먼저 &quot;word&quot;에 대해 일치하는 값을 포함하는 항목을 찾기 위해 인덱스 B-Tree를 검색해야합니다. 색인에서 항목을 찾으면 rowid가 추출되어 기본 테이블을 검색하는 데 사용됩니다. 그런 다음 &quot;cnt&quot;값을 기본 테이블에서 읽고 리턴합니다. 따라서 요청을 수행하려면 두 개의 개별 이진 검색이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="620f9a1f33cc73df6597e56b9939bf24aa81844a" translate="yes" xml:space="preserve">
          <source>This query gives the same result:</source>
          <target state="translated">이 쿼리는 동일한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d2601bd4ed6990af8a96269ebe6b0cb66d50d79e" translate="yes" xml:space="preserve">
          <source>This query is not especially complicated, but even so it replaces hundreds or perhaps thousands of lines of procedural code. The gist of the query is this: Scan down the EVENT table looking for the most recent 200 check-ins that satisfy any one of three conditions:</source>
          <target state="translated">이 쿼리는 특별히 복잡하지는 않지만 수백 또는 수천 줄의 절차 코드를 대체합니다. 쿼리의 요지는 다음과 같습니다. EVENT 테이블을 스캔하여 세 가지 조건 중 하나를 만족하는 최신 200 개의 체크인을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="2749b73f041610bfa01e6d5aed946eaac3cd848e" translate="yes" xml:space="preserve">
          <source>This query is perhaps a bit contrived, but it does serve to illustrate our points. The result will have three column with names &quot;one&quot;, &quot;two&quot;, and &quot;both&quot;. The first two columns are direct copies of the two columns in the table and the third result column is a string formed by concatenating the first and second columns of the table. Finally, the WHERE clause says that we will only chose rows for the results where the &quot;one&quot; column begins with an &quot;H&quot;. Here is what the VDBE program looks like for this query:</source>
          <target state="translated">이 쿼리는 아마도 약간의 생각이지만 우리의 요점을 설명하는 역할을합니다. 결과에는 이름이 &quot;1&quot;, &quot;2&quot;및 &quot;both&quot;인 3 개의 열이 있습니다. 처음 두 열은 테이블에있는 두 열의 직접 복사본이며 세 번째 결과 열은 테이블의 첫 번째 열과 두 번째 열을 연결하여 형성된 문자열입니다. 마지막으로 WHERE 절은 &quot;하나&quot;열이 &quot;H&quot;로 시작하는 결과에 대해서만 행을 선택한다고 말합니다. 이 쿼리에 대한 VDBE 프로그램의 모습은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6af6cd36f1f43fba0a96ca0a8f8120de050aaf2f" translate="yes" xml:space="preserve">
          <source>This query will quickly and efficiently return the content of the first slide, which could then be speedily parsed and displayed to the user. Only one page needs to be read and parsed in order render the first screen, which means that the first screen appears much faster and there is no longer a need for an annoying progress bar.</source>
          <target state="translated">이 쿼리는 첫 번째 슬라이드의 내용을 빠르고 효율적으로 반환하며,이 내용은 신속하게 구문 분석되어 사용자에게 표시 될 수 있습니다. 첫 번째 화면을 렌더링하려면 하나의 페이지 만 읽고 파싱해야합니다. 즉, 첫 번째 화면이 훨씬 빠르게 나타나고 더 이상 성가신 진행률 표시 줄이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a6c62ef8547acc00a0d376fd2eee1cb18ab798d" translate="yes" xml:space="preserve">
          <source>This query will return the name, login and host computer name for every employee whose login begins with the letter &quot;d&quot;. If this query is submitted to &lt;b&gt;sqlite_get_table&lt;/b&gt; the result might look like this:</source>
          <target state="translated">이 쿼리는 로그인이 문자 &quot;d&quot;로 시작하는 모든 직원의 이름, 로그인 및 호스트 컴퓨터 이름을 반환합니다. 이 쿼리가 &lt;b&gt;sqlite_get_table에&lt;/b&gt; 제출 되면 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="786fc0a802df1e8aec075c9e88a6bbb535aa99ad" translate="yes" xml:space="preserve">
          <source>This routine actually returns the index of the largest (rightmost) parameter. For all forms except ?NNN, this will correspond to the number of unique parameters. If parameters of the ?NNN form are used, there may be gaps in the list.</source>
          <target state="translated">이 루틴은 실제로 가장 큰 (가장 오른쪽) 매개 변수의 색인을 리턴합니다. ? NNN을 제외한 모든 양식의 경우 고유 매개 변수 수에 해당합니다. ? NNN 형식의 매개 변수를 사용하면 목록에 공백이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82cead05834ab856656df11fcc02860924d8d8b1" translate="yes" xml:space="preserve">
          <source>This routine can be used to find the number of &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameters&lt;/a&gt; in a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. SQL parameters are tokens of the form &quot;?&quot;, &quot;?NNN&quot;, &quot;:AAA&quot;, &quot;$AAA&quot;, or &quot;@AAA&quot; that serve as placeholders for values that are &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;bound&lt;/a&gt; to the parameters at a later time.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에서 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 의 수를 찾는 데 사용될 수 있습니다 . SQL 매개 변수는 &quot;?&quot;, &quot;? NNN&quot;, &quot;: AAA&quot;, &quot;$ AAA&quot;또는 &quot;@AAA&quot;형식의 토큰 으로 나중에 매개 변수에 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인드 된&lt;/a&gt; 값의 자리 표시 자로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6aaf25d9f82325cb031a156482001e57680fd3f9" translate="yes" xml:space="preserve">
          <source>This routine can be used to find the number of &lt;a href=&quot;bind_blob&quot;&gt;SQL parameters&lt;/a&gt; in a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. SQL parameters are tokens of the form &quot;?&quot;, &quot;?NNN&quot;, &quot;:AAA&quot;, &quot;$AAA&quot;, or &quot;@AAA&quot; that serve as placeholders for values that are &lt;a href=&quot;bind_blob&quot;&gt;bound&lt;/a&gt; to the parameters at a later time.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에서 &lt;a href=&quot;bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 의 수를 찾는 데 사용될 수 있습니다 . SQL 매개 변수는 &quot;?&quot;, &quot;? NNN&quot;, &quot;: AAA&quot;, &quot;$ AAA&quot;또는 &quot;@AAA&quot;형식의 토큰 으로 나중에 매개 변수에 &lt;a href=&quot;bind_blob&quot;&gt;바인드 된&lt;/a&gt; 값의 자리 표시 자로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a65562aad6f3d45b12e58b386a59a0e67c73c2c" translate="yes" xml:space="preserve">
          <source>This routine closes a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; previously opened by a call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. All &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the connection should be &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt; prior to closing the connection.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 호출로 이전에 열린 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 닫습니다 . 연결과 관련된 모든 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 은 연결 을 닫기 전에 &lt;a href=&quot;c3ref/finalize&quot;&gt;완료&lt;/a&gt; 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6109a4798fab358a5831fcddc3e8943992908f3a" translate="yes" xml:space="preserve">
          <source>This routine constructs a phonetic hash of the pure ascii input word X and returns that hash. This routine is used internally by spellfix1 in order to transform the K1 column of the shadow table into the K2 column.</source>
          <target state="translated">이 루틴은 순수한 ASCII 입력 단어 X의 발음 해시를 구성하고 해당 해시를 반환합니다. 이 루틴은 새도우 테이블의 K1 컬럼을 K2 컬럼으로 변환하기 위해 spellfix1에 의해 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ac023c7cfdfffbaae6b8a792abd8043d224eebe" translate="yes" xml:space="preserve">
          <source>This routine converts SQL text into a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object and returns a pointer to that object. This interface requires a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pointer created by a prior call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and a text string containing the SQL statement to be prepared. This API does not actually evaluate the SQL statement. It merely prepares the SQL statement for evaluation.</source>
          <target state="translated">이 루틴은 SQL 텍스트를 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트 로 변환 하고 해당 오브젝트에 대한 포인터를 리턴합니다. 이 인터페이스에는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 에 대한 이전 호출 및 작성 될 SQL 문을 포함하는 텍스트 문자열로 작성된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 포인터 가 필요합니다 . 이 API는 실제로 SQL 문을 평가하지 않습니다. 단지 평가를 위해 SQL 문을 준비하기 만합니다.</target>
        </trans-unit>
        <trans-unit id="3865bbf14bf147fc543355db38f5dadbf150122d" translate="yes" xml:space="preserve">
          <source>This routine destroys a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; created by a prior call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. Every prepared statement must be destroyed using a call to this routine in order to avoid memory leaks.</source>
          <target state="translated">이 루틴 은 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 에 대한 이전 호출로 작성된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문을&lt;/a&gt; 삭제합니다 . 메모리 누수를 피하기 위해이 루틴을 호출하여 모든 준비된 명령문을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="a52c3faf1c3a1657fd6a40523756966514b3bd4b" translate="yes" xml:space="preserve">
          <source>This routine enables or disables the sharing of the database cache and schema data structures between &lt;a href=&quot;#sqlite3&quot;&gt;connections&lt;/a&gt; to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.</source>
          <target state="translated">이 루틴은 동일한 데이터베이스에 대한 &lt;a href=&quot;#sqlite3&quot;&gt;연결&lt;/a&gt; 간에 데이터베이스 캐시 및 스키마 데이터 구조의 공유를 활성화 또는 비활성화 합니다. 인수가 true이면 공유가 활성화되고 인수가 false이면 공유가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d901aac850e2874e347f7c695dbc9ec37b0c376c" translate="yes" xml:space="preserve">
          <source>This routine enables or disables the sharing of the database cache and schema data structures between &lt;a href=&quot;sqlite3&quot;&gt;connections&lt;/a&gt; to the same database. Sharing is enabled if the argument is true and disabled if the argument is false.</source>
          <target state="translated">이 루틴은 동일한 데이터베이스에 대한 &lt;a href=&quot;sqlite3&quot;&gt;연결&lt;/a&gt; 간에 데이터베이스 캐시 및 스키마 데이터 구조의 공유를 활성화 또는 비활성화 합니다. 인수가 true이면 공유가 활성화되고 인수가 false이면 공유가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="e45ac400962f26a46b0c7a761a5b27fee72dc04a" translate="yes" xml:space="preserve">
          <source>This routine is intended for use in custom &lt;a href=&quot;../vfs&quot;&gt;VFS&lt;/a&gt; implementations only. It is not a general-purpose interface. The argument sqlite3_file_object(X) must be a filename pointer that has been passed into &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.xOpen method where the flags parameter to xOpen contains one of the bits &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_MAIN_JOURNAL&lt;/a&gt; or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_WAL&lt;/a&gt;. Any other use of this routine results in undefined and probably undesirable behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29a07bad74dc3a8e7d5052bfbcc32c750599206e" translate="yes" xml:space="preserve">
          <source>This routine is intended for use in custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations only. It is not a general-purpose interface. The argument sqlite3_file_object(X) must be a filename pointer that has been passed into &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;.xOpen method where the flags parameter to xOpen contains one of the bits &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_JOURNAL&lt;/a&gt; or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_WAL&lt;/a&gt;. Any other use of this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">이 루틴은 사용자 정의 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현에서만 사용하기위한 것입니다 . 범용 인터페이스가 아닙니다. 인수 sqlite3_file_object (X)는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; .xOpen 메소드 로 전달 된 파일 이름 포인터 여야합니다. 여기서 xOpen에 대한 flags 매개 변수는 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_MAIN_JOURNAL&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_WAL&lt;/a&gt; 비트 중 하나를 포함 합니다. 이 루틴을 다른 용도로 사용하면 정의되지 않고 바람직하지 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66ec00e3ab29e600b8638a80acbfec2ed5a9c1b5" translate="yes" xml:space="preserve">
          <source>This routine is used to evaluate a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that has been previously created by the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface. The statement is evaluated up to the point where the first row of results are available. To advance to the second row of results, invoke &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; again. Continue invoking &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; until the statement is complete. Statements that do not return results (ex: INSERT, UPDATE, or DELETE statements) run to completion on a single call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스에 의해 이전에 작성된 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 평가하는 데 사용됩니다 . 명령문은 첫 번째 결과 행이 사용 가능한 지점까지 평가됩니다. 결과의 두 번째 행으로 진행하려면 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 다시 호출 하십시오. 명령문이 완료 될 때까지 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 계속 호출하십시오 . &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 을 한 번 호출하면 결과를 반환하지 않는 명령문 (예 : INSERT, UPDATE 또는 DELETE 문)이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="c21adee0cae411351e9767eae2ca17c143aefc07" translate="yes" xml:space="preserve">
          <source>This routine must be called from the same thread in which the aggregate SQL function is running.</source>
          <target state="translated">이 루틴은 집계 SQL 함수가 실행중인 동일한 스레드에서 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e489cf15316fb146ac0baf370fbbfcb5134583b8" translate="yes" xml:space="preserve">
          <source>This routine must be called from the same thread in which the application-defined function is running.</source>
          <target state="translated">이 루틴은 응용 프로그램 정의 함수가 실행중인 동일한 스레드에서 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="07007def1c51de043ffcd727a12c0e6566d62bdb" translate="yes" xml:space="preserve">
          <source>This routine only works on a &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; which has been created by a prior successful call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and which has not been closed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. Passing any other pointer in to this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">이 루틴은 단지에서 작동 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에 이전 성공적인 호출에 의해 생성 된 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;(sqlite3_blob_open)&lt;/a&gt; 하고있는가에 의해 폐쇄되지 않은 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;() sqlite3_blob_close&lt;/a&gt; . 이 루틴에 다른 포인터를 전달하면 정의되지 않았으며 바람직하지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d92c14464f28e95d1806fdcf38633495ea9ee90c" translate="yes" xml:space="preserve">
          <source>This routine only works on a &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; which has been created by a prior successful call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and which has not been closed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. Passing any other pointer in to this routine results in undefined and probably undesirable behavior.</source>
          <target state="translated">이 루틴은 단지에서 작동 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에 이전 성공적인 호출에 의해 생성 된 &lt;a href=&quot;blob_open&quot;&gt;(sqlite3_blob_open)&lt;/a&gt; 하고있는가에 의해 폐쇄되지 않은 &lt;a href=&quot;blob_close&quot;&gt;() sqlite3_blob_close&lt;/a&gt; . 이 루틴에 다른 포인터를 전달하면 정의되지 않았으며 바람직하지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="07b6feb6d3d354b38307dc8433a451fe5b332630" translate="yes" xml:space="preserve">
          <source>This routine opens a connection to an SQLite database file and returns a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object. This is often the first SQLite API call that an application makes and is a prerequisite for most other SQLite APIs. Many SQLite interfaces require a pointer to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object as their first parameter and can be thought of as methods on the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object. This routine is the constructor for the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; object.</source>
          <target state="translated">이 루틴은 SQLite 데이터베이스 파일에 대한 연결을 열고 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 개체를 반환 합니다. 이것은 종종 응용 프로그램이 수행하는 첫 번째 SQLite API 호출이며 대부분의 다른 SQLite API의 전제 조건입니다. 많은 SQLite는 인터페이스는 포인터가 필요 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 자신의 첫 번째 매개 변수로 객체와 메소드로 생각 될 수있다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 객체입니다. 이 루틴은 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트 의 생성자입니다 .</target>
        </trans-unit>
        <trans-unit id="8eb287af5c0b98096f9cf0455204f0ad3d8277d3" translate="yes" xml:space="preserve">
          <source>This routine provides access to the built-in Wagner edit-distance function that uses default, fixed costs. The value returned is the edit distance needed to transform W into P.</source>
          <target state="translated">이 루틴을 통해 기본 고정 비용을 사용하는 내장 Wagner 편집 거리 기능에 액세스 할 수 있습니다. 반환 된 값은 W를 P로 변환하는 데 필요한 편집 거리입니다.</target>
        </trans-unit>
        <trans-unit id="93eac9a1a83b23f2a48d0e76580b6d5dc096f4b0" translate="yes" xml:space="preserve">
          <source>This routine registers an authorizer callback with a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;, supplied in the first argument. The authorizer callback is invoked as SQL statements are being compiled by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed. The authorizer callback should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to allow the action, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; to disallow the specific action but allow the SQL statement to continue to be compiled, or &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; to cause the entire SQL statement to be rejected with an error. If the authorizer callback returns any value other than &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; then the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message.</source>
          <target state="translated">이 루틴 은 첫 번째 인수에 제공된 특정 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 권한 부 여자 콜백을 등록합니다 . SQL 문이 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 해당 변형 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3에&lt;/a&gt; 의해 SQL 문이 컴파일 될 때 권한 부 여자 콜백이 호출됩니다 . 컴파일 프로세스 중 다양한 시점에서 다양한 조치를 수행하기위한 로직이 작성 될 때 해당 조치가 허용되는지 확인하기 위해 권한 부 여기 콜백이 호출됩니다. 인가 자 콜백이 반환해야 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK을&lt;/a&gt; 작업을 할 수 있도록, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;특정 조치를 허용하지 않지만 SQL 문을 계속 컴파일하도록 허용하거나 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; 를 사용하여 전체 SQL 문을 오류와 함께 거부합니다. 권한 부 여자 콜백이 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt; 이외의 값을 리턴하면 권한 부여 자를 트리거 한 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 동등한 호출이 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dcaafc38803b7cef296c24894bb19eac21f398f7" translate="yes" xml:space="preserve">
          <source>This routine registers an authorizer callback with a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;, supplied in the first argument. The authorizer callback is invoked as SQL statements are being compiled by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. At various points during the compilation process, as logic is being created to perform various actions, the authorizer callback is invoked to see if those actions are allowed. The authorizer callback should return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to allow the action, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; to disallow the specific action but allow the SQL statement to continue to be compiled, or &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; to cause the entire SQL statement to be rejected with an error. If the authorizer callback returns any value other than &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, or &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; then the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message.</source>
          <target state="translated">이 루틴 은 첫 번째 인수에 제공된 특정 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 권한 부 여자 콜백을 등록합니다 . SQL 문이 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 해당 변형 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 및 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3에&lt;/a&gt; 의해 SQL 문이 컴파일 될 때 권한 부 여자 콜백이 호출됩니다 . 컴파일 프로세스 중 다양한 시점에서 다양한 조치를 수행하기위한 로직이 작성 될 때 해당 조치가 허용되는지 확인하기 위해 권한 부 여기 콜백이 호출됩니다. 인가 자 콜백이 반환해야 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK을&lt;/a&gt; 작업을 할 수 있도록, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;특정 조치를 허용하지 않지만 SQL 문을 계속 컴파일하도록 허용하거나 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; 를 사용하여 전체 SQL 문을 오류와 함께 거부합니다. 권한 부 여자 콜백이 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 또는 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt; 이외의 값을 리턴하면 권한 부여 자를 트리거 한 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 동등한 호출이 오류 메시지와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="99bd82f31eb3b138636b801769508b327d9ce007" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if shared cache was enabled or disabled successfully. An &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned otherwise.</source>
          <target state="translated">이 루틴은 공유 캐시가 활성화되거나 비활성화 된 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 반환합니다 . &lt;a href=&quot;rescode&quot;&gt;오류 코드가&lt;/a&gt; , 그렇지 않으면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2e5b155148072e0e0717f83e2e5d7963cd701ab3" translate="yes" xml:space="preserve">
          <source>This routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if shared cache was enabled or disabled successfully. An &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned otherwise.</source>
          <target state="translated">이 루틴은 공유 캐시가 활성화되거나 비활성화 된 경우 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 반환합니다 . &lt;a href=&quot;../rescode&quot;&gt;오류 코드가&lt;/a&gt; , 그렇지 않으면 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4d167dde1efd15582fdfdddff7653e5e9800f482" translate="yes" xml:space="preserve">
          <source>This routine returns a TCL byte-array that is the complete content of the identified database. This byte-array can be written into a file and then used as an ordinary SQLite database, or it can be sent over a TCP/IP connection to some other application, or passed to the &quot;deserialize&quot; method of another database connection.</source>
          <target state="translated">이 루틴은 식별 된 데이터베이스의 전체 컨텐츠 인 TCL 바이트 배열을 리턴합니다. 이 바이트 배열을 파일에 기록한 다음 일반 SQLite 데이터베이스로 사용하거나 TCP / IP 연결을 통해 다른 응용 프로그램으로 보내거나 다른 데이터베이스 연결의 &quot;직렬화&quot;방법으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc962087e437ca7c6c8165e9968a2bc2c77ed304" translate="yes" xml:space="preserve">
          <source>This routine returns a single column from the current row of a result set for a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Each time &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; stops with a new result set row, this routine can be called multiple times to find the values of all columns in that row.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 의해 평가되는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 결과 세트의 현재 행에서 단일 열을 리턴합니다 . &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 새로운 결과 세트 행으로 중지 될 때 마다이 루틴을 여러 번 호출하여 해당 행의 모든 ​​열 값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb8bd2a9855b404f89ce4b63dddd244bdc9bda29" translate="yes" xml:space="preserve">
          <source>This routine sets a &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy handler&lt;/a&gt; that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least &quot;ms&quot; milliseconds of sleeping have accumulated. After at least &quot;ms&quot; milliseconds of sleeping, the handler returns 0 which causes &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; to return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 테이블이 잠겨있을 때 지정된 시간 동안 휴면 상태로있는 사용 중 &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;핸들러&lt;/a&gt; 를 설정합니다 . 처리기는 적어도 &quot;ms&quot;밀리 초의 수면이 누적 될 때까지 여러 번 절전합니다. 최소 &quot;ms&quot;밀리 초의 휴면 후 핸들러는 0 을 리턴하여 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="97ac6d25d7ee72382d3f7aec3c40d5d374b3ea97" translate="yes" xml:space="preserve">
          <source>This routine sets a &lt;a href=&quot;busy_handler&quot;&gt;busy handler&lt;/a&gt; that sleeps for a specified amount of time when a table is locked. The handler will sleep multiple times until at least &quot;ms&quot; milliseconds of sleeping have accumulated. After at least &quot;ms&quot; milliseconds of sleeping, the handler returns 0 which causes &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; to return &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 테이블이 잠겨있을 때 지정된 시간 동안 휴면 상태로있는 사용 중 &lt;a href=&quot;busy_handler&quot;&gt;핸들러&lt;/a&gt; 를 설정합니다 . 처리기는 적어도 &quot;ms&quot;밀리 초의 수면이 누적 될 때까지 여러 번 절전합니다. 최소 &quot;ms&quot;밀리 초의 휴면 후 핸들러는 0 을 리턴하여 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;../rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="1d633b79271bff7ae103d633764cef0869ef0e52" translate="yes" xml:space="preserve">
          <source>This routine transliterates unicode text into pure ascii, returning the pure ascii representation of the input text X. This is the function that is used internally to transform vocabulary words into the K1 column of the shadow table.</source>
          <target state="translated">이 루틴은 유니 코드 텍스트를 순수한 ASCII로 음역하여 입력 텍스트 X의 순수한 ASCII 표현을 반환합니다. 이것은 어휘 단어를 새도우 테이블의 K1 열로 변환하기 위해 내부적으로 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f0ad86a48fbea1254fe3c4c84468bcbdc8dd6e8c" translate="yes" xml:space="preserve">
          <source>This same content is also available as a &lt;a href=&quot;../capi3ref&quot;&gt;single large HTML file&lt;/a&gt;.</source>
          <target state="translated">동일한 내용을 &lt;a href=&quot;../capi3ref&quot;&gt;하나의 큰 HTML 파일&lt;/a&gt; 로도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b74b81048986ae624c4d01a81a2fa637394592ee" translate="yes" xml:space="preserve">
          <source>This same content is also available split out into &lt;a href=&quot;c3ref/intro&quot;&gt;lots of small pages&lt;/a&gt;.</source>
          <target state="translated">이 같은 내용을 여러 &lt;a href=&quot;c3ref/intro&quot;&gt;개의 작은 페이지&lt;/a&gt; 로 나눌 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e9d9070e55bd57ac8188b9955c919aae3b6970b" translate="yes" xml:space="preserve">
          <source>This scenario can be avoided by ensuring that there are &quot;reader gaps&quot;: times when no processes are reading from the database and that checkpoints are attempted during those times. In applications with many concurrent readers, one might also consider running manual checkpoints with the &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; or &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; option which will ensure that the checkpoint runs to completion before returning. The disadvantage of using &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; and &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; is that readers might block while the checkpoint is running.</source>
          <target state="translated">데이터베이스에서 프로세스를 읽지 않는 시간과 해당 시간 동안 체크 포인트를 시도하는 &quot;리더 간격&quot;이 있는지 확인하면이 시나리오를 피할 수 있습니다. 동시 판독기가 많은 응용 프로그램에서는 리턴하기 전에 체크 포인트가 완료 될 수 있도록 &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; 옵션을 사용하여 수동 체크 포인트를 실행하는 것도 고려할 수 있습니다 . &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_RESTART&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; 를 사용할 때 의 단점은 검사 점이 실행되는 동안 리더가 차단 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="727ff7ebcc4d3f37cef6d2c8786627a54c4374f3" translate="yes" xml:space="preserve">
          <source>This second command will &quot;checkout&quot; the latest check-in from the SQLite source tree into your current directory. Subsequently, you can easily switch to a different version by typing:</source>
          <target state="translated">이 두 번째 명령은 SQLite 소스 트리에서 현재 디렉토리로 최신 체크인을 &quot;체크 아웃&quot;합니다. 결과적으로 다음을 입력하여 다른 버전으로 쉽게 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61831695cc5a4baa6ebe1da3db0f44d7f1cd6a66" translate="yes" xml:space="preserve">
          <source>This second number is too small. The first number is closer to the desired value of 47.49, so that is the one that gets used. But it is not exact. Most decimal values work this way in IEEE 754. Remember the key point we made above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c18c66c49575067fb81143d22f048900116d477" translate="yes" xml:space="preserve">
          <source>This second query will likely use the index because now the expression in the WHERE clause (x+y) matches the expression in the index exactly.</source>
          <target state="translated">이 두 번째 쿼리는 이제 WHERE 절 (x + y)의식이 인덱스의 식과 정확히 일치하므로 인덱스를 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7abd749e3d4aa6938fa840ccf9ebcf410ac2c722" translate="yes" xml:space="preserve">
          <source>This second query would find both entry 1 (the SQLite.org office) which is entirely contained within the query box and also the 12th Congressional District which extends well outside the query box but still overlaps the query box.</source>
          <target state="translated">이 두 번째 쿼리는 쿼리 상자 내에 완전히 포함 된 항목 1 (SQLite.org 사무소)과 쿼리 상자 외부로 확장되지만 여전히 쿼리 상자와 겹치는 12 번째 의회 구역을 모두 찾습니다.</target>
        </trans-unit>
        <trans-unit id="810173a22163c6dabf4d33c2feedff31184b22f0" translate="yes" xml:space="preserve">
          <source>This section describes at a high-level the way the FTS module stores its index and content in the database. It is &lt;b&gt;not necessary to read or understand the material in this section in order to use FTS&lt;/b&gt; in an application. However, it may be useful to application developers attempting to analyze and understand FTS performance characteristics, or to developers contemplating enhancements to the existing FTS feature set.</source>
          <target state="translated">이 섹션에서는 FTS 모듈이 색인과 내용을 데이터베이스에 저장하는 방법을 개략적으로 설명합니다. 응용 프로그램에서 &lt;b&gt;FTS를 사용하기 위해이 섹션의 내용을 읽거나 이해할 필요&lt;/b&gt; 는 &lt;b&gt;없습니다&lt;/b&gt; . 그러나 FTS 성능 특성을 분석하고 이해하려는 응용 프로그램 개발자 나 기존 FTS 기능 세트를 개선하려는 개발자에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d17de40cff5e777833059135b83479f23261c6" translate="yes" xml:space="preserve">
          <source>This section describes how the assumptions presented in the parent section apply to the individual API functions and operations provided by the VFS to SQLite for the purposes of modifying the contents of the file-system.</source>
          <target state="translated">이 섹션에서는 상위 섹션에 제시된 가정이 파일 시스템의 내용을 수정하기 위해 VFS가 SQLite에 제공하는 개별 API 함수 및 작업에 적용되는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="02fc8cc874e5b9c1577641015a9135b50baf469c" translate="yes" xml:space="preserve">
          <source>This section describes the VFS operations that take place when a new database connection is created.</source>
          <target state="translated">이 절에서는 새 데이터베이스 연결이 작성 될 때 발생하는 VFS 조작에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4342e6a0d98af49025e37a5849302106877ca948" translate="yes" xml:space="preserve">
          <source>This section describes the VFS operations that take place when an existing database connection is closed (destroyed).</source>
          <target state="translated">이 섹션에서는 기존 데이터베이스 연결이 닫히거나 제거 될 때 발생하는 VFS 작업에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c2a1275da916ed3be3012a2f190ab9c2d388331b" translate="yes" xml:space="preserve">
          <source>This section describes the assumptions that SQLite makes about the content of a file-system following a power or system failure. In other words, it describes the extent of file and file-system corruption that such an event may cause.</source>
          <target state="translated">이 섹션에서는 전원 또는 시스템 장애 후 SQLite가 파일 시스템의 내용에 대해 가정하는 내용을 설명합니다. 즉, 이러한 이벤트로 인해 발생할 수있는 파일 및 파일 시스템 손상의 정도를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="edc6897ad6af970e04c51704d6197016314c42a7" translate="yes" xml:space="preserve">
          <source>This section describes the format used by an SQLite</source>
          <target state="translated">이 섹션에서는 SQLite가 사용하는 형식에 대해 설명합니다</target>
        </trans-unit>
        <trans-unit id="9a13aa03c88e9ab244b07031a9171942d0c6ff54" translate="yes" xml:space="preserve">
          <source>This section describes the procedure that SQLite uses to detect a</source>
          <target state="translated">이 섹션에서는 SQLite가</target>
        </trans-unit>
        <trans-unit id="bfe35a7e5c6f4117d5a645ddcb82fb94f15ae997" translate="yes" xml:space="preserve">
          <source>This section describes the progression of an SQLite</source>
          <target state="translated">이 섹션에서는 SQLite의 진행 상황에 대해 설명합니다</target>
        </trans-unit>
        <trans-unit id="f48fcfeb28df528b9f1d5864af41f8c4b970f962" translate="yes" xml:space="preserve">
          <source>This section describes the way the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt;, and &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; commands interact with SQLite's foreign keys.</source>
          <target state="translated">이 절에서는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 및 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 명령이 SQLite의 외래 키와 상호 작용 하는 방식에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="58dd65dbe0083407cb2b8d63f24be502e95d9bbe" translate="yes" xml:space="preserve">
          <source>This section documents those assumptions made about the system that the VFS adaptor provides access to. The assumptions noted in section</source>
          <target state="translated">이 절에서는 VFS 어댑터가 액세스 할 수있는 시스템에 대한 가정을 설명합니다. 섹션에 언급 된 가정</target>
        </trans-unit>
        <trans-unit id="1a8f1342dd83bc1cc71b3fbbf42a58b70897383c" translate="yes" xml:space="preserve">
          <source>This section is a combination of the Plan For Software Aspects Of Certification and the Software Development Plan sections of DO-178B.</source>
          <target state="translated">이 섹션은 인증 소프트웨어 측면 계획 및 DO-178B의 소프트웨어 개발 계획 섹션의 조합입니다.</target>
        </trans-unit>
        <trans-unit id="30a1220c5879164f4d9cfc83dbec5374939998e6" translate="yes" xml:space="preserve">
          <source>This section is different from the others. Most other sections of this document talks about a particular SQL command. This section does not talk about a standalone command but about &quot;expressions&quot; which are subcomponents of most other commands.</source>
          <target state="translated">이 섹션은 다른 섹션과 다릅니다. 이 문서의 대부분의 다른 섹션에서는 특정 SQL 명령에 대해 설명합니다. 이 절에서는 독립형 명령이 아니라 대부분의 다른 명령의 하위 구성 요소 인 &quot;표현식&quot;에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7d95e851797a07bafc31faa128d84f9f3bcc87a9" translate="yes" xml:space="preserve">
          <source>This section lists a few limitations and omitted features that are not mentioned elsewhere.</source>
          <target state="translated">이 섹션에는 다른 곳에서는 언급되지 않은 몇 가지 제한 사항과 생략 된 기능이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f346ae80c10c621b4cd5c514c74301adfd2cd43" translate="yes" xml:space="preserve">
          <source>This section only describes the format of the journal file and the various objects that make it up. But because a journal file may be read by an SQLite process following recovery from a system failure (</source>
          <target state="translated">이 섹션에서는 저널 파일의 형식과이를 구성하는 다양한 개체에 대해서만 설명합니다. 그러나 시스템 오류 복구 후 SQLite 프로세스에서 저널 파일을 읽을 수 있기 때문에 (</target>
        </trans-unit>
        <trans-unit id="aa8720f51b774a70c5f7cce02a309b8eb281c900" translate="yes" xml:space="preserve">
          <source>This section provides an overview of and example code demonstrating the integration of RBU Vacuum into an application program. For full details, refer to the comments in &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;header file sqlite3rbu.h&lt;/a&gt;.</source>
          <target state="translated">이 섹션에서는 RBU Vacuum을 응용 프로그램에 통합하는 방법을 보여주는 코드 개요와 예제를 제공합니다. 자세한 내용은 &lt;a href=&quot;http://sqlite.org/src/doc/trunk/ext/rbu/sqlite3rbu.h&quot;&gt;헤더 파일 sqlite3rbu.h&lt;/a&gt; 의 주석을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c2f6418e2cfdab367ef3398ce17bbd29bfdf0e6" translate="yes" xml:space="preserve">
          <source>This section provides examples that demonstrate how to use the sessions extension.</source>
          <target state="translated">이 섹션에서는 세션 확장을 사용하는 방법을 보여주는 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b87966e6f8ae748c88886a65d993a4d228e6112" translate="yes" xml:space="preserve">
          <source>This sets the maximum number of statements that can be cached. The upper limit is 100. The default is 10. If you set the cache size to 0, no caching is done.</source>
          <target state="translated">캐시 할 수있는 최대 명령문 수를 설정합니다. 상한은 100입니다. 기본값은 10입니다. 캐시 크기를 0으로 설정하면 캐싱이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ac8ffe5a0d74c555a62f1b92afaea89504bf302" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;on&quot; for legacy compatibility, however all applications are advised to turn it off if possible. This setting can also be controlled using the &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; statement.</source>
          <target state="translated">이 설정은 레거시 호환성을 위해 기본적으로 &quot;on&quot;으로 설정되지만 모든 응용 프로그램은 가능하면이 기능을 끄는 것이 좋습니다. 이 설정은 &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; 문을 사용하여 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5315120760f3d3f82397813611296a7c3158949" translate="yes" xml:space="preserve">
          <source>This setting defaults to &quot;on&quot; for legacy compatibility, however all applications are advised to turn it off if possible. This setting can also be controlled using the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; statement.</source>
          <target state="translated">이 설정은 레거시 호환성을 위해 기본적으로 &quot;on&quot;으로 설정되지만 모든 응용 프로그램은 가능하면이 기능을 끄는 것이 좋습니다. 이 설정은 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema&lt;/a&gt; 문을 사용하여 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5e77f8448a0f37903a1b46b5a44275edbc4cdc59" translate="yes" xml:space="preserve">
          <source>This spellfix1 &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; can be used to search a large vocabulary for close matches. For example, spellfix1 can be used to suggest corrections to misspelled words. Or, it could be used with &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; to do full-text search using potentially misspelled words.</source>
          <target state="translated">이 spellfix1 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하면 큰 단어를 검색하여 근접한 항목을 찾을 수 있습니다. 예를 들어, spellfix1은 철자가 틀린 단어에 대한 수정을 제안하는 데 사용될 수 있습니다. 또는 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 와 함께 사용하여 철자가 틀린 단어를 사용하여 전체 텍스트 검색을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6b40152c9ab376b3fd172fa9a2eebf595b1b8d89" translate="yes" xml:space="preserve">
          <source>This statement detaches an additional database connection previously attached using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. When not in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;, it is possible to have the same database file attached multiple times using different names, and detaching one connection to a file will leave the others intact.</source>
          <target state="translated">이 명령문은 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문을 사용하여 이전에 접속 된 추가 데이터베이스 연결을 분리합니다 . &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 아닌 경우 다른 이름을 사용하여 동일한 데이터베이스 파일을 여러 번 첨부 할 수 있으며 파일에 대한 하나의 연결을 분리하면 다른 데이터베이스는 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="34e0116d5c2febec8b6ae2d5a756ac7b5b48d70e" translate="yes" xml:space="preserve">
          <source>This step corresponds to steps &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt;, &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;, and &lt;a href=&quot;#section_3_10&quot;&gt;3.10&lt;/a&gt; in the single-file commit scenario described previously.</source>
          <target state="translated">이 단계 는 앞에서 설명한 단일 파일 커밋 시나리오의 단계 &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; , &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; 및 &lt;a href=&quot;#section_3_10&quot;&gt;3.10&lt;/a&gt; 에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0bc82eb6eb64e5996a7d75a58cb1d3a4ce9124d4" translate="yes" xml:space="preserve">
          <source>This step is analogous to &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; in the single-file commit scenario described above.</source>
          <target state="translated">이 단계는 위에서 설명한 단일 파일 커밋 시나리오의 &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; 단계와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e70a15ffedf708ad5c91c97bd2e22cff7b5bcebe" translate="yes" xml:space="preserve">
          <source>This step is usually more complicated than simply flushing the rollback journal to the disk. On most platforms two separate flush (or fsync()) operations are required. The first flush writes out the base rollback journal content. Then the header of the rollback journal is modified to show the number of pages in the rollback journal. Then the header is flushed to disk. The details on why we do this header modification and extra flush are provided in a later section of this paper.</source>
          <target state="translated">이 단계는 일반적으로 단순히 롤백 저널을 디스크로 플러시하는 것보다 더 복잡합니다. 대부분의 플랫폼에서 두 개의 개별 플러시 (또는 fsync ()) 작업이 필요합니다. 첫 번째 플러시는 기본 롤백 저널 내용을 작성합니다. 그런 다음 롤백 저널의 헤더가 롤백 저널의 페이지 수를 표시하도록 수정됩니다. 그런 다음 헤더가 디스크로 플러시됩니다. 이 헤더 수정 및 추가 플러시를 수행하는 이유에 대한 자세한 내용은이 백서의 뒷부분에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="60743213af70350c2b0e4cdfe091bf8177abcaf2" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">&quot;가상 테이블 모듈&quot;이라고도하는이 구조는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 구현을 정의 합니다 . 이 구조는 대부분 모듈에 대한 메소드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="efa2100d52bcf7ffba30b15c96c96f87de04a155" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">&quot;가상 테이블 모듈&quot;이라고도하는이 구조는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 구현을 정의합니다 . 이 구조는 대부분 모듈의 메소드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="5114924ab3d2182dbc86222d1c257aa678f84e0e" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">&quot;가상 테이블 모듈&quot;이라고도하는이 구조는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 구현을 정의 합니다 . 이 구조는 대부분 모듈에 대한 메소드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="8b149e60f46d57857e167e94989fa609269eabe7" translate="yes" xml:space="preserve">
          <source>This structure, sometimes called a &quot;virtual table module&quot;, defines the implementation of a &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. This structure consists mostly of methods for the module.</source>
          <target state="translated">&quot;가상 테이블 모듈&quot;이라고도하는이 구조는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 구현을 정의합니다 . 이 구조는 대부분 모듈의 메소드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="c18963c23800694aa33718fdc0a2deeb514a26e5" translate="yes" xml:space="preserve">
          <source>This substitution works like %q except that it doubles all double-quote characters (&quot;) instead of single-quotes, making the result suitable for using with a double-quoted identifier name in an SQL statement.</source>
          <target state="translated">이 대체는 작은 따옴표 대신 모든 큰 따옴표 문자 ( &quot;)를 두 배로한다는 점을 제외하고는 % q와 유사하게 작동하므로 결과는 SQL 문에서 큰 따옴표로 묶인 식별자 이름과 함께 사용하기에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="42be9e1e34f4a968dedd36f548fc29765ab65613" translate="yes" xml:space="preserve">
          <source>This superclass exists in order to define fields of the cursor that are common to all implementations.</source>
          <target state="translated">이 슈퍼 클래스는 모든 구현에 공통적 인 커서 필드를 정의하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="28a7628277525a8ffd76f253de9da66f017821fe" translate="yes" xml:space="preserve">
          <source>This table contains most of the full-text index data.</source>
          <target state="translated">이 테이블에는 대부분의 전체 텍스트 인덱스 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="63f8d9aa5562f8625c8b6180eed7f4824807c199" translate="yes" xml:space="preserve">
          <source>This table contains the remainder of the full-text index data. It is almost always much smaller than the &amp;lt;name&amp;gt;_data table.</source>
          <target state="translated">이 테이블에는 나머지 전체 텍스트 인덱스 데이터가 포함됩니다. 거의 항상 &amp;lt;name&amp;gt; _data 테이블보다 훨씬 작습니다.</target>
        </trans-unit>
        <trans-unit id="99a29c55c2ba7d8e5ed532c3667ff2c75e355b87" translate="yes" xml:space="preserve">
          <source>This template will be expanded considerably as we consider additional complications such as joins, compound selects, using indices to speed the search, sorting, and aggregate functions with and without GROUP BY and HAVING clauses. But the same basic ideas will continue to apply.</source>
          <target state="translated">이 템플릿은 GROUP BY 및 HAVING 절을 사용하거나 사용하지 않고 검색, 정렬 및 집계 함수의 속도를 높이기 위해 인덱스를 사용하여 조인, 복합 선택과 같은 추가 복잡성을 고려할 때 상당히 확장됩니다. 그러나 동일한 기본 아이디어가 계속 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="24117611eed72daf6182805466d7956918d024ae" translate="yes" xml:space="preserve">
          <source>This template will work, but it is likely to be slow since we are now dealing with an O(N&lt;sup&gt;2&lt;/sup&gt;) loop. But it often works out that the WHERE clause can be factored into terms and that one or more of those terms will involve only columns in the first table. When this happens, we can factor part of the WHERE clause test out of the inner loop and gain a lot of efficiency. So a better template would be something like this:</source>
          <target state="translated">이 템플릿은 작동하지만 이제 O (N &lt;sup&gt;2&lt;/sup&gt; ) 루프를 처리하므로 속도가 느려질 수 있습니다 . 그러나 WHERE 절을 용어로 고려할 수 있으며 이러한 용어 중 하나 이상이 첫 번째 테이블의 열만 포함한다는 사실이 종종 해결됩니다. 이런 일이 발생하면 내부 루프에서 WHERE 절 테스트의 일부를 고려하여 많은 효율성을 얻을 수 있습니다. 따라서 더 나은 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40b7eb475c7480d45cf5d3a80f0e3d7ffa7f110b" translate="yes" xml:space="preserve">
          <source>This test does 100 queries on a 25000 entry table without an index, thus requiring a full table scan. Prior versions of SQLite used to be slower than PostgreSQL and MySQL on this test, but recent performance enhancements have increased its speed so that it is now the fastest of the group.</source>
          <target state="translated">이 테스트는 인덱스가없는 25000 항목 테이블에서 100 개의 쿼리를 수행하므로 전체 테이블 스캔이 필요합니다. 이전 버전의 SQLite는이 테스트에서 PostgreSQL 및 MySQL보다 느 렸지만 최근의 성능 향상으로 속도가 빨라져 그룹에서 가장 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="90bd4e8e5db8b4283e65f22e76a0a17334a8b857" translate="yes" xml:space="preserve">
          <source>This test is significant because it is one of the few where PostgreSQL is faster than MySQL. The asynchronous SQLite is, however, faster then both the other two.</source>
          <target state="translated">이 테스트는 PostgreSQL이 MySQL보다 빠른 몇 가지 중 하나이기 때문에 중요합니다. 그러나 비동기 SQLite는 다른 두 가지보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ff90f130b4a2f4ca55eaa179d90bc136860c0418" translate="yes" xml:space="preserve">
          <source>This test still does 100 full table scans but it uses uses string comparisons instead of numerical comparisons. SQLite is over three times faster than PostgreSQL here and about 30% faster than MySQL.</source>
          <target state="translated">이 테스트는 여전히 100 개의 전체 테이블 스캔을 수행하지만 숫자 비교 대신 문자열 비교를 사용합니다. SQLite는 PostgreSQL보다 3 배 이상 빠르며 MySQL보다 약 30 % 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="75cb6907a37685d70c3eab0489918444cffd71bd" translate="yes" xml:space="preserve">
          <source>This value may only be returned if the second argument to the conflict handler was SQLITE_CHANGESET_DATA or SQLITE_CHANGESET_CONFLICT. If this is not the case, any changes applied so far are rolled back and the call to sqlite3changeset_apply() returns SQLITE_MISUSE.</source>
          <target state="translated">이 값은 충돌 핸들러에 대한 두 번째 인수가 SQLITE_CHANGESET_DATA 또는 SQLITE_CHANGESET_CONFLICT 인 경우에만 리턴 될 수 있습니다. 그렇지 않은 경우 지금까지 적용된 모든 변경 사항이 롤백되고 sqlite3changeset_apply ()에 대한 호출은 SQLITE_MISUSE를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fe35134e2f2f77c904cd39e87bb164a345691cc7" translate="yes" xml:space="preserve">
          <source>This version of the query is very similar to that used by the &lt;a href=&quot;http://www.sqlite.org/search?q=fts3&quot;&gt;sqlite.org documentation search&lt;/a&gt; application.</source>
          <target state="translated">이 버전의 쿼리는 &lt;a href=&quot;http://www.sqlite.org/search?q=fts3&quot;&gt;sqlite.org 문서 검색&lt;/a&gt; 응용 프로그램 에서 사용하는 것과 매우 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="e1b7ba2bf7de254b6233045869c121647086b777" translate="yes" xml:space="preserve">
          <source>This way, even if the tokenizer does not provide synonyms when tokenizing query text (it should not - to do so would be inefficient), it doesn't matter if the user queries for 'first + place' or '1st + place', as there are entries in the FTS index corresponding to both forms of the first token.</source>
          <target state="translated">이런 식으로, 토크 나이저가 쿼리 텍스트를 토큰화할 때 동의어를 제공하지 않더라도 (비효율적이지 않아야 함) 사용자가 'first + place'또는 '1st + place'를 쿼리하는지 여부는 중요하지 않습니다. FTS 인덱스에 첫 번째 토큰의 두 가지 형식에 해당하는 항목이 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8b49b7dda3f7ed95bc6c0488f10b2d72b542544f" translate="yes" xml:space="preserve">
          <source>This way, it doesn't matter if the unlock-notify callback has already been invoked, or is being invoked, when the wait_for_unlock_notify() thread begins blocking.</source>
          <target state="translated">이 방법으로, wait_for_unlock_notify () 스레드가 블로킹을 시작할 때 잠금 해제 알림 콜백이 이미 호출되었는지 또는 호출되고 있는지는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e965074df0aa19e8da42be140ba59a4414b6e325" translate="yes" xml:space="preserve">
          <source>This way, the constraint is enforced by SQLite. Attempting to insert a row into the</source>
          <target state="translated">이런 식으로 제약 조건은 SQLite에 의해 시행됩니다. 행을 삽입하려고</target>
        </trans-unit>
        <trans-unit id="1963503ab7ddc8537d802ec1a46d6ab92fd36cda" translate="yes" xml:space="preserve">
          <source>This works just like the Eq opcode except that the jump is taken if the operands in registers P1 and P3 are not equal. See the Eq opcode for additional information.</source>
          <target state="translated">이것은 레지스터 P1과 P3의 피연산자가 같지 않은 경우 점프가 수행된다는 점을 제외하고는 Eq opcode와 동일하게 작동합니다. 추가 정보는 Eq opcode를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ba4077bf92f07ea1c02be8f845355e71e2fb6bc1" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is greater than or equal to the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">이는 레지스터 P3의 내용이 레지스터 P1의 내용보다 크거나 같은 경우 점프가 수행된다는 점을 제외하고는 Lt opcode와 동일하게 작동합니다. 추가 정보는 Lt opcode를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72ecdb2970fef3b315f55cce910e6f260e472e04" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is greater than the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">레지스터 P3의 내용이 레지스터 P1의 내용보다 큰 경우 점프가 수행된다는 점을 제외하면 Lt opcode와 동일하게 작동합니다. 추가 정보는 Lt opcode를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1c247f5679a36aaa3ff0f0b8bb4e1ddc0bb02eb" translate="yes" xml:space="preserve">
          <source>This works just like the Lt opcode except that the jump is taken if the content of register P3 is less than or equal to the content of register P1. See the Lt opcode for additional information.</source>
          <target state="translated">이는 레지스터 P3의 내용이 레지스터 P1의 내용보다 작거나 같은 경우 점프가 수행된다는 점을 제외하고는 Lt opcode와 동일하게 작동합니다. 추가 정보는 Lt opcode를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ccca64f89115392e8d23869e20d951ca911dd666" translate="yes" xml:space="preserve">
          <source>Those columns of the ORDER BY that are already in the correct order due to indexes can be omitted from the sort key, further reducing storage requirements and CPU time.</source>
          <target state="translated">인덱스로 인해 올바른 순서로 이미 정렬 된 ORDER BY의 열을 정렬 키에서 생략하여 스토리지 요구 사항 및 CPU 시간을 더욱 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d2c9c2c10bcace961c3bdf096488ff4797705a5" translate="yes" xml:space="preserve">
          <source>Those familiar with &lt;a href=&quot;lang_createtrigger&quot;&gt;SQLite triggers&lt;/a&gt; will have noticed that the &quot;ON DELETE SET DEFAULT&quot; action demonstrated in the example above is similar in effect to the following AFTER DELETE trigger:</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger&quot;&gt;SQLite 트리거에&lt;/a&gt; 익숙한 사용자는 위 예에서 설명 된 &quot;ON DELETE SET DEFAULT&quot;조치가 다음 AFTER DELETE 트리거와 사실상 유사하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d18009fe3f6af8b99678afaf8cbdbff34a63626" translate="yes" xml:space="preserve">
          <source>Though SQLite is resistant to database corruption, it is not immune. This document describes the various ways that an SQLite database might go corrupt.</source>
          <target state="translated">SQLite는 데이터베이스 손상에 강하지 만 면역성이 없습니다. 이 문서는 SQLite 데이터베이스가 손상 될 수있는 다양한 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="63d965d7269cad4f0b5e995d2cd0b230b8d8b12b" translate="yes" xml:space="preserve">
          <source>Though most application should not notice any change (except that they run a little faster), if problems arise then the legacy behavior can be restored at compile-time by using the following options to the C-compiler:</source>
          <target state="translated">대부분의 응용 프로그램은 조금 더 빠르게 실행되는 것을 제외하고는 변경 사항을 알 수 없지만 문제가 발생하면 C 컴파일러에 다음 옵션을 사용하여 컴파일시 레거시 동작을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b87710f7e7be3fc29f9b95f7ed9731b29e09de9b" translate="yes" xml:space="preserve">
          <source>Though stable now, when SQLite was first designed, the rules for unicode case folding where still in flux. That means that the behavior might have changed with each new unicode release, disrupting applications and corrupting indexes in the process.</source>
          <target state="translated">지금은 안정적이지만 SQLite가 처음 설계되었을 때 여전히 유동적 인 유니 코드 케이스 접는 규칙. 즉, 새로운 유니 코드 릴리스마다 동작이 변경되어 응용 프로그램이 중단되고 프로세스의 인덱스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91666d572b5dcdd0257e06fbd15cb93e3374b565" translate="yes" xml:space="preserve">
          <source>Though the SQLite developers do not consider CVEs to be a reliable source of information about bugs in SQLite, they recognize that many groups, and especially small teams working at the bottom of tall bureaucracies, sometimes need to track CVEs, whether they are useful or not. To aid in this chore, the following table of recent CVEs affecting SQLite is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32c0373383e43339e4cb612416beb69372e9cd00" translate="yes" xml:space="preserve">
          <source>Though these routines exist for the use of the SQLite core, application code is free to use these routines as well, if desired. A mutex is an &lt;a href=&quot;c3ref/mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; object. The &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; routine allocates a new mutex object and returns a pointer to it. The argument to &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; should be &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_FAST&lt;/a&gt; or &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_RECURSIVE&lt;/a&gt; for non-recursive and recursive mutexes, respectively. If the underlying system does not provide non-recursive mutexes, then a recursive mutex can be substituted in that case. The argument to &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt; can also be a constant designating one of several static mutexes:</source>
          <target state="translated">이러한 루틴은 SQLite 코어를 사용하기 위해 존재하지만 원하는 경우 응용 프로그램 코드에서도 이러한 루틴을 자유롭게 사용할 수 있습니다. 뮤텍스는 &lt;a href=&quot;c3ref/mutex&quot;&gt;sqlite3_mutex&lt;/a&gt; 객체입니다. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()&lt;/a&gt; 루틴 할당 새로운 뮤텍스 개체 반환이에 대한 포인터. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()에&lt;/a&gt; 대한 인수 는 각각 비 재귀 및 재귀 뮤텍스의 경우 &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_FAST&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_RECURSIVE&lt;/a&gt; 여야합니다 . 기본 시스템이 비 재귀 뮤텍스를 제공하지 않으면, 그 경우 재귀 뮤텍스를 대체 할 수 있습니다. &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()에&lt;/a&gt; 대한 인수 는 여러 정적 뮤텍스 중 하나를 지정하는 상수 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8e45f7c88cdfcb99131b4aaa5838c20ed6b8b6" translate="yes" xml:space="preserve">
          <source>Threads pragma</source>
          <target state="translated">스레드 pragma</target>
        </trans-unit>
        <trans-unit id="4aa00012e302f932462a2aadd7eac2be49a6dc69" translate="yes" xml:space="preserve">
          <source>Three independently developed test harnesses</source>
          <target state="translated">독립적으로 개발 된 3 개의 테스트 하니스</target>
        </trans-unit>
        <trans-unit id="101417f647e79751240d39257253cbe0e7dba110" translate="yes" xml:space="preserve">
          <source>Three new &quot;_pointer()&quot; interfaces were added to SQLite 3.20.0 (2017-08-01):</source>
          <target state="translated">세 개의 새로운 &quot;_pointer ()&quot;인터페이스가 SQLite 3.20.0 (2017-08-01)에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="176df8577c19b0a0b1cbe128b8ab9971af780b41" translate="yes" xml:space="preserve">
          <source>Three new interfaces are used to create alternative OS interfaces: &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;, &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;, and &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt;.</source>
          <target state="translated">대체 OS 인터페이스를 생성하기 위해 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; , &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()의&lt;/a&gt; 세 가지 새로운 인터페이스가 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bddfc84ad3ee0ff45f2511104b4769a3c7921c10" translate="yes" xml:space="preserve">
          <source>Three new objects are defined for specifying I/O procedures: &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;, &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;, and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">I / O 프로 시저를 지정하기 위해 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; , &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 및 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 세 가지 새 오브젝트가 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="26f24f48d0d16296ec7a50525c0bafe03ba4c4e6" translate="yes" xml:space="preserve">
          <source>Three separate builds are used to validate the SQLite software.</source>
          <target state="translated">SQLite 소프트웨어의 유효성을 검사하기 위해 세 개의 별도 빌드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="72ea1e12fc0eda1090ebcae83911a5114d06b045" translate="yes" xml:space="preserve">
          <source>Throughout this article, we will call the mass storage device &quot;disk&quot; even though the mass storage device might really be flash memory.</source>
          <target state="translated">이 기사에서는 대용량 저장 장치가 실제로 플래시 메모리 일지라도 대용량 저장 장치를 &quot;디스크&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="e196474211e435a6f5483b8a22aa9fc7215731cf" translate="yes" xml:space="preserve">
          <source>Throw an error if the ON clause of a LEFT JOIN references tables to the right of the ON clause. This is the same behavior as PostgreSQL. Formerly, SQLite silently converted the LEFT JOIN into an INNER JOIN. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/25e335f802dd&quot;&gt;25e335f802dd&lt;/a&gt;.</source>
          <target state="translated">LEFT JOIN의 ON 절이 ON 절의 오른쪽에있는 테이블을 참조하면 오류가 발생합니다. 이것은 PostgreSQL과 같은 동작입니다. 이전에는 SQLite가 LEFT JOIN을 INNER JOIN으로 자동 변환했습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/25e335f802dd&quot;&gt;25e335f802dd&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="21549ff8099c71713aab7703fb00b1ee44e6073d" translate="yes" xml:space="preserve">
          <source>Thus a long-running read transaction can prevent a checkpointer from making progress. But presumably every read transaction will eventually end and the checkpointer will be able to continue.</source>
          <target state="translated">따라서 장기 실행 읽기 트랜잭션은 검사 점이 진행되지 못하게 할 수 있습니다. 그러나 아마도 모든 읽기 트랜잭션은 결국 종료되고 검사 점은 계속할 수있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="66a9c8441c0a2a7c6aa8fad21d196fb6d9fccc17" translate="yes" xml:space="preserve">
          <source>Thus, in some cases, a WITHOUT ROWID table can use about half the amount of disk space and can operate nearly twice as fast. Of course, in a real-world schema, there will typically be secondary indices and/or UNIQUE constraints, and the situation is more complicated. But even then, there can often be space and performance advantages to using WITHOUT ROWID on tables that have non-integer or composite PRIMARY KEYs.</source>
          <target state="translated">따라서 WITHOUT ROWID 테이블은 디스크 공간의 약 절반을 사용할 수 있으며 거의 ​​두 배 빠른 속도로 작동 할 수 있습니다. 물론 실제 스키마에는 일반적으로 보조 인덱스 및 / 또는 UNIQUE 제약 조건이 있으며 상황이 더 복잡합니다. 그러나 정수가 아닌 복합 PRIMARY KEY가있는 테이블에서 WITHOUT ROWID를 사용하면 공간 및 성능 이점이 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="c862bae7f1be02bdcb9d8e255dd3ec4c98f14797" translate="yes" xml:space="preserve">
          <source>Time Strings</source>
          <target state="translated">시간 문자열</target>
        </trans-unit>
        <trans-unit id="3efef30f9e54a3aa98bf3ea7266c1fe5e32903a6" translate="yes" xml:space="preserve">
          <source>Timeout method</source>
          <target state="translated">타임 아웃 방법</target>
        </trans-unit>
        <trans-unit id="4c2102fd7eb59a1aa14201958dca73486b19babc" translate="yes" xml:space="preserve">
          <source>Tip: If the application requires a stricter relationship between</source>
          <target state="translated">팁 : 응용 프로그램간에보다 엄격한 관계가 필요한 경우</target>
        </trans-unit>
        <trans-unit id="9e8b45c5519a803740f95fa980a6771d28344be2" translate="yes" xml:space="preserve">
          <source>Tip: If the command &quot;PRAGMA foreign_keys&quot; returns no data instead of a single row containing &quot;0&quot; or &quot;1&quot;, then the version of SQLite you are using does not support foreign keys (either because it is older than 3.6.19 or because it was compiled with &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; or &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER&lt;/a&gt; defined).</source>
          <target state="translated">팁 : &quot;PRAGMA foreign_keys&quot;명령이 &quot;0&quot;또는 &quot;1&quot;을 포함하는 단일 행 대신 데이터를 리턴하지 않으면 사용중인 SQLite 버전이 외래 키를 지원하지 않는 것입니다 (3.6.19보다 오래되었거나 &lt;a href=&quot;compile#omit_foreign_key&quot;&gt;SQLITE_OMIT_FOREIGN_KEY&lt;/a&gt; 또는 &lt;a href=&quot;compile#omit_trigger&quot;&gt;SQLITE_OMIT_TRIGGER가&lt;/a&gt; 정의 되어 컴파일 되었으므로 ).</target>
        </trans-unit>
        <trans-unit id="c0bd7276e013b0c8d316928d427b046dc76a4f10" translate="yes" xml:space="preserve">
          <source>To &quot;apply affinity&quot; means to convert an operand to a particular storage class if and only if the conversion does not lose essential information. Numeric values can always be converted into TEXT. TEXT values can be converted into numeric values if the text content is a well-formed integer or real literal, but not a hexadecimal integer literal. BLOB values are converted into TEXT values by simply interpreting the binary BLOB context as a text string in the current database encoding.</source>
          <target state="translated">&quot;친화도 적용&quot;이란 변환이 필수 정보를 잃지 않는 경우에만 피연산자를 특정 스토리지 클래스로 변환하는 것을 의미합니다. 숫자 값은 항상 TEXT로 변환 할 수 있습니다. 텍스트 내용이 올바른 형식의 정수 또는 실제 리터럴이지만 16 진 정수 리터럴이 아닌 경우 TEXT 값을 숫자 값으로 변환 할 수 있습니다. BLOB 값은 단순히 바이너리 BLOB 컨텍스트를 현재 데이터베이스 인코딩의 텍스트 문자열로 해석하여 TEXT 값으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="9953da657538c4e50d519e562b12ca1980f1dcb7" translate="yes" xml:space="preserve">
          <source>To &quot;apply affinity&quot; means to convert an operand to a particular storage class if and only if the conversion is lossless and reversible. Affinity is applied to operands of a comparison operator prior to the comparison according to the following rules in the order shown:</source>
          <target state="translated">&quot;호환성 적용&quot;은 변환이 손실이없고 되돌릴 수있는 경우에만 피연산자를 특정 저장소 클래스로 변환하는 것을 의미합니다. 선호도는 표시된 순서대로 다음 규칙에 따라 비교하기 전에 비교 연산자의 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5a8c0c09fa3a23fe732db499c52749bc592395f7" translate="yes" xml:space="preserve">
          <source>To SQL, the values created by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; are indistinguishable from NULL. An SQL statement that tries to use the &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex()&lt;/a&gt; function to read the value of a pointer will get an SQL NULL answer. The only way to discover whether or not a value has an associated pointer is to use the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; interface with the appropriate type string T.</source>
          <target state="translated">SQL에서 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; 의해 작성된 값 은 NULL과 구별 할 수 없습니다. &lt;a href=&quot;lang_corefunc#hex&quot;&gt;hex ()&lt;/a&gt; 함수 를 사용하여 포인터 값을 읽으 려고 시도하는 SQL 문 은 SQL NULL 응답을 얻습니다. 값에 연관된 포인터가 있는지 여부를 발견하는 유일한 방법은 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 인터페이스를 적절한 유형 문자열 T와 함께 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bd20e3a8ddd8b4faa78ec9a165e77cef8f3d196f" translate="yes" xml:space="preserve">
          <source>To achieve the best long-term query performance without the need to do a detailed engineering analysis of the application schema and SQL, it is recommended that applications run &quot;PRAGMA optimize&quot; (with no arguments) just before closing each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;. Long-running applications might also benefit from setting a timer to run &quot;PRAGMA optimize&quot; every few hours.</source>
          <target state="translated">응용 프로그램 스키마 및 SQL에 대한 자세한 엔지니어링 분석을 수행 할 필요없이 최상의 장기 쿼리 성능을 얻으려면 응용 프로그램이 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 닫기 직전에 &quot;PRAGMA optimize&quot;(인수없이)를 실행하는 것이 좋습니다 . 장시간 실행되는 응용 프로그램은 몇 시간마다 &quot;PRAGMA optimize&quot;를 실행하도록 타이머를 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4711fd773d775e7aba9628e842931be929ca6432" translate="yes" xml:space="preserve">
          <source>To activate memory-mapped I/O, an application can set the mmap_size to some large value. For example:</source>
          <target state="translated">메모리 매핑 된 I / O를 활성화하기 위해 응용 프로그램은 mmap_size를 큰 값으로 설정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="645a357eaf144992f34fe37551ab4e935405fce2" translate="yes" xml:space="preserve">
          <source>To activate the undo/redo logic, invoke the undo::activate command with all classes (tables) that are to participate in the undo/redo as arguments. Use undo::deactivate, undo::freeze, and undo::unfreeze to control the state of the undo/redo mechanism.</source>
          <target state="translated">실행 취소 / 다시 실행 로직을 활성화하려면 실행 취소 / 다시 실행에 참여할 모든 클래스 (테이블)와 함께 undo :: activate 명령을 호출하십시오. undo :: deactivate, undo :: freeze 및 undo :: unfreeze를 사용하여 실행 취소 / 다시 실행 메커니즘의 상태를 제어하십시오.</target>
        </trans-unit>
        <trans-unit id="fd71ab2838c8371371ec0d2fdb4dcfcc6665885b" translate="yes" xml:space="preserve">
          <source>To add or update files in an existing SQLite Archive:</source>
          <target state="translated">기존 SQLite Archive에서 파일을 추가하거나 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="4ae1010309917f14b49ddef52acc40466e6c17b8" translate="yes" xml:space="preserve">
          <source>To add prefix indexes to an FTS5 table, the &quot;prefix&quot; option is set to either a single positive integer or a text value containing a white-space separated list of one or more positive integer values. A prefix index is created for each integer specified. If more than one &quot;prefix&quot; option is specified as part of a single CREATE VIRTUAL TABLE statement, all apply.</source>
          <target state="translated">FTS5 테이블에 접두사 인덱스를 추가하기 위해 &quot;접두사&quot;옵션은 단일 양의 정수 또는 공백으로 구분 된 하나 이상의 양의 정수 값 목록을 포함하는 텍스트 값으로 설정됩니다. 지정된 각 정수에 대해 접두어 색인이 작성됩니다. 단일 CREATE VIRTUAL TABLE 문의 일부로 둘 이상의 &quot;접 두부&quot;옵션이 지정된 경우 모두 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c191d56879fcb319acf75a9863fb0fa338e351b7" translate="yes" xml:space="preserve">
          <source>To append an element onto the end of an array, using json_insert() with an array index of &quot;#&quot;. Examples:</source>
          <target state="translated">배열의 끝에 요소를 추가하려면 배열 인덱스가 &quot;#&quot;인 json_insert ()를 사용합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="9404c6d887c060fefd19170a66f575055b2dffb6" translate="yes" xml:space="preserve">
          <source>To avoid a parsing ambiguity, the SELECT statement should always contain a WHERE clause, even if that clause is simply &quot;WHERE true&quot;, if the &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is present. Without the WHERE clause, the parser does not know if the token &quot;ON&quot; is part of a join constraint on the SELECT, or the beginning of the &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;.</source>
          <target state="translated">구문 분석 모호성을 피하기 위해, &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; 가 존재하는 경우 해당 절이 단순히 &quot;WHERE true&quot;인 경우에도 SELECT 문은 항상 WHERE 절을 포함해야합니다 . WHERE 절이 없으면 구문 분석기는 &quot;ON&quot;토큰이 SELECT에 대한 결합 제한 조건의 일부 &lt;a href=&quot;syntax/upsert-clause&quot;&gt;인지 upsert-clause&lt;/a&gt; 의 시작인지 알 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a1e573e48b1d1bbc7ead62db489ded9fccb8416c" translate="yes" xml:space="preserve">
          <source>To avoid a resource leak, every open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; should eventually be released by a call to &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;.</source>
          <target state="translated">리소스 누수를 피하려면 모든 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 은 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 호출로 해제되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d1fa3979b4e4aef1b6ce33c8f42fa7bd685b437c" translate="yes" xml:space="preserve">
          <source>To avoid a resource leak, every open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; should eventually be released by a call to &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;.</source>
          <target state="translated">리소스 누수를 피하려면 모든 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 은 &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 호출로 해제되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1ab3db1a50085aa74a015739222af42ac2d31de2" translate="yes" xml:space="preserve">
          <source>To avoid creating the temporary table, the query might be rewritten as follows:</source>
          <target state="translated">임시 테이블을 작성하지 않으려면 다음과 같이 쿼리를 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a939a1a7b1b6da9d7410b936fb953adb2a10ab14" translate="yes" xml:space="preserve">
          <source>To avoid deadlocks and other threading problems, the sqlite3_log() routine will not use dynamically allocated memory. The log message is stored in a fixed-length buffer on the stack. If the log message is longer than a few hundred characters, it will be truncated to the length of the buffer.</source>
          <target state="translated">교착 상태 및 기타 스레딩 문제를 피하기 위해 sqlite3_log () 루틴은 동적으로 할당 된 메모리를 사용하지 않습니다. 로그 메시지는 스택의 고정 길이 버퍼에 저장됩니다. 로그 메시지가 수백자를 초과하면 버퍼 길이에 맞게 잘립니다.</target>
        </trans-unit>
        <trans-unit id="4d1915ee0fe2780a5f846ddace0d96d4a65194c4" translate="yes" xml:space="preserve">
          <source>To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; to be invoked whenever an undefined collation sequence is required.</source>
          <target state="translated">데이터베이스를 사용하기 전에 모든 데이터 정렬 시퀀스를 등록 할 필요가 없도록 정의되지 않은 데이터 정렬 시퀀스가 ​​필요할 때마다 단일 콜백 함수가 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 등록되어 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2a04aec5cbeb09fcc4e41c36a55b1da3e1b43d6" translate="yes" xml:space="preserve">
          <source>To avoid having to register all collation sequences before a database can be used, a single callback function may be registered with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; to be invoked whenever an undefined collation sequence is required.</source>
          <target state="translated">데이터베이스를 사용하기 전에 모든 데이터 정렬 시퀀스를 등록 할 필요가 없도록 정의되지 않은 데이터 정렬 시퀀스가 ​​필요할 때마다 단일 콜백 함수가 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 등록되어 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e3ed74fe6098d68e31f0bee29e829f469078e4" translate="yes" xml:space="preserve">
          <source>To avoid name collisions, all external symbols in the SQLite library begin with the prefix &lt;b&gt;sqlite3&lt;/b&gt;. Those symbols that are intended for external use (in other words, those symbols which form the API for SQLite) add an underscore, and thus begin with &lt;b&gt;sqlite3_&lt;/b&gt;. Extension APIs sometimes add the extension name prior to the underscore; for example: &lt;b&gt;sqlite3rbu_&lt;/b&gt; or &lt;b&gt;sqlite3session_&lt;/b&gt;.</source>
          <target state="translated">이름 충돌을 피하기 위해 SQLite 라이브러리의 모든 외부 심볼은 &lt;b&gt;sqlite3&lt;/b&gt; 접두어로 시작합니다 . 외부 용으로 작성된 기호 (즉, API for SQLite를 형성하는 기호)는 밑줄을 추가하여 &lt;b&gt;sqlite3_로&lt;/b&gt; 시작합니다 . 확장 API는 때때로 밑줄 앞에 확장 이름을 추가합니다. 예를 들어 &lt;b&gt;sqlite3rbu_&lt;/b&gt; 또는 &lt;b&gt;sqlite3session_&lt;/b&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="51b8dbcd79c868e6c2b51fbc0d8f4e62d1ce3707" translate="yes" xml:space="preserve">
          <source>To avoid spiky INSERT performance, an application can run the &quot;merge=X,Y&quot; command periodically, possibly in an idle thread or idle process, to ensure that the FTS table never accumulates too many b-tree segments at the same level. INSERT performance spikes can generally be avoided, and performance of FTS3/4 can be maximized, by running &quot;merge=X,Y&quot; after every few thousand document inserts. Each &quot;merge=X,Y&quot; command will run in a separate transaction (unless they are grouped together using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, of course). The transactions can be kept small by choosing a value for X in the range of 100 to 300. The idle thread that is running the merge commands can know when it is done by checking the difference in &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; before and after each &quot;merge=X,Y&quot; command and stopping the loop when the difference drops below two.</source>
          <target state="translated">뾰족한 INSERT 성능을 피하기 위해 응용 프로그램은 유휴 스레드 또는 유휴 프로세스에서 &quot;merge = X, Y&quot;명령을 주기적으로 실행하여 FTS 테이블이 같은 수준에서 너무 많은 b- 트리 세그먼트를 누적하지 않도록 할 수 있습니다. INSERT 성능 스파이크는 일반적으로 피할 수 있으며 수천 번의 문서 삽입 후에 &quot;merge = X, Y&quot;를 실행하여 FTS3 / 4의 성능을 최대화 할 수 있습니다. 각 &quot;merge = X, Y&quot;명령은 별도의 트랜잭션에서 실행됩니다 ( 물론 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT를&lt;/a&gt; 사용하여 그룹화되지 않는 한 ). X의 값을 100-300 범위에서 선택하여 트랜잭션을 작게 유지할 수 있습니다. 병합 명령을 실행하는 유휴 스레드는 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 의 차이를 확인하여 언제 완료되는지 알 수 있습니다.각 &quot;merge = X, Y&quot;명령 전후에 차이가 2 미만으로 떨어지면 루프를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="bed15fd00e4480b7c81ecee249b2b398f62c1b86" translate="yes" xml:space="preserve">
          <source>To avoid this scenario, the sqlite3_unlock_notify() performs deadlock detection. If a given call to sqlite3_unlock_notify() would put the system in a deadlocked state, then SQLITE_LOCKED is returned and no unlock-notify callback is registered. The system is said to be in a deadlocked state if connection A has registered for an unlock-notify callback on the conclusion of connection B's transaction, and connection B has itself registered for an unlock-notify callback when connection A's transaction is concluded. Indirect deadlock is also detected, so the system is also considered to be deadlocked if connection B has registered for an unlock-notify callback on the conclusion of connection C's transaction, where connection C is waiting on connection A. Any number of levels of indirection are allowed.</source>
          <target state="translated">이 시나리오를 피하기 위해 sqlite3_unlock_notify ()는 교착 상태 감지를 수행합니다. sqlite3_unlock_notify ()에 대한 지정된 호출이 시스템을 교착 상태로 만들면 SQLITE_LOCKED가 리턴되고 unlock-notify 콜백이 등록되지 않습니다. 연결 B의 트랜잭션이 종료 될 때 연결 A가 잠금 해제 알림 콜백에 등록되고 연결 A의 트랜잭션이 완료되면 연결 B가 잠금 해제 알림 콜백에 등록 된 경우 시스템은 교착 상태에 있다고합니다. 간접 교착 상태도 감지되므로 연결 C가 연결 A의 연결을 기다리고있는 연결 C의 트랜잭션 종료시 연결 B가 잠금 해제 알림 콜백에 등록 된 경우 시스템도 교착 상태 인 것으로 간주됩니다. 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="3e35797a56e3488dd19632be8d37b7c920ead5fc" translate="yes" xml:space="preserve">
          <source>To be clear: &quot;</source>
          <target state="translated">확실하게: &quot;</target>
        </trans-unit>
        <trans-unit id="80e35d386745dd980983bb89049deefc03dfe51b" translate="yes" xml:space="preserve">
          <source>To build a DLL of SQLite for use in Windows, first acquire the appropriate amalgamated source code files, sqlite3.c and sqlite3.h. These can either be downloaded from the &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite website&lt;/a&gt; or custom generated from sources as shown above.</source>
          <target state="translated">Windows에서 사용할 SQLite DLL을 빌드하려면 먼저 적절한 통합 소스 코드 파일 인 sqlite3.c 및 sqlite3.h를 확보하십시오. 이것들은 &lt;a href=&quot;http://www.sqlite.org/download.html&quot;&gt;SQLite 웹 사이트&lt;/a&gt; 에서 다운로드 하거나 위와 같이 소스에서 사용자 정의하여 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8c2bc1841bf864b266faa9153cf419507175bd74" translate="yes" xml:space="preserve">
          <source>To build a copy of the dbhash utility program on unix, get a copy of the canonical SQLite source code and enter:</source>
          <target state="translated">유닉스에서 dbhash 유틸리티 프로그램의 사본을 빌드하려면 표준 SQLite 소스 코드의 사본을 확보하여 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8dbbee62ca23cc1e3fdd3d3f98bea994ab8a5656" translate="yes" xml:space="preserve">
          <source>To build a custom amalgamation, first download the original individual source files onto a unix or unix-like development platform. Be sure to get the original source files not the &quot;preprocessed source files&quot;. One can obtain the complete set of original source files either from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; or directly from the &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;configuration management system&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 통합을 구축하려면 먼저 원본 개별 소스 파일을 유닉스 또는 유닉스 계열 개발 플랫폼에 다운로드하십시오. &quot;전처리 된 소스 파일&quot;이 아닌 원본 소스 파일을 가져와야합니다. &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 또는 &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;구성 관리 시스템&lt;/a&gt; 에서 직접 원본 소스 파일의 전체 세트를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bbb58546549ded0701f18afdab64c04ca26ea6a1" translate="yes" xml:space="preserve">
          <source>To build the CLI, simply put these three files in the same directory and compile them together. Using MSVC:</source>
          <target state="translated">CLI를 빌드하려면이 세 파일을 동일한 디렉토리에 놓고 함께 컴파일하십시오. MSVC 사용 :</target>
        </trans-unit>
        <trans-unit id="5d2c0fe38d130be317edc2f5dfddee01ac43e855" translate="yes" xml:space="preserve">
          <source>To build the amalgamation (either the full amalgamation or the split amalgamation), first &lt;a href=&quot;getthecode&quot;&gt;get the canonical source code&lt;/a&gt; from one of the three servers. Then, on both unix-like systems and on Windows systems that have the free &lt;a href=&quot;http://mingw.org/wiki/msys&quot;&gt;MinGW&lt;/a&gt; development environment installed, the amalgamation can be built using the following commands:</source>
          <target state="translated">합병 (전체 합병 또는 분할 합병)을 구축하려면 먼저 세 서버 중 하나에서 &lt;a href=&quot;getthecode&quot;&gt;표준 소스 코드&lt;/a&gt; 를 가져 오십시오 . 그런 다음 유닉스 계열 시스템과 무료 &lt;a href=&quot;http://mingw.org/wiki/msys&quot;&gt;MinGW&lt;/a&gt; 개발 환경이 설치된 Windows 시스템 모두 에서 다음 명령을 사용하여 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="774e7f5cdd8b87b1abd96dec12eb0c1dad3d32d9" translate="yes" xml:space="preserve">
          <source>To build the checksum VFS module into a run-time loadable extension, use commands similar to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7b9af325052cb89e33dbc430967cc0b7deb7cf6" translate="yes" xml:space="preserve">
          <source>To build using Microsoft Visual C++, run this command:</source>
          <target state="translated">Microsoft Visual C ++를 사용하여 빌드하려면 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="39cded5adcef7aa92aca1ba527e5da5a120510e0" translate="yes" xml:space="preserve">
          <source>To cast a BLOB value to TEXT, the sequence of bytes that make up the BLOB is interpreted as text encoded using the database encoding.</source>
          <target state="translated">BLOB 값을 TEXT로 캐스트하기 위해 BLOB를 구성하는 바이트 시퀀스는 데이터베이스 인코딩을 사용하여 인코딩 된 텍스트로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="78f27fb02b3100de75bd999544415d6f6516d9a7" translate="yes" xml:space="preserve">
          <source>To cause SQLite to use a new memory allocator, the application simply calls:</source>
          <target state="translated">SQLite가 새로운 메모리 할당자를 사용하게하려면 응용 프로그램은 다음을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="06731044cb7999e326abfa5edb7ddc70e70000e7" translate="yes" xml:space="preserve">
          <source>To change your check-out to the private branch, type:</source>
          <target state="translated">체크 아웃을 개인 브랜치로 변경하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="1981f2b6db16ebcce7bb76f8ad9bf3a92a4b7325" translate="yes" xml:space="preserve">
          <source>To change your checkout to a different version of Fossil use the &quot;update&quot; command:</source>
          <target state="translated">결제를 다른 버전의 Fossil로 변경하려면 &quot;update&quot;명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e90e1970a4d12dd7ff50fb8afa438dceccf71dae" translate="yes" xml:space="preserve">
          <source>To circumvent this limitation, the amalgamation is also available in a split form, consisting of files &quot;sqlite3-1.c&quot;, &quot;sqlite3-2.c&quot;, and so forth, where each file is less than 32,768 lines in length and where the concatenation of the files contain all of the code for the complete amalgamation. Then there is a separate source file named &quot;sqlite3-all.c&quot; which basically consists of code like this:</source>
          <target state="translated">이 제한을 피하기 위해, 합병은 &quot;sqlite3-1.c&quot;, &quot;sqlite3-2.c&quot;등의 파일로 구성된 분할 형식으로도 제공됩니다. 여기서 각 파일의 길이는 32,768 행 미만입니다. 파일의 연결에는 완전한 통합을위한 모든 코드가 포함됩니다. 그런 다음 &quot;sqlite3-all.c&quot;라는 별도의 소스 파일이 있으며 기본적으로 다음과 같은 코드로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e894e5b94a3ef2bd6606b0bac122e783cd91aa9" translate="yes" xml:space="preserve">
          <source>To clarify, if this function is called and then a changeset constructed using &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, then after applying that changeset to database zFrom the contents of the two compatible tables would be identical.</source>
          <target state="translated">명확히하기 위해이 함수가 호출 된 다음 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()을&lt;/a&gt; 사용하여 변경 세트가 구성된 경우 해당 변경 세트를 데이터베이스 z에 적용 한 후 호환 가능한 두 테이블의 내용이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6d157b6ace52aa2f1341c1373e4a984c6c232891" translate="yes" xml:space="preserve">
          <source>To clarify, if this function is called and then a changeset constructed using &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, then after applying that changeset to database zFrom the contents of the two compatible tables would be identical.</source>
          <target state="translated">명확히하기 위해이 함수가 호출 된 다음 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()을&lt;/a&gt; 사용하여 변경 세트가 구성된 경우 해당 변경 세트를 데이터베이스 z에 적용 한 후 호환 가능한 두 테이블의 내용이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c1845a0b274cc5a67a90f51319c61b78f90f9584" translate="yes" xml:space="preserve">
          <source>To clarify: SQLite version 3.31.0 can read and write any database created by any prior version of SQLite going back to SQLite 3.0.0 (2004-06-18). And, earlier versions of SQLite, prior to 3.31.0, can read and write databases created by SQLite version 3.31.0 and later as long as the database schema does not contain features, such as generated columns, that are not understood by the earlier version. Problems only arise if you create a new database that contains generated columns, using SQLite version 3.31.0 or later, and then try to read or write that database file using an earlier version of SQLite that does not understand generated columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f3d190805c91114a85c4ded726387a4e9c9b6ef" translate="yes" xml:space="preserve">
          <source>To clarify: an extension for which the initialization function returns SQLITE_OK_LOAD_PERMANENTLY continues to exist in memory after the database connection closes. However, the extension is &lt;em&gt;not&lt;/em&gt; automatically registered with subsequent database connections. This makes it possible to load extensions that implement new &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;. To persistently load and register an extension that implements new SQL functions, collating sequences, and/or virtual tables, such that those added capabilities are available to all subsequent database connections, then the initialization routine should also invoke &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; on a subfunction that will register those services.</source>
          <target state="translated">명확히하기 위해 : 초기화 함수가 SQLITE_OK_LOAD_PERMANENTLY를 반환하는 확장은 데이터베이스 연결이 닫힌 후에도 메모리에 계속 존재합니다. 그러나 확장은 후속 데이터베이스 연결에 자동으로 등록 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이를 통해 새로운 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 구현하는 확장을로드 할 수 있습니다 . 새로운 SQL 함수, 데이터 정렬 시퀀스 및 / 또는 가상 테이블을 구현하는 확장을 지속적으로로드 및 등록하여 추가 된 기능을 모든 후속 데이터베이스 연결에 사용할 수있게하려면 초기화 루틴도 하위 함수에서 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 을 호출해야합니다. 해당 서비스를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="bccbaf3af7fd4e2f28bb629648fc3e526aaa7ab9" translate="yes" xml:space="preserve">
          <source>To clone the entire history of SQLite, first go to the &lt;a href=&quot;http://www.fossil-scm.org/download.html&quot;&gt;http://www.fossil-scm.org/download.html&lt;/a&gt; page and grab a precompiled binary for the Fossil version control program. Or get the source code on the same page and compile it yourself.</source>
          <target state="translated">SQLite의 전체 기록을 복제하려면 먼저 &lt;a href=&quot;http://www.fossil-scm.org/download.html&quot;&gt;http://www.fossil-scm.org/download.html&lt;/a&gt; 페이지 로 이동 하여 Fossil 버전 제어 프로그램을 위해 사전 컴파일 된 바이너리를 가져 오십시오. 또는 동일한 페이지에서 소스 코드를 가져 와서 직접 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="1a2fe4833a1026479d31af2dc4ee8fce8b3b5030" translate="yes" xml:space="preserve">
          <source>To close an SQLite database, call the &lt;b&gt;sqlite_close&lt;/b&gt; function passing it the sqlite structure pointer that was obtained from a prior call to &lt;b&gt;sqlite_open&lt;/b&gt;. If a transaction is active when the database is closed, the transaction is rolled back.</source>
          <target state="translated">SQLite 데이터베이스를 닫으려면 &lt;b&gt;sqlite_close&lt;/b&gt; 함수를 호출하여 &lt;b&gt;sqlite_open에&lt;/b&gt; 대한 이전 호출에서 얻은 sqlite 구조 포인터를 전달하십시오 . 데이터베이스가 닫힐 때 트랜잭션이 활성화되면 트랜잭션이 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="2864c3c7a649d4d26acb60269d4c618571d81546" translate="yes" xml:space="preserve">
          <source>To compile for Windows using MinGW, the command line is just like it is for unix except that the output file suffix is changed to &quot;.dll&quot; and the -fPIC argument is omitted:</source>
          <target state="translated">MinGW를 사용하여 Windows를 컴파일하려면 명령 행은 출력 파일 접미 부가 &quot;.dll&quot;로 변경되고 -fPIC 인수가 생략된다는 점을 제외하고는 UNIX와 같습니다.</target>
        </trans-unit>
        <trans-unit id="f73c38ca2dac9f31efaddc70782e387db0501bf7" translate="yes" xml:space="preserve">
          <source>To compile on Windows using MSVC, a command similar to the following will usually work:</source>
          <target state="translated">MSVC를 사용하여 Windows에서 컴파일하려면 일반적으로 다음과 유사한 명령이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5f996fbc61d75fe9538101264c9b8819e60f8184" translate="yes" xml:space="preserve">
          <source>To compile the command-line shell on unix systems and on Windows with MinGW, the usual configure-make command works:</source>
          <target state="translated">유닉스 시스템과 Windows에서 MinGW를 사용하여 명령 행 쉘을 컴파일하려면 일반적인 configure-make 명령이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="51cc1e77b8f71008cf9ef9201c87c8f93c492b49" translate="yes" xml:space="preserve">
          <source>To compute aggregate functions, the VDBE implements a special data structure and instructions for controlling that data structure. The data structure is an unordered set of buckets, where each bucket has a key and one or more memory locations. Within the query loop, the GROUP BY clause is used to construct a key and the bucket with that key is brought into focus. A new bucket is created with the key if one did not previously exist. Once the bucket is in focus, the memory locations of the bucket are used to accumulate the values of the various aggregate functions. After the query loop terminates, each bucket is visited once to generate a single row of the results.</source>
          <target state="translated">집계 함수를 계산하기 위해 VDBE는 특수한 데이터 구조와 해당 데이터 구조를 제어하기위한 명령어를 구현합니다. 데이터 구조는 정렬되지 않은 버킷 세트이며, 각 버킷에는 키와 하나 이상의 메모리 위치가 있습니다. 쿼리 루프 내에서 GROUP BY 절을 사용하여 키를 구성하고 해당 키가있는 버킷에 초점을 맞 춥니 다. 이전에 키가없는 경우 키를 사용하여 새 버킷이 생성됩니다. 버킷에 초점이 맞춰지면 버킷의 메모리 위치를 사용하여 다양한 집계 함수의 값을 누적합니다. 쿼리 루프가 종료 된 후 각 버킷을 한 번 방문하여 단일 행의 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="94ded02646e1eb96801f525361b3b596cadfec9e" translate="yes" xml:space="preserve">
          <source>To control memory usage in the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;, compile with &quot;&lt;a href=&quot;compile#printf_precision_limit&quot;&gt;-DSQLITE_PRINTF_PRECISION_LIMIT=1000&lt;/a&gt;&quot; or some similar small value. This #define limits the width and precision for %-substitutions in the printf() function, and thus prevents a hostile SQL statement from consuming large amounts of RAM via constructs such as &quot;&lt;code&gt;printf('%1000000000s','hi')&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf () SQL 함수&lt;/a&gt; 에서 메모리 사용량을 제어하려면 &quot; &lt;a href=&quot;compile#printf_precision_limit&quot;&gt;-DSQLITE_PRINTF_PRECISION_LIMIT = 1000&lt;/a&gt; &quot;또는 유사한 작은 값으로 컴파일하십시오 . 이 #define은 printf () 함수에서 %-대체에 대한 너비와 정밀도를 제한하므로 적대적인 SQL 문이 &quot; &lt;code&gt;printf('%1000000000s','hi')&lt;/code&gt; &quot; 와 같은 구문을 통해 많은 양의 RAM을 소비하는 것을 방지합니다 .</target>
        </trans-unit>
        <trans-unit id="de49f53ff4a4b3038be9f08fcf4db86631b03856" translate="yes" xml:space="preserve">
          <source>To convert an SQLite 2.8 database into an SQLite 3.0 database, have ready the command-line shells for both version 2.8 and 3.0. Then enter a command like the following:</source>
          <target state="translated">SQLite 2.8 데이터베이스를 SQLite 3.0 데이터베이스로 변환하려면 버전 2.8 및 3.0에 대한 명령 행 쉘을 준비하십시오. 그런 다음 다음과 같은 명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="d15f29e334ec535855fdc1d71f46105bc0e5b848" translate="yes" xml:space="preserve">
          <source>To convert the results of an SQL expression to a boolean value, SQLite first casts the result to a NUMERIC value in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt;. A numeric zero value (integer value 0 or real value 0.0) is considered to be false. A NULL value is still NULL. All other values are considered true.</source>
          <target state="translated">SQL 표현식의 결과를 부울 값으로 변환하기 위해 SQLite는 먼저 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식&lt;/a&gt; 과 동일한 방식으로 결과를 NUMERIC 값으로 캐스트합니다 . 숫자 0 값 (정수 값 0 또는 실수 0.0)은 false로 간주됩니다. NULL 값은 여전히 ​​NULL입니다. 다른 모든 값은 참으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="86fc6f32b0c0d0aa47c4d6f69f34d90eb1dafec6" translate="yes" xml:space="preserve">
          <source>To create a WITHOUT ROWID table, simply add the keywords &quot;WITHOUT ROWID&quot; to the end of the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. For example:</source>
          <target state="translated">WITHOUT ROWID 테이블을 작성하려면 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 끝에 키워드 &quot;WITHOUT ROWID&quot;를 추가하십시오 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="44c6e38819829481385517b096a1954e645cc686" translate="yes" xml:space="preserve">
          <source>To create a custom tokenizer, an application must implement three functions: a tokenizer constructor (xCreate), a destructor (xDelete) and a function to do the actual tokenization (xTokenize). The type of each function is as for the member variables of the fts5_tokenizer struct:</source>
          <target state="translated">사용자 정의 토크 나이저를 만들려면 응용 프로그램에서 토크 나이저 생성자 (xCreate), 소멸자 (xDelete) 및 실제 토큰 화 (xTokenize)를 수행하는 함수의 세 가지 기능을 구현해야합니다. 각 함수의 유형은 fts5_tokenizer 구조체의 멤버 변수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="e13c6f787f4a4c87c62a52e8c2eaf1189f9ab3f7" translate="yes" xml:space="preserve">
          <source>To create a new SQLite Archive named &quot;alltxt.sqlar&quot; containing all *.txt files in the current directory:</source>
          <target state="translated">현재 디렉토리의 모든 * .txt 파일을 포함하는 &quot;alltxt.sqlar&quot;라는 새 SQLite 아카이브를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="66b80310b3a0d85a550dc7fa520d19dce45cca28" translate="yes" xml:space="preserve">
          <source>To create a new VFS, an application fills in an instance of this structure with appropriate values and then calls &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="translated">새 VFS를 작성하기 위해 애플리케이션은이 구조의 인스턴스를 적절한 값으로 채우고 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b68e0297b120fdc8700b37a16e22b1bcac7b7255" translate="yes" xml:space="preserve">
          <source>To create a permanent imposter table &quot;t2&quot; against index &quot;t1bc&quot; one should first enable editing of the sqlite_master table by running &quot;&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;&quot;. (Be careful to observe the warnings that accompany this PRAGMA. A mistake can cause severe database corruption.) Then insert a new entry into the sqlite_master table like this:</source>
          <target state="translated">인덱스 &quot;t1bc&quot;에 대해 영구 임 포스터 테이블 &quot;t2&quot;를 만들려면 먼저 &quot; &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt; &quot; 을 실행하여 sqlite_master 테이블을 편집 할 수 있어야합니다 . (이 PRAGMA와 함께 제공되는 경고를주의하십시오. 실수로 심각한 데이터베이스 손상이 발생할 수 있습니다.) 그런 다음 다음과 같이 sqlite_master 테이블에 새 항목을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="36c615429908288394555c6e0565e1074cd2dbb0" translate="yes" xml:space="preserve">
          <source>To create a permanent imposter table &quot;t2&quot; against index &quot;t1bc&quot; one should first enable editing of the sqlite_schema table by running &quot;&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt;&quot;. (Be careful to observe the warnings that accompany this PRAGMA. A mistake can cause severe database corruption.) Then insert a new entry into the sqlite_schema table like this:</source>
          <target state="translated">인덱스 &quot;t1bc&quot;에 대해 영구 가짜 테이블 &quot;t2&quot;를 생성하려면 먼저 &quot; &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON&lt;/a&gt; &quot; 을 실행하여 sqlite_schema 테이블의 편집을 활성화해야합니다 . (이 PRAGMA에 수반되는 경고를주의 깊게 관찰하십시오. 실수로 인해 심각한 데이터베이스 손상이 발생할 수 있습니다.) 그런 다음 다음과 같이 sqlite_schema 테이블에 새 항목을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="75af239d46a1ccaf4ed3b8c83752a1c8cd61ef3d" translate="yes" xml:space="preserve">
          <source>To create a transient imposter table, first call sqlite3_test_control() as follows:</source>
          <target state="translated">임시 임 포스터 테이블을 작성하려면 먼저 다음과 같이 sqlite3_test_control ()을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="840cded7bd85361bb0373236ba14ab05cb33ba76" translate="yes" xml:space="preserve">
          <source>To disable memory-mapped I/O, simply set the mmap_size to zero:</source>
          <target state="translated">메모리 매핑 된 I / O를 비활성화하려면 mmap_size를 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4162611fd5eb01354b37fefdcc47165c36368726" translate="yes" xml:space="preserve">
          <source>To download a specific historical version, first locate the specific version desired by visiting the timeline page on one of these servers (for example: &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline&quot;&gt;http://www.sqlite.org/cgi/src/timeline&lt;/a&gt;). If you know the approximate date of the version you want to download, you can add a query parameter like &quot;c=YYYY-MM-DD&quot; to the &quot;timeline&quot; URL to see a timeline centered on that date. For example, to see all the check-ins that occurred around August 26, 2013, visit &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&quot;&gt;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&lt;/a&gt;. If you are looking for an official release, visit the &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;chronology&lt;/a&gt; page, click on the date to the left of the release you are looking for, and that will take you immediately to the check-in corresponding to the release.</source>
          <target state="translated">특정 히스토리 버전을 다운로드하려면 먼저 다음 서버 중 하나에서 타임 라인 페이지를 방문하여 원하는 특정 버전을 찾으십시오 (예 : &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline&quot;&gt;http://www.sqlite.org/cgi/src/timeline&lt;/a&gt; ). 다운로드하려는 버전의 대략적인 날짜를 알고있는 경우 &quot;c = YYYY-MM-DD&quot;와 같은 쿼리 매개 변수를 &quot;타임 라인&quot;URL에 추가하여 해당 날짜를 중심으로 타임 라인을 볼 수 있습니다. 예를 들어 2013 년 8 월 26 일 경에 발생한 모든 체크인을 보려면 &lt;a href=&quot;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26&quot;&gt;http://www.sqlite.org/cgi/src/timeline?c=2013-08-26을&lt;/a&gt; 방문 하십시오 . 공식 릴리스를 찾으려면 &lt;a href=&quot;https://sqlite.org/chronology.html&quot;&gt;연대기&lt;/a&gt; 페이지를 방문하여 찾고있는 릴리스 왼쪽의 날짜를 클릭하면 해당 릴리스에 해당하는 체크인으로 즉시 이동합니다.</target>
        </trans-unit>
        <trans-unit id="26b6f299c4f6dbffd907751cbcf7de075d977917" translate="yes" xml:space="preserve">
          <source>To end a</source>
          <target state="translated">종료하려면</target>
        </trans-unit>
        <trans-unit id="b5999f6915f561051a988538e0bd45a5b252eaed" translate="yes" xml:space="preserve">
          <source>To enhance the ability to correct the spelling of &quot;salm&quot; into &quot;psalm&quot;, make an addition entry like this:</source>
          <target state="translated">&quot;salm&quot;의 철자를 &quot;psalm&quot;으로 정정하는 기능을 향상 시키려면 다음과 같이 추가 항목을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="cad4b923bd651194c8769c3ac961aaea0541a296" translate="yes" xml:space="preserve">
          <source>To ensure that</source>
          <target state="translated">그것을 보장하기 위해</target>
        </trans-unit>
        <trans-unit id="1e6f0b75d33070e67761c1e9b6a6ed87d2ff380d" translate="yes" xml:space="preserve">
          <source>To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines. Or, in other words, these routines are constructors for the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object.</source>
          <target state="translated">SQL 문을 실행하려면 먼저이 루틴 중 하나를 사용하여 바이트 코드 프로그램으로 컴파일해야합니다. 즉,이 루틴은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트의 생성자입니다 .</target>
        </trans-unit>
        <trans-unit id="ec8443402dd2eb014887f71b7af85c4019b4e801" translate="yes" xml:space="preserve">
          <source>To execute an SQL statement, it must first be compiled into a byte-code program using one of these routines. Or, in other words, these routines are constructors for the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object.</source>
          <target state="translated">SQL 문을 실행하려면 먼저이 루틴 중 하나를 사용하여 바이트 코드 프로그램으로 컴파일해야합니다. 즉,이 루틴은 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트의 생성자입니다 .</target>
        </trans-unit>
        <trans-unit id="58b794006b35834c11476296b13d055bca3cb6ad" translate="yes" xml:space="preserve">
          <source>To export an SQLite table (or part of a table) as CSV, simply set the &quot;mode&quot; to &quot;csv&quot; and then run a query to extract the desired rows of the table.</source>
          <target state="translated">SQLite 테이블 (또는 테이블의 일부)을 CSV로 내보내려면 &quot;mode&quot;를 &quot;csv&quot;로 설정 한 다음 쿼리를 실행하여 원하는 테이블 행을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="34bdecaf4db0d4f0bc535a4d51fd07e2c07ade79" translate="yes" xml:space="preserve">
          <source>To extract all files from an SQLite Archive named &quot;example.sqlar&quot;:</source>
          <target state="translated">&quot;example.sqlar&quot;라는 SQLite Archive에서 모든 파일을 추출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="378da684f0e8132365653868ae764440748a4226" translate="yes" xml:space="preserve">
          <source>To find the average fan-out for a table, run:</source>
          <target state="translated">테이블의 평균 팬 아웃을 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="ee153014b1f6b01134aa6e70c369b696d194ac09" translate="yes" xml:space="preserve">
          <source>To find the total number of pages used to store table &quot;xyz&quot; in schema &quot;aux1&quot;, use either of the following two queries (the first is the traditional way, and the second shows the use of the aggregated feature):</source>
          <target state="translated">스키마 &quot;aux1&quot;에 테이블 &quot;xyz&quot;를 저장하는 데 사용 된 총 페이지 수를 찾으려면 다음 두 쿼리 중 하나를 사용하십시오 (첫 번째는 일반적인 방법이고 두 번째는 집계 된 기능의 사용을 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="77ab957506d48f71aa3fc70f6eedd2aaaf50bd48" translate="yes" xml:space="preserve">
          <source>To find the total number of pages used to store table &quot;xyz&quot; in schema &quot;aux1&quot;, use:</source>
          <target state="translated">&quot;aux1&quot;스키마에서 &quot;xyz&quot;테이블을 저장하는 데 사용 된 총 페이지 수를 찾으려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0a11c9e40b95aaa85081ba6c0555c462813b8b92" translate="yes" xml:space="preserve">
          <source>To force any register to be an integer, just add 0.</source>
          <target state="translated">레지스터를 강제로 정수로 만들려면 0을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7bb085f6483822eb83ea0075d305dc39115c6ffe" translate="yes" xml:space="preserve">
          <source>To generate a TCL-loadable library for SQLite on Linux, the following command will suffice:</source>
          <target state="translated">Linux에서 SQLite 용 TCL로드 가능 라이브러리를 생성하려면 다음 명령으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="dc0ee9d48bb10de38aec057fb2ba37285a13b707" translate="yes" xml:space="preserve">
          <source>To generate a standalone tclsh that is statically linked with SQLite, use this compiler invocation:</source>
          <target state="translated">SQLite와 정적으로 링크 된 독립형 tclsh를 생성하려면 다음 컴파일러 호출을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8ffcbf0f0118885934819d8152d29f23d6bdeaf0" translate="yes" xml:space="preserve">
          <source>To get the latest release, use &quot;release&quot; for</source>
          <target state="translated">최신 릴리스를 얻으려면 &quot;release&quot;를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="865105a4d24714f5572a2af260a890cf20c3e9e8" translate="yes" xml:space="preserve">
          <source>To get the latest trunk check-in, us &quot;trunk&quot; for</source>
          <target state="translated">최신 트렁크 체크인을 받으려면 &quot;트렁크&quot;를</target>
        </trans-unit>
        <trans-unit id="baaadfb75f7d2bdda9240215ff1dc1b92db5726d" translate="yes" xml:space="preserve">
          <source>To get the maximum performance out of a query with multiple AND-connected terms in the WHERE clause, you really want a multi-column index with columns for each of the AND terms. In this case we create a new index on the &quot;fruit&quot; and &quot;state&quot; columns of FruitsForSale:</source>
          <target state="translated">WHERE 절에 여러 개의 AND 연결 용어가있는 쿼리에서 최대 성능을 얻으려면 각 AND 용어에 대한 열이있는 다중 열 인덱스가 필요합니다. 이 경우 FruitsForSale의 &quot;fruit&quot;및 &quot;state&quot;열에 새 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6c98051e0b4ba35892475ed9f9c40c06634ca73f" translate="yes" xml:space="preserve">
          <source>To help ensure that SQLite does not make use of undefined or implementation defined behavior, the test suites are rerun using instrumented builds that try to detect undefined behavior. For example, test suites are run using the &quot;-ftrapv&quot; option of GCC. And they are run again using the &quot;-fsanitize=undefined&quot; option on Clang. And again using the &quot;/RTC1&quot; option in MSVC. Then the test suites are rerun using options like &quot;-funsigned-char&quot; and &quot;-fsigned-char&quot; to make sure that implementation differences do not matter either. Tests are then repeated on 32-bit and 64-bit systems and on big-endian and little-endian systems, using a variety of CPU architectures. Furthermore, the test suites are augmented with many test cases that are deliberately designed to provoke undefined behavior. For example: &quot;&lt;b&gt;SELECT -1*(-9223372036854775808);&lt;/b&gt;&quot;.</source>
          <target state="translated">SQLite가 정의되지 않은 또는 구현 정의 된 동작을 사용하지 않도록하기 위해 테스트 스위트는 정의되지 않은 동작을 감지하는 인스트루먼트 된 빌드를 사용하여 다시 실행됩니다. 예를 들어 테스트 스위트는 GCC의 &quot;-ftrapv&quot;옵션을 사용하여 실행됩니다. 그리고 Clang에서 &quot;-fsanitize = undefined&quot;옵션을 사용하여 다시 실행됩니다. 그리고 MSVC에서 &quot;/ RTC1&quot;옵션을 다시 사용하십시오. 그런 다음 &quot;-funsigned-char&quot;및 &quot;-fsigned-char&quot;와 같은 옵션을 사용하여 테스트 스위트를 다시 실행하여 구현 차이가 중요하지 않은지 확인하십시오. 그런 다음 다양한 CPU 아키텍처를 사용하여 32 비트 및 64 비트 시스템과 빅 엔디안 및 리틀 엔디안 시스템에서 테스트를 반복합니다. 또한 테스트 스위트에는 정의되지 않은 동작을 유발하도록 의도적으로 설계된 많은 테스트 사례가 추가되었습니다. 예를 들면 다음과 같습니다.&quot; &lt;b&gt;SELECT -1 * (-9223372036854775808);&lt;/b&gt;&quot;.</target>
        </trans-unit>
        <trans-unit id="a47c1a7cf7a764ae8418d262a8cbe0034fa682ba" translate="yes" xml:space="preserve">
          <source>To help the optimizer get a more accurate estimate of the work involved in using various indices, the user may optionally run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command scans all indices of database where there might be a choice between two or more indices and gathers statistics on the selectiveness of those indices. The statistics gathered by this scan are stored in special database tables names shows names all begin with &quot;&lt;b&gt;sqlite_stat&lt;/b&gt;&quot;. The content of these tables is not updated as the database changes so after making significant changes it might be prudent to rerun &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The results of an ANALYZE command are only available to database connections that are opened after the ANALYZE command completes.</source>
          <target state="translated">옵티마이 저가 다양한 인덱스 사용과 관련된 작업을보다 정확하게 추정 할 수 있도록 사용자는 선택적으로 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행할 수 있습니다 . 는 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령 검사에게 그 인덱스의위한 선택에 두 개 이상의 인덱스 및 집결 통계 사이에 선택의 여지가있을 수 있습니다 데이터베이스의 모든 인덱스를. 이 스캔에 의해 수집 된 통계는 특수 데이터베이스 테이블에 저장됩니다. 이름은 이름이 모두 &quot; &lt;b&gt;sqlite_stat&lt;/b&gt; &quot;로 시작하는 이름을 보여줍니다 . 이러한 테이블의 내용은 데이터베이스가 변경 될 때 업데이트되지 않으므로 크게 변경 한 후에는 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 다시 실행해야 합니다. ANALYZE 명령의 결과는 ANALYZE 명령이 완료된 후 열린 데이터베이스 연결에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13cfb0765d8bed99c080b9b691906f95cc028d17" translate="yes" xml:space="preserve">
          <source>To illustrate the difference between statement coverage and branch coverage, consider the following hypothetical line of C code:</source>
          <target state="translated">명령문 적용 범위와 브랜치 적용 범위의 차이점을 설명하려면 다음과 같은 가상 C 코드 행을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ae50591a7fcbd23ea798d861abeb0270f701ae3a" translate="yes" xml:space="preserve">
          <source>To implement atomic transactions in the face of potential application, operating system or power failures, database writers write a copy of those portions of the database file that they are going to modify into a second file, the</source>
          <target state="translated">잠재적 인 응용 프로그램, 운영 체제 또는 정전에 직면하여 원자 트랜잭션을 구현하기 위해 데이터베이스 작성자는 데이터베이스 파일의 일부를 두 번째 파일로 수정할 사본을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="b22523df059612f91ea53aafd162b4bd5ed35d56" translate="yes" xml:space="preserve">
          <source>To include a single &quot;%&quot; character in the output, put two consecutive &quot;%&quot; characters in the template.</source>
          <target state="translated">출력에 단일 &quot;%&quot;문자를 포함 시키려면 템플릿에 두 개의 연속 &quot;%&quot;문자를 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="04f1ff1539e760f03360e336c883d5d39fb452d1" translate="yes" xml:space="preserve">
          <source>To insert a directory into the archive, this field must be set to NULL. In this case if a value was explicitly specified for the &quot;mode&quot; column, then it must be consistent with a directory (i.e. it must be true that (mode &amp;amp; 0040000)=0040000).</source>
          <target state="translated">아카이브에 디렉토리를 삽입하려면이 필드를 NULL로 설정해야합니다. 이 경우 &quot;mode&quot;열에 값이 명시 적으로 지정된 경우 디렉토리와 일치해야합니다 (즉, (mode &amp;amp; 0040000) = 0040000).</target>
        </trans-unit>
        <trans-unit id="f39783c1ee7868744c61463c5d909272c5cc8fe4" translate="yes" xml:space="preserve">
          <source>To insert a symbolic link, the user must also supply a &quot;mode&quot; value. For example, to add a symbolic link from &quot;link.txt&quot; to &quot;m.txt&quot;:</source>
          <target state="translated">기호 링크를 삽입하려면 사용자는 &quot;모드&quot;값도 제공해야합니다. 예를 들어 &quot;link.txt&quot;에서 &quot;m.txt&quot;로 심볼릭 링크를 추가하려면</target>
        </trans-unit>
        <trans-unit id="95775537d7e96d79f73ff5683b7a0f5a80a5ce74" translate="yes" xml:space="preserve">
          <source>To invoke a method of the fts5_api object, the fts5_api pointer itself should be passed as the methods first argument followed by the other, method specific, arguments. For example:</source>
          <target state="translated">fts5_api 객체의 메서드를 호출하려면 fts5_api 포인터 자체가 메서드의 첫 번째 인수로 전달되고 그 뒤에 다른 메서드 별 인수가 전달되어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e6a0331292326c4328c6ad0538b3a057984238d" translate="yes" xml:space="preserve">
          <source>To invoke an auxiliary function, the name of the FTS5 table should be specified as the first argument. Other arguments may follow the first, depending on the specific auxiliary function being invoked. For example, to invoke the &quot;highlight&quot; function:</source>
          <target state="translated">보조 기능을 호출하려면 FTS5 테이블의 이름을 첫 번째 인수로 지정해야합니다. 호출되는 특정 보조 기능에 따라 다른 인수가 첫 번째 인수 뒤에 올 수 있습니다. 예를 들어 &quot;highlight&quot;기능을 호출하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="87798f32eb98a197933acbeaa659a6391e6e206b" translate="yes" xml:space="preserve">
          <source>To list all of the files in an SQLite Archive named &quot;example.sqlar&quot; using one of these commands:</source>
          <target state="translated">다음 명령 중 하나를 사용하여 &quot;example.sqlar&quot;라는 SQLite Archive의 모든 파일을 나열하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a8e56bf2f9a0444cb5685f8d4658bfe54c212bc2" translate="yes" xml:space="preserve">
          <source>To load this extension as a shared library, you first have to bring up a dummy SQLite database connection to use as the argument to the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API call. Then you invoke the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API and shutdown the dummy database connection. All subsequent database connections that are opened will include this extension. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a407629fac05e188e2276249cb3e6705d8eabc" translate="yes" xml:space="preserve">
          <source>To make the original query more efficient, we can add an index on the &quot;fruit&quot; column of the &quot;fruitsforsale&quot; table like this:</source>
          <target state="translated">원래 쿼리를보다 효율적으로 만들기 위해 다음과 같이 &quot;fruitsforsale&quot;테이블의 &quot;fruit&quot;열에 인덱스를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="477566566ad78ed80a1c50e083a36f65bd003836" translate="yes" xml:space="preserve">
          <source>To mark a foreign key constraint as deferred, its declaration must include the following clause:</source>
          <target state="translated">외래 키 제약 조건을 지연된 것으로 표시하려면 선언에 다음 절이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ffa62717516e178da2c90e6012b64fda52ee2d3e" translate="yes" xml:space="preserve">
          <source>To minimize storage space, the 64-bit rowid is stored as a variable length integer. Rowids between 0 and 127 use only a single byte. Rowids between 0 and 16383 use just 2 bytes. Up to 2097152 uses three bytes. And so forth. Negative rowids are allowed but they always use nine bytes of storage and so their use is discouraged. When rowids are generated automatically by SQLite, they will always be non-negative.</source>
          <target state="translated">저장 공간을 최소화하기 위해 64 비트 rowid는 가변 길이 정수로 저장됩니다. 0에서 127 사이의 Rowid는 단일 바이트 만 사용합니다. 0에서 16383 사이의 Rowid는 2 바이트 만 사용합니다. 최대 2097152는 3 바이트를 사용합니다. 기타 등등. 음의 rowid는 허용되지만 항상 9 바이트의 스토리지를 사용하므로 사용을 권장하지 않습니다. 행 ID가 SQLite에 의해 자동으로 생성되면 항상 음이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d120ff6bfe9d147f02eaa10dff44acc87f07df1f" translate="yes" xml:space="preserve">
          <source>To overcome this problem, SQLite attempts to flatten subqueries in the FROM clause of a SELECT. This involves inserting the FROM clause of the subquery into the FROM clause of the outer query and rewriting expressions in the outer query that refer to the result set of the subquery. For example:</source>
          <target state="translated">이 문제를 극복하기 위해 SQLite는 SELECT의 FROM 절에서 하위 쿼리를 병합하려고 시도합니다. 여기에는 하위 쿼리의 FROM 절을 외부 쿼리의 FROM 절에 삽입하고 하위 쿼리의 결과 집합을 참조하는 외부 쿼리의 식을 다시 작성하는 작업이 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="294f2168272133a9c981fc5402e94f65b32feecd" translate="yes" xml:space="preserve">
          <source>To perform a backup operation:</source>
          <target state="translated">백업 작업을 수행하려면</target>
        </trans-unit>
        <trans-unit id="9189855e1dd7fa25c3ea4d362ef1bbf56fd3d46b" translate="yes" xml:space="preserve">
          <source>To port the asynchronous IO extension to another platform, the user must implement mutex and condition variable primitives for the new platform. Currently there is no externally available interface to allow this, but modifying the code within sqlite3async.c to include the new platforms concurrency primitives is relatively easy. Search within sqlite3async.c for the comment string &quot;PORTING FUNCTIONS&quot; for details. Then implement new versions of each of the following:</source>
          <target state="translated">비동기 IO 확장을 다른 플랫폼으로 이식하려면 사용자가 새 플랫폼에 대한 뮤텍스 및 조건 변수 프리미티브를 구현해야합니다. 현재이를 위해 외부 적으로 사용 가능한 인터페이스가 없지만 sqlite3async.c 내에서 코드를 수정하여 새로운 플랫폼 동시성 프리미티브를 포함하는 것은 비교적 쉽습니다. 자세한 내용은 sqlite3async.c에서 주석 문자열 &quot;PORTING FUNCTIONS&quot;를 검색하십시오. 그런 다음 다음 각 버전의 새 버전을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="b29c4e979c790f9733cc9cd0e4cadf4faa4804b3" translate="yes" xml:space="preserve">
          <source>To prevent this kind of mischief, applications that create their own custom SQL functions should take one or more of the following safety precautions. The more precautions taken the better:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abe3a1c0f986e7dff3c66e10e0bc8613ec8a4a29" translate="yes" xml:space="preserve">
          <source>To program the costs of editdist3, create a table such as the following:</source>
          <target state="translated">editdist3의 비용을 프로그래밍하려면 다음과 같은 테이블을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="dd961efb741387ced404586d2d77531be32d0018" translate="yes" xml:space="preserve">
          <source>To put it another way, SQLITE_THREADSAFE=1 sets the default &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. SQLITE_THREADSAFE=2 sets the default &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-threaded. And SQLITE_THREADSAFE=0 sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-threaded.</source>
          <target state="translated">달리 말하면 SQLITE_THREADSAFE = 1은 기본 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 Serialized로 설정합니다 . SQLITE_THREADSAFE = 2는 기본 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 다중 스레드로 설정합니다. 그리고 SQLITE_THREADSAFE = 0은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 단일 스레드로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8bbf633fa4610c96c0c7ffee341d20c19f6a10c0" translate="yes" xml:space="preserve">
          <source>To put it another way, a recursive common table expression must look like the following:</source>
          <target state="translated">다시 말하면 재귀 공통 테이블 표현식은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="d0db6354379e9349b630c5c37e78992d9de59b0b" translate="yes" xml:space="preserve">
          <source>To put it another way, this setting requires that application-defined functions only be run directly by top-level SQL invoked from the application itself, not as a consequence of doing some other innocent-looking query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ef640929ff79fff30565de2cdb61e3e8331dcd" translate="yes" xml:space="preserve">
          <source>To query the geopoly table using an indexed geospatial search, use one of the functions geopoly_overlap() or geopoly_within() as a boolean function in the WHERE clause, with the &quot;_shape&quot; column as the first argument to the function. For example:</source>
          <target state="translated">인덱싱 된 지리 공간 검색을 사용하여 지오 폴리 테이블을 쿼리하려면 geopoly_overlap () 또는 geopoly_within () 함수 중 하나를 WHERE 절에서 부울 함수로 사용하고 &quot;_shape&quot;열을 함수의 첫 번째 인수로 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c7559a504a1b848e2c2a1bb94bcc0d6574af605" translate="yes" xml:space="preserve">
          <source>To query the virtual table, include a MATCH operator in the WHERE clause. For example:</source>
          <target state="translated">가상 테이블을 조회하려면 WHERE 절에 MATCH 연산자를 포함 시키십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="956aac33f5ccab9c31f6bd406dfe90336575d36e" translate="yes" xml:space="preserve">
          <source>To raise an error, the xColumn method should use one of the result_text() methods to set the error message text, then return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. The xColumn method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success.</source>
          <target state="translated">오류를 발생 시키려면 xColumn 메소드는 result_text () 메소드 중 하나를 사용하여 오류 메시지 텍스트를 설정 한 후 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴해야 합니다 . xColumn 메소드는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a347542d414080ba36506855372190f72248d59a" translate="yes" xml:space="preserve">
          <source>To read a page from the database (call it page number P), a reader first checks the WAL to see if it contains page P. If so, then the last valid instance of page P that is followed by a commit frame or is a commit frame itself becomes the value read. If the WAL contains no copies of page P that are valid and which are a commit frame or are followed by a commit frame, then page P is read from the database file.</source>
          <target state="translated">데이터베이스에서 페이지를 읽으려면 (페이지 번호 P라고 함) 독자는 먼저 WAL에서 페이지 P가 포함되어 있는지 확인합니다. 그렇다면 페이지 P의 마지막 유효한 인스턴스는 커밋 프레임 다음에 오거나 커밋 프레임 자체가 읽은 값이됩니다. WAL에 유효하고 커밋 프레임이거나 다음에 커밋 프레임이있는 페이지 P의 사본이없는 경우 데이터베이스 파일에서 페이지 P를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="76f16284fd2bce9d8388d5ab5df8c7614583bafc" translate="yes" xml:space="preserve">
          <source>To read a page of database content using the legacy xRead() method, SQLite first allocates a page-size chunk of heap memory then invokes the xRead() method which causes the database page content to be copied into the newly allocated heap memory. This involves (at a minimum) a copy of the entire page.</source>
          <target state="translated">레거시 xRead () 메소드를 사용하여 데이터베이스 컨텐츠 페이지를 읽으려면 SQLite는 먼저 페이지 크기의 힙 메모리 청크를 할당 한 다음 xRead () 메소드를 호출하여 데이터베이스 페이지 컨텐츠가 새로 할당 된 힙 메모리에 복사되도록합니다. 여기에는 (최소한) 전체 페이지의 사본이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0d23c4dcc478663c58481efcab9ef78dfade7580" translate="yes" xml:space="preserve">
          <source>To reiterate, the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; only influence the temporary files other than the rollback journal and the master journal. The rollback journal and the master journal are always written to disk regardless of the settings of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">다시 &lt;a href=&quot;compile#temp_store&quot;&gt;말하면 SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수 및 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 는 롤백 저널 및 마스터 저널 이외의 임시 파일에만 영향을줍니다. 롤백 저널 및 마스터 저널은 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수 및 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 의 설정에 관계없이 항상 디스크에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="2e5b2bd7c52b7e4f110f0ff73389c5c950328a31" translate="yes" xml:space="preserve">
          <source>To reiterate, the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; only influence the temporary files other than the rollback journal and the super-journal. The rollback journal and the super-journal are always written to disk regardless of the settings of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">다시 &lt;a href=&quot;compile#temp_store&quot;&gt;말하면 SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수와 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 는 롤백 저널 및 수퍼 저널을 제외한 임시 파일에만 영향을줍니다. 롤백 저널 및 수퍼 저널은 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수 및 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 의 설정에 관계없이 항상 디스크에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="c25cb966293d60ae97a959ff16018be4ed0f257f" translate="yes" xml:space="preserve">
          <source>To rotate a polygon by R radians around the point 0, 0:</source>
          <target state="translated">점 0, 0 주위에서 R 라디안으로 다각형을 회전하려면 :</target>
        </trans-unit>
        <trans-unit id="b22af78238ac154cfedfa8fdf1735dd0e28767bd" translate="yes" xml:space="preserve">
          <source>To run an SQL statement, the application follows these steps:</source>
          <target state="translated">SQL 문을 실행하기 위해 애플리케이션은 다음 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2ac3ac4ee6565dd2ccf0aa06e215ad75c047aa3c" translate="yes" xml:space="preserve">
          <source>To satisfy this query, SQLite reads every row out of the table, checks to see if the &quot;fruit&quot; column has the value of &quot;Peach&quot; and if so, outputs the &quot;price&quot; column from that row. The process is illustrated by &lt;a href=&quot;#fig2&quot;&gt;figure 2&lt;/a&gt; below. This is algorithm is called a</source>
          <target state="translated">이 쿼리를 만족시키기 위해 SQLite는 테이블에서 모든 행을 읽고 &quot;fruit&quot;열의 값이 &quot;Peach&quot;인지 확인한 다음 해당 행에서 &quot;price&quot;열을 출력합니다. 프로세스는 아래 &lt;a href=&quot;#fig2&quot;&gt;그림 2에&lt;/a&gt; 설명되어 있습니다. 이 알고리즘은</target>
        </trans-unit>
        <trans-unit id="15441596cf9057824d089a51008503a5c1e85b73" translate="yes" xml:space="preserve">
          <source>To see all optimizations that would have been done without actually doing them, run &quot;PRAGMA optimize(-1)&quot;. To use only the ANALYZE optimization, run &quot;PRAGMA optimize(0x02)&quot;.</source>
          <target state="translated">실제로 수행하지 않고 수행 된 모든 최적화를 보려면 &quot;PRAGMA optimize (-1)&quot;를 실행하십시오. ANALYZE 최적화 만 사용하려면 &quot;PRAGMA optimize (0x02)&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="eba318aa21bd2422c25fe6b43564edd2f371cc6a" translate="yes" xml:space="preserve">
          <source>To see how efficiently the content of a table is stored on disk, compute the amount of space used to hold actual content divided by the total amount of disk space used. The closer this number is to 100%, the more efficient the packing. (In this example, the 'xyz' table is assumed to be in the 'main' schema. Again, there are two different versions that show the use of DBSTAT both without and with the new aggregated feature, respectively.)</source>
          <target state="translated">테이블의 콘텐츠가 디스크에 얼마나 효율적으로 저장되는지 확인하려면 실제 콘텐츠를 보관하는 데 사용되는 공간을 사용 된 총 디스크 공간으로 나눈 값을 계산하십시오. 이 수치가 100 %에 가까울수록 패킹이 더 효율적입니다. (이 예에서 'xyz'테이블은 'main'스키마에있는 것으로 가정합니다. 다시, 각각 새로운 집계 기능이없는 경우와없는 경우 모두 DBSTAT 사용을 보여주는 두 가지 버전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63736dfc77ed5a0f9b2aa82f7d9b5938ad21b2a2" translate="yes" xml:space="preserve">
          <source>To see how efficiently the content of a table is stored on disk, compute the amount of space used to hold actual content divided by the total amount of disk space used. The closer this number is to 100%, the more efficient the packing. (In this example, the 'xyz' table is assumed to be in the 'main' schema.)</source>
          <target state="translated">테이블의 내용이 디스크에 얼마나 효율적으로 저장되는지 확인하려면 실제 내용을 보유하는 데 사용 된 공간의 양을 사용 된 총 디스크 공간으로 나눈 값을 계산하십시오. 이 수치가 100 %에 가까울수록 포장이 더 효율적입니다. 이 예에서 'xyz'테이블은 'main'스키마에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b389fbfc405d7654267e252e722e4fd63d443182" translate="yes" xml:space="preserve">
          <source>To see what SQL statements are used to implement an SQLite Archive operation, add the --dryrun or -n option. This causes the SQL to be displayed but inhibits the execution of the SQL.</source>
          <target state="translated">SQLite Archive 작업을 구현하는 데 사용되는 SQL 문을 보려면 --dryrun 또는 -n 옵션을 추가하십시오. 이로 인해 SQL이 표시되지만 SQL 실행은 금지됩니다.</target>
        </trans-unit>
        <trans-unit id="4b42f62d4c2b9ee3d96292447437ef792183dfd3" translate="yes" xml:space="preserve">
          <source>To simplify export to a spreadsheet, the CLI provides the &quot;.excel&quot; command which captures the output of a single query and sends that output to the default spreadsheet program on the host computer. Use it like this:</source>
          <target state="translated">스프레드 시트로 내보내기를 단순화하기 위해 CLI는 &quot;.excel&quot;명령을 제공하여 단일 쿼리의 출력을 캡처하고 해당 출력을 호스트 컴퓨터의 기본 스프레드 시트 프로그램으로 보냅니다. 다음과 같이 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7637fa0269c40df023fe74c58e653b7742bc4073" translate="yes" xml:space="preserve">
          <source>To simplify matters, SQLite is also available as a pre-packaged &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code file: &lt;b&gt;sqlite3.c&lt;/b&gt;. The amalgamation is a single file of ANSI-C code that implements the entire SQLite library. The amalgamation is much easier to deal with. Everything is contained within a single code file, so it is easy to drop into the source tree of a larger C or C++ program. All the code generation and transformation steps have already been carried out so there are no auxiliary C programs to configure and compile and no scripts to run. And, because the entire library is contained in a single translation unit, compilers are able to do more advanced optimizations resulting in a 5% to 10% performance improvement. For these reasons, the amalgamation source file (&quot;&lt;b&gt;sqlite3.c&lt;/b&gt;&quot;) is recommended for all applications.</source>
          <target state="translated">문제를 단순화하기 위해 SQLite는 사전 패키지 된 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 소스 코드 파일 &lt;b&gt;sqlite3.c&lt;/b&gt; 로도 제공됩니다 . 합병은 전체 SQLite 라이브러리를 구현하는 ANSI-C 코드의 단일 파일입니다. 합병은 다루기가 훨씬 쉽습니다. 모든 것이 단일 코드 파일에 포함되어 있으므로 더 큰 C 또는 C ++ 프로그램의 소스 트리로 쉽게 넘어갈 수 있습니다. 모든 코드 생성 및 변환 단계가 이미 수행되었으므로 구성 및 컴파일 할 보조 C 프로그램과 실행할 스크립트가 없습니다. 또한 전체 라이브러리가 단일 변환 단위에 포함되어 있기 때문에 컴파일러는 고급 최적화를 수행하여 성능을 5 ~ 10 % 향상시킬 수 있습니다. 이러한 이유로, 합병 소스 파일 ( &quot; &lt;b&gt;sqlite3.c&lt;/b&gt;&quot;)는 모든 응용 프로그램에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d56a317c733fa84480a64f52f9271ff584d1e783" translate="yes" xml:space="preserve">
          <source>To start a read transaction, the reader records the number of value frames in the WAL as &quot;mxFrame&quot;. (&lt;a href=&quot;walformat#mxframe&quot;&gt;More detail&lt;/a&gt;) The reader uses this recorded mxFrame value for all subsequent read operations. New transactions can be appended to the WAL, but as long as the reader uses its original mxFrame value and ignores subsequently appended content, the reader will see a consistent snapshot of the database from a single point in time. This technique allows multiple concurrent readers to view different versions of the database content simultaneously.</source>
          <target state="translated">읽기 트랜잭션을 시작하기 위해 리더는 WAL의 값 프레임 수를 &quot;mxFrame&quot;으로 기록합니다. ( &lt;a href=&quot;walformat#mxframe&quot;&gt;자세한 내용&lt;/a&gt; ) 리더는 모든 후속 읽기 작업에이 기록 된 mxFrame 값을 사용합니다. 새로운 트랜잭션을 WAL에 추가 할 수 있지만 독자가 원래의 mxFrame 값을 사용하고 이후에 추가 된 컨텐츠를 무시하는 한 독자는 단일 시점에서 데이터베이스의 일관된 스냅 샷을 보게됩니다. 이 기술을 사용하면 여러 동시 판독기가 서로 다른 버전의 데이터베이스 컨텐츠를 동시에 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9664fcd7b01d40ea215ecbc89763a66fc98a4450" translate="yes" xml:space="preserve">
          <source>To statically link this extension with your product, compile it like any other C-language module but add the &quot;-DSQLITE_CKSUMVFS_STATIC&quot; option so that this module knows that it is being statically linked rather than dynamically linked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dba6bd0d0a444202c62a827b56648b58c226e29" translate="yes" xml:space="preserve">
          <source>To statically link your extension, simply add the -DSQLITE_CORE compile-time option. The SQLITE_CORE macro causes the SQLITE_EXTENSION_INIT1 and SQLITE_EXTENSION_INIT2 macros to become no-ops. Then modify your application to invoke the entry point directly, passing in a NULL pointer as the third &quot;pApi&quot; parameter.</source>
          <target state="translated">확장을 정적으로 연결하려면 -DSQLITE_CORE 컴파일 타임 옵션을 추가하십시오. SQLITE_CORE 매크로는 SQLITE_EXTENSION_INIT1 및 SQLITE_EXTENSION_INIT2 매크로가 작동하지 않게합니다. 그런 다음 애플리케이션을 수정하여 진입 점을 직접 호출하고 NULL 포인터를 세 번째 &quot;pApi&quot;매개 변수로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="63ab9efaac3f7a15bafc977a5dae2473a8be793a" translate="yes" xml:space="preserve">
          <source>To support</source>
          <target state="translated">지원하기</target>
        </trans-unit>
        <trans-unit id="a791e72c80a35cf93de60b32f2721ee1c5ba3b6f" translate="yes" xml:space="preserve">
          <source>To support full-text queries, FTS maintains an inverted index that maps from each unique term or word that appears in the dataset to the locations in which it appears within the table contents. For the curious, a complete description of the &lt;a href=&quot;fts3#data_structures&quot;&gt;data structure&lt;/a&gt; used to store this index within the database file appears below. A feature of this data structure is that at any time the database may contain not one index b-tree, but several different b-trees that are incrementally merged as rows are inserted, updated and deleted. This technique improves performance when writing to an FTS table, but causes some overhead for full-text queries that use the index. Evaluating the special &lt;a href=&quot;fts3#*fts4optcmd&quot;&gt;&quot;optimize&quot; command&lt;/a&gt;, an SQL statement of the form &quot;INSERT INTO &amp;lt;fts-table&amp;gt;(&amp;lt;fts-table&amp;gt;) VALUES('optimize')&quot;, causes FTS to merge all existing index b-trees into a single large b-tree containing the entire index. This can be an expensive operation, but may speed up future queries.</source>
          <target state="translated">전체 텍스트 쿼리를 지원하기 위해 FTS는 데이터 집합에 나타나는 각각의 고유 한 용어 또는 단어에서 테이블 내용 내에 나타나는 위치로 매핑되는 반전 된 인덱스를 유지 관리합니다. 궁금한 점은 데이터베이스 파일 내에이 인덱스를 저장하는 데 사용되는 &lt;a href=&quot;fts3#data_structures&quot;&gt;데이터 구조에&lt;/a&gt; 대한 전체 설명 이 아래에 나와 있습니다. 이 데이터 구조의 특징은 데이터베이스에 언제든지 하나의 인덱스 b- 트리가 아니라 행이 삽입, 업데이트 및 삭제 될 때 점진적으로 병합되는 여러 다른 b- 트리가 포함될 수 있다는 것입니다. 이 기술은 FTS 테이블에 쓸 때 성능을 향상 시키지만 인덱스를 사용하는 전체 텍스트 쿼리에 약간의 오버 헤드를 발생시킵니다. 특수한 &lt;a href=&quot;fts3#*fts4optcmd&quot;&gt;&quot;최적화&quot;명령&lt;/a&gt; 평가&quot;INSERT INTO &amp;lt;fts-table&amp;gt; (&amp;lt;fts-table&amp;gt;) VALUES ( 'optimize')&quot;형식의 SQL 문은 FTS가 기존의 모든 인덱스 b- 트리를 전체를 포함하는 하나의 큰 b- 트리로 병합합니다. 인덱스. 이 작업은 비용이 많이 들지만 향후 쿼리 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef681c818587ecc3e802ff227ea9402f9c2f1648" translate="yes" xml:space="preserve">
          <source>To try to answer this, we ran 49 test cases with various BLOB sizes and SQLite page sizes on a Linux workstation (Ubuntu circa 2011 with the Ext4 filesystem on a fast SATA disk). For each test case, a database was created that contains 100MB of BLOB content. The sizes of the BLOBs ranged from 10KB to 1MB. The number of BLOBs varied in order to keep the total BLOB content at about 100MB. (Hence, 100 BLOBs for the 1MB size and 10000 BLOBs for the 10K size and so forth.) SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_8.html&quot;&gt;version 3.7.8&lt;/a&gt; (2011-09-19) was used.</source>
          <target state="translated">이에 대한 답을 찾기 위해 Linux 워크 스테이션 (빠른 SATA 디스크에 Ext4 파일 시스템이있는 2011 년경 우분투)에서 다양한 BLOB 크기와 SQLite 페이지 크기로 49 개의 테스트 사례를 실행했습니다. 각 테스트 사례에 대해 100MB의 BLOB 컨텐츠를 포함하는 데이터베이스가 작성되었습니다. BLOB의 크기는 10KB에서 1MB 사이였습니다. 총 BLOB 내용을 약 100MB로 유지하기 위해 BLOB의 수는 다양했습니다. 따라서 1MB 크기의 경우 100 개의 BLOB 및 10K 크기의 경우 10000 개의 BLOB 등이 있습니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_8.html&quot;&gt;버전 3.7.8&lt;/a&gt; (2011-09-19)이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="49ecd119f567ef3a86904898280b0f364fa219ed" translate="yes" xml:space="preserve">
          <source>To understand better how indices work, lets first look at how they are created. Let's go ahead and put an index on the two column of the examp table. We have:</source>
          <target state="translated">인덱스의 작동 방식을 더 잘 이해하려면 먼저 인덱스 생성 방법을 살펴 보겠습니다. 계속해서 examp 테이블의 두 열에 색인을 작성하십시오. 우리는 :</target>
        </trans-unit>
        <trans-unit id="dec160dc75f7898baa78422fcd36c20f9eb86bdf" translate="yes" xml:space="preserve">
          <source>To use FTS5, the user creates an FTS5 virtual table with one or more columns. For example:</source>
          <target state="translated">FTS5를 사용하기 위해 사용자는 하나 이상의 열이있는 FTS5 가상 테이블을 만듭니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="265f2aec4f2165ae622d11cb8e5b583eee970ef5" translate="yes" xml:space="preserve">
          <source>To use a custom delta format, the RBU application must register a user-defined SQL function named &quot;rbu_delta&quot; before beginning to process the update. rbu_delta() will be invoked with two arguments - the original value stored in the target table column and the delta value provided as part of the RBU update. It should return the result of applying the delta to the original value. To use the custom delta function, the character of the rbu_control value corresponding to the target column to update must be set to 'd' instead of 'x'. Then, instead of updating the target table with the value stored in the corresponding data_% column, RBU invokes the user-defined SQL function &quot;rbu_delta()&quot; and the store in the target table column.</source>
          <target state="translated">사용자 정의 델타 형식을 사용하려면 RBU 애플리케이션이 업데이트 처리를 시작하기 전에 &quot;rbu_delta&quot;라는 사용자 정의 SQL 함수를 등록해야합니다. rbu_delta ()는 두 개의 인수, 즉 대상 테이블 열에 저장된 원래 값과 RBU 업데이트의 일부로 제공된 델타 값으로 호출됩니다. 델타를 원래 값에 적용한 결과를 반환해야합니다. 사용자 정의 델타 함수를 사용하려면 업데이트 할 대상 열에 해당하는 rbu_control 값의 문자를 'x'대신 'd'로 설정해야합니다. 그런 다음, 해당 data_ % 열에 저장된 값으로 대상 테이블을 업데이트하는 대신 RBU는 사용자 정의 SQL 함수 &quot;rbu_delta ()&quot;및 대상 테이블 열의 저장소를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1df3b152e981587cbc8d566dc7a1e4614e184269" translate="yes" xml:space="preserve">
          <source>To use the asynchronous IO extension, compile sqlite3async.c as part of the application that uses SQLite. Then use the APIs defined in sqlite3async.h to initialize and configure the module.</source>
          <target state="translated">비동기 IO 확장을 사용하려면 SQLite를 사용하는 애플리케이션의 일부로 sqlite3async.c를 컴파일하십시오. 그런 다음 sqlite3async.h에 정의 된 API를 사용하여 모듈을 초기화하고 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="54369ca0a2e65d88aa2188ae1aea4d3b328a4d8d" translate="yes" xml:space="preserve">
          <source>To work around this problem, comments of the form &quot;&lt;code&gt;/*OPTIMIZATION-IF-TRUE*/&lt;/code&gt;&quot; and &quot;&lt;code&gt;/*OPTIMIZATION-IF-FALSE*/&lt;/code&gt;&quot; are inserted into the SQLite source code to tell the mutation testing script to ignore some branch instructions.</source>
          <target state="translated">이 문제를 해결하기 위해 &quot; &lt;code&gt;/*OPTIMIZATION-IF-TRUE*/&lt;/code&gt; &quot;및 &quot; &lt;code&gt;/*OPTIMIZATION-IF-FALSE*/&lt;/code&gt; &quot; 형식의 주석이 SQLite 소스 코드에 삽입되어 돌연변이 테스트 스크립트가 일부 분기를 무시하도록 지시합니다. 명령.</target>
        </trans-unit>
        <trans-unit id="8634a2716b4084136c44730377ba4cb303464e5e" translate="yes" xml:space="preserve">
          <source>To write to a database, a process must first acquire a SHARED lock as described above (possibly rolling back incomplete changes if there is a hot journal). After a SHARED lock is obtained, a RESERVED lock must be acquired. The RESERVED lock signals that the process intends to write to the database at some point in the future. Only one process at a time can hold a RESERVED lock. But other processes can continue to read the database while the RESERVED lock is held.</source>
          <target state="translated">데이터베이스에 쓰려면 프로세스는 먼저 위에서 설명한대로 SHARED 잠금을 획득해야합니다 (핫 저널이있는 경우 불완전한 변경 사항을 롤백 할 수 있음). SHARED 잠금을 얻은 후에는 RESERVED 잠금을 획득해야합니다. 예약 된 잠금은 프로세스가 나중에 특정 시점에 데이터베이스에 쓰려고한다는 신호를 보냅니다. 한 번에 하나의 프로세스 만 예약 된 잠금을 보유 할 수 있습니다. 그러나 RESERVED 잠금이 유지되는 동안 다른 프로세스는 계속 데이터베이스를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a3153289ec6bfe9b3f6870a925bacb15383077" translate="yes" xml:space="preserve">
          <source>Tokenize text using the tokenizer belonging to the FTS5 table.</source>
          <target state="translated">FTS5 테이블에 속하는 토크 나이저를 사용하여 텍스트를 토큰 화하십시오.</target>
        </trans-unit>
        <trans-unit id="0c8bdf6b370d1a312eb6820161397309d486c6dc" translate="yes" xml:space="preserve">
          <source>Tokenizer</source>
          <target state="translated">Tokenizer</target>
        </trans-unit>
        <trans-unit id="4fa8cc860c52b268dc6a3adcde7305e9415db5bb" translate="yes" xml:space="preserve">
          <source>Tools</source>
          <target state="translated">Tools</target>
        </trans-unit>
        <trans-unit id="75832235d44d151c0581571bd2e345dae5797a4a" translate="yes" xml:space="preserve">
          <source>Top-level programs determine first invocation by comparing the P1 operand against the P1 operand on the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode at the beginning of the program. If the P1 values differ, then fall through and make the P1 of this opcode equal to the P1 of &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt;. If P1 values are the same then take the jump.</source>
          <target state="translated">최상위 프로그램 은 프로그램 시작시 &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode 의 P1 피연산자와 P1 피연산자를 비교하여 첫 번째 호출을 판별 합니다. P1 값이 다르면이 opcode의 P1을 &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; 의 P1과 동일하게 만듭니다. P1 값이 동일하면 점프를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="95996c8558adf5424c8f05c23135b86d2248df1e" translate="yes" xml:space="preserve">
          <source>Torn Pages</source>
          <target state="translated">찢어진 페이지</target>
        </trans-unit>
        <trans-unit id="f377932bef10eacf89a6d96048f5b7dd7d0a3754" translate="yes" xml:space="preserve">
          <source>Torn page</source>
          <target state="translated">찢어진 페이지</target>
        </trans-unit>
        <trans-unit id="052c92ab74e0edce8a8ddb051550d404ed7fea5b" translate="yes" xml:space="preserve">
          <source>Total Number Of Rows Modified</source>
          <target state="translated">수정 된 총 행 수</target>
        </trans-unit>
        <trans-unit id="3c9565648378ccdf7ff691fdffa344d4a20079e8" translate="yes" xml:space="preserve">
          <source>Total number of freelist pages.</source>
          <target state="translated">총 자유 목록 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="bedc83f26e09b1694605e6429adbe802acf7164e" translate="yes" xml:space="preserve">
          <source>Total storage space used by the current page or btree.</source>
          <target state="translated">현재 페이지 또는 btree에서 사용하는 총 저장 공간입니다.</target>
        </trans-unit>
        <trans-unit id="2f38169a712e499b917900e244feafc980a814f4" translate="yes" xml:space="preserve">
          <source>Trace</source>
          <target state="translated">Trace</target>
        </trans-unit>
        <trans-unit id="74cdc489721505bec65d3348184378ff2eaaa995" translate="yes" xml:space="preserve">
          <source>Trace method</source>
          <target state="translated">추적 방법</target>
        </trans-unit>
        <trans-unit id="d43a1036d6d0f2293d5b6b4fac27045bad910d65" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;close&lt;/b&gt; invoke the callback with a single argument as the database connection is closing. The argument is an integer which is the value of a pointer to the underlying &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; object that is closing.</source>
          <target state="translated">&lt;b&gt;닫기&lt;/b&gt; 추적 은 데이터베이스 연결이 닫힐 때 단일 인수로 콜백을 호출합니다. 인수 는 닫는 기본 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;sqlite3&lt;/a&gt; 객체 에 대한 포인터 값인 정수입니다 .</target>
        </trans-unit>
        <trans-unit id="a9ae29ad74c7078369f553dd8cff4f37e437703e" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;profile&lt;/b&gt; invoke the callback with two arguments as each SQL statement finishes. The first argument is an integer which is the value of the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object. The second argument is the approximate run-time for the statement in nanoseconds. The run-time is the best estimate available depending on the capabilities of the platform on which the application is running.</source>
          <target state="translated">&lt;b&gt;프로파일에&lt;/b&gt; 대한 추적은 각 SQL 문이 완료 될 때 두 개의 인수로 콜백을 호출합니다. 첫 번째 인수는 기본 &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 객체 의 값인 정수입니다 . 두 번째 인수는 명령문의 대략적인 런타임입니다 (나노초). 런타임은 응용 프로그램이 실행되는 플랫폼의 기능에 따라 사용 가능한 최상의 추정치입니다.</target>
        </trans-unit>
        <trans-unit id="57b5e1e30279e2c4dd1bed70627b5481cb49b436" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;row&lt;/b&gt; invoke the callback with a single argument whenever a new result row is available from an SQL statement. The argument is an integer which is the value of the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object pointer.</source>
          <target state="translated">&lt;b&gt;행에&lt;/b&gt; 대한 추적 은 SQL 문에서 새 결과 행을 사용할 수있을 때마다 단일 인수로 콜백을 호출합니다. 인수는 기본 &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 오브젝트 포인터 의 값인 정수입니다 .</target>
        </trans-unit>
        <trans-unit id="408f79d424be1f606eac26e2ea2665bbafc8553b" translate="yes" xml:space="preserve">
          <source>Traces for &lt;b&gt;statement&lt;/b&gt; invoke the callback with two arguments whenever a new SQL statement is run. The first argument is an integer which is the value of the pointer to the underlying &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object. This integer can be used to correlate SQL statement text with the result of a &lt;b&gt;profile&lt;/b&gt; or &lt;b&gt;row&lt;/b&gt; callback. The second argument is the unexpanded text of the SQL statement being run. By &quot;unexpanded&quot;, we mean that variable substitutions in the text are not expanded into the variable values. This is different from the behavior of the &quot;trace&quot; method which does expand variable substitutions.</source>
          <target state="translated">&lt;b&gt;명령문&lt;/b&gt; 추적 은 새 SQL 문이 실행될 때마다 두 개의 인수로 콜백을 호출합니다. 첫 번째 인수는 기본 &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 객체 에 대한 포인터 값인 정수입니다 . 이 정수는 SQL 문 텍스트를 &lt;b&gt;프로파일&lt;/b&gt; 또는 &lt;b&gt;행&lt;/b&gt; 콜백 의 결과와 연관시키는 데 사용될 수 있습니다 . 두 번째 인수는 실행중인 SQL 문의 확장되지 않은 텍스트입니다. &quot;확장되지 않음&quot;은 텍스트의 변수 대체가 변수 값으로 확장되지 않음을 의미합니다. 이는 변수 대체를 확장하는 &quot;추적&quot;방법의 동작과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="97acc1b59f9ec17c88715b436c8c28883bd4892f" translate="yes" xml:space="preserve">
          <source>Tracing And Profiling Functions</source>
          <target state="translated">추적 및 프로파일 링 기능</target>
        </trans-unit>
        <trans-unit id="394bbe198e3a9b250514b00b862a8ecf0b427532" translate="yes" xml:space="preserve">
          <source>Tracing VDBE Program Execution</source>
          <target state="translated">VDBE 프로그램 실행 추적</target>
        </trans-unit>
        <trans-unit id="a89304c783bc5056656be7a965ab51352c92b27f" translate="yes" xml:space="preserve">
          <source>Traditional Command</source>
          <target state="translated">전통적인 명령</target>
        </trans-unit>
        <trans-unit id="1a7b7c1b33d161f45804730c70b75175dccd9883" translate="yes" xml:space="preserve">
          <source>Transaction</source>
          <target state="translated">Transaction</target>
        </trans-unit>
        <trans-unit id="9f6d84035f64a6ceb70cb91cd6cf32d299234a85" translate="yes" xml:space="preserve">
          <source>Transaction Nesting Rules</source>
          <target state="translated">트랜잭션 중첩 규칙</target>
        </trans-unit>
        <trans-unit id="559a84bc65d3e0735a796537311e8ae93e9b3578" translate="yes" xml:space="preserve">
          <source>Transaction Rollback</source>
          <target state="translated">트랜잭션 롤백</target>
        </trans-unit>
        <trans-unit id="8ade0bd69f2ac11b2fad88f7b26304c0adf8bac8" translate="yes" xml:space="preserve">
          <source>Transaction control statements such as &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, and &lt;a href=&quot;../lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt; statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; since &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; merely sets internal flags, but the &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.</source>
          <target state="translated">&lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; , &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; , &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; , &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 및 &lt;a href=&quot;../lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 와 같은 트랜잭션 제어 명령문 은 명령문 자체가 실제로 데이터베이스를 수정하지 않고 다른 명령문이 데이터베이스를 수정하는시기를 제어하므로 sqlite3_stmt_readonly ()는 true를 리턴합니다. 는 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;../lang_detach&quot;&gt;DETACH의&lt;/a&gt; 가 디스크의 데이터베이스 파일의 내용을 변경하지 않는, 그 문은 데이터베이스 연결의 구성을 변경하면서 문은 또한, () (때문에), true가 돌아갑니다 sqlite3_stmt_readonly 원인이된다. sqlite3_stmt_readonly () 인터페이스는 &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 이후 &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN에&lt;/a&gt; 대해 true를 리턴합니다.내부 플래그 만 설정하지만 &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; 및 &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; 명령은 데이터베이스를 터치하므로 sqlite3_stmt_readonly ()는 해당 명령에 대해 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27b3779c5fd38ff491a7c50d915a8ad6fa71bac3" translate="yes" xml:space="preserve">
          <source>Transaction control statements such as &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, and &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; cause sqlite3_stmt_readonly() to return true, since the statements themselves do not actually modify the database but rather they control the timing of when other statements modify the database. The &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; statements also cause sqlite3_stmt_readonly() to return true since, while those statements change the configuration of a database connection, they do not make changes to the content of the database files on disk. The sqlite3_stmt_readonly() interface returns true for &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; since &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; merely sets internal flags, but the &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; and &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; commands do touch the database and so sqlite3_stmt_readonly() returns false for those commands.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; , &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; , &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 및 &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 와 같은 트랜잭션 제어 명령문 은 명령문 자체가 실제로 데이터베이스를 수정하지 않고 다른 명령문이 데이터베이스를 수정하는시기를 제어하므로 sqlite3_stmt_readonly ()는 true를 리턴합니다. 는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;lang_detach&quot;&gt;DETACH의&lt;/a&gt; 가 디스크의 데이터베이스 파일의 내용을 변경하지 않는, 그 문은 데이터베이스 연결의 구성을 변경하면서 문은 또한, () (때문에), true가 돌아갑니다 sqlite3_stmt_readonly 원인이된다. sqlite3_stmt_readonly () 인터페이스는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 이후 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN에&lt;/a&gt; 대해 true를 리턴합니다.내부 플래그 만 설정하지만 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; 및 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN EXCLUSIVE&lt;/a&gt; 명령은 데이터베이스를 터치하므로 sqlite3_stmt_readonly ()는 해당 명령에 대해 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8a3a9f146929435e416d0b1eea1f2d4c645865f1" translate="yes" xml:space="preserve">
          <source>Transaction method</source>
          <target state="translated">거래 방법</target>
        </trans-unit>
        <trans-unit id="e07bd983fd2be3fec651b38d00687dea5ddec91f" translate="yes" xml:space="preserve">
          <source>Transaction speed is limited by disk drive speed because (by default) SQLite actually waits until the data really is safely stored on the disk surface before the transaction is complete. That way, if you suddenly lose power or if your OS crashes, your data is still safe. For details, read about &lt;a href=&quot;atomiccommit&quot;&gt;atomic commit in SQLite.&lt;/a&gt;.</source>
          <target state="translated">트랜잭션 속도는 디스크 드라이브 속도에 의해 제한됩니다 (기본적으로 SQLite는 트랜잭션이 완료되기 전에 데이터가 실제로 디스크 표면에 안전하게 저장 될 때까지 대기하기 때문에). 이렇게하면 갑자기 전원이 꺼 지거나 OS가 중단 되더라도 데이터는 여전히 안전합니다. 자세한 내용 &lt;a href=&quot;atomiccommit&quot;&gt;은 SQLite의 원자 커밋에&lt;/a&gt; 대해 읽으십시오 . .</target>
        </trans-unit>
        <trans-unit id="df69c71bc9ee2d5d83cb3c63296f150aa519dbce" translate="yes" xml:space="preserve">
          <source>Transactions can be DEFERRED, IMMEDIATE, or EXCLUSIVE. The default transaction behavior is DEFERRED.</source>
          <target state="translated">트랜잭션은 지연, 즉시 또는 독점적 일 수 있습니다. 기본 트랜잭션 동작은 DEFERRED입니다.</target>
        </trans-unit>
        <trans-unit id="8441979420cc8e7193bf0e0806b90756ef918a72" translate="yes" xml:space="preserve">
          <source>Transactions can be started manually using the BEGIN command. Such transactions usually persist until the next COMMIT or ROLLBACK command. But a transaction will also ROLLBACK if the database is closed or if an error occurs and the ROLLBACK conflict resolution algorithm is specified. See the documentation on the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause for additional information about the ROLLBACK conflict resolution algorithm.</source>
          <target state="translated">BEGIN 명령을 사용하여 트랜잭션을 수동으로 시작할 수 있습니다. 이러한 트랜잭션은 일반적으로 다음 COMMIT 또는 ROLLBACK 명령까지 지속됩니다. 그러나 데이터베이스가 닫히거나 오류가 발생하고 ROLLBACK 충돌 해결 알고리즘이 지정된 경우 트랜잭션도 ROLLBACK됩니다. ROLLBACK 충돌 해결 알고리즘에 대한 추가 정보 는 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5743531bc167a0f47f6a510d1c09f16148c6d3da" translate="yes" xml:space="preserve">
          <source>Transactions created using BEGIN...COMMIT do not nest. For nested transactions, use the &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; and &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; commands. The &quot;TO SAVEPOINT name&quot; clause of the ROLLBACK command shown in the syntax diagram above is only applicable to &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; transactions. An attempt to invoke the BEGIN command within a transaction will fail with an error, regardless of whether the transaction was started by &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; or a prior BEGIN. The COMMIT command and the ROLLBACK command without the TO clause work the same on &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; transactions as they do with transactions started by BEGIN.</source>
          <target state="translated">BEGIN ... COMMIT을 사용하여 작성된 트랜잭션은 중첩되지 않습니다. 중첩 트랜잭션의 경우 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 및 &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 명령을 사용하십시오 . 위의 구문 다이어그램에 표시된 ROLLBACK 명령의 &quot;TO SAVEPOINT name&quot;절은 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 트랜잭션 에만 적용 됩니다. 트랜잭션이 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT에&lt;/a&gt; 의해 시작되었는지 또는 이전 BEGIN에 의해 시작되었는지에 관계없이 트랜잭션 내에서 BEGIN 명령을 호출하려는 시도는 오류와 함께 실패합니다 . TO 절이없는 COMMIT 명령 및 ROLLBACK 명령은 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 트랜잭션에서 BEGIN으로 시작된 트랜잭션과 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="4e5b097bbdedc9d11240febdc9033ef693213407" translate="yes" xml:space="preserve">
          <source>Transactions in SQLite are SERIALIZABLE.</source>
          <target state="translated">SQLite의 트랜잭션은 직렬화 가능합니다.</target>
        </trans-unit>
        <trans-unit id="40f17b088c01997dd93e90e0db80840a80f74d26" translate="yes" xml:space="preserve">
          <source>Transactions involving multiple attached databases are atomic, assuming that the main database is not &quot;&lt;a href=&quot;inmemorydb&quot;&gt;:memory:&lt;/a&gt;&quot; and the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; is not &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;. If the main database is &quot;:memory:&quot; or if the journal_mode is WAL, then transactions continue to be atomic within each individual database file. But if the host computer crashes in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; where two or more database files are updated, some of those files might get the changes where others might not.</source>
          <target state="translated">주 데이터베이스가 &quot; &lt;a href=&quot;inmemorydb&quot;&gt;: memory :&lt;/a&gt; &quot; 가 아니고 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; 가 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 이 아니라고 가정하면 여러 개의 연결된 데이터베이스가 포함 된 트랜잭션은 원 자성 입니다. 기본 데이터베이스가 &quot;: memory :&quot;이거나 journal_mode가 WAL 인 경우 트랜잭션은 각 개별 데이터베이스 파일 내에서 계속 원자 적입니다. 그러나 두 개 이상의 데이터베이스 파일이 업데이트 되는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 도중에 호스트 컴퓨터가 충돌하는 경우 해당 파일 중 일부는 다른 파일이 변경되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eceeec5767d02607ea24c1ab3a8a3bd0186d9069" translate="yes" xml:space="preserve">
          <source>Transactions that involve changes against multiple &lt;a href=&quot;lang_attach&quot;&gt;ATTACHed&lt;/a&gt; databases are atomic for each individual database, but are not atomic across all databases as a set.</source>
          <target state="translated">여러 &lt;a href=&quot;lang_attach&quot;&gt;첨부 된&lt;/a&gt; 데이터베이스 에 대한 변경이 포함 된 트랜잭션 은 각 개별 데이터베이스마다 원자 적이지만 모든 데이터베이스에서 하나의 원자 집합은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="62eb009ad23bc2fc48eb046817b2cfc13d56eba9" translate="yes" xml:space="preserve">
          <source>Transfer any terms of the HAVING clause that use only columns mentioned in the GROUP BY clause over to the WHERE clause for faster processing.</source>
          <target state="translated">빠른 처리를 위해 GROUP BY 절에서 언급 된 열만 사용하는 HAVING 절의 용어를 WHERE 절로 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="730f8c6a84d5869c2c8dd4a477da51b4cb41ea47" translate="yes" xml:space="preserve">
          <source>Transfer content from X into new_X using a statement like: INSERT INTO new_X SELECT ... FROM X.</source>
          <target state="translated">INSERT INTO new_X SELECT ... FROM X와 같은 명령문을 사용하여 X에서 new_X로 컨텐츠를 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="f547c01f878e078bc070f937769a72523b2e574f" translate="yes" xml:space="preserve">
          <source>Transfer the integer value held in register P1 into register P2.</source>
          <target state="translated">레지스터 P1에 보유 된 정수 값을 레지스터 P2로 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="77dbfff94d90d8a93cedb37403df1e3f9c6cd3b3" translate="yes" xml:space="preserve">
          <source>Transfer the values of bound parameter P1 into register P2</source>
          <target state="translated">바운드 파라미터 P1의 값을 레지스터 P2로 전송</target>
        </trans-unit>
        <trans-unit id="893d914ab7aa99042fec20acf2eaca5958133d3d" translate="yes" xml:space="preserve">
          <source>Transient databases used by VACUUM</source>
          <target state="translated">VACUUM에서 사용하는 임시 데이터베이스</target>
        </trans-unit>
        <trans-unit id="2f1b468fe1a7e1526a9f4c864607d41c919ffd24" translate="yes" xml:space="preserve">
          <source>Transient indices</source>
          <target state="translated">일시적인 지수</target>
        </trans-unit>
        <trans-unit id="50518458bc2d78b06bb9e7c5b63ac61506608217" translate="yes" xml:space="preserve">
          <source>Translate between MBCS and UTF8 when running in &lt;a href=&quot;https://en.wikipedia.org/wiki/Cmd.exe&quot;&gt;cmd.exe&lt;/a&gt; on Windows.</source>
          <target state="translated">Windows의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cmd.exe&quot;&gt;cmd.exe&lt;/a&gt; 에서 실행할 때 MBCS와 UTF8 사이를 변환 하십시오.</target>
        </trans-unit>
        <trans-unit id="6e387894c93cc4723354d247bd4d6e5f35bd4895" translate="yes" xml:space="preserve">
          <source>Translate filenames</source>
          <target state="translated">파일 이름 번역</target>
        </trans-unit>
        <trans-unit id="f295e110407055d129ea14d63c92143f2eb2907c" translate="yes" xml:space="preserve">
          <source>Translate the program source text into an executable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644d0f445f0d7fb8522aea7a162b92e1da1dcdd3" translate="yes" xml:space="preserve">
          <source>Treat carriage returns as white space.</source>
          <target state="translated">캐리지 리턴은 공백으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1627be3072e4ff3d0841c2ea6a10d65f535946" translate="yes" xml:space="preserve">
          <source>Treats the CROSS JOIN operator specially</source>
          <target state="translated">CROSS JOIN 연산자를 특수하게 처리</target>
        </trans-unit>
        <trans-unit id="decc687edb29445327b8a79bb188b87ba3135e16" translate="yes" xml:space="preserve">
          <source>Trigger automatic reprepares on all prepared statements when &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; is run.</source>
          <target state="translated">&lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 가 실행될 때 모든 준비된 명령문에서 자동 재 준비를 트리거 합니다.</target>
        </trans-unit>
        <trans-unit id="1766c462387d7f9f9f502cf4237e70b197fe70e9" translate="yes" xml:space="preserve">
          <source>Triggers are automatically &lt;a href=&quot;lang_droptrigger&quot;&gt;dropped&lt;/a&gt; when the table that they are associated with (the</source>
          <target state="translated">연관된 테이블이 트리거 되면 트리거가 자동으로 &lt;a href=&quot;lang_droptrigger&quot;&gt;삭제&lt;/a&gt; 됩니다 (</target>
        </trans-unit>
        <trans-unit id="69e3fbc441e15119829ba089bca3c89252728d25" translate="yes" xml:space="preserve">
          <source>Triggers are removed using the &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; 문을 사용하여 트리거를 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="dcdd52f1e8691359fb02268af93879c1dfcea004" translate="yes" xml:space="preserve">
          <source>Triggers may be created on &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt;, as well as ordinary tables, by specifying INSTEAD OF in the CREATE TRIGGER statement. If one or more ON INSERT, ON DELETE or ON UPDATE triggers are defined on a view, then it is not an error to execute an INSERT, DELETE or UPDATE statement on the view, respectively. Instead, executing an INSERT, DELETE or UPDATE on the view causes the associated triggers to fire. The real tables underlying the view are not modified (except possibly explicitly, by a trigger program).</source>
          <target state="translated">CREATE TRIGGER 문에 INSTEAD OF를 지정하여 일반 테이블뿐만 아니라 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 에서 트리거를 작성할 수 있습니다 . 하나 이상의 ON INSERT, ON DELETE 또는 ON UPDATE 트리거가 뷰에 정의되어 있으면 뷰에서 INSERT, DELETE 또는 UPDATE 문을 각각 실행하는 것은 오류가 아닙니다. 대신,보기에서 INSERT, DELETE 또는 UPDATE를 실행하면 연관된 트리거가 실행됩니다. 뷰의 기본이되는 실제 테이블은 수정되지 않습니다 (가능하면 명시 적으로 트리거 프로그램에 의해).</target>
        </trans-unit>
        <trans-unit id="b66e919e408840fec331f77f8a3429cfe94170cd" translate="yes" xml:space="preserve">
          <source>Triggers such as the above could be entered manually, but that is tedious. An important feature of the technique demonstrated below is that the triggers are generated automatically.</source>
          <target state="translated">위와 같은 트리거는 수동으로 입력 할 수 있지만 지루합니다. 아래에 설명 된 기술의 중요한 특징은 트리거가 자동으로 생성된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e34acb097623e43c8ff52044ca91f3ced5485a85" translate="yes" xml:space="preserve">
          <source>Triggers to record changes to table EX1 might look like this:</source>
          <target state="translated">테이블 EX1에 대한 변경 사항을 기록하는 트리거는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43c2fb589737be865737ea2fc85a0b75088859d6" translate="yes" xml:space="preserve">
          <source>True (non-zero) for incremental-vacuum mode. False (zero) otherwise.</source>
          <target state="translated">증분 진공 모드의 경우 참 (0이 아님). 그렇지 않으면 False (영).</target>
        </trans-unit>
        <trans-unit id="7f074c0b29f264e9ae59cff2fae5db054bccc396" translate="yes" xml:space="preserve">
          <source>True if column has a NOT NULL constraint</source>
          <target state="translated">열에 NOT NULL 제약 조건이 있으면 참</target>
        </trans-unit>
        <trans-unit id="fe2612de064655438c6e90275d3a5af5d9b7504f" translate="yes" xml:space="preserve">
          <source>True if column is &lt;a href=&quot;../autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;</source>
          <target state="translated">열이 &lt;a href=&quot;../autoinc&quot;&gt;AUTOINCREMENT 인&lt;/a&gt; 경우 참</target>
        </trans-unit>
        <trans-unit id="7d8389507b03b7d46d63990e4a0a8f44db65074c" translate="yes" xml:space="preserve">
          <source>True if column is &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;</source>
          <target state="translated">열이 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT 인&lt;/a&gt; 경우 참</target>
        </trans-unit>
        <trans-unit id="1c010493691adbcbc6784aac8024d72b69524a24" translate="yes" xml:space="preserve">
          <source>True if column is part of the PRIMARY KEY</source>
          <target state="translated">열이 PRIMARY KEY의 일부이면 참</target>
        </trans-unit>
        <trans-unit id="ce6a6b1eac82572eb6efa838b7ab286cb9aa31b8" translate="yes" xml:space="preserve">
          <source>True if the WAL file uses big-ending checksums. 0 if the WAL uses little-endian checksums.</source>
          <target state="translated">WAL 파일이 큰 종료 체크섬을 사용하는 경우 참입니다. WAL이 리틀 엔디안 체크섬을 사용하는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="4f373c45e72a0d221fc0b61dcd227422649ce1e7" translate="yes" xml:space="preserve">
          <source>Truncate optimization</source>
          <target state="translated">최적화 자르기</target>
        </trans-unit>
        <trans-unit id="7e18421daa9a7bec86e2d8e3de5902e74a610b23" translate="yes" xml:space="preserve">
          <source>Truncate rather than delete the rollback journal when committing a transaction in exclusive access mode, or when committing the TEMP database.</source>
          <target state="translated">배타적 액세스 모드에서 트랜잭션을 커밋하거나 TEMP 데이터베이스를 커밋 할 때 롤백 저널을 삭제하지 말고 잘립니다.</target>
        </trans-unit>
        <trans-unit id="4b63e8b603e1d297d723aa97c1e1ff1c6b4ada53" translate="yes" xml:space="preserve">
          <source>Truncating a page from the end of the database file.</source>
          <target state="translated">데이터베이스 파일 끝에서 페이지를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="4e8f932224015abd68ecfec37f440d1143c9375a" translate="yes" xml:space="preserve">
          <source>Try to set the maximum page count for database P1 to the value in P3. Do not let the maximum page count fall below the current page count and do not change the maximum page count value if P3==0.</source>
          <target state="translated">데이터베이스 P1의 최대 페이지 수를 P3의 값으로 설정하십시오. 최대 페이지 카운트가 현재 페이지 카운트 아래로 떨어지지 않도록하고 P3 == 0 인 경우 최대 페이지 카운트 값을 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f50ca78764f92b1078126a69f3373b839ce5721" translate="yes" xml:space="preserve">
          <source>Tweaks to the query planner to help it do a better job of finding the most efficient query plan for each query.</source>
          <target state="translated">각 쿼리에 가장 효율적인 쿼리 계획을 찾는 데 도움이되도록 쿼리 플래너로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="95be1719f96ddc802fb54cddca40bb8014e1f9bb" translate="yes" xml:space="preserve">
          <source>Two &quot;%&quot; characters in a row are translated into a single &quot;%&quot; in the output, without substituting any values.</source>
          <target state="translated">행에서 두 개의 &quot;%&quot;문자는 값을 대체하지 않고 출력에서 ​​단일 &quot;%&quot;로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="1133220939a743e590c3ead4cc79361a1d89e1c7" translate="yes" xml:space="preserve">
          <source>Two methods of measuring test coverage were described above: &quot;statement&quot; and &quot;branch&quot; coverage. There are many other test coverage metrics besides these two. Another popular metric is &quot;Modified Condition/Decision Coverage&quot; or MC/DC. &lt;a href=&quot;http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage&quot;&gt;Wikipedia&lt;/a&gt; defines MC/DC as follows:</source>
          <target state="translated">테스트 커버리지를 측정하는 두 가지 방법 인 &quot;statement&quot;및 &quot;branch&quot;커버리지가 위에서 설명되었습니다. 이 두 가지 외에도 많은 다른 테스트 범위 메트릭이 있습니다. 널리 사용되는 또 다른 메트릭은 &quot;수정 된 조건 / 결정 범위&quot;또는 MC / DC입니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Modified_Condition/Decision_Coverage&quot;&gt;Wikipedia&lt;/a&gt; 는 다음과 같이 MC / DC를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="8cca3509242a992941b536c5c6f0d9414a60665b" translate="yes" xml:space="preserve">
          <source>Two or more &lt;a href=&quot;lang_select#simpleselect&quot;&gt;simple SELECT&lt;/a&gt; statements may be connected together to form a compound SELECT using the UNION, UNION ALL, INTERSECT or EXCEPT operator, as shown by the following diagram:</source>
          <target state="translated">다음 다이어그램과 같이 UNION, UNION ALL, INTERSECT 또는 EXCEPT 연산자를 사용하여 두 개 이상의 &lt;a href=&quot;lang_select#simpleselect&quot;&gt;간단한 SELECT&lt;/a&gt; 문을 함께 연결하여 복합 SELECT를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b49920fdd4ad177f1ffaae1df0f25051b8256c94" translate="yes" xml:space="preserve">
          <source>Two or more MATCH operators are allowed in the same WHERE clause, as long as they are connected by AND operators. However, the R*Tree query engine only contains a single priority queue. The priority assigned to each node in the search is the lowest priority returned by any of the MATCH operators.</source>
          <target state="translated">AND 연산자로 연결되어있는 한 동일한 WHERE 절에 둘 이상의 MATCH 연산자가 허용됩니다. 그러나 R * Tree 쿼리 엔진에는 단일 우선 순위 큐만 포함됩니다. 검색에서 각 노드에 지정된 우선 순위는 MATCH 연산자가 리턴 한 가장 낮은 우선 순위입니다.</target>
        </trans-unit>
        <trans-unit id="b719bd70cf2f4781f7a548062aa93163c0a6f5e6" translate="yes" xml:space="preserve">
          <source>Two or more changeset/patchsets may be combined using the &lt;a href=&quot;session/sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;session/changegroup&quot;&gt;sqlite3_changegroup&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; 또는 &lt;a href=&quot;session/changegroup&quot;&gt;sqlite3_changegroup&lt;/a&gt; 인터페이스를 사용하여 둘 이상의 변경 세트 / 패치 세트를 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9c4d063752347abc5d77d07399a38265fd22861" translate="yes" xml:space="preserve">
          <source>Two or more phrases may be grouped into a &lt;b&gt;NEAR group&lt;/b&gt;. A NEAR group is specified by the token &quot;NEAR&quot; (case sensitive) followed by an open parenthesis character, followed by two or more whitespace separated phrases, optionally followed by a comma and the numeric parameter</source>
          <target state="translated">두 개 이상의 문구가 &lt;b&gt;NEAR 그룹&lt;/b&gt; 으로 그룹화 될 수 있습니다 . NEAR 그룹은 토큰 &quot;NEAR&quot;(대소 문자 구분), 괄호로 묶은 공백 문자, 두 개 이상의 공백으로 구분 된 구문, 선택적으로 쉼표 및 숫자 매개 변수로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0284a3abf0fb32119d7d4eb4f9b488143f92f251" translate="yes" xml:space="preserve">
          <source>Two other very minor bug fixes</source>
          <target state="translated">다른 두 가지 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="439961cdf4c53f5e47fc6a54c26c745e60b3c545" translate="yes" xml:space="preserve">
          <source>Two row values are compared by looking at the constituent scalar values from left to right. A NULL means of &quot;unknown&quot;. The overall result of comparison is NULL if it is possible to make the result either true or false by substituting alternative values in place of the constituent NULLs. The following query demonstrates some row value comparisons:</source>
          <target state="translated">구성 스칼라 값을 왼쪽에서 오른쪽으로보고 두 개의 행 값을 비교합니다. NULL은 &quot;알 수 없음&quot;을 의미합니다. 구성 NULL 대신 대체 값을 대체하여 결과를 true 또는 false로 만들 수있는 경우 전체 비교 결과는 NULL입니다. 다음 쿼리는 일부 행 값 비교를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ce050ac4e33af964af82beb0e5b3e0ce52ab58e9" translate="yes" xml:space="preserve">
          <source>Two row values of the same size can be compared using operators &amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=, =, &amp;lt;&amp;gt;, IS, IS NOT, IN, NOT IN, BETWEEN, or CASE.</source>
          <target state="translated">연산자 &amp;lt;, &amp;lt;=,&amp;gt;,&amp;gt; =, =, &amp;lt;&amp;gt;, IS, IS NOT, IN, NOT IN, BETWEEN 또는 CASE를 사용하여 동일한 크기의 두 행 값을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
