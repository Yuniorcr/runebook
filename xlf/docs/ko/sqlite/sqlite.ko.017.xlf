<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="4fe1d3a13dd63ed4836e434d893dc270763cfe84" translate="yes" xml:space="preserve">
          <source>The release checklist is continuously evolving. As new problems or potential problems are discovered, new checklist items are added to make sure those problems do not appear in subsequent releases. The release checklist has proven to be an invaluable tool in helping to ensure that nothing is overlooked during the release process.</source>
          <target state="translated">릴리스 체크리스트는 지속적으로 발전하고 있습니다. 새로운 문제 나 잠재적 인 문제가 발견되면 새로운 점검 목록 항목이 추가되어 이후 릴리스에서 해당 문제가 나타나지 않도록합니다. 릴리스 체크리스트는 릴리스 프로세스 중에 간과되는 것이 없는지 확인하는 데 유용한 도구로 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="54fb9bcb3273ff541df78c3b4ae7a5c1d95caf43" translate="yes" xml:space="preserve">
          <source>The release checklist is not automated: developers run each item on the checklist manually. We find that it is important to keep a human in the loop. Sometimes problems are found while running a checklist item even though the test itself passed. It is important to have a human reviewing the test output at the highest level, and constantly asking &quot;Is this really right?&quot;</source>
          <target state="translated">릴리스 체크리스트는 자동화되지 않습니다. 개발자는 체크리스트의 각 항목을 수동으로 실행합니다. 우리는 인간을 반복적으로 유지하는 것이 중요하다는 것을 알게되었습니다. 테스트 자체가 통과되었지만 검사 목록 항목을 실행하는 동안 문제가 발견되는 경우가 있습니다. 인간이 테스트 결과를 가장 높은 수준으로 검토하고 지속적으로 &quot;정말입니까?&quot;라고 묻는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2c9d643524e4e559789769fa0d9c05fd5ba6364a" translate="yes" xml:space="preserve">
          <source>The relevancy of a document may depend on something other than just the data available in the return value of matchinfo. For example each document in the database may be assigned a static weight based on factors unrelated to its content (origin, author, age, number of references etc.). These values can be stored by the application in a separate table that can be joined against the documents table in the sub-query so that the rank function may access them.</source>
          <target state="translated">문서의 관련성은 matchinfo의 반환 값에서 사용 가능한 데이터 이외의 다른 것에 의존 할 수 있습니다. 예를 들어, 데이터베이스의 각 문서에는 내용과 관련없는 요소 (원본, 저자, 나이, 참조 수 등)를 기반으로 정적 가중치가 할당 될 수 있습니다. 이러한 값은 응용 프로그램에 의해 별도의 테이블에 저장되어 하위 쿼리의 문서 테이블과 조인 될 수 있으므로 순위 함수가 해당 테이블에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03714ee4fa95f4e8679f472e2f3c59cc9a47883" translate="yes" xml:space="preserve">
          <source>The reliability and robustness of SQLite is achieved in part by thorough and careful testing.</source>
          <target state="translated">SQLite의 신뢰성과 견고성은 부분적이고 철저한 테스트를 통해 달성됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3157bd64ab9a637ba9a36bada2711bd2147294" translate="yes" xml:space="preserve">
          <source>The remainder of this document will guide the reader through the steps needed to maintain a private branch. The general idea is the same as outlined above. This section merely provides more detail.</source>
          <target state="translated">이 문서의 나머지 부분에서는 독자가 개인 브랜치를 유지 관리하는 데 필요한 단계를 안내합니다. 일반적인 아이디어는 위에서 설명한 것과 같습니다. 이 섹션은 더 자세한 내용 만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="30a538553e382aa8cfb9498b6fd827480cf2d80b" translate="yes" xml:space="preserve">
          <source>The remaining fields of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object all store pointers to functions that implement primitive operations. We call these &quot;methods&quot;. The first method, xOpen, is used to open files on the underlying storage media. The result is an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. There are additional methods, defined by the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object itself that are used to read and write and close the file. The additional methods are detailed below. The filename is in UTF-8. SQLite will guarantee that the zFilename string passed to xOpen() is a full pathname as generated by xFullPathname() and that the string will be valid and unchanged until xClose() is called. So the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; can store a pointer to the filename if it needs to remember the filename for some reason. The flags argument to xOpen() is a copy of the flags argument to sqlite3_open_v2(). If sqlite3_open() or sqlite3_open16() is used, then flags is &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt;. If xOpen() opens a file read-only then it sets *pOutFlags to include &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt;. Other bits in *pOutFlags may be set. SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 나머지 필드는 모두 기본 작업을 구현하는 함수에 대한 포인터를 저장합니다. 우리는 이것을 &quot;방법&quot;이라고 부릅니다. 첫 번째 방법 인 xOpen은 기본 스토리지 미디어에서 파일을 여는 데 사용됩니다. 결과는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체입니다. 파일을 읽고 쓰고 닫는 데 사용되는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체 자체에 의해 정의 된 추가 방법 이 있습니다. 추가 방법은 아래에 자세히 설명되어 있습니다. 파일 이름은 UTF-8입니다. SQLite는 xOpen ()에 전달 된 zFilename 문자열이 xFullPathname ()에 의해 생성 된 전체 경로 이름이며 xClose ()가 호출 될 때까지 문자열이 유효하고 변경되지 않음을 보증합니다. 그래서 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt;어떤 이유로 파일 이름을 기억 해야하는 경우 파일 이름에 대한 포인터를 저장할 수 있습니다. xOpen ()에 대한 flags 인자는 sqlite3_open_v2 ()에 대한 flags 인자의 복사본입니다. sqlite3_open () 또는 sqlite3_open16 ()이 사용되면 플래그는 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READWRITE&lt;/a&gt; | &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_CREATE&lt;/a&gt; . XOPEN ()가 열리면 파일은 읽기 전용 다음은 설정 * pOutFlags를 포함 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_READONLY&lt;/a&gt; . * pOutFlags의 다른 비트가 설정 될 수 있습니다. SQLite는 열린 객체에 따라 xOpen () 호출에 다음 플래그 중 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="75ee3ed9cd8aa1cdca7e660d366395ab9cdd104b" translate="yes" xml:space="preserve">
          <source>The remaining seven methods defined by this structure (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld and xMutexNotheld) implement the following interfaces (respectively):</source>
          <target state="translated">이 구조로 정의 된 나머지 7 가지 메소드 (xMutexAlloc, xMutexFree, xMutexEnter, xMutexTry, xMutexLeave, xMutexHeld 및 xMutexNotheld)는 다음과 같은 인터페이스를 각각 구현합니다.</target>
        </trans-unit>
        <trans-unit id="01d5ccb02fb58f9483b8bb4a6c89788e5e99328d" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option is not supported.</source>
          <target state="translated">remove_diacritics 옵션은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5dc3bfc4e2330eb1c8eb7d47b9e9b34b4b7effb1" translate="yes" xml:space="preserve">
          <source>The remove_diacritics option may be set to &quot;0&quot;, &quot;1&quot; or &quot;2&quot;. The default value is &quot;1&quot;. If it is set to &quot;1&quot; or &quot;2&quot;, then diacritics are removed from Latin script characters as described above. However, if it is set to &quot;1&quot;, then diacritics are not removed in the fairly uncommon case where a single unicode codepoint is used to represent a character with more that one diacritic. For example, diacritics are not removed from codepoint 0x1ED9 (&quot;LATIN SMALL LETTER O WITH CIRCUMFLEX AND DOT BELOW&quot;). This is technically a bug, but cannot be fixed without creating backwards compatibility problems. If this option is set to &quot;2&quot;, then diacritics are correctly removed from all Latin characters.</source>
          <target state="translated">remove_diacritics 옵션은 &quot;0&quot;, &quot;1&quot;또는 &quot;2&quot;로 설정 될 수 있습니다. 기본값은 &quot;1&quot;입니다. &quot;1&quot;또는 &quot;2&quot;로 설정되면 위에서 설명한대로 분음 부호가 라틴어 스크립트 문자에서 제거됩니다. 그러나 &quot;1&quot;로 설정하면 하나의 유니 코드 코드 포인트가 하나 이상의 분음 부호를 갖는 문자를 나타내는 데 사용되는 드문 경우에 분음 부호가 제거되지 않습니다. 예를 들어 분음 부호는 코드 포인트 0x1ED9에서 제거되지 않습니다 ( &quot;CIRCUMFLEX와 DOT 아래의 라틴 문자가 너무 작음&quot;). 이것은 기술적으로 버그이지만 이전 버전과의 호환성 문제를 일으키지 않으면 해결할 수 없습니다. 이 옵션을 &quot;2&quot;로 설정하면 분음 부호가 모든 라틴 문자에서 올바르게 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e878b1555960f1149f69c44e721edf9e3c3726dd" translate="yes" xml:space="preserve">
          <source>The replace(X,Y,Z) function returns a string formed by substituting string Z for every occurrence of string Y in string X. The &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collating sequence is used for comparisons. If Y is an empty string then return X unchanged. If Z is not initially a string, it is cast to a UTF-8 string prior to processing.</source>
          <target state="translated">replace (X, Y, Z) 함수는 문자열 X에서 문자열 Y가 &lt;a href=&quot;datatype3#collation&quot;&gt;나타날&lt;/a&gt; 때마다 문자열 Z를 대체하여 구성된 문자열을 반환합니다. BINARY 조합 시퀀스는 비교에 사용됩니다. Y가 빈 문자열이면 X를 변경하지 않고 반환합니다. Z가 처음에 문자열이 아닌 경우 처리 전에 UTF-8 문자열로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="7d84cb3d97dd720ff83b043f47169f048a42ed9d" translate="yes" xml:space="preserve">
          <source>The repository created in the previous step is initially empty. The next step is to load the baseline SQLite release - circle (1) in the diagram above.</source>
          <target state="translated">이전 단계에서 작성된 저장소는 처음에 비어 있습니다. 다음 단계는 위의 다이어그램에서 기준선 SQLite 릴리스-원 (1)을로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="10c2d611bbd1154503c3d2f589b7893620f36217" translate="yes" xml:space="preserve">
          <source>The reserved region is an area of unused space at the end of every page (except the locking page) that extensions can use to hold per-page information. The size of the reserved region is determined by the one-byte unsigned integer found at an offset of 20 into the database file header. The size of the reserved region is usually zero.</source>
          <target state="translated">예약 된 영역은 확장 프로그램이 페이지 별 정보를 보유하는 데 사용할 수있는 모든 페이지 끝에있는 사용되지 않은 공간 영역입니다 (잠금 페이지 제외). 예약 영역의 크기는 데이터베이스 파일 헤더에서 20의 오프셋에서 발견 된 1 바이트 부호없는 정수에 의해 결정됩니다. 예약 영역의 크기는 일반적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="5406b5dfde9f00d0738ba2c75a1507fa33caf617" translate="yes" xml:space="preserve">
          <source>The reserved region.</source>
          <target state="translated">예약 된 지역</target>
        </trans-unit>
        <trans-unit id="aad9068a01cab0c1ed6f0408e5a3ca43105c9476" translate="yes" xml:space="preserve">
          <source>The response of SQLite to out-of-memory (OOM) errors is tested using a specialized memory allocator overlay that can simulate memory failures. The overlay is a layer that is inserted in between the memory allocator and the rest of SQLite. The overlay passes most memory allocation requests straight through to the underlying allocator and passes the results back up to the requester. But the overlay can be set to cause the Nth memory allocation to fail. To run an OOM test, the overlay is first set to fail on the first allocation attempt. Then some test script is run and verification that the allocation was correctly caught and handled is made. Then the overlay is set to fail on the second allocation and the test repeats. The failure point continues to advance one allocation at a time until the entire test procedure runs to completion without hitting a memory allocation error. This whole test sequence run twice. On the first pass, the overlay is set to fail only the Nth allocation. On the second pass, the overlay is set to fail the Nth and all subsequent allocations.</source>
          <target state="translated">메모리 부족 (OOM) 오류에 대한 SQLite의 응답은 메모리 장애를 시뮬레이션 할 수있는 특수 메모리 할당 기 오버레이를 사용하여 테스트됩니다. 오버레이는 메모리 할당 자와 나머지 SQLite 사이에 삽입되는 레이어입니다. 오버레이는 대부분의 메모리 할당 요청을 기본 할당 자로 직접 전달하고 결과를 요청자에게 다시 전달합니다. 그러나 N 번째 메모리 할당이 실패하도록 오버레이를 설정할 수 있습니다. OOM 테스트를 실행하기 위해 첫 번째 할당 시도에서 오버레이가 먼저 실패하도록 설정됩니다. 그런 다음 일부 테스트 스크립트가 실행되고 할당이 올바르게 포착되고 처리되었는지 확인합니다. 그런 다음 두 번째 할당에서 오버레이가 실패하도록 설정되고 테스트가 반복됩니다.메모리 할당 오류가 발생하지 않고 전체 테스트 절차가 완료 될 때까지 실패 지점이 한 번에 한 번의 할당으로 계속 진행됩니다. 이 전체 테스트 순서는 두 번 실행됩니다. 첫 번째 패스에서 오버레이는 N 번째 할당 만 실패하도록 설정됩니다. 두 번째 패스에서 오버레이는 N 번째 및 모든 후속 할당에 실패하도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="12691a5bbec67aa65e24fe31d2477402bd3c4199" translate="yes" xml:space="preserve">
          <source>The rest of the module structure consists of methods used to implement various features of the virtual table. Details on what each of these methods do are provided in the sequel.</source>
          <target state="translated">나머지 모듈 구조는 가상 테이블의 다양한 기능을 구현하는 데 사용되는 메소드로 구성됩니다. 이러한 각 방법이 수행하는 작업에 대한 자세한 내용은 후속편에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4c062c28bf53cd1153a7f659fc941fb25e4394ee" translate="yes" xml:space="preserve">
          <source>The result column names generated for compound subqueries have been simplified to show only the name of the column of the original table and omit the table name. This makes SQLite operate more like other SQL database engines.</source>
          <target state="translated">복합 서브 쿼리에 대해 생성 된 결과 컬럼 이름은 원래 테이블의 컬럼 이름 만 표시하고 테이블 이름을 생략하도록 단순화되었습니다. 이를 통해 SQLite는 다른 SQL 데이터베이스 엔진처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8fba3a08c8f1c5c3b4c188d84f260675274f7bae" translate="yes" xml:space="preserve">
          <source>The result of &quot;(1,2,3)=(1,NULL,3)&quot; is NULL because the result might be true if we replaced NULL&amp;rarr;2 or false if we replaced NULL&amp;rarr;9. The result of &quot;(1,2,3)=(1,NULL,4)&quot; is not NULL because there is no substitutions of the constituent NULL that will make the expression true, since 3 will never equal 4 in the third column.</source>
          <target state="translated">&quot;(1,2,3) = (1, NULL, 3)&quot;의 결과는 NULL입니다. NULL &amp;rarr; 2를 대체하면 결과가 true이고 NULL &amp;rarr; 9를 대체하면 false입니다. &quot;(1,2,3) = (1, NULL, 4)&quot;의 결과는 NULL이 아닙니다. 3 번째 열에서 3은 절대로 4가 아니기 때문에 식을 true로 만드는 구성 요소 NULL을 대체하지 않기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8f8beef2187bafe894f67b36f4b351c6bf0083c2" translate="yes" xml:space="preserve">
          <source>The result of an IN or NOT IN operator is determined by the following matrix:</source>
          <target state="translated">IN 또는 NOT IN 연산자의 결과는 다음 매트릭스에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="61365ffa3c163a280c658c5edf1eb2a5c12ca346" translate="yes" xml:space="preserve">
          <source>The result of any binary operator is either a numeric value or NULL, except for the</source>
          <target state="translated">이항 연산자의 결과는 숫자 값이거나 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="efe84f22635d66f10495dd8d63c09814ab5f5a9a" translate="yes" xml:space="preserve">
          <source>The result of combining all input changesets together is obtained by the application via a call to sqlite3changegroup_output().</source>
          <target state="translated">모든 입력 변경 세트를 함께 결합한 결과는 sqlite3changegroup_output ()에 대한 호출을 통해 애플리케이션에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bf374835b6b23f4254068862fbe80fd36859e25a" translate="yes" xml:space="preserve">
          <source>The result of opening a file is an instance of an &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. The &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is an abstract base class defined as follows:</source>
          <target state="translated">파일을 연 결과는 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체 의 인스턴스입니다 . &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file에&lt;/a&gt; 다음과 같이 객체는 추상 기본 클래스 정의된다 :</target>
        </trans-unit>
        <trans-unit id="8384d1099fcb8eaa40cfc52c9ccfbf281fc795df" translate="yes" xml:space="preserve">
          <source>The result of the compound select is sent to the callback routine by the loop at instructions 22 through 25. There is nothing new or remarkable about this loop, except for the fact that the Column instruction at 23 will be extracting a column out of the record key rather than the record data.</source>
          <target state="translated">복합 선택의 결과는 명령 22에서 25까지의 루프에 의해 콜백 루틴으로 전송됩니다. 23의 열 명령이 레코드에서 열을 추출한다는 사실을 제외하고는이 루프에 대해 새롭거나 주목할만한 것이 없습니다. 레코드 데이터보다는 키.</target>
        </trans-unit>
        <trans-unit id="a2285b0635d880f7a2485fe902caef319bce2b4f" translate="yes" xml:space="preserve">
          <source>The result of this last example should be every unique value of the &quot;two&quot; column in the examp table, except any value that is in the &quot;four&quot; column of examp2 is removed. The code to implement this query is as follows:</source>
          <target state="translated">마지막 예의 결과는 examp2의 &quot;4&quot;열에있는 값이 제거되는 것을 제외하고 examp 테이블의 &quot;2&quot;열의 모든 고유 값이어야합니다. 이 쿼리를 구현하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ccf7a73ae578c847fadf3966512c178de5c0acda" translate="yes" xml:space="preserve">
          <source>The result of total() is always a floating point value. The result of sum() is an integer value if all non-NULL inputs are integers. If any input to sum() is neither an integer or a NULL then sum() returns a floating point value which might be an approximation to the true sum.</source>
          <target state="translated">total ()의 결과는 항상 부동 소수점 값입니다. NULL이 아닌 모든 입력이 정수인 경우 sum ()의 결과는 정수 값입니다. sum ()에 대한 입력이 정수 또는 NULL이 아닌 경우 sum ()은 부동 소수점 값을 리턴하며 이는 실제 합계에 대한 근사치 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3501cb60eee256e312e1519991e5a4a97f468bc9" translate="yes" xml:space="preserve">
          <source>The result shown above (0.0000011126) is the correct answer. But if you do this computation using binary64 floating-point, the answer you get is 0.00000095367431640625 - an error of about 14%. If you do many similar computations as part of your program, the errors add up so that your final result might be completely meaningless.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a6fa042949920d8ab9a65592e82f3922c405d35" translate="yes" xml:space="preserve">
          <source>The resulting &quot;sqlite3.c&quot; amalgamation code file (and its associated header file &quot;sqlite3.h&quot;) can then be moved to a non-unix platform for final compilation using a native compiler.</source>
          <target state="translated">결과 &quot;sqlite3.c&quot;통합 코드 파일 (및 관련 헤더 파일 &quot;sqlite3.h&quot;)은 기본 컴파일러를 사용하여 최종 컴파일을 위해 비 유닉스 플랫폼으로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2d2e1926aa6ddaac2f60d9749f53fb11268ec2a" translate="yes" xml:space="preserve">
          <source>The results of a comparison depend on the storage classes of the operands, according to the following rules:</source>
          <target state="translated">비교 결과는 다음 규칙에 따라 피연산자의 스토리지 클래스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="32d9d0342a63956078e67d37802198109f0decfd" translate="yes" xml:space="preserve">
          <source>The results presented here come with the following caveats:</source>
          <target state="translated">여기에 제시된 결과에는 다음과 같은 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aa6d6ab54b80d454b7163f11aaed1a126d7a246" translate="yes" xml:space="preserve">
          <source>The return value from both sqlite3_soft_heap_limit64() and sqlite3_hard_heap_limit64() is the size of the heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the heap limit. Hence, the current size of heap limits can be determined by invoking sqlite3_soft_heap_limit64(-1) or sqlite3_hard_heap_limit(-1).</source>
          <target state="translated">sqlite3_soft_heap_limit64 () 및 sqlite3_hard_heap_limit64 () 모두의 반환 값은 호출 이전의 힙 제한 크기이거나 오류가있는 경우 음수입니다. 인수 N이 음수이면 힙 한계가 변경되지 않습니다. 따라서 현재 힙 제한 크기는 sqlite3_soft_heap_limit64 (-1) 또는 sqlite3_hard_heap_limit (-1)을 호출하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9310ef8309cce9fab8d7528f6f21efe5cbb34c7" translate="yes" xml:space="preserve">
          <source>The return value from sqlite3_soft_heap_limit64() is the size of the soft heap limit prior to the call, or negative in the case of an error. If the argument N is negative then no change is made to the soft heap limit. Hence, the current size of the soft heap limit can be determined by invoking sqlite3_soft_heap_limit64() with a negative argument.</source>
          <target state="translated">sqlite3_soft_heap_limit64 ()의 반환 값은 호출 전의 소프트 힙 제한 크기이거나 오류의 경우 음수입니다. 인수 N이 음수이면 소프트 힙 한계가 변경되지 않습니다. 따라서 소프트 힙 제한의 현재 크기는 sqlite3_soft_heap_limit64 ()를 음수 인수로 호출하여 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca53c6554299d5eae8ef584802645a6046ae33" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the indirect flag: 0 if it is clear, or 1 if it is set.</source>
          <target state="translated">리턴 값은 간접 플래그의 최종 상태를 나타냅니다. 지워지면 0, 설정되어 있으면 1입니다.</target>
        </trans-unit>
        <trans-unit id="7ce2179f1a4d84a59cb420b693cc86ea07338afc" translate="yes" xml:space="preserve">
          <source>The return value indicates the final state of the session object: 0 if the session is disabled, or 1 if it is enabled.</source>
          <target state="translated">리턴 값은 세션 오브젝트의 최종 상태를 나타냅니다. 세션이 사용 불가능하면 0, 사용 가능하면 1</target>
        </trans-unit>
        <trans-unit id="cae4bd57ed056db33a88f07df4b39cc7f3ccb51d" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface is determined by the compile-time threading mode selection. If single-thread mode is selected at compile-time, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns false. If either the multi-thread or serialized modes are selected, then &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returns true. The &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface predates the multi-thread mode and start-time and run-time mode selection and so is unable to distinguish between multi-thread and serialized mode nor is it able to report start-time or run-time mode changes.</source>
          <target state="translated">&lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스 의 반환 값은 컴파일 타임 스레딩 모드 선택에 의해 결정됩니다. 컴파일 타임에 단일 스레드 모드를 선택하면 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 가 false를 반환합니다. 다중 스레드 또는 직렬 모드를 선택하면 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 가 true를 반환합니다. &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스는 시작 시간 또는 런타임 모드 변경 사항을보고 할 수있는 멀티 스레드 모드를 선행하고 시작 시간과 런타임 모드 선택 등 멀티 스레드 및 직렬화 모드도 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="39d80cd93bcac1fdb374e9a2b5c0dd95b400a1d6" translate="yes" xml:space="preserve">
          <source>The return value of the &lt;b&gt;sqlite_open&lt;/b&gt; function is a pointer to an opaque &lt;b&gt;sqlite&lt;/b&gt; structure. This pointer will be the first argument to all subsequent SQLite function calls that deal with the same database. NULL is returned if the open fails for any reason.</source>
          <target state="translated">&lt;b&gt;sqlite_open&lt;/b&gt; 함수 의 반환 값은 불투명 한 &lt;b&gt;sqlite&lt;/b&gt; 구조에 대한 포인터 입니다. 이 포인터는 동일한 데이터베이스를 처리하는 모든 후속 SQLite 함수 호출에 대한 첫 번째 인수입니다. 어떤 이유로 든 열기에 실패하면 NULL이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6ab6c5924ac478fb10f4cbca37723d1a21ffdbb3" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">리턴 된 문자열 포인터는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()에&lt;/a&gt; 의해 삭제 되거나 특정 실행에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 다음에 sqlite3_column_name () 또는 sqlite3_column_name16 ()에 대한 다음 호출까지 자동으로 다시 준비 될 때까지 유효 합니다. 같은 열.</target>
        </trans-unit>
        <trans-unit id="b378f46326a64f9ce7b892670372ed936b24e5cc" translate="yes" xml:space="preserve">
          <source>The returned string pointer is valid until either the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed by &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the next call to sqlite3_column_name() or sqlite3_column_name16() on the same column.</source>
          <target state="translated">리턴 된 문자열 포인터는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()에&lt;/a&gt; 의해 삭제 되거나 특정 실행에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 다음에 sqlite3_column_name () 또는 sqlite3_column_name16 ()에 대한 다음 호출까지 자동으로 다시 준비 될 때까지 유효 합니다. 같은 열.</target>
        </trans-unit>
        <trans-unit id="bee83cce7953088554432a61ef6e85ee98f1b384" translate="yes" xml:space="preserve">
          <source>The rewritten expression above is conceptual; WHERE clauses containing OR are not really rewritten this way. The actual implementation of the OR clause uses a mechanism that is more efficient and that works even for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or tables in which the &quot;rowid&quot; is inaccessible. But the essence of the implementation is captured by the statement above: Separate indices are used to find candidate result rows from each OR clause term and the final result is the union of those rows.</source>
          <target state="translated">위에서 다시 작성된 표현은 개념입니다. OR가 포함 된 WHERE 절은 실제로이 방법으로 다시 작성되지 않습니다. OR 절의 실제 구현은 더 효율적이고 &quot;rowid&quot;에 액세스 할 수없는 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 또는 테이블에 대해서도 작동하는 메커니즘을 사용합니다 . 그러나 구현의 본질은 위의 진술에 의해 포착됩니다. 각 OR 절 용어에서 후보 결과 행을 찾는 데 별도의 인덱스가 사용되며 최종 결과는 해당 행의 합집합입니다.</target>
        </trans-unit>
        <trans-unit id="1bd2a272126ae7fe0bcc8e6d37c8017e55bcc2f1" translate="yes" xml:space="preserve">
          <source>The rewritten term then might go on to constrain an index using the normal rules for *IN* operators. Note that</source>
          <target state="translated">다시 작성된 용어는 * IN * 연산자에 대한 일반 규칙을 사용하여 색인을 제한하기 위해 계속 될 수 있습니다. 참고</target>
        </trans-unit>
        <trans-unit id="d0930df338a07de9990756603662657ba4f08d89" translate="yes" xml:space="preserve">
          <source>The right-hand operand of an IN or NOT IN operator has no affinity if the operand is a list and has the same affinity as the affinity of the result set expression if the operand is a SELECT.</source>
          <target state="translated">IN 또는 NOT IN 연산자의 오른쪽 피연산자는 피연산자가 목록 인 경우 선호도가없고 피연산자가 SELECT 인 경우 결과 세트 표현식의 선호도와 동일한 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="066626c86d12ae463e5bc63db194f29a635a8420" translate="yes" xml:space="preserve">
          <source>The right-hand side of the IN operator can now be a list of expressions instead of just a list of constants</source>
          <target state="translated">IN 연산자의 오른쪽은 상수 목록 대신 표현식 목록이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c40f29b907e12e70ce95f7046453c736453580d" translate="yes" xml:space="preserve">
          <source>The right-hand side of the LIKE or GLOB must be either a string literal or a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; bound to a string literal that does not begin with a wildcard character.</source>
          <target state="translated">LIKE 또는 GLOB의 오른쪽은 문자열 리터럴이거나 와일드 카드 문자로 시작하지 않는 문자열 리터럴에 바인드 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b4246dd614eb68d70df4434b2497d819d23353bb" translate="yes" xml:space="preserve">
          <source>The right-hand table of the LEFT JOIN is not be used anywhere in the query outside of its own USING or ON clause.</source>
          <target state="translated">LEFT JOIN의 오른쪽 테이블은 자체 USING 또는 ON 절 이외의 쿼리에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fc3dd2572b5bfa090299b30f5d81e58803cff0cb" translate="yes" xml:space="preserve">
          <source>The right-hand-side of the MATCH or = operator must be a constant expression that evaluates to a string consisting of the auxiliary function to invoke, followed by zero or more comma separated arguments within parenthesis. Arguments must be SQL literals. For example:</source>
          <target state="translated">MATCH 또는 = 연산자의 오른쪽은 호출 할 보조 함수로 구성된 문자열로 평가되고 괄호 안에 쉼표로 구분 된 인수가 0 개 이상인 문자열로 평가되는 상수 표현식이어야합니다. 인수는 SQL 리터럴이어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60bf6a0aa9c141c91d3c15f81e63af1fbe6058ec" translate="yes" xml:space="preserve">
          <source>The right-most SELECT of the compound select must not make use of &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt; or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;.</source>
          <target state="translated">복합 선택의 가장 오른쪽 SELECT는 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계&lt;/a&gt; 또는 &lt;a href=&quot;windowfunctions&quot;&gt;창 함수를&lt;/a&gt; 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b1ae3c5986255800fb2859410b2b4acb04d2122" translate="yes" xml:space="preserve">
          <source>The rollback journal contains a small header (shown in green in the diagram) that records the original size of the database file. So if a change causes the database file to grow, we will still know the original size of the database. The page number is stored together with each database page that is written into the rollback journal.</source>
          <target state="translated">롤백 저널에는 데이터베이스 파일의 원래 크기를 기록하는 작은 헤더 (다이어그램에서 녹색으로 표시)가 있습니다. 따라서 변경으로 인해 데이터베이스 파일이 커져도 데이터베이스의 원래 크기를 알 수 있습니다. 페이지 번호는 롤백 저널에 기록 된 각 데이터베이스 페이지와 함께 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1c053ab6c700ac534ac79f62078cfd2e255f73f2" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a master journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a master journal, then that master journal file exists.</source>
          <target state="translated">롤백 저널에 마스터 저널 파일의 이름이 없거나 (아래 &lt;a href=&quot;#section_5_5&quot;&gt;섹션 5.5&lt;/a&gt; 참조) 마스터 저널의 이름이있는 경우 해당 마스터 저널 파일이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="070c8fccacf99462797ddd5845e4bd8960ffcf17" translate="yes" xml:space="preserve">
          <source>The rollback journal does not contain the name of a super-journal file (see &lt;a href=&quot;#section_5_5&quot;&gt;section 5.5&lt;/a&gt; below) or if does contain the name of a super-journal, then that super-journal file exists.</source>
          <target state="translated">롤백 저널에는 수퍼 저널 파일의 이름이 포함되어 있지 않거나 (아래 &lt;a href=&quot;#section_5_5&quot;&gt;섹션 5.5&lt;/a&gt; 참조) 수퍼 저널의 이름이 포함되어있는 경우 해당 수퍼 저널 파일이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6e312e9592f38c1d0abcf1823ca656ae6dc24729" translate="yes" xml:space="preserve">
          <source>The rollback journal exists.</source>
          <target state="translated">롤백 저널이 존재합니다.</target>
        </trans-unit>
        <trans-unit id="a6a9ff12c8273f443fb56b2bd7d0ab6853333cef" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be deleted,</source>
          <target state="translated">롤백 저널 파일을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="841baedc01f54f9ab6f694a5b23bcc695e5f21f1" translate="yes" xml:space="preserve">
          <source>The rollback journal file can be truncated to zero length, or</source>
          <target state="translated">롤백 저널 파일을 길이가 0으로 잘 리거나</target>
        </trans-unit>
        <trans-unit id="31415ebe9f384149b021a50dd2fb2ee645763262" translate="yes" xml:space="preserve">
          <source>The rollback journal is</source>
          <target state="translated">롤백 저널은</target>
        </trans-unit>
        <trans-unit id="08afad671df0d2c575466e5f9fe1a518b69a6c6b" translate="yes" xml:space="preserve">
          <source>The rollback journal is a file associated with each SQLite database file that holds information used to restore the database file to its initial state during the course of a transaction. The rollback journal file is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-journal&lt;/code&gt;&quot; appended. There can only be a single rollback journal associated with a give database and hence there can only be one write transaction open against a single database at one time.</source>
          <target state="translated">롤백 저널은 트랜잭션 중에 데이터베이스 파일을 초기 상태로 복원하는 데 사용되는 정보를 보유하는 각 SQLite 데이터베이스 파일과 연관된 파일입니다. 롤백 저널 파일은 항상 데이터베이스 파일과 동일한 디렉토리에 있으며 데이터베이스 파일과 이름은 동일하지만 문자열 &quot; &lt;code&gt;-journal&lt;/code&gt; &quot;이 추가됩니다. give 데이터베이스와 연관된 단일 롤백 저널 만있을 수 있으므로 한 번에 하나의 데이터베이스에 대해 하나의 쓰기 트랜잭션 만 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a29cd2d15ece2c4c624bfe95a88741dea324ccf" translate="yes" xml:space="preserve">
          <source>The rollback journal is complete and intact on disk when the power is restored. This is a key point. The reason for the flush operation in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; is to make absolutely sure that all of the rollback journal is safely on nonvolatile storage prior to making any changes to the database file itself.</source>
          <target state="translated">전원이 복원되면 롤백 저널이 완료되어 디스크에 그대로 있습니다. 이것이 핵심입니다. &lt;a href=&quot;#section_3_7&quot;&gt;3.7 단계&lt;/a&gt; 에서 플러시 작업을 수행 하는 이유 는 데이터베이스 파일 자체를 변경하기 전에 모든 롤백 저널이 비 휘발성 저장소에 안전하게 있는지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5d1b7832cc643f77f52a69083206bb3b5fc3e74c" translate="yes" xml:space="preserve">
          <source>The rollback journal is not an empty file.</source>
          <target state="translated">롤백 저널이 빈 파일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="194c559058723739212e12d7c3749019f8df5f55" translate="yes" xml:space="preserve">
          <source>The root page numbers of all tables in the database are integers stored in P4_INTARRAY argument.</source>
          <target state="translated">데이터베이스에있는 모든 테이블의 루트 페이지 번호는 P4_INTARRAY 인수에 저장된 정수입니다.</target>
        </trans-unit>
        <trans-unit id="a973ad8403210b9b222fd26c2aef5b8f2808389c" translate="yes" xml:space="preserve">
          <source>The round(X,Y) function returns a floating-point value X rounded to Y digits to the right of the decimal point. If the Y argument is omitted, it is assumed to be 0.</source>
          <target state="translated">round (X, Y) 함수는 소수점 오른쪽에 Y 자리로 반올림 된 부동 소수점 값 X를 반환합니다. Y 인수가 생략되면 0으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5fa12ab6f93c055083bc1a95b917e71f9cff725b" translate="yes" xml:space="preserve">
          <source>The routines &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; accept an SQL statement list (sql-stmt-list) which is a semicolon-separated list of statements.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 루틴 은 세미콜론으로 구분 된 SQL 문 목록 (sql-stmt-list)을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="94230b7f00353328063595629d48ef7be9fce389" translate="yes" xml:space="preserve">
          <source>The row-value notation is useful for updating two or more columns of a table from the result of a single query. An example of this is in the full-text search feature of the &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;.</source>
          <target state="translated">행 값 표기법은 단일 쿼리 결과에서 테이블의 둘 이상의 열을 업데이트하는 데 유용합니다. 이에 대한 예는 &lt;a href=&quot;https://www.fossil-scm.org/&quot;&gt;Fossil 버전 제어 시스템&lt;/a&gt; 의 전체 텍스트 검색 기능에 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12b6af8126e4e3b962d71bf35b72e9a66ab6fcba" translate="yes" xml:space="preserve">
          <source>The row_number() of the first peer in each group - the rank of the current row with gaps. If there is no ORDER BY clause, then all rows are considered peers and this function always returns 1.</source>
          <target state="translated">각 그룹에서 첫 번째 피어의 row_number ()-공백이있는 현재 행의 순위입니다. ORDER BY 절이 없으면 모든 행이 피어로 간주되며이 함수는 항상 1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d3978e13ae998834400769bcf87213e9a57acdbe" translate="yes" xml:space="preserve">
          <source>The row_number() window function assigns consecutive integers to each row in order of the &quot;ORDER BY&quot; clause within the window-defn (in this case &quot;ORDER BY y&quot;). Note that this does not affect the order in which results are returned from the overall query. The order of the final output is still governed by the ORDER BY clause attached to the SELECT statement (in this case &quot;ORDER BY x&quot;).</source>
          <target state="translated">row_number () 창 함수는 window-defn (이 경우 &quot;ORDER BY y&quot;) 내의 &quot;ORDER BY&quot;절 순서로 각 행에 연속 정수를 할당합니다. 이는 전체 쿼리에서 결과가 반환되는 순서에 영향을주지 않습니다. 최종 출력 순서는 여전히 SELECT 문에 첨부 된 ORDER BY 절 (이 경우 &quot;ORDER BY x&quot;)에 의해 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="97fcd9de22c4efb0eb648cf609eba1ee3fdf411d" translate="yes" xml:space="preserve">
          <source>The rowid (and &quot;oid&quot; and &quot;_rowid_&quot;) is omitted in &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. WITHOUT ROWID tables are only available in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) and later. A table that lacks the WITHOUT ROWID clause is called a &quot;rowid table&quot;.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에서는 rowid (및 &quot;oid&quot;및 &quot;_rowid_&quot;)가 생략됩니다 . WITHOUT ROWID 테이블은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;버전 3.8.2&lt;/a&gt; (2013-12-06) 이상 에서만 사용 가능 합니다. WITHOUT ROWID 절이없는 테이블을 &quot;행 테이블&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a4a453c67097537d0d10c4b81190fd5d03a4b9dd" translate="yes" xml:space="preserve">
          <source>The rowid column is not accessible on a WITHOUT ROWID virtual table (of course).</source>
          <target state="translated">물론 WITHOUT ROWID 가상 테이블에서 rowid 열에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="101d05f0746854eb07065f446e80313cdc7692a7" translate="yes" xml:space="preserve">
          <source>The rowid of the document that contains the term instance.</source>
          <target state="translated">용어 인스턴스를 포함하는 문서의 rowid</target>
        </trans-unit>
        <trans-unit id="21037157130833680d029f7ec56534a7a85bda67" translate="yes" xml:space="preserve">
          <source>The rowid of the row in the table being changed</source>
          <target state="translated">변경되는 테이블에서 행의 rowid</target>
        </trans-unit>
        <trans-unit id="4967842a66478a8da76fb91a725d0ca4385c40a8" translate="yes" xml:space="preserve">
          <source>The rtreecheck() function performs the following checks:</source>
          <target state="translated">rtreecheck () 함수는 다음 검사를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="93e10cfe1c883491ee9016750849300312683ba1" translate="yes" xml:space="preserve">
          <source>The rtrim(X,Y) function returns a string formed by removing any and all characters that appear in Y from the right side of X. If the Y argument is omitted, rtrim(X) removes spaces from the right side of X.</source>
          <target state="translated">rtrim (X, Y) 함수는 X의 오른쪽에서 Y에 나타나는 모든 문자를 제거하여 형성된 문자열을 반환합니다. Y 인수가 생략되면 rtrim (X)는 X의 오른쪽에서 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="46ff031bad92aa35bcef2484317fc2661aa2d589" translate="yes" xml:space="preserve">
          <source>The rule above says that the letter &quot;a&quot; in user input can be matched against the letter &quot;&amp;auml;&quot; in the dictionary with a penalty of 5.</source>
          <target state="translated">위의 규칙에 따르면 사용자 입력의 문자 &quot;a&quot;는 페널티가 5 인 사전의 문자 &quot;&amp;auml;&quot;와 일치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed3a2c883d263a1e9abd7d6661fda464d09422b3" translate="yes" xml:space="preserve">
          <source>The rules for determining which collating function to use for a binary comparison operator (=, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, !=, IS, and IS NOT) are as follows:</source>
          <target state="translated">이진 비교 연산자에 사용할 조합 함수 (=, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =,! =, IS 및 IS NOT)를 결정하는 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27705c6545cd7b92f01b98bd6ebfb1aa891406e9" translate="yes" xml:space="preserve">
          <source>The rules for when tables are analyzed are likely to change in future releases.</source>
          <target state="translated">테이블이 분석되는시기에 대한 규칙은 향후 릴리스에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="819c15849a2758e415f2520702095eeff7ea13a5" translate="yes" xml:space="preserve">
          <source>The safest and easiest to remember policy is this: assume that any result from</source>
          <target state="translated">가장 안전하고 기억하기 쉬운 정책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bfc94ce3f6dbf06df6c899612d318253dda6014" translate="yes" xml:space="preserve">
          <source>The safest policy is to invoke these routines in one of the following ways:</source>
          <target state="translated">가장 안전한 정책은 다음 방법 중 하나를 사용하여 이러한 루틴을 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="376b573ee029dd7d9463b27b130e605260069a93" translate="yes" xml:space="preserve">
          <source>The salt-1 and salt-2 values in the frame-header match salt values in the wal-header</source>
          <target state="translated">프레임 헤더의 소금 1과 소금 2 값은 월 헤더의 소금 값과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="b0647dc001e4e971c816ce4a73a18b5c698aa62d" translate="yes" xml:space="preserve">
          <source>The same SQL statement will fail on every other SQL implementation that we know of due to the use of keywords &quot;union&quot;, &quot;true&quot;, and &quot;with&quot; as identifiers.</source>
          <target state="translated">키워드 &quot;union&quot;, &quot;true&quot;및 &quot;with&quot;를 식별자로 사용하기 때문에 알고있는 다른 모든 SQL 구현에서 동일한 SQL 문이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="67d39480596a16c7c11f0309e84be58f71d89746" translate="yes" xml:space="preserve">
          <source>The same basic B-Tree format is used but the details of the index keys were changed in order to provide better query optimization opportunities. Some of the headers were also changed in order to increase the maximum size of a row from 64KB to 24MB.</source>
          <target state="translated">동일한 기본 B- 트리 형식이 사용되지만 더 나은 쿼리 최적화 기회를 제공하기 위해 인덱스 키의 세부 사항이 변경되었습니다. 행의 최대 크기를 64KB에서 24MB로 늘리기 위해 일부 헤더도 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="8827fbb3b64d8c27595464e7777bbb4e772df118" translate="yes" xml:space="preserve">
          <source>The same basic algorithm is followed, except this time the matching rows of the index are scanned from bottom to top instead of from top to bottom, so that the states will appear in descending order.</source>
          <target state="translated">동일한 기본 알고리즘을 따릅니다. 이번에는 색인의 일치하는 행이 위에서 아래로가 아니라 아래에서 위로 스캔되어 상태가 내림차순으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef4bb6f50ee96f372f99fa9088d7b9c16950c07" translate="yes" xml:space="preserve">
          <source>The same core string formatter is also used internally by SQLite.</source>
          <target state="translated">동일한 핵심 문자열 포맷터도 SQLite에서 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c76359de67616f16a26e96d68504c135072ade53" translate="yes" xml:space="preserve">
          <source>The same database connection may now be used simultaneously by separate threads.</source>
          <target state="translated">동일한 데이터베이스 연결을 이제 별도의 스레드에서 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bfa6cdc7cb80687d83044e6ab3337ab8d5595b5" translate="yes" xml:space="preserve">
          <source>The same indices are used to speed up every loop in both implementation options. The only difference in these two query plans is the order in which the loops are nested.</source>
          <target state="translated">동일한 인덱스가 두 구현 옵션에서 모든 루프의 속도를 높이는 데 사용됩니다. 이 두 쿼리 계획의 유일한 차이점은 루프가 중첩되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="d1cd4608c87b02b3bc5ed6c81e7bb9ae9c4b8e13" translate="yes" xml:space="preserve">
          <source>The same technique ensures that an SQLite database file cannot be corrupted by a system failure that occurs at an inopportune moment. If a system failure does occur before SQLite has had a chance to execute sufficient</source>
          <target state="translated">동일한 기술을 사용하면 부적절한 순간에 시스템 장애로 인해 SQLite 데이터베이스 파일을 손상시킬 수 없습니다. SQLite가 충분한 실행 기회를 갖기 전에 시스템 장애가 발생한 경우</target>
        </trans-unit>
        <trans-unit id="40cbe38c06ce85b1c49ad0c8414f8f89ac5525ac" translate="yes" xml:space="preserve">
          <source>The same thing can be done with an enterprise client/server database, of course. The advantage of SQLite is that it is easier to install and use and the resulting database is a single file that can be written to a USB memory stick or emailed to a colleague.</source>
          <target state="translated">물론 엔터프라이즈 클라이언트 / 서버 데이터베이스에서도 동일한 작업을 수행 할 수 있습니다. SQLite의 장점은 설치 및 사용이 더 쉽고 결과 데이터베이스는 USB 메모리 스틱에 작성하거나 동료에게 이메일로 보낼 수있는 단일 파일이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9e7d4c0bf312ba2ed4d788d1d81806125454441" translate="yes" xml:space="preserve">
          <source>The scalar SQL function rtreecheck(R) or rtreecheck(S,R) runs an integrity check on the rtree table named R contained within database S. The function returns a human-language description of any problems found, or the string 'ok' if everything is ok. Running rtreecheck() on an R*Tree virtual table is similar to running &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on a database.</source>
          <target state="translated">스칼라 SQL 함수 rtreecheck (R) 또는 rtreecheck (S, R)은 데이터베이스 S에 포함 된 R이라는 rtree 테이블에서 무결성 검사를 실행합니다.이 함수는 발견 된 문제점에 대한 인간 언어 설명 또는 발견 된 경우 문자열 'ok'를 리턴합니다. 다 괜찮아 R * Tree 가상 테이블에서 rtreecheck ()를 실행 하는 것은 데이터베이스 에서 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 를 실행하는 것과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="181bcf0e796a132dd22a68144a4e494726dfbf32" translate="yes" xml:space="preserve">
          <source>The scenario above sounds far-fetched. But the SQLite developers are aware of at least one commercial product that was released with exactly this bug. The vendor came to the SQLite developers seeking help in tracking down some infrequent database corruption issues they were seeing on Linux and Mac. The problem was eventually traced to the fact that the application was linking against two separate copies of SQLite. The solution was to change the application build procedures to link against just one copy of SQLite instead of two.</source>
          <target state="translated">위의 시나리오는 많이 들립니다. 그러나 SQLite 개발자들은 정확히이 버그로 출시 된 하나 이상의 상용 제품을 알고 있습니다. 공급 업체는 Linux 및 Mac에서 자주 발생하는 데이터베이스 손상 문제를 추적하는 데 도움을 요청하는 SQLite 개발자에게 왔습니다. 결국이 문제는 응용 프로그램이 두 개의 별도 SQLite 복사본에 연결되어 있다는 사실로 추적되었습니다. 해결책은 애플리케이션 빌드 프로 시저를 변경하여 두 개의 SQLite 대신 한 개의 SQLite에 대해서만 링크하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7cf33abd12fd2e97d31a441b54d245ec800fc490" translate="yes" xml:space="preserve">
          <source>The schema above defines a directed graph with the ability to store a name at each node. Now consider a query against this schema:</source>
          <target state="translated">위의 스키마는 각 노드에 이름을 저장할 수있는 유향 그래프를 정의합니다. 이제이 스키마에 대한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d37b6e6570fc572ab09d9f50bc38138c9b41b0ec" translate="yes" xml:space="preserve">
          <source>The schema cookie is a 4-byte big-endian integer at offset 40 that is incremented whenever the database schema changes. A prepared statement is compiled against a specific version of the database schema. When the database schema changes, the statement must be reprepared. When a prepared statement runs, it first checks the schema cookie to ensure the value is the same as when the statement was prepared and if the schema cookie has changed, the statement either automatically reprepares and reruns or it aborts with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error.</source>
          <target state="translated">스키마 쿠키는 오프셋 40에서 4 바이트 빅 엔디안 정수이며 데이터베이스 스키마가 변경 될 때마다 증가합니다. 준비된 명령문은 특정 버전의 데이터베이스 스키마에 대해 컴파일됩니다. 데이터베이스 스키마가 변경되면 명령문을 다시 준비해야합니다. 준비된 명령문이 실행될 때 먼저 스키마 쿠키를 검사하여 값이 명령문이 준비된 시점과 동일한 지 확인하고 스키마 쿠키가 변경된 경우 명령문이 자동으로 다시 준비되고 다시 실행되거나 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 와 함께 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ab0e540f94c93f90585f3869aa649d5881cec37" translate="yes" xml:space="preserve">
          <source>The schema cookie.</source>
          <target state="translated">스키마 쿠키.</target>
        </trans-unit>
        <trans-unit id="4488aa59b7580b3c4da5952eb56f99b2cde228a2" translate="yes" xml:space="preserve">
          <source>The schema depicted above is not designed to store the full-text index directly. Instead, it is used to store one or more b-tree structures. There is one b-tree for each row in the %_segdir table. The %_segdir table row contains the root node and various meta-data associated with the b-tree structure, and the %_segments table contains all other (non-root) b-tree nodes. Each b-tree is referred to as a &quot;segment&quot;. Once it has been created, a segment b-tree is never updated (although it may be deleted altogether).</source>
          <target state="translated">위에서 설명한 스키마는 전체 텍스트 인덱스를 직접 저장하도록 설계되지 않았습니다. 대신 하나 이상의 b- 트리 구조를 저장하는 데 사용됩니다. % _segdir 테이블의 각 행마다 하나의 b- 트리가 있습니다. % _segdir 테이블 행에는 루트 노드와 b- 트리 구조와 관련된 다양한 메타 데이터가 포함되어 있으며 % _segments 테이블에는 다른 모든 루트 (비 루트) b- 트리 노드가 포함되어 있습니다. 각 b- 트리는 &quot;세그먼트&quot;라고합니다. 일단 생성되면 세그먼트 b- 트리는 절대로 업데이트되지 않습니다 (모두 삭제 될 수는 있음).</target>
        </trans-unit>
        <trans-unit id="2b92ee620ed7f83eb29e5266f914917afed4620a" translate="yes" xml:space="preserve">
          <source>The schema for the DBSTAT virtual table looks like this:</source>
          <target state="translated">DBSTAT 가상 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0fd02dc53052cb07a4282595789654910705302c" translate="yes" xml:space="preserve">
          <source>The schema for the dbstat virtual table is this:</source>
          <target state="translated">dbstat 가상 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2252a25e95423355b1edc92e550e314acf60ad89" translate="yes" xml:space="preserve">
          <source>The schema for the table returned by json_each() and json_tree() is as follows:</source>
          <target state="translated">json_each () 및 json_tree ()가 리턴 한 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3619e8cc0e29548b78032aaa5130408e5391fbe" translate="yes" xml:space="preserve">
          <source>The schema for the tables_used table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f20e4cd592c03cab97adad3d2182916294f862d" translate="yes" xml:space="preserve">
          <source>The schema format number for a new database can be set at runtime using the &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;PRAGMA legacy_file_format&lt;/a&gt; 명령을 사용하여 런타임시 새 데이터베이스의 스키마 형식 번호를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="933a80ece41d7c4fe3169e373964e2826ef1d8f7" translate="yes" xml:space="preserve">
          <source>The schema format number is a 4-byte big-endian integer at offset 44. The schema format number is similar to the file format read and write version numbers at offsets 18 and 19 except that the schema format number refers to the high-level SQL formatting rather than the low-level b-tree formatting. Four schema format numbers are currently defined:</source>
          <target state="translated">스키마 형식 번호는 오프셋 44에서 4 바이트 빅 엔디안 정수입니다. 스키마 형식 번호는 스키마 형식 번호가 상위 SQL을 참조한다는 점을 제외하고 오프셋 18 및 19에서 파일 형식 읽기 및 쓰기 버전 번호와 유사합니다. 하위 수준의 b- 트리 형식이 아닌 형식. 현재 네 가지 스키마 형식 번호가 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="62a7a887a20a821d1b69e9b449caf90b4200d958" translate="yes" xml:space="preserve">
          <source>The schema format number. Supported schema formats are 1, 2, 3, and 4.</source>
          <target state="translated">스키마 형식 번호 지원되는 스키마 형식은 1, 2, 3 및 4입니다.</target>
        </trans-unit>
        <trans-unit id="c07d56a869023707575ade10738a217ecfcee4af" translate="yes" xml:space="preserve">
          <source>The schema of an SQL database is able to represent information more directly and succinctly than a key/value database such as a ZIP archive. This makes the document content more accessible to third-party applications and scripts and facilitates advanced features such as built-in document versioning, and incremental saving of work in progress for recovery after a crash.</source>
          <target state="translated">SQL 데이터베이스의 스키마는 ZIP 아카이브와 같은 키 / 값 데이터베이스보다 더 직접적이고 간결하게 정보를 표현할 수 있습니다. 이를 통해 타사 응용 프로그램 및 스크립트에서 문서 내용에보다 쉽게 ​​액세스 할 수 있으며 내장 문서 버전 관리 및 충돌 후 복구를 위해 진행중인 작업의 증분 저장과 같은 고급 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4828e232778c36009f5d78cd72861a810e476bb6" translate="yes" xml:space="preserve">
          <source>The schema of the bytecode table is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a339d84c3beee1eeb93694c936d75161789ed451" translate="yes" xml:space="preserve">
          <source>The schema table can always be referenced using the name &quot;sqlite_schema&quot;, especially if qualifed by the schema name like &quot;main.sqlite_schema&quot; or &quot;temp.sqlite_schema&quot;. But for historical compatibility, some alternative names are also recognized, including:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70d31e0ed54ade1f01f5803b76d2ee1ab0a7fa16" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_version pragma는 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 헤더의&lt;/a&gt; 오프셋 40에서 schema-version 정수 값을 가져 오거나 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="87cc88d5b4a5e95bb023c0790cc28378b9e2bd05" translate="yes" xml:space="preserve">
          <source>The schema_version pragma will to get or set the value of the schema-version integer at offset 40 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;.</source>
          <target state="translated">schema_version pragma는 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 헤더의&lt;/a&gt; 오프셋 40에서 schema-version 정수 값을 가져 오거나 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="077341a10c528ac1588a1408b9034c9f8021b705" translate="yes" xml:space="preserve">
          <source>The scheme of the URI must be &quot;&lt;code&gt;file:&lt;/code&gt;&quot;. Any other scheme results in the input being treated as an ordinary filename.</source>
          <target state="translated">URI 스킴은 &quot; &lt;code&gt;file:&lt;/code&gt; &quot; 이어야합니다 . 다른 체계는 입력을 일반적인 파일 이름으로 취급합니다.</target>
        </trans-unit>
        <trans-unit id="08d91918dffee8fc87a94df6946790f6caab8817" translate="yes" xml:space="preserve">
          <source>The score is a combination of rank and distance. The idea is that a lower score is better. The virtual table attempts to find words with the lowest score and by default (unless overridden by ORDER BY) returns results in order of increasing score.</source>
          <target state="translated">점수는 순위와 거리의 조합입니다. 아이디어는 점수가 낮을수록 좋습니다. 가상 테이블은 가장 낮은 점수를 가진 단어를 찾으려고 기본적으로 (ORDER BY로 재정의되지 않은 경우) 점수가 높은 순서대로 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="61fd3b441b127465c680d5c3514e6d464720698f" translate="yes" xml:space="preserve">
          <source>The script compiles the TH3 test harness into machine code (&quot;th3.o&quot;) if necessary.</source>
          <target state="translated">이 스크립트는 필요한 경우 TH3 테스트 하니스를 기계 코드 ( &quot;th3.o&quot;)로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="9f405708716b43bff0ad67cd4c7d9fb92e6afc28" translate="yes" xml:space="preserve">
          <source>The script compiles the sqlite3.c source file into assembly language (&quot;sqlite3.s&quot;) if necessary.</source>
          <target state="translated">스크립트는 필요한 경우 sqlite3.c 소스 파일을 어셈블리 언어 ( &quot;sqlite3.s&quot;)로 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="9bf1fc92f793f60b433b7ebac87847be7a48eb60" translate="yes" xml:space="preserve">
          <source>The script loops through instructions in the assembly language file to locate branch operations.</source>
          <target state="translated">스크립트는 어셈블리 언어 파일의 명령어를 반복하여 분기 작업을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="576c62795ba33247bec0c331da3dd87f14e7a748" translate="yes" xml:space="preserve">
          <source>The script makes a copy of the original sqlite3.s file.</source>
          <target state="translated">스크립트는 원본 sqlite3.s 파일의 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fbefc60f4848710280b3f195980be93ae6fb0731" translate="yes" xml:space="preserve">
          <source>The script shows progress for each cycle of the previous step then displays a summary of &quot;survivors&quot; at the end. A &quot;survivor&quot; is a mutation that was not detected by TH3.</source>
          <target state="translated">이 스크립트는 이전 단계의 각주기에 대한 진행률을 표시 한 다음 끝에 &quot;생존자&quot;요약을 표시합니다. &quot;생존자&quot;는 TH3에 의해 검출되지 않은 돌연변이이다.</target>
        </trans-unit>
        <trans-unit id="4a731425cd1bb86844c78ad068a724419eca7459" translate="yes" xml:space="preserve">
          <source>The search for these strings in the type declaration is case insensitive, of course. If any of the above strings occur anywhere in the type declaration, then the datatype of the column is text. Notice that the type &quot;VARCHAR&quot; contains &quot;CHAR&quot; as a substring so it is considered text.</source>
          <target state="translated">타입 선언에서이 문자열을 검색하는 것은 물론 대소 문자를 구분하지 않습니다. 위의 문자열 중 하나가 형식 선언의 어느 곳에서나 발생하면 열의 데이터 형식은 텍스트입니다. &quot;VARCHAR&quot;유형은 &quot;CHAR&quot;을 하위 문자열로 포함하므로 텍스트로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="201735a6137bd8c721345300624cc86e3645ba64" translate="yes" xml:space="preserve">
          <source>The second &lt;a href=&quot;opcode#Transaction&quot;&gt;Transaction&lt;/a&gt; instruction begins a transaction and starts a rollback journal for database 1, the database used for temporary tables.</source>
          <target state="translated">두 번째 &lt;a href=&quot;opcode#Transaction&quot;&gt;트랜잭션&lt;/a&gt; 명령어는 트랜잭션을 시작하고 임시 테이블에 사용되는 데이터베이스 1에 대한 롤백 저널을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="541464126fdf47682a89498dd2c1f59037e5c50b" translate="yes" xml:space="preserve">
          <source>The second SELECT is implemented by instructions 14 through 19. Instruction 14 initializes the loop by rewinding its cursor. A new result row is created from the &quot;four&quot; column of table &quot;examp2&quot; by instructions 15 and 16. But instead of using PutStrKey to write this new row into the temporary table, we instead call Delete to remove it from the temporary table if it exists.</source>
          <target state="translated">제 2 SELECT는 명령 14 내지 19에 의해 구현된다. 명령 14는 커서를 되 감음으로써 루프를 초기화한다. 명령어 15와 16에 의해 테이블 ​​&quot;examp2&quot;의 &quot;4&quot;열에서 새로운 결과 행이 생성됩니다. 그러나 PutStrKey를 사용하여이 새 행을 임시 테이블에 쓰는 대신 Delete를 호출하여 임시 테이블에서 제거합니다. 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b382925f3a88c50c566963d5ae8b2f2a69bce488" translate="yes" xml:space="preserve">
          <source>The second advantage the SQLite printf routines have over &lt;b&gt;sprintf&lt;/b&gt; are two new formatting options specifically designed to support string literals in SQL. Within the format string, the %q formatting option works very much like %s in that it reads a null-terminated string from the argument list and inserts it into the result. But %q translates the inserted string by making two copies of every single-quote (') character in the substituted string. This has the effect of escaping the end-of-string meaning of single-quote within a string literal. The %Q formatting option works similar; it translates the single-quotes like %q and additionally encloses the resulting string in single-quotes. If the argument for the %Q formatting options is a NULL pointer, the resulting string is NULL without single quotes.</source>
          <target state="translated">SQLite printf 루틴이 &lt;b&gt;sprintf&lt;/b&gt; 보다 두 번째 장점은 SQL에서 문자열 리터럴을 지원하도록 특별히 설계된 두 가지 새로운 서식 옵션입니다. 형식화 문자열 내에서 % q 형식화 옵션은 인수 목록에서 널 (null) 종료 문자열을 읽고 결과에 삽입한다는 점에서 % s와 매우 유사하게 작동합니다. 그러나 % q는 대체 된 문자열에서 작은 따옴표 ( ') 문자마다 두 개의 복사본을 만들어 삽입 된 문자열을 변환합니다. 이것은 문자열 리터럴 내에서 작은 따옴표의 문자열 끝 의미를 피하는 효과가 있습니다. % Q 형식화 옵션은 비슷하게 작동합니다. % q와 같이 작은 따옴표를 번역하고 결과 문자열을 작은 따옴표로 묶습니다. % Q 형식화 옵션의 인수가 NULL 포인터 인 경우 작은 따옴표없이 결과 문자열이 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="24bd2add8c4054117cbe09f659537f282404edb5" translate="yes" xml:space="preserve">
          <source>The second and all subsequent 32768-byte units of the shm file are like this:</source>
          <target state="translated">shm 파일의 두 번째 및 모든 후속 32768 바이트 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f88dda8423c5371c7ad74eb85809481a6d1addf" translate="yes" xml:space="preserve">
          <source>The second and third forms return the computed edit distance between strings 'string1' and &quot;string2'. In the second form, a language id of 0 is used. The language id is specified in the third form.</source>
          <target state="translated">두 번째와 세 번째 형식은 문자열 'string1'과 'string2'사이의 계산 된 편집 거리를 반환하며 두 번째 형식에서는 언어 ID 0이 사용되며 언어 ID는 세 번째 형식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="bab5b375ff048a5d63f1a3b4cc3d343effcaa9c1" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes are not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">두 번째 인수 (xFilter)는 &quot;필터 콜백&quot;입니다. Session 개체에 연결되지 않은 테이블의 행 변경의 경우 테이블 행의 변경 내용을 추적해야하는지 여부를 결정하기 위해 필터가 호출됩니다. xFilter가 0을 반환하면 변경 사항이 추적되지 않습니다. 테이블이 연결되면 xFilter가 다시 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3a47f0193da66fdda72484a51d350d2076b5681" translate="yes" xml:space="preserve">
          <source>The second argument (xFilter) is the &quot;filter callback&quot;. For changes to rows in tables that are not attached to the Session object, the filter is called to determine whether changes to the table's rows should be tracked or not. If xFilter returns 0, changes is not tracked. Note that once a table is attached, xFilter will not be called again.</source>
          <target state="translated">두 번째 인수 (xFilter)는 &quot;필터 콜백&quot;입니다. Session 오브젝트에 첨부되지 않은 테이블의 행 변경 사항에 대해 테이블 ​​행의 변경 사항을 추적해야하는지 여부를 판별하기 위해 필터가 호출됩니다. xFilter가 0을 반환하면 변경 내용이 추적되지 않습니다. 테이블이 연결되면 xFilter가 다시 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="718f90fed591046439ad14f60ea06810377e7e83" translate="yes" xml:space="preserve">
          <source>The second argument indicates the reason that FTS5 is requesting tokenization of the supplied text. This is always one of the following four values:</source>
          <target state="translated">두 번째 인수는 FTS5가 제공된 텍스트의 토큰 화를 요청하는 이유를 나타냅니다. 이것은 항상 다음 네 가지 값 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="1b37e9b1846948d626696aade4d54493fddd03d8" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">두 번째 인수는 rowid 테이블에서 행이 업데이트, 삽입 또는 삭제 될 때 호출 할 함수에 대한 포인터입니다. 콜백에 대한 첫 번째 인수는 sqlite3_update_hook ()에 대한 세 번째 인수의 사본입니다. 두 번째 콜백 인수는 콜백을 호출 한 조작에 따라 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 중 하나입니다 . 콜백에 대한 세 번째 및 네 번째 인수는 영향을받는 행을 포함하는 데이터베이스 및 테이블 이름에 대한 포인터를 포함합니다. 최종 콜백 매개 변수는 행 의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다. 업데이트의 경우 업데이트가 발생한 후의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f6eef977cb1db09c38e32ceda39f74ec952be8d2" translate="yes" xml:space="preserve">
          <source>The second argument is a pointer to the function to invoke when a row is updated, inserted or deleted in a rowid table. The first argument to the callback is a copy of the third argument to sqlite3_update_hook(). The second callback argument is one of &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt;, depending on the operation that caused the callback to be invoked. The third and fourth arguments to the callback contain pointers to the database and table name containing the affected row. The final callback parameter is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the row. In the case of an update, this is the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; after the update takes place.</source>
          <target state="translated">두 번째 인수는 rowid 테이블에서 행이 업데이트, 삽입 또는 삭제 될 때 호출 할 함수에 대한 포인터입니다. 콜백에 대한 첫 번째 인수는 sqlite3_update_hook ()에 대한 세 번째 인수의 사본입니다. 두 번째 콜백 인수는 콜백을 호출 한 조작에 따라 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 중 하나입니다 . 콜백에 대한 세 번째 및 네 번째 인수는 영향을받는 행을 포함하는 데이터베이스 및 테이블 이름에 대한 포인터를 포함합니다. 최종 콜백 매개 변수는 행 의 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다. 업데이트의 경우 업데이트가 발생한 후의 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="724bd11ad92d936922e1ead7d8425d39851a3038" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="translated">두 번째 인수는 설정할 SQL 매개 변수의 색인입니다. 가장 왼쪽 SQL 매개 변수의 색인은 1입니다. 동일한 명명 된 SQL 매개 변수가 두 번 이상 사용되면 두 번째 및 후속 발생은 첫 번째 발생과 동일한 색인을 갖습니다. 이름이 지정된 매개 변수의 색인은 원하는 경우 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; API를 사용하여 조회 할 수 있습니다 . &quot;? NNN&quot;매개 변수의 색인은 NNN의 값입니다. NNN 값은 1과 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 매개 변수 &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (기본값 : 32766) 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d4e308f3aa98b17590b5e994747b662ab58b2433" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">두 번째 인수는 설정할 SQL 매개 변수의 색인입니다. 가장 왼쪽의 SQL 매개 변수는 1의 인덱스를 갖습니다. 동일한 명명 된 SQL 매개 변수가 두 번 이상 사용되면, 두 번째 이후의 발생은 첫 번째 발생과 동일한 인덱스를 갖습니다. 원하는 경우 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; API를 사용하여 명명 된 매개 변수의 색인을 찾을 수 있습니다 . &quot;? NNN&quot;매개 변수의 색인은 NNN의 값입니다. NNN 값은 1과 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 매개 변수 &lt;a href=&quot;#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (기본값 : 999) 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff965dc4a3884d50d8419508e30018f226ac3b0d" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 32766).</source>
          <target state="translated">두 번째 인수는 설정할 SQL 매개 변수의 색인입니다. 가장 왼쪽 SQL 매개 변수의 색인은 1입니다. 동일한 명명 된 SQL 매개 변수가 두 번 이상 사용되면 두 번째 및 후속 발생은 첫 번째 발생과 동일한 색인을 갖습니다. 이름이 지정된 매개 변수의 색인은 원하는 경우 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; API를 사용하여 조회 할 수 있습니다 . &quot;? NNN&quot;매개 변수의 색인은 NNN의 값입니다. NNN 값은 1과 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 매개 변수 &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (기본값 : 32766) 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="a3f014790ea15d84ae5efd1a40e8d6440e64de4e" translate="yes" xml:space="preserve">
          <source>The second argument is the index of the SQL parameter to be set. The leftmost SQL parameter has an index of 1. When the same named SQL parameter is used more than once, second and subsequent occurrences have the same index as the first occurrence. The index for named parameters can be looked up using the &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; API if desired. The index for &quot;?NNN&quot; parameters is the value of NNN. The NNN value must be between 1 and the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; parameter &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (default value: 999).</source>
          <target state="translated">두 번째 인수는 설정할 SQL 매개 변수의 색인입니다. 가장 왼쪽의 SQL 매개 변수는 1의 인덱스를 갖습니다. 동일한 명명 된 SQL 매개 변수가 두 번 이상 사용되면, 두 번째 이후의 발생은 첫 번째 발생과 동일한 인덱스를 갖습니다. 원하는 경우 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; API를 사용하여 명명 된 매개 변수의 색인을 찾을 수 있습니다 . &quot;? NNN&quot;매개 변수의 색인은 NNN의 값입니다. NNN 값은 1과 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 매개 변수 &lt;a href=&quot;c_limit_attached#sqlitelimitvariablenumber&quot;&gt;SQLITE_LIMIT_VARIABLE_NUMBER&lt;/a&gt; (기본값 : 999) 사이 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="2fb1bff691f79072fe4cf1aa2d31d1bd3832725a" translate="yes" xml:space="preserve">
          <source>The second argument passed to the xToken() callback (&quot;tflags&quot;) should normally be set to 0. The exception is if the tokenizer supports synonyms. In this case see the discussion below for details.</source>
          <target state="translated">xToken () 콜백 ( &quot;tflags&quot;)에 전달 된 두 번째 인수는 일반적으로 0으로 설정해야합니다. 토크 나이저가 동의어를 지원하는 경우는 예외입니다. 이 경우 자세한 내용은 아래 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca943db57529952ad5f76d4c9a47b52221a6d6e3" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config (D, V, ...)의 두 번째 인수는 &lt;a href=&quot;#sqlitedbconfiglookaside&quot;&gt;구성 동사&lt;/a&gt; - &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 어떤 측면 이 구성되고 있는지를 나타내는 정수 코드입니다 . 후속 인수는 구성 동사에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a7845e3bb7f88361055af36d05adde4b952592f9" translate="yes" xml:space="preserve">
          <source>The second argument to sqlite3_db_config(D,V,...) is the &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;configuration verb&lt;/a&gt; - an integer code that indicates what aspect of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being configured. Subsequent arguments vary depending on the configuration verb.</source>
          <target state="translated">sqlite3_db_config (D, V, ...)의 두 번째 인수는 &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;구성 동사&lt;/a&gt; - &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 어떤 측면 이 구성되고 있는지를 나타내는 정수 코드입니다 . 후속 인수는 구성 동사에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7ca88f23336b34513d2d790b7c87ef9c5d8d0e67" translate="yes" xml:space="preserve">
          <source>The second argument to the error logger callback is an integer &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;. The third argument to the error logger is the text of the error message. The error message text is stored in a fixed-length stack buffer in the calling function and so will only be valid for the duration of the error logger callback function. The error logger should make a copy of this message into persistent storage if retention of the message is needed.</source>
          <target state="translated">에러 로거 콜백에 대한 두 번째 인수는 정수 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 에러 코드&lt;/a&gt; 입니다. 오류 로거에 대한 세 번째 인수는 오류 메시지의 텍스트입니다. 오류 메시지 텍스트는 호출 함수의 고정 길이 스택 버퍼에 저장되므로 오류 로거 콜백 함수 기간 동안 만 유효합니다. 메시지 보존이 필요한 경우 오류 로거는이 메시지를 영구 저장소에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2a47b21d6064e4d10a2f6d6161c0f1dce1664a1" translate="yes" xml:space="preserve">
          <source>The second argument, &quot;zSql&quot;, is the statement to be compiled, encoded as either UTF-8 or UTF-16. The sqlite3_prepare(), sqlite3_prepare_v2(), and sqlite3_prepare_v3() interfaces use UTF-8, and sqlite3_prepare16(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() use UTF-16.</source>
          <target state="translated">두 번째 인수 인 &quot;zSql&quot;은 컴파일 할 명령문이며 UTF-8 또는 UTF-16으로 인코딩됩니다. sqlite3_prepare (), sqlite3_prepare_v2 () 및 sqlite3_prepare_v3 () 인터페이스는 UTF-8을 사용하고 sqlite3_prepare16 (), sqlite3_prepare16_v2 () 및 sqlite3_prepare16_v3 ()은 UTF-16을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f2e250c2ef383dec7dc31067a07b23d0da95c91b" translate="yes" xml:space="preserve">
          <source>The second beta release for SQLite 3.0.</source>
          <target state="translated">SQLite 3.0의 두 번째 베타 릴리스.</target>
        </trans-unit>
        <trans-unit id="771287a1de97a728b2134cd9c420c1c39a0f52c6" translate="yes" xml:space="preserve">
          <source>The second column is the name of the table.</source>
          <target state="translated">두 번째 열은 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="68511a08109abd7af5a81fce815eeb4f023584c9" translate="yes" xml:space="preserve">
          <source>The second form changes the journaling mode for &quot;</source>
          <target state="translated">두 번째 양식은 &quot;</target>
        </trans-unit>
        <trans-unit id="2f272c30ebac8ce92b2f903964b40a07bad463d7" translate="yes" xml:space="preserve">
          <source>The second form of the INSERT statement contains a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement instead of a VALUES clause. A new entry is inserted into the table for each row of data returned by executing the SELECT statement. If a column-list is specified, the number of columns in the result of the SELECT must be the same as the number of items in the column-list. Otherwise, if no column-list is specified, the number of columns in the result of the SELECT must be the same as the number of columns in the table. Any SELECT statement, including &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECTs&lt;/a&gt; and SELECT statements with &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; and/or &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; clauses, may be used in an INSERT statement of this form.</source>
          <target state="translated">INSERT 문의 두 번째 양식은 VALUES 절 대신 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 포함합니다 . SELECT 문을 실행하여 리턴 된 각 데이터 행에 대해 새 항목이 테이블에 삽입됩니다. 열 목록이 지정된 경우 SELECT 결과의 열 수는 열 목록의 항목 수와 같아야합니다. 그렇지 않으면 column-list가 지정되지 않은 경우 SELECT 결과의 열 수는 테이블의 열 수와 같아야합니다. &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; 및 / 또는 &lt;a href=&quot;lang_select#limitoffset&quot;&gt;LIMIT&lt;/a&gt; 절이있는 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 SELECT&lt;/a&gt; 및 SELECT 문을 포함한 모든 SELECT 문 은이 형식의 INSERT 문에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec9aa9593798c759bbdf9a6cf2b73541eab87efe" translate="yes" xml:space="preserve">
          <source>The second form of the command is this:</source>
          <target state="translated">명령의 두 번째 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa9b557c755fe5c619c7e5fc0af0adff81ce48ad" translate="yes" xml:space="preserve">
          <source>The second form of the pragma listed above is used to set a new limit in bytes for the specified database. A negative number implies no limit. To always truncate rollback journals and WAL files to their minimum size, set the journal_size_limit to zero. Both the first and second forms of the pragma listed above return a single result row containing a single integer column - the value of the journal size limit in bytes. The default journal size limit is -1 (no limit). The &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT&lt;/a&gt; preprocessor macro can be used to change the default journal size limit at compile-time.</source>
          <target state="translated">위에 나열된 pragma의 두 번째 형식은 지정된 데이터베이스에 대한 새 제한을 바이트 단위로 설정하는 데 사용됩니다. 음수는 제한이 없음을 의미합니다. 롤백 저널 및 WAL 파일을 항상 최소 크기로 자르려면 journal_size_limit를 0으로 설정하십시오. 위에 나열된 pragma의 첫 번째 형식과 두 번째 형식은 모두 단일 정수 열 (바이트 크기의 저널 크기 값)을 포함하는 단일 결과 행을 반환합니다. 기본 저널 크기 제한은 -1 (제한 없음)입니다. &lt;a href=&quot;compile#default_journal_size_limit&quot;&gt;SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT의&lt;/a&gt; 전 처리기 매크로는 컴파일시에 기본 저널 크기 제한을 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4008980ca9a9274111928748bc06de4b907efa68" translate="yes" xml:space="preserve">
          <source>The second integer, if it is present, is the aggregate size of all data stored on leaf pages in bytes. If the value is negative, then the segment is the output of an unfinished incremental-merge operation, and the absolute value is current size in bytes.</source>
          <target state="translated">두 번째 정수 (있는 경우)는 리프 페이지에 저장된 모든 데이터의 총 크기 (바이트)입니다. 값이 음수이면 세그먼트는 완료되지 않은 증분 병합 연산의 출력이며 절대 값은 현재 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="211c21970b7cdeb91101e574bc29708c2cdfae64" translate="yes" xml:space="preserve">
          <source>The second line above creates a virtual table named &quot;t1&quot; that reads the content of the file named in the argument. The number and names of the columns is determined automatically by reading the first line of content. Other options to the CSV virtual table provide the ability to take the CSV content from a string rather than a separate file, and give the programmer more control over the number and names of the columns. The options are detailed below. The CSV virtual table is usually created as a TEMP table so that it exists only for the current database connection and does not become a permanent part of the database schema. Note that there is no &quot;CREATE TEMP VIRTUAL TABLE&quot; command in SQLite. Instead, prepend the &quot;temp.&quot; schema prefix to the name of the virtual table.</source>
          <target state="translated">위의 두 번째 줄은 인수에 명명 된 파일의 내용을 읽는 &quot;t1&quot;이라는 가상 테이블을 만듭니다. 열의 수와 이름은 첫 번째 컨텐츠 행을 읽음으로써 자동으로 결정됩니다. CSV 가상 테이블에 대한 다른 옵션을 사용하면 별도의 파일이 아닌 문자열에서 CSV 내용을 가져 와서 프로그래머가 열의 수와 이름을보다 잘 제어 할 수 있습니다. 옵션은 아래에 자세히 설명되어 있습니다. CSV 가상 테이블은 일반적으로 TEMP 테이블로 만들어져 현재 데이터베이스 연결에만 존재하며 데이터베이스 스키마의 영구적 인 부분이되지 않습니다. SQLite에는 &quot;CREATE TEMP VIRTUAL TABLE&quot;명령이 없습니다. 대신 &quot;temp&quot;를 추가하십시오. 가상 테이블의 이름에 스키마 접두사.</target>
        </trans-unit>
        <trans-unit id="c3933495d9788c26f88ba69fbabb317f1e83064e" translate="yes" xml:space="preserve">
          <source>The second line of the file contains 211792 characters of impenetrable XML. Yes, 211792 characters all on one line. This file is a good stress-test for a text editor. Thankfully, the file is not some obscure binary format, but in terms of accessibility, it might as well be written in Klingon.</source>
          <target state="translated">파일의 두 번째 줄에는 211792 자의 뚫을 수없는 XML이 들어 있습니다. 예, 한 줄에 211792자가 모두 있습니다. 이 파일은 텍스트 편집기에 대한 스트레스 테스트입니다. 고맙게도 파일은 모호한 바이너리 형식이 아니지만 접근성 측면에서 Klingon으로 작성되었을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c1d27adf7a874de9fb599be39fb1d27d63c3092" translate="yes" xml:space="preserve">
          <source>The second number Y is incremented for any change that breaks forward compatibility by adding new features. Most future SQLite releases are expected to increment the second number Y. The Z is reset to zero whenever Y is increased.</source>
          <target state="translated">두 번째 숫자 Y는 새로운 기능을 추가하여 호환성을 향상시키는 모든 변경에 대해 증가합니다. 대부분의 향후 SQLite 릴리스는 두 번째 숫자 Y를 증가시킬 것으로 예상됩니다. Y가 증가 할 때마다 Z가 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="50b9dd44fd65466aa651f4fce7056da00ed7e13a" translate="yes" xml:space="preserve">
          <source>The second parameter (argc) and the fourth parameter (columnNames) are still valid and can be used to determine the number and names of the result columns if there had been a result. The default behavior is not to invoke the callback at all if the result set is empty.</source>
          <target state="translated">두 번째 매개 변수 (argc) 및 네 번째 매개 변수 (columnNames)는 여전히 유효하며 결과가있는 경우 결과 열의 수와 이름을 판별하는 데 사용할 수 있습니다. 기본 동작은 결과 집합이 비어있는 경우 콜백을 전혀 호출하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="682054ab4ce2cb4dfe2528dcad7556d5d406ca5f" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">두 번째 매개 변수는 작성하거나 재정의 할 SQL 함수의 이름입니다. UTF-8 표현에서 이름의 길이는 0 종결자를 제외하고 255 바이트로 제한됩니다. 이름 길이 제한은 문자 나 UTF-16 바이트가 아닌 UTF-8 바이트입니다. 더 긴 이름으로 함수를 작성하려고하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="266b83f6439ab5e88dcd3928741ef542cdbb6626" translate="yes" xml:space="preserve">
          <source>The second parameter is the name of the SQL function to be created or redefined. The length of the name is limited to 255 bytes in a UTF-8 representation, exclusive of the zero-terminator. Note that the name length limit is in UTF-8 bytes, not characters nor UTF-16 bytes. Any attempt to create a function with a longer name will result in &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; being returned.</source>
          <target state="translated">두 번째 매개 변수는 작성하거나 재정의 할 SQL 함수의 이름입니다. UTF-8 표현에서 이름의 길이는 0 종결자를 제외하고 255 바이트로 제한됩니다. 이름 길이 제한은 문자 나 UTF-16 바이트가 아닌 UTF-8 바이트입니다. 더 긴 이름으로 함수를 작성하려고하면 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="560b989b803d6b51bde79f3db2c1500c44cc5751" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">사전 갱신 콜백에 대한 두 번째 매개 변수 는 사전 갱신 후크를 등록한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 포인터 입니다. 사전 갱신 콜백에 대한 세 번째 매개 변수 는 발생하는 업데이트 조작의 종류를 식별하기위한 상수 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ALTER_TABLE&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 중 하나입니다 . 사전 갱신 콜백의 네 번째 매개 변수는 수정중인 데이터베이스 연결 내의 데이터베이스 이름입니다. 이는 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 테이블의 경우 &quot;temp&quot;이거나 연결된 데이터베이스 의 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 지정된 이름 입니다. 사전 갱신 콜백의 다섯 번째 매개 변수는 수정중인 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="097d5db1a651bbf810ec3be53362ed0414cfc3f9" translate="yes" xml:space="preserve">
          <source>The second parameter to the preupdate callback is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that registered the preupdate hook. The third parameter to the preupdate callback is one of the constants &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt;, &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt;, or &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; to identify the kind of update operation that is about to occur. The fourth parameter to the preupdate callback is the name of the database within the database connection that is being modified. This will be &quot;main&quot; for the main database or &quot;temp&quot; for TEMP tables or the name given after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement for attached databases. The fifth parameter to the preupdate callback is the name of the table that is being modified.</source>
          <target state="translated">사전 갱신 콜백에 대한 두 번째 매개 변수 는 사전 갱신 후크를 등록한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 포인터 입니다. 사전 갱신 콜백에 대한 세 번째 매개 변수 는 발생하는 업데이트 조작의 종류를 식별하기위한 상수 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_INSERT&lt;/a&gt; , &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 또는 &lt;a href=&quot;c_alter_table&quot;&gt;SQLITE_UPDATE&lt;/a&gt; 중 하나입니다 . 사전 갱신 콜백의 네 번째 매개 변수는 수정중인 데이터베이스 연결 내의 데이터베이스 이름입니다. 이는 기본 데이터베이스의 경우 &quot;main&quot;이거나 TEMP 테이블의 경우 &quot;temp&quot;이거나 연결된 데이터베이스 의 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 지정된 이름 입니다. 사전 갱신 콜백의 다섯 번째 매개 변수는 수정중인 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f5ad56c8e6b709d2294efc15c0b9ac27fea8d776" translate="yes" xml:space="preserve">
          <source>The second step finds the four shortest paths to visit two nodes beginning with one of the four paths from the previous step. In the case where two or more paths are equivalent (they have the same set of visited nodes, though possibly in a different order) only the first and lowest-cost path is retained. We have:</source>
          <target state="translated">두 번째 단계는 이전 단계의 4 개 경로 중 하나로 시작하여 2 개의 노드를 방문하는 4 개의 최단 경로를 찾습니다. 둘 이상의 경로가 동일한 경우 (아마도 순서가 다른 동일한 방문 노드 집합을 가짐) 첫 번째 경로와 가장 저렴한 경로 만 유지됩니다. 우리는 :</target>
        </trans-unit>
        <trans-unit id="73fbb8fcf9b3b6fa8277785714e82cfa142507c2" translate="yes" xml:space="preserve">
          <source>The second through fifth forms of this pragma set the encoding that the main database will be created with if it is created by this session. The string 'UTF-16' is interpreted as &quot;UTF-16 encoding using native machine byte-ordering&quot;. It is not possible to change the text encoding of a database after it has been created and any attempt to do so will be silently ignored.</source>
          <target state="translated">이 pragma의 두 번째에서 다섯 번째 형식은이 세션에서 생성 된 경우 주 데이터베이스가 생성 될 인코딩을 설정합니다. 문자열 'UTF-16'은 &quot;기본 머신 바이트 순서를 사용한 UTFF-16 인코딩&quot;으로 해석됩니다. 데이터베이스가 작성된 후에는 텍스트 인코딩을 변경할 수 없으며 그렇게하려는 시도는 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5882943850506b5e4c2358f26a0aca06e4d009ac" translate="yes" xml:space="preserve">
          <source>The secure_delete setting causes deleted content to be overwritten with zeros. There is a small performance penalty since additional I/O must occur. On the other hand, secure_delete can prevent fragments of sensitive information from lingering in unused parts of the database file after it has been deleted. See the documentation on the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; for additional information.</source>
          <target state="translated">secure_delete 설정은 삭제 된 내용을 0으로 덮어 씁니다. 추가 I / O가 발생해야하므로 성능이 약간 저하됩니다. 반면에 secure_delete를 사용하면 중요한 정보 조각이 삭제 된 후 데이터베이스 파일의 사용되지 않은 부분에 남아 있지 않을 수 있습니다. 추가 정보 는 &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; 의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b04afcfc3f7fd09080833015b31410c518c0339" translate="yes" xml:space="preserve">
          <source>The separate &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; description provides details on the structure of a database file and of the write-head log file used in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;. But details of the locking protocol and of the format of the WAL-index are deliberately omitted since those details are left to discretion of individual &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations. This document fills in those missing details for the unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;.</source>
          <target state="translated">별도의 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명은 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 사용되는 데이터베이스 파일 및 쓰기 헤드 로그 파일의 구조에 대한 세부 사항을 제공 합니다 . 그러나 잠금 프로토콜 및 WAL- 인덱스 형식의 세부 사항은 개별 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현 에 따라 결정되므로 의도적으로 생략 됩니다. 이 문서는 유닉스 및 윈도우 &lt;a href=&quot;vfs&quot;&gt;VFS에&lt;/a&gt; 대한 누락 된 세부 사항을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="92103d1dd017d8e08e89604f71cfaaa913bec164" translate="yes" xml:space="preserve">
          <source>The session extension facilitates this by recording all changes to both Alice's and Bob's databases and writing those changes into changeset or patchset files. At the end of the day, Alice can send her changeset to Bob and Bob can &quot;apply&quot; it to his database. The result (assuming there are no conflicts) is that Bob's database then contains both his changes and Alice's changes. Likewise, Bob can send a changeset of his work over to Alice and she can apply his changes to her database.</source>
          <target state="translated">세션 확장은 Alice와 Bob의 데이터베이스에 대한 모든 변경 사항을 기록하고 해당 변경 사항을 변경 세트 또는 패치 세트 파일에 기록하여이를 용이하게합니다. 하루가 끝나면 Alice는 변경 세트를 Bob에게 보내고 Bob은 해당 변경 세트를 데이터베이스에 &quot;적용&quot;할 수 있습니다. 그 결과 (충돌이 없다고 가정) Bob의 데이터베이스에는 변경 사항과 Alice의 변경 사항이 모두 포함됩니다. 마찬가지로 Bob은 자신의 작업에 대한 변경 세트를 Alice에게 보내고 변경 사항을 데이터베이스에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c8659fbbef014d7697d1ea170e739bed552acd5" translate="yes" xml:space="preserve">
          <source>The session extension only works with tables that have a declared PRIMARY KEY. The PRIMARY KEY of a table may be an INTEGER PRIMARY KEY (rowid alias) or an external PRIMARY KEY.</source>
          <target state="translated">세션 확장은 선언 된 PRIMARY KEY가있는 테이블에서만 작동합니다. 테이블의 PRIMARY KEY는 정수 PRIMARY KEY (행 별명) 또는 외부 PRIMARY KEY 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8619b8eb0bb510e39b3c8622337b2bb7b6549aba" translate="yes" xml:space="preserve">
          <source>The session extension provide a mechanism for recording changes to some or all of the &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt; in an SQLite database, and packaging those changes into a &quot;changeset&quot; or &quot;patchset&quot; file that can later be used to apply the same set of changes to another database with the same schema and compatible starting data. A &quot;changeset&quot; may also be inverted and used to &quot;undo&quot; a session.</source>
          <target state="translated">세션 확장 은 SQLite 데이터베이스 의 일부 또는 모든 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에 대한 변경 사항을 기록하고 나중에 변경 사항을 다른 변경 사항에 적용하는 데 사용할 수있는 &quot;changeset&quot;또는 &quot;patchset&quot;파일로 패키지화 하는 메커니즘을 제공합니다. 동일한 스키마 및 호환되는 시작 데이터가있는 데이터베이스 &quot;변경 세트&quot;는 반전되어 세션을 &quot;실행 취소&quot;하는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b97f5ba300285bc33992abb7779519b897b7aa7" translate="yes" xml:space="preserve">
          <source>The session object &quot;indirect&quot; flag is set when the change is made, or</source>
          <target state="translated">세션 개체 &quot;간접&quot;플래그는 변경시 설정됩니다. 또는</target>
        </trans-unit>
        <trans-unit id="ffcb76dee8dc3b4cb20fe29908bbbe2ff2230909" translate="yes" xml:space="preserve">
          <source>The session object is configured with a set of tables to monitor changes on.</source>
          <target state="translated">세션 개체는 테이블 집합으로 구성되어 변경 사항을 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="0c67ff7ccfd533851dea34da8187939bbeae8841" translate="yes" xml:space="preserve">
          <source>The session object is deleted using a call to the &lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; API function.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; API 함수를 호출하여 세션 객체가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="b41c2d1dd25f0b9daf0304c7870c3eb7ae78b919" translate="yes" xml:space="preserve">
          <source>The session object therefore accumulates two types of records - those that consist of primary key values only (created when the user inserts a new record) and those that consist of the primary key values and the original values of other table columns (created when the users deletes or updates a record).</source>
          <target state="translated">따라서 세션 오브젝트는 두 가지 유형의 레코드 (기본 키 값만으로 구성 (사용자가 새 레코드를 삽입 할 때 작성 됨)와 기본 키 값 및 기타 테이블 열의 원래 값 (사용자가 작성했을 때 작성 됨)으로 누적됩니다. 레코드를 삭제하거나 업데이트합니다).</target>
        </trans-unit>
        <trans-unit id="67b4d05a6aa852ba851b95d39158470c33cead0c" translate="yes" xml:space="preserve">
          <source>The session object will be used to create changesets for tables in database zDb, where zDb is either &quot;main&quot;, or &quot;temp&quot;, or the name of an attached database. It is not an error if database zDb is not attached to the database when the session object is created.</source>
          <target state="translated">세션 오브젝트는 데이터베이스 zDb에서 테이블에 대한 변경 세트를 작성하는 데 사용됩니다. 여기서 zDb는 &quot;main&quot;또는 &quot;temp&quot;이거나 연결된 데이터베이스의 이름입니다. 세션 오브젝트가 작성 될 때 데이터베이스 zDb가 데이터베이스에 접속되지 않은 경우 오류가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="45a8679117c7936fefc29c4e8b252b099d09917b" translate="yes" xml:space="preserve">
          <source>The sessions module never invokes an xOutput callback with the third parameter set to a value less than or equal to zero. Other than this, no guarantees are made as to the size of the chunks of data returned.</source>
          <target state="translated">세션 모듈은 세 번째 매개 변수가 0보다 작거나 같은 값으로 설정된 xOutput 콜백을 호출하지 않습니다. 이 외에는 반환 된 데이터 청크의 크기에 대한 보장이 없습니다.</target>
        </trans-unit>
        <trans-unit id="a218d47a709906affb4f3ae717da9de3077b519d" translate="yes" xml:space="preserve">
          <source>The sessions module revolves around creating and manipulating changesets. A changeset is a blob of data that encodes a series of changes to a database. Each change in a changeset is one of the following:</source>
          <target state="translated">세션 모듈은 변경 세트 작성 및 조작을 중심으로 진행됩니다. 변경 세트는 일련의 변경 사항을 데이터베이스에 인코딩하는 데이터 덩어리입니다. 변경 세트의 각 변경은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="d639d6bbcd88a2f2cd5339240f5d5c5de8f80432" translate="yes" xml:space="preserve">
          <source>The set X contains the index in aPgno of every entry in the current 32768-byte unit of the shm file that might possible be a solution to the FindFrame(P,M) function. Each of these entries must be checked separately to ensure that the aPgno value is P and that the frame number does not exceed M. The largest frame number that passes those two tests is the answer.</source>
          <target state="translated">X 세트는 shm 파일의 현재 32768 바이트 단위에있는 모든 항목의 FindP (P, M) 함수에 대한 솔루션 일 수있는 모든 항목의 색인에 aPgno의 색인을 포함합니다. aPgno 값이 P이고 프레임 번호가 M을 초과하지 않도록 이러한 각 항목을 개별적으로 확인해야합니다.이 두 테스트를 통과하는 가장 큰 프레임 번호가 정답입니다.</target>
        </trans-unit>
        <trans-unit id="daeab809359987c0f17f57c78f38704f62041f7b" translate="yes" xml:space="preserve">
          <source>The set of</source>
          <target state="translated">세트</target>
        </trans-unit>
        <trans-unit id="df619f50e7143055665ccf4d69e938c1340f4737" translate="yes" xml:space="preserve">
          <source>The set of built-in auxiliary functions provided by FTS5 may be improved upon in the future.</source>
          <target state="translated">FTS5가 제공하는 내장 보조 기능 세트는 향후 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a49341beec33b485301f8bafe6ae6c61c6f39915" translate="yes" xml:space="preserve">
          <source>The set of checklist items for release checklist is potentially updated for each release. The content and complete history of each release checklist are retained for the historical record.</source>
          <target state="translated">릴리스 점검 목록에 대한 점검 목록 항목 세트는 각 릴리스마다 잠재적으로 업데이트됩니다. 각 릴리스 점검 목록의 컨텐츠 및 전체 히스토리는 히스토리 레코드에 대해 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5a66644e1d1f4b0f41c960d4f2f7a794b20868" translate="yes" xml:space="preserve">
          <source>The set of static mutexes may change from one SQLite release to the next. Applications that override the built-in mutex logic must be prepared to accommodate additional static mutexes.</source>
          <target state="translated">정적 뮤텍스 세트는 하나의 SQLite 릴리스에서 다음 SQLite 릴리스로 변경 될 수 있습니다. 내장 뮤텍스 로직을 재정의하는 애플리케이션은 추가 정적 뮤텍스를 수용 할 수 있도록 준비해야합니다.</target>
        </trans-unit>
        <trans-unit id="9b60f1982b5c4164ca917a617479f0aacfe46294" translate="yes" xml:space="preserve">
          <source>The shadow tables are ordinary SQLite data tables. You can query them directly if you like, though this unlikely to reveal anything particularly useful. And you can &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or even &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; the shadow tables, though doing so will corrupt your R*Tree index. So it is best to simply ignore the shadow tables. Recognize that they hold your R*Tree index information and let it go as that.</source>
          <target state="translated">새도우 테이블은 일반 SQLite 데이터 테이블입니다. 원하는 경우 직접 쿼리 할 수 ​​있지만 특히 유용한 정보가 표시되지는 않습니다. 또한 섀도우 테이블을 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;lang_droptable&quot;&gt;DROP&lt;/a&gt; 할 수 있지만 R * Tree 인덱스가 손상됩니다. 따라서 새도우 테이블을 단순히 무시하는 것이 가장 좋습니다. 이들이 R * Tree 색인 정보를 보유하고 있음을 인식하십시오.</target>
        </trans-unit>
        <trans-unit id="7b89e4e1261efca1d668789aecafeceb06cf0045" translate="yes" xml:space="preserve">
          <source>The shared library filename passed to &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; may omit the filename suffix, and an appropriate architecture-dependent suffix (&quot;.so&quot;, &quot;.dylib&quot;, or &quot;.dll&quot;) will be added automatically.</source>
          <target state="translated">&lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()에&lt;/a&gt; 전달 된 공유 라이브러리 파일 이름 은 파일 이름 접미사를 생략하고 적절한 아키텍처 종속 접미사 ( &quot;.so&quot;, &quot;.dylib&quot;또는 &quot;.dll&quot;)가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="683712ddb2de169a205df89a5ffe29d5c006c2b5" translate="yes" xml:space="preserve">
          <source>The shared-memory file contains no persistent content. The only purpose of the shared-memory file is to provide a block of shared memory for use by multiple processes all accessing the same database in WAL mode. If the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; is able to provide an alternative method for accessing shared memory, then that alternative method might be used rather than the shared-memory file. For example, if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; is set to EXCLUSIVE (meaning that only one process is able to access the database file) then the shared memory will be allocated from heap rather than out of the shared-memory file, and the shared-memory file will never be created.</source>
          <target state="translated">공유 메모리 파일에는 영구 컨텐츠가 없습니다. 공유 메모리 파일의 유일한 목적은 WAL 모드에서 동일한 데이터베이스에 모두 액세스하는 여러 프로세스에서 사용할 공유 메모리 블록을 제공하는 것입니다. &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 가 공유 메모리에 액세스하기위한 대체 방법을 제공 할 수 있으면 공유 메모리 파일 대신 해당 대체 방법을 사용할 수 있습니다. 예를 들어 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode&lt;/a&gt; 가 EXCLUSIVE로 설정되면 (하나의 프로세스 만 데이터베이스 파일에 액세스 할 수 있음을 의미) 공유 메모리는 공유 메모리 파일이 아닌 힙에서 할당되며 공유 메모리 파일은 절대로 만들어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d84d71db4e9c7a1a18a467e4bbe2be0320c053f2" translate="yes" xml:space="preserve">
          <source>The shared-memory file has the same lifetime as its associated WAL file. The shared-memory file is created when the WAL file is created and is deleted when the WAL file is deleted. During WAL file recovery, the shared memory file is recreated from scratch based on the contents of the WAL file being recovered.</source>
          <target state="translated">공유 메모리 파일의 수명은 관련 WAL 파일과 동일합니다. 공유 메모리 파일은 WAL 파일이 작성 될 때 작성되고 WAL 파일이 삭제 될 때 삭제됩니다. WAL 파일 복구 중에는 복구중인 WAL 파일의 내용을 기반으로 공유 메모리 파일이 처음부터 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c6175d074e784d9fffd662056186d3e1dc1f4cc9" translate="yes" xml:space="preserve">
          <source>The shm does not contain any database content and is not required to recover the database following a crash. For that reason, the first client to connect to a quiescent database will normally truncate the shm file if it exists. Since the content of the shm file does not need to be preserved across a crash, the shm file is never fsync()-ed to disk. In fact, if there were a mechanism by which SQLite could tell the operating system to never persist the shm file to disk but always hold it in cache memory, SQLite would use that mechanism to avoid any unnecessary disk I/O associated with the shm file. However, no such mechanism exists in standard posix.</source>
          <target state="translated">shm에는 데이터베이스 내용이 포함되어 있지 않으며 충돌 후 데이터베이스를 복구 할 필요가 없습니다. 따라서 대기 데이터베이스에 연결하는 첫 번째 클라이언트는 일반적으로 shm 파일이있는 경우이를 잘립니다. shm 파일의 내용은 충돌로 유지 될 필요가 없으므로 shm 파일은 디스크에 fsync ()되지 않습니다. 실제로 SQLite가 운영 체제에 shm 파일을 디스크에 저장하지 않고 항상 캐시 메모리에 보관하도록 지시하는 메커니즘이있는 경우 SQLite는 해당 메커니즘을 사용하여 shm 파일과 연관된 불필요한 디스크 I / O를 피합니다. . 그러나 표준 posix에는 이러한 메커니즘이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ce5842569cd9ae6cb873fe122d925e98dfd9e57" translate="yes" xml:space="preserve">
          <source>The shm file consists of one or more hash tables, where each hash table is 32768 bytes in size. Except, a 136-byte header is carved out of the front of the very first hash table, so the first hash table is only 32632 bytes in size. The total size of the shm file is always a multiple of 32768. In most cases, the total size of the shm file is exactly 32768 bytes. The shm file only needs to grow beyond a single hash table if when the wal file grows very large (more than 4079 frames). Since the default &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;automatic checkpoint threshold&lt;/a&gt; is 1000, WAL files rare reach the 4079 threshold needed to make the shm file grow.</source>
          <target state="translated">shm 파일은 하나 이상의 해시 테이블로 구성되며 각 해시 테이블의 크기는 32768 바이트입니다. 단, 136 바이트 헤더는 첫 번째 해시 테이블의 앞면에 새겨 져 있으므로 첫 번째 해시 테이블의 크기는 32632 바이트에 불과합니다. shm 파일의 총 크기는 항상 32768의 배수입니다. 대부분의 경우 shm 파일의 총 크기는 정확히 32768 바이트입니다. wal 파일이 매우 커지면 (4079 프레임 이상) shm 파일은 단일 해시 테이블 이상으로 커야합니다. 기본 &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;자동 검사 점 임계 값&lt;/a&gt; 은 1000이므로 WAL 파일은 shm 파일을 늘리는 데 필요한 4079 임계 값에 도달하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0d8774149ef596e36906cd1fe56afff10a697841" translate="yes" xml:space="preserve">
          <source>The signature of the xAccess method has been modified to return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and to store its output into an integer pointed to by a parameter, rather than returning the output directly. This change allows the xAccess() method to report failures. In association with this signature change, a new extended error code &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; has been added.</source>
          <target state="translated">xAccess 메소드의 서명은 출력을 직접 리턴하지 않고 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴 하고 출력을 매개 변수가 가리키는 정수에 저장 하도록 수정되었습니다 . 이 변경으로 xAccess () 메소드가 실패를보고 할 수 있습니다. 이 서명 변경과 관련하여 새로운 확장 오류 코드 &lt;a href=&quot;rescode#ioerr_access&quot;&gt;SQLITE_IOERR_ACCESS&lt;/a&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="73da15d1378e7e4cecf6c05a9921a5f1b3117f3b" translate="yes" xml:space="preserve">
          <source>The signature of the xCheckReservedLock method on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; has been modified so that it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; and stores its boolean result into an integer pointed to by a parameter. In association with this change, a new extended error code &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; has been added.</source>
          <target state="translated">&lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 에서 xCheckReservedLock 메소드의 서명 이 수정되어 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴하고 해당 부울 결과를 매개 변수가 가리키는 정수로 저장합니다. 이 변경과 관련하여 새로운 확장 오류 코드 &lt;a href=&quot;rescode#ioerr_checkreservedlock&quot;&gt;SQLITE_IOERR_CHECKRESERVEDLOCK&lt;/a&gt; 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="23da313c5318bbaf1e11638c6787139e74ceff62" translate="yes" xml:space="preserve">
          <source>The simple, modular design of SQLite makes it a good platform for prototyping new, experimental database language features or ideas.</source>
          <target state="translated">SQLite의 단순 모듈 식 설계는 새로운 실험 데이터베이스 언어 기능 또는 아이디어를 프로토 타이핑하기에 적합한 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="2d0de7ad7a0838db1beb185b37e3f4659d20a947" translate="yes" xml:space="preserve">
          <source>The single row of result-set data created by evaluating the aggregate and non-aggregate expressions in the result-set forms the result of an aggregate query without a GROUP BY clause. An aggregate query without a GROUP BY clause always returns exactly one row of data, even if there are zero rows of input data.</source>
          <target state="translated">결과 집합에서 집계 및 비 집계 식을 평가하여 생성 된 단일 결과 집합 데이터 행은 GROUP BY 절이없는 집계 쿼리 결과를 형성합니다. GROUP BY 절이없는 집계 쿼리는 입력 데이터 행이 0 인 경우에도 항상 정확히 한 행의 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fee8fe6df1809775fcd62fdf9f110bcf759d94a6" translate="yes" xml:space="preserve">
          <source>The six streaming API xxx_strm() functions serve similar purposes to the corresponding non-streaming API functions:</source>
          <target state="translated">6 개의 스트리밍 API xxx_strm () 함수는 해당 비 스트리밍 API 함수와 유사한 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af903c0dcc364c9d11abbe191c3960a1c5d014f5" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64 ()에 대한 여섯 번째 인수 는 세 번째 매개 변수에서 텍스트 인코딩을 지정하려면 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 중 하나 여야합니다 . sqlite3_bind_text64 ()에 대한 여섯 번째 인수가 위에 표시된 허용 된 값 중 하나가 아니거나 텍스트 인코딩이 여섯 번째 매개 변수로 지정된 인코딩과 다른 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a920902ff183846916ffe84129516653c512659" translate="yes" xml:space="preserve">
          <source>The sixth argument to sqlite3_bind_text64() must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; to specify the encoding of the text in the third parameter. If the sixth argument to sqlite3_bind_text64() is not one of the allowed values shown above, or if the text encoding is different from the encoding specified by the sixth parameter, then the behavior is undefined.</source>
          <target state="translated">sqlite3_bind_text64 ()에 대한 여섯 번째 인수 는 세 번째 매개 변수에서 텍스트 인코딩을 지정하려면 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 또는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 중 하나 여야합니다 . sqlite3_bind_text64 ()에 대한 여섯 번째 인수가 위에 표시된 허용 된 값 중 하나가 아니거나 텍스트 인코딩이 여섯 번째 매개 변수로 지정된 인코딩과 다른 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8b06ccbdc8c379a9a470f7c185a0247a80f8e2b" translate="yes" xml:space="preserve">
          <source>The sixth, seventh and eighth parameters passed to the three &quot;sqlite3_create_function*&quot; functions, xFunc, xStep and xFinal, are pointers to C-language functions that implement the SQL function or aggregate. A scalar SQL function requires an implementation of the xFunc callback only; NULL pointers must be passed as the xStep and xFinal parameters. An aggregate SQL function requires an implementation of xStep and xFinal and NULL pointer must be passed for xFunc. To delete an existing SQL function or aggregate, pass NULL pointers for all three function callbacks.</source>
          <target state="translated">세 개의 &quot;sqlite3_create_function *&quot;함수 xFunc, xStep 및 xFinal에 전달 된 여섯 번째, 일곱 번째 및 여덟 번째 매개 변수는 SQL 함수 또는 집계를 구현하는 C 언어 함수에 대한 포인터입니다. 스칼라 SQL 함수에는 xFunc 콜백 구현 만 필요합니다. NULL 포인터는 xStep 및 xFinal 매개 변수로 전달되어야합니다. 집계 SQL 함수에는 xStep 및 xFinal 구현이 필요하며 xFunc에 NULL 포인터를 전달해야합니다. 기존 SQL 함수 또는 집계를 삭제하려면 세 함수 콜백 모두에 대해 NULL 포인터를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1e0ca7d22b49ccdf57dfbe9e13e610f7e7488a" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_window_function에 전달 된 6, 7, 8 및 9 번째 매개 변수 (xStep, xFinal, xValue 및 xInverse)는 새 함수를 구현하는 C 언어 콜백에 대한 포인터입니다. xStep 및 xFinal은 모두 NULL이 아니어야합니다. xValue 및 xInverse는 모두 NULL 일 수 있으며,이 경우 일반 집계 함수가 작성되거나 NULL이 아니어야합니다.이 경우 새 함수는 집계 또는 집계 창 함수로 사용될 수 있습니다. 집계 창 함수 구현에 대한 자세한 내용은 &lt;a href=&quot;../windowfunctions#udfwinfunc&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f70d86715eabcca8a7d61d2f6e68b2fc4d6a57e" translate="yes" xml:space="preserve">
          <source>The sixth, seventh, eighth and ninth parameters (xStep, xFinal, xValue and xInverse) passed to sqlite3_create_window_function are pointers to C-language callbacks that implement the new function. xStep and xFinal must both be non-NULL. xValue and xInverse may either both be NULL, in which case a regular aggregate function is created, or must both be non-NULL, in which case the new function may be used as either an aggregate or aggregate window function. More details regarding the implementation of aggregate window functions are &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;available here&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_window_function에 전달 된 6, 7, 8 및 9 번째 매개 변수 (xStep, xFinal, xValue 및 xInverse)는 새 함수를 구현하는 C 언어 콜백에 대한 포인터입니다. xStep 및 xFinal은 모두 NULL이 아니어야합니다. xValue 및 xInverse는 모두 NULL 일 수 있으며,이 경우 일반 집계 함수가 작성되거나 NULL이 아니어야합니다.이 경우 새 함수는 집계 또는 집계 창 함수로 사용될 수 있습니다. 집계 창 함수 구현에 대한 자세한 내용은 &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="650196bb22cf5bf05d1563df9b31bf781c3e9a6d" translate="yes" xml:space="preserve">
          <source>The size of the blobs in the test data affects performance. The filesystem will generally be faster for larger blobs, since the overhead of open() and close() is amortized over more bytes of I/O, whereas the database will be more efficient in both speed and space as the average blob size decreases.</source>
          <target state="translated">테스트 데이터의 얼룩 크기는 성능에 영향을줍니다. open () 및 close ()의 오버 헤드가 더 많은 I / O 바이트에서 상각되므로 파일 시스템은 일반적으로 더 큰 블로 브에 대해 더 빠릅니다. 반면 데이터베이스는 평균 블로 브 크기가 감소함에 따라 속도와 공간 모두에서 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="71ba6b5b378d657456a5945d2ff20a780b1b14d4" translate="yes" xml:space="preserve">
          <source>The size of the lookaside memory pool has a global default value but can also be configured on a connection-by-connection basis. To change the default size of the lookaside memory pool at compile-time, use the &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE=&lt;i&gt;SZ,N&lt;/i&gt;&lt;/a&gt; option. To change the default size of the lookaside memory pool at start-time, use the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface:</source>
          <target state="translated">lookaside 메모리 풀의 크기는 전역 기본값을 갖지만 연결별로 구성 할 수도 있습니다. 컴파일시 lookaside 메모리 풀의 기본 크기를 변경하려면 &lt;a href=&quot;compile#default_lookaside&quot;&gt;-DSQLITE_DEFAULT_LOOKASIDE = &lt;i&gt;SZ, N&lt;/i&gt;&lt;/a&gt; 옵션을 사용하십시오. 시작시 lookaside 메모리 풀의 기본 크기를 변경하려면 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7032e0044fe8cbf0ccd0392512f38ee2b17ffc25" translate="yes" xml:space="preserve">
          <source>The size of the matching term in bytes.</source>
          <target state="translated">일치하는 용어의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="481f99d28cac0daa50062e9ad3a05601840366c0" translate="yes" xml:space="preserve">
          <source>The size of the memory-mapped I/O region cannot be changed while the memory-mapped I/O region is in active use, to avoid unmapping memory out from under running SQL statements. For this reason, the mmap_size pragma may be a no-op if the prior mmap_size is non-zero and there are other SQL statements running concurrently on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">메모리 매핑 된 I / O 영역의 크기는 메모리 매핑 된 I / O 영역이 사용중인 동안 변경할 수 없으므로 실행중인 SQL 문에서 메모리 매핑 해제가 발생하지 않습니다. 이러한 이유로 이전 mmap_size가 0이 아니고 동일한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 동시에 실행중인 다른 SQL 문이있는 경우 mmap_size pragma는 작동하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19c67c781984d7843a725bf421c45281605af01e" translate="yes" xml:space="preserve">
          <source>The snippet function first attempts to find a fragment of text consisting of</source>
          <target state="translated">스 니펫 함수는 먼저 다음으로 구성된 텍스트 조각을 찾으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="54b3f9fdd628ef57cd97424e1a01116d0ba15ccd" translate="yes" xml:space="preserve">
          <source>The snippet function is used to create formatted fragments of document text for display as part of a full-text query results report. The snippet function may be passed between one and six arguments, as follows:</source>
          <target state="translated">스 니펫 기능은 전체 텍스트 쿼리 결과 보고서의 일부로 표시 할 문서 텍스트의 형식화 된 단편을 작성하는 데 사용됩니다. 스 니펫 함수는 다음과 같이 1 개와 6 개의 인수 사이에 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ab90403f978d997e2573cced370b12d71d602c" translate="yes" xml:space="preserve">
          <source>The snippet() function is similar to highlight(), except that instead of returning entire column values, it automatically selects and extracts a short fragment of document text to process and return. The snippet() function must be passed five parameters following the table name argument:</source>
          <target state="translated">snippet () 함수는 전체 열 값을 반환하는 대신 처리 및 반환 할 짧은 문서 텍스트 조각을 자동으로 선택하여 추출한다는 점을 제외하면 highlight ()와 유사합니다. snippet () 함수는 테이블 이름 인수 다음에 5 개의 매개 변수를 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="650db23255aac8aa4103c6f6d9992ba8c2854051" translate="yes" xml:space="preserve">
          <source>The soft heap limit is &quot;soft&quot; in this sense: If SQLite is not able to free up enough auxiliary memory to stay below the limit, it goes ahead and allocates the extra memory and exceeds its limit. This occurs under the theory that it is better to use additional memory than to fail outright.</source>
          <target state="translated">소프트 힙 한계는 이런 의미에서 &quot;소프트&quot;입니다. SQLite가 한계 미만으로 유지하기에 충분한 보조 메모리를 확보 할 수없는 경우 계속해서 추가 메모리를 할당하고 한계를 초과합니다. 이것은 완전히 실패하는 것보다 추가 메모리를 사용하는 것이 낫다는 이론 하에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f259c7b18142819d8b2454c94e82cad365d3cfbd" translate="yes" xml:space="preserve">
          <source>The soft heap limit is not enforced in the current implementation if one or more of following conditions are true:</source>
          <target state="translated">다음 조건 중 하나 이상에 해당되면 현재 구현에서 소프트 힙 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62f643dbe59889b37bb6ee27203ce861b75e4df1" translate="yes" xml:space="preserve">
          <source>The soft heap limit is set to zero.</source>
          <target state="translated">소프트 힙 한계는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1e9f9417ca080fbcc56641af6510e79f88f545c2" translate="yes" xml:space="preserve">
          <source>The soft heap limit may not be greater than the hard heap limit. If the hard heap limit is enabled and if sqlite3_soft_heap_limit(N) is invoked with a value of N that is greater than the hard heap limit, the the soft heap limit is set to the value of the hard heap limit. The soft heap limit is automatically enabled whenever the hard heap limit is enabled. When sqlite3_hard_heap_limit64(N) is invoked and the soft heap limit is outside the range of 1..N, then the soft heap limit is set to N. Invoking sqlite3_soft_heap_limit64(0) when the hard heap limit is enabled makes the soft heap limit equal to the hard heap limit.</source>
          <target state="translated">소프트 힙 한계는 하드 힙 한계보다 클 수 없습니다. 하드 힙 한계가 사용 가능하고 sqlite3_soft_heap_limit (N)이 하드 힙 한계보다 큰 N 값으로 호출되는 경우 소프트 힙 한계는 하드 힙 한계 값으로 설정됩니다. 소프트 힙 제한은 하드 힙 제한이 활성화 될 때마다 자동으로 활성화됩니다. sqlite3_hard_heap_limit64 (N)이 호출되고 소프트 힙 제한이 1..N 범위를 벗어나면 소프트 힙 제한이 N으로 설정됩니다. 하드 힙 제한이 활성화 된 경우 sqlite3_soft_heap_limit64 (0)를 호출하면 소프트 힙 제한이 동일 해집니다. 하드 힙 한계까지.</target>
        </trans-unit>
        <trans-unit id="84963983acb45095ae249428915953ba1875b5f1" translate="yes" xml:space="preserve">
          <source>The solution was computed in less than 300 milliseconds on a modern workstation.</source>
          <target state="translated">솔루션은 최신 워크 스테이션에서 300 밀리 초 이내에 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="d8fc439428a4b57b8a635dfdc3bc6c9e9458a598" translate="yes" xml:space="preserve">
          <source>The solver works by adding new entries to the &quot;x&quot; recursive table. Given prior entries, the recursive-select tries to fill in a single new position with all values between 1 and 9 that actually work in that position. The complicated &quot;NOT EXISTS&quot; subquery is the magic that figures out whether or not each candidate &quot;s&quot; string is a valid sudoku puzzle or not.</source>
          <target state="translated">솔버는 &quot;x&quot;재귀 테이블에 새 항목을 추가하여 작동합니다. 이전 항목이 주어지면 재귀 선택은 실제로 해당 위치에서 작동하는 1에서 9 사이의 모든 값으로 단일 새 위치를 채우려 고합니다. 복잡한 &quot;NOT EXISTS&quot;하위 쿼리는 각 후보 &quot;s&quot;문자열이 유효한 스도쿠 퍼즐인지 아닌지를 알아내는 마법입니다.</target>
        </trans-unit>
        <trans-unit id="a81e5007b5735cbaaaf41fe92b085a6bb28859ca" translate="yes" xml:space="preserve">
          <source>The sorter can use auxiliary helper threads to increase real-time response. This feature is off by default and may be enabled using the &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command or the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option.</source>
          <target state="translated">분류기는 보조 헬퍼 스레드를 사용하여 실시간 응답을 증가시킬 수 있습니다. 이 기능은 기본적으로 해제되어 있으며 &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; 명령 또는 &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; 컴파일 타임 옵션을 사용하여 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3082f533e58c712999cbf940673f567d8a29017" translate="yes" xml:space="preserve">
          <source>The soundex(X) function returns a string that is the soundex encoding of the string X. The string &quot;?000&quot; is returned if the argument is NULL or contains no ASCII alphabetic characters. This function is omitted from SQLite by default. It is only available if the &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; compile-time option is used when SQLite is built.</source>
          <target state="translated">soundex (X) 함수는 문자열 X의 soundex 인코딩 인 문자열을 반환합니다. 인수가 NULL이거나 ASCII 알파벳 문자를 포함하지 않으면 &quot;? 000&quot;문자열이 반환됩니다. 이 기능은 기본적으로 SQLite에서 생략됩니다. SQLite가 빌드 될 때 &lt;a href=&quot;compile#soundex&quot;&gt;SQLITE_SOUNDEX&lt;/a&gt; 컴파일 타임 옵션이 사용 된 경우 에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="9611e60fec986c004f40bb3986af444fd02497aa" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">소스 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 백업 작업이 진행 중이거나 초기화되는 동안 다른 목적으로 응용 프로그램에서 사용될 수 있습니다. SQLite가 스레드 세이프 데이터베이스 연결을 지원하도록 컴파일되고 구성되면 소스 데이터베이스 연결이 다른 스레드 내에서 동시에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d46770cf519d64fb4869e93bb4ebad2a0d214ebb" translate="yes" xml:space="preserve">
          <source>The source &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; may be used by the application for other purposes while a backup operation is underway or being initialized. If SQLite is compiled and configured to support threadsafe database connections, then the source database connection may be used concurrently from within other threads.</source>
          <target state="translated">소스 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 백업 작업이 진행 중이거나 초기화되는 동안 다른 목적으로 응용 프로그램에서 사용될 수 있습니다. SQLite가 스레드 세이프 데이터베이스 연결을 지원하도록 컴파일되고 구성되면 소스 데이터베이스 연결이 다른 스레드 내에서 동시에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb98bce78cf336a453aacfd68f1f2a70ccf1bb9e" translate="yes" xml:space="preserve">
          <source>The source code files for other SQL database engines typically begin with a comment describing your legal rights to view and copy that file. The SQLite source code contains no license since it is not governed by copyright. Instead of a license, the SQLite source code offers a blessing:</source>
          <target state="translated">다른 SQL 데이터베이스 엔진의 소스 코드 파일은 일반적으로 해당 파일을보고 복사 할 수있는 법적 권한을 설명하는 주석으로 시작합니다. SQLite 소스 코드에는 저작권이 적용되지 않으므로 라이센스가 없습니다. 라이센스 대신 SQLite 소스 코드는 다음과 같은 축복을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b230daf41ab11e7921fa2a959263c09c6fe7e609" translate="yes" xml:space="preserve">
          <source>The source code for Geopoly is included in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is not included in the library unless the &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">Geopoly의 소스 코드에 포함되어 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 있지만하지 않는 라이브러리에 포함되지 않습니다 &lt;a href=&quot;compile#enable_geopoly&quot;&gt;-DSQLITE_ENABLE_GEOPOLY&lt;/a&gt; 컴파일시 옵션이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce563d47e369284dcc9eb90d209f5fe50c9d87d" translate="yes" xml:space="preserve">
          <source>The source code for SQLite is in the public domain. No claim of copyright is made on any part of the core source code. (The documentation and test code is a different matter - some sections of documentation and test logic are governed by open-source licenses.) All contributors to the SQLite core software have signed affidavits specifically disavowing any copyright interest in the code. This means that anybody is able to legally do anything they want with the SQLite source code.</source>
          <target state="translated">SQLite의 소스 코드는 공개 도메인에 있습니다. 핵심 소스 코드의 어느 부분에도 저작권에 대한 주장이 없습니다. (문서와 테스트 코드는 다른 문제입니다. 문서와 테스트 로직의 일부 섹션은 오픈 소스 라이센스에 의해 관리됩니다.) SQLite 핵심 소프트웨어의 모든 기고자들은 코드에 대한 저작권에 대한 관심을 불허하는 진술서에 서명했습니다. 이는 누구나 SQLite 소스 코드로 원하는 것을 합법적으로 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1cfec4458134c689073b56a3f124a05cfee319a4" translate="yes" xml:space="preserve">
          <source>The source code in public SQLite releases uses unix line endings (ASCII code 10: &quot;newline&quot; only, NL) and spaces instead of tabs. If you will be changing the line ending to windows-style line endings (ASCII codes 13, 10: &quot;carriage-return&quot; and &quot;newline&quot;; CR-NL) or if you will be changing space indents into tab indents, &lt;b&gt;make that change now&lt;/b&gt; before you check in the baseline. The merging process will only work well if the differences between the public and the private branches are minimal. If every single line of the source file is changed in the private branch because you changed from NL to CR-NL line endings, then the merge steps will not work correctly.</source>
          <target state="translated">공개 SQLite 릴리스의 소스 코드는 탭 대신 유닉스 줄 끝 (ASCII 코드 10 : &quot;newline&quot;만, NL)과 공백을 사용합니다. 줄 끝을 Windows 스타일 줄 끝 (ASCII 코드 13, 10 : &quot;캐리지 리턴&quot;및 &quot;줄 바꾸기&quot;; CR-NL)으로 변경하거나 공백 들여 쓰기를 탭 들여 쓰기로 변경하려는 경우 &lt;b&gt;변경하십시오. 지금&lt;/b&gt; 당신은베이스 라인에서 확인하기 전에. 합병 과정은 공공 지점과 개인 지점의 차이가 최소화 된 경우에만 잘 작동합니다. NL에서 CR-NL 행 끝으로 변경되어 소스 파일의 모든 단일 행이 개인 브랜치에서 변경되면 병합 단계가 올바르게 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c71fe30151d8d1ffe822e83fe610e421f8822069" translate="yes" xml:space="preserve">
          <source>The source code module that implements the spellfix1 virtual table also implements several SQL functions that might be useful to applications that employ spellfix1 or for testing or diagnostic work while developing applications that use spellfix1. The following auxiliary functions are available:</source>
          <target state="translated">spellfix1 가상 테이블을 구현하는 소스 코드 모듈은 spellfix1을 사용하는 응용 프로그램 또는 spellfix1을 사용하는 응용 프로그램을 개발하는 동안 테스트 또는 진단 작업에 유용 할 수있는 몇 가지 SQL 함수도 구현합니다. 다음과 같은 보조 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e0d7a5506cbf178b35ec85914ad01a3f38017c" translate="yes" xml:space="preserve">
          <source>The source code to SQLite is designed to be readable and accessible to the average programmer. All procedures and data structures and many automatic variables are carefully commented with useful information about what they do. Boilerplate commenting is omitted.</source>
          <target state="translated">SQLite의 소스 코드는 일반 프로그래머가 읽고 액세스 할 수 있도록 설계되었습니다. 모든 프로 시저와 데이터 구조 및 많은 자동 변수에는 수행 할 작업에 대한 유용한 정보가 포함되어 있습니다. 상용구 주석 처리가 생략되었습니다.</target>
        </trans-unit>
        <trans-unit id="042c70a1cba19758906aae3ec84cad7dc8c53383" translate="yes" xml:space="preserve">
          <source>The source code to the SQLite R*Tree module is included as part of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; but is disabled by default. To enable the R*Tree module, simply compile with the &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C-preprocessor macro defined. With many compilers, this is accomplished by adding the option &quot;-DSQLITE_ENABLE_RTREE=1&quot; to the compiler command-line.</source>
          <target state="translated">SQLite R * Tree 모듈의 소스 코드는 &lt;a href=&quot;amalgamation&quot;&gt;통합의&lt;/a&gt; 일부로 포함되어 있지만 기본적으로 비활성화되어 있습니다. R * Tree 모듈을 사용하려면 &lt;a href=&quot;compile#enable_rtree&quot;&gt;SQLITE_ENABLE_RTREE&lt;/a&gt; C 프리 프로세서 매크로가 정의 된 상태로 컴파일하십시오 . 많은 컴파일러의 경우 컴파일러 명령 줄에 &quot;-DSQLITE_ENABLE_RTREE = 1&quot;옵션을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a40cbeb8ac52569bca99e948856ab4db846ed02b" translate="yes" xml:space="preserve">
          <source>The source code to the bytecode engine is in the &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; source file. The &lt;a href=&quot;opcode#codes&quot;&gt;opcode definitions&lt;/a&gt; in this document are derived from comments in that source file. The source code comments are the canonical source of information about the bytecode engine. When in doubt, refer to the source code.</source>
          <target state="translated">바이트 코드 엔진의 소스 코드는 &lt;a href=&quot;http://www.sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; 소스 파일에 있습니다. 이 문서 의 &lt;a href=&quot;opcode#codes&quot;&gt;opcode 정의&lt;/a&gt; 는 해당 소스 파일의 주석에서 파생됩니다. 소스 코드 주석은 바이트 코드 엔진에 대한 정식 정보 소스입니다. 확실치 않은 경우 소스 코드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="013177e363c21284dd8426d7c41bb413bf325a0a" translate="yes" xml:space="preserve">
          <source>The source code to the software that runs the checklists is stored in its own Fossil repository at &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt;.</source>
          <target state="translated">점검 목록을 실행하는 소프트웨어의 소스 코드는 &lt;a href=&quot;https://www.sqlite.org/checklistapp&quot;&gt;https://www.sqlite.org/checklistapp&lt;/a&gt; 의 자체 Fossil 저장소에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="79b8e8d26e2fd4c36bb8b15bd366cedd02031771" translate="yes" xml:space="preserve">
          <source>The source code to the sqlite3 command line interface is in a single file named &quot;shell.c&quot;. The shell.c source file is generated from other sources, but most of the code for shell.c can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src/shell.c.in&lt;/a&gt;. (Regenerate shell.c by typing &quot;make shell.c&quot; from the canonical source tree.) &lt;a href=&quot;howtocompile&quot;&gt;Compile&lt;/a&gt; the shell.c file (together with the &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 library source code&lt;/a&gt;) to generate the executable. For example:</source>
          <target state="translated">sqlite3 명령 행 인터페이스의 소스 코드는 &quot;shell.c&quot;라는 단일 파일에 있습니다. shell.c 소스 파일은 다른 소스에서 생성되지만 대부분의 shell.c 코드는 &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;src / shell.c.in에&lt;/a&gt; 있습니다. 표준 소스 트리에서 &quot;make shell.c&quot;를 입력하여 shell.c를 재생성하십시오. &lt;a href=&quot;amalgamation&quot;&gt;sqlite3 라이브러리 소스 코드&lt;/a&gt; 와 함께 shell.c 파일을 &lt;a href=&quot;howtocompile&quot;&gt;컴파일&lt;/a&gt; 하여 실행 파일 을 생성하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3baebed042eebfba10dcbc501e7f4785bd1f6d07" translate="yes" xml:space="preserve">
          <source>The source file and entry point are named for &quot;unionvtab&quot; instead of &quot;swarmvtab&quot;. Unionvtab is a &lt;a href=&quot;unionvtab&quot;&gt;separately documented&lt;/a&gt; virtual table that is bundled with swarmvtab.</source>
          <target state="translated">소스 파일과 진입 점은 &quot;swarmvtab&quot;대신 &quot;unionvtab&quot;으로 이름이 지정됩니다. Unionvtab은 swarmvtab 과 함께 번들로 제공되는 &lt;a href=&quot;unionvtab&quot;&gt;별도로 문서화 된&lt;/a&gt; 가상 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="f3fba365763538ecbddb6c57bd7009fd058f9084" translate="yes" xml:space="preserve">
          <source>The special &quot;:memory:&quot; filename also works when using &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI 파일&lt;/a&gt; 이름을 사용할 때 특수한 &quot;: memory :&quot;파일 이름도 작동합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e94ff833d41c9d30c15767ac9e7aeb85daf442aa" translate="yes" xml:space="preserve">
          <source>The special UPSERT processing happens only for uniqueness constraint on the table that is receiving the INSERT. A &quot;uniqueness constraint&quot; is an explicit UNIQUE or PRIMARY KEY constraint within the CREATE TABLE statement, or a &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt;. UPSERT does not intervene for failed NOT NULL or foreign key constraints or for constraints that are implemented using triggers.</source>
          <target state="translated">특수 UPSERT 처리는 INSERT를 수신하는 테이블에서 고유성 제한 조건에 대해서만 발생합니다. &quot;고유성 제약 조건&quot;은 CREATE TABLE 문 내의 명시 적 UNIQUE 또는 PRIMARY KEY 제약 조건 또는 &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;고유 인덱스&lt;/a&gt; 입니다. UPSERT는 실패한 NOT NULL 또는 외래 키 제약 조건이나 트리거를 사용하여 구현 된 제약 조건에 개입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e94e3f68bdf7fc07fc0dcd878c089797a3fe9a2" translate="yes" xml:space="preserve">
          <source>The special filename &quot;:memory:&quot; can be used anywhere that a database filename is permitted. For example, it can be used as the</source>
          <target state="translated">데이터베이스 파일 이름이 허용되는 모든 위치에서 특수 파일 이름 &quot;: memory :&quot;를 사용할 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="dff68709141a31a267598fa549dc38cfbd61c946" translate="yes" xml:space="preserve">
          <source>The special processing for opening ZIP archives is a trick of the command-line shell, not the core SQLite library. So if you want to open a ZIP archive as a database in your application, you will need to activate the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; module then run an appropriate &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement.</source>
          <target state="translated">ZIP 아카이브를 열기위한 특수 처리는 핵심 SQLite 라이브러리가 아닌 명령 줄 셸의 트릭입니다. 따라서 애플리케이션에서 ZIP 아카이브를 데이터베이스로 열려면 &lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블&lt;/a&gt; 모듈 을 활성화 한 다음 적절한 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문 을 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="29bca994e11cb6f841a93aac5cdb8471376e38df" translate="yes" xml:space="preserve">
          <source>The specified column of row iRow contains a value that is not a TEXT or BLOB value,</source>
          <target state="translated">iRow 행의 지정된 열에 TEXT 또는 BLOB 값이 아닌 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e48e6df6f51c35512fa45acc8a0e8a634c95f8" translate="yes" xml:space="preserve">
          <source>The speedtest1.c program is updated from time to time as the SQLite developers' understanding of what constitutes &quot;typical&quot; usage evolves.</source>
          <target state="translated">speedtest1.c 프로그램은 SQLite 개발자가 &quot;일반적인&quot;사용법에 대한 이해가 발전함에 따라 때때로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="5446f248e6916745d646dc3f5e88e893b3ad00cc" translate="yes" xml:space="preserve">
          <source>The speedtest1.c workload that is being measured tries to be representative of a wide range of typical uses of SQLite. But every application is different. The speedtest1.c workload might not be a good proxy for the kinds of activities performed by some applications. The SQLite developers are constantly working to improve the speedtest1.c program, to make it a better proxy for actual SQLite usage. Community feedback is welcomed.</source>
          <target state="translated">측정되는 speedtest1.c 워크로드는 SQLite의 광범위한 일반적인 사용을 나타내려고합니다. 그러나 모든 응용 프로그램은 다릅니다. speedtest1.c 작업량은 일부 응용 프로그램에서 수행되는 활동 종류에 적합한 프록시가 아닐 수 있습니다. SQLite 개발자는 speedtest1.c 프로그램을 개선하여 실제 SQLite 사용을 위해 더 나은 프록시를 만들기 위해 지속적으로 노력하고 있습니다. 커뮤니티 피드백을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="92167de554e681259504f6e2f3edf942b7026bd6" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table creates a single shadow table named &quot;%_vocab&quot; (where the % is replaced by the name of the virtual table; Ex: &quot;demo_vocab&quot; for the &quot;demo&quot; virtual table). the shadow table contains the following columns:</source>
          <target state="translated">spellfix1 가상 테이블은 &quot;% _vocab&quot;라는 단일 새도우 테이블을 작성합니다 (여기서 %는 가상 테이블의 이름으로 대체됩니다 (예 : &quot;demo&quot;가상 테이블의 경우 &quot;demo_vocab&quot;)). 새도우 테이블에는 다음 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9097157fe13f14b48b89617ee87aed62da83c73" translate="yes" xml:space="preserve">
          <source>The spellfix1 virtual table uses editdist3 if the &quot;edit_cost_table=TABLE&quot; option is specified as an argument when the spellfix1 virtual table is created. But editdist3 can also be tested directly using the built-in &quot;editdist3()&quot; SQL function. The editdist3() SQL function has 3 forms:</source>
          <target state="translated">spellfix1 가상 테이블이 작성 될 때 &quot;edit_cost_table = TABLE&quot;옵션이 인수로 지정된 경우 spellfix1 가상 테이블은 editdist3을 사용합니다. 그러나 내장 &quot;editdist3 ()&quot;SQL 함수를 사용하여 editdist3을 직접 테스트 할 수도 있습니다. editdist3 () SQL 함수는 3 가지 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e416e23f51996e4d87d84d45407db4bd482280e4" translate="yes" xml:space="preserve">
          <source>The sqlar_compress(X) function attempts to compress a copy of the string or blob X using the &lt;a href=&quot;https://zlib.net/&quot;&gt;Default&lt;/a&gt; algorithm and returns the result as a blob. If the input X is incompressible, then a copy of X is returned. This routine is used when inserting content into an SQLite Archive.</source>
          <target state="translated">sqlar_compress (X) 함수는 &lt;a href=&quot;https://zlib.net/&quot;&gt;기본&lt;/a&gt; 알고리즘을 사용하여 문자열 또는 Blob X의 사본을 압축하려고 시도 하고 결과를 Blob으로 리턴합니다. 입력 X를 압축 할 수 없으면 X의 사본이 리턴됩니다. 이 루틴은 컨텐츠를 SQLite Archive에 삽입 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0c132e268d7082089985d58b1716bee78c9b6c72" translate="yes" xml:space="preserve">
          <source>The sqlar_uncompress(Y,SZ) function will undo the compression accomplished by sqlar_compress(X). The Y parameter is the compressed content (the output from a prior call to sqlar_compress()) and SZ is the original uncompressed size of the input X that generated Y. If SZ is less than or equal to the size of Y, that indicates that no compression occurred, and so sqlar_uncompress(Y,SZ) returns a copy of Y. Otherwise, sqlar_uncompress(Y,SZ) runs the Inflate algorithm on Y to uncompress it and restore it to its original form and returns the uncompressed content. This routine is used when extracting content from an SQLite Archive.</source>
          <target state="translated">sqlar_uncompress (Y, SZ) 함수는 sqlar_compress (X)에 의해 수행 된 압축을 취소합니다. Y 매개 변수는 압축 된 컨텐츠 (sqlar_compress ()에 대한 이전 호출의 출력)이고 SZ는 Y를 생성 한 입력 X의 원래 압축되지 않은 크기입니다. SZ가 Y의 크기보다 작거나 같으면 다음을 나타냅니다. 압축이 발생하지 않았으므로 sqlar_uncompress (Y, SZ)는 Y의 사본을 리턴합니다. 그렇지 않으면 sqlar_uncompress (Y, SZ)는 Y에서 팽창 알고리즘을 실행하여 압축을 풀고 원래 형식으로 복원하고 압축되지 않은 컨텐츠를 리턴합니다. 이 루틴은 SQLite Archive에서 컨텐츠를 추출 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9894bd2027e1ec7fe1defc073eb794af8cfcddba" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility does not (currently) display differences in &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGERs&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt;.</source>
          <target state="translated">sqldiff.exe 유틸리티는 현재 &lt;a href=&quot;lang_createtrigger&quot;&gt;TRIGGER&lt;/a&gt; 또는 &lt;a href=&quot;lang_createview&quot;&gt;VIEW의&lt;/a&gt; 차이점을 표시하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1eec35831f2ddb18882fbe495fb78b6e88f27f70" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility is unable to compute differences for rowid tables for which the rowid is inaccessible. An example of a table with an inaccessible rowid is:</source>
          <target state="translated">sqldiff.exe 유틸리티는 rowid에 액세스 할 수없는 rowid 테이블의 차이를 계산할 수 없습니다. 액세스 할 수없는 rowid가있는 테이블의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="199f0fae6d132ab01eeef495a83df7f5456338b1" translate="yes" xml:space="preserve">
          <source>The sqldiff.exe utility works by finding rows in the source and destination that are logical &quot;pairs&quot;. The default behavior is to treat two rows as pairs if they are in tables with the same name and they have the same &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;, or in the case of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table if they have the same &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt;. Any differences in the content of paired rows are output as UPDATEs. Rows in the source database that could not be paired are output as DELETEs. Rows in the destination database that could not be paired are output as INSERTs.</source>
          <target state="translated">sqldiff.exe 유틸리티는 소스 및 대상에서 논리적 &quot;쌍&quot;인 행을 찾아서 작동합니다. 기본 동작은 두 개의 행이 이름이 같은 테이블에 있고 동일한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 갖는 경우 또는 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블의 경우 동일한 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY를&lt;/a&gt; 갖는 경우 쌍으로 취급 하는 것 입니다. 쌍을 이루는 행 내용의 차이는 UPDATE로 출력됩니다. 쌍을 이룰 수없는 소스 데이터베이스의 행은 DELETE로 출력됩니다. 페어링 할 수없는 대상 데이터베이스의 행은 INSERT로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="5a94a70315a765a01576195e900e88922987242a" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in 14 different formats:</source>
          <target state="translated">sqlite3 프로그램은 14 개의 다른 형식으로 쿼리 결과를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a33930cce71afaf2bac4391a7d92f2102fe6799" translate="yes" xml:space="preserve">
          <source>The sqlite3 program is able to show the results of a query in eight different formats: &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;, and &quot;tcl&quot;. You can use the &quot;.mode&quot; dot command to switch between these output formats.</source>
          <target state="translated">sqlite3 프로그램은 &quot;csv&quot;, &quot;column&quot;, &quot;html&quot;, &quot;insert&quot;, &quot;line&quot;, &quot;list&quot;, &quot;quote&quot;, &quot;tabs&quot;및 8 가지 형식으로 쿼리 결과를 표시 할 수 있습니다. &quot;tcl&quot;. &quot;.mode&quot;도트 명령을 사용하여 이러한 출력 형식간에 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c934dde95758c5fad9d43c84ef7f4c41bf3fe114" translate="yes" xml:space="preserve">
          <source>The sqlite3 program provides several convenience commands that are useful for looking at the schema of the database. There is nothing that these commands do that cannot be done by some other means. These commands are provided purely as a shortcut.</source>
          <target state="translated">sqlite3 프로그램은 데이터베이스의 스키마를 보는 데 유용한 여러 편의 명령을 제공합니다. 다른 방법으로는 수행 할 수없는 명령이 없습니다. 이러한 명령은 순전히 바로 가기로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d730ebfc68ed44661fe9aaa4784f842bff23a6ec" translate="yes" xml:space="preserve">
          <source>The sqlite3_aggregate_context(C,N) routine returns a NULL pointer when first called if N is less than or equal to zero or if a memory allocate error occurs.</source>
          <target state="translated">sqlite3_aggregate_context (C, N) 루틴은 N이 0보다 작거나 같거나 메모리 할당 오류가 발생한 경우 처음 호출 될 때 NULL 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a781b80076608933fb39f35323ee417edf53e9fb" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer utility program is updated to provide better descriptions and to compute a more accurate estimate for &quot;Non-sequential pages&quot;</source>
          <target state="translated">sqlite3_analyzer 유틸리티 프로그램은보다 나은 설명을 제공하고 &quot;비 순차 페이지&quot;에 대한보다 정확한 추정치를 계산하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="cea6cec9b3cecf3cdb8b21b8c439ffacaf7e4757" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe Utility Program</source>
          <target state="translated">sqlite3_analyzer.exe 유틸리티 프로그램</target>
        </trans-unit>
        <trans-unit id="08064e181ad262ed7b2155684ee88c71ec311b40" translate="yes" xml:space="preserve">
          <source>The sqlite3_analyzer.exe utility is updated to report the depth of each btree and to show the average fanout for indexes and WITHOUT ROWID tables.</source>
          <target state="translated">sqlite3_analyzer.exe 유틸리티는 각 btree의 깊이를보고하고 인덱스 및 WITHOUT ROWID 테이블의 평균 팬 아웃을 표시하도록 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="69ea749b99043a4585c42b36d581974b4510bba7" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup 객체는 진행중인 온라인 백업 작업에 대한 상태 정보를 기록합니다. sqlite3_backup 객체 호출에 의해 생성 &lt;a href=&quot;#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; 및 호출에 의해 파괴 &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5c92c4105199925092609d2d9f802d1fa55672" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup object records state information about an ongoing online backup operation. The sqlite3_backup object is created by a call to &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init()&lt;/a&gt; and is destroyed by a call to &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup 객체는 진행중인 온라인 백업 작업에 대한 상태 정보를 기록합니다. sqlite3_backup 객체 호출에 의해 생성 &lt;a href=&quot;backup_finish#sqlite3backupinit&quot;&gt;sqlite3_backup_init ()&lt;/a&gt; 및 호출에 의해 파괴 &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;sqlite3_backup_finish ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db586a6cde9f4397b1aba32074e60460ba79310a" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() and sqlite3_backup_pagecount() APIs report values stored by the previous call to sqlite3_backup_step(), they do not actually inspect the source database file. This means that if the source database is written to by another thread or process after the call to sqlite3_backup_step() returns but before the values returned by sqlite3_backup_remaining() and sqlite3_backup_pagecount() are used, the values may be technically incorrect. This is not usually a problem.</source>
          <target state="translated">sqlite3_backup_remaining () 및 sqlite3_backup_pagecount () API는 sqlite3_backup_step ()에 대한 이전 호출로 저장된 값을보고하지만 실제로 소스 데이터베이스 파일을 검사하지는 않습니다. 이는 sqlite3_backup_step ()에 대한 호출이 리턴 된 후 sqlite3_backup_remaining () 및 sqlite3_backup_pagecount ()에 의해 리턴 된 값이 사용되기 전에 다른 스레드 또는 프로세스에 의해 소스 데이터베이스가 기록되는 경우 기술적으로 올바르지 않을 수 있습니다. 이것은 일반적으로 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab13e83a5eec05a800456f808bd2ed14f96ad7d8" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_remaining() routine returns the number of pages still to be backed up at the conclusion of the most recent sqlite3_backup_step(). The sqlite3_backup_pagecount() routine returns the total number of pages in the source database at the conclusion of the most recent sqlite3_backup_step(). The values returned by these functions are only updated by sqlite3_backup_step(). If the source database is modified in a way that changes the size of the source database or the number of pages remaining, those changes are not reflected in the output of sqlite3_backup_pagecount() and sqlite3_backup_remaining() until after the next sqlite3_backup_step().</source>
          <target state="translated">sqlite3_backup_remaining () 루틴은 가장 최근의 sqlite3_backup_step ()이 끝날 때 여전히 백업 될 페이지 수를 리턴합니다. sqlite3_backup_pagecount () 루틴은 가장 최근의 sqlite3_backup_step ()이 끝날 때 소스 데이터베이스의 총 페이지 수를 리턴합니다. 이 함수에 의해 반환되는 값은 sqlite3_backup_step ()에 의해서만 업데이트됩니다. 소스 데이터베이스의 크기 나 남은 페이지 수를 변경하는 방식으로 소스 데이터베이스를 수정 한 경우 다음 sqlite3_backup_step () 이후까지 변경 사항이 sqlite3_backup_pagecount () 및 sqlite3_backup_remaining ()의 출력에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="027c7809f8a158ea3a080d548eaba037441f7cc5" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">sqlite3_backup_step ()은 다음과 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;같은&lt;/a&gt; 경우 SQLITE_READONLY를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44bfd22dba6c2a0335c1b72cfe8865a0ed15325c" translate="yes" xml:space="preserve">
          <source>The sqlite3_backup_step() might return &lt;a href=&quot;../rescode#readonly&quot;&gt;SQLITE_READONLY&lt;/a&gt; if</source>
          <target state="translated">sqlite3_backup_step ()은 다음과 &lt;a href=&quot;../rescode#readonly&quot;&gt;같은&lt;/a&gt; 경우 SQLITE_READONLY를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2f8db9336dd78e8265a2d46cc59a9e446011dc7" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ * 루틴 은 성공시 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴 하거나 문제가 &lt;a href=&quot;rescode&quot;&gt;발생&lt;/a&gt; 하면 오류 코드를 리턴 합니다. 문자열 또는 BLOB의 크기가 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) 또는 &lt;a href=&quot;limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 에 의해 부과 된 한계를 초과하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; 가 리턴 될 수 있습니다 . 매개 변수 색인이 범위를 벗어난 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_RANGE&lt;/a&gt; 가 리턴됩니다. malloc ()이 실패하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="eb0da7fe06be85118ba3dab99ff46185b6777bbe" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_* routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success or an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if anything goes wrong. &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; might be returned if the size of a string or BLOB exceeds limits imposed by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;) or &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt;. &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned if the parameter index is out of range. &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; is returned if malloc() fails.</source>
          <target state="translated">sqlite3_bind_ * 루틴 은 성공시 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴 하거나 문제가 &lt;a href=&quot;../rescode&quot;&gt;발생&lt;/a&gt; 하면 오류 코드를 리턴 합니다. 문자열 또는 BLOB의 크기가 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt; ) 또는 &lt;a href=&quot;../limits#max_length&quot;&gt;SQLITE_MAX_LENGTH&lt;/a&gt; 에 의해 부과 된 한계를 초과하면 &lt;a href=&quot;../rescode#toobig&quot;&gt;SQLITE_TOOBIG&lt;/a&gt; 가 리턴 될 수 있습니다 . 매개 변수 색인이 범위를 벗어난 경우 &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; 가 리턴됩니다. malloc ()이 실패하면 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6f71713542739e9593b1adb467245384ef671786" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name (P, N) 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 에서 N 번째 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 의 이름을 리턴합니다 . P &quot;? NNN&quot;또는 &quot;: AAA&quot;또는 &quot;@AAA&quot;또는 &quot;$ AAA&quot;형식의 SQL 매개 변수는 이름은 각각 문자열 &quot;? NNN&quot;또는 &quot;: AAA&quot;또는 &quot;@AAA&quot;또는 &quot;$ AAA&quot;입니다. 즉, 초기 &quot;:&quot;또는 &quot;$&quot;또는 &quot;@&quot;또는 &quot;?&quot; 이름의 일부로 포함됩니다. &quot;?&quot;형식의 매개 변수 다음 정수가 없으면 이름이 없으며 &quot;nameless&quot;또는 &quot;anonymous parameters&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="8f7478b82c93544aa582bd52cdb8be854dddfaed" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_parameter_name(P,N) interface returns the name of the N-th &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; in the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. SQL parameters of the form &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; have a name which is the string &quot;?NNN&quot; or &quot;:AAA&quot; or &quot;@AAA&quot; or &quot;$AAA&quot; respectively. In other words, the initial &quot;:&quot; or &quot;$&quot; or &quot;@&quot; or &quot;?&quot; is included as part of the name. Parameters of the form &quot;?&quot; without a following integer have no name and are referred to as &quot;nameless&quot; or &quot;anonymous parameters&quot;.</source>
          <target state="translated">sqlite3_bind_parameter_name (P, N) 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 에서 N 번째 &lt;a href=&quot;bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 의 이름을 리턴합니다. &quot;? NNN&quot;또는 &quot;: AAA&quot;또는 &quot;@AAA&quot;또는 &quot;$ AAA&quot;형식의 SQL 매개 변수는 이름은 각각 문자열 &quot;? NNN&quot;또는 &quot;: AAA&quot;또는 &quot;@AAA&quot;또는 &quot;$ AAA&quot;입니다. 즉, 초기 &quot;:&quot;또는 &quot;$&quot;또는 &quot;@&quot;또는 &quot;?&quot; 이름의 일부로 포함됩니다. &quot;?&quot;형식의 매개 변수 다음 정수가 없으면 이름이 없으며 &quot;nameless&quot;또는 &quot;anonymous parameters&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="2f7ba9ace88be98840180479bfcb11ff0ebe16ce" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer (S, I, P, T, D) 루틴은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; S 의 I 번째 매개 변수에 SQL 값 NULL이 있지만 T 유형의 포인터 P 와도 연관됩니다. D는 NULL입니다. P에 대한 소멸자 함수에 대한 포인터 또는 포인터. SQLite는 P 사용이 끝나면 P의 단일 인수로 소멸자 D를 호출합니다. T 매개 변수는 정적 문자열, 바람직하게는 문자열 리터럴이어야합니다. sqlite3_bind_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="658c91c6c69fa0e297b2600c0a7ae1e8d41b306a" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_pointer(S,I,P,T,D) routine causes the I-th parameter in &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S to have an SQL value of NULL, but to also be associated with the pointer P of type T. D is either a NULL pointer or a pointer to a destructor function for P. SQLite will invoke the destructor D with a single argument of P when it is finished using P. The T parameter should be a static string, preferably a string literal. The sqlite3_bind_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_bind_pointer (S, I, P, T, D) 루틴은 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; S 의 I 번째 매개 변수에 SQL 값 NULL이 있지만 T 유형의 포인터 P 와도 연관됩니다. D는 NULL입니다. P에 대한 소멸자 함수에 대한 포인터 또는 포인터. SQLite는 P 사용이 끝나면 P의 단일 인수로 소멸자 D를 호출합니다. T 매개 변수는 정적 문자열, 바람직하게는 문자열 리터럴이어야합니다. sqlite3_bind_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;../bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="6397a7b2569f0831356316d22abee5d260da2f56" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob () 루틴은 0으로 채워진 길이 N의 BLOB를 바인드합니다. zeroblob는 처리되는 동안 고정 된 양의 메모리 (크기를 보유하기위한 정수)를 사용합니다. Zeroblobs는 나중에 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;증분 BLOB I / O를&lt;/a&gt; 사용하여 내용을 작성하는 BLOB의 자리 표시 자 역할을합니다. 루틴을 합니다. zeroblob의 음수 값은 길이가 0 인 BLOB가됩니다.</target>
        </trans-unit>
        <trans-unit id="c43ef2df76e0304e4b4beb3c8e7c5dbefc82b96b" translate="yes" xml:space="preserve">
          <source>The sqlite3_bind_zeroblob() routine binds a BLOB of length N that is filled with zeroes. A zeroblob uses a fixed amount of memory (just an integer to hold its size) while it is being processed. Zeroblobs are intended to serve as placeholders for BLOBs whose content is later written using &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; routines. A negative value for the zeroblob results in a zero-length BLOB.</source>
          <target state="translated">sqlite3_bind_zeroblob () 루틴은 0으로 채워진 길이 N의 BLOB를 바인드합니다. zeroblob는 처리되는 동안 고정 된 양의 메모리 (크기를 보유하기위한 정수)를 사용합니다. Zeroblobs는 나중에 &lt;a href=&quot;blob_open&quot;&gt;증분 BLOB I / O를&lt;/a&gt; 사용하여 내용을 작성하는 BLOB의 자리 표시 자 역할을합니다. 루틴을 합니다. zeroblob의 음수 값은 길이가 0 인 BLOB가됩니다.</target>
        </trans-unit>
        <trans-unit id="3d2cce49ac08682bc109d88559efafcb5bc906c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler (D, X, P) 루틴은 다른 스레드 또는 프로세스가 테이블을 잠근 경우 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 와 연관된 데이터베이스 테이블에 액세스하려고 할 때마다 인수 P로 호출 될 수있는 콜백 함수 X를 설정합니다 . sqlite3_busy_handler () 인터페이스는 &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; 을 구현하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="d3363e5f93709d191e40f4d06f477acdab0e375e" translate="yes" xml:space="preserve">
          <source>The sqlite3_busy_handler(D,X,P) routine sets a callback function X that might be invoked with argument P whenever an attempt is made to access a database table associated with &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D when another thread or process has the table locked. The sqlite3_busy_handler() interface is used to implement &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;.</source>
          <target state="translated">sqlite3_busy_handler (D, X, P) 루틴은 다른 스레드 또는 프로세스가 테이블을 잠근 경우 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 와 연관된 데이터베이스 테이블에 액세스하려고 할 때마다 인수 P로 호출 될 수있는 콜백 함수 X를 설정합니다 . sqlite3_busy_handler () 인터페이스는 &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 및 &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; 을 구현하는 데 사용됩니다. .</target>
        </trans-unit>
        <trans-unit id="e8d93853c1f8ff5d06942fd5a08d82650ba96772" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close () 및 sqlite3_close_v2 () 루틴은 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; 객체의 소멸자입니다 . sqlite3_close () 및 sqlite3_close_v2 ()에 대한 호출 은 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3 인&lt;/a&gt; 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다. 객체가 성공적으로 삭제되고 모든 관련 리소스가 할당 해제 호출은 .</target>
        </trans-unit>
        <trans-unit id="c3b661e4a47ed928f3b7e88dd929f7831fe5385b" translate="yes" xml:space="preserve">
          <source>The sqlite3_close() and sqlite3_close_v2() routines are destructors for the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. Calls to sqlite3_close() and sqlite3_close_v2() return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object is successfully destroyed and all associated resources are deallocated.</source>
          <target state="translated">sqlite3_close () 및 sqlite3_close_v2 () 루틴은 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; 객체의 소멸자입니다 . sqlite3_close () 및 sqlite3_close_v2 ()에 대한 호출 은 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3 인&lt;/a&gt; 경우 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다. 객체가 성공적으로 삭제되고 모든 관련 리소스가 할당 해제 호출은 .</target>
        </trans-unit>
        <trans-unit id="2e35c3e04c8fe7269b95a0494cefdd5cde7acf02" translate="yes" xml:space="preserve">
          <source>The sqlite3_collation_needed() routine registers a callback which the database engine will invoke if it encounters an unknown collating sequence. The callback can lookup an appropriate comparison function and invoke sqlite_3_create_collation() as needed. The fourth parameter to the callback is the name of the collating sequence in UTF-8. For sqlite3_collation_need16() the callback sends the collating sequence name in UTF-16 host byte order.</source>
          <target state="translated">sqlite3_collation_needed () 루틴은 알 수없는 조합 순서가 발생하면 데이터베이스 엔진이 호출 할 콜백을 등록합니다. 콜백은 적절한 비교 함수를 조회하고 필요에 따라 sqlite_3_create_collation ()을 호출 할 수 있습니다. 콜백에 대한 네 번째 매개 변수는 UTF-8의 조합 순서 이름입니다. sqlite3_collation_need16 ()의 경우 콜백은 조합 시퀀스 이름을 UTF-16 호스트 바이트 순서로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="289668a545984e8fa7c4b426fa20f850363028a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_decltype() routine returns text which is the declared type of the column in the CREATE TABLE statement. For an expression, the return type is an empty string. sqlite3_column_name() returns the name of the Nth column. sqlite3_column_bytes() returns the number of bytes in a column that has type BLOB or the number of bytes in a TEXT string with UTF-8 encoding. sqlite3_column_bytes16() returns the same value for BLOBs but for TEXT strings returns the number of bytes in a UTF-16 encoding. sqlite3_column_blob() return BLOB data. sqlite3_column_text() return TEXT data as UTF-8. sqlite3_column_text16() return TEXT data as UTF-16. sqlite3_column_int() return INTEGER data in the host machines native integer format. sqlite3_column_int64() returns 64-bit INTEGER data. Finally, sqlite3_column_double() return floating point data.</source>
          <target state="translated">sqlite3_column_decltype () 루틴은 CREATE TABLE 문에서 열의 선언 된 유형 인 텍스트를 리턴합니다. 표현식의 경우 리턴 유형은 빈 문자열입니다. sqlite3_column_name ()은 N 번째 열의 이름을 반환합니다. sqlite3_column_bytes ()는 BLOB 유형을 가진 열의 바이트 수 또는 UTF-8 인코딩을 사용하는 TEXT 문자열의 바이트 수를 리턴합니다. sqlite3_column_bytes16 ()은 BLOB에 대해 동일한 값을 반환하지만 TEXT 문자열에 대해서는 UTF-16 인코딩의 바이트 수를 반환합니다. sqlite3_column_blob ()는 BLOB 데이터를 반환합니다. sqlite3_column_text ()는 TEXT 데이터를 UTF-8로 반환합니다. sqlite3_column_text16 ()은 TEXT 데이터를 UTF-16으로 반환합니다. sqlite3_column_int ()는 호스트 시스템 고유 정수 형식으로 INTEGER 데이터를 리턴합니다. sqlite3_column_int64 ()는 64 비트 INTEGER 데이터를 리턴합니다. 마지막으로 sqlite3_column_double ()은 부동 소수점 데이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a9b38d21f857b4d104b01ccf828564edcab9302b" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type () 루틴 은 결과 열의 초기 데이터 유형에 대한 데이터 유형 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;코드&lt;/a&gt; 를 리턴합니다 . 리턴 된 값은 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; 중 하나입니다. . sqlite3_column_type ()의 반환 값을 사용하여 처음 6 개의 인터페이스 중 열 값을 추출하는 데 사용할 인터페이스를 결정할 수 있습니다. sqlite3_column_type ()에 의해 리턴 된 값은 해당 값에 대해 자동 유형 변환이 발생하지 않은 경우에만 의미가 있습니다. 형식 변환 후 sqlite3_column_type () 호출 결과는 정의되지 않았지만 무해합니다. 이후 버전의 SQLite는 형식 변환 후 sqlite3_column_type ()의 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87c623fe2ec1f08f5218d69ec07d1b6f1fe406e" translate="yes" xml:space="preserve">
          <source>The sqlite3_column_type() routine returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial data type of the result column. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. The return value of sqlite3_column_type() can be used to decide which of the first six interface should be used to extract the column value. The value returned by sqlite3_column_type() is only meaningful if no automatic type conversions have occurred for the value in question. After a type conversion, the result of calling sqlite3_column_type() is undefined, though harmless. Future versions of SQLite may change the behavior of sqlite3_column_type() following a type conversion.</source>
          <target state="translated">sqlite3_column_type () 루틴 은 결과 열의 초기 데이터 유형에 대한 데이터 유형 &lt;a href=&quot;c_blob&quot;&gt;코드&lt;/a&gt; 를 리턴합니다 . 리턴 된 값은 &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; 또는 &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; 중 하나입니다. . sqlite3_column_type ()의 반환 값을 사용하여 처음 6 개의 인터페이스 중 열 값을 추출하는 데 사용할 인터페이스를 결정할 수 있습니다. sqlite3_column_type ()에 의해 리턴 된 값은 해당 값에 대해 자동 유형 변환이 발생하지 않은 경우에만 의미가 있습니다. 형식 변환 후 sqlite3_column_type () 호출 결과는 정의되지 않았지만 무해합니다. 이후 버전의 SQLite는 형식 변환 후 sqlite3_column_type ()의 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80c9429e83e0f6600057106ffc072b05d6e8df14" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;../lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook () 인터페이스는 트랜잭션이 &lt;a href=&quot;../lang_transaction&quot;&gt;커밋&lt;/a&gt; 될 때마다 호출 될 콜백 함수를 등록합니다 . 동일한 데이터베이스 연결에 대해 sqlite3_commit_hook ()에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다. sqlite3_rollback_hook () 인터페이스는 트랜잭션이 &lt;a href=&quot;../lang_transaction&quot;&gt;롤백&lt;/a&gt; 될 때마다 호출 될 콜백 함수를 등록합니다. . 동일한 데이터베이스 연결에 대해 sqlite3_rollback_hook ()에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다. pArg 인수는 콜백으로 전달됩니다. 커밋 후크 함수의 콜백이 0이 아닌 값을 반환하면 커밋이 롤백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="c831f98581f1e28276e947cc54e55e8093cff2bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;committed&lt;/a&gt;. Any callback set by a previous call to sqlite3_commit_hook() for the same database connection is overridden. The sqlite3_rollback_hook() interface registers a callback function to be invoked whenever a transaction is &lt;a href=&quot;lang_transaction&quot;&gt;rolled back&lt;/a&gt;. Any callback set by a previous call to sqlite3_rollback_hook() for the same database connection is overridden. The pArg argument is passed through to the callback. If the callback on a commit hook function returns non-zero, then the commit is converted into a rollback.</source>
          <target state="translated">sqlite3_commit_hook () 인터페이스는 트랜잭션이 &lt;a href=&quot;lang_transaction&quot;&gt;커밋&lt;/a&gt; 될 때마다 호출 될 콜백 함수를 등록합니다 . 동일한 데이터베이스 연결에 대해 sqlite3_commit_hook ()에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다. sqlite3_rollback_hook () 인터페이스는 트랜잭션이 &lt;a href=&quot;lang_transaction&quot;&gt;롤백&lt;/a&gt; 될 때마다 호출 될 콜백 함수를 등록합니다 . 동일한 데이터베이스 연결에 대해 sqlite3_rollback_hook ()에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다. pArg 인수는 콜백으로 전달됩니다. 커밋 후크 함수의 콜백이 0이 아닌 값을 반환하면 커밋이 롤백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8ed0ff1b29d3e198ebfc7c54c6d04128fb45e5b9" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook (D, C, P) 및 sqlite3_rollback_hook (D, C, P) 함수는 동일한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 동일한 함수의 이전 호출에서 P 인수를 리턴 하거나 D의 각 함수에 대한 첫 번째 호출에 대해서는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5c814d040fa0b2376c6a44e987d8d06f8d405641" translate="yes" xml:space="preserve">
          <source>The sqlite3_commit_hook(D,C,P) and sqlite3_rollback_hook(D,C,P) functions return the P argument from the previous call of the same function on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call for each function on D.</source>
          <target state="translated">sqlite3_commit_hook (D, C, P) 및 sqlite3_rollback_hook (D, C, P) 함수는 동일한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 동일한 함수의 이전 호출에서 P 인수를 리턴 하거나 D의 각 함수에 대한 첫 번째 호출에 대해서는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a783ef29506da5187d0b6a8b529c5db8a199c982" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_get() function allows iterating over the list of options that were defined at compile time by returning the N-th compile time option string. If N is out of range, sqlite3_compileoption_get() returns a NULL pointer. The SQLITE_ prefix is omitted from any strings returned by sqlite3_compileoption_get().</source>
          <target state="translated">sqlite3_compileoption_get () 함수를 사용하면 N 번째 컴파일 시간 옵션 문자열을 반환하여 컴파일시 정의 된 옵션 목록을 반복 할 수 있습니다. N이 범위를 벗어나면 sqlite3_compileoption_get ()은 NULL 포인터를 반환합니다. sqlite3_compileoption_get ()에 의해 리턴 된 문자열에서 SQLITE_ 접 두부가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="39c27e864f7c32b9ceed46ceee3feba79ed9e6fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_compileoption_used() function returns 0 or 1 indicating whether the specified option was defined at compile time. The SQLITE_ prefix may be omitted from the option name passed to sqlite3_compileoption_used().</source>
          <target state="translated">sqlite3_compileoption_used () 함수는 지정된 옵션이 컴파일 타임에 정의되었는지 여부를 나타내는 0 또는 1을 리턴합니다. sqlite3_compileoption_used ()에 전달 된 옵션 이름에서 SQLITE_ 접두어를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2f7b71d769d28cabe75800e2f0fc786a0e3ca05" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface is used to make global configuration changes to SQLite in order to tune SQLite to the specific needs of the application. The default configuration is recommended for most applications and so this routine is usually not necessary. It is provided to support rare applications with unusual needs.</source>
          <target state="translated">sqlite3_config () 인터페이스는 SQLite를 응용 프로그램의 특정 요구에 맞게 조정하기 위해 SQLite의 전역 구성을 변경하는 데 사용됩니다. 기본 구성은 대부분의 응용 프로그램에 권장되므로이 루틴은 일반적으로 필요하지 않습니다. 특별한 요구가있는 드문 응용 프로그램을 지원하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2a43551c13014713b84ff3176d603e20a0bb2d0e" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config () 인터페이스는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()를&lt;/a&gt; 사용하여 라이브러리를 초기화하기 전 또는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 종료 된 후에 만 호출 할 수 있습니다 . sqlite3_config가 () 이후에 호출하면 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 및 전 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 다음은 SQLITE_MISUSE를 반환합니다. 그러나 sqlite3_config ()는 애플리케이션 정의 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; 구현의 일부로 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="950f596cd61399b38213d68d8e3371f1294cd97c" translate="yes" xml:space="preserve">
          <source>The sqlite3_config() interface may only be invoked prior to library initialization using &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; or after shutdown by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. If sqlite3_config() is called after &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and before &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; then it will return SQLITE_MISUSE. Note, however, that sqlite3_config() can be called as part of the implementation of an application-defined &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_config () 인터페이스는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()를&lt;/a&gt; 사용하여 라이브러리를 초기화하기 전 또는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 종료 된 후에 만 호출 할 수 있습니다 . sqlite3_config가 () 이후에 호출하면 &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 및 전 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 다음은 SQLITE_MISUSE를 반환합니다. 그러나 sqlite3_config ()는 애플리케이션 정의 &lt;a href=&quot;initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; 구현의 일부로 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f36e7397009cd60c7259be5a8cbdeb80264ff811" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle () 인터페이스는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 의 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (첫 번째 매개 변수)에 대한 포인터 사본을 리턴합니다. 원래 애플리케이션 정의 함수를 등록한 루틴 합니다.</target>
        </trans-unit>
        <trans-unit id="04b3afa93b5033ef2c02acd3a1ef18374b3a066e" translate="yes" xml:space="preserve">
          <source>The sqlite3_context_db_handle() interface returns a copy of the pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (the 1st parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_context_db_handle () 인터페이스는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 의 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (첫 번째 매개 변수)에 대한 포인터 사본을 리턴합니다. 원래 애플리케이션 정의 함수를 등록한 루틴 합니다.</target>
        </trans-unit>
        <trans-unit id="0b0f49ec423453d8567eeff6ab2f843591a04245" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function honors the SQLITE_UTF16_ALIGNED flag.</source>
          <target state="translated">sqlite3_create_collation () 함수는 SQLITE_UTF16_ALIGNED 플래그를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0e46987511170cbb4e8e90d14cfd9fe052087146" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation() function specifies a collating sequence name and a comparison function to implement that collating sequence. The comparison function is only used for comparing text values. The eTextRep parameter is one of SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE, or SQLITE_ANY to specify which text representation the comparison function works with. Separate comparison functions can exist for the same collating sequence for each of the UTF-8, UTF-16LE and UTF-16BE text representations. The sqlite3_create_collation16() works like sqlite3_create_collation() except that the collation name is specified in UTF-16 host byte order instead of in UTF-8.</source>
          <target state="translated">sqlite3_create_collation () 함수는 배열 순서 이름과 해당 배열 순서를 구현하기위한 비교 함수를 지정합니다. 비교 기능은 텍스트 값을 비교하는 데만 사용됩니다. eTextRep 매개 변수는 비교 함수가 작동하는 텍스트 표시를 지정하기위한 SQLITE_UTF8, SQLITE_UTF16LE, SQLITE_UTF16BE 또는 SQLITE_ANY 중 하나입니다. UTF-8, UTF-16LE 및 UTF-16BE 텍스트 표현 각각에 대해 동일한 조합 순서에 대해 별도의 비교 함수가 존재할 수 있습니다. sqlite3_create_collation16 ()은 데이터 정렬 이름이 UTF-8 대신 UTF-16 호스트 바이트 순서로 지정된다는 점을 제외하고 sqlite3_create_collation ()과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3bb1bc030c0ecaf171e6e7837d4fc5ad509b9304" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collation_v2 ()는 sqlite3_create_collation ()처럼 작동하며 조합 함수가 삭제 될 때 pArg에서 xDestroy 콜백이 호출됩니다. 데이터 정렬 기능은 나중에 데이터 정렬 생성 기능을 호출하여 재정의되거나&lt;a href=&quot;#sqlite3&quot;&gt;&lt;/a&gt;&lt;a href=&quot;#sqlite3_close&quot;&gt; sqlite3_close ()를&lt;/a&gt; 사용하여 데이터베이스 연결 이 닫히면 .</target>
        </trans-unit>
        <trans-unit id="cce8a06023084f98541458166466b478b68c97fc" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_collation_v2() works like sqlite3_create_collation() with the addition that the xDestroy callback is invoked on pArg when the collating function is deleted. Collating functions are deleted when they are overridden by later calls to the collation creation functions or when the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_create_collation_v2 ()는 sqlite3_create_collation ()처럼 작동하며 조합 함수가 삭제 될 때 pArg에서 xDestroy 콜백이 호출됩니다. 데이터 정렬 기능은 나중에 데이터 정렬 작성 함수를 호출하여 겹쳐 쓰거나 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 시 삭제됩니다.&lt;a href=&quot;close&quot;&gt; sqlite3_close ()를&lt;/a&gt; 사용하여 이 닫히면 .</target>
        </trans-unit>
        <trans-unit id="35eaa1fdb7403d0bf2c872e0985b90cb08324f23" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_filename(D,J,W,N,P) allocates memory to hold a version of database filename D with corresponding journal file J and WAL file W and with N URI parameters key/values pairs in the array P. The result from sqlite3_create_filename(D,J,W,N,P) is a pointer to a database filename that is safe to pass to routines like:</source>
          <target state="translated">sqlite3_create_filename (D, J, W, N, P)는 해당 저널 파일 J 및 WAL 파일 W와 배열 P의 N 개의 URI 매개 변수 키 / 값 쌍이있는 데이터베이스 파일 이름 D의 버전을 보유하기 위해 메모리를 할당합니다. sqlite3_create_filename의 결과 (D, J, W, N, P)는 다음과 같은 루틴에 안전하게 전달할 수있는 데이터베이스 파일 이름에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="2321a78d45e7f791f5be9bd5eeeecdd73b61cbff" translate="yes" xml:space="preserve">
          <source>The sqlite3_create_module_v2() interface has a fifth parameter which is a pointer to a destructor for the pClientData. SQLite will invoke the destructor function (if it is not NULL) when SQLite no longer needs the pClientData pointer. The destructor will also be invoked if the call to sqlite3_create_module_v2() fails. The sqlite3_create_module() interface is equivalent to sqlite3_create_module_v2() with a NULL destructor.</source>
          <target state="translated">sqlite3_create_module_v2 () 인터페이스에는 pClientData의 소멸자에 대한 포인터 인 다섯 번째 매개 변수가 있습니다. SQLite가 더 이상 pClientData 포인터가 필요하지 않을 때 SQLite는 소멸자 함수 (NULL이 아닌 경우)를 호출합니다. sqlite3_create_module_v2 () 호출이 실패하면 소멸자가 호출됩니다. sqlite3_create_module () 인터페이스는 NULL 소멸자를 사용하는 sqlite3_create_module_v2 ()와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce43917c89192dc7d4a31aeaa86afac14bcedebc" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count (P) 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; P 의 결과 집합의 현재 행에있는 열 수를 반환합니다 . 준비된 문 P에 반환 할 결과가없는 경우 ( &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column ()&lt;/a&gt; 인터페이스 제품군 호출을 통해 ) sqlite3_data_count ( P)는 0을 반환합니다. sqlite3_data_count (P) 루틴은 P가 NULL 포인터이면 0도 반환합니다. sqlite3_data_count (P)으로 돌아 간다 0에 이전 호출하면 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P)의 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; . sqlite3_data_count (P)는 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; 의 경우를 제외하고 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P)에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW를&lt;/a&gt; 반환 하면 0이 아닌 값을 반환 합니다.다단계 pragma의 각 단계는 0 개의 데이터 열을 반환하므로 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b23578428cca6b0b7cc9f351266849d54d3f4ac7" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count (P) 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 결과 세트의 현재 행에있는 열 수를 리턴합니다 . 준비된 명령문 P에 리턴 할 결과가없는 경우 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;(&lt;/a&gt; 인터페이스 의 sqlite3_column _ * () 에 대한 호출을 통해) 리턴 할 수있는 경우 sqlite3_data_count ( P)는 0을 리턴합니다. sqlite3_data_count (P) 루틴은 또한 P가 NULL 포인터 인 경우 0을 리턴합니다. sqlite3_data_count (P)으로 돌아 간다 0에 이전 호출하면 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P)의 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; . &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; 의 경우를 제외하고 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; (P)에 대한 이전 호출이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ROW를&lt;/a&gt; 리턴 한 경우 sqlite3_data_count (P)는 0이 아닌 값을 리턴 합니다.여기서 다단계 pragma의 각 단계는 0 개의 데이터 열을 반환하므로 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f5791b68b76b19a4a15dafbc0a31b6f189b8fc89" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; family of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count (P) 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; P 의 결과 집합의 현재 행에있는 열 수를 반환합니다 . 준비된 문 P에 반환 할 결과가없는 경우 ( &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column ()&lt;/a&gt; 인터페이스 제품군 호출을 통해 ) sqlite3_data_count ( P)는 0을 반환합니다. sqlite3_data_count (P) 루틴은 P가 NULL 포인터이면 0도 반환합니다. sqlite3_data_count (P)으로 돌아 간다 0에 이전 호출하면 &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P)의 반환 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; . sqlite3_data_count (P)는 &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; 의 경우를 제외하고 &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P)에 대한 이전 호출이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW를&lt;/a&gt; 반환 하면 0이 아닌 값을 반환 합니다.다단계 pragma의 각 단계는 0 개의 데이터 열을 반환하므로 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0331c5159620074031eabe2d2fffeb3879925815" translate="yes" xml:space="preserve">
          <source>The sqlite3_data_count(P) interface returns the number of columns in the current row of the result set of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P. If prepared statement P does not have results ready to return (via calls to the &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_*()&lt;/a&gt; of interfaces) then sqlite3_data_count(P) returns 0. The sqlite3_data_count(P) routine also returns 0 if P is a NULL pointer. The sqlite3_data_count(P) routine returns 0 if the previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;. The sqlite3_data_count(P) will return non-zero if previous call to &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt;(P) returned &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, except in the case of the &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; where it always returns zero since each step of that multi-step pragma returns 0 columns of data.</source>
          <target state="translated">sqlite3_data_count (P) 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 결과 세트의 현재 행에있는 열 수를 리턴합니다 . 준비된 명령문 P에 리턴 할 결과가없는 경우 &lt;a href=&quot;column_blob&quot;&gt;(&lt;/a&gt; 인터페이스 의 sqlite3_column _ * () 에 대한 호출을 통해) 리턴 할 수있는 경우 sqlite3_data_count ( P)는 0을 리턴합니다. sqlite3_data_count (P) 루틴은 또한 P가 NULL 포인터 인 경우 0을 리턴합니다. sqlite3_data_count (P)으로 돌아 간다 0에 이전 호출하면 &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P)의 반환 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; . &lt;a href=&quot;../pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt; 의 경우를 제외하고 &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; (P)에 대한 이전 호출이 &lt;a href=&quot;../rescode#row&quot;&gt;SQLITE_ROW를&lt;/a&gt; 리턴 한 경우 sqlite3_data_count (P)는 0이 아닌 값을 리턴 합니다.여기서 다단계 pragma의 각 단계는 0 개의 데이터 열을 반환하므로 항상 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="043836a9d52018cfd95036ef1de8601c0dd65b27" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config () 인터페이스는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 구성을 변경하는 데 사용됩니다 . 인터페이스는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 와 유사하지만 변경 사항이 단일 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (첫 번째 인수에 지정)에 적용된다는 점만 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="cb382b8043f6bd41fb4e955562ae2dd8de8821a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_config() interface is used to make configuration changes to a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. The interface is similar to &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; except that the changes apply to a single &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; (specified in the first argument).</source>
          <target state="translated">sqlite3_db_config () 인터페이스는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 구성을 변경하는 데 사용됩니다 . 인터페이스는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 와 유사하지만 변경 사항이 단일 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; (첫 번째 인수에 지정)에 적용된다는 점만 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d9890e9099b39efa9f23ed1209f98fc2abd695d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to a filename associated with database N of connection D. The main database file has the name &quot;main&quot;. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename (D, N) 인터페이스는 연결 D의 데이터베이스 N과 연관된 파일 이름에 대한 포인터를 리턴합니다. 기본 데이터베이스 파일의 이름은 &quot;main&quot;입니다. 데이터베이스 연결 D에 연결된 데이터베이스 N이 없거나 데이터베이스 N이 임시 또는 인 메모리 데이터베이스 인 경우이 함수는 NULL 포인터 또는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6ce559d2134cd8f80b32424d9cafa088f3f1de6d" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_filename(D,N) interface returns a pointer to the filename associated with database N of connection D. If there is no attached database N on the database connection D, or if database N is a temporary or in-memory database, then this function will return either a NULL pointer or an empty string.</source>
          <target state="translated">sqlite3_db_filename (D, N) 인터페이스는 연결 D의 데이터베이스 N과 관련된 파일 이름에 대한 포인터를 반환합니다. 데이터베이스 연결 D에 연결된 데이터베이스 N이 없거나 데이터베이스 N이 임시 또는 메모리 내 데이터베이스 인 경우 함수는 NULL 포인터 또는 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7a0142f7765d452e556a6d1ade538189bbf023a1" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문이&lt;/a&gt; 속하는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들을 리턴합니다 . &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; sqlite3_db_handle에 의해 반환은 동일 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 받는 첫 번째 인수했다 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 처음에 문을 만드는 데 사용 된 호출 (또는 그 변종).</target>
        </trans-unit>
        <trans-unit id="0ed4944069eec7d7c0e7904b6909ffc71d6a37af" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_handle interface returns the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle to which a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; belongs. The &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; returned by sqlite3_db_handle is the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that was the first argument to the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; call (or its variants) that was used to create the statement in the first place.</source>
          <target state="translated">sqlite3_db_handle 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문이&lt;/a&gt; 속하는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들을 리턴합니다 . &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; sqlite3_db_handle에 의해 반환은 동일 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 받는 첫 번째 인수했다 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 처음에 문을 만드는 데 사용 된 호출 (또는 그 변종).</target>
        </trans-unit>
        <trans-unit id="f13e3d008759351c9d014a67b0c7d66c909c38ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_readonly(D,N) interface returns 1 if the database N of connection D is read-only, 0 if it is read/write, or -1 if N is not the name of a database on connection D.</source>
          <target state="translated">연결 D의 데이터베이스 N이 읽기 전용 인 경우 sqlite3_db_readonly (D, N) 인터페이스는 1을 리턴하고, 읽기 / 쓰기 인 경우 0을, 또는 연결 D의 데이터베이스 이름이 아닌 경우 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7c54e0312a49676acc8e0fa5a98fa6c3ca389049" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory (D) 인터페이스는 데이터베이스 연결 D에서 가능한 한 많은 힙 메모리를 해제하려고 시도합니다. &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 인터페이스 와 달리이 인터페이스는 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션이 생략 된 경우에도 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="a4505b330dae36966abd878a7a5251bb10a809a6" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_release_memory(D) interface attempts to free as much heap memory as possible from database connection D. Unlike the &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; interface, this interface is in effect even when the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is omitted.</source>
          <target state="translated">sqlite3_db_release_memory (D) 인터페이스는 데이터베이스 연결 D에서 가능한 한 많은 힙 메모리를 해제하려고 시도합니다. &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 인터페이스 와 달리이 인터페이스는 &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션이 생략 된 경우에도 유효 합니다.</target>
        </trans-unit>
        <trans-unit id="83634ce6a2d174966fca0f07d2eb6e5e52439e9f" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status () 루틴은 성공하면 SQLITE_OK를, 실패 하면 0이 아닌 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7babdc84886f95b16b07a064461180aa8e231247" translate="yes" xml:space="preserve">
          <source>The sqlite3_db_status() routine returns SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_db_status () 루틴은 성공하면 SQLITE_OK를, 실패 하면 0이 아닌 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="18d47ae58f8b29dbac7701bb014dc19e22eadf62" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the database is currently in a read transaction or is involved in a backup operation.</source>
          <target state="translated">데이터베이스가 현재 읽기 트랜잭션에 있거나 백업 작업에 관련된 경우 sqlite3_deserialize () 인터페이스는 SQLITE_BUSY와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="12340c8333dc6a82eca44a1f4c8bbf0434fac375" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize (D, S, P, N, M, F) 인터페이스는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D와 데이터베이스 S의 연결을 끊은 다음 P에 포함 된 직렬화를 기반으로 S를 메모리 내 데이터베이스로 다시 엽니 다. 직렬화 된 데이터베이스 P는 N입니다. 바이트 크기. M은 버퍼 P의 크기이며 N보다 클 수 있습니다. M이 N보다 크고 SQLITE_DESERIALIZE_READONLY 비트가 F로 설정되어 있지 않으면 SQLite는 다음과 같은 한 메모리 내 데이터베이스에 내용을 추가 할 수 있습니다. 총 크기는 M 바이트를 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afac5ec67e0561a540471ae51b94788f3734ed79" translate="yes" xml:space="preserve">
          <source>The sqlite3_deserialize(D,S,P,N,M,F) interface causes the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D to disconnect from database S and then reopen S as an in-memory database based on the serialization contained in P. The serialized database P is N bytes in size. M is the size of the buffer P, which might be larger than N. If M is larger than N, and the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is permitted to add content to the in-memory database as long as the total size does not exceed M bytes.</source>
          <target state="translated">sqlite3_deserialize (D, S, P, N, M, F) 인터페이스는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D와 데이터베이스 S의 연결을 끊은 다음 P에 포함 된 직렬화를 기반으로 S를 메모리 내 데이터베이스로 다시 엽니 다. 직렬화 된 데이터베이스 P는 N입니다. 바이트 크기. M은 버퍼 P의 크기이며 N보다 클 수 있습니다. M이 N보다 크고 SQLITE_DESERIALIZE_READONLY 비트가 F로 설정되어 있지 않으면 SQLite는 다음과 같은 한 메모리 내 데이터베이스에 내용을 추가 할 수 있습니다. 총 크기는 M 바이트를 초과하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ae05681a8b59259daa468a1d8590729337a135a" translate="yes" xml:space="preserve">
          <source>The sqlite3_drop_modules(D,L) interface removes all virtual table modules from database connection D except those named on list L. The L parameter must be either NULL or a pointer to an array of pointers to strings where the array is terminated by a single NULL pointer. If the L parameter is NULL, then all virtual table modules are removed.</source>
          <target state="translated">sqlite3_drop_modules (D, L) 인터페이스는 목록 L에 이름이 지정된 것을 제외한 데이터베이스 연결 D에서 모든 가상 테이블 모듈을 제거합니다. L 매개 변수는 NULL이거나 배열이 단일 NULL로 종료되는 문자열에 대한 포인터 배열에 대한 포인터 여야합니다. 바늘. L 매개 변수가 NULL이면 모든 가상 테이블 모듈이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="cb17fe8b042f1bd6f76a39ed23dd1524edfc2345" translate="yes" xml:space="preserve">
          <source>The sqlite3_errcode() routine returns a result code for the most recent major API call. sqlite3_errmsg() returns an English-language text error message for the most recent error. The error message is represented in UTF-8 and will be ephemeral - it could disappear on the next call to any SQLite API function. sqlite3_errmsg16() works like sqlite3_errmsg() except that it returns the error message represented as UTF-16 in host native byte order.</source>
          <target state="translated">sqlite3_errcode () 루틴은 가장 최근의 주요 API 호출에 대한 결과 코드를 리턴합니다. sqlite3_errmsg ()는 가장 최근의 오류에 대한 영어 텍스트 오류 메시지를 반환합니다. 오류 메시지는 UTF-8로 표시되며 일시적입니다. 다음 번 SQLite API 함수 호출시 사라질 수 있습니다. sqlite3_errmsg16 ()은 sqlite3_errmsg ()와 같이 작동하며 호스트 기본 바이트 순서로 UTF-16으로 표시되는 오류 메시지를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5e0d9cf7c1277961ee0db98705525eacc5bb425f" translate="yes" xml:space="preserve">
          <source>The sqlite3_errmsg() and sqlite3_errmsg16() return English-language text that describes the error, as either UTF-8 or UTF-16 respectively. Memory to hold the error message string is managed internally. The application does not need to worry about freeing the result. However, the error string might be overwritten or deallocated by subsequent calls to other SQLite interface functions.</source>
          <target state="translated">sqlite3_errmsg () 및 sqlite3_errmsg16 ()은 오류를 설명하는 영어 텍스트를 각각 UTF-8 또는 UTF-16으로 반환합니다. 오류 메시지 문자열을 보유 할 메모리는 내부적으로 관리됩니다. 응용 프로그램은 결과 해제에 대해 걱정할 필요가 없습니다. 그러나 이후에 다른 SQLite 인터페이스 함수를 호출하면 오류 문자열을 덮어 쓰거나 할당을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3b2d05546afbeecb20b8fe87e3f3189bfedb642" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr () 인터페이스는 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; 를 설명하는 영어 텍스트를 UTF-8로 리턴합니다 . 오류 메시지 문자열을 보유 할 메모리는 내부적으로 관리되므로 응용 프로그램에서 해제해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3185f0fefecbff2d0db8b69bac9298083b70809e" translate="yes" xml:space="preserve">
          <source>The sqlite3_errstr() interface returns the English-language text that describes the &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;, as UTF-8. Memory to hold the error message string is managed internally and must not be freed by the application.</source>
          <target state="translated">sqlite3_errstr () 인터페이스는 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; 를 설명하는 영어 텍스트를 UTF-8로 리턴합니다 . 오류 메시지 문자열을 보유 할 메모리는 내부적으로 관리되므로 응용 프로그램에서 해제해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="eec19de3d00e4cd6319cb02ddf72d5b612e30300" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec () 인터페이스는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 주위의 편리한 래퍼이므로 응용 프로그램에서 많은 C 코드를 사용하지 않고도 여러 SQL 문을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a4e88bd32574fff7b2361feb6cf37710d7194a2" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface is a convenience wrapper around &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, and &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt;, that allows an application to run multiple statements of SQL without having to use a lot of C code.</source>
          <target state="translated">sqlite3_exec () 인터페이스는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 주위의 편리한 래퍼이므로 응용 프로그램에서 많은 C 코드를 사용하지 않고도 여러 SQL 문을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6ecb5327784e2b3ab3076a060e42400e8e6e49" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec () 인터페이스는 첫 번째 인수로 전달 된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 컨텍스트에서 두 번째 인수로 전달 된 UTF-8로 인코딩 된 세미콜론으로 분리 된 SQL 문을 0 개 이상 실행합니다 . sqlite3_exec ()에 대한 세 번째 인수의 콜백 함수가 NULL이 아닌 경우 평가 된 SQL 문에서 나오는 각 결과 행에 대해 호출됩니다. sqlite3_exec ()의 네 번째 인수는 각 콜백 호출의 첫 번째 인수로 릴레이됩니다. sqlite3_exec ()에 대한 콜백 포인터가 NULL이면 콜백이 호출되지 않으며 결과 행은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f2bf987e70ab4f6565417a4f7295b79e8706b9e" translate="yes" xml:space="preserve">
          <source>The sqlite3_exec() interface runs zero or more UTF-8 encoded, semicolon-separate SQL statements passed into its 2nd argument, in the context of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; passed in as its 1st argument. If the callback function of the 3rd argument to sqlite3_exec() is not NULL, then it is invoked for each result row coming out of the evaluated SQL statements. The 4th argument to sqlite3_exec() is relayed through to the 1st argument of each callback invocation. If the callback pointer to sqlite3_exec() is NULL, then no callback is ever invoked and result rows are ignored.</source>
          <target state="translated">sqlite3_exec () 인터페이스는 첫 번째 인수로 전달 된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 컨텍스트에서 두 번째 인수로 전달 된 UTF-8로 인코딩 된 세미콜론으로 분리 된 SQL 문을 0 개 이상 실행합니다 . sqlite3_exec ()에 대한 세 번째 인수의 콜백 함수가 NULL이 아닌 경우 평가 된 SQL 문에서 나오는 각 결과 행에 대해 호출됩니다. sqlite3_exec ()의 네 번째 인수는 각 콜백 호출의 첫 번째 인수로 릴레이됩니다. sqlite3_exec ()에 대한 콜백 포인터가 NULL이면 콜백이 호출되지 않으며 결과 행은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc80de144729ab29ec768dc45f521935b24167a" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">sqlite3_expanded_sql () 인터페이스는 결과를 보유 할 메모리가 충분하지 않거나 결과가 &lt;a href=&quot;#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH에&lt;/a&gt; 의해 결정된 최대 문자열 길이를 초과하는 경우 NULL을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="253eafa1da6e36def799917e15566e8c664899fe" translate="yes" xml:space="preserve">
          <source>The sqlite3_expanded_sql() interface returns NULL if insufficient memory is available to hold the result, or if the result would exceed the the maximum string length determined by the &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH&lt;/a&gt;.</source>
          <target state="translated">sqlite3_expanded_sql () 인터페이스는 결과를 보유 할 메모리가 충분하지 않거나 결과가 &lt;a href=&quot;c_limit_attached#sqlitelimitlength&quot;&gt;SQLITE_LIMIT_LENGTH에&lt;/a&gt; 의해 결정된 최대 문자열 길이를 초과하는 경우 NULL을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="1d1fd4c0ad3995d89a0ef41f1f46affc2269eba4" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;../rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes () 루틴 은 SQLite 의 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 기능을 사용하거나 사용하지 않습니다. 기록 호환성을 위해 확장 결과 코드는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="904ab00e0ae19fa09117889888e1162471d32017" translate="yes" xml:space="preserve">
          <source>The sqlite3_extended_result_codes() routine enables or disables the &lt;a href=&quot;rescode#extrc&quot;&gt;extended result codes&lt;/a&gt; feature of SQLite. The extended result codes are disabled by default for historical compatibility.</source>
          <target state="translated">sqlite3_extended_result_codes () 루틴 은 SQLite 의 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 결과 코드&lt;/a&gt; 기능을 사용하거나 사용하지 않습니다. 기록 호환성을 위해 확장 결과 코드는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5daeea1eac71cd621bf8b80af259a724f2e831b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_finalize () 함수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 삭제하기 위해 호출됩니다 . 명령문의 최신 평가에서 오류가 발생하지 않았거나 명령문이 평가되지 않은 경우 sqlite3_finalize ()는 SQLITE_OK를 리턴합니다. 명령문 S의 최신 평가에 실패한 경우 sqlite3_finalize (S)는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="74837217c620c1e41ee1e321a9ad17968e0d6486" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize() function is called to delete a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If the most recent evaluation of the statement encountered no errors or if the statement is never been evaluated, then sqlite3_finalize() returns SQLITE_OK. If the most recent evaluation of statement S failed, then sqlite3_finalize(S) returns the appropriate &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_finalize () 함수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 삭제하기 위해 호출됩니다 . 명령문의 최신 평가에서 오류가 발생하지 않았거나 명령문이 평가되지 않은 경우 sqlite3_finalize ()는 SQLITE_OK를 리턴합니다. 명령문 S의 최신 평가에 실패한 경우 sqlite3_finalize (S)는 적절한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="cfdc64000a1f68dd938d60f9bb70e02c947748fd" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize (S) 루틴의 수명주기 동안 어느 시점에서 호출 할 수있는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; S : 문 S는 어느 하나 개 이상의 통화를 한 후, 평가 전에 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , 또는에 대한 호출 후 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 여부에 관계없이의 명령문이 실행을 완료하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1dec5478469a2333006cfdfd3bbed8c6613161e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_finalize(S) routine can be called at any point during the life cycle of &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S: before statement S is ever evaluated, after one or more calls to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt;, or after any call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; regardless of whether or not the statement has completed execution.</source>
          <target state="translated">sqlite3_finalize (S) 루틴의 수명주기 동안 어느 시점에서 호출 할 수있는 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; S : 문 S는 어느 하나 개 이상의 통화를 한 후, 평가 전에 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; , 또는에 대한 호출 후 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 여부에 관계없이의 명령문이 실행을 완료하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="408796a34b26a6721118a4ab1b7c1f9baef90909" translate="yes" xml:space="preserve">
          <source>The sqlite3_free_filename(Y) routine releases a memory allocation previously obtained from sqlite3_create_filename(). Invoking sqlite3_free_filename(Y) where Y is a NULL pointer is a harmless no-op.</source>
          <target state="translated">sqlite3_free_filename (Y) 루틴은 이전에 sqlite3_create_filename ()에서 얻은 메모리 할당을 해제합니다. Y가 NULL 포인터 인 sqlite3_free_filename (Y)을 호출하는 것은 무해한 작업입니다.</target>
        </trans-unit>
        <trans-unit id="0a8a4dfedb4d5de550dae28093210eb5e1165c50" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">주어진 데이터베이스 연결이 각각 자동 커밋 모드에 있거나없는 경우 sqlite3_get_autocommit () 인터페이스는 0이 아닌 값 또는 0을 반환합니다. 자동 커밋 모드는 기본적으로 켜져 있습니다. 자동 커미트 모드는 &lt;a href=&quot;../lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 문에 의해 사용 불가능 합니다. 자동 &lt;a href=&quot;../lang_transaction&quot;&gt;커밋&lt;/a&gt; 모드는 COMMIT 또는 &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK에&lt;/a&gt; 의해 다시 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6407bbe024eecae19905f3987328770ebef955e" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_autocommit() interface returns non-zero or zero if the given database connection is or is not in autocommit mode, respectively. Autocommit mode is on by default. Autocommit mode is disabled by a &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; statement. Autocommit mode is re-enabled by a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;.</source>
          <target state="translated">주어진 데이터베이스 연결이 각각 자동 커밋 모드에 있거나없는 경우 sqlite3_get_autocommit () 인터페이스는 0이 아닌 값 또는 0을 반환합니다. 자동 커밋 모드는 기본적으로 켜져 있습니다. 자동 커미트 모드는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 문에 의해 사용 불가능 합니다. 자동 &lt;a href=&quot;lang_transaction&quot;&gt;커밋&lt;/a&gt; 모드는 COMMIT 또는 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK에&lt;/a&gt; 의해 다시 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="c54753db8fb054877250927a699aaaed04734d2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_auxdata(C,N) interface returns a pointer to the metadata associated by the sqlite3_set_auxdata(C,N,P,X) function with the Nth argument value to the application-defined function. N is zero for the left-most function argument. If there is no metadata associated with the function argument, the sqlite3_get_auxdata(C,N) interface returns a NULL pointer.</source>
          <target state="translated">sqlite3_get_auxdata (C, N) 인터페이스는 sqlite3_set_auxdata (C, N, P, X) 함수와 N 번째 인수 값이 응용 프로그램 정의 함수에 연관된 메타 데이터에 대한 포인터를 리턴합니다. 가장 왼쪽 함수 인수의 경우 N은 0입니다. 함수 인수와 연관된 메타 데이터가없는 경우 sqlite3_get_auxdata (C, N) 인터페이스는 NULL 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="35597daf57a6a6a4650eb220c2a29fa2c91a59d0" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() function evaluates one or more semicolon-separated SQL statements in the zero-terminated UTF-8 string of its 2nd parameter and returns a result table to the pointer given in its 3rd parameter.</source>
          <target state="translated">sqlite3_get_table () 함수는 두 번째 매개 변수의 0으로 끝나는 UTF-8 문자열에서 하나 이상의 세미콜론으로 구분 된 SQL 문을 평가하고 세 번째 매개 변수에 제공된 포인터에 결과 테이블을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="acdf7ebaf34cc7cf8bdf020e8dc45c52df0d628c" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table () 인터페이스는 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 주위의 래퍼로 구현됩니다 . sqlite3_get_table () 루틴은 SQLite의 내부 데이터 구조에 액세스 할 수 없습니다. 여기에 정의 된 공용 인터페이스 만 사용합니다. 결과적으로 내부 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 호출 외부의 랩퍼 계층에서 발생하는 오류는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 에 대한 후속 호출에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="566ec671a5bf78f09b92642b451438dd26c86350" translate="yes" xml:space="preserve">
          <source>The sqlite3_get_table() interface is implemented as a wrapper around &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. The sqlite3_get_table() routine does not have access to any internal data structures of SQLite. It uses only the public interface defined here. As a consequence, errors that occur in the wrapper layer outside of the internal &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt; call are not reflected in subsequent calls to &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_get_table () 인터페이스는 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 주위의 래퍼로 구현됩니다 . sqlite3_get_table () 루틴은 SQLite의 내부 데이터 구조에 액세스 할 수 없습니다. 여기에 정의 된 공용 인터페이스 만 사용합니다. 결과적으로 내부 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 호출 외부의 랩퍼 계층에서 발생하는 오류는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 에 대한 후속 호출에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b9b992cc0be7235d15c4a18cbb125e283656622e" translate="yes" xml:space="preserve">
          <source>The sqlite3_hard_heap_limit64(N) interface sets a hard upper bound of N bytes on the amount of memory that will be allocated. The sqlite3_hard_heap_limit64(N) interface is similar to sqlite3_soft_heap_limit64(N) except that memory allocations will fail when the hard heap limit is reached.</source>
          <target state="translated">sqlite3_hard_heap_limit64 (N) 인터페이스는 할당 될 메모리 양에 대해 N 바이트의 하드 상한을 설정합니다. sqlite3_hard_heap_limit64 (N) 인터페이스는 하드 힙 한계에 도달하면 메모리 할당이 실패한다는 점을 제외하면 sqlite3_soft_heap_limit64 (N)과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="5a1053b2bb267ced2e3415b8b71b02dc7bb0d976" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info 구조 및 해당 하위 구조는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 인터페이스의 일부로 사용되어 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; 메소드 로 정보를 전달하고 응답을 수신합니다 . ** 입력 ** 아래의 필드는 xBestIndex에 대한 입력이며 읽기 전용입니다. xBestIndex는 결과를 ** 출력 ** 필드에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="779db7516101e2733ab83d988869d6422e837e26" translate="yes" xml:space="preserve">
          <source>The sqlite3_index_info structure and its substructures is used as part of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; interface to pass information into and receive the reply from the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. The fields under **Inputs** are the inputs to xBestIndex and are read-only. xBestIndex inserts its results into the **Outputs** fields.</source>
          <target state="translated">sqlite3_index_info 구조 및 해당 하위 구조는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 인터페이스의 일부로 사용되어 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; 메소드 로 정보를 전달하고 응답을 수신합니다 . ** 입력 ** 아래의 필드는 xBestIndex에 대한 입력이며 읽기 전용입니다. xBestIndex는 결과를 ** 출력 ** 필드에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="f7b3a693ac538b125172c62d75cc7d377f31b955" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize () 인터페이스는 스레드 세이프이지만 sqlite3_shutdown ()은 그렇지 않습니다. sqlite3_shutdown () 인터페이스는 단일 스레드에서만 호출해야합니다. sqlite3_shutdown ()을 호출하기 전에 열려있는 모든 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 닫아야하고 다른 모든 SQLite 자원을 할당 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="88e442978d61726b76c4c6bd7b1f8a87808c119b" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() interface is threadsafe, but sqlite3_shutdown() is not. The sqlite3_shutdown() interface must only be called from a single thread. All open &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; must be closed and all other SQLite resources must be deallocated prior to invoking sqlite3_shutdown().</source>
          <target state="translated">sqlite3_initialize () 인터페이스는 스레드 세이프이지만 sqlite3_shutdown ()은 그렇지 않습니다. sqlite3_shutdown () 인터페이스는 단일 스레드에서만 호출해야합니다. sqlite3_shutdown ()을 호출하기 전에 열려있는 모든 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 닫아야하고 다른 모든 SQLite 자원을 할당 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e2957684efb0782443d87103a368a9305c21dfe" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine initializes the SQLite library. The sqlite3_shutdown() routine deallocates any resources that were allocated by sqlite3_initialize(). These routines are designed to aid in process initialization and shutdown on embedded systems. Workstation applications using SQLite normally do not need to invoke either of these routines.</source>
          <target state="translated">sqlite3_initialize () 루틴은 SQLite 라이브러리를 초기화합니다. sqlite3_shutdown () 루틴은 sqlite3_initialize ()에 의해 할당 된 모든 자원을 할당 해제합니다. 이 루틴은 임베디드 시스템에서 프로세스 초기화 및 종료를 지원하도록 설계되었습니다. SQLite를 사용하는 워크 스테이션 응용 프로그램은 일반적으로 이러한 루틴 중 하나를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6344d658101e62a854952f62047632e568cb77e6" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize () 루틴은 많은 다른 SQLite 인터페이스에 의해 내부적으로 호출되므로 응용 프로그램은 일반적으로 sqlite3_initialize ()를 직접 호출 할 필요가 없습니다. 예를 들어 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; 은 sqlite3_initialize ()를 호출하므로 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; 이 아직 초기화되지 않은 경우 sqlite3_open () 이 호출되면 SQLite 라이브러리가 자동으로 초기화됩니다 . 그러나 SQLite가&lt;a href=&quot;compile#omit_autoinit&quot;&gt; SQLITE_OMIT_AUTOINIT&lt;/a&gt;컴파일 타임 옵션 인 경우 sqlite3_initialize ()에 대한 자동 호출은 생략되며 응용 프로그램은 다른 SQLite 인터페이스를 사용하기 전에 sqlite3_initialize ()를 직접 호출해야합니다. 이식성을 최대화하려면 다른 SQLite 인터페이스를 사용하기 전에 항상 응용 프로그램에서 항상 sqlite3_initialize ()를 호출하는 것이 좋습니다. SQLite의 향후 릴리스에는 이것이 필요할 수 있습니다. 즉, SQLite가 &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; 로 컴파일 될 때 나타나는 동작은 향후 SQLite 릴리스에서 기본 동작이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcebb10283d6873f839e3d670ae393ff5c1368df" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine is called internally by many other SQLite interfaces so that an application usually does not need to invoke sqlite3_initialize() directly. For example, &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; calls sqlite3_initialize() so the SQLite library will be automatically initialized when &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt; is called if it has not be initialized already. However, if SQLite is compiled with the &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; compile-time option, then the automatic calls to sqlite3_initialize() are omitted and the application must call sqlite3_initialize() directly prior to using any other SQLite interface. For maximum portability, it is recommended that applications always invoke sqlite3_initialize() directly prior to using any other SQLite interface. Future releases of SQLite may require this. In other words, the behavior exhibited when SQLite is compiled with &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; might become the default behavior in some future release of SQLite.</source>
          <target state="translated">sqlite3_initialize () 루틴은 많은 다른 SQLite 인터페이스에 의해 내부적으로 호출되므로 응용 프로그램은 일반적으로 sqlite3_initialize ()를 직접 호출 할 필요가 없습니다. 예를 들어 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; 은 sqlite3_initialize ()를 호출하므로 &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; 이 아직 초기화되지 않은 경우 sqlite3_open () 이 호출되면 SQLite 라이브러리가 자동으로 초기화됩니다 . 그러나 SQLite가&lt;a href=&quot;../compile#omit_autoinit&quot;&gt; SQLITE_OMIT_AUTOINIT&lt;/a&gt; 로 컴파일 된 경우컴파일 타임 옵션 인 경우 sqlite3_initialize ()에 대한 자동 호출은 생략되며 응용 프로그램은 다른 SQLite 인터페이스를 사용하기 전에 sqlite3_initialize ()를 직접 호출해야합니다. 이식성을 최대화하려면 다른 SQLite 인터페이스를 사용하기 전에 항상 응용 프로그램에서 항상 sqlite3_initialize ()를 호출하는 것이 좋습니다. SQLite의 향후 릴리스에는 이것이 필요할 수 있습니다. 즉, SQLite가 &lt;a href=&quot;../compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt; 로 컴파일 될 때 나타나는 동작은 향후 SQLite 릴리스에서 기본 동작이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce2e2f5e58c3c92f466c0d1a9cbb3782ccb3ca7e" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize () 루틴은 성공시 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . 어떤 이유로 sqlite3_initialize ()가 라이브러리를 초기화 할 수없는 경우 (아마도 mutex와 같은 필요한 자원을 할당 할 수없는 경우) &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 이외 의 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7cfd6fb2b2f9b6bef5dc2729044b616aa2e46340" translate="yes" xml:space="preserve">
          <source>The sqlite3_initialize() routine returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If for some reason, sqlite3_initialize() is unable to initialize the library (perhaps it is unable to allocate a needed resource such as a mutex) it returns an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">sqlite3_initialize () 루틴은 성공시 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . 어떤 이유로 sqlite3_initialize ()가 라이브러리를 초기화 할 수없는 경우 (아마도 mutex와 같은 필요한 자원을 할당 할 수없는 경우) &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 이외 의 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="004164880e4716eb9f6522ffa56490d8e1026730" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite3_uint64 are the preferred type definitions. The sqlite_int64 and sqlite_uint64 types are supported for backwards compatibility only.</source>
          <target state="translated">sqlite3_int64 및 sqlite3_uint64가 선호되는 유형 정의입니다. sqlite_int64 및 sqlite_uint64 유형은 이전 버전과의 호환성을 위해서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="7d87f3d7209e128d2babe00e667401d22d9cc8a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_int64 and sqlite_int64 types can store integer values between -9223372036854775808 and +9223372036854775807 inclusive. The sqlite3_uint64 and sqlite_uint64 types can store integer values between 0 and +18446744073709551615 inclusive.</source>
          <target state="translated">sqlite3_int64 및 sqlite_int64 유형은 -9223372036854775808과 +9223372036854775807 사이의 정수 값을 저장할 수 있습니다. sqlite3_uint64 및 sqlite_uint64 유형은 0과 +18446744073709551615 사이의 정수 값을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1945cfc4228bc66b1032ca0f61bc88893782d0c" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt (D) 호출은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 현재 실행중인 모든 SQL 문이 완료 될 때까지 유효 합니다. sqlite3_interrupt () 호출 후 실행중인 명령문 수가 0에 도달하기 전에 시작된 모든 새 SQL 문은 sqlite3_interrupt () 호출 이전에 실행 된 것처럼 인터럽트됩니다. 실행중인 명령문 수가 0에 도달 한 후 시작된 새 SQL 문은 sqlite3_interrupt ()의 영향을받지 않습니다. 실행중인 SQL 문이 없을 때 발생하는 sqlite3_interrupt (D)에 대한 호출은 작동하지 않으며 sqlite3_interrupt () 호출이 반환 된 후 시작된 SQL 문에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7eba8c8e6f99b81a907173174c705f9ed98298ab" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt (D) 호출은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 현재 실행중인 모든 SQL 문이 완료 될 때까지 유효 합니다. sqlite3_interrupt () 호출 이후에 시작하고 실행 명령문이 0에 도달하기 전에 시작되는 모든 새 SQL 문은 sqlite3_interrupt () 호출 전에 실행 된 것처럼 인터럽트됩니다. 실행중인 명령문 수가 0에 도달 한 후 시작된 새 SQL 문은 sqlite3_interrupt ()의 영향을받지 않습니다. 실행중인 SQL 문이 없을 때 발생하는 sqlite3_interrupt (D)에 대한 호출은 작동하지 않으며 sqlite3_interrupt () 호출이 리턴 된 후 시작되는 SQL 문에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="397354330de52f0df08035b92ede80f0eda59fd9" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statement count reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt (D) 호출은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 현재 실행중인 모든 SQL 문이 완료 될 때까지 유효 합니다. sqlite3_interrupt () 호출 후 실행중인 명령문 수가 0에 도달하기 전에 시작된 모든 새 SQL 문은 sqlite3_interrupt () 호출 이전에 실행 된 것처럼 인터럽트됩니다. 실행중인 명령문 수가 0에 도달 한 후 시작된 새 SQL 문은 sqlite3_interrupt ()의 영향을받지 않습니다. 실행중인 SQL 문이 없을 때 발생하는 sqlite3_interrupt (D)에 대한 호출은 작동하지 않으며 sqlite3_interrupt () 호출이 반환 된 후 시작된 SQL 문에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6b86af3fa8ce3c883af892e74e82bdad0554e41" translate="yes" xml:space="preserve">
          <source>The sqlite3_interrupt(D) call is in effect until all currently running SQL statements on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D complete. Any new SQL statements that are started after the sqlite3_interrupt() call and before the running statements reaches zero are interrupted as if they had been running prior to the sqlite3_interrupt() call. New SQL statements that are started after the running statement count reaches zero are not effected by the sqlite3_interrupt(). A call to sqlite3_interrupt(D) that occurs when there are no running SQL statements is a no-op and has no effect on SQL statements that are started after the sqlite3_interrupt() call returns.</source>
          <target state="translated">sqlite3_interrupt (D) 호출은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 현재 실행중인 모든 SQL 문이 완료 될 때까지 유효 합니다. sqlite3_interrupt () 호출 이후에 시작하고 실행 명령문이 0에 도달하기 전에 시작되는 모든 새 SQL 문은 sqlite3_interrupt () 호출 전에 실행 된 것처럼 인터럽트됩니다. 실행중인 명령문 수가 0에 도달 한 후 시작된 새 SQL 문은 sqlite3_interrupt ()의 영향을받지 않습니다. 실행중인 SQL 문이 없을 때 발생하는 sqlite3_interrupt (D)에 대한 호출은 작동하지 않으며 sqlite3_interrupt () 호출이 리턴 된 후 시작되는 SQL 문에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bfe2e62ea9486a964b648fd6403e7edfa3b65f8" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_check(Z,L) interface checks to see whether or not the L-byte UTF8 identifier that Z points to is a keyword, returning non-zero if it is and zero if not.</source>
          <target state="translated">sqlite3_keyword_check (Z, L) 인터페이스는 Z가 가리키는 L 바이트 UTF8 ID가 키워드인지 여부를 확인하여 0이 아닌 경우 0을 리턴하고 그렇지 않으면 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d4d8092bdf6d249db5e6e39b2ccbee0c913272c1" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_count() interface returns the number of distinct keywords understood by SQLite.</source>
          <target state="translated">sqlite3_keyword_count () 인터페이스는 SQLite가 이해하는 고유 키워드 수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="dc0acf41ffb529d44b2ebca13529ac325b17bad2" translate="yes" xml:space="preserve">
          <source>The sqlite3_keyword_name(N,Z,L) interface finds the N-th keyword and makes *Z point to that keyword expressed as UTF8 and writes the number of bytes in the keyword into *L. The string that *Z points to is not zero-terminated. The sqlite3_keyword_name(N,Z,L) routine returns SQLITE_OK if N is within bounds and SQLITE_ERROR if not. If either Z or L are NULL or invalid pointers then calls to sqlite3_keyword_name(N,Z,L) result in undefined behavior.</source>
          <target state="translated">sqlite3_keyword_name (N, Z, L) 인터페이스는 N 번째 키워드를 찾아 * Z를 UTF8로 표현 된 해당 키워드를 가리키고 키워드의 바이트 수를 * L에 씁니다. * Z가 가리키는 문자열은 0으로 끝나지 않습니다. sqlite3_keyword_name (N, Z, L) 루틴은 N이 범위 내에 있으면 SQLITE_OK를, 그렇지 않으면 SQLITE_ERROR를 반환합니다. Z 또는 L이 NULL이거나 유효하지 않은 포인터 인 경우 sqlite3_keyword_name (N, Z, L)을 호출하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a1d77fc76c131dee5ee5dd030d6d5133cee00d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid (D) 인터페이스는 일반적으로 반환 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 가장 최근의 성공의 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWID 테이블이나에 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 에 데이터베이스 연결 D. 삽입에를 &lt;a href=&quot;../withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블이 기록되지 않습니다. 데이터베이스 연결 D에서 rowid 테이블에 대한 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 가 성공적으로 수행되지 않은 경우 sqlite3_last_insert_rowid (D)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid (D) 인터페이스는 일반적으로 반환 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 가장 최근의 성공의 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWID 테이블이나에 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에 데이터베이스 연결 D. 삽입에를 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블이 기록되지 않습니다. 데이터베이스 연결 D에서 rowid 테이블에 대한 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 가 성공적으로 수행되지 않은 경우 sqlite3_last_insert_rowid (D)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension () 인터페이스 는 파일 zFile에 포함 된 &lt;a href=&quot;../loadext&quot;&gt;SQLite 확장&lt;/a&gt; 라이브러리 를로드하려고 시도합니다 . 파일을 직접로드 할 수없는 경우 다양한 운영 체제 별 확장명을 추가하여로드를 시도합니다. 예를 들어 &quot;samplelib&quot;를로드 할 수없는 경우 &quot;samplelib.so&quot;또는 &quot;samplelib.dylib&quot;또는 &quot;samplelib.dll&quot;과 같은 이름도 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension () 인터페이스 는 파일 zFile에 포함 된 &lt;a href=&quot;loadext&quot;&gt;SQLite 확장&lt;/a&gt; 라이브러리 를로드하려고 시도합니다 . 파일을 직접로드 할 수없는 경우 다양한 운영 체제 별 확장명을 추가하여로드를 시도합니다. 예를 들어 &quot;samplelib&quot;를로드 할 수없는 경우 &quot;samplelib.so&quot;또는 &quot;samplelib.dylib&quot;또는 &quot;samplelib.dll&quot;과 같은 이름도 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log () 인터페이스는 가상 테이블, 데이터 정렬 함수 및 SQL 함수와 같은 확장에서 사용하기위한 것입니다. 응용 프로그램이 sqlite3_log ()를 호출하는 것을 막을 방법이 없지만, 그렇게하는 것은 잘못된 형식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc () 루틴은 최소 N 바이트 길이의 메모리 블록에 대한 포인터를 리턴합니다. 여기서 N은 매개 변수입니다. sqlite3_malloc ()이 충분한 여유 메모리를 확보 할 수 없으면 NULL 포인터를 리턴합니다. sqlite3_malloc ()에 대한 매개 변수 N이 0이거나 음수이면 sqlite3_malloc ()은 NULL 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64 (N) 루틴은 sqlite3_malloc (N)과 동일하게 작동합니다. N은 부호있는 32 비트 정수 대신 부호없는 64 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf () 및 sqlite3_vmprintf () 루틴은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 결과를 씁니다 . 이 두 루틴이 리턴 한 문자열은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()에&lt;/a&gt; 의해 해제되어야합니다 . &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 가 결과 문자열을 보유하기에 충분한 메모리를 할당 할 수없는 경우 두 루틴 모두 NULL 포인터를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf () 및 sqlite3_vmprintf () 루틴은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 결과를 씁니다 . 이 두 루틴이 리턴 한 문자열은 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()에&lt;/a&gt; 의해 해제되어야합니다 . &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 가 결과 문자열을 보유하기에 충분한 메모리를 할당 할 수없는 경우 두 루틴 모두 NULL 포인터를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc () 루틴은 새로운 뮤텍스를 할당하고 이에 대한 포인터를 반환합니다. sqlite3_mutex_alloc () 루틴은 요청 된 뮤텍스를 할당 할 수없는 경우 NULL을 리턴합니다. sqlite3_mutex_alloc ()에 대한 인수는 다음 정수 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter () 및 sqlite3_mutex_try () 루틴은 뮤텍스 입력을 시도합니다. 다른 스레드가 이미 뮤텍스 내에 있으면 sqlite3_mutex_enter ()가 차단되고 sqlite3_mutex_try ()는 SQLITE_BUSY를 반환합니다. sqlite3_mutex_try () 인터페이스는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;입력&lt;/a&gt; 에 성공하면 SQLITE_OK 를 반환합니다 . SQLITE_MUTEX_RECURSIVE를 사용하여 작성된 뮤텍스는 동일한 스레드로 여러 번 입력 할 수 있습니다. 이 경우 다른 스레드가 들어가기 전에 뮤텍스를 같은 횟수만큼 종료해야합니다. 동일한 스레드가 SQLITE_MUTEX_RECURSIVE 이외의 뮤텍스를 두 번 이상 입력하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter () 및 sqlite3_mutex_try () 루틴은 뮤텍스 입력을 시도합니다. 다른 스레드가 이미 뮤텍스 내에 있으면 sqlite3_mutex_enter ()가 차단되고 sqlite3_mutex_try ()는 SQLITE_BUSY를 반환합니다. sqlite3_mutex_try () 인터페이스는 &lt;a href=&quot;../rescode#ok&quot;&gt;입력&lt;/a&gt; 에 성공하면 SQLITE_OK 를 반환합니다 . SQLITE_MUTEX_RECURSIVE를 사용하여 작성된 뮤텍스는 동일한 스레드로 여러 번 입력 할 수 있습니다. 이 경우 다른 스레드가 들어가기 전에 뮤텍스를 같은 횟수만큼 종료해야합니다. 동일한 스레드가 SQLITE_MUTEX_RECURSIVE 이외의 뮤텍스를 두 번 이상 입력하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free () 루틴은 이전에 할당 된 동적 뮤텍스를 할당 해제합니다. 정적 뮤텍스 할당 해제를 시도하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held () 및 sqlite3_mutex_notheld () 루틴은 assert () 문에서 사용하기위한 것입니다. SQLite 코어는 assert () 내부를 제외하고는 이러한 루틴을 사용하지 않으며 애플리케이션은 코어의 리드를 따르는 것이 좋습니다. SQLite 코어는 SQLITE_DEBUG 플래그로 컴파일 될 때 이러한 루틴에 대한 구현 만 제공합니다. 외부 뮤텍스 구현은 SQLITE_DEBUG가 정의되어 있고 NDEBUG가 정의되지 않은 경우에만 이러한 루틴을 제공하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave () 루틴은 이전에 동일한 스레드에 의해 입력 된 뮤텍스를 종료합니다. 뮤텍스가 현재 호출 스레드에 의해 입력되지 않았거나 현재 할당되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open () 루틴은 버전 2 인터페이스와 마찬가지로 sqlite3 구조에 대한 포인터가 아닌 정수 오류 코드를 리턴합니다. sqlite3_open ()과 sqlite3_open16 ()의 차이점은 sqlite3_open16 ()은 데이터베이스 파일 이름으로 UTF-16 (호스트 기본 바이트 순서)을 사용한다는 것입니다. 새 데이터베이스 파일을 작성해야하는 경우 sqlite3_open16 ()은 내부 텍스트 표현을 UTF-16으로 설정하고 sqlite3_open ()은 텍스트 표현을 UTF-8로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2 () 인터페이스는 새로운 데이터베이스 연결에 대한 추가 제어를 위해 두 개의 추가 매개 변수를 허용한다는 점을 제외하면 sqlite3_open ()과 유사하게 작동합니다. sqlite3_open_v2 ()에 대한 flags 매개 변수는 다음 세 가지 값 중 하나를 취할 수 있습니다.&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt; SQLITE_OPEN_NOMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 .</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2 () 인터페이스는 새로운 데이터베이스 연결에 대한 추가 제어를 위해 두 개의 추가 매개 변수를 허용한다는 점을 제외하면 sqlite3_open ()과 유사하게 작동합니다. sqlite3_open_v2 ()에 대한 flags 매개 변수는 선택적으로 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; 와 결합 된 다음 세 값 중 하나를 취할 수 있습니다. , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; 및 / 또는 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 .</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="translated">sqlite3_open_v2 () 인터페이스는 새로운 데이터베이스 연결에 대한 추가 제어를 위해 두 개의 추가 매개 변수를 허용한다는 점을 제외하면 sqlite3_open ()과 같이 작동합니다. sqlite3_open_v2 ()에 대한 flags 매개 변수는 최소한 다음 세 가지 플래그 조합 중 하나를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init () 루틴은 SQLite 라이브러리의 운영 체제 별 초기화를 수행합니다. sqlite3_os_end () 루틴은 sqlite3_os_init ()의 효과를 취소합니다. 이러한 루틴에 의해 수행되는 일반적인 작업에는 정적 자원 할당 또는 할당 해제, 전역 변수 초기화, 기본 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 모듈 설정 또는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 사용하여 기본 구성 설정이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init () 루틴은 SQLite 라이브러리의 운영 체제 별 초기화를 수행합니다. sqlite3_os_end () 루틴은 sqlite3_os_init ()의 효과를 취소합니다. 이러한 루틴에 의해 수행되는 일반적인 작업에는 정적 자원 할당 또는 할당 해제, 전역 변수 초기화, 기본 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 모듈 설정 또는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 사용하여 기본 구성 설정이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache 유형이 불투명합니다. 플러그 가능한 모듈로 구현됩니다. SQLite 코어는 크기 나 내부 구조를 알지 못하며 포인터를 잡고 객체에 전달하는 것 외에는 sqlite3_pcache 객체를 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">sqlite3_pcache_methods 구조 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; 구성 매개 변수는 더 이상 사용되지 않습니다. 그것들은 새로운 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 로 대체됩니다 구조와 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; 구성 매개 변수 .</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_page 객체는 페이지 캐시의 단일 페이지를 나타냅니다. 페이지 캐시는이 개체의 인스턴스를 할당합니다. 페이지 캐시의 다양한 메소드는이 오브젝트의 인스턴스에 대한 포인터를 매개 변수 또는 리턴 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepare 인터페이스는 나중에 실행하기 위해 단일 SQL 문을 바이트 코드로 컴파일합니다. 이 인터페이스는 이제 데이터베이스에 액세스하는 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () 및 sqlite3_prepare16_v3 () 인터페이스는 모든 새 프로그램에 권장됩니다. 이전 인터페이스 (sqlite3_prepare () 및 sqlite3_prepare16 ())는 이전 버전과의 호환성을 위해 유지되지만 사용을 권장하지 않습니다. &quot;vX&quot;인터페이스에서 리턴 된 준비된 명령문 ( &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 오브젝트)은 원래 SQL 텍스트의 사본을 포함합니다. 이로 인해&lt;a href=&quot;#sqlite3_step&quot;&gt; sqlite3_step ()&lt;/a&gt; 인터페이스는 세 가지 방식으로 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () 및 sqlite3_prepare16_v3 () 인터페이스는 모든 새 프로그램에 권장됩니다. 이전 인터페이스 (sqlite3_prepare () 및 sqlite3_prepare16 ())는 이전 버전과의 호환성을 위해 유지되지만 사용을 권장하지 않습니다. &quot;vX&quot;인터페이스에서 리턴 된 준비된 명령문 ( &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 오브젝트)은 원래 SQL 텍스트의 사본을 포함합니다. 이로 인해&lt;a href=&quot;step&quot;&gt; sqlite3_step ()&lt;/a&gt; 인터페이스는 세 가지 방식으로 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler (D, N, X, P) 인터페이스는 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 장기 호출을하는 동안 콜백 함수 X가 주기적으로 호출되도록합니다.&lt;a href=&quot;#sqlite3_free_table&quot;&gt;&lt;/a&gt; 데이터베이스 연결 D에 대한 sqlite3_get_table () 을 합니다.이 인터페이스의 사용 예는 다음과 같습니다. 큰 쿼리 중에 GUI를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler (D, N, X, P) 인터페이스는 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table ()을&lt;/a&gt; 오랫동안 실행하는 동안 콜백 함수 X가 주기적으로 호출되도록합니다. 데이터베이스 연결 D에 대한 을 합니다.이 인터페이스의 사용 예는 다음과 같습니다. 큰 쿼리 중에 GUI를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc (X, N) 인터페이스는 이전 메모리 할당 X의 크기를 최소 N 바이트로 조정하려고 시도합니다. sqlite3_realloc (X, N)에 대한 X 매개 변수가 NULL 포인터이면 sqlite3_malloc (N) 호출과 동일합니다. sqlite3_realloc (X, N)에 대한 N 매개 변수가 0이거나 음수이면 동작은 sqlite3_free (X)를 호출하는 것과 정확히 동일합니다. sqlite3_realloc (X, N)은 사용 가능한 메모리가 충분하지 않은 경우 크기가 N 바이트 이상이거나 NULL 인 메모리 할당에 대한 포인터를 반환합니다. M이 이전 할당의 크기이면, 이전 할당의 min (N, M) 바이트가 sqlite3_realloc (X, N)에 의해 리턴 된 버퍼의 시작 부분에 복사되고 이전 할당이 해제됩니다. sqlite3_realloc (X, N)이 NULL을 반환하고 N이 양수이면 이전 할당이 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64 (X, N) 인터페이스는 sqlite3_realloc (X, N)과 동일하게 작동합니다. N은 32 비트 부호있는 정수 대신 64 비트 부호없는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">sqlite3rebaser_delete ()를 호출하면 sqlite3_rebaser 객체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory () 인터페이스는 데이터베이스 라이브러리가 보유한 비 필수 메모리 할당을 할당 해제하여 N 바이트의 힙 메모리를 해제하려고 시도합니다. 성능 향상을 위해 데이터베이스 페이지를 캐시하는 데 사용되는 메모리는 필수적이지 않은 메모리의 예입니다. sqlite3_release_memory ()는 실제로 해제 된 바이트 수를 반환합니다. 이는 요청 된 양보다 많거나 적을 수 있습니다. SQLite가 다음과 같이 컴파일되지 않은 경우 sqlite3_release_memory () 루틴은 0을 반환하는 no-op입니다&lt;a href=&quot;../compile#enable_memory_management&quot;&gt; SQLITE_ENABLE_MEMORY_MANAGEMENT로&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory () 인터페이스는 데이터베이스 라이브러리가 보유한 비 필수 메모리 할당을 할당 해제하여 N 바이트의 힙 메모리를 해제하려고 시도합니다. 성능 향상을 위해 데이터베이스 페이지를 캐시하는 데 사용되는 메모리는 필수적이지 않은 메모리의 예입니다. sqlite3_release_memory ()는 실제로 해제 된 바이트 수를 반환합니다. 이는 요청 된 양보다 많거나 적을 수 있습니다. SQLite가 다음과 같이 컴파일되지 않은 경우 sqlite3_release_memory () 루틴은 0을 반환하는 no-op입니다&lt;a href=&quot;compile#enable_memory_management&quot;&gt; SQLITE_ENABLE_MEMORY_MANAGEMENT로&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset () 함수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트를 초기 상태로 다시 설정하여 다시 실행할 준비가되도록 호출됩니다 . &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ * () API를&lt;/a&gt; 사용하여 값이 바인드 된 모든 SQL 문 변수는 해당 값을 유지합니다. 사용하다&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; 를 하여 바인딩을 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset () 함수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트를 초기 상태로 다시 설정하여 다시 실행할 준비가되도록 호출됩니다 . &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ * () API를&lt;/a&gt; 사용하여 값이 바인드 된 모든 SQL 문 변수는 해당 값을 유지합니다. 사용하다&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; 를 하여 바인딩을 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob () 인터페이스는 응용 프로그램 정의 함수의 결과를 내용이 두 번째 매개 변수로 가리키고 N 바이트 길이 인 BLOB가되도록 설정합니다. 여기서 N은 세 번째 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double () 인터페이스는 응용 프로그램 정의 함수의 결과를 두 번째 인수로 지정된 부동 소수점 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error () 및 sqlite3_result_error16 () 함수는 구현 된 SQL 함수에서 예외를 발생시킵니다. SQLite는 sqlite3_result_error () 또는 sqlite3_result_error16 ()의 두 번째 매개 변수가 가리키는 문자열을 오류 메시지의 텍스트로 사용합니다. SQLite는 sqlite3_result_error ()의 오류 메시지 문자열을 UTF-8로 해석합니다. SQLite는 sqlite3_result_error16 ()의 문자열을 원시 바이트 순서로 UTF-16으로 해석합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 세 번째 매개 변수가 음수이면 SQLite는 첫 번째 0 문자를 통해 모든 텍스트를 오류 메시지로 사용합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 세 번째 매개 변수가 음이 아닌 경우 SQLite는 두 번째 매개 변수에서 문자 수가 아닌 많은 바이트를 오류 메시지로 사용합니다.sqlite3_result_error () 및 sqlite3_result_error16 () 루틴은 오류 메시지 텍스트가 리턴되기 전에 개인용 사본을 작성합니다. 따라서 호출 기능은 텍스트가 해를 끼치 지 않고 반환 된 후에 텍스트를 할당 해제하거나 수정할 수 있습니다. sqlite3_result_error_code () 함수는 함수 오류의 결과로 SQLite가 리턴 한 오류 코드를 변경합니다. 기본적으로 오류 코드는 SQLITE_ERROR입니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error () 및 sqlite3_result_error16 () 함수는 구현 된 SQL 함수가 예외를 발생 시키도록합니다. SQLite는 sqlite3_result_error () 또는 sqlite3_result_error16 ()의 두 번째 매개 변수가 가리키는 문자열을 오류 메시지의 텍스트로 사용합니다. SQLite는 sqlite3_result_error ()의 오류 메시지 문자열을 UTF-8로 해석합니다. SQLite는 동일한 사용 UTF-16 sqlite3_result_error16 ()으로부터 문자열 해석 &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;바이트 순서 결정 규칙&lt;/a&gt; 등 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;) (sqlite3_bind_text16을&lt;/a&gt;. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수이면 SQLite는 첫 번째 0 문자까지 모든 텍스트를 오류 메시지로 간주합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수가 아닌 경우 SQLite는 두 번째 매개 변수에서 오류 메시지로 많은 바이트 (문자가 아님)를 가져옵니다. sqlite3_result_error () 및 sqlite3_result_error16 () 루틴은 반환되기 전에 오류 메시지 텍스트의 개인 복사본을 만듭니다. 따라서 호출 함수는 텍스트가 손상없이 반환 된 후 할당을 취소하거나 수정할 수 있습니다. sqlite3_result_error_code () 함수는 함수 오류의 결과로 SQLite가 반환하는 오류 코드를 변경합니다. 기본적으로 오류 코드는 SQLITE_ERROR입니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error () 및 sqlite3_result_error16 () 함수는 구현 된 SQL 함수가 예외를 발생 시키도록합니다. SQLite는 sqlite3_result_error () 또는 sqlite3_result_error16 ()의 두 번째 매개 변수가 가리키는 문자열을 오류 메시지의 텍스트로 사용합니다. SQLite는 sqlite3_result_error ()의 오류 메시지 문자열을 UTF-8로 해석합니다. SQLite는 동일한 사용 UTF-16 sqlite3_result_error16 ()으로부터 문자열 해석 &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;바이트 순서 결정 규칙&lt;/a&gt; 등 &lt;a href=&quot;bind_blob&quot;&gt;) (sqlite3_bind_text16을&lt;/a&gt;. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수이면 SQLite는 첫 번째 0 문자까지 모든 텍스트를 오류 메시지로 간주합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수가 아닌 경우 SQLite는 두 번째 매개 변수에서 오류 메시지로 많은 바이트 (문자가 아님)를 가져옵니다. sqlite3_result_error () 및 sqlite3_result_error16 () 루틴은 반환되기 전에 오류 메시지 텍스트의 개인 복사본을 만듭니다. 따라서 호출 함수는 텍스트가 손상없이 반환 된 후 할당을 취소하거나 수정할 수 있습니다. sqlite3_result_error_code () 함수는 함수 오류의 결과로 SQLite가 반환하는 오류 코드를 변경합니다. 기본적으로 오류 코드는 SQLITE_ERROR입니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem () 인터페이스는 SQLite가 메모리 할당 실패를 나타내는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig () 인터페이스는 SQLite가 문자열 또는 BLOB가 표현하기에 너무 길다는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int () 인터페이스는 응용 프로그램 정의 함수의 반환 값을 두 번째 인수에 지정된 32 비트 부호있는 정수 값으로 설정합니다. sqlite3_result_int64 () 인터페이스는 응용 프로그램 정의 함수의 반환 값을 두 번째 인수에 지정된 64 비트 부호있는 정수 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null () 인터페이스는 응용 프로그램 정의 함수의 반환 값을 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 와 마찬가지로 결과를 SQL NULL 값으로 설정합니다. 단 , 호스트 언어 포인터 P 또는 유형 T도 NULL 값과 연관되어 포인터가됩니다. &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아닌 경우 P 매개 변수의 소멸자에 대한 포인터입니다. SQLite가 P로 끝났을 때 SQLite는 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이어야합니다. sqlite3_result_pointer () 루틴은 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 SQLite 3.20.0에 추가 된 .</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 과 마찬가지로 결과를 SQL NULL 값으로 설정 하지만 호스트 언어 포인터 P 또는 유형 T를 해당 NULL 값과 연결하여 포인터 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아니면 P 매개 변수에 대한 소멸자를 가리키는 포인터입니다. SQLite는 SQLite가 P로 완료 될 때 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이 바람직합니다. sqlite3_result_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 과 마찬가지로 결과를 SQL NULL 값으로 설정 하지만 호스트 언어 포인터 P 또는 유형 T를 해당 NULL 값과 연결하여 포인터 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아니면 P 매개 변수에 대한 소멸자를 가리키는 포인터입니다. SQLite는 SQLite가 P로 완료 될 때 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이 바람직합니다. sqlite3_result_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;../bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 와 마찬가지로 결과를 SQL NULL 값으로 설정합니다. 단 , 호스트 언어 포인터 P 또는 유형 T도 NULL 값과 연관되어 포인터가됩니다. &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아닌 경우 P 매개 변수의 소멸자에 대한 포인터입니다. SQLite가 P로 끝났을 때 SQLite는 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이어야합니다. sqlite3_result_pointer () 루틴은 &lt;a href=&quot;../bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 SQLite 3.20.0에 추가 된 .</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype은 (C, T)의 함수의 결과의 아류 발생 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context을&lt;/a&gt; C를 값 T가되게합니다. 버전 T의 하위 8 비트 만 현재 버전의 SQLite에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite에서 유지되는 하위 유형 바이트 수는 이후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype (C, T) 함수는 &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C를 사용 하는 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 결과 하위 유형이 값 T가되도록합니다. 하위 유형 T의 하위 8 비트 만 SQLite의 현재 버전에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite가 보존하는 하위 유형 바이트 수는 향후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype (C, T) 함수는 &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C를 사용 하는 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 결과 하위 유형이 값 T가되도록합니다. 하위 유형 T의 하위 8 비트 만 SQLite의 현재 버전에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite가 보존하는 하위 유형 바이트 수는 향후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype은 (C, T)의 함수의 결과의 아류 발생 &lt;a href=&quot;create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 와 &lt;a href=&quot;context&quot;&gt;sqlite3_context을&lt;/a&gt; C를 값 T가되게합니다. 버전 T의 하위 8 비트 만 현재 버전의 SQLite에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite에서 유지되는 하위 유형 바이트 수는 이후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () 및 sqlite3_result_text16be () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 UTF-8, UTF-16 기본 바이트 순서, UTF-로 표시되는 텍스트 문자열로 설정합니다. 16 리틀 엔디안 또는 UTF-16 빅 엔디안 sqlite3_result_text64 () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 다섯 번째 (마지막) 매개 변수로 지정된 인코딩의 텍스트 문자열로 설정합니다. 이는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 중 하나 여야합니다 또는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite는 sqlite3_result_text * 인터페이스의 두 번째 매개 변수에서 응용 프로그램의 텍스트 결과를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 세 번째 매개 변수가 음수이면 SQLite는 두 번째 매개 변수에서 첫 번째 0 문자를 통해 결과 텍스트를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 3 번째 매개 변수가 음수가 아닌 경우, 2 번째 매개 변수가 가리키는 텍스트의 바이트 수 (문자가 아닌)가 응용 프로그램 정의 함수 결과로 간주됩니다. 세 번째 매개 변수가 음수가 아닌 경우 NUL이 종료 된 문자열 인 경우 NUL 종료자가 표시되는 문자열로의 바이트 오프셋이어야합니다. 3 번째 매개 변수의 값보다 작은 바이트 오프셋에서 문자열에 NUL 문자가 있으면,결과 문자열에는 포함 된 NUL이 포함되며 NUL이 포함 된 문자열에서 작동하는 표현식의 결과는 정의되지 않습니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 널 (NULL)이 아닌 포인터 인 경우 SQLite는 해당 결과의 사용이 완료되면 텍스트 또는 BLOB 결과에서 소멸자로 기능을 호출합니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_STATIC 인 경우 SQLite는 텍스트 또는 BLOB 결과가 일정한 공간에 있다고 가정하고 매개 변수의 컨텐츠를 복사하지 않거나 컨텐츠가있는 경우 컨텐츠에서 소멸자를 호출하지 않습니다. 그 결과 사용을 마쳤습니다.sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_TRANSIENT 인 경우 SQLite는 결과를 공간에서 얻은 공간으로 복사합니다.&lt;a href=&quot;#sqlite3_free&quot;&gt;&lt;/a&gt;반환하기 전에 sqlite3_malloc () .</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () 및 sqlite3_result_text16be () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 UTF-8, UTF-16 기본 바이트 순서, UTF-로 표시되는 텍스트 문자열로 설정합니다. 16 리틀 엔디안 또는 UTF-16 빅 엔디안 sqlite3_result_text64 () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 다섯 번째 (마지막) 매개 변수로 지정된 인코딩의 텍스트 문자열로 설정합니다. 이는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 또는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 중 하나 여야합니다. SQLite는 sqlite3_result_text * 인터페이스의 두 번째 매개 변수에서 응용 프로그램의 텍스트 결과를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 세 번째 매개 변수가 음수이면 SQLite는 두 번째 매개 변수에서 첫 번째 0 문자를 통해 결과 텍스트를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 3 번째 매개 변수가 음수가 아닌 경우, 2 번째 매개 변수가 가리키는 텍스트의 바이트 수 (문자가 아닌)가 응용 프로그램 정의 함수 결과로 간주됩니다. 세 번째 매개 변수가 음수가 아닌 경우 NUL이 종료 된 문자열 인 경우 NUL 종료자가 표시되는 문자열로의 바이트 오프셋이어야합니다. 3 번째 매개 변수의 값보다 작은 바이트 오프셋에서 문자열에 NUL 문자가 있으면,결과 문자열에는 포함 된 NUL이 포함되며 NUL이 포함 된 문자열에서 작동하는 표현식의 결과는 정의되지 않습니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 널 (NULL)이 아닌 포인터 인 경우 SQLite는 해당 결과의 사용이 완료되면 텍스트 또는 BLOB 결과에서 소멸자로 기능을 호출합니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_STATIC 인 경우 SQLite는 텍스트 또는 BLOB 결과가 일정한 공간에 있다고 가정하고 매개 변수의 컨텐츠를 복사하지 않거나 컨텐츠가있는 경우 컨텐츠에서 소멸자를 호출하지 않습니다. 그 결과 사용을 마쳤습니다.sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_TRANSIENT 인 경우 SQLite는 결과를 공간에서 얻은 공간으로 복사합니다.&lt;a href=&quot;free&quot;&gt;&lt;/a&gt;반환하기 전에 sqlite3_malloc () .</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value () 인터페이스는 응용 프로그램 정의 함수의 결과를 2 차 매개 변수로 지정된 &lt;a href=&quot;#sqlite3_value&quot;&gt;비보호 sqlite3_value&lt;/a&gt; 오브젝트 의 사본으로 설정합니다 . sqlite3_result_value () 인터페이스는 사본하게 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value을&lt;/a&gt; 있도록 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 매개 변수에 지정된 변경하거나 피해없이 sqlite3_result_value ()의 복귀 후 해제 될 수있다. &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 객체는 항상 어디에 사용할 수 있습니다 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체가 필요합니다, 그래서 두 가지 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 목적이 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value () 인터페이스는 응용 프로그램 정의 함수의 결과를 2 차 매개 변수로 지정된 &lt;a href=&quot;value&quot;&gt;비보호 sqlite3_value&lt;/a&gt; 오브젝트 의 사본으로 설정합니다 . sqlite3_result_value () 인터페이스는 사본하게 &lt;a href=&quot;value&quot;&gt;sqlite3_value을&lt;/a&gt; 있도록 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 매개 변수에 지정된 변경하거나 피해없이 sqlite3_result_value ()의 복귀 후 해제 될 수있다. &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 객체는 항상 어디에 사용할 수 있습니다 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체가 필요합니다, 그래서 두 가지 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 목적이 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob (C, N) 및 sqlite3_result_zeroblob64 (C, N) 인터페이스는 애플리케이션 정의 함수의 결과를 0 바이트 및 N 바이트 크기를 모두 포함하는 BLOB로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeom 콜백에 대한 첫 번째 인수가 가리키는 sqlite3_rtree_geometry 구조는 다음과 같은 구조를 갖습니다. 동일한 쿼리에서 동일한 MATCH 연산자에 대한 모든 콜백에 정확히 동일한 sqlite3_rtree_geometry 구조가 사용됩니다. sqlite3_rtree_geometry 구조의 내용은 SQLite에 의해 초기화되지만 나중에 수정되지는 않습니다. 콜백은 원하는 경우 구조의 pUser 및 xDelUser 요소를 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback ()은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;버전 3.8.5&lt;/a&gt; (2014-06-04)에서 사용 가능해 졌으며 선호되는 인터페이스입니다. sqlite3_rtree_geometry_callback ()은 이전 버전과의 호환성을 위해 지원되는 오래되고 덜 유연한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize (D, S, P, F) 인터페이스는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 S 데이터베이스의 직렬화 인 메모리에 대한 포인터를 리턴 합니다 . P가 NULL 포인터가 아닌 경우 데이터베이스 의 크기 (바이트)는 *에 기록됩니다. 피.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize (D, S, P, F) 인터페이스는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 S 데이터베이스의 직렬화 인 메모리에 대한 포인터를 리턴 합니다 . P가 NULL 포인터가 아닌 경우 데이터베이스 의 크기 (바이트)는 *에 기록됩니다. 피.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata (C, N, P, X) 인터페이스는 P를 응용 프로그램 정의 함수의 N 번째 인수에 대한 메타 데이터로 저장합니다. sqlite3_get_auxdata (C, N)에 대한 후속 호출은 메타 데이터가 여전히 유효한 경우 가장 최근의 sqlite3_set_auxdata (C, N, P, X) 호출에서 P를 반환하고 메타 데이터가 삭제 된 경우 NULL입니다. X가 NULL이 아닌 sqlite3_set_auxdata (C, N, P, X)를 호출 할 때마다 SQLite는 메타 데이터가 삭제 될 때 매개 변수 P를 사용하여 소멸자 함수 X를 정확히 한 번만 호출합니다. SQLite는 다음을 포함하여 언제든지 메타 데이터를 자유롭게 버립니다.</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid (D, R) 메소드를 사용하면 데이터베이스에 행을 삽입하지 않고 sqlite3_last_insert_rowid (D)를 R로 호출하여 리턴 된 값을 애플리케이션이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep () 함수는 현재 스레드가 해당 매개 변수에 지정된 수 밀리 초 동안 실행을 일시 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshot 오브젝트는 데이터베이스 파일의 히스토리 버전에 대한 상태 정보를 기록하므로 나중에 최신 버전이 아닌 해당 히스토리 버전의 데이터베이스를 보는 새 읽기 트랜잭션을 나중에 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp (P1, P2) 인터페이스는 두 개의 유효한 스냅 샷 핸들의 수명을 비교하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf () 루틴은 표준 C 라이브러리의 &quot;snprintf ()&quot;와 유사합니다. 결과는 첫 번째 매개 변수에 의해 크기가 주어진 두 번째 매개 변수로 제공된 버퍼에 기록됩니다. 처음 두 매개 변수의 순서는 snprintf ()와 반대입니다. 이는 이전 버전과의 호환성을 유지하지 않으면 해결할 수없는 역사적 사고입니다. sqlite3_snprintf ()는 실제로 버퍼에 쓴 문자 수 대신 버퍼에 대한 포인터를 반환합니다. 우리는 쓰여진 문자의 수가 더 유용한 반환 값일 것이라는 점을 인정하지만 호환성을 유지하지 않으면 서 sqlite3_snprintf ()의 구현을 지금 변경할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64 () 인터페이스는 SQLite에 의해 할당 될 수있는 힙 메모리의 양에 대한 소프트 한계를 설정 및 / 또는 쿼리합니다. SQLite는 힙 메모리 사용량이 한계에 도달함에 따라 페이지 캐시에 보유 된 페이지 수를 줄임으로써 힙 메모리 사용량을 소프트 힙 한계 아래로 유지하려고 노력합니다. 소프트 힙 한계는 &quot;소프트&quot;입니다. 왜냐하면 SQLite가 한계 아래로 유지하려고 노력하더라도 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 오류를 생성하는 것이 아니라 한계를 초과합니다 . 다시 말해 소프트 힙 제한은 권고에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64 () 인터페이스는 SQLite에 의해 할당 될 수있는 힙 메모리의 양에 대한 소프트 한계를 설정 및 / 또는 쿼리합니다. SQLite는 힙 메모리 사용량이 한계에 도달함에 따라 페이지 캐시에 보유 된 페이지 수를 줄임으로써 힙 메모리 사용량을 소프트 힙 한계 아래로 유지하려고 노력합니다. 소프트 힙 한계는 &quot;소프트&quot;입니다. 왜냐하면 SQLite가 한계 아래로 유지하려고 노력하더라도 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 오류를 생성하는 것이 아니라 한계를 초과합니다 . 다시 말해 소프트 힙 제한은 권고에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">sqlite3_sql (P) 인터페이스는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()에&lt;/a&gt; 의해 P가 작성된 경우 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 를 작성하는 데 사용 된 UTF-8 SQL 텍스트의 사본에 대한 포인터를 리턴합니다 . sqlite3_expanded_sql (P) 인터페이스는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수가&lt;/a&gt; 확장 된 준비된 명령문 P의 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다 . sqlite3_normalized_sql (P) 인터페이스는 준비된 명령문 P의 정규화 된 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다. SQL 문을 정규화하는 데 사용되는 시맨틱은 지정되지 않으며 변경 될 수 있습니다. 최소한 리터럴 값은 적절한 자리 표시 자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">sqlite3_sql (P) 인터페이스는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()에&lt;/a&gt; 의해 P가 작성된 경우 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 를 작성하는 데 사용 된 UTF-8 SQL 텍스트의 사본에 대한 포인터를 리턴합니다 . sqlite3_expanded_sql (P) 인터페이스는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;바운드 매개 변수가&lt;/a&gt; 확장 된 준비된 명령문 P의 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다 . sqlite3_normalized_sql (P) 인터페이스는 준비된 명령문 P의 정규화 된 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다. SQL 문을 정규화하는 데 사용되는 시맨틱은 지정되지 않으며 변경 될 수 있습니다. 최소한 리터럴 값은 적절한 자리 표시 자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status () 및 sqlite3_status64 () 루틴은 성공하면 SQLITE_OK를, 실패 하면 0이 아닌 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status () 및 sqlite3_status64 () 루틴은 성공하면 SQLITE_OK를, 실패 하면 0이 아닌 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">sqlite3_step () 인터페이스는 잠금으로 인해 변경을 커밋 할 수없는 경우 SQLITE_BUSY를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step () 루틴은 결과 세트의 단일 행을 리턴하는 경우 SQLITE_ROW를 리턴하거나 정상적으로 완료되었거나 오류로 인해 실행이 완료된 경우 SQLITE_DONE을 리턴합니다. 데이터베이스 파일을 열 수 없으면 SQLITE_BUSY를 리턴 할 수도 있습니다. 리턴 값이 SQLITE_ROW 인 경우 다음 루틴을 사용하여 결과 세트의 해당 행에 대한 정보를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">sqlite3_stmt_busy은 (S) 인터페이스 true를 반환 (비 제로)이 경우 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; S가 사용되면 적어도 강화 된 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)을&lt;/a&gt; 하지만, 어느 쪽도 (반환 완료 될 때까지 실행하지 않았다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; 에서 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 사용하여 재설정)도 있었다 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset을 ( S)&lt;/a&gt; . S가 NULL 포인터 인 경우 sqlite3_stmt_busy (S) 인터페이스는 false를 반환합니다. S가 NULL 포인터가 아니고 유효한 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트에 대한 포인터가 아닌 경우 , 동작은 정의되지 않았으며 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">sqlite3_stmt_busy은 (S) 인터페이스 true를 반환 (비 제로)이 경우 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; S가 사용되면 적어도 강화 된 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)을&lt;/a&gt; 하지만, 어느 쪽도 (반환 완료 될 때까지 실행하지 않았다 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; 에서 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 사용하여 재설정)도 있었다 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset을 ( S)&lt;/a&gt; . S가 NULL 포인터 인 경우 sqlite3_stmt_busy (S) 인터페이스는 false를 반환합니다. S가 NULL 포인터가 아니고 유효한 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트에 대한 포인터가 아닌 경우 , 동작은 정의되지 않았으며 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">sqlite3_stmt_isexplain (S) 인터페이스는 준비된 명령문 S가 EXPLAIN 문인 경우 1을 리턴하고 명령문 S가 EXPLAIN QUERY PLAN 인 경우 2를 리턴합니다. S가 일반 명령문이거나 NULL 포인터 인 경우 sqlite3_stmt_isexplain (S) 인터페이스는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly (X) 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; X가 데이터베이스 파일의 내용을 직접 변경하지 않는 경우에만 true (0이 아님)를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly (X) 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; X가 데이터베이스 파일의 내용을 직접 변경하지 않는 경우에만 true (0이 아님)를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str 객체는 &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()를&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str 객체는 &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()를&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str 오브젝트가 삭제되고 작성된 문자열이 &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; 인터페이스를 사용하여 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str 오브젝트가 삭제되고 작성된 문자열이 &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; 인터페이스를 사용하여 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에서 테이블 T의 열 C에 대한 정보를 리턴합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 리턴하고 NULL이 아닌 포인터를 채 웁니다. 지정된 열이 존재하면 적절한 값을 가진 마지막 다섯 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이 없으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우,이 루틴은 단순히 테이블의 존재를 점검하고 테이블이 존재하면 SQLITE_OK를, 그렇지 않으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata (X, D, T, C, ...)에 대한 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에있는 테이블 T의 열 C에 대한 정보를 반환합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 반환하고 NULL이 아닌 포인터를 지정된 열이있는 경우 적절한 값을 가진 마지막 5 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이없는 경우 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우이 루틴은 단순히 테이블의 존재를 확인하고 테이블이 존재하면 SQLITE_OK를 반환하고 그렇지 않으면 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata (X, D, T, C, ...) 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에서 테이블 T의 열 C에 대한 정보를 리턴합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 리턴하고 NULL이 아닌 포인터를 채 웁니다. 지정된 열이 존재하면 적절한 값을 가진 마지막 다섯 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이 없으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우,이 루틴은 단순히 테이블의 존재를 점검하고 테이블이 존재하면 SQLITE_OK를, 그렇지 않으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata (X, D, T, C, ...)에 대한 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에있는 테이블 T의 열 C에 대한 정보를 반환합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 반환하고 NULL이 아닌 포인터를 지정된 열이있는 경우 적절한 값을 가진 마지막 5 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이없는 경우 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우이 루틴은 단순히 테이블의 존재를 확인하고 테이블이 존재하면 SQLITE_OK를 반환하고 그렇지 않으면 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata (X, D, T, C, ...) 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control () 인터페이스는 SQLite의 내부 상태를 읽고 테스트 목적으로 SQLite에 결함을 주입하는 데 사용됩니다. 첫 번째 매개 변수는 모든 후속 매개 변수의 수, 의미 및 작업을 결정하는 작업 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe () 함수는 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 컴파일 타임 옵션이 0으로 설정되어 mutexing 코드가 생략 된 상태에서 SQLite가 컴파일 된 경우에만 0을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe () 함수는 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 컴파일 타임 옵션이 0으로 설정되어 mutexing 코드가 생략 된 상태에서 SQLite가 컴파일 된 경우에만 0을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace () 콜백은 명령문이 컴파일 될 때가 아니라 각 명령문이 실행되기 전에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2 () 인터페이스는 더 이상 사용되지 않는 레거시 인터페이스 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 을 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2 () 인터페이스는 더 이상 사용되지 않는 레거시 인터페이스 &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 및 &lt;a href=&quot;profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 을 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2 (D, M, X, P) 인터페이스는 특성 마스크 M 및 컨텍스트 포인터 P를 사용하여 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에 대해 추적 콜백 함수 X 를 등록합니다. X 콜백이 NULL이거나 M 마스크가 0이면 추적이 사용 불가능합니다. . M 인수는 0 개 이상의 &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; 상수 의 비트 단위 OR 조합 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2 (D, M, X, P) 인터페이스는 특성 마스크 M 및 컨텍스트 포인터 P를 사용하여 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에 대해 추적 콜백 함수 X 를 등록합니다. X 콜백이 NULL이거나 M 마스크가 0이면 추적이 사용 불가능합니다. . M 인수는 0 개 이상의 &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; 상수 의 비트 단위 OR 조합 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook () 인터페이스 는 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서 행이 업데이트, 삽입 또는 삭제 될 때마다 호출 될 첫 번째 인수로 식별 된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 콜백 함수를 등록 합니다 . 동일한 데이터베이스 연결에 대해이 함수에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook () 인터페이스 는 &lt;a href=&quot;../rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서 행이 업데이트, 삽입 또는 삭제 될 때마다 호출 될 첫 번째 인수로 식별 된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 콜백 함수를 등록 합니다 . 동일한 데이터베이스 연결에 대해이 함수에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook (D, C, P) 함수는 동일한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 이전 호출에서 P 인수를 리턴 하거나 D의 첫 번째 호출에 대해서는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook (D, C, P) 함수는 동일한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 이전 호출에서 P 인수를 리턴 하거나 D의 첫 번째 호출에 대해서는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean (F, P, B) 루틴은 P가 부울 매개 변수라고 가정하고 P의 값에 따라 true (1) 또는 false (0)를 리턴합니다. sqlite3_uri_boolean (F, P, B) 루틴은 true (1)를 리턴합니다. 쿼리 매개 변수 P의 값이 &quot;yes&quot;, &quot;true&quot;또는 &quot;on&quot;중 하나 인 경우 또는 값이 0이 아닌 숫자로 시작하는 경우 sqlite3_uri_boolean (F, P, B) 루틴은 쿼리 매개 변수 P의 값이 &quot;no&quot;, &quot;false&quot;또는 &quot;off&quot;중 하나이거나 값이 숫자 0으로 시작하는 경우 false (0)를 반환합니다. P가 F의 쿼리 매개 변수가 아니거나 P의 값이 위와 일치하지 않는 경우 sqlite3_uri_boolean (F, P, B)는 (B! = 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean (F, P, B) 루틴은 P가 부울 매개 변수라고 가정하고 P 값에 따라 true (1) 또는 false (0)를 리턴합니다. sqlite3_uri_boolean (F, P, B) 루틴은 true (1)를 리턴합니다. 쿼리 매개 변수 P의 값이 &quot;yes&quot;, &quot;true&quot;또는 &quot;on&quot;중 하나이거나 값이 0이 아닌 숫자로 시작하는 경우 sqlite3_uri_boolean (F, P, B) 루틴은 조회 매개 변수 P의 값이 &quot;no&quot;, &quot;false&quot;또는 &quot;off&quot;중 하나이거나 값이 숫자 0으로 시작하는 경우 false (0)를 리턴합니다. P가 F의 쿼리 매개 변수가 아니거나 P의 값이 위의 값과 일치하지 않으면 sqlite3_uri_boolean (F, P, B)는 (B! = 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64 (F, P, D) 루틴은 P의 값을 부호있는 64 비트 정수로 변환하고 해당 정수를 반환하거나 P가 없으면 D를 반환합니다. P의 값이 정수 이외의 값이면 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="translated">sqlite3_uri_key (F, N)는 파일 이름 F에 대한 N 번째 쿼리 매개 변수의 이름 (값이 아님)에 대한 포인터를 반환하거나 N이 0보다 작거나 쿼리 매개 변수 수에서 1을 뺀 값보다 큰 경우 NULL 포인터를 반환합니다. N 값은 0부터 시작하므로 N은 첫 번째 쿼리 매개 변수의 이름을 가져 오려면 0, 두 번째 매개 변수의 경우 1 등이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data () 인터페이스는 원래 응용 프로그램 정의 함수를 등록한 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 루틴 의 pUserData 매개 변수 (5 번째 매개 변수) 인 포인터의 사본을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data () 인터페이스는 원래 응용 프로그램 정의 함수를 등록한 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 루틴 의 pUserData 매개 변수 (5 번째 매개 변수) 인 포인터의 사본을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달 된 sqlite3_value 오브젝트 가 보호됩니다. &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 리턴 된 sqlite3_value 오브젝트 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달되는 sqlite3_value 오브젝트 는 보호됩니다. &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 sqlite3_value 객체 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달되는 sqlite3_value 오브젝트 는 보호됩니다. &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 sqlite3_value 객체 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달 된 sqlite3_value 오브젝트 가 보호됩니다. &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 리턴 된 sqlite3_value 오브젝트 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup (V) 인터페이스는 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 D 의 사본을 작성하고 해당 사본에 대한 포인터를 리턴합니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 반환은이다 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 입력이없는 경우에도 객체입니다. sqlite3_value_dup (V) 인터페이스는 V가 NULL이거나 메모리 할당이 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup (V) 인터페이스는 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 D 의 사본을 작성하고 해당 사본에 대한 포인터를 리턴합니다. &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 반환은이다 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 입력이없는 경우에도 객체입니다. sqlite3_value_dup (V) 인터페이스는 V가 NULL이거나 메모리 할당이 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free (V) 인터페이스는 &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 에서 이전에 얻은 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 객체를 해제합니다 . V가 NULL 포인터이면 sqlite3_value_free (V)는 무해한 무 작동입니다.</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free (V) 인터페이스는 &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 에서 이전에 얻은 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 객체를 해제합니다 . V가 NULL 포인터이면 sqlite3_value_free (V)는 무해한 무 작동입니다.</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">값 X가 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 sqlite3_value_frombind (X) 인터페이스는 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값 또는 테이블 열 및 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">sqlite3_value_frombind (X) 인터페이스는 값 X가 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값, 테이블 열 또는 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">값 X가 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 sqlite3_value_frombind (X) 인터페이스는 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값 또는 테이블 열 및 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">sqlite3_value_frombind (X) 인터페이스는 값 X가 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값, 테이블 열 또는 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type () 인터페이스는 값에 숫자 선호도를 적용하려고 시도합니다. 이는 값을 정수 또는 부동 소수점으로 변환하려고 시도 함을 의미합니다. 정보의 손실없이 이러한 변환이 가능하면 (즉, 값이 숫자처럼 보이는 문자열 인 경우) 변환이 수행됩니다. 그렇지 않으면 변환이 발생하지 않습니다. &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;데이터 형식&lt;/a&gt; 변환 후이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type () 인터페이스는 값에 숫자 선호도를 적용하려고 시도합니다. 이는 값을 정수 또는 부동 소수점으로 변환하려고 시도 함을 의미합니다. 정보의 손실없이 이러한 변환이 가능하면 (즉, 값이 숫자처럼 보이는 문자열 인 경우) 변환이 수행됩니다. 그렇지 않으면 변환이 발생하지 않습니다. &lt;a href=&quot;c_blob&quot;&gt;데이터 형식&lt;/a&gt; 변환 후이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 서브 타입을 리턴합니다. 인수 V에 대한 서브 타입 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용될 수 있습니다. &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype ()&lt;/a&gt; 루틴을 사용하여 SQL 함수의 리턴 값에 대한 하위 유형을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 인수 V에 대한 하위 유형을 리턴합니다. 하위 유형 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용할 수 있습니다. SQL 함수의 리턴 값에 대한 &lt;a href=&quot;result_subtype&quot;&gt;부속&lt;/a&gt; 유형을 설정 하려면 sqlite3_result_subtype () 루틴을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 인수 V에 대한 하위 유형을 리턴합니다. 하위 유형 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용할 수 있습니다. SQL 함수의 리턴 값에 대한 &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;부속&lt;/a&gt; 유형을 설정 하려면 sqlite3_result_subtype () 루틴을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 인수 V에 대한 서브 타입을 리턴합니다. 서브 타입 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용될 수 있습니다. 사용&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype ()&lt;/a&gt; 루틴을 SQL 함수의 리턴 값에 대한 하위 유형을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16 () 인터페이스는 호스트 시스템의 기본 바이트 순서로 UTF-16 문자열을 추출합니다. sqlite3_value_text16be () 및 sqlite3_value_text16le () 인터페이스는 각각 UTF-16 문자열을 빅 엔디안 및 리틀 엔디안으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type (V) 인터페이스는 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 V의 초기 데이터 유형에 대한 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;데이터 유형 코드&lt;/a&gt; 를 리턴합니다. 리턴 된 값은 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; 중 하나입니다. . 다른 인터페이스는 sqlite3_value 객체의 데이터 유형을 변경할 수 있습니다. 예를 들어, 데이터 유형이 처음에 SQLITE_INTEGER이고 해당 정수에 대한 텍스트 값을 추출하기 위해 sqlite3_value_text (V)가 호출 된 경우 sqlite3_value_type (V)에 대한 후속 호출은 SQLITE_TEXT를 리턴 할 수 있습니다. 지속적 내부 데이터 유형 변환이 발생하는지 여부는 정의되어 있지 않으며 SQLite의 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type (V) 인터페이스는 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 V의 초기 데이터 유형에 대한 &lt;a href=&quot;c_blob&quot;&gt;데이터 유형 코드&lt;/a&gt; 를 리턴합니다. 리턴 된 값은 &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; 또는 &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; 중 하나입니다. . 다른 인터페이스는 sqlite3_value 객체의 데이터 유형을 변경할 수 있습니다. 예를 들어, 데이터 유형이 처음에 SQLITE_INTEGER이고 해당 정수에 대한 텍스트 값을 추출하기 위해 sqlite3_value_text (V)가 호출 된 경우 sqlite3_value_type (V)에 대한 후속 호출은 SQLITE_TEXT를 리턴 할 수 있습니다. 지속적 내부 데이터 유형 변환이 발생하는지 여부는 정의되어 있지 않으며 SQLite의 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version [] 문자열 상수에는 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; 매크로 의 텍스트가 포함 됩니다. sqlite3_libversion () 함수는 sqlite3_version [] 문자열 상수에 대한 포인터를 리턴합니다. sqlite3_libversion () 함수는 DLL 사용자가 일반적으로 DLL 내의 문자열 상수에 직접 액세스 할 수 없으므로 DLL에서 사용하기 위해 제공됩니다. sqlite3_libversion_number () 함수는 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER와&lt;/a&gt; 동일한 정수를 리턴합니다 . sqlite3_sourceid () 함수는 값이 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전 처리기 매크로 와 동일한 문자열 상수에 대한 포인터를 리턴합니다 . SQLite가 편집 된 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; 사본을 사용하여 빌드 된 경우를 제외하고 해시의 마지막 네 문자는 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version [] 문자열 상수에는 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; 매크로 의 텍스트가 포함 됩니다. sqlite3_libversion () 함수는 sqlite3_version [] 문자열 상수에 대한 포인터를 리턴합니다. sqlite3_libversion () 함수는 DLL 사용자가 일반적으로 DLL 내의 문자열 상수에 직접 액세스 할 수 없으므로 DLL에서 사용하기 위해 제공됩니다. sqlite3_libversion_number () 함수는 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER와&lt;/a&gt; 동일한 정수를 리턴합니다 . sqlite3_sourceid () 함수는 값이 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전 처리기 매크로 와 동일한 문자열 상수에 대한 포인터를 리턴합니다 . SQLite가 편집 된 &lt;a href=&quot;../amalgamation&quot;&gt;amalgamation&lt;/a&gt; 사본을 사용하여 빌드 된 경우를 제외하고 해시의 마지막 네 문자는 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find () 인터페이스는 이름이 지정된 VFS에 대한 포인터를 반환합니다. 이름은 대소 문자를 구분합니다. 이름은 0으로 끝나는 UTF-8 문자열입니다. 일치하는 것이 없으면 NULL 포인터가 반환됩니다. zVfsName이 NULL이면 기본 VFS가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf () 루틴은 varlites 버전의 sqlite3_snprintf ()입니다.</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint (D, X)는 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint (D, X)는 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2 (D, X, M, L, C) 인터페이스는 M 모드에서 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 데이터베이스 X에 대해 체크 포인트 조작을 실행 합니다. 상태 정보는 L 및 C가 가리키는 정수로 다시 기록됩니다. M 매개 변수는 유효해야합니다. &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;체크 포인트 모드&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2 (D, X, M, L, C) 인터페이스는 M 모드에서 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 데이터베이스 X에 대해 체크 포인트 조작을 실행 합니다. 상태 정보는 L 및 C가 가리키는 정수로 다시 기록됩니다. M 매개 변수는 유효해야합니다. &lt;a href=&quot;c_checkpoint_full&quot;&gt;체크 포인트 모드&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">sqlite3changeset_apply () 함수는 sqlite_stat1 테이블을 업데이트 할 때 길이가 0 인 얼룩을 NULL 값으로 자동 변환합니다. 그러나 애플리케이션이 변경 세트 반복자에서 직접 sqlite3changeset_new (), sqlite3changeset_old () 또는 sqlite3changeset_conflict를 호출하면 (충돌 핸들러 콜백에 전달 된 변경 세트 반복자를 포함하여) X ''값이 리턴됩니다. 필요한 경우 응용 프로그램은 X ''를 NULL로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open (T, A, S) 함수는 &quot;sqlite3rbu&quot;오브젝트에 대한 포인터를 리턴 한 후 후속 인터페이스로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config () 인터페이스는 스레드 세이프가 아닙니다. 다른 스레드가 다른 세션 메소드 내에있는 동안 호출되면 결과가 정의되지 않습니다. 또한 세션 관련 오브젝트가 작성된 후에 호출되면 결과도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config () 인터페이스는 응용 프로그램의 특정 요구에 맞게 세션 모듈을 전체적으로 구성 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get () SQL 함수는 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get ()&lt;/a&gt; C / C ++ 함수 주위의 랩퍼 입니다. 이 루틴은 SQLite를 빌드하는 데 사용 된 N 번째 컴파일 타임 옵션을 반환하거나 N이 범위를 벗어난 경우 NULL을 반환합니다. &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used () SQL 함수는 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used ()&lt;/a&gt; 주위의 랩퍼입니다. C / C ++ 함수 입니다. sqlite_compileoption_used (X)에 대한 인수 X가 컴파일 타임 옵션의 이름 인 문자열 인 경우,이 루틴은 빌드 중 해당 옵션의 사용 여부에 따라 true (1) 또는 false (0)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_master 테이블에는 sqlite_master 테이블 자체에 대한 항목이없는 경우를 제외하고 데이터베이스 스키마의 각 테이블, 인덱스, 뷰 및 트리거 (총칭하여 &quot;개체&quot;)에 대해 하나의 행이 포함됩니다. sqlite_master 테이블에는 애플리케이션 및 프로그래머 정의 오브젝트 외에 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 스키마 오브젝트&lt;/a&gt; 에 대한 항목이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.name 컬럼은 오브젝트의 이름을 보유합니다. 테이블의 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건으로 인해 SQLite는 &quot;sqlite_autoindex_TABLE_N&quot;형식의 이름으로 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스&lt;/a&gt; 를 생성 합니다. 여기서 TABLE은 제약 조건이 포함 된 테이블의 이름으로 대체되고 N은 1로 시작하고 각 제약 조건마다 하나씩 증가하는 정수입니다. 테이블 정의에서 볼 수 있습니다. A의 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID없이&lt;/a&gt; 테이블, 기본 키에 대한있는 sqlite_master 항목이 없지만,있는 sqlite_master 항목이 존재했던 것처럼 &quot;sqlite_autoindex_TABLE_N&quot;이름은 PRIMARY KEY 위해 따로 설정되어 있습니다. 이는 후속 UNIQUE 제약 조건의 번호 지정에 영향을줍니다. &quot;sqlite_autoindex_TABLE_N&quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY 에는 이름이 할당되지 않습니다&lt;/a&gt;rowid 테이블 또는 WITHOUT ROWID 테이블에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpage 열은 테이블 및 인덱스에 대한 루트 b- 트리 페이지의 페이지 번호를 저장합니다. 뷰, 트리거 및 가상 테이블을 정의하는 행의 경우 루트 페이지 열은 0 또는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql 열은 객체를 설명하는 SQL 텍스트를 저장합니다. 이 SQL 텍스트는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문으로, 데이터베이스 파일이 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 기본 데이터베이스 일 때 데이터베이스 파일에 대해 평가되는 경우 오브젝트를 다시 작성합니다. 텍스트는 일반적으로 오브젝트를 작성하는 데 사용 된 원래 명령문의 사본이지만 텍스트가 다음 규칙을 준수하도록 정규화가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_name 컬럼은 오브젝트가 연관된 테이블 또는 뷰의 이름을 보유합니다. 테이블 또는 뷰의 경우 tbl_name 컬럼은 이름 컬럼의 사본입니다. 인덱스의 경우 tbl_name은 인덱스 된 테이블의 이름입니다. 트리거의 경우 tbl_name 컬럼은 트리거를 발생시키는 테이블 또는 뷰의 이름을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.type 열은 정의 된 객체 유형에 따라 'table', 'index', 'view'또는 'trigger'텍스트 문자열 중 하나입니다. 'table'문자열은 일반 &lt;a href=&quot;vtab&quot;&gt;테이블&lt;/a&gt; 과 가상 테이블 모두에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">sqlite_offset (X) SQL 함수는 &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; 컴파일 타임 옵션을 사용하여 SQLite를 빌드 한 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset (X) 함수는 값을 읽을 레코드의 시작 부분에 대한 데이터베이스 파일의 바이트 오프셋을 리턴합니다. X가 일반 테이블의 열이 아닌 경우 sqlite_offset (X)는 NULL을 반환합니다. sqlite_offset (X)에 의해 리턴 된 값은 쿼리에 따라 원래 테이블 또는 인덱스를 참조 할 수 있습니다. 값 X가 일반적으로 인덱스에서 추출되면 sqlite_offset (X)는 해당 인덱스 레코드에 오프셋을 리턴합니다. 값 X가 원래 테이블에서 추출되면 sqlite_offset (X)는 테이블 레코드에 오프셋을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_schema 테이블은 sqlite_schema 테이블 자체에 대한 항목이 없다는 점을 제외하고 데이터베이스 스키마의 각 테이블, 인덱스, 뷰 및 트리거 (총칭하여 &quot;객체&quot;)에 대해 하나의 행을 포함합니다. sqlite_schema 테이블에는 응용 프로그램 및 프로그래머 정의 개체 외에도 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 스키마 개체&lt;/a&gt; 에 대한 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8cd91bb0f299cfe62ef641ec65f9fe2bb5de142" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the schema, except there is no entry for the sqlite_schema table itself. See the &lt;a href=&quot;fileformat2#ffschema&quot;&gt;schema storage&lt;/a&gt; subsection of the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for additional information on how SQLite uses the sqlite_schema table internally.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01b38e5a9d3444c64ea7992a244995da2b49b851" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. (&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_schema.name 열은 객체의 이름을 보유합니다. 테이블에 대한 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건으로 인해 SQLite는 &quot;sqlite_autoindex_TABLE_N&quot;형식의 이름을 가진 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스&lt;/a&gt; 를 생성 합니다. 여기서 TABLE은 제약 조건을 포함하는 테이블의 이름으로 대체되고 N은 1로 시작하여 각 제약 조건에 따라 1 씩 증가하는 정수입니다. 테이블 정의에서 볼 수 있습니다. A의 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID없이&lt;/a&gt; 테이블, 기본 키에 대한 sqlite_schema 항목이 없지만, sqlite_schema 항목이 존재했던 것처럼 &quot;sqlite_autoindex_TABLE_N&quot;이름은 PRIMARY KEY 위해 따로 설정되어 있습니다. 이는 후속 UNIQUE 제약 조건의 번호 지정에 영향을줍니다. &quot;sqlite_autoindex_TABLE_N&quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY에 이름이 할당되지 않았습니다.&lt;/a&gt;, rowid 테이블 또는 WITHOUT ROWID 테이블에서.</target>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_schema.rootpage 열은 테이블 및 인덱스에 대한 루트 B- 트리 페이지의 페이지 번호를 저장합니다. 뷰, 트리거 및 가상 테이블을 정의하는 행의 경우 rootpage 열은 0 또는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_schema.sql 열은 객체를 설명하는 SQL 텍스트를 저장합니다. 이 SQL 텍스트는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문으로, &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 주 데이터베이스 일 때 데이터베이스 파일에 대해 평가 하면 개체가 다시 생성됩니다. 텍스트는 일반적으로 개체를 만드는 데 사용 된 원본 문의 복사본이지만 텍스트가 다음 규칙을 따르도록 정규화가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_schema.tbl_name 컬럼은 오브젝트가 연관된 테이블 또는 뷰의 이름을 보유합니다. 테이블 또는 뷰의 경우 tbl_name 열은 이름 열의 복사본입니다. 인덱스의 경우 tbl_name은 인덱싱 된 테이블의 이름입니다. 트리거의 경우 tbl_name 열은 트리거를 발생시키는 테이블 또는 뷰의 이름을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_schema.type 열은 정의 된 객체 유형에 따라 'table', 'index', 'view'또는 'trigger'텍스트 문자열 중 하나입니다. 'table'문자열은 일반 &lt;a href=&quot;vtab&quot;&gt;테이블&lt;/a&gt; 과 가상 테이블 모두에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence 테이블은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 구현을 돕는 데 사용되는 내부 테이블 입니다. sqlite_sequence 테이블은 AUTOINCREMENT 정수 기본 키가있는 일반 테이블이 작성 될 때마다 자동으로 작성됩니다. 일단 sqlite_sequence 테이블은 sqlite_master 테이블에 영원히 존재합니다. 떨어 뜨릴 수 없습니다. sqlite_sequence 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence 테이블은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 구현을 돕는 데 사용되는 내부 테이블 입니다. sqlite_sequence 테이블은 AUTOINCREMENT 정수 기본 키가있는 일반 테이블이 생성 될 때마다 자동으로 생성됩니다. 일단 생성되면 sqlite_sequence 테이블은 sqlite_schema 테이블에 영원히 존재합니다. 삭제할 수 없습니다. sqlite_sequence 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id () 함수는 SQLite 라이브러리를 빌드하는 데 사용 된 특정 버전의 소스 코드를 식별하는 문자열을 리턴합니다. sqlite_source_id ()에 의해 리턴 된 문자열은 소스 코드가 체크인 된 날짜 및 시간과 그 체크인에 대한 SHA1 해시입니다. 이 함수는 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; C 인터페이스 주위의 SQL 랩퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령으로 작성된 내부 테이블이며 쿼리 플래너가 더 나은 쿼리 수행 방법을 찾는 데 사용할 수있는 테이블 및 인덱스에 대한 보충 정보를 보유하는 데 사용됩니다. 애플리케이션은 sqlite_stat1 테이블을 업데이트, 삭제, 삽입 또는 삭제할 수 있지만 sqlite_stat1 테이블을 작성하거나 변경할 수는 없습니다. sqlite_stat1 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">sqlite_stat2.sampleno가 0에서 9 사이 인 인덱스의 sqlite_stat2 항목은 인덱스를 따라 균일 한 간격으로 점에서 가져온 인덱스의 가장 왼쪽 키 값 샘플입니다. C를 색인의 행 수로 설정하십시오. 그런 다음 샘플링 된 행은</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2는 SQLite가 SQLITE_ENABLE_STAT2로 컴파일되고 SQLite 버전 번호가 3.6.18 (2009-09-11)과 3.7.8 (2011-09-19) 사이 인 경우에만 작성되며 사용됩니다. sqlite_stat2 테이블은 3.6.18 이전 또는 3.7.8 이후의 SQLite 버전에서 읽거나 쓰지 않습니다. sqlite_stat2 테이블에는 인덱스 내 키 분배에 대한 추가 정보가 포함되어 있습니다. sqlite_stat2 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2 테이블의 각 행에있는 sqlite_stat2.idx 열과 sqlite_stat2.tbl 열은 해당 행에서 설명하는 인덱스를 식별합니다. sqlite_stat2 테이블에는 일반적으로 각 인덱스에 대해 10 개의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">sqlite_stat3은 SQLite가 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4로&lt;/a&gt; 컴파일되고 SQLite 버전 번호가 3.7.9 (2011-11-01) 이상인 경우에만 사용됩니다 . sqlite_stat3 테이블은 3.7.9 이전의 모든 SQLite 버전에서 읽거나 쓰지 않습니다. 는 IF &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일시 옵션을 사용하고, SQLite는 버전 번호가 3.8.1 (2013년 10월 17일) 이상이다, 다음 sqlite_stat3 읽을 수는 있지만 기록되지 수 있습니다. sqlite_stat3 테이블에는 인덱스 내의 키 분배에 대한 추가 정보, 쿼리 플래너가 더 빠르고 빠른 쿼리 알고리즘을 고안하는 데 사용할 수있는 정보가 포함되어 있습니다. sqlite_stat3 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4는 sqlite_stat3 테이블의 일반화입니다. sqlite_stat3 테이블은 인덱스의 가장 왼쪽 열에 대한 정보를 제공하고 sqlite_stat4 테이블은 인덱스의 모든 열에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4는 SQLite가 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 로 컴파일되고 SQLite 버전 번호가 3.8.1 (2013-10-17) 이상인 경우에만 작성되며 사용됩니다 . sqlite_stat4 테이블은 3.8.1 이전의 SQLite 버전에서 읽거나 쓰지 않습니다. sqlite_stat4 테이블에는 인덱스 내 키 분배 또는 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 의 기본 키 키 분배에 대한 추가 정보가 있습니다. 쿼리 플래너는 sqlite_stat4 테이블의 추가 정보를 사용하여 더 빠르고 더 빠른 쿼리 알고리즘을 고안 할 수 있습니다. sqlite_stat4 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx 열에는 행이 설명하는 인덱스 이름이 있거나 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에 대한 sqlite_stat4 항목 의 경우 테이블 자체의 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt 열은 N 개의 정수 목록을 보유합니다. 여기서 K 번째 정수는 첫 번째 K 열에서 구별되는 색인의 대략적인 항목 수이며 가장 왼쪽의 K 열이 집합 적으로 가장 왼쪽보다 작습니다 샘플의 K 열.</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq 열에는 N 개의 정수 목록이 있습니다. 여기서 K 번째 정수는 가장 왼쪽의 K 열이 샘플의 K 가장 왼쪽 열과 정확히 일치하는 색인의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt 열에는 N 개의 정수 목록이 있습니다. 여기서 K 번째 정수는 K의 가장 왼쪽 열이 집합 적으로 샘플의 K 가장 왼쪽 열보다 작은 인덱스의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample 컬럼은 색인화 컬럼 다음에 rowid 테이블에 대한 rowid 또는 WITHOUT ROWID 테이블에 대한 기본 키의 컬럼을 인코딩 하는 &lt;a href=&quot;fileformat2#record_format&quot;&gt;레코드 형식&lt;/a&gt; 의 BLOB를 보유 합니다. WITHOUT ROWID 테이블 자체의 sqlite_stat4.sample BLOB에는 기본 키의 열만 포함됩니다. sqlite_stat4.sample Blob에 의해 인코딩 된 열 수를 N으로 설정하십시오. 일반 rowid 테이블의 인덱스의 경우 N은 인덱스 된 열 수의 1보다 큽니다. WITHOUT ROWID 테이블에 대한 인덱스의 경우 N은 인덱스 된 열 수에 기본 키의 열 수를 더한 값입니다. WITHOUT ROWID 테이블의 경우 N은 기본 키의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl 열은 행이 설명하는 색인을 소유 한 테이블의 이름을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version () 함수는 실행중인 SQLite 라이브러리의 버전 문자열을 리턴합니다. 이 함수는 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; C 인터페이스 주위의 SQL 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLite 데이터베이스 파일 형식의 안정성과 파일 형식이 크로스 플랫폼이라는 사실은 SQLite 데이터베이스 파일을 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식&lt;/a&gt; 으로 탁월한 선택으로 만들기 위해 결합됩니다 . 미국 의회 도서관 은 디지털 컨텐츠의 장기 보존을 위해 SQLite를 &lt;a href=&quot;locrsf&quot;&gt;권장 스토리지 형식&lt;/a&gt; 으로 표시함으로써이를 인정 합니다.</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">표준 SQLite 소스 트리에는 유닉스 및 윈도우 용 내장 VFS가 포함되어 있습니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 시작 또는 런타임에 대체 VFS를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">데이터베이스 연결이 처음 열릴 때의 컴퓨터 상태는 오른쪽 다이어그램에 개념적으로 표시됩니다. 맨 오른쪽의 다이어그램 영역 ( &quot;디스크&quot;라고 표시됨)은 대용량 저장 장치에 저장된 정보를 나타냅니다. 각 사각형은 섹터입니다. 파란색은 섹터에 원본 데이터가 포함되어 있음을 나타냅니다. 중간 영역은 운영 체제 디스크 캐시입니다. 이 예의 시작에서 캐시는 차갑고 디스크 캐시의 사각형을 비워 두어 표시됩니다. 다이어그램의 왼쪽 영역에는 SQLite를 사용중인 프로세스의 메모리 내용이 표시됩니다. 데이터베이스 연결이 열려 있고 정보를 아직 읽지 않았으므로 사용자 공간이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">위의 설명은 &quot;newtab&quot;이라는 새 지오 폴리 테이블을 만듭니다. 모든 지오 폴리 테이블에는 내장 정수 &quot;rowid&quot;열과 테이블의 해당 행과 관련된 다각형이 포함 된 &quot;_shape&quot;열이 포함됩니다. 위의 예에서는 응용 프로그램이 각 다각형과 연결하는 데 필요한 추가 정보를 저장할 수있는 &quot;a&quot;, &quot;b&quot;및 &quot;c&quot;라는 세 개의 보조 데이터 열도 정의합니다. 보조 정보를 저장할 필요가없는 경우 보조 열 목록을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3ed1fe19431b8dcc87a89320be8ef338ed550ea" translate="yes" xml:space="preserve">
          <source>The statement above has three ordinary columns, &quot;a&quot; (the PRIMARY KEY), &quot;b&quot;, and &quot;c&quot;, and two generated columns &quot;d&quot; and &quot;e&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">위의 내용은 일부 구문 상 구문 상 부정확 할 수 있습니다. 설명은 &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;간단한 fts 쿼리&lt;/a&gt; 를 설명하는 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">명세서 일지는 기본 데이터베이스와 동일한 디렉토리에있을 필요는없는 무작위 이름으로 주어지며, 거래가 끝나면 자동으로 삭제됩니다. 명령문 저널의 크기는 명령문 저널이 작성되게하는 UPDATE 또는 INSERT 문에 의해 구현 된 변경 크기에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">상태 메소드는 기본적으로 &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; C 언어 인터페이스 의 랩퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="c5cf163b4b04538a4fb65ca4f4e01be3e19142a2" translate="yes" xml:space="preserve">
          <source>The step function for an aggregate should always begin with a call to the &lt;a href=&quot;c3ref/aggregate_context&quot;&gt;sqlite3_aggregate_context()&lt;/a&gt; routine to fetch the persistent state of the aggregate function. On the first invocation of the step() function, the aggregate context is initialized to a block of memory that is N bytes in size, where N is the second parameter to sqlite3_aggregate_context() and that memory is zeroed. On all subsequent calls to the step() function, the same block of memory is returned. Except, sqlite3_aggregate_context() might return NULL in the case of an out-of-memory error, so aggregate functions should be prepared to deal with that case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">전략은 &lt;b&gt;sqlite_compile&lt;/b&gt; 을 사용하여 단일 SQL 문을 컴파일 한 다음 각 출력 행에 대해 &lt;b&gt;sqlite_step을&lt;/b&gt; 여러 번 호출 한 다음 SQL 실행이 완료된 후 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출 하여 정리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">길이 P1 (바이트)의 문자열 값 P4는 레지스터 P2에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">이 루틴에서 반환 된 문자열 값은 데이터베이스 연결에서 소유하고 관리합니다. 값은 데이터베이스 N이 &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt; -ed가 될 때까지 또는 데이터베이스 연결이 닫힐 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">이 루틴에서 반환 된 문자열 값은 데이터베이스 연결에서 소유하고 관리합니다. 값은 데이터베이스 N이 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; -ed가 될 때까지 또는 데이터베이스 연결이 닫힐 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql (P) 및 sqlite3_normalized_sql (P)에 의해 리턴 된 문자열은 SQLite에 의해 관리되며 준비된 명령문이 완료되면 자동으로 해제됩니다. 반면에 sqlite3_expanded_sql (P)에 의해 반환 된 문자열은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 가져 와서 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 에 전달하여 응용 프로그램에서 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql (P) 및 sqlite3_normalized_sql (P)에 의해 리턴 된 문자열은 SQLite에 의해 관리되며 준비된 명령문이 완료되면 자동으로 해제됩니다. 반면에 sqlite3_expanded_sql (P)에 의해 반환 된 문자열은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 가져 와서 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 에 전달하여 응용 프로그램에서 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">하위 쿼리와 외부 쿼리는 모두 LIMIT를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">부속 조회와 외부 조회 모두에 ORDER BY 절이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">부속 조회는 LIMIT를 사용하지 않거나 외부 조회는 집계를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">부속 조회가 LIMIT를 사용하지 않거나 외부 조회가 결합이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">부속 조회는 OFFSET을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">부속 조회에는 FROM 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="translated">FROM 절의 하위 쿼리는 각 itemId에 대해 재고를 줄여야하는 양을 계산합니다. 해당 하위 쿼리는 인벤토리 테이블에 대해 조인되고 영향을받는 각 인벤토리 행의 수량은 적절한 양만큼 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">하위 쿼리는 DISTINCT가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">하위 쿼리는 재귀 CTE가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">대체 문자 (유니 코드 코드 포인트 26).</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">위의 SQL 뷰에서 substr () 함수는 첫 번째 문자 (FTS 테이블에 필요하지 않은 &quot;i&quot;열에 해당하는 문자)가 제거 된 rbu_control 인수의 텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">substr (X, Y, Z) 함수는 Y 번째 문자로 시작하고 Z 자 길이 인 입력 문자열 X의 하위 문자열을 반환합니다. Z가 생략되면 substr (X, Y)는 Y 번째로 시작하는 문자열 X의 끝을 통해 모든 문자를 반환합니다. X의 가장 왼쪽 문자는 1입니다. Y가 음수이면 부분 문자열의 첫 번째 문자는 왼쪽이 아니라 오른쪽에서 세어집니다. Z가 음수이면 Y 번째 문자 앞에 오는 abs (Z) 문자가 반환됩니다. X가 문자열이면 문자 색인은 실제 UTF-8 문자를 나타냅니다. X가 BLOB이면 인덱스는 바이트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">모든 &quot;4&quot;값의 합입니다. 이것은 &quot;avg (four)&quot;를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum () 및 total () 집계 함수는 그룹의 모든 NULL이 아닌 값의 합계를 반환합니다. NULL이 아닌 입력 행이 없으면 sum ()은 NULL을 반환하지만 total ()은 0.0을 반환합니다. NULL은 일반적으로 행이없는 합계에 유용한 결과는 아니지만 SQL 표준에서는이를 필요로하며 대부분의 다른 SQL 데이터베이스 엔진은 sum ()을 이런 식으로 구현하므로 SQLite가 호환되도록 동일한 방식으로 수행합니다. 비표준 total () 함수는이 디자인 문제를 SQL 언어로 해결할 수있는 편리한 방법으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">수퍼 저널 파일은 최소 두 개의 데이터베이스가 다음 요구 사항을 모두 충족하는 여러 데이터베이스 파일을 포함하는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 작업에 대해서만 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">수퍼 저널 파일은 단일 트랜잭션이 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문을 사용하여 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 추가 된 여러 데이터베이스를 변경할 때 원자 적 커밋 프로세스의 일부로 사용됩니다 . 수퍼 저널 파일은 항상 기본 데이터베이스 파일과 동일한 디렉토리에 있습니다 (기본 데이터베이스 파일은 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 생성 한 원래 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출 에서 식별되는 데이터베이스입니다 ))를 무작위 접미사로 지정합니다. 수퍼 저널 파일에는 트랜잭션 중에 변경된 다양한 연결된 보조 데이터베이스의 이름이 모두 포함되어 있습니다. 수퍼 저널 파일이 삭제되면 다중 데이터베이스 트랜잭션이 커밋됩니다. 자세한 내용은 &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; 라는 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">인덱스 항목의 키 접미 부에서 중복 컬럼을 억제하는 것은 WITHOUT ROWID 테이블에서만 발생합니다. 일반 rowid 테이블에서 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY 인&lt;/a&gt; 경우에도 색인 항목은 항상 rowid로 끝납니다. 열이 색인화되는 열 중 하나 인 .</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab 구현은 언제든지 데이터베이스를 열거 나 닫을 수 있습니다. 기본적으로 동시에 열려있는 데이터베이스 파일의 최대 수를 9 개로 제한하려고합니다. 이는 하드 제한이 아니며 swarmvtab이이를 초과하는 시나리오를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;동기식 pragma를&lt;/a&gt; 사용하여 런타임시 무결성을 비활성화 할 수 있도록 SQLite가 수행하는 동기화 작업 . PRAGMA synchronous = OFF를 설정하면 모든 동기화 작업이 생략됩니다. 이로 인해 SQLite가 더 빨리 실행되는 것처럼 보이지만 운영 체제가 자유롭게 쓰기 순서를 바꿀 수 있으므로 모든 콘텐츠가 영구 저장소에 도달하기 전에 정전 또는 하드 리셋이 발생하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">이 테스트에서 SQLite의 동기 버전이 가장 느리지 만 비동기 버전이 가장 빠릅니다. 차이점은 fsync ()를 실행하는 데 필요한 추가 시간입니다.</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">윈도우 함수의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">정수 및 부동 소수점 리터럴 (통칭하여 &quot;숫자 리터럴&quot;)의 구문은 다음 다이어그램으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">행 값의 구문과 행 값을 사용할 수있는 환경이 아래 예에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">ON CONFLICT 절의 구문은 CREATE TABLE 명령에서 위와 같습니다. INSERT 및 UPDATE 명령의 경우 키워드 &quot;ON CONFLICT&quot;가 &quot;OR&quot;로 바뀌어 구문이보다 자연스럽게 읽 힙니다. 예를 들어 &quot;INSERT ON CONFLICT IGNORE&quot;대신 &quot;INSERT OR IGNORE&quot;가 있습니다. 키워드는 변경되지만 절의 의미는 어느 쪽이든 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; , &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; , &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; , &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; , &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; , &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 및 기타 여러 명령 의 구문을 통해 사용자는 이름 만 또는 이름과 이름의 조합으로 데이터베이스 오브젝트를 지정할 수 있습니다 데이터베이스. 데이터베이스가 객체 참조의 일부로 지정되지 않으면 SQLite는 기본, 임시 및 연결된 모든 데이터베이스에서 이름이 일치하는 객체를 검색합니다. 임시 데이터베이스를 먼저 검색 한 다음 기본 데이터베이스를 검색 한 다음 연결된 순서대로 모든 연결된 데이터베이스를 검색합니다. 참조는 발견 된 첫 번째 일치로 해석됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">&quot;ON CONFLICT&quot;와 &quot;DO&quot;키워드 사이에서 발생하는 구문을 &quot;충돌 대상&quot;이라고합니다. 충돌 대상은 upsert를 트리거 할 특정 고유 제한 조건을 지정합니다. DO UPDATE upsert에는 충돌 대상이 필요하지만 DO NOTHING의 경우 선택적입니다. 충돌 대상을 생략하면 INSERT 테이블의 고유성 제약 조건을 위반하여 업 사트 동작이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">szOsFile 필드는 열린 파일 인 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체 를 정의하는 구조의 크기 (바이트)입니다 . 이 객체는 아래에서 더 자세히 설명 될 것이다. 여기서 중요한 것은 각 VFS 구현 이 VFS 구현이 열린 파일에 대해 저장해야하는 정보를 포함하는 자체 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체를 정의 할 수 있다는 것 입니다. 그러나 SQLite는 객체를 보유하기에 충분한 공간을 사전 할당하기 위해이 객체의 크기를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile 필드는 이 VFS가 사용 하는 서브 클래스 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 의 크기입니다 . mxPathname은이 VFS에서 경로 이름의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile 필드는 이 VFS가 사용 하는 서브 클래스 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 의 크기입니다 . mxPathname은이 VFS에서 경로 이름의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">t2 테이블은 위의 쿼리에서 완전히 사용되지 않으므로 쿼리 플래너는 작성된 것처럼 쿼리를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="translated">테이블 &quot;t1&quot;에는 특정 데이터 유형이 할당되지 않은 네 개의 열 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;및 &quot;d&quot;가 있습니다. 이러한 열에 원하는 것은 무엇이든 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P2 == 0 인 경우 지워지는 테이블은 기본 데이터베이스 파일에 있습니다. P2 == 1 인 경우 지울 테이블은 CREATE TEMPORARY TABLE을 사용하여 작성하는 테이블을 저장하는 데 사용되는 보조 데이터베이스 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P3 == 0 인 경우 파괴되는 테이블이 기본 데이터베이스 파일에 있습니다. P3 == 1 인 경우 지울 테이블은 CREATE TEMPORARY TABLE을 사용하여 작성하는 테이블을 저장하는 데 사용되는 보조 데이터베이스 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">아래 표에는 SQLite에 사용 가능한 몇 가지 가상 테이블 구현이 나와 있습니다. 개발자는 이러한 가상 테이블을 자체 응용 프로그램에 배포하거나 아래에 표시된 구현을 자체 가상 테이블을 작성하기위한 템플릿으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">테이블에는 개념적으로 많은 행과 열이 있습니다. 그러나이 숫자는 결과표 자체의 일부가 아닙니다. 이 숫자는 별도로 구합니다. N을 행 수로하고 M을 열 수로하십시오.</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">테이블에는 변경 집합에 기록 된 열 수 이상이 있으며</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">테이블에는 변경 세트에 기록 된 것과 동일한 위치에 기본 키 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">테이블의 이름은 변경 집합에 기록 된 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">table_info pragma에 명명 된 테이블도 뷰가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">AS 키워드의 왼쪽에 명명 된 테이블은 복합 select의 가장 오른쪽 SELECT 문의 FROM 절에 정확히 한 번만 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">변경중인 테이블</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">트리거 본문 내에서 DELETE 문의 일부로 지정된 table-name은 규정되지 않아야합니다. 다시 말해</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">트리거 본문 내에서 UPDATE 문의 일부로 지정된 table-name은 규정되지 않아야합니다. 다시 말해</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">테이블 반환 함수는 zip 아카이브의 각 레코드 (파일, 디렉토리 또는 기호 링크)에 대해 하나의 행을 반환합니다. 각 행에는 다음과 같은 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">테이블 반환 함수 구문을 사용하여 대체 순위 함수를 지정할 수도 있습니다. 이 경우 순위 함수를 설명하는 텍스트는 두 번째 테이블 반환 함수 인수로 지정해야합니다. 다음 세 가지 쿼리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">PRAGMA 기능에 대한 테이블 반환 함수는 SQLite 버전 3.16.0 (2017-01-02)에 추가되었습니다. 이전 버전의 SQLite는이 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="translated">tableZ 테이블에는 &quot;INTEGER&quot;라는 단일 열이 있습니다. 해당 열에는 지정된 데이터 유형이 없지만 PRIMARY KEY입니다. 열은 &lt;em&gt;하지 &lt;/em&gt;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY 키&lt;/a&gt; 가 더 데이터 형식이 없기 때문에 테이블에 대한. &quot;INTEGER&quot;토큰은 데이터 유형 키워드가 아닌 열 이름의 식별자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">완전하고 적절한 유니 코드 케이스 폴딩을 수행하는 데 필요한 테이블은 전체 SQLite 라이브러리보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">노조-vtab에 참여하는 테이블이 동일한 데이터베이스 파일에있을 수 있습니다, 또는 그들이하는 별도의 데이터베이스 파일에있을 수 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH가&lt;/a&gt; 동일한 데이터베이스 연결에 -ed.</target>
        </trans-unit>
        <trans-unit id="0d9a0645c34c7b267a5cc6a578129314b8359efc" translate="yes" xml:space="preserve">
          <source>The tables_used table is intended to show which btrees of the database file are read or written by a prepared statement, both by the main statement itself but also by related triggers and foreign key actions. The columns are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">대상 데이터베이스에 INSERT 변경으로 지정된 것과 동일한 PRIMARY KEY 값을 가진 행이 이미 포함되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">대상 데이터베이스에 지정된 PRIMARY KEY 값이있는 행이 포함될 수 있지만 변경으로 수정 될 필드의 현재 값이 변경 세트에 저장된 원래 값과 일치하지 않을 수 있습니다. 패치 세트를 사용할 때는 이러한 유형의 충돌이 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">대상 데이터베이스에 지정된 PRIMARY KEY 값이있는 행이 포함될 수 있지만 다른 필드에는 변경 세트의 일부로 저장된 값과 일치하지 않는 값이있을 수 있습니다. 패치 세트를 사용할 때는 이러한 유형의 충돌이 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">대상 데이터베이스에 삭제할 PRIMARY KEY 값이 지정된 행이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">대상 데이터베이스에 수정할 PRIMARY KEY 값이 지정된 행이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">대상 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="translated">대상 테이블에 대해 자체 조인을 수행하려는 의도가 아니라면 대상 테이블은 FROM 절에 포함되지 않습니다. 자체 조인의 경우 FROM 절의 테이블은 대상 테이블과 다른 이름으로 별칭을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">&quot;조회 계획자&quot;의 임무는 SQL 문을 달성하기위한 최상의 알고리즘 또는 &quot;조회 계획&quot;을 파악하는 것입니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 부터 쿼리 플래너 구성 요소가 더 빨리 실행되고 더 나은 계획을 생성하도록 다시 작성되었습니다. 재 작성을 &quot;차세대 쿼리 플래너&quot;또는 &quot;NGQP&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">일반적으로 같은 팀에 여러 사람이 있으므로 team_id 필드는 고유 할 수 없습니다. 각 팀에는 일반적으로 여러 명의 비 지도자가 있기 때문에 team_id와 is_team_leader의 조합을 고유하게 만들 수 없습니다. 팀당 하나의 리더를 시행하는 솔루션은 team_id에 고유 인덱스를 작성하는 것이지만 is_team_leader가 true 인 항목으로 제한하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">xFindFunction을 갖는 기술은 ()의 반환 값 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION는&lt;/a&gt; 초기의 구현에 사용 된 &lt;a href=&quot;geopoly&quot;&gt;Geopoly 모듈&lt;/a&gt; . xFindFunction ()을위한 모듈이 리턴 SQLITE_INDEX_CONSTRAINT_FUNCTION 방법 &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap ()&lt;/a&gt; SQL 함수 및 그것을위한 SQLITE_INDEX_CONSTRAINT_FUNCTION + 1을 리턴 &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within ()&lt;/a&gt; SQL 함수. 이를 통해 다음과 같은 쿼리에 대한 검색 최적화가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">temp.sqlite_parameters 테이블은 명령 줄 셸의 매개 변수 값만 제공합니다. temp.sqlite_parameter 테이블은 SQLite C 언어 API를 사용하여 직접 실행되는 쿼리에는 영향을 미치지 않습니다. 개별 응용 프로그램은 자체 매개 변수 바인딩을 구현해야합니다. &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;명령 행 쉘 소스 코드&lt;/a&gt; 에서 &quot;sqlite_parameters&quot;를 검색 하여 명령 행 쉘이 매개 변수 바인딩을 수행하는 방법을보고이를 직접 구현하는 방법에 대한 힌트로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령으로 작성된 임시 파일 은 명령 기간 동안 만 존재합니다. 임시 파일의 크기는 원래 데이터베이스보다 크지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">TEMP 데이터베이스 및 해당 롤백 저널과 연관된 임시 파일은 응용 프로그램이 &quot;CREATE TEMP TABLE&quot;문을 사용하는 경우에만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">트랜잭션 제어와 관련된 임시 파일, 즉 롤백 저널, 마스터 저널, WAL (Write-Ahead Log) 파일 및 공유 메모리 파일은 항상 디스크에 기록됩니다. 그러나 다른 종류의 임시 파일은 메모리에만 저장되고 디스크에는 쓰지 않을 수 있습니다. 롤백, 마스터 및 명령문 저널 이외의 임시 파일이 디스크에 기록되거나 메모리에만 저장 &lt;a href=&quot;compile#temp_store&quot;&gt;되는지&lt;/a&gt; 여부는 SQLITE_TEMP_STORE 컴파일 타임 매개 변수, &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 및 임시 파일의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">트랜잭션 제어와 관련된 임시 파일, 즉 롤백 저널, 수퍼 저널, 미리 쓰기 로그 (WAL) 파일 및 공유 메모리 파일은 항상 디스크에 기록됩니다. 그러나 다른 종류의 임시 파일은 메모리에만 저장되고 디스크에 기록되지 않을 수 있습니다. 롤백, 수퍼 및 명령문 저널 이외의 임시 파일이 디스크에 기록되는지 또는 메모리에만 저장 &lt;a href=&quot;compile#temp_store&quot;&gt;되는지&lt;/a&gt; 여부는 SQLITE_TEMP_STORE 컴파일 시간 매개 변수, &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 및 임시 파일의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">전체 텍스트 쿼리 식 내에서 일치하는 용어의 용어 번호입니다. 쿼리 표현식 내의 용어는 발생 순서대로 0부터 시작하여 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">FTS5 색인에 저장된 용어입니다.</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">&quot;보호 된&quot;및 &quot;비보호 된&quot;이라는 용어는 뮤텍스가 보유되는지 여부를 지칭한다. 내부 뮤텍스는 보호 된 sqlite3_value 객체에 대해 유지되지만 보호되지 않은 sqlite3_value 객체에 대해서는 뮤텍스가 유지되지 않습니다. SQLite가 단일 스레드 ( &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 및 &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe ()가&lt;/a&gt; 0을 리턴 함 ) 로 컴파일 되거나 SQLite가 감소 된 뮤텍스 모드 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; 또는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 중 하나로 실행되는 경우 보호 된 sqlite3_value 오브젝트와 구별되지 않는 sqlite3_value 오브젝트간에 구별이 없으며 상호 교환하여 사용하십시오. 그러나 코드 이식성을 최대화하려면 엄격하게 요구되지 않는 경우에도 애플리케이션이 보호 된 sqlite3_value 오브젝트를 여전히 구별하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">&quot;보호 된&quot;및 &quot;비보호 된&quot;이라는 용어는 뮤텍스가 보유되는지 여부를 지칭한다. 내부 뮤텍스는 보호 된 sqlite3_value 객체에 대해 유지되지만 보호되지 않은 sqlite3_value 객체에 대해서는 뮤텍스가 유지되지 않습니다. SQLite가 단일 스레드 ( &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe ()가&lt;/a&gt; 0을 리턴 함 ) 로 컴파일 되거나 SQLite가 감소 된 뮤텍스 모드 &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; 또는 &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 중 하나로 실행되는 경우 보호 된 sqlite3_value 오브젝트와 구별되지 않는 sqlite3_value 오브젝트간에 구별이 없으며 상호 교환하여 사용하십시오. 그러나 코드 이식성을 최대화하려면 엄격하게 요구되지 않는 경우에도 애플리케이션이 보호 된 sqlite3_value 오브젝트를 여전히 구별하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">W와 X의 용어는 정확히 일치해야합니다. SQLite는 똑같이 보이도록 대수를하지 않습니다. &quot;b = 6&quot;이라는 용어는 &quot;b = 3 + 3&quot;또는 &quot;b-6 = 0&quot;또는 &quot;b 6과 6 사이&quot;와 일치하지 않습니다. &quot;b = 6&quot;이 인덱스에 있고 &quot;6 = b&quot;가 쿼리에 있으면 &quot;b = 6&quot;은 &quot;6 = b&quot;와 일치합니다. 색인에 &quot;6 = b&quot;형식의 용어가 나타나면 아무 것도 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">테스트 인프라는 SQLite가 특별히 계측 된 메모리 할당자를 사용하여 동적으로 할당 된 메모리를 오용하지 않는지 확인합니다. 인스트루먼트 된 메모리 할당자는 &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; 옵션을 사용하여 컴파일시 사용 가능합니다 . 인스트루먼트 된 메모리 할당자는 기본 메모리 할당 기보다 훨씬 느리므로 프로덕션 환경에서는 사용하지 않는 것이 좋습니다. 그러나 테스트 중에 활성화되면 인스트루먼트 된 메모리 할당자는 다음 점검을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">테스트 스위트는 위에 표시된 각 ALWAYS () 및 NEVER () 정의마다 한 번씩 세 번 실행되도록 설계되었습니다. 세 가지 테스트 실행 모두 정확히 동일한 결과를 가져와야합니다. &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt; , ...) 인터페이스를 사용하는 런타임 테스트 가 있으며 이는 배치를 위해 매크로가 첫 번째 양식 (통과 양식)으로 올바르게 설정되었는지 검증하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">SQLite 용 테스트 스위트는 또한 여러 오류를 스태킹 한 결과를 탐색합니다. 예를 들어, 이전 충돌에서 복구하려고 시도하는 동안 I / O 오류 또는 OOM 오류가 발생할 때 올바른 동작을 보장하기 위해 테스트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">test1.dir 디렉토리는 &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot;등과 같은 이름을 가진 100,000 개의 파일을 포함하지만 test1.tree 디렉토리는 &quot;00/00/00&quot;, &quot;00과 같은 서브 디렉토리에 동일한 파일을 포함합니다. / 00 / 01 &quot;등. test1.dir 및 test1.test 디렉토리는 대략 동일한 공간을 차지하지만 test1.test는 추가 디렉토리 항목으로 인해 약간 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">test_async.c 드라이브는 이제 전체 파일 잠금을 수행하고 동일한 데이터베이스의 여러 프로세스에서 동시에 사용될 때 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">testcase () 매크로는 종종 불평등 비교의 경계 사례가 확인되었는지 확인하는 데 사용됩니다. 예를 들어 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766에&lt;/a&gt; 있습니다. 이러한 종류의 검사는 개별 오류를 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">testcase (X) 매크로는 일반적으로 no-op이지만, 적용 범위 테스트 빌드의 경우 X가 true 및 X 인 테스트 케이스가 있는지 확인하기 위해 하나 이상의 브랜치를 포함하는 소량의 추가 코드를 생성합니다. 그릇된.</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">SQLite의 테스트 프로세스는 &lt;a href=&quot;testing&quot;&gt;테스트&lt;/a&gt; 문서에 설명되어 있습니다. 테스트 목표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">테스트 프로세스는 &lt;a href=&quot;testing#cklist&quot;&gt;릴리스 테스트 체크리스트에&lt;/a&gt; 의해 제어됩니다 . 체크리스트는 SQLite를 완전히 검증하는 데 필요한 모든 단계를 간결하게 요약하고 각 검증 단계가 수행 된시기와 대상을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">텍스트 형식은 순수한 SQL이므로 .dump 명령을 사용하여 SQLite 데이터베이스를 다른 인기있는 SQL 데이터베이스 엔진으로 내보낼 수도 있습니다. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_master.sql 열의 텍스트는 위에서 설명한대로 정규화되고 후속 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 문 으로 수정 된 경우를 제외하고 객체를 만든 원래 CREATE 문 텍스트의 복사본입니다 . &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건에 의해 자동으로 생성되는 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스&lt;/a&gt; 의 경우 sqlite_master.sql은 NULL입니다 .</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_schema.sql 열의 텍스트는 위에서 설명한대로 정규화되고 후속 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 문에 의해 수정 된 경우를 제외하고 개체를 생성 한 원래 CREATE 문 텍스트의 복사본입니다 . sqlite_schema.sql은 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건에 의해 자동으로 생성되는 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스의&lt;/a&gt; 경우 NULL입니다 .</target>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">조회 매개 변수의 텍스트는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xOpen 메소드의 파일 이름 인수에 추가됩니다 . 쿼리 매개 변수의 % HH 이스케이프 시퀀스는 xOpen 파일 이름에 추가되기 전에 확인됩니다. 단일 0 바이트는 xOpen 파일 이름 인수를 첫 번째 쿼리 매개 변수의 키, 각 키 및 값, 각 후속 키를 이전 값과 구분합니다. xOpen 파일 이름에 추가 된 쿼리 매개 변수 목록은 길이가 0 인 단일 키로 종료됩니다. 쿼리 매개 변수의 값은 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">패턴과 일치하는 단어의 텍스트입니다. 단어와 패턴 모두 유니 코드 문자를 포함 할 수 있으며 대소 문자를 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af9ff5f020628933bb8ed136e797234a16f70b6" translate="yes" xml:space="preserve">
          <source>The text output of the one-argument form of ieee754() is great for human readability, but it awkward to use as part of a larger expression. Hence The ieee754_mantissa() and ieee754_exponent() routines were added to return the M and E values corresponding to their single argument F value. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">선택한 텍스트의 시작 또는 끝에 추가 할 텍스트는 반환 된 텍스트가 해당 열의 시작 또는 끝에서 각각 발생하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">각 문구 뒤에 삽입 할 텍스트는 반환 된 텍스트 내에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">각 구가 일치 한 후 삽입 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">각 문구 앞에 삽입 할 텍스트는 반환 된 텍스트 내에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">각 구가 일치하기 전에 삽입 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">테이블의 이론상 최대 행 수는 2 &lt;sup&gt;&lt;small&gt;64입니다&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 또는 약 1.8e + 19). 최대 140 테라 바이트의 데이터베이스 크기에 먼저 도달하므로이 한계에 도달 할 수 없습니다. 140 테라 바이트 데이터베이스는 대략 1e + 13 개의 행을 보유 할 수 있으며, 인덱스가없고 각 행에 데이터가 거의없는 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">테이블의 이론적 인 최대 행 수는 2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 또는 약 1.8e + 19)입니다. 최대 데이터베이스 크기 인 281TB에 먼저 도달하므로이 제한에 도달 할 수 없습니다. 281 테라 바이트 데이터베이스는 약 2e + 13 행을 보유 할 수 있으며, 인덱스가없고 각 행에 매우 적은 데이터가 포함 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">이러한 루틴은 결과의 데이터 유형 변환을 시도 할 수 있습니다. 예를 들어, 내부 표현이 FLOAT이고 텍스트 결과가 요청 된 경우 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 가 내부적으로 사용되어 자동으로 변환을 수행합니다. 다음 표에는 적용되는 변환이 자세히 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">이러한 루틴은 결과의 데이터 유형 변환을 시도 할 수 있습니다. 예를 들어, 내부 표현이 FLOAT이고 텍스트 결과가 요청 된 경우 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 가 내부적으로 사용되어 자동으로 변환을 수행합니다. 다음 표에는 적용되는 변환이 자세히 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">이 함수의 세 번째 및 네 번째 매개 변수는 각각 원하는 열의 테이블 및 열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">세 번째 인수 (eTextRep)는 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">세 번째 인수는 매개 변수에 바인딩 할 값입니다. sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_blob ()의 세 번째 매개 변수가 NULL 포인터 인 경우 네 번째 매개 변수는 무시되고 최종 결과는 sqlite3_bind_null ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="translated">세 번째 인수는 매개 변수에 바인딩 할 값입니다. sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_blob ()의 세 번째 매개 변수가 NULL 포인터이면 네 번째 매개 변수는 무시되고 최종 결과는 sqlite3_bind_null ()과 동일합니다. sqlite3_bind_text ()의 세 번째 매개 변수가 NULL이 아니면 올바른 형식의 UTF8 텍스트에 대한 포인터 여야합니다. sqlite3_bind_text16 ()에 대한 세 번째 매개 변수가 NULL이 아니면 올바른 형식의 UTF16 텍스트에 대한 포인터 여야합니다. sqlite3_bind_text64 ()에 대한 세 번째 매개 변수가 NULL이 아니면 여섯 번째 매개 변수가 SQLITE_UTF8이면 UTF8이고 그렇지 않으면 UTF16 인 올바른 형식의 유니 코드 문자열에 대한 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; , ...) 인터페이스에 대한 세 번째 인수 ( 위의 예에서 &quot;pData&quot;인수)는 임의의 데이터에 대한 포인터입니다. SQLite는이 포인터를 오류 로거 콜백의 첫 번째 인수로 전달합니다. 원하는 경우 포인터를 사용하여 응용 프로그램 별 설정 또는 상태 정보를 전달할 수 있습니다. 또는 단순히 콜백에서 무시되는 NULL 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">세 번째 차트는 SQLite에서 Blob 내용을 읽는 것이 Mac 및 Android 용 디스크의 개별 파일을 읽는 것보다 두 배 빠르며 Windows의 경우 10 배 더 빠르다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">세 번째 열은 테이블에있는 모든 rowid의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">INSERT 문의 세 번째 형식은 DEFAULT VALUES입니다. INSERT ... DEFAULT VALUES 문은 이름 지정된 테이블에 하나의 새 행을 삽입합니다. 새 행의 각 열은 &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;기본값으로&lt;/a&gt; 채워지 거나 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 열 정의의 일부로 기본값이 지정되지 않은 경우 NULL 로 채워집니다 . DEFAULT VALUES 이후 에는 &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; 가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">예제의 세 번째 줄은 CSV 파일의 모든 내용을 읽는 데 사용되는 가상 테이블을 보여줍니다. 이것은 아마도 가상 테이블의 가장 간단한 사용 일 것입니다. CSV 가상 테이블은 일반 가상 테이블을 사용할 수있는 모든 곳에서 사용할 수 있습니다. 서브 쿼리 또는 &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 에서 CSV 가상 테이블을 사용 하거나 필요에 따라 WHERE, GROUP BY, HAVING, ORDER BY 및 LIMIT 절을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">세 번째 숫자 Z는 성능 향상 및 / 또는 버그 수정을 구현하는 작은 변경 사항만으로 구성된 릴리스에 대해 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">롤백 저널 파일을 삭제하지 않고 저널 파일 헤더를 0으로 만드는 세 번째 최적화는 항상 독점 잠금을 유지하는 데 의존하지 않습니다. 이 최적화는 아래 &lt;a href=&quot;#section_7_6&quot;&gt;섹션 7.6에&lt;/a&gt; 설명 된 것처럼 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; 를 사용하여 배타적 잠금 모드와 독립적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">세 번째 매개 변수 (nArg)는 SQL 함수 또는 집계가 취하는 인수 수입니다. 이 매개 변수가 -1이면 SQL 함수 또는 집계는 0과 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; )에 의해 설정된 한계 사이에서 임의의 수의 인수를 취할 수 있습니다 . 세 번째 매개 변수가 -1보다 작거나 127보다 큰 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">세 번째 매개 변수 (nArg)는 SQL 함수 또는 집계가 취하는 인수 수입니다. 이 매개 변수가 -1이면 SQL 함수 또는 집계는 0과 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; )에 의해 설정된 한계 사이에서 임의의 수의 인수를 취할 수 있습니다 . 세 번째 매개 변수가 -1보다 작거나 127보다 큰 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">세 번째 단계는 4 개의 가장 짧은 2 노드 경로로 시작하여 4 개의 가장 짧은 3 노드 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">스레딩 모드는 컴파일 타임 (SQLite 라이브러리가 소스 코드에서 컴파일 될 때) 또는 시작 시간 (SQLite를 사용하려는 응용 프로그램이 초기화 될 때) 또는 런타임 (새 SQLite 데이터베이스 인 경우)에서 선택할 수 있습니다. 연결 중입니다). 일반적으로 런타임은 시작 시간을 재정의하고 시작 시간은 컴파일 타임을 재정의합니다. 단, 단일 스레드 모드는 일단 선택한 후에는 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">개별 데이터베이스 연결의 스레딩 모드는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()에&lt;/a&gt; 대한 세 번째 인수로 지정된 플래그에 의해 결정됩니다 . &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 플래그는 데이터베이스 연결이 멀티 스레드 모드로 원인과 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX의&lt;/a&gt; 플래그는 직렬화 모드로 연결됩니다. 어느 플래그가 지정된 경우, 또는 경우 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 대신에 사용된다 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , 디폴트 모드 설정을 사용-시작 시간 컴파일 시간에 의해 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">세 가지 보조 함수는 FTS 테이블의 전체 텍스트 인덱스를 사용하는 SELECT 문에서만 유용합니다. &quot;rowid로 쿼리&quot;또는 &quot;선형 스캔&quot;전략을 사용하는 SELECT 내에서 스 니펫과 오프셋은 모두 빈 문자열을 반환하고 matchinfo 함수는 크기가 0 바이트 인 블롭 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">위에서 설명한 세 가지 기본 쿼리 유형을 사용하여 지정된 기준과 일치하는 문서 집합에 대한 전체 텍스트 인덱스를 쿼리 할 수 ​​있습니다. FTS 쿼리 표현식 언어를 사용하면 기본 쿼리 결과에 대해 다양한 세트 작업을 수행 할 수 있습니다. 현재 지원되는 세 가지 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">zipfile 가상 테이블의 가장 왼쪽 열인 &quot;name&quot;, &quot;mode&quot;및 &quot;mtime&quot;은 각각 동일한 열에 삽입 될 수있는 값으로 설정 될 수 있습니다 (위 참조). &quot;mode&quot;또는 &quot;mtime&quot;이 NULL로 설정된 경우 최종 값은 NULL 값의 INSERT에 대해 설명 된대로 결정됩니다. &quot;mtime&quot;의 현재 시간 및 &quot;mode&quot;의 경우 33188 또는 16877입니다. zipfile 테이블의 다음 네 열에 지정된 값이 아니라면 항목이 디렉토리 또는 파일임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">시간 문자열 다음에는 날짜 및 / 또는 시간을 변경하는 0 개 이상의 수정자가 올 수 있습니다. 각 수정자는 왼쪽의 시간 값에 적용되는 변환입니다. 수정자는 왼쪽에서 오른쪽으로 적용됩니다. 순서가 중요합니다. 사용 가능한 수정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">각 가상 머신 작업을 실행하는 데 걸리는 시간은 여러 요인에 따라 달라질 수 있습니다. 1GHz PC의 일반적인 값은 초당 50 만에서 3 백만 사이이지만 쿼리에 따라 훨씬 높거나 낮을 수 있습니다. 따라서 가상 머신 작업을 기반으로 백그라운드 작업을 예약하기가 어렵습니다. 대신 콜백을 비교적 자주 예약하고 (예 : 1000 개의 명령마다) 백그라운드 작업을 실행해야하는지 여부를 결정하는 데 사용되는 외부 타이머 루틴을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">모든 테스트에서보고 된 시간은 초 단위의 벽시계 시간을 나타냅니다. SQLite에 대해 두 개의 개별 시간 값이보고됩니다. 첫 번째 값은 전체 디스크 동기화가 설정된 기본 구성의 SQLite입니다. 동기화가 설정되면 SQLite는 &lt;b&gt;fsync ()를&lt;/b&gt; 실행합니다.&lt;b&gt;&lt;/b&gt;중요한 데이터가 실제로 디스크 드라이브 표면에 기록되었는지 확인하기 위해 주요 지점에서 시스템 호출 (또는 이에 상응하는 기능). 데이터베이스 업데이트 도중 운영 체제가 충돌하거나 컴퓨터 전원이 예기치 않게 꺼지는 경우 데이터베이스의 무결성을 보장하기 위해 동기화가 필요합니다. SQLite에 대해보고 된 두 번째 시간은 동기화가 해제 된 경우입니다. 동기화를 해제하면 SQLite가 훨씬 빠르지 만 운영 체제 충돌 또는 예기치 않은 정전으로 인해 데이터베이스가 손상 될 수 있습니다. 일반적으로, 동기 SQLite 시간은 PostgreSQL (동기)과 비교하기위한 것이고 비동기 SQLite 시간은 비동기 MySQL 엔진과 비교하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">b- 트리 페이지의 사용 가능한 총 공간 크기는 할당되지 않은 영역의 크기와 모든 사용 가능한 블록의 전체 크기에 조각난 사용 가능한 바이트 수를 더한 값으로 구성됩니다. SQLite는 때때로 프리 블록 또는 프래그먼트 바이트가없고, 사용되지 않은 모든 바이트가 할당되지 않은 공간 영역에 포함되며 모든 셀이 페이지의 끝에 단단히 묶여 있도록 b- 트리 페이지를 재구성 할 수 있습니다. 이것을 b- 트리 페이지 &quot;조각 모음&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">전체 FTS5 테이블에서 용어의 총 인스턴스 수입니다.</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">FTS5 테이블의 $ col 열에 나타나는 용어의 총 인스턴스 수입니다 (모든 행을 고려).</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="translated">현재 행에 대한 btree의 총 페이지 수</target>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">FTS 테이블에서 열에 하나 이상의 문구 인스턴스가 포함 된 총 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">FTS 테이블의 모든 행에서 열에 문구가 나타나는 총 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">total_changes () 함수는 현재 데이터베이스 연결이 열린 이후 INSERT, UPDATE 또는 DELETE 문으로 인한 행 변경 수를 리턴합니다. 이 함수는 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; C / C ++ 인터페이스를 감싸는 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">기존의 롤백 저널은 변경되지 않은 원래 데이터베이스 컨텐츠의 사본을 별도의 롤백 저널 파일에 기록한 다음 변경 사항을 데이터베이스 파일에 직접 기록하여 작동합니다. 충돌 또는 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK의&lt;/a&gt; 경우 롤백 저널에 포함 된 원래 컨텐츠가 데이터베이스 파일로 재생되어 데이터베이스 파일을 원래 상태로 되돌립니다. 는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 롤백 저널이 삭제 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">이 정보를 전달하는 전통적인 방법은 C 언어 포인터를 BLOB 또는 64 비트 정수로 변환 한 다음 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; 또는 정수 등가</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">트랜잭션 명령을 사용하여 여러 SQLite 명령을 안전하게 그룹화 할 수 있습니다. 물론 BEGIN을 사용하여 수동으로 거래를 시작할 수 있습니다. 그러나 COMMIT 또는 ROLLBACK이 실행되지 않도록 오류가 발생하면 데이터베이스는 무기한으로 잠금 상태를 유지합니다. 또한 BEGIN은 중첩되지 않으므로 새 트랜잭션을 시작하기 전에 다른 트랜잭션이 활성화되어 있지 않은지 확인해야합니다. &quot;트랜잭션&quot;방법은 이러한 모든 세부 사항을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">이 시점에서 트랜잭션이 이미 커밋되었으므로 롤백 저널 삭제시 타이밍이 중요하지 않습니다. 현재 구현은 단일 롤백 저널을 삭제 한 후 다음 롤백 저널로 진행하기 전에 해당 데이터베이스 파일을 잠금 해제합니다. 그러나 앞으로는 데이터베이스 파일을 잠금 해제하기 전에 모든 롤백 저널이 삭제되도록이를 변경할 수 있습니다. 해당 데이터베이스 파일이 잠금 해제되기 전에 롤백 저널이 삭제되는 한 롤백 저널이 삭제되거나 데이터베이스 파일이 잠금 해제되는 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">변환은 다음 공식에 따라 다각형의 각 정점을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">결과가 작성되는 임시 테이블은 명령 0으로 작성됩니다. 그런 다음 세 개의 루프가 이어집니다. 명령어 5-10의 루프는 첫 번째 SELECT 문을 구현합니다. 두 번째 SELECT 문은 명령 14-19에서 루프로 구현됩니다. 마지막으로 명령 22-25의 루프는 임시 테이블을 읽고 결과의 각 행에 대해 콜백을 한 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">내부 SELECT의 결과가 저장되는 임시 테이블은 &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; 명령에 의해 0에 작성됩니다. 이 opcode는 단일 SQL 문 기간 동안 존재하는 테이블에 사용됩니다. 기본 데이터베이스가 읽기 전용 인 경우에도 임시 커서는 항상 읽기 / 쓰기로 열립니다. 커서가 닫히면 임시 테이블이 자동으로 삭제됩니다. P2 값 1은 커서가 데이터는 없지만 임의의 키를 가질 수있는 BTree 인덱스를 가리킴을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">SQLite 버전 3.4.2에서 3.5.0으로의 전환이 크게 변경되었습니다. SQLite 코어의 모든 소스 코드 파일은 광범위하게 수정되어야했습니다. 그리고이 변경으로 인해 C 인터페이스에서 약간의 비 호환성이 발생했습니다. 그러나 우리는 3.4.2에서 3.5.0으로의 전환의 이점이 이식의 고통보다 훨씬 크다고 생각합니다. 새로운 VFS 계층은 이제 잘 정의되고 안정적이며 향후 사용자 지정을 단순화해야합니다. VFS 계층과 분리 가능한 메모리 할당 기 및 뮤텍스 하위 시스템을 통해 표준 SQLite 소스 코드 통합을 변경없이 포함 된 프로젝트에서 사용할 수 있으므로 구성 관리가 크게 간소화됩니다. 그리고 결과 시스템은 높은 스레드 설계에 훨씬 더 견딜 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">트릭은 -DTCLSH = 1 옵션입니다. SQLite 용 TCL 인터페이스 모듈에는 TCL 인터프리터를 초기화하고 -DTCLSH = 1로 컴파일 될 때 명령 행 루프를 입력 하는 &lt;b&gt;main ()&lt;/b&gt; 프로 시저가 포함되어 있습니다. 위의 명령은 Linux 및 Mac OS X에서 모두 작동하지만 플랫폼 및 TCL 버전에 따라 라이브러리 옵션을 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="translated">이전 명령문에 의해 생성 된 트리거의 이름은 &quot;AFTER&quot;이며 &quot;BEFORE&quot;트리거입니다. &quot;AFTER&quot;토큰은 문을 구문 분석하는 유일한 방법이므로 키워드 대신 식별자로 사용됩니다. 다른 예시:</target>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">trim (X, Y) 함수는 X의 양쪽 끝에서 Y에 나타나는 모든 문자를 제거하여 형성된 문자열을 반환합니다. Y 인수가 생략되면 trim (X)는 X의 양쪽 끝에서 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid 테이블의 실제 기본 키 (기본 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 스토리지 엔진 에서 행을 조회하는 키로 사용되는 값 )는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 절단 최적화를 비활성화 할 수도 있습니다 . 권한 부 여자 콜백 이 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 조치 코드에 대해 &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하면 DELETE 조작은 진행되지만 절단 최적화는 생략되고 행은 하나씩 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; 컴파일 타임 스위치를 사용하여 SQLite를 다시 컴파일하면 모든 쿼리에 대해 잘림 최적화를 영구적으로 사용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="translated">trusted_schema 설정은 뷰에 의해 운영 될 수 있습니다 감사 보안되지 않았습니다 여부 SQL 기능과 가상 테이블을 결정하는 당 연결 부울이다, 트리거, 또는 같은 스키마의 표현에 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;gencol&quot;&gt;생성 열&lt;/a&gt; , &lt;a href=&quot;expridx&quot;&gt;표현식 색인&lt;/a&gt; 및 / 또는 &lt;a href=&quot;partialindex&quot;&gt;부분 색인&lt;/a&gt; . 이 설정은 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; , ...) C 언어 인터페이스를 사용하여 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">두 가지 &quot;0&quot;매개 변수는 일부 상황에서 서버를 목적으로 사용하지만 이러한 루틴을 사용하여 구문 분석 트리를 터미널에서 ASCII 아트로 인쇄하려면 둘 다 &quot;0&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">오프셋 52 및 64에서 2 개의 4 바이트 빅 엔디안 정수는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 모드 를 관리하는 데 사용됩니다 . 오프셋 52의 정수가 0이면 포인터 맵 (ptrmap) 페이지가 데이터베이스 파일에서 생략되고 auto_vacuum 또는 incremental_vacuum이 지원되지 않습니다. 오프셋 52의 정수가 0이 아닌 경우 데이터베이스 파일에서 가장 큰 루트 페이지의 페이지 번호이며 데이터베이스 파일에는 ptrmap 페이지가 포함되며 모드는 auto_vacuum 또는 incremental_vacuum이어야합니다. 후자의 경우 오프셋 64의 정수는 incremental_vacuum의 경우 true이고 auto_vacuum의 경우 false입니다. 오프셋 52의 정수가 0이면 오프셋 64의 정수도 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">두 가지 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">두 가지 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">윈도우 &quot;win&quot;정의에 프레임 스펙이 포함되어 있으면 후자의 SQL이 실패하므로 아래의 두 SQL 조각은 비슷하지만 완전히 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">나머지 두 테이블 인 % _segments 및 % _segdir은 전체 텍스트 인덱스를 저장하는 데 사용됩니다. 개념적으로이 인덱스는 각 용어 (워드)를 하나 이상의 용어가 포함 된 % _content 테이블의 레코드에 해당하는 docid 값 집합에 매핑하는 조회 테이블입니다. 지정된 용어가 포함 된 모든 문서를 검색하기 위해 FTS 모듈은이 인덱스를 쿼리하여 용어가 포함 된 레코드의 문서 값 집합을 결정한 다음 % _content 테이블에서 필요한 문서를 검색합니다. FTS 가상 테이블의 스키마에 관계없이 % _segments 및 % _segdir 테이블은 항상 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">WAL 파일 헤더에서 복사 된 2 개의 솔트 값입니다. 이 값은 WAL 파일의 바이트 순서이며 시스템의 기본 바이트 순서와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 의 두 인수 버전은 두 번째 인수가 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인드 된 매개 변수 인&lt;/a&gt; 경우 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ) 설정 없이도 토크 나이저 메소드 오브젝트에 대한 포인터를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">오프셋 1의 2 바이트 정수는 페이지에서 첫 번째 여유 블록의 시작을 제공하거나 여유 블록이없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">오프셋 3의 2 바이트 정수는 페이지의 셀 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">오프셋 5의 2 바이트 정수는 셀 내용 영역의 시작을 나타냅니다. 이 정수의 0 값은 65536으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">오프셋 16에서 시작하는 2 바이트 값은 데이터베이스의 페이지 크기를 결정합니다. SQLite 버전 3.7.0.1 (2010-08-04) 이하의 경우이 값은 빅 엔디안 정수로 해석되며 512에서 32768 사이의 2의 제곱이어야합니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;버전 3.7.1&lt;/a&gt; (2010-08-23) 부터는 페이지 크기 65536 바이트가 지원됩니다. 65536 값은 2 바이트 정수에 맞지 않으므로 65536 바이트 페이지 크기를 지정하려면 오프셋 16의 값은 0x00 0x01입니다. 이 값은 빅 엔디안 1로 해석 될 수 있으며 65536 페이지 크기를 나타내는 마법의 숫자로 생각됩니다. 또는 2 바이트 필드를 리틀 엔디안 숫자로보고 페이지 크기를 256으로 나눈 값을 나타냅니다.이 두 페이지 크기 필드 해석은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">특정 C ++ 컴파일러에서 문제를 해결하려면 typedef가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">typeof (X) 함수는 표현식 X 의 &lt;a href=&quot;datatype3&quot;&gt;데이터 유형&lt;/a&gt; &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;또는 &quot;blob&quot; 를 나타내는 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">각 열에 첨부 된 유형 및 기본 데이터 정렬 순서는 모든 구성 요소 테이블에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">단항 연산자</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">압축 해제 기능은 압축 기능에 의해 이전에 압축 된 데이터를 압축 해제해야합니다. 다시 말해, 모든 SQLite 값 X에 대해 uncompress (compress (X))가 X와 같다는 것이 사실이어야합니다. 압축 함수로 압축 된 데이터를 FTS4가 데이터베이스에서 읽을 때 압축 해제 기능으로 전달됩니다. 사용하기 전에.</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">기본 구현은이 단락의 다른 요구 사항을 충족하는 한 이러한 잠금 수준의 일부를 지원할 수 있습니다. 잠금 수준은 xLock 및 xUnlock에 대한 두 번째 인수로 지정됩니다. xLock 메소드는 잠금 레벨을 지정된 잠금 레벨 이상으로 증가시킵니다. xUnlock 메소드는 잠금 레벨을 지정된 레벨 이상으로 줄입니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; 은 파일이 잠금 해제 되었음을 의미합니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; 는 파일을 읽을 수있는 권한을 부여합니다. 다중 데이터베이스 연결은 &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; 를 동시에 보유 할 수 있습니다 . &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; 는 SQLITE_LOCK_SHARED 와 &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;같습니다.&lt;/a&gt;파일을 읽을 수있는 권한이라는 점에서 그러나 어느 시점에서든 단일 연결 만 예약 잠금을 유지할 수 있습니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING는&lt;/a&gt; 또한 파일을 읽을 수있는 권한입니다. 다른 연결에서도 파일을 계속 읽을 수 있지만 다른 연결에서는 잠금을 없음에서 공유로 에스컬레이션 할 수 없습니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; 는 파일에 쓸 수있는 권한입니다. 단일 연결 만 단독 잠금을 보유 할 수 있으며 다른 연결은 &quot;없음&quot;이외의 다른 잠금을 보유 할 수 없지만 한 연결은 단독 잠금을 보유합니다. XLOCK 반환 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK을&lt;/a&gt; , 성공 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 는 잠금, 또는 취득 할 수없는 경우 &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK을&lt;/a&gt; 다른 뭔가가 잘못되면. xUnlock 메소드는&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 성공에 &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; 문제.</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">밑줄 문자 (유니 코드 코드 포인트 96).</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">undo :: activate 명령은 인수에 이름이 지정된 테이블의 모든 변경 사항을 기록하는 임시 트리거를 데이터베이스에 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">문서화되지 않은 &lt;b&gt;sqlite3_os_switch ()&lt;/b&gt; 인터페이스가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">유니 코드 토크 나이 저는 모든 유니 코드 문자를 &quot;구분자&quot;또는 &quot;토큰&quot;문자로 분류합니다. 기본적으로 유니 코드 6.1에 정의 된대로 모든 공백 및 문장 부호 문자는 구분 기호로 간주되고 다른 모든 문자는 토큰 문자로 간주됩니다. 보다 구체적으로, &quot;L&quot;또는 &quot;N&quot;(특히 문자 및 숫자)으로 시작 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;일반 범주&lt;/a&gt; 또는 &quot;Co&quot;( &quot;기타 개인 용도&quot;) 범주에 할당 된 모든 유니 코드 문자 는 토큰으로 간주됩니다. 다른 모든 문자는 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">unicode (X) 함수는 문자열 X의 첫 번째 문자에 해당하는 숫자 유니 코드 코드 포인트를 리턴합니다. unicode (X)에 대한 인수가 문자열이 아닌 경우 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">union-vtab은 SQLite에 내장되어 있지 않습니다. Union-vtab은 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 입니다. union-vtab의 소스 코드 는 SQLite 소스 트리의 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt; 에 있는 단일 파일에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">union-vtab은 읽기 전용입니다. 쓰기 지원은 나중에 추가 될 수 있지만 쓰기는 초기 구현의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">union-vtab은 쿼리의 제약 조건이 아래에 표시된 형식 중 하나 인 경우 기본 실제 테이블에 대한 액세스를 최적화해야합니다. 앞으로 다른 종류의 제약이 최적화 될 수 있지만 초기 구현에서는 이러한 제약 만이 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">고유 ID (INTEGER PRIMARY KEY)</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 파일 디스크립터를</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">unlikely (X) 함수는 변경되지 않은 인수 X를 리턴합니다. 가능하지 않은 (X) 함수는 코드 생성기가 최적화하여 런타임에 (즉, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 호출하는 동안) CPU주기를 소비하지 않도록 최적화 합니다. unlikely (X) 함수의 목적은 쿼리 플래너에 인수 X가 일반적으로 true가 아닌 부울 값이라는 힌트를 제공하는 것입니다. 가능하지 않은 (X) 함수는 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성&lt;/a&gt; (X, 0.0625)과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">잠금 해제 알림 콜백은 재진입이 아닙니다. 애플리케이션이 unlock-notify 콜백 내에서 sqlite3_xxx API 함수를 호출하면 충돌 또는 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">unlock_notify 메소드는 테스트 목적으로 SQLite 코어 라이브러리에 대한 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스에 액세스하는 데 사용 됩니다. 응용 프로그램에서이 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">업데이트 후크 구현은 업데이트 후크를 호출 한 데이터베이스 연결을 수정하는 작업을 수행하지 않아야합니다. 데이터베이스 연결을 수정하기위한 모든 조치 는 업데이트 후크를 트리거 한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출이 완료 될 때까지 연기되어야합니다 . 참고 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">업데이트 후크 구현은 업데이트 후크를 호출 한 데이터베이스 연결을 수정하는 작업을 수행하지 않아야합니다. 데이터베이스 연결을 수정하기위한 모든 조치 는 업데이트 후크를 트리거 한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출이 완료 될 때까지 연기되어야합니다 . 참고 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 (예 : sqlite_master 및 sqlite_sequence) 업데이트 후크가 호출되지 않습니다. &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 (예 : sqlite_master 및 sqlite_sequence) 업데이트 후크가 호출되지 않습니다. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 (예 : sqlite_sequence). &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 되면 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 (예 : sqlite_sequence). &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 되면 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">데이터베이스 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;캐시 크기&lt;/a&gt; 의 상한 은 기본적으로 2000 페이지로 기본 설정되었습니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; 은이 기본 설정을 &quot;-2000&quot;으로 변경하여 페이지 크기에 관계없이 2000 * 1024 바이트를 의미합니다. 따라서 페이지 캐시에 사용 된 메모리 양의 상한은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">upper (X) 함수는 모든 소문자 ASCII 문자가 대문자로 변환되는 입력 문자열 X의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">위의 upsert는 해당 단어가 사전에 없거나 사전에 있으면 새 어휘 &quot;jovial&quot;을 삽입합니다. &quot;count + 1&quot;표현식은 &quot;vocabulary.count&quot;로 쓸 수도 있습니다. PostgreSQL에는 두 번째 형식이 필요하지만 SQLite는 두 가지 형식 중 하나를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">페이지 캐시 메모리의 사용은 SQLite 버전 3.6.1에서 제어하기가 다소 어렵지만 페이지 캐시 메모리를 훨씬 쉽게 제어 할 수있는 후속 릴리스에 대한 메커니즘이 계획되어 있습니다. 이러한 새로운 메커니즘을 도입하기 전에 pagecache 메모리를 제어하는 ​​유일한 방법은 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma를&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">변수 이름 앞에 &quot;$&quot;대신 &quot;:&quot;을 사용하면 SQL 텍스트가 중괄호 {...} 대신 큰 따옴표 &quot;...&quot;로 묶인 경우 유용 할 수 있습니다. SQL이 큰 따옴표 &quot;...&quot;안에 포함되어 있으면 TCL은 $ -variables를 대체하므로주의를 기울이지 않으면 SQL 삽입이 발생할 수 있습니다. 그러나 TCL은 큰 따옴표 &quot;...&quot;또는 중괄호 {...}가 SQL을 묶는 데 사용되는지 여부에 관계없이 : -variable을 대체하지 않으므로 : -variables를 사용하면 추가적인 방어 수단이 추가됩니다. SQL 주입.</target>
        </trans-unit>
        <trans-unit id="c10b4d5006af0e657932026cc02e7f4a31cf3940" translate="yes" xml:space="preserve">
          <source>The use of NUL characters in SQL text strings is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">ZIP 파일을 사용하여 XML 파일과 리소스를 캡슐화하는 것은 응용 프로그램 파일 형식에 대한 우아한 접근 방식입니다. 사용자 정의 이진 파일 형식보다 분명히 우수합니다. 그러나 ZIP 대신 SQLite 데이터베이스를 컨테이너로 사용하는 것이 더 우아합니다.</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">SQLite에서 가상 머신을 사용하면 라이브러리 개발에 큰 이점이 있습니다. 가상 머신은 SQLite의 프런트 엔드 (SQL 문을 구문 분석하고 가상 머신 코드를 생성하는 부분)와 백엔드 (가상 머신 코드를 실행하고 결과를 계산하는 부분) 사이에 명확하고 정의 된 정션을 제공합니다. ) 가상 머신을 사용하면 개발자는 SQLite가 컴파일하는 각 명령문으로 수행하려는 작업을 명확하고 쉽게 읽을 수있는 형식으로 볼 수 있습니다. 이는 디버깅에 큰 도움이됩니다. SQLite는 컴파일 방식에 따라 가상 머신의 실행을 추적하는 기능도 가지고 있습니다. 각 가상 머신 명령어와 실행 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">이들 방법 각각의 사용은 상기 도시 된 순서가 아닌 후속편에 설명 될 것이다.</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">지속적 저널 모드를 사용하면 많은 시스템에서 눈에 띄는 성능 향상을 제공합니다. 물론, 트랜잭션이 커밋 된 후에도 저널 파일이 디스크 공간과 복잡한 디렉토리를 사용하여 디스크에 남아 있다는 단점이 있습니다. 지속적 저널 파일을 삭제하는 유일한 안전한 방법은 저널링 모드가 DELETE로 설정된 트랜잭션을 커미트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">포인터 전달의 사용은 드물고 신중하게 사용해야하는 고급 기술입니다. 포인터 전달을 우연히 또는 부주의하게 사용해서는 안됩니다. 포인터 통과는 잘못 사용하면 깊은 상처를 남길 수있는 날카로운 도구입니다.</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">포인터에 하위 유형을 사용하면 순수한 SQL을 사용하는 포인터 위조가 방지되었습니다. 그러나 하위 유형은 공격자가 포인터 값을 읽지 못하도록하기 위해 아무 것도하지 않습니다. 즉, 포인터 값의 하위 유형은 다음과 같은 SQL 문을 사용하는 공격을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">모든 응용 분야에 &lt;a href=&quot;amalgamation&quot;&gt;아말감&lt;/a&gt; 사용을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">SQLite는 현재 UTF-8을 사용하여 모든 구문 분석을 수행하므로 UTF-8 인터페이스를 사용하는 것이 좋습니다. UTF-16 인터페이스는 편의상 제공됩니다. UTF-16 인터페이스는 입력 텍스트를 UTF-8로 변환 한 다음 해당 UTF-8 인터페이스를 호출하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">오류 로거 콜백을 사용하는 것이 좋습니다. 오류 로거가 제공하는 디버깅 정보는 응용 프로그램이 현장에 들어간 후 발생하는 모호한 문제를 추적하는 데 매우 유용한 것으로 입증되었습니다. 오류 로거 콜백은 API 리턴 코드의 일관성 검사로 인해 응용 프로그램에서 누락되는 오류를 포착하는 데 유용하다는 것이 입증되었습니다. 개발자는 예기치 않은 동작을 신속하게 발견하고 배포를 통해 오류 로거 콜백을 켜두려면 개발주기 초기에 오류 로거 콜백을 구현하는 것이 좋습니다. 오류 로거가 문제를 찾지 못하면 아무런 해가 없습니다. 그러나 적절한 오류 로거를 설정하지 않으면 나중에 진단 기능이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">표준화 된 speedtest1.c 워크로드 및 캐시 그라인드를 사용하면 성능이 크게 향상되었습니다. 그러나이 방법의 한계를 인식하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">SQLite에서 가변 길이 레코드를 사용하면 여러 가지 장점이 있습니다. 분명히 작은 데이터베이스 파일이 만들어집니다. 또한 디스크로 이동하는 정보가 적기 때문에 데이터베이스를 더 빠르게 실행할 수 있습니다. 또한 가변 길이 레코드를 사용하면 SQLite에서 정적 입력 대신 매니페스트 입력을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">user_version pragma는 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 헤더의&lt;/a&gt; 오프셋 60에서 사용자 버전 정수 값을 가져 오거나 설정합니다 . 사용자 버전은 응용 프로그램에서 원하는대로 사용할 수있는 정수입니다. SQLite는 사용자 버전 자체를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">usermerge 옵션은 automerge 및 crisismerge 옵션과 유사합니다. 양수 매개 변수와 함께 '병합'명령으로 병합되는 최소 b- 트리 세그먼트 수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">일반적인 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 명령은 일반 테이블과 마찬가지로 R * Tree 인덱스에서 작동합니다. 따라서 샘플 R * Tree 인덱스에 일부 데이터를 삽입하기 위해 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">일반적인 경우 sqlite3_serialize ()는 데이터베이스의 직렬화를 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 복사하고 해당 메모리에 대한 포인터를 반환합니다. 호출자는 메모리 누수를 피하기 위해 반환 된 값을 해제해야합니다. 그러나 F 인수에 SQLITE_SERIALIZE_NOCOPY 비트가 포함되어 있으면 메모리 할당이 이루어지지 않으며 sqlite3_serialize () 함수는 SQLite가 현재 해당 데이터베이스에 사용중인 데이터베이스의 연속 메모리 표시에 대한 포인터를 리턴합니다. 데이터베이스의 이러한 연속적인 메모리 표현이 존재합니다. 데이터베이스의 연속 메모리 표현은 일반적으로 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; 에 대한 사전 호출이있는 경우에만 존재합니다 .SQLITE_SERIALIZE_NOCOPY 비트가 설정되었지만 데이터베이스의 연속 사본이없는 경우에도 데이터베이스의 크기는 * P에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">일반적인 경우 sqlite3_serialize ()는 데이터베이스의 직렬화를 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 복사하고 해당 메모리에 대한 포인터를 반환합니다. 호출자는 메모리 누수를 피하기 위해 반환 된 값을 해제해야합니다. 그러나 F 인수에 SQLITE_SERIALIZE_NOCOPY 비트가 포함되어 있으면 메모리 할당이 이루어지지 않으며 sqlite3_serialize () 함수는 SQLite가 현재 해당 데이터베이스에 사용중인 데이터베이스의 연속 메모리 표시에 대한 포인터를 리턴합니다. 데이터베이스의 이러한 연속적인 메모리 표현이 존재합니다. 데이터베이스의 연속 메모리 표현은 일반적으로 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; 에 대한 사전 호출이있는 경우에만 존재합니다 .SQLITE_SERIALIZE_NOCOPY 비트가 설정되었지만 데이터베이스의 연속 사본이없는 경우에도 데이터베이스의 크기는 * P에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="translated">일반적인 경우는 전체 데이터베이스 파일을 확인하는 것입니다. 그러나 인수가</target>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">일반적인 출력은 database1.sqlite ( &quot;소스&quot;데이터베이스)를 database2.sqlite ( &quot;대상&quot;데이터베이스)로 변환하는 SQL 스크립트입니다. 이 동작은 명령 행 스위치를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">sqlite3_changegroup 객체의 일반적인 사용 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">데이터베이스 테이블에 날짜를 저장하는 일반적인 방법은 단일 필드, 유닉스 타임 스탬프, julian day number 또는 ISO-8601 날짜 문자열입니다. 그러나 일부 응용 프로그램 저장소는 연도, 월 및 일에 대해 세 개의 별도 필드로 날짜가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">가치</target>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">추출 된 값은 레지스터 P3에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">NEW.rowid의 값은 rowid가 명시 적으로 정수로 설정되지 않은 BEFORE INSERT 트리거에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_THREADSAFE의 값은 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열의 값은 항상 NULL이 아닌 정수 여야합니다. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 의 PRIMARY KEY 열도 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">이러한 인터페이스에 대한 N 매개 변수의 값은 음수가 아니어야합니다. 향후 개선 사항은 새로운 종류의 함수 캐싱 동작을 정의하기 위해 음수 N 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">변경 카운터의 값은 데이터베이스 핸들 변경 카운터에 복사됩니다 (sqlite3_changes ()에 대한 후속 호출로 리턴 됨). 그런 다음 VM 내부 변경 카운터가 0으로 재설정됩니다. 이는 트리거 프로그램에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step () 완료 여부에 관계없이 sqlite3_backup_step () 오류가 발생하지 않으면 sqlite3_backup_finish에 의해 리턴되는 값은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 입니다. 동일한 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 에서 이전 sqlite3_backup_step () 호출 중에 메모리 부족 조건 또는 IO 오류가 발생 하면 sqlite3_backup_finish ()는 해당 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step () 완료 여부에 관계없이 sqlite3_backup_step () 오류가 발생하지 않으면 sqlite3_backup_finish에 의해 리턴되는 값은 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 입니다. 동일한 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 에서 이전 sqlite3_backup_step () 호출 중에 메모리 부족 조건 또는 IO 오류가 발생 하면 sqlite3_backup_finish ()는 해당 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">값 &lt;b&gt;M&lt;/b&gt; 과 &lt;b&gt;n&lt;/b&gt; 은 응용 프로그램의 속성입니다. 애플리케이션이 이러한 방식으로 구성되는 경우에 모두 있다는 &lt;b&gt;M&lt;/b&gt; 및 &lt;b&gt;N은&lt;/b&gt; 공지되어 있거나, 적어도 상부 경계를 알고 있고, 응용 프로그램이 사용하는 경우 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5의&lt;/a&gt; 메모리 할당과 함께 제공되는 &lt;b&gt;N&lt;/b&gt; 사용 가능한 메모리 공간 바이트 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP를&lt;/a&gt; 다음 롭슨 증명 응용 프로그램 내에서 메모리 할당 요청이 실패하지 않습니다. 다른 방법으로, 응용 프로그램 개발자는 &lt;b&gt;N에&lt;/b&gt; 대한 값을 선택하여 SQLite 인터페이스를 호출 &lt;a href=&quot;rescode#nomem&quot;&gt;해도 SQLITE_NOMEM을&lt;/a&gt; 반환하지 않습니다.. 메모리 풀은 조각화되지 않으므로 새 메모리 할당 요청을 충족 할 수 없습니다. 이는 소프트웨어 결함으로 인해 부상, 물리적 손상 또는 대체 할 수없는 데이터 손실이 발생할 수있는 응용 프로그램의 중요한 속성입니다.</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">레코드의 각 열 값은 헤더 바로 다음에옵니다. 직렬 유형 0, 8, 9, 12 및 13의 경우 값의 길이는 0 바이트입니다. 모든 열이 이러한 유형 인 경우 레코드의 본문 섹션이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">행의 각 열에 대한 값이이 열에 저장됩니다. &quot;.recover&quot;명령은 가장 긴 분리 된 행에 필요한만큼의 열이있는 lost_and_found 테이블을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="translated">대략적인 ANALYZE에 의해 sqlite_stat1 테이블에 배치 된 값은 무제한 분석으로 계산되는 값과 정확히 동일하지 않습니다. 그러나 그들은 일반적으로 충분히 가깝습니다. sqlite_stat1 테이블의 인덱스 통계는 어떤 경우에도 근사치이므로 근사 ANALYZE의 결과가 기존 전체 스캔 ANALYZE와 약간 다르다는 사실은 실질적인 영향이 거의 없습니다. 대략적인 ANALYZE가 full-scan ANALYZE보다 눈에 띄게 열등한 병리학 적 사례를 구성 할 수 있지만 실제 문제에서는 이러한 사례가 드뭅니다.</target>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴 된 값 은 문자열 끝에 0 종결 자를 포함하지 않습니다. 명확성을 위해 : &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴되는 값 은 문자 수가 아닌 문자열의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴 된 값 은 문자열 끝에 0 종결 자를 포함하지 않습니다. 명확성을 위해 : &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴되는 값 은 문자 수가 아닌 문자열의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">sqlite3_errcode () 및 / 또는 sqlite3_extended_errcode ()에 의해 리턴 된 값은 각 API 호출에 따라 변경 될 수 있습니다. 단, 오류 코드의 값을 절대로 변경하지 않는 인터페이스가 있습니다. 오류 코드 보존 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">변수 &lt;b&gt;$ x&lt;/b&gt; 는 위의 코드에서</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">이전 식에서 변수 i는 0과 9 사이에서 변합니다. 개념적으로 인덱스 공간은 10 개의 균일 한 버킷으로 나뉘며 샘플은 각 버킷의 가운데 행입니다.</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">다양한 &lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">다양한 SQLite Archive Archive 명령은 SQL 문을 사용하여 구현됩니다. 응용 프로그램 개발자는 적절한 SQL을 실행하여 자신의 프로젝트에 SQLite Archive Archive 읽기 및 쓰기 지원을 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">다양한 assert ()와 유사한 매크로는 SQLite의 빌드 방식에 따라 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">다양한 유닉스 VFS는 파일 잠금을 처리하는 방식에서만 차이가 있습니다. 대부분의 구현을 서로 공통으로 공유하며 모두 동일한 SQLite 소스 파일 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c에&lt;/a&gt; 있습니다. &quot;unix&quot;및 &quot;unix-excl&quot;을 제외하고 다양한 유닉스 VFS는 모두 호환되지 않는 잠금 구현을 사용합니다. 두 프로세스가 서로 다른 유닉스 VFS를 사용하여 동일한 SQLite 데이터베이스에 액세스하는 경우 서로의 잠금을 보지 못하고 서로 방해하여 데이터베이스가 손상 될 수 있습니다. &quot;unix-none&quot;VFS는 특히 전혀 잠금을 수행하지 않으며 동시에 둘 이상의 데이터베이스 연결에서 사용하는 경우 데이터베이스가 손상 될 수 있습니다. 프로그래머는 &quot;unix&quot;또는 &quot;unix-excl&quot;만 사용하는 것이 좋습니다.달리해야 할 강력한 이유가없는 한.</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">Apple Mac OS X 컴퓨터에 사전 설치된 SQLite 버전에는 Apple이 지원하는 모든 네트워크 파일 시스템에서 작동하는 대체 잠금 전략을 사용하도록 확장 된 SQLite 버전이 포함되어 있습니다. Apple에서 사용하는 이러한 확장은 모든 프로세스가 동일한 방식으로 데이터베이스 파일에 액세스하는 한 효과적입니다. 불행히도 잠금 메커니즘은 서로를 배제하지 않으므로 한 프로세스가 (예를 들어) AFP 잠금을 사용하여 파일에 액세스하고 다른 프로세스 (아마 다른 시스템에 있음)가 도트 파일 잠금을 사용하는 경우 AFP 때문에 두 프로세스가 충돌 할 수 있습니다 잠금은 도트 파일 잠금을 제외하지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에 제공되는 SQLite 통합의 버전 은 일반적으로 대부분의 사용자에게 적합합니다. 그러나 일부 프로젝트는 자체 융합을 원하거나 필요로 할 수 있습니다. 사용자 지정 합병을 만드는 일반적인 이유는 특정 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션&lt;/a&gt; 을 사용하기위한 것입니다.SQLite 라이브러리를 사용자 정의합니다. SQLite 통합에는 보조 프로그램 및 스크립트에 의해 생성되는 많은 C 코드가 포함되어 있습니다. 많은 컴파일 타임 옵션이이 생성 된 코드에 영향을 미치며 통합하기 전에 코드 생성기에 제공되어야합니다. 코드 생성기로 전달되어야하는 컴파일 타임 옵션 세트는 SQLite 릴리스마다 다를 수 있지만이 시점 (SQLite 3.6.20, 2009-11-04 경)에는 옵션 세트가 있습니다. 코드 생성기에서 알아야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">&quot;Structured Query Language&quot;라는 이름은 SQL이 중첩 쿼리를 지원해야 함을 나타냅니다. 실제로 두 가지 종류의 중첩이 지원됩니다. 단일 행, 단일 열 결과를 리턴하는 SELECT 문은 다른 SELECT 문의 표현식에서 용어로 사용될 수 있습니다. 또한 단일 열, 다중 행 결과를 반환하는 SELECT 문을 IN 및 NOT IN 연산자의 오른쪽 피연산자로 사용할 수 있습니다. 첫 번째 종류의 중첩 예제로이 섹션을 시작하겠습니다. 여기서 단일 행, 단일 열 SELECT가 다른 SELECT의 표현식에서 용어로 사용됩니다. 우리의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">VFS에 쿼리 매개 변수를 사용하여 열 수 데이터베이스 연결을 일으키는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 전화를</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">제거 할 뷰는 DROP VIEW 문의 일부로 지정된 view-name 및 선택적 schema-name으로 식별됩니다. 이 참조는 &lt;a href=&quot;lang_naming&quot;&gt;객체 해상도에&lt;/a&gt; 대한 표준 절차를 사용하여 해결 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">뷰 V1을 할 수없는 &lt;a href=&quot;optoverview#flattening&quot;&gt;평평&lt;/a&gt; 가 DISTINCT 때문이다. 대신 결과가 임시 테이블에 저장된 서브 쿼리로 실행되어야하며 조인은 t2와 임시 테이블 사이에서 수행됩니다. 푸시 다운 최적화는 &quot;b와 10 사이의 b&quot;용어를보기로 푸시 다운합니다. 이는 임시 테이블을 더 작게 만들고 t1.b에 인덱스가있는 경우 서브 쿼리를 더 빨리 실행하는 데 도움이됩니다. 결과 평가는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">가상 머신 자체는 단일 소스 파일 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; 에 완전히 포함되어 있습니다. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h의&lt;/a&gt; 헤더 파일은 가상 머신과 SQLite는 라이브러리의 나머지 사이의 인터페이스를 정의 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; 가상 머신 자체 비공개 구조와 인터페이스를 정의한다. 다른 여러 &lt;b&gt;vdbe * .c&lt;/b&gt; 파일은 가상 머신의 도우미입니다. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c의&lt;/a&gt; 파일은 VM 프로그램을 구성하는 라이브러리의 나머지 부분에서 사용되는 가상 머신 및 인터페이스 모듈에 의해 사용되는 유틸리티가 포함되어 있습니다. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c의&lt;/a&gt; 파일 등과 같은 가상 머신의 외부 인터페이스를 포함 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()를&lt;/a&gt;. 개별 값 (문자열, 정수, 부동 소수점 숫자 및 BLOB)은 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c에&lt;/a&gt; 의해 구현되는 &quot;Mem&quot;이라는 내부 객체에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">가상 테이블에는 xShadowName 메서드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">가상 테이블 메커니즘을 통해 애플리케이션은 SQL 문에서 액세스 할 수있는 인터페이스를 테이블 인 것처럼 공개 할 수 있습니다. SQL 문은 다음을 제외하고 실제 테이블에 대해 수행 할 수있는 거의 모든 작업을 가상 테이블에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">가상 테이블은 입력 문자열의 각 토큰에 대해 하나의 출력 행을 반환합니다. &quot;토큰&quot;열은 토큰의 텍스트입니다. &quot;start&quot;및 &quot;end&quot;열은 원래 입력 문자열에서 토큰의 시작과 끝에 대한 바이트 오프셋입니다. &quot;위치&quot;열은 원래 입력 문자열에서 토큰의 시퀀스 번호입니다. WHERE 절에 지정된 입력 문자열의 복사 본인 &quot;입력&quot;열도 있습니다. &quot;input =?&quot;형식의 제한 조건에 유의하십시오. WHERE 절에 나타나야합니다. 그렇지 않으면 가상 테이블에 토큰화할 입력이없고 행을 반환하지 않습니다. 위의 예제는 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">wal-index 파일 또는 &quot;shm&quot;파일은 실제로 파일로 사용되지 않습니다. 오히려 개별 데이터베이스 클라이언트는 shm 파일을 mmap하여 데이터베이스에 대한 액세스를 조정하기위한 공유 메모리 및 wal 파일 내에서 프레임을 빠르게 찾을 수있는 캐시로 사용합니다. shm 파일의 이름은 4 개의 문자 &quot;-shm&quot;이 추가 된 기본 데이터베이스 파일 이름입니다. 또는 8 + 3 파일 시스템의 경우 shm 파일은 접미사가 &quot;.SHM&quot;으로 변경된 주 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">일반적으로 &quot;X-shm&quot;이라는 wal-index 파일입니다.</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">월 인덱스는 일시적입니다. 충돌 후 wal-index는 원래 WAL 파일에서 재구성됩니다. VFS는 마지막 연결이 닫힐 때 wal-index의 헤더를 자르거나 0으로 만들어야합니다. 월 인덱스는 일시적이므로 아키텍처 별 형식을 사용할 수 있습니다. 크로스 플랫폼 일 필요는 없습니다. 따라서 모든 값을 big endian으로 저장하는 데이터베이스 및 WAL 파일 형식과 달리 wal-index는 멀티 바이트 값을 호스트 컴퓨터의 기본 바이트 순서로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">wal_checkpoint pragma는 3 개의 정수 열이있는 단일 행을 반환합니다. 첫 번째 열은 일반적으로 0이지만 다른 스레드 또는 프로세스가 데이터베이스를 적극적으로 사용하고 있기 때문에 RESTART, FULL 또는 TRUNCATE 검사 점이 완료되지 않도록 차단 된 경우 1입니다. 즉, &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()에&lt;/a&gt; 대한 동등한 호출이 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 한 경우 첫 번째 열은 0이고 동등한 호출이 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 한 경우 1 인 첫 번째 열은 0입니다. 두 번째 열은 미리 쓰기 로그 파일에 기록 된 수정 된 페이지 수입니다. 세 번째 열은 체크 포인트가 끝날 때 미리 쓰기 로그 파일에서 데이터베이스 파일로 다시 이동 된 페이지 수입니다. 두 번째 및 세 번째 열은 미리 쓰기 로그가없는 경우 (예 : &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 가 아닌 데이터베이스 연결에서이 pragma가 호출 된 경우) -1 입니다.</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">SQLite가 이것을 다루는 방법은 먼저 내부 SELECT (testp2에 대한 것)를 실행하고 그 결과를 개인 메모리 셀에 저장하는 것입니다. 그런 다음 SQLite는 외부 SELECT를 평가할 때이 개인용 메모리 셀의 값을 내부 SELECT로 대체합니다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">IN 및 NOT IN 연산자가 오른쪽 표현식에서 NULL 값을 처리하는 방식은 SQL 표준 및 기타 SQL 데이터베이스 엔진을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">xShadowName 메서드의 요점은 섀도우 테이블의 내용이 악의적 인 SQL에 의해 손상되지 않도록 보호하는 것입니다. 새도우 테이블을 사용하는 모든 가상 테이블 구현은 손상된 새도우 테이블 컨텐츠를 감지하고 대처할 수 있어야합니다. 그러나 특정 가상 테이블 구현의 버그로 인해 의도적으로 손상된 새도우 테이블로 인해 충돌 또는 기타 오작동이 발생할 수 있습니다. xShadowName 메커니즘은 일반 SQL 문이 의도적으로 새도우 테이블을 손상시키지 못하게함으로써 제로 데이 악용을 피하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">너비 필드는 출력에서 ​​대체 된 값의 최소 너비를 지정합니다. 출력에 쓰여지는 문자열 또는 숫자가 너비보다 짧으면 값이 채워집니다. 패딩은 기본적으로 왼쪽에 있습니다 (값은 오른쪽 정렬 됨). &quot;-&quot;플래그가 사용되면 패딩이 오른쪽에 있고 값이 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">너비는 기본적으로 바이트 단위로 측정됩니다. 그러나 &quot;!&quot; 플래그가 있으면 너비는 문자입니다. 이는 멀티 바이트 utf-8 문자에만 차이가 있으며 문자열 대체에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">이 단어는 소문자 ASCII로 음역되었습니다. 비 ASCII 문자에서 ASCII 로의 표준 맵핑 테이블이 있습니다. 예 : &quot;&amp;aelig;&quot;-&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot;-&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot;-&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot;-&amp;gt; &quot;a&quot;, ... 보조 기능 spellfix1_translit (X)는 비 ASCII에서 ASCII 로의 맵핑 내장 된 lower (X) 함수는 소문자로 변환됩니다. 따라서 : k1 = lower (spellfix1_translit (word)). 단어가 이미 모두 소문자 ASCII이면 k1 열에 NULL이 포함됩니다. 이로 인해 % _vocab 테이블의 스토리지 요구 사항이 줄어들고 철자가 약간 더 빨리 실행되도록 도와줍니다. 따라서 소문자 ASCII 어휘를 사용하여 가능한 많은 철자 테이블을 채우는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">작업 디렉토리</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">미리 쓰기 로그 파일 (일반적으로 &quot;X-wal&quot;)</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">미리 쓰기 로그 또는 &quot;wal&quot;파일은 커밋되었지만 아직 주 데이터베이스에 적용되지 않은 트랜잭션을 기록하는 롤 포워드 저널입니다. wal 파일의 형식에 대한 자세한 내용 은 기본 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 문서 의 &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL 형식&lt;/a&gt; 하위 섹션에 설명되어 있습니다. wal 파일은 기본 데이터베이스 파일 이름 끝에 네 개의 문자 &quot;-wal&quot;을 추가하여 이름이 지정됩니다. 8 + 3 파일 시스템을 제외하고 이러한 이름은 허용되지 않으며이 경우 파일 접미사가 &quot;.WAL&quot;로 변경됩니다. 그러나 8 + 3 파일 시스템이 점점 더 드물기 때문에 예외적 인 경우는 대개 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">writefile (X, Y) SQL 함수는 Blob Y를 X라는 파일에 기록하고 기록 된 바이트 수를 리턴합니다. 단일 테이블 열의 내용을 파일로 추출하려면이 기능을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;transactional&quot;&gt;전원 안전 트랜잭션을 수행&lt;/a&gt; 하는 반면 디스크 직접 쓰기는 수행하지 않기 때문에 위의 쓰기 테스트는 완전히 공평 하지 않습니다. 테스트를보다 평등 한 위치에 두려면 --nosync 옵션을 SQLite 쓰기에 추가하여 fsync () 또는 FlushFileBuffers () 호출을 비활성화하여 내용을 디스크에 강제로 적용하거나 --fsync 옵션을 사용하여 direct-to-- 디스크 테스트시 디스크 파일을 업데이트 할 때 fsync () 또는 FlushFileBuffers ()를 강제로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">xAccess 메서드는 파일에 대한 액세스 권한을 확인하는 데 사용됩니다. 파일 이름은 UTF-8로 인코딩됩니다. 플래그 인수가 될 것입니다 &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS이&lt;/a&gt; 파일의 존재를 확인하기 위해, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE는&lt;/a&gt; 파일을 읽고 쓸 수, 또는 두 가지 모두 있는지 확인합니다 &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; 파일이 적어도 읽을 수 있는지 확인합니다. 두 번째 매개 변수로 명명 된 &quot;파일&quot;은 디렉토리 또는 폴더 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">저널 파일이 여전히 파일 시스템에 있는지 여부를 감지하기 위해 xAccess () 메소드가 다시 호출됩니다. 그렇다면 핫 저널 파일이고 SQLite는 롤백을 시도합니다 (섹션 참조).</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">VFS의 xAccess () 메소드는 메모리 할당 오류를 알리기 위해 -1을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">xBestIndex 함수가 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 aConstraintUsage []. argvIndex 값을 사용하여 특정 표현식의 값을 요청했을 수 있습니다 . 이러한 값은 argc 및 argv 매개 변수를 사용하여 xFilter로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">xBestIndex 메소드는 색인 전략을 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 와 통신하는 정보로 idxNum 및 idxStr 필드를 채 웁니다 . idxNum 및 idxStr의 정보는 SQLite 코어에 관한 한 임의적입니다. SQLite 코어는 정보를 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 로 복사합니다 . xBestIndex 및 xFilter가 해당 의미에 동의하는 한 원하는 의미를 idxNum 및 idxStr에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">xBestIndex 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">xBestIndex 메소드는 선택적으로 idxFlags 필드를 SQLITE_INDEX_SCAN_ * 플래그의 마스크로 채울 수 있습니다. 현재 SQLITE_INDEX_SCAN_UNIQUE 플래그는 하나뿐입니다. xBestIndex 메소드가이 플래그를 설정하면 SQLite는 전략이 최대 하나의 행을 방문 할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">xBestIndex 메소드는 aConstraintUsage []. argvIndex 항목을 0보다 큰 값으로 설정할 수 있습니다. 정확히 하나의 항목은 1, 다른 항목은 2, 다른 항목은 3 등으로 설정해야하며 xBestIndex 메소드가 원하는만큼 또는 그 이하로 설정해야합니다. 해당 제한 조건의 EXPR은 argv [] 매개 변수로 xFilter에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">xBestIndex 메소드는 성공시 SQLITE_OK를 리턴해야합니다. 치명적인 오류가 발생하면 적절한 오류 코드 (예 : &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; )가 대신 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">xBestIndex 메소드는 위의 각 잠재적 계획마다 한 번씩 호출됩니다. 계획 1의 경우 &quot;param1 =?&quot;의 오른쪽 값 때문에 param1 열의 SQLITE_CONSTRAINT_EQ 제약 조건에 대한 aConstraint []. usable 플래그가 true가됩니다. 제약 조건은 외부 realtab 루프에 의해 결정되므로 알 수 있습니다. 그러나 계획 2의 경우 &quot;param1 =?&quot;에 대한 aConstraint []. usable 플래그 오른쪽 값은 내부 루프에 의해 결정되므로 알 수없는 수량이기 때문에 false입니다. param1은 테이블 반환 함수에 대한 필수 입력이므로 계획 2가 표시되면 xBestIndex 메서드가 SQLITE_CONSTRAINT를 반환하여 필수 입력이 누락되었음을 나타냅니다. 쿼리 플래너가 계획 1을 선택하도록합니다.</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">xCachesize () 메소드는 언제든지 SQLite에 의해 호출되어 제안 된 최대 캐시 크기 (저장된 페이지 수)를 첫 번째 인수로 전달 된 캐시 인스턴스로 설정할 수 있습니다. 이것은 SQLite &quot; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;명령을 사용하여 구성된 값 입니다. bPurgeable 매개 변수와 마찬가지로 구현시이 값으로 작업을 수행 할 필요는 없습니다. 단지 자문 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">xCachesize () 메소드는 언제든지 SQLite에 의해 호출되어 제안 된 최대 캐시 크기 (저장된 페이지 수)를 첫 번째 인수로 전달 된 캐시 인스턴스로 설정할 수 있습니다. 이것은 SQLite &quot; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;명령을 사용하여 구성된 값 입니다. bPurgeable 매개 변수와 마찬가지로 구현시이 값으로 작업을 수행 할 필요는 없습니다. 단지 자문 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">xCheckReservedLock () 메소드는 다른 연결 또는 다른 프로세스가 현재 파일에 대해 예약, 보류 또는 독점 잠금을 보유하고 있는지 확인합니다. true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">xClose 방법은 이전에 열 커서 닫 &lt;a href=&quot;vtab#xopen&quot;&gt;XOPEN을&lt;/a&gt; . SQLite 코어는 xOpen을 사용하여 열린 각 커서에 대해 항상 xClose를 한 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">xClose 메소드는 파일을 닫습니다. &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 구조를 위한 공간 은 호출자가 할당 해제합니다. 그러나 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 에 다른 할당 된 메모리 나 자원에 대한 포인터가 포함되어 있으면 xClose 메소드로 해당 할당을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">xClose 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">xColumn 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">xColumnSize API는 항상 -1을 반환합니다. columnsize = 0으로 구성된 contentless FTS5 테이블에 저장된 값의 토큰 수를 결정하는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 xConnect 포인터 이지만 xConnect 메소드는 모든 가상 테이블 구현에 필요합니다.가상 테이블이 백업 저장소를 초기화 할 필요가없는 경우 객체 동일한 기능을 가리킬 수 .</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">xConnect 방법은 매우 유사하다 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; . 동일한 매개 변수를 가지며 xCreate와 마찬가지로 새로운 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조를 구성합니다 . 또한 xCreate와 같이 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()을&lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">xConnect 방법은 반환해야합니다 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 이 새로운 가상 테이블 또는 생성에 성공하면 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 가 성공하지 못한 경우. 성공하지 못하면 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조를 할당 하면 안됩니다 . 실패하면 * pzErr에 오류 메시지가 선택적으로 리턴 될 수 있습니다. SQLite 코어가 오류가 애플리케이션에보고 된 후 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 사용하여 공간을 확보하려고 시도하므로 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 와 같은 SQLite 메모리 할당 함수를 사용하여 오류 메시지 문자열을 보유 할 공간을 할당해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">xCreate 및 xConnect 메소드는 가상 테이블에 가상 테이블이 처음 생성 될 때 초기화되어야하는 일종의 백업 저장소가있는 경우에만 다릅니다. xCreate 메소드는 백업 저장소를 작성하고 초기화합니다. xConnect 메소드는 기존 백업 저장소에 연결합니다. xCreate와 xConnect가 동일한 경우 테이블은 &lt;a href=&quot;vtab#epovtab&quot;&gt;가상 가상 테이블&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문 에 대한 응답으로 가상 테이블의 새 인스턴스를 작성하기 위해 xCreate 메소드가 호출됩니다 . xCreate 방법은 같은 포인터 경우 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect에&lt;/a&gt; 있어서, 다음 가상 테이블은 인 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; . xCreate 메소드가 생략 된 경우 (NULL 포인터 인 경우) 가상 테이블은 시상 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">xCreate 메소드는 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 오브젝트 의 pModule, nRef 및 zErrMsg 필드를 초기화하지 않아도 됩니다. SQLite 코어가 그 일을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">xCreate은 반환해야 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 이 새로운 가상 테이블 또는 생성에 성공하면 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 가 성공하지 못한 경우. 성공하지 못하면 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조를 할당 하면 안됩니다 . 실패하면 * pzErr에 오류 메시지가 선택적으로 리턴 될 수 있습니다. SQLite 코어가 오류가 애플리케이션에보고 된 후 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 사용하여 공간을 확보하려고 시도하므로 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 와 같은 SQLite 메모리 할당 함수를 사용하여 오류 메시지 문자열을 보유 할 공간을 할당해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">xCurrentTime 메소드는 현재 시간과 날짜를 찾고 결과를 배정 밀도 부동 소수점 값으로 두 번째 매개 변수가 제공하는 포인터에 씁니다. 시간과 날짜는 협정 세계시 (UTC)이며 소수 줄리안 일수입니다.</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">지정된 경우 xDelete 콜백도 FTS5 쿼리가 완료된 후 보조 데이터 포인터에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">내장의 xDelete 방법 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; 파일이 삭제 될 경우 지금 돌아 SQLITE_IOERR_DELETE_NOENT가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">xDelete 메소드는 파일을 삭제하는 데 사용됩니다. 파일 이름은 두 번째 매개 변수에 제공됩니다. 파일 이름은 UTF-8입니다. VFS는 파일 이름을 기본 운영 체제가 기대하는 문자 표현으로 변환해야합니다. syncDir 매개 변수가 true 인 경우 정전이 발생한 경우 파일이 &quot;다시 나타나지&quot;않도록하기 위해 삭제 된 파일을 포함하는 디렉토리의 디렉토리 내용 변경이 디스크에 동기화 될 때까지 xDelete 메소드가 리턴되지 않아야합니다. 곧바로.</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">sqlite3_create_collation_v2 () 함수가 실패하면 xDestroy 콜백이 호출 &lt;u&gt;되지 않습니다&lt;/u&gt; . NULL이 아닌 xDestroy 인수로 sqlite3_create_collation_v2 ()를 호출하는 응용 프로그램은 리턴 코드를 점검하고 SQLite가 처리 할 것으로 예상하지 않고 응용 프로그램 데이터 포인터 자체를 처리해야합니다. 이것은 다른 모든 SQLite 인터페이스와 다릅니다. 불일치는 유감 스럽지만 이전 버전과의 호환성을 유지하지 않으면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">xDisstroy 메소드는 모든 가상 테이블 구현에 필요하지만 &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; 및 xDestroy 메소드가 특정 가상 테이블에 적합한 경우 동일한 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy () 메소드는 xCreate ()에 의해 할당 된 캐시를 삭제하는 데 사용됩니다. 지정된 캐시와 연관된 모든 자원을 해제해야합니다. xitestroy () 메소드를 호출 한 후 SQLite는 &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; 핸들이 유효하지 않은 것으로 간주하고 다른 sqlite3_pcache_methods2 함수와 함께 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy () 메소드는 xCreate ()에 의해 할당 된 캐시를 삭제하는 데 사용됩니다. 지정된 캐시와 연관된 모든 자원을 해제해야합니다. xitestroy () 메소드를 호출 한 후 SQLite는 &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; 핸들이 유효하지 않은 것으로 간주하고 다른 sqlite3_pcache_methods2 함수와 함께 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xDeviceCharacteristics 메소드 는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 참조 하는 파일을 보유하는 대용량 저장 장치의 I / O 특성을 나타내는 이러한 비트 값의 벡터 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xDeviceCharacteristics 메소드 는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 참조 하는 파일을 보유하는 대용량 저장 장치의 I / O 특성을 나타내는 이러한 비트 값의 벡터 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">xDeviceCharacteristics 메소드는 기본 저장 매체가 SQLite가 성능 향상을 위해 사용할 수있는 특수 특성을 정의하는 정수 비트 벡터를 리턴합니다. 허용되는 반환 값은 다음 값의 비트 단위 OR입니다.</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">xDisconnect 메소드는 모든 가상 테이블 구현에 필요하지만 xDisconnect 및 &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; 메소드가 특정 가상 테이블에 적합한 경우 동일한 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">xDlOpen, xDlError, xDlSym 및 xDlClose 메소드는 모두 런타임시 공유 라이브러리에 액세스하는 데 사용됩니다. 라이브러리가 &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; 으로 컴파일 되거나 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension () 인&lt;/a&gt; 경우 이러한 메소드를 생략하고 포인터를 0으로 설정할 수 있습니다.인터페이스는 동적 확장 로딩을 활성화하는 데 사용되지 않습니다. xDlOpen 메소드는 공유 라이브러리 또는 DLL을 열고 핸들에 대한 포인터를 리턴합니다. 열기에 실패하면 NULL이 반환됩니다. 열기에 실패하면 xDlError 메소드를 사용하여 텍스트 오류 메시지를 얻을 수 있습니다. 메시지는 적어도 nByte 바이트 길이 인 세 번째 매개 변수의 zErrMsg 버퍼에 기록됩니다. xDlSym은 공유 라이브러리의 심볼에 대한 포인터를 반환합니다. 심볼의 이름은 두 번째 매개 변수로 제공됩니다. UTF-8 인코딩이 가정됩니다. 기호가 없으면 NULL 포인터가 반환됩니다. xDlClose 루틴은 공유 라이브러리를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">xEof 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">지정된 커서가 현재 유효한 데이터 행을 가리키는 경우 xEof 메소드는 false (0)를 리턴하고 그렇지 않으면 true (0이 아닌)를 리턴해야합니다. 이 메소드는 각 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 및 &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; 호출 직후 SQL 엔진에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">xFetch () 메소드는 캐시에서 페이지를 찾아 해당 페이지와 연관된 sqlite3_pcache_page 오브젝트에 대한 포인터 또는 NULL 포인터를 리턴합니다. 리턴 된 sqlite3_pcache_page 오브젝트의 pBuf 요소는 단일 데이터베이스 페이지의 컨텐츠를 저장하는 데 사용되는 szPage 바이트 버퍼에 대한 포인터입니다. sqlite3_pcache_page의 pExtra 요소는 SQLite가 페이지 캐시의 각 항목에 대해 요청한 추가 스토리지의 szExtra 바이트에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">xFileControl () 메소드는 커스텀 VFS 구현이 (신규 및 실험적) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 열린 파일을 직접 제어 할 수있는 일반 인터페이스입니다 . 두 번째 &quot;op&quot;인수는 정수 opcode입니다. 세 번째 인수는 반환 값을 쓸 인수 또는 공백을 포함 할 수있는 구조에 대한 포인터를 가리키는 일반 포인터입니다. xFileControl ()의 잠재적 사용은 시간 초과로 잠금을 차단하고 잠금 전략을 변경하거나 (예 : 도트 파일 잠금을 사용하여) 잠금 상태를 문의하거나 오래된 잠금을 해제하는 기능 일 수 있습니다. SQLite 코어는 자체 사용을 위해 opcode를 100 미만으로 예약합니다. ㅏ&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt; 옵 코드의 목록&lt;/a&gt;100 개 미만이 사용 가능합니다. 사용자 정의 xFileControl 메소드를 정의하는 응용 프로그램은 충돌을 피하기 위해 100보다 큰 opcode를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl () 메소드는 사용자 정의 VFS 구현이 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 열린 파일을 직접 제어 할 수있는 일반 인터페이스입니다 . 두 번째 &quot;op&quot;인수는 정수 opcode입니다. 세 번째 인수는 반환 값을 쓸 인수 또는 공백을 포함 할 수있는 구조를 가리키는 일반 포인터입니다. xFileControl ()의 잠재적 사용은 시간 초과로 잠금을 차단하고 잠금 전략을 변경하거나 (예 : 도트 파일 잠금을 사용하여) 잠금 상태를 문의하거나 오래된 잠금을 해제하는 기능 일 수 있습니다. SQLite 코어는 자체 사용을 위해 모든 opcode를 100 미만으로 예약합니다. &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;옵 코드의 목록&lt;/a&gt;100 개 미만이 사용 가능합니다. 사용자 정의 xFileControl 메소드를 정의하는 응용 프로그램은 충돌을 피하기 위해 100보다 큰 opcode를 사용해야합니다. VFS 구현은 인식하지 못하는 파일 제어 opcode에 대해 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl () 메소드는 사용자 정의 VFS 구현이 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 열린 파일을 직접 제어 할 수있는 일반 인터페이스입니다 . 두 번째 &quot;op&quot;인수는 정수 opcode입니다. 세 번째 인수는 반환 값을 쓸 인수 또는 공백을 포함 할 수있는 구조를 가리키는 일반 포인터입니다. xFileControl ()의 잠재적 사용은 시간 초과로 잠금을 차단하고 잠금 전략을 변경하거나 (예 : 도트 파일 잠금을 사용하여) 잠금 상태를 문의하거나 오래된 잠금을 해제하는 기능 일 수 있습니다. SQLite 코어는 자체 사용을 위해 모든 opcode를 100 미만으로 예약합니다. ㅏ&lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;옵 코드의 목록&lt;/a&gt;100 개 미만이 사용 가능합니다. 사용자 정의 xFileControl 메소드를 정의하는 응용 프로그램은 충돌을 피하기 위해 100보다 큰 opcode를 사용해야합니다. VFS 구현은 인식하지 못하는 파일 제어 opcode에 대해 &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">xFileSize () 메소드는 파일의 현재 크기를 바이트 단위로 판별하여 해당 값을 * pSize에 씁니다. 성공 하면 &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_OK를&lt;/a&gt; , 무언가 잘못되면 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">모든 가상 테이블 구현에 xFilter 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">xFullPathname 메소드는 상대 경로 이름을 전체 경로 이름으로 변환하는 데 사용됩니다. 결과 전체 경로 이름은 세 번째 매개 변수에서 제공 한 버퍼에 기록됩니다. SQLite는 출력 버퍼의 크기를 mxPathname 바이트 이상으로 조정합니다. 입력 및 출력 이름은 모두 UTF-8이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">xGeom 콜백은 항상 r- 트리의 깊이 우선 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">xGetTempName 메소드는 SQLite가 사용할 수있는 임시 파일의 이름을 계산합니다. 이름은 두 번째 매개 변수가 제공 한 버퍼에 작성해야합니다. SQLite는 mxPathname 바이트 이상을 보유하도록 해당 버퍼의 크기를 조정합니다. 생성 된 파일 이름은 UTF-8이어야합니다. 보안 문제를 피하려면 생성 된 임시 파일 이름에 공격자가 임시 파일 이름을 미리 추측하지 못하도록 충분한 임의성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">xGetTempname 메소드가 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 에서 제거되었습니다 . 대신, filename 매개 변수가 NULL 인 경우 xOpen 메소드가 자체 발명의 임시 파일을 열도록 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메소드는 메모리 할당자를 초기화합니다. 예를 들어, 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에 의해 획득 된 모든 자원을 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메소드는 메모리 할당자를 초기화합니다. 예를 들어, 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메소드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에 의해 획득 된 모든 자원을 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메서드는 메모리 할당자를 초기화합니다. 예를 들어 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메서드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에서 획득 한 모든 리소스를 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메서드는 메모리 할당자를 초기화합니다. 예를 들어 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메서드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에서 획득 한 모든 리소스를 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit () 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출에 대해 한 번만 호출됩니다 (일반적으로 프로세스 수명 동안 한 번만). xInit () 메소드에는 sqlite3_pcache_methods2.pArg 값의 사본이 전달됩니다. xInit () 메소드의 목적은 사용자 정의 페이지 캐시 구현에 필요한 글로벌 데이터 구조를 설정하는 것입니다. xInit () 메소드가 NULL이면 응용 프로그램 정의 페이지 캐시 대신 기본 제공 기본 페이지 캐시가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit () 메소드는 &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출에 대해 한 번만 호출됩니다 (일반적으로 프로세스 수명 동안 한 번만). xInit () 메소드에는 sqlite3_pcache_methods2.pArg 값의 사본이 전달됩니다. xInit () 메소드의 목적은 사용자 정의 페이지 캐시 구현에 필요한 글로벌 데이터 구조를 설정하는 것입니다. xInit () 메소드가 NULL이면 응용 프로그램 정의 페이지 캐시 대신 기본 제공 기본 페이지 캐시가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">xLock 및 xUnlock 메소드는 파일 잠금을 설정하고 지우는 데 사용됩니다. SQLite는 5 가지 수준의 파일 잠금을 순서대로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">xMalloc, xRealloc 및 xFree 메소드는 표준 C 라이브러리의 malloc (), realloc () 및 free () 함수와 같이 작동해야합니다. SQLite는 xRealloc에 ​​대한 두 번째 인수가 항상 xRoundup에 대한 이전 호출에서 반환 된 값임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexEnd 메소드는 sqlite3_shutdown () 함수에 의해 시스템 종료의 일부로 호출됩니다. 이 메소드의 구현은, 뮤텍스 메소드 구현에 의해 취득 된 모든 미해결 자원, 특히 xMutexInit 메소드에 의해 취득 된 미해결 자원을 모두 공개 할 것으로 예상됩니다. xMutexEnd () 인터페이스는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()을&lt;/a&gt; 호출 할 때마다 정확히 한 번 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexEnd 메소드는 sqlite3_shutdown () 함수에 의해 시스템 종료의 일부로 호출됩니다. 이 메소드의 구현은, 뮤텍스 메소드 구현에 의해 취득 된 모든 미해결 자원, 특히 xMutexInit 메소드에 의해 취득 된 미해결 자원을 모두 공개 할 것으로 예상됩니다. xMutexEnd () 인터페이스는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()을&lt;/a&gt; 호출 할 때마다 정확히 한 번 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexInit 메소드는 sqlite3_initialize () 함수에 의한 시스템 초기화의 일부로 호출됩니다. SQLite는 xMutexInit 루틴을 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출마다 정확히 한 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexInit 메소드는 sqlite3_initialize () 함수에 의한 시스템 초기화의 일부로 호출됩니다. SQLite는 xMutexInit 루틴을 &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출마다 정확히 한 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">xMutexInit () 메소드는 스레드 안전해야합니다. 동일한 프로세스 내에서 xMutexEnd ()를 호출하지 않고 xMutexInit ()를 여러 번 호출하는 것은 무해해야합니다. xMutexInit ()에 대한 두 번째 및 후속 호출은 no-ops 여야합니다.</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">xNext 메소드 는 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter가&lt;/a&gt; 시작한 결과 세트의 다음 행으로 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;가상 테이블 커서&lt;/a&gt; 를 진행 시킵니다 . 이 루틴이 호출 될 때 커서가 이미 마지막 행을 가리키는 경우, 커서는 더 이상 유효한 데이터를 가리 &lt;a href=&quot;vtab#xeof&quot;&gt;키지 않으며 xEof&lt;/a&gt; 메소드에 대한 후속 호출 은 true (0이 아님)를 리턴해야합니다. 커서가 다른 내용의 행으로 성공적으로 이동 한 경우 &lt;a href=&quot;vtab#xeof&quot;&gt;xEof에 대한&lt;/a&gt; 후속 호출 은 false (영)를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">모든 가상 테이블 구현에는 xNext 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">xOpen 메소드는 가상 테이블에 액세스 (읽기 및 / 또는 쓰기)하는 데 사용되는 새 커서를 작성합니다. 이 메소드를 성공적으로 호출하면 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (또는 서브 클래스)에 메모리를 할당 하고 새 오브젝트를 초기화하고 * ppCursor가 새 오브젝트를 가리키게합니다. 그런 다음 성공적인 호출은 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">모든 가상 테이블 구현에는 xOpen 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">xOpen 메소드는 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; 구조 의 pVtab 필드를 초기화하지 않아도 됩니다. SQLite 코어는 해당 작업을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">데이터를 애플리케이션으로 리턴하기 위해 xOutput 콜백이 0 회 이상 호출됩니다. 각 호출에 전달되는 첫 번째 매개 변수는 응용 프로그램에서 제공 한 pOut 포인터의 사본입니다. 두 번째 매개 변수 pData는 반환되는 출력 데이터 청크를 포함하는 크기의 버퍼 nData 바이트를 가리 킵니다. xOutput 콜백이 제공된 데이터를 성공적으로 처리하면 성공을 표시하기 위해 SQLITE_OK를 리턴해야합니다. 그렇지 않으면 다른 SQLite 오류 코드를 반환해야합니다. 이 경우 처리가 즉시 중단되고 스트리밍 API 함수는 xOutput 오류 코드의 사본을 애플리케이션에 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">xPagecount () 메소드는 현재 캐시에 저장된 페이지 수 (고정 및 비 고정)를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFunc는 aCoord []에 의해 정의 된 경계 상자가 영역 외부에 있는지, 영역과 겹치거나 영역에 완전히 있는지 여부에 따라 sqlite3_rtree_query_info의 eWithin 필드를 NOT_WITHIN, PARTLY_WITHIN 또는 FULLY_WITHIN 값 중 하나로 설정해야합니다. 각기. 또한 xQueryFunc는 rScore 필드를 음수가 아닌 값으로 설정하여 쿼리의 하위 트리와 항목을 분석하고 반환해야하는 순서를 나타냅니다. 작은 점수가 먼저 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">xRandomness 메소드는 SQLite 내에서 의사 난수 생성기 (PRNG)를 초기화하기 위해 정확히 한 번만 사용됩니다. 기본 VFS의 xRandomness 방법 만 사용됩니다. 다른 VFS의 xRandomness 메소드는 SQLite에서 액세스하지 않습니다. xRandomness 루틴은 임의의 nByte 바이트를 zOut에 기록하도록 요청합니다. 루틴은 획득 한 임의의 실제 바이트 수를 리턴합니다. 이렇게 얻은 난수의 품질은 random () 및 randomblob ()와 같은 내장 SQLite 함수에 의해 생성 된 난수의 품질을 결정합니다. SQLite는 PRNG를 사용하여 임시 파일 이름을 생성합니다. 일부 플랫폼 (예 : Windows)에서 SQLite는 임시 파일 이름이 실제로 충돌을 테스트하지 않고 고유하다고 가정하므로 random () 및 randomblob () 함수를 사용하지 않더라도 양질의 임의성을 갖는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">xRandomness (), xSleep (), xCurrentTime () 및 xCurrentTimeInt64 () 인터페이스는 파일 시스템의 일부가 아니지만 완전성을 위해 VFS 구조에 포함됩니다. xRandomness () 함수는 양질의 임의성 nBytes 바이트를 zOut으로 리턴하려고 시도합니다. 리턴 값은 획득 된 실제 임의 바이트 수입니다. xSleep () 메소드는 호출 스레드가 최소한 지정된 마이크로 초 동안 휴면 상태가되도록합니다. xCurrentTime () 메소드는 현재 날짜 및 시간에 대한 율리우스 일 수를 부동 소수점 값으로 리턴합니다. xCurrentTimeInt64 () 메소드는 율리우스 일 수에 86400000 (24 시간 동안 밀리 초 수)을 곱한 값을 정수로 리턴합니다.SQLite는 해당 메소드를 사용할 수있는 경우 (iVersion이 2 이상이고 함수 포인터가 NULL이 아닌 경우) xCurrentTimeInt64 () 메소드를 사용하여 현재 날짜 및 시간을 가져오고 xCurrentTimeInt64 ()를 사용할 수없는 경우 xCurrentTime ()으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">xRead 메소드는 파일에서 바이트 오프셋에서 iOfst로 iAmt 바이트를 읽습니다. 읽은 데이터는 두 번째 매개 변수의 포인터에 저장됩니다. xRead는 반환 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; , 성공을 &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; 이 파일의 마지막에 도달, 또는 때문에 바이트의 전체 수를 읽을 수 없습니다 경우 &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; 다른 오류.</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">xRekey () 메소드는 두 번째 인수로 전달 된 페이지와 연관된 키 값을 변경하는 데 사용됩니다. 캐시에 이전에 newKey와 연관된 항목이 포함 된 경우이를 버려야합니다. newKey와 관련된 이전 캐시 항목은 고정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">xRename 방법은 선택 사항입니다. 생략하면 ALTER TABLE RENAME 명령을 사용하여 가상 테이블의 이름을 바꿀 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup 메소드는 특정 요청 크기가 주어진 경우 할당 된 메모리 할당 크기를 반환합니다. 대부분의 메모리 할당자는 메모리 할당을 8의 다음 배수로 반올림합니다. 일부 할당자는 더 큰 배수 또는 2의 거듭 제곱으로 올림합니다. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 을 통해 들어오는 모든 메모리 할당 요청은 먼저 xRoundup을 호출합니다. xRoundup이 0을 반환하면 해당 메모리 할당이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup 메소드는 특정 요청 크기가 주어진 경우 할당 된 메모리 할당 크기를 반환합니다. 대부분의 메모리 할당자는 메모리 할당을 8의 다음 배수로 반올림합니다. 일부 할당자는 더 큰 배수 또는 2의 거듭 제곱으로 올림합니다. &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 을 통해 들어오는 모든 메모리 할당 요청은 먼저 xRoundup을 호출합니다. xRoundup이 0을 반환하면 해당 메모리 할당이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">xRowid 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize는 기본 비 휘발성 매체의 &quot;섹터 크기&quot;를 반환합니다. &quot;섹터&quot;는 인접한 스토리지를 방해하지 않고 기록 할 수있는 가장 작은 스토리지 단위로 정의됩니다. 디스크 드라이브에서 &quot;섹터 크기&quot;는 최근까지 512 바이트 였지만이 값을 4KiB로 올리려는 노력이있었습니다. SQLite는 한 번에 전체 섹터를 쓸 수 있도록 섹터 크기를 알아야하므로 쓰기 도중에 전원 손실이 발생할 경우 인접한 스토리지 공간이 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">xSectorSize () 메서드는 파일의 기반이되는 장치의 섹터 크기를 반환합니다. 섹터 크기는 파일의 다른 바이트를 방해하지 않고 수행 할 수있는 최소 쓰기입니다. xDeviceCharacteristics () 메서드는 기본 장치의 동작을 설명하는 비트 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">xSetSystemCall (), xGetSystemCall () 및 xNestSystemCall () 인터페이스는 SQLite 코어에서 사용되지 않습니다. 이러한 선택적 인터페이스는 VFS 코드 테스트를 용이하게하기 위해 일부 VFS에서 제공합니다. 테스트 프로그램은 제어하에 함수로 시스템 호출을 재정의함으로써 유도하기 어렵거나 불가능한 결함 및 오류 조건을 시뮬레이션 할 수 있습니다. 재정의 할 수있는 시스템 호출 집합은 VFS마다 다르고 동일한 VFS 버전마다 다릅니다. 이러한 인터페이스를 사용하는 응용 프로그램은 이러한 인터페이스 중 일부 또는 전부가 NULL이거나 동작이 한 릴리스에서 다음 릴리스로 변경되도록 준비해야합니다. VFS의 iVersion이 3보다 작은 경우 응용 프로그램은 이러한 방법 중 하나에 액세스하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">xitedowName 메소드는 SQLite가 특정 실제 테이블이 실제로 가상 테이블의 새도우 테이블인지 여부를 판별 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">xShadowName 메소드는 입력이 마지막 &quot;_&quot;문자를 지난 테이블 이름의 일부인 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">xShmLock 메소드는 잠금 해제와 공유 사이 또는 잠금 해제와 독점 사이에서 전환 할 수 있습니다. SHARED와 EXCLUSIVE간에 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드 는 0과이 상한 사이의 값을 &quot;오프셋&quot;인수로 사용할 수 있습니다. SQLite 코어는이 범위를 벗어난 잠금을 획득하거나 해제하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드 는 0과이 상한 사이의 값을 &quot;오프셋&quot;인수로 사용할 수 있습니다. SQLite 코어는이 범위를 벗어난 잠금을 획득하거나 해제하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown () 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 호출됩니다 . 필요한 경우 프로세스 종료 전에 미해결 리소스를 정리하는 데 사용할 수 있습니다. xShutdown () 메소드는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown () 메소드는 &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 호출됩니다 . 필요한 경우 프로세스 종료 전에 미해결 리소스를 정리하는 데 사용할 수 있습니다. xShutdown () 메소드는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">xSleep 메소드는 최소한 주어진 마이크로 초 동안 호출 스레드를 일시 중단하는 데 사용됩니다. 이 메소드는 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; API 를 구현하는 데 사용됩니다 . 의 경우 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 디폴트의 xSleep 방법 VFS는 항상 사용됩니다. 기본 시스템에 마이크로 초 해상도 절전 기능이 없으면 절전 시간을 반올림해야합니다. xSleep는이 반올림 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">xSync 메소드가 다시 호출되어</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xSync 방법은 이전에 기록 된 데이터를 운영 체제 캐시 및 비 휘발성 메모리에 강제로 저장하는 데 사용됩니다. 두 번째 매개 변수는 일반적으로 &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; 입니다. 두 번째 매개 변수 인 경우 &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; 다음 xSync 방법이 있는지 데이터는 디스크 컨트롤러 캐시를 플러시되어 있는지 확인해야합니다. &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL의&lt;/a&gt; 매개 변수는 맥 OS X의 xSync 방법 반환에 F_FULLSYNC ioctl을 ()에 해당합니다 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 성공에 &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; 아무것도 잘못되면.</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">저널 파일에서 열린 파일 핸들의 xSync 메소드가 호출됩니다. 이 작업은 모든</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xTruncate 메소드는 파일을 길이가 nByte 바이트로 절단합니다. 파일 길이가 이미 nByte 바이트 이하인 경우이 방법은 작동하지 않습니다. xTruncate 메소드는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴 하고 &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;문제가&lt;/a&gt; 발생하면 SQLITE_IOERR_TRUNCATE 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">xUpdate 방법은 선택 사항입니다. 가상 테이블 에 대한 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 xUpdate 포인터 가 NULL 포인터 인 경우 가상 테이블은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">xUpdate 메소드는 &lt;a href=&quot;rescode#ok&quot;&gt;성공한&lt;/a&gt; 경우에만 SQLITE_OK 를 리턴해야합니다 . 장애가 발생하면 xUpdate는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 반환해야합니다 . 실패시 pVTab-&amp;gt; zErrMsg 요소는 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 과 같은 함수를 사용하여 SQLite에서 할당 된 메모리에 저장된 오류 메시지 텍스트로 선택적으로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">xUpdate 메소드는 DELETE 또는 INSERT 또는 둘 다를 수행합니다. argv [0] 요소 (메모리 셀 P3에 해당)는 삭제할 행의 rowid입니다. argv [0]이 NULL이면 삭제가 발생하지 않습니다. argv [1] 요소는 새 행의 rowid입니다. 가상 테이블이 자체적으로 새 rowid를 선택하도록하려면 NULL 일 수 있습니다. 배열의 후속 요소는 새 행의 열 값입니다.</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">xWrite 메소드는 iOfst 바이트 오프셋에서 시작하여 두 번째 매개 변수의 iAmt 바이트 데이터를 파일에 기록합니다. 파일 크기가 쓰기 전에 iOfst 바이트보다 작 으면 xWrite는 파일이 쓰기를 시작하기 전에 iOfst 바이트까지 0으로 확장되는지 확인해야합니다. xWrite 호출이 끝날 때 파일 크기가 iAmt + iOfst 바이트 이상이되도록 xWrite는 필요에 따라 파일을 계속 확장합니다. xWrite 메소드는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . 기본 저장 매체가 가득 차서 쓰기를 완료 할 수 없으면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 이 리턴됩니다. 다른 오류에 대해서는 &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; 가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">zFormat 문자열은 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">zName 필드에는 VFS 모듈의 이름이 있습니다. 이름은 모든 VFS 모듈에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">zName 필드는 VFS의 기호 이름입니다. 이것은 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 가 VFS를 찾을 때 비교 하는 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">zeroblob (N) 함수는 N 바이트 0x00으로 구성된 BLOB를 반환합니다. SQLite는 이러한 제로 블롭을 매우 효율적으로 관리합니다. Zeroblobs는 &lt;a href=&quot;c3ref/blob_open&quot;&gt;BLOB I / O를&lt;/a&gt; 사용하여 나중에 작성된 BLOB의 공간을 예약하는 데 사용할 수 있습니다 . 이 SQL 함수는 C / C ++ 인터페이스에서 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; 루틴을 사용하여 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">zipfile 모듈은 간단한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP 아카이브에&lt;/a&gt; 대한 읽기 / 쓰기 액세스를 제공합니다 . 현재 구현에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">zipfile 모듈은 zip 파일 아카이브에 액세스, 업데이트 및 작성하기위한 세 가지 유사한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">zipfile 모듈은 zip 아카이브에 액세스하기위한 두 개의 유사한 인터페이스를 제공합니다. 기존 아카이브에 대한 읽기 전용 액세스를 제공하는 테이블 반환 함수와 읽기 및 쓰기 액세스를 모두 제공하는 가상 테이블 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">zipfile () 집계 함수는 2, 4 또는 5 개의 인수와 함께 호출 될 수 있습니다. 5 개의 인수로 호출 된 경우 아카이브에 추가 된 항목은 zipfile 가상 테이블의 &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot;및 &quot;method&quot;열에 동일한 값을 삽입하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">그러면 열 &quot;c&quot;에서 연산자 =, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =, &amp;lt;&amp;gt;, IN, LIKE 또는 GLOB를 사용하는 쿼리는 &quot;c&quot;인 경우에만 비교 연산자가 참이므로 부분 인덱스와 함께 사용할 수 있습니다. NULL이 아닙니다. 따라서 다음 쿼리는 부분 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">그런 다음 3.7 절에 설명 된대로 &quot;트렁크&quot;의 변경 사항을 &quot;개인&quot;변경 사항과 계속 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">그런 다음 테이블 값 PRAGMA 함수를 사용하여 공식 정보 스키마 테이블을 구현하는 해당 스키마에서 &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; 를 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">그런 다음 새 버전의 SQLite 소스를 다운로드하고 체크 아웃에있는 파일을 겹쳐 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">그런 다음 아래의 두 쿼리 중 하나를 실행하여 &quot;linux&quot;(351)라는 단어가 포함 된 데이터베이스의 문서 수를 찾을 수 있습니다. 하나의 데스크톱 PC 하드웨어 구성을 사용하면 FTS3 테이블의 쿼리는 일반 테이블 쿼리의 경우 22.5에 비해 약 0.03 초 후에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="translated">그런 다음 반환 된 각 &quot;id&quot;값에 대해 응용 프로그램이 다음과 같은 UPDATE 문을 만들고 &quot;? 1&quot;매개 변수에 대해 반환 된 &quot;id&quot;값을 바인딩한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">그런 다음 응용 프로그램 이 작성 될 때 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 분배 할 수있는 더 큰 lookaside 메모리 버퍼 풀을 유지 보수하십시오 . 일반적인 경우 응용 프로그램은 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 만 가지 므로 lookaside 메모리 풀은 하나의 큰 버퍼로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e376e98c10da73b25d2ab9a479ff86c1a4e0ab3c" translate="yes" xml:space="preserve">
          <source>Then no rows are returned. SQLite knows that the t1.b column actually holds a 7-character string, and the 7-character string 'abc'||char(0)||'xyz' is not equal to the 3-character string 'abc', and so no rows are returned. But a user might be easily confused by this because the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; output seems to show that the string has only 3 characters. This seems like a bug. But it is how SQLite works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">그런 다음 제약 조건 중 하나는 연산자 &quot;=&quot;및 표현식 &quot;5&quot;가있는 &quot;a&quot;열에 있습니다. 제약 조건에는 WHERE 절을 문자 그대로 나타낼 필요가 없습니다. 쿼리 최적화 프로그램은 가능한 한 많은 제약 조건을 추출하기 위해 WHERE 절을 변환 할 수 있습니다. 예를 들어 WHERE 절에 다음과 같은 내용이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">그런 다음 &quot;sh speed-check.sh trunk&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">그런 다음 해당 용어는 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">그런 다음 LIKE 연산자는 사례에주의를 기울이고 위의 예는 false로 평가됩니다. 대소 문자 구분은 라틴어 1 문자에만 적용됩니다 (기본적으로 ASCII의 127 바이트 코드에서 영어의 대문자와 소문자). 비 ASCII 문자를 고려 하는 응용 프로그램 정의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#like&quot;&gt;like () SQL 함수&lt;/a&gt; 가 제공 되지 않으면 다국어 문자 세트는 SQLite에서 대소 문자를 구분합니다. 그러나 응용 프로그램 정의 조합 순서 및 / 또는 like () SQL 함수가 제공되면 여기에 설명 된 LIKE 최적화는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">그런 다음 RBU 데이터베이스에는 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="translated">그런 다음 SQLITE_LOCKED 오류와 함께 UPDATE가 실패 할 수 있습니다. 그 이유는 초기 쿼리가 완료되지 않았기 때문입니다. R-Tree 스캔 중간에 위치를 기억하고 있습니다. 따라서 R-Tree에 대한 업데이트는 스캔을 방해 할 수 있으므로 허용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">그런 다음 생성 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">그러면 &quot;b = 6&quot;용어가 인덱스 정의와 쿼리 모두에 나타나므로 쿼리에서 인덱스를 사용할 수 있습니다. 색인의 용어는 OR로 연결되어야하고 쿼리의 용어는 AND로 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">그런 다음 인덱스의 초기 열 (열 a, b 등)이 WHERE 절 용어에 나타나는 경우 인덱스를 사용할 수 있습니다. 색인의 초기 컬럼은 * = * 또는 * IN * 또는 * IS * 연산자와 함께 사용해야합니다. 사용되는 가장 오른쪽 열은 불평등을 사용할 수 있습니다. 사용되는 인덱스의 가장 오른쪽 열에 대해 허용 된 열 값을 두 극단 사이에 두어야하는 최대 2 개의 부등식이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">그런 다음 인덱스는 것이다 &lt;u&gt;되지&lt;/u&gt; 는 쿼리 (Y + X)에 나타나는 인덱스를 CREATE 문 (X + Y)에 대한 표현은 표현과 동일하지 않기 때문에 사용할 수. 두 표현식은 수학적으로 동일하지만 SQLite 쿼리 플래너는 단순히 동등한 것이 아니라 동일하다고 주장합니다. 쿼리를 다음과 같이 다시 작성해보십시오.</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">그런 다음 잠금 모드는 명명 된 데이터베이스에만 적용됩니다. &quot;locking_mode&quot;키워드 앞에 데이터베이스 이름 규정자가 없으면 후속 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령으로 추가 된 새 데이터베이스를 포함하여 모든 데이터베이스에 잠금 모드가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">그런 다음 두 개의 숨겨진 열과 &quot;VARCHAR (12)&quot;및 &quot;INTEGER&quot;데이터 유형으로 가상 테이블이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">그런 다음 해당 데이터베이스 파일의 첫 페이지를 읽으려면 다음 중 하나만 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">그런 다음 두 개의 &quot;가상&quot;용어가 다음과 같이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX ()&lt;/a&gt; 함수를 사용하여 큰 문자열 값을 SQL 문에 바인딩합니다. 바인딩을 사용하면 문자열에서 따옴표 문자를 이스케이프 할 필요가 없어 SQL 주입 공격의 위험이 줄어 듭니다. 또한 큰 문자열을 많이 구문 분석하거나 복사 할 필요가 없기 때문에 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX ()&lt;/a&gt; 함수를 사용하여 큰 문자열 값을 SQL 문에 바인드하십시오. 바인딩을 사용하면 문자열에서 따옴표 문자를 이스케이프 할 필요가 없으므로 SQL 삽입 공격의 위험이 줄어 듭니다. 큰 문자열을 구문 분석하거나 복사 할 필요가 없으므로 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">그런 다음 이웃을 자신처럼 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="aaba5b69e34e258d19f535d62804a66ddc861cc0" translate="yes" xml:space="preserve">
          <source>Then, when the application attempts to open the database, register the system() function, then run an innocent query against the &quot;tab1&quot; table, it instead deletes all the files in its working directory. Yikes!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;vtablist&quot;&gt;많은 다른 가상 테이블 구현&lt;/a&gt; 예제로 사용할 수 있습니다 SQLite는 소스 트리에가. &quot;sqlite3_create_module&quot;을 검색하여 이러한 다른 가상 테이블 구현을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">단일 레벨에 U 개 이상의 이러한 b- 트리가 있습니다 ( b- 트리 레벨에 대한 설명은 &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 자동 병합 옵션&lt;/a&gt; 문서 참조 ). 여기서 U는 &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge 옵션&lt;/a&gt; 옵션에 지정된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">서버리스가되는 장점과 단점이 있습니다. 주요 이점은 설치, 설정, 구성, 초기화, 관리 및 문제 해결을위한 별도의 서버 프로세스가 없다는 것입니다. 이것이 SQLite가 &quot; &lt;a href=&quot;zeroconf&quot;&gt;제로 구성&lt;/a&gt; &quot;데이터베이스 엔진 인 이유 중 하나 입니다. SQLite를 사용하는 프로그램은 실행하기 전에 데이터베이스 엔진을 설정하기위한 관리 지원이 필요하지 않습니다. 디스크에 액세스 할 수있는 모든 프로그램은 SQLite 데이터베이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">서버리스가되는 장점과 단점이 있습니다. 주요 이점은 설치, 설정, 구성, 초기화, 관리 및 문제 해결을위한 별도의 서버 프로세스가 없다는 것입니다. 이것이 SQLite가 &quot;제로 구성&quot;데이터베이스 엔진 인 이유 중 하나입니다. SQLite를 사용하는 프로그램은 실행하기 전에 데이터베이스 엔진을 설정하기위한 관리 지원이 필요하지 않습니다. 디스크에 액세스 할 수있는 모든 프로그램은 SQLite 데이터베이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">롤백 저널 대신 WAL을 사용하면 장단점이 있습니다. 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">메모리 매핑 된 I / O를 사용하면 장단점이 있습니다. 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">CREATE INDEX 문에 나타나는 표현식에 대한 합리적인 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">SQLite의 다양한 구조의 크기에 상한을 설정하는 컴파일 타임 옵션이 있습니다. 컴파일 타임 옵션은 일반적으로 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 인터페이스를 사용하여 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 런타임시 변경할 수있는 하드 상한을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">가상 머신에 의해 현재 170 개의 opcode가 정의되어 있습니다. 현재 정의 된 모든 opcode가 아래 표에 설명되어 있습니다. 이 테이블은 &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt; 파일에서 소스 코드를 스캔하여 자동으로 생성 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">현재 가상 머신에 정의 된 175 개의 opcode가 있습니다. 현재 정의 된 모든 opcode는 아래 표에 설명되어 있습니다. 이 테이블은 &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt; 파일에서 소스 코드를 스캔하여 자동으로 생성 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">현재 다음 구성 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">여기에 기입해야 할 세부 사항이 있습니다. 아마도 사용자가 보거나 편집 할 버전을 선택할 수 있도록 내역 변경 (그래프와 함께)을 표시하는 화면이 제공 될 수 있습니다. 버전 기록에서 발생할 수있는 포크를 병합하기 위해 일부 기능을 제공 할 수 있습니다. 그리고 아마도 응용 프로그램은 이전 버전과 원하지 않는 버전을 제거하는 수단을 제공해야합니다. 중요한 점은 ZIP 아카이브가 아닌 SQLite 데이터베이스를 사용하여 컨텐츠를 저장하면 이러한 모든 기능을 훨씬 쉽게 구현할 수있게되어 결국 구현 될 가능성이 높아진다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="97fa5e0129d965dcc6b70eeae4ab75a90f4ae6ee" translate="yes" xml:space="preserve">
          <source>There are dozens and dozens of SQL function implementations scattered throughout the SQLite source code that can be used as example applications. The built-in SQL functions use the same interface as application-defined SQL functions, so built-in functions can be used as examples too. Search for &quot;sqlite3_context&quot; in the SQLite source code to find examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">0에서 4까지의 5 개의 개별 읽기 잠금이 있습니다. 읽기 잠금은 SHARED 또는 EXCLUSIVE 일 수 있습니다. 연결은 트랜잭션 내에있는 동안 읽기 잠금 바이트 중 하나에서 공유 잠금을 얻습니다. 또한 연결은 해당 읽기 표시의 값을 업데이트하는 동안 잠시 동안 읽기 잠금에 대해 독점 잠금을 얻습니다. 읽기 잠금 1-4는 &lt;a href=&quot;walformat#recovery&quot;&gt;복구를&lt;/a&gt; 실행할 때 독점적으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">시작 및 끝 프레임 경계를 설명하는 5 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">핵심 SQLite 라이브러리를 테스트하는 데 사용되는 4 개의 독립적 인 테스트 도구가 있습니다. 각 테스트 장치는 다른 장치와 별도로 설계, 유지 관리 및 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="253fb3b554421e91657bed4f34f13690b219d88b" translate="yes" xml:space="preserve">
          <source>There are many SQL-based database management systems available, besides SQLite. Common options include MySQL, PostgreSQL, and SQL-Server. All these systems use the SQL langauge to communicate with the application, just like SQLite. But these other systems different from SQLite in important respects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">SQLite를 응용 프로그램 파일 형식으로 사용하면 다음과 같은 많은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">이 방법에는 성능 향상, 비용 및 복잡성 감소, 안정성 향상 등 많은 이점이 있습니다. 기술 노트를 참조하십시오 &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; 및 &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; 및 &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; 자세한 내용을. 이 사용 사례는 아래 의 &lt;a href=&quot;#wireproto&quot;&gt;데이터 전송 형식&lt;/a&gt; 및 &lt;a href=&quot;#container&quot;&gt;데이터 컨테이너&lt;/a&gt; 사용 사례 와 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">실패한 특정 I / O 조작을 식별하는 I / O 오류에 대한 여러 가지 확장 된 결과 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">고용량 (예 : 8GB)을 가지고 있지만 실제로는 훨씬 적은 양 (예 : 1GB) 만 저장할 수있는 사기성 USB 스틱이 많이 유통되고 있습니다. 이러한 장치에 쓰려고하면 관련없는 파일을 덮어 쓰는 경우가 종종 있습니다. 따라서 사기성 플래시 메모리 장치를 사용하면 데이터베이스가 쉽게 손상 될 수 있습니다. &quot;가짜 용량 USB&quot;와 같은 인터넷 검색은이 문제에 대한 많은 방해 정보를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">위에 나열되지 않은 더 많은 기능이 있습니다. SQLite는 크기가 작고 이름에 &quot;Lite&quot;가있을 수 있지만 기능이 부족하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">명령 줄 셸에서 사용할 수있는 다른 많은 도트 명령이 있습니다. SQLite의 특정 버전 및 빌드에 대한 전체 목록은 &quot;.help&quot;명령을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">명령을 실행하여 볼 수있는 다른 많은 테스트 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">테스트 범위를 측정하는 방법에는 여러 가지가 있습니다. 가장 많이 사용되는 메트릭은 &quot;statement coverage&quot;입니다. 더 이상의 설명없이 자신의 프로그램이 &quot;XX % 테스트 적용 범위&quot;라고 말하는 것을들을 때 일반적으로 진술 범위를 의미합니다. 명령문 적용 범위는 테스트 제품군에서 최소 한 번 실행 된 코드 줄 백분율을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">TH3에는 임의의 제한이 없습니다. 모든 테스트 모듈과 모든 구성 파일을 포함하는 단일 테스트 프로그램을 생성 할 수 있습니다. 그러나 이러한 테스트 프로그램은 너무 커서 임베디드 플랫폼에 배포 할 수 없습니다. (2018 년 5 월 19 일 현재 전체 TH3 테스트는 80 만 라인 이상, C 코드는 58MB 이상입니다.) TH3은 테스트 모듈 라이브러리를 더 작고 더 쉽게 소화 할 수있는 조각으로 나눌 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">단일 테이블에 첨부 할 수있는 인덱스 수에는 임의의 제한이 없습니다. 인덱스의 열 수는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt; , ...)에 의해 설정된 값으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 다중 스레드로 설정합니다 . 즉, &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트 에서 mutexing을 사용하지 않습니다 . 응용 프로그램은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화해야 합니다 . 그러나 두 개의 스레드가 동일한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에 사용하려고 시도하지 않는 한 다중 스레드 환경에서 SQLite를 안전하게 사용할 수 있도록 다른 뮤텍스가 활성화 됩니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 다중 스레드 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 및 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 설정할 수 없습니다반환 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 직렬화로 설정합니다 . 즉,이 옵션은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 재귀 뮤텍스 와 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 객체를 포함하여 모든 뮤텍스를 활성화 합니다. 이 모드 (SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1로&lt;/a&gt; 컴파일 될 때 기본값 임 )에서 SQLite 라이브러리는 자체적으로 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화 하여 애플리케이션이 다른 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 에서 동일한 데이터베이스 연결 또는 동일한 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 자유롭게 사용할 수 있도록합니다. 동시에. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0으로&lt;/a&gt; 컴파일 된 경우다음은 직렬화 설정할 수 없습니다 옵션을 컴파일시 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 와 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 반환합니다 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_SERIALIZED 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 단일 스레드로 설정합니다 . 즉, 모든 뮤텍스를 비활성화하고 SQLite를 단일 스레드에서만 사용할 수있는 모드로 만듭니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 기본값 인 단일 스레드 에서 변경할 수 없으므로 SQLITE_CONFIG_SINGLETHREAD 구성 옵션으로 호출하면 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 는 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 다중 스레드로 설정합니다 . 즉, &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트 에서 mutexing을 사용하지 않습니다 . 응용 프로그램은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화해야 합니다 . 그러나 두 개의 스레드가 동일한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에 사용하려고 시도하지 않는 한 다중 스레드 환경에서 SQLite를 안전하게 사용할 수 있도록 다른 뮤텍스가 활성화 됩니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 다중 스레드 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 설정할 수 없습니다반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 직렬화로 설정합니다 . 즉,이 옵션은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 재귀 뮤텍스 와 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 객체를 포함하여 모든 뮤텍스를 활성화 합니다. 이 모드 (SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1로&lt;/a&gt; 컴파일 될 때 기본값 임 )에서 SQLite 라이브러리는 자체적으로 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화 하여 애플리케이션이 다른 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 에서 동일한 데이터베이스 연결 또는 동일한 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 자유롭게 사용할 수 있도록합니다. 동시에. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0으로&lt;/a&gt; 컴파일 된 경우다음은 직렬화 설정할 수 없습니다 옵션을 컴파일시 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 반환합니다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_SERIALIZED 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 단일 스레드로 설정합니다 . 즉, 모든 뮤텍스를 비활성화하고 SQLite를 단일 스레드에서만 사용할 수있는 모드로 만듭니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 기본값 인 단일 스레드 에서 변경할 수 없으므로 SQLITE_CONFIG_SINGLETHREAD 구성 옵션으로 호출하면 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">SQLite가 잘못된 데이터베이스 파일을 처리 할 수 ​​있는지 확인하는 수많은 테스트 사례가 있습니다. 이 테스트는 먼저 올바른 형식의 데이터베이스 파일을 작성한 다음 SQLite 이외의 다른 방법으로 파일에서 하나 이상의 바이트를 변경하여 손상을 추가합니다. 그런 다음 SQLite를 사용하여 데이터베이스를 읽습니다. 경우에 따라 바이트 변경이 데이터 중간에 있습니다. 이로 인해 데이터베이스의 형식을 유지하면서 데이터베이스의 내용이 변경됩니다. 다른 경우에는 파일의 사용되지 않는 바이트가 수정되어 데이터베이스의 무결성에 영향을 미치지 않습니다. 흥미로운 경우는 데이터베이스 구조를 정의하는 파일의 바이트가 변경되는 경우입니다. 잘못된 데이터베이스 테스트는 SQLite가 파일 형식 오류를 찾아서 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT를&lt;/a&gt; 사용하여보고하는지 확인합니다. 버퍼 오버 플로우, NULL 포인터 역 참조 또는 기타 부적절한 동작을 수행하지 않고 리턴 코드.</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">이 쿼리를 구현하는 데는 두 가지 합리적인 방법이 있습니다. (가능한 다른 알고리즘이 많이 있지만, &quot;최상의&quot;알고리즘에 대한 경쟁자는 없습니다.)</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">코드를 광범위하고 자유롭게 사용할 수있는 자유 라이센스가있는 다른 SQL 데이터베이스 엔진이 있습니다. 그러나 다른 엔진에는 여전히 저작권법이 적용됩니다. SQLite는 저작권법이 단순히 적용되지 않는다는 점에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">핵심 SQLite 소스 코드 라이브러리와 사용 가능한 확장 모두에 다른 VFS 구현이 있습니다. 위의 목록은 완전한 것이 아니라 VFS 인터페이스를 사용하여 실현할 수있는 기능의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문에 동등한 외래 키 선언을 추가하는 몇 가지 다른 방법이 있습니다 . 자세한 내용은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">RELEASE 명령에 대해 여러 가지 방법으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">FTS5에는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">비 결정적 함수의 사용을 허용하지 않는 일부 컨텍스트는 SQLite에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">구문 다이어그램에 표시되지 않은 VALUES 절 사용에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">ROWS, GROUPS 및 RANGE의 세 가지 프레임 유형이 있습니다. 프레임 유형에 따라 프레임의 시작 및 끝 경계가 측정되는 방식이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">핵심 SQLite 라이브러리를 테스트하는 데 사용되는 세 개의 독립적 인 테스트 하네스가 있습니다. 각 테스트 하니스는 다른 테스트 하니스와 별도로 설계, 유지 보수 및 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">공유 캐시 잠금 모델, 트랜잭션 수준 잠금, 테이블 수준 잠금 및 스키마 수준 잠금에는 세 가지 수준이 있습니다. 다음 세 가지 하위 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e99c034a6b8af219b7e8f49f9f3d601cff4065a7" translate="yes" xml:space="preserve">
          <source>There are three math functions available:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eaabb690f2c43b66d0713f1063a91097f30c63b" translate="yes" xml:space="preserve">
          <source>There are three possible outputs from the verify_checksum() function: 1, 0, and NULL. 1 is returned if the checksum is correct. 0 is returned if the checksum is incorrect. NULL is returned if the page is unreadable. If checksumming is enabled, the read will fail if the checksum is wrong, so the usual result from verify_checksum() on a bad checksum is NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">잠금 모드를 독점으로 설정해야하는 세 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">비용 테이블에는 세 가지 특수한 경우 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">&lt;b&gt;sprintf&lt;/b&gt; 대신 SQLite printf 함수를 사용하면 두 가지 장점이 있습니다 . 우선, SQLite printf 루틴을 사용하면 &lt;b&gt;sprintf&lt;/b&gt; 와 같이 정적 버퍼가 오버플로 될 위험이 없습니다 . SQLite printf 루틴은 생성 된 SQL 문을 보유하는 데 필요한만큼의 메모리를 자동으로 할당 (및 나중에 해제)합니다.</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">두 가지 집계 SQL 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">고려해야 할 두 가지 경우가 있습니다. (1) 테이블 &quot;tab1&quot;이 존재하지 않고 (2) 테이블 &quot;tab1&quot;이 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">두 개의 열 (M == 2)과 세 개의 행 (N == 3)이 있습니다. 따라서 결과 테이블에는 8 개의 항목이 있습니다. 결과 테이블이 배열 이름 azResult에 저장되어 있다고 가정하십시오. 그런 다음 azResult는 다음 내용을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="translated">두 개의 열 (M == 2)과 세 개의 행 (N == 3)이 있습니다. 따라서 결과 테이블에는 8 개의 항목이 있습니다. 결과 테이블이 azResult라는 배열에 저장되어 있다고 가정합니다. 그런 다음 azResult는 다음 콘텐츠를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">이 변형에는 두 가지 차이점이 있습니다. 초기 선택은 &quot;VALUES (1)&quot;대신 &quot;SELECT 1&quot;입니다. 그러나 이것들은 정확히 같은 것을 말하는 다른 구문입니다. 다른 변경은 재귀가 WHERE 절이 아닌 LIMIT에 의해 중지된다는 것입니다. LIMIT를 사용하면 1 백만 번째 행이 &quot;cnt&quot;테이블에 추가되고 (쿼리 최적화 프로그램으로 인해 기본 SELECT에 의해 리턴 될 때) 큐에 남아있는 행 수에 관계없이 재귀가 즉시 중지됩니다. . 보다 복잡한 쿼리에서는 WHERE 절이 결국 큐를 비우고 재귀가 종료되도록하는 것이 어려울 수 있습니다. 그러나 LIMIT 절은 항상 재귀를 중지합니다.따라서 재귀 크기의 상한을 알고있는 경우 항상 LIMIT 절을 안전으로 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">togethr 또는 개별적으로 사용할 수있는 두 가지 별도의 구성 변경 사항이 있습니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD의&lt;/a&gt; 설정은에 직렬화 액세스 것을 뮤텍스 비활성화 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 객체와 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체. 이 설정을 사용하면 응용 프로그램이 여러 스레드에서 SQLite는 무료로 사용할 수 있지만 두 개의 스레드가 같은 액세스하려고하지보다가 있는지 확인해야합니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 같은과 관련된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에합니다. 두 스레드는 동시에 SQLite를 사용할 수 있지만 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 사용해야 합니다 . 두 번째 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;설정은 모든 미해결 메모리 할당 요청의 총 크기를 추적하는 SQLite의 메커니즘을 비활성화합니다. 이렇게하면 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()에 대한&lt;/a&gt; 각 호출을 뮤텍스 할 필요가 없으므로 엄청난 수의 뮤텍스 작업이 절약됩니다. 그러나 메모리 통계 메커니즘을 비활성화하면 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">여기서는 getgethr 또는 별도로 사용할 수있는 두 가지 구성 변경이 있습니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD의&lt;/a&gt; 설정은에 직렬화 액세스 것을 뮤텍스 비활성화 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 객체와 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체. 이 설정을 사용하면 응용 프로그램이 여러 스레드에서 SQLite는 무료로 사용할 수 있지만 두 개의 스레드가 같은 액세스하려고하지보다가 있는지 확인해야합니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 같은과 관련된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에합니다. 두 개의 스레드가 동시에 SQLite를 사용할 수 있지만 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 사용해야 합니다 . 두 번째 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;설정은 모든 미해결 메모리 할당 요청의 총 크기를 추적하는 SQLite의 메커니즘을 비활성화합니다. 따라서 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()에 대한&lt;/a&gt; 각 호출을 mutex 할 필요가 없으므로 많은 수의 mutex 작업이 절약됩니다. 그러나 메모리 통계 메커니즘을 비활성화하면 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">간단한 SELECT 문에는 집계 및 비 집계 쿼리라는 두 가지 유형이 있습니다. 간단한 SELECT 문은 결과 집합에 GROUP BY 절 또는 하나 이상의 집계 함수가 포함 된 경우 집계 쿼리입니다. 그렇지 않으면 간단한 SELECT에 집계 함수 나 GROUP BY 절이 포함되어 있지 않으면 집계되지 않은 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">&quot;content&quot;옵션을 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">통계가 사용 가능한 각 인덱스에 대해 sqlite_stat4 테이블에 일반적으로 10-40 개의 항목이 있지만 이러한 한계는 하드 한계가 아닙니다. sqlite_stat4 테이블에서 열의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">sqlite_stat3 테이블에는 일반적으로 각 색인에 대한 여러 항목이 있습니다. sqlite_stat3.sample 컬럼은 sqlite_stat3.idx 및 sqlite_stat3.tbl에 의해 식별 된 색인의 가장 왼쪽 필드 값을 보유합니다. sqlite_stat3.nEq 열은 가장 왼쪽 열이 샘플과 정확히 일치하는 색인의 대략적인 항목 수를 보유합니다. sqlite_stat3.nLt는 가장 왼쪽 열이 샘플보다 작은 인덱스의 대략적인 항목 수를 보유합니다. sqlite_stat3.nDLt 열은 샘플보다 적은 인덱스에서 가장 왼쪽에있는 고유 한 항목 수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">인덱스 당 임의의 수의 sqlite_stat3 항목이있을 수 있습니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령은 일반적으로 키 공간을 가로 질러 큰 NEQ 값으로 분포되어 10 ~ 40 샘플을 포함 sqlite_stat3 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">인덱스 당 임의의 수의 sqlite_stat4 항목이있을 수 있습니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령은 일반적으로 키 공간을 가로 질러 큰 NEQ 값으로 분포되어 10 ~ 40 샘플을 포함 sqlite_stat4 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">각 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만 정의 될 수 있습니다 . 새로운 통화 중 처리기를 설정하면 이전에 설정된 처리기가 지워집니다. &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N을&lt;/a&gt; 평가 하면 사용중인 핸들러가 변경되어 이전에 설정된 사용중인 핸들러가 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">각 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만 정의 될 수 있습니다 . 새로운 통화 중 처리기를 설정하면 이전에 설정된 처리기가 지워집니다. &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N을&lt;/a&gt; 평가 하면 사용중인 핸들러가 변경되어 이전에 설정된 사용중인 핸들러가 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">특정 시점에 특정 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만있을 수 있습니다 . 이 루틴을 호출하기 전에 다른 사용중인 핸들러가 정의 된 경우 ( &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler () 사용&lt;/a&gt; ) 해당 다른 사용중인 핸들러가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">특정 시점에 특정 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만있을 수 있습니다 . 이 루틴을 호출하기 전에 다른 사용중인 핸들러가 정의 된 경우 ( &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler () 사용&lt;/a&gt; ) 해당 다른 사용중인 핸들러가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">프로세스 당 하나의 오류 로깅 콜백 만있을 수 있습니다. 오류 로깅 콜백은 시작시 다음과 유사한 C 코드를 사용하여 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">데이터베이스 연결에 등록 된 단일 추적 콜백 만있을 수 있습니다. &quot;trace&quot;또는 &quot;trace_v2&quot;를 사용할 때마다 모든 이전 추적 콜백이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">단일 파일 디스크립터에 대해 두 번째 mmap () 호출을 수행하면 첫 번째 mmap () 호출에서 얻은 메모리가 0이 될 수 있도록 QNX에서 mmap ()에 미묘한 문제가 있습니다. Unix의 SQLite는 mmap ()을 사용하여 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 트랜잭션 조정을위한 공유 메모리 영역을 작성하며 대규모 트랜잭션의 경우 mmap ()을 여러 번 호출합니다. QNX mmap ()은 해당 시나리오에서 데이터베이스 파일을 손상시키는 것으로 입증되었습니다. QNX 엔지니어는이 문제를 알고 있으며 해결책을 찾고 있습니다. 이 내용을 읽을 때 문제가 이미 해결되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">최근 Rust 또는 Go와 같은 &quot;안전한&quot;프로그래밍 언어에 관심이있어 메모리 누수 나 어레이 오버런과 같은 일반적인 프로그래밍 오류를 만드는 것이 불가능하거나 적어도 어렵다. 따라서 SQLite가 &quot;안전한&quot;언어로 코딩되지 않은 이유에 대한 의문이 종종 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">SQLite에 대한 세 가지 히스토리 파일 형식이 있습니다. SQLite 1.0부터 1.0.32까지는 &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; 라이브러리를 스토리지 엔진으로 사용했습니다. SQLite 2.0.0부터 2.8.17까지는 텍스트 키와 데이터 만 지원하는 사용자 지정 b- 트리 저장소 엔진을 사용했습니다. 모든 최신 버전의 SQLite (3.0.0부터 현재)는 이진 데이터 및 유니 코드를 완벽하게 지원하는 b- 트리 스토리지 엔진을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 라는 함수 가 있으며 가장 최근의 삽입 작업에 대한 정수 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt; 를 사용하여 단일 데이터베이스 연결에 동시에 연결할 수있는 데이터베이스 수에 한계 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">쿼리 병합을 수행하기 위해 충족해야하는 조건 목록이 많이 있습니다. 일부 제약 조건은 기울임 꼴 텍스트에서 더 이상 사용되지 않는 것으로 표시됩니다. 이러한 추가 제약 조건은 다른 제약 조건의 번호를 유지하기 위해 설명서에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">표현식이 숫자인지 텍스트인지 판별하는 데 사용되는 새로운 TypeOf () 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">sqlite_sequence 테이블에는 AUTOINCREMENT를 사용하는 각 일반 테이블에 대한 단일 행이 있습니다. sqlite_master.name에 표시되는 테이블 이름은 sqlite_sequence.main 필드에 있으며 해당 테이블에 삽입 된 최대 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 는 sqlite_sequence.seq 필드에 있습니다. AUTOINCREMENT 테이블에 대해 새로 자동 생성 된 정수 기본 키는 해당 테이블의 sqlite_sequence.seq 필드보다 커야합니다. AUTOINCREMENT 테이블의 sqlite_sequence.seq 필드가 이미 가장 큰 정수 값 (9223372036854775807) 인 경우 자동으로 생성 된 정수 1 차로 해당 테이블에 새 행을 추가하려고 시도하면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 과 함께 실패합니다 .오류. sqlite_sequence.seq 필드는 새 항목이 AUTOINCREMENT 테이블에 삽입 될 때 필요한 경우 자동으로 업데이트됩니다. AUTOINCREMENT 테이블의 sqlite_sequence 행은 테이블이 삭제 될 때 자동으로 삭제됩니다. AUTOINCREMENT 테이블이 갱신 될 때 AUTOINCREMENT 테이블에 대한 sqlite_sequence 행이 존재하지 않으면, 새로운 sqlite_sequence 행이 작성됩니다. AUTOINCREMENT 테이블의 sqlite_sequence.seq 값을 수동으로 정수 이외의 값으로 설정 한 후 AUTOINCREMENT 테이블을 삽입하거나 업데이트하려는 후속 시도가 있으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">AUTOINCREMENT를 사용하는 각 일반 테이블에 대한 sqlite_sequence 테이블에는 단일 행이 있습니다. 테이블 이름 (sqlite_schema.name에 표시됨)은 sqlite_sequence.main 필드에 있으며 해당 테이블에 삽입 된 가장 큰 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 는 sqlite_sequence.seq 필드에 있습니다. AUTOINCREMENT 테이블에 대해 자동으로 생성 된 새로 생성 된 정수 기본 키는 해당 테이블의 sqlite_sequence.seq 필드보다 큰 것이 보장됩니다. AUTOINCREMENT 테이블의 sqlite_sequence.seq 필드가 이미 가장 큰 정수 값 (9223372036854775807)에있는 경우 자동으로 생성 된 정수 기본을 사용하여 해당 테이블에 새 행을 추가하려고하면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 과 함께 실패합니다 .오류. sqlite_sequence.seq 필드는 AUTOINCREMENT 테이블에 새 항목이 삽입 될 때 필요한 경우 자동으로 업데이트됩니다. AUTOINCREMENT 테이블의 sqlite_sequence 행은 테이블이 삭제 될 때 자동으로 삭제됩니다. AUTOINCREMENT 테이블이 업데이트 될 때 AUTOINCREMENT 테이블에 대한 sqlite_sequence 행이 없으면 새 sqlite_sequence 행이 생성됩니다. AUTOINCREMENT 테이블에 대한 sqlite_sequence.seq 값이 정수가 아닌 다른 값으로 수동 설정되고 이후에 AUTOINCREMENT 테이블을 삽입하거나 업데이트하려는 시도가있는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">데이터베이스 파일의 각 페이지에 대해 dbstat 테이블의 단일 행이 있습니다. 데이터베이스 파일의 프리리스트 페이지, 잠금 페이지 및 포인터 맵 페이지가 dbstat 가상 테이블에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">&quot;.once -e&quot;명령도 있습니다. 기본 스프레드 시트 대신 시스템의 기본 텍스트 편집기가 호출되도록 임시 파일의 이름을 &quot;.txt&quot;접미어로 지정한다는 점을 제외하면 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">패턴과 단어 사이의 Wagner 편집 거리 또는 Levenshtein 거리를 계산하는 기능도 있습니다. 이 함수는 spellfix1_editdist (X, Y)로 노출됩니다. 거리 편집 기능은 X를 Y로 변환하는 &quot;비용&quot;을 반환합니다. 일부 변환은 다른 변환보다 비용이 많이 듭니다. 예를 들어, 하나의 모음을 다른 모음으로 변경하는 것은 상수를 두 배로 늘리거나 이중 상수의 두 번째 문자를 생략하는 것처럼 비교적 저렴합니다. 다른 변형 또는 더 비쌉니다. 아이디어는 거리 편집 기능이 유사한 단어에 대해서는 저렴한 비용을, 더 떨어져있는 단어에는 더 높은 비용을 반환한다는 것입니다. 이 구현에서 단일 문자 편집 (삭제, 삽입 또는 대체)의 최대 비용은 100이며 일부 편집 (예 : 모음 변환)에 대한 비용이 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">또한 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 새로운 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode가 있어 응용 프로그램이 데이터베이스 파일의 powersafe 겹쳐 쓰기 특성을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">확장을로드하는 데 사용할 수있는 SQL 함수도 있습니다 : &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension (X, Y)&lt;/a&gt; . &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C 인터페이스 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">항상 기본 VFS가 있습니다. 레거시 인터페이스 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()은&lt;/a&gt; 항상 기본 VFS를 사용합니다. 데이터베이스 연결 작성을위한 새로운 인터페이스 인 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 사용하면 이름으로 사용할 VFS를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">기본 VFS 인 VFS는 항상 하나입니다. 유닉스 시스템에서는 &quot;unix&quot;VFS가 기본값으로 나타나고 Windows에서는 &quot;win32&quot;입니다. 다른 조치를 취하지 않으면 새 데이터베이스 연결에서 기본 VFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">각 데이터베이스와 연관된 추가 준 지속적 &quot; &lt;code&gt;-wal&lt;/code&gt; &quot;파일 및 &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;공유 메모리 파일이 있으므로 SQLite를 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용하기에 덜 매력적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">준비된 SQL 문에서 와일드 카드에 값을 지정하는 데 사용되는 sqlite3_bind 루틴이 있습니다. 언 바운드 와일드 카드는 NULL로 해석됩니다. 바인딩은 sqlite3_reset ()에 의해 재설정되지 않습니다. 그러나 sqlite3_reset () 다음에 와일드 카드를 새 값으로 리 바인드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">모든 프로그램의 맨 끝에 묵시적 &quot; &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot;명령이 삽입되었습니다. 따라서 프로그램의 마지막 명령을 뛰어 넘는 것은 &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 실행과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt; 에이 저장소의 비공식 및 승인되지 않은 Git 복제본이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">SELECT 문을 사용하여 최적화 작업을 호출하는 더 이상 사용되지 않는 다른 방법이 있습니다. 새 코드는 위의 INSERT와 유사한 명령문을 사용하여 FTS 구조를 최적화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">&quot;CREATE TEMP VIRTUAL TABLE&quot;문이 없습니다. 임시 가상 테이블을 작성하려면 가상 테이블 이름 앞에 &quot;temp&quot;스키마를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">해당 데이터베이스 파일에 예약 된 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">UTF-16 문자열에 대한 C 데이터 유형이 무엇인지에 대해서는 동의하지 않습니다. 따라서 SQLite는 일반적인 유형의 void *를 사용하여 UTF-16 문자열을 참조합니다. 클라이언트 소프트웨어는 시스템에 적합한 데이터 유형으로 void *를 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">이 경우 충돌하는 행이 없습니다. sqlite3changeset_conflict () API를 호출 한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">사전 정의 된 릴리스주기가 없습니다. 많은 기능 향상 및 / 또는 버그 수정이있을 때 릴리스가 발생합니다. 역사적으로 릴리스는 매년 약 5-6 회 발생했습니다. SQLite 사용자는 필요에 따라 웹 사이트에서 새 릴리스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">기본 데이터베이스 파일에는 예약 된 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 지원되지 않습니다 . 가상 테이블의 변경 사항이 캡처되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">일반적으로 인덱스 당 하나의 행이 있으며 인덱스는 sqlite_stat1.idx 열의 이름으로 식별됩니다. sqlite_stat1.tbl 열은 인덱스가 속한 테이블의 이름입니다. 이러한 각 행에서 sqlite_stat.stat 열은 정수 목록과 0 개 이상의 인수로 구성된 문자열입니다. 이 목록의 첫 번째 정수는 색인의 대략적인 행 수입니다. (인덱스의 행 수는 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스를&lt;/a&gt; 제외하고 테이블의 행 수와 동일 합니다..) 두 번째 정수는 인덱스의 첫 번째 열에서 동일한 값을 갖는 인덱스의 대략적인 행 수입니다. 세 번째 정수는 처음 두 열에 대해 동일한 값을 갖는 인덱스의 행 수입니다. N 번째 정수 (N&amp;gt; 1의 경우)는 인덱스에서 첫 번째 N-1 열에 대해 동일한 값을 갖는 예상 평균 행 수입니다. K- 컬럼 인덱스의 경우 통계 열에 K + 1 정수가 있습니다. 인덱스가 고유하면 마지막 정수는 1입니다.</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">응용 프로그램이 핵심 SQLite 코드를 수정하지 않고도 대체 malloc () / free () 구현을 정의 할 수있는 컴파일 타임 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">응용 프로그램이 핵심 SQLite 코드를 수정하지 않고도 대체 뮤텍스 구현을 정의 할 수있는 컴파일 타임 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">% _node 테이블에는 각 R * Tree 노드마다 하나의 항목이 있습니다. R * Tree 노드는 서로 근접한 하나 이상의 항목으로 구성됩니다. 트리에 대한 R * Tree의 노드입니다. 루트 이외의 모든 노드에는 % _parent 새도우 테이블에 상위 노드를 식별하는 항목이 있습니다. R * Tree의 각 항목에는 rowid가 있습니다. % _rowid 새도우 테이블은 항목 rowid를 해당 항목이 포함 된 노드에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">이전 단락에는 한 가지 예외가 있습니다. 행을 삽입, 업데이트 또는 삭제하는 경우 하나 이상의 기본 키 열에 NULL 값이 포함되어 있으면 변경 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">ON UPDATE 외래 키 동작과 SQL 트리거 사이에는 중요한 차이점이 있습니다. ON UPDATE 조치는 새 상위 키 값이 이전 값과 같지 않도록 상위 키 값이 수정 된 경우에만 수행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">&quot;docid&quot;와 rowid 열의 일반 SQLite 별명 간에는 미묘한 차이가 있습니다. 일반적으로 INSERT 또는 UPDATE 문이 이산 값을 rowid 열의 둘 이상의 별칭에 할당하면 SQLite는 INSERT 또는 UPDATE 문에 지정된 값 중 가장 오른쪽을 데이터베이스에 씁니다. 그러나 FTS 테이블을 삽입하거나 갱신 할 때 &quot;docid&quot;및 하나 이상의 SQLite rowid 별명 모두에 NULL이 아닌 값을 지정하는 것은 오류로 간주됩니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">분류기 개체가 하나뿐이므로이를 열거 나 닫는 지침이 없습니다. 필요할 때 자동으로 열리고 VDBE 프로그램이 중지되면 닫힙니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
