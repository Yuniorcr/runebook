<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="96cc17a506c60ac9000086a1e0105e51d535d45e" translate="yes" xml:space="preserve">
          <source>The sqlite3_last_insert_rowid(D) interface usually returns the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; of the most recent successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; into a rowid table or &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; on database connection D. Inserts into &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are not recorded. If no successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;s into rowid tables have ever occurred on the database connection D, then sqlite3_last_insert_rowid(D) returns zero.</source>
          <target state="translated">sqlite3_last_insert_rowid (D) 인터페이스는 일반적으로 반환 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 가장 최근의 성공의 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWID 테이블이나에 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에 데이터베이스 연결 D. 삽입에를 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID의없이&lt;/a&gt; 테이블이 기록되지 않습니다. 데이터베이스 연결 D에서 rowid 테이블에 대한 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 가 성공적으로 수행되지 않은 경우 sqlite3_last_insert_rowid (D)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="97d28d93a8572fd39455b44f97795fb1531500e9" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension () 인터페이스 는 파일 zFile에 포함 된 &lt;a href=&quot;../loadext&quot;&gt;SQLite 확장&lt;/a&gt; 라이브러리 를로드하려고 시도합니다 . 파일을 직접로드 할 수없는 경우 다양한 운영 체제 별 확장명을 추가하여로드를 시도합니다. 예를 들어 &quot;samplelib&quot;를로드 할 수없는 경우 &quot;samplelib.so&quot;또는 &quot;samplelib.dylib&quot;또는 &quot;samplelib.dll&quot;과 같은 이름도 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29a1d12e678745f57cc139b953c6116a8408aff6" translate="yes" xml:space="preserve">
          <source>The sqlite3_load_extension() interface attempts to load an &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; library contained in the file zFile. If the file cannot be loaded directly, attempts are made to load with various operating-system specific extensions added. So for example, if &quot;samplelib&quot; cannot be loaded, then names like &quot;samplelib.so&quot; or &quot;samplelib.dylib&quot; or &quot;samplelib.dll&quot; might be tried also.</source>
          <target state="translated">sqlite3_load_extension () 인터페이스 는 파일 zFile에 포함 된 &lt;a href=&quot;loadext&quot;&gt;SQLite 확장&lt;/a&gt; 라이브러리 를로드하려고 시도합니다 . 파일을 직접로드 할 수없는 경우 다양한 운영 체제 별 확장명을 추가하여로드를 시도합니다. 예를 들어 &quot;samplelib&quot;를로드 할 수없는 경우 &quot;samplelib.so&quot;또는 &quot;samplelib.dylib&quot;또는 &quot;samplelib.dll&quot;과 같은 이름도 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="653b87892cb27376af041bf3731e3304fd208799" translate="yes" xml:space="preserve">
          <source>The sqlite3_log() interface is intended for use by extensions such as virtual tables, collating functions, and SQL functions. While there is nothing to prevent an application from calling sqlite3_log(), doing so is considered bad form.</source>
          <target state="translated">sqlite3_log () 인터페이스는 가상 테이블, 데이터 정렬 함수 및 SQL 함수와 같은 확장에서 사용하기위한 것입니다. 응용 프로그램이 sqlite3_log ()를 호출하는 것을 막을 방법이 없지만, 그렇게하는 것은 잘못된 형식으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c4ad2aeb0d9be1f2327ef6d534ab004f6a2b8dc6" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc() routine returns a pointer to a block of memory at least N bytes in length, where N is the parameter. If sqlite3_malloc() is unable to obtain sufficient free memory, it returns a NULL pointer. If the parameter N to sqlite3_malloc() is zero or negative then sqlite3_malloc() returns a NULL pointer.</source>
          <target state="translated">sqlite3_malloc () 루틴은 최소 N 바이트 길이의 메모리 블록에 대한 포인터를 리턴합니다. 여기서 N은 매개 변수입니다. sqlite3_malloc ()이 충분한 여유 메모리를 확보 할 수 없으면 NULL 포인터를 리턴합니다. sqlite3_malloc ()에 대한 매개 변수 N이 0이거나 음수이면 sqlite3_malloc ()은 NULL 포인터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a4e65f99f4accbf5db989c9154cb81e75b9ee8ed" translate="yes" xml:space="preserve">
          <source>The sqlite3_malloc64(N) routine works just like sqlite3_malloc(N) except that N is an unsigned 64-bit integer instead of a signed 32-bit integer.</source>
          <target state="translated">sqlite3_malloc64 (N) 루틴은 sqlite3_malloc (N)과 동일하게 작동합니다. N은 부호있는 32 비트 정수 대신 부호없는 64 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="6aa420d40670b164a1cce9b427bd49e7d1c5fd88" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf () 및 sqlite3_vmprintf () 루틴은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 결과를 씁니다 . 이 두 루틴이 리턴 한 문자열은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()에&lt;/a&gt; 의해 해제되어야합니다 . &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 가 결과 문자열을 보유하기에 충분한 메모리를 할당 할 수없는 경우 두 루틴 모두 NULL 포인터를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="aeca10a8c44ac57eac0c9c7f71ba952063b68cc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_mprintf() and sqlite3_vmprintf() routines write their results into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. The strings returned by these two routines should be released by &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;. Both routines return a NULL pointer if &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; is unable to allocate enough memory to hold the resulting string.</source>
          <target state="translated">sqlite3_mprintf () 및 sqlite3_vmprintf () 루틴은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 결과를 씁니다 . 이 두 루틴이 리턴 한 문자열은 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()에&lt;/a&gt; 의해 해제되어야합니다 . &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 가 결과 문자열을 보유하기에 충분한 메모리를 할당 할 수없는 경우 두 루틴 모두 NULL 포인터를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="f0bcf6e7726b974822789eb5eaa08500974adb52" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_alloc() routine allocates a new mutex and returns a pointer to it. The sqlite3_mutex_alloc() routine returns NULL if it is unable to allocate the requested mutex. The argument to sqlite3_mutex_alloc() must one of these integer constants:</source>
          <target state="translated">sqlite3_mutex_alloc () 루틴은 새로운 뮤텍스를 할당하고 이에 대한 포인터를 반환합니다. sqlite3_mutex_alloc () 루틴은 요청 된 뮤텍스를 할당 할 수없는 경우 NULL을 리턴합니다. sqlite3_mutex_alloc ()에 대한 인수는 다음 정수 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2d81df454ad810426381d8f39e8b57e0d9de3e46" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter () 및 sqlite3_mutex_try () 루틴은 뮤텍스 입력을 시도합니다. 다른 스레드가 이미 뮤텍스 내에 있으면 sqlite3_mutex_enter ()가 차단되고 sqlite3_mutex_try ()는 SQLITE_BUSY를 반환합니다. sqlite3_mutex_try () 인터페이스는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;입력&lt;/a&gt; 에 성공하면 SQLITE_OK 를 반환합니다 . SQLITE_MUTEX_RECURSIVE를 사용하여 작성된 뮤텍스는 동일한 스레드로 여러 번 입력 할 수 있습니다. 이 경우 다른 스레드가 들어가기 전에 뮤텍스를 같은 횟수만큼 종료해야합니다. 동일한 스레드가 SQLITE_MUTEX_RECURSIVE 이외의 뮤텍스를 두 번 이상 입력하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b45ebc24527ab0f89738f7016be66d43d5251ac" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt to enter a mutex. If another thread is already within the mutex, sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return SQLITE_BUSY. The sqlite3_mutex_try() interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; upon successful entry. Mutexes created using SQLITE_MUTEX_RECURSIVE can be entered multiple times by the same thread. In such cases, the mutex must be exited an equal number of times before another thread can enter. If the same thread tries to enter any mutex other than an SQLITE_MUTEX_RECURSIVE more than once, the behavior is undefined.</source>
          <target state="translated">sqlite3_mutex_enter () 및 sqlite3_mutex_try () 루틴은 뮤텍스 입력을 시도합니다. 다른 스레드가 이미 뮤텍스 내에 있으면 sqlite3_mutex_enter ()가 차단되고 sqlite3_mutex_try ()는 SQLITE_BUSY를 반환합니다. sqlite3_mutex_try () 인터페이스는 &lt;a href=&quot;../rescode#ok&quot;&gt;입력&lt;/a&gt; 에 성공하면 SQLITE_OK 를 반환합니다 . SQLITE_MUTEX_RECURSIVE를 사용하여 작성된 뮤텍스는 동일한 스레드로 여러 번 입력 할 수 있습니다. 이 경우 다른 스레드가 들어가기 전에 뮤텍스를 같은 횟수만큼 종료해야합니다. 동일한 스레드가 SQLITE_MUTEX_RECURSIVE 이외의 뮤텍스를 두 번 이상 입력하려고하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a9c3683cf3483b6e604960673d2e4ca248bc41dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_free() routine deallocates a previously allocated dynamic mutex. Attempting to deallocate a static mutex results in undefined behavior.</source>
          <target state="translated">sqlite3_mutex_free () 루틴은 이전에 할당 된 동적 뮤텍스를 할당 해제합니다. 정적 뮤텍스 할당 해제를 시도하면 정의되지 않은 동작이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c54fa9a704452135b01172d66edadf344257a173" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_held() and sqlite3_mutex_notheld() routines are intended for use inside assert() statements. The SQLite core never uses these routines except inside an assert() and applications are advised to follow the lead of the core. The SQLite core only provides implementations for these routines when it is compiled with the SQLITE_DEBUG flag. External mutex implementations are only required to provide these routines if SQLITE_DEBUG is defined and if NDEBUG is not defined.</source>
          <target state="translated">sqlite3_mutex_held () 및 sqlite3_mutex_notheld () 루틴은 assert () 문에서 사용하기위한 것입니다. SQLite 코어는 assert () 내부를 제외하고는 이러한 루틴을 사용하지 않으며 애플리케이션은 코어의 리드를 따르는 것이 좋습니다. SQLite 코어는 SQLITE_DEBUG 플래그로 컴파일 될 때 이러한 루틴에 대한 구현 만 제공합니다. 외부 뮤텍스 구현은 SQLITE_DEBUG가 정의되어 있고 NDEBUG가 정의되지 않은 경우에만 이러한 루틴을 제공하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="93534cd54fb671abd29d988fdeee0858c44767d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_mutex_leave() routine exits a mutex that was previously entered by the same thread. The behavior is undefined if the mutex is not currently entered by the calling thread or is not currently allocated.</source>
          <target state="translated">sqlite3_mutex_leave () 루틴은 이전에 동일한 스레드에 의해 입력 된 뮤텍스를 종료합니다. 뮤텍스가 현재 호출 스레드에 의해 입력되지 않았거나 현재 할당되지 않은 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb745ae4bf7930e6464af0ad23559d80e7f2b3bc" translate="yes" xml:space="preserve">
          <source>The sqlite3_open() routine returns an integer error code rather than a pointer to the sqlite3 structure as the version 2 interface did. The difference between sqlite3_open() and sqlite3_open16() is that sqlite3_open16() takes UTF-16 (in host native byte order) for the name of the database file. If a new database file needs to be created, then sqlite3_open16() sets the internal text representation to UTF-16 whereas sqlite3_open() sets the text representation to UTF-8.</source>
          <target state="translated">sqlite3_open () 루틴은 버전 2 인터페이스와 마찬가지로 sqlite3 구조에 대한 포인터가 아닌 정수 오류 코드를 리턴합니다. sqlite3_open ()과 sqlite3_open16 ()의 차이점은 sqlite3_open16 ()은 데이터베이스 파일 이름으로 UTF-16 (호스트 기본 바이트 순서)을 사용한다는 것입니다. 새 데이터베이스 파일을 작성해야하는 경우 sqlite3_open16 ()은 내부 텍스트 표현을 UTF-16으로 설정하고 sqlite3_open ()은 텍스트 표현을 UTF-8로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="49cca3441049c31bbff034c5494130978bd29358" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2 () 인터페이스는 새로운 데이터베이스 연결에 대한 추가 제어를 위해 두 개의 추가 매개 변수를 허용한다는 점을 제외하면 sqlite3_open ()과 유사하게 작동합니다. sqlite3_open_v2 ()에 대한 flags 매개 변수는 다음 세 가지 값 중 하나를 취할 수 있습니다.&lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt; SQLITE_OPEN_NOMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 .</target>
        </trans-unit>
        <trans-unit id="e598ece82e5f2beb42f8604c9b91c3f1054b0c31" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() can take one of the following three values, optionally combined with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;, &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt;, and/or &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; flags:</source>
          <target state="translated">sqlite3_open_v2 () 인터페이스는 새로운 데이터베이스 연결에 대한 추가 제어를 위해 두 개의 추가 매개 변수를 허용한다는 점을 제외하면 sqlite3_open ()과 유사하게 작동합니다. sqlite3_open_v2 ()에 대한 flags 매개 변수는 선택적으로 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; 와 결합 된 다음 세 값 중 하나를 취할 수 있습니다. , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; , &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; 및 / 또는 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_URI&lt;/a&gt; 플래그 .</target>
        </trans-unit>
        <trans-unit id="5a0142d09a66478c971c322bbffc0dda8bf83c4b" translate="yes" xml:space="preserve">
          <source>The sqlite3_open_v2() interface works like sqlite3_open() except that it accepts two additional parameters for additional control over the new database connection. The flags parameter to sqlite3_open_v2() must include, at a minimum, one of the following three flag combinations:</source>
          <target state="translated">sqlite3_open_v2 () 인터페이스는 새로운 데이터베이스 연결에 대한 추가 제어를 위해 두 개의 추가 매개 변수를 허용한다는 점을 제외하면 sqlite3_open ()과 같이 작동합니다. sqlite3_open_v2 ()에 대한 flags 매개 변수는 최소한 다음 세 가지 플래그 조합 중 하나를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e55b10d2fb69bf6bea01941ab944f29f8bde45c" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init () 루틴은 SQLite 라이브러리의 운영 체제 별 초기화를 수행합니다. sqlite3_os_end () 루틴은 sqlite3_os_init ()의 효과를 취소합니다. 이러한 루틴에 의해 수행되는 일반적인 작업에는 정적 자원 할당 또는 할당 해제, 전역 변수 초기화, 기본 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 모듈 설정 또는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 사용하여 기본 구성 설정이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea78da5df45c282e78d4b89a318af0ce437587df" translate="yes" xml:space="preserve">
          <source>The sqlite3_os_init() routine does operating-system specific initialization of the SQLite library. The sqlite3_os_end() routine undoes the effect of sqlite3_os_init(). Typical tasks performed by these routines include allocation or deallocation of static resources, initialization of global variables, setting up a default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; module, or setting up a default configuration using &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_os_init () 루틴은 SQLite 라이브러리의 운영 체제 별 초기화를 수행합니다. sqlite3_os_end () 루틴은 sqlite3_os_init ()의 효과를 취소합니다. 이러한 루틴에 의해 수행되는 일반적인 작업에는 정적 자원 할당 또는 할당 해제, 전역 변수 초기화, 기본 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 모듈 설정 또는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 사용하여 기본 구성 설정이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bd4022600e005736b49c1c51ead1422ec8da9c9" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache type is opaque. It is implemented by the pluggable module. The SQLite core has no knowledge of its size or internal structure and never deals with the sqlite3_pcache object except by holding and passing pointers to the object.</source>
          <target state="translated">sqlite3_pcache 유형이 불투명합니다. 플러그 가능한 모듈로 구현됩니다. SQLite 코어는 크기 나 내부 구조를 알지 못하며 포인터를 잡고 객체에 전달하는 것 외에는 sqlite3_pcache 객체를 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07293c189451b8c181f77d9379a0238420ee3f47" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_methods structure and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; configuration parameters are deprecated. They are replaced by a new &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; structure and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; configuration parameters.</source>
          <target state="translated">sqlite3_pcache_methods 구조 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache&quot;&gt;SQLITE_CONFIG_PCACHE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache&quot;&gt;SQLITE_CONFIG_GETPCACHE&lt;/a&gt; 구성 매개 변수는 더 이상 사용되지 않습니다. 그것들은 새로운 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 로 대체됩니다 구조와 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiggetpcache2&quot;&gt;SQLITE_CONFIG_GETPCACHE2&lt;/a&gt; 구성 매개 변수 .</target>
        </trans-unit>
        <trans-unit id="445aa02fd749c19bfbd930e14dfefb0c0e11a4d3" translate="yes" xml:space="preserve">
          <source>The sqlite3_pcache_page object represents a single page in the page cache. The page cache will allocate instances of this object. Various methods of the page cache use pointers to instances of this object as parameters or as their return value.</source>
          <target state="translated">sqlite3_pcache_page 객체는 페이지 캐시의 단일 페이지를 나타냅니다. 페이지 캐시는이 개체의 인스턴스를 할당합니다. 페이지 캐시의 다양한 메소드는이 오브젝트의 인스턴스에 대한 포인터를 매개 변수 또는 리턴 값으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7bf15591143e8308e465ab8ab773665acb5da577" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare interface compiles a single SQL statement into byte code for later execution. This interface is now the preferred way of accessing the database.</source>
          <target state="translated">sqlite3_prepare 인터페이스는 나중에 실행하기 위해 단일 SQL 문을 바이트 코드로 컴파일합니다. 이 인터페이스는 이제 데이터베이스에 액세스하는 기본 방법입니다.</target>
        </trans-unit>
        <trans-unit id="63425e76fcf41641f3bb3043a50f94b90abaff47" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () 및 sqlite3_prepare16_v3 () 인터페이스는 모든 새 프로그램에 권장됩니다. 이전 인터페이스 (sqlite3_prepare () 및 sqlite3_prepare16 ())는 이전 버전과의 호환성을 위해 유지되지만 사용을 권장하지 않습니다. &quot;vX&quot;인터페이스에서 리턴 된 준비된 명령문 ( &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 오브젝트)은 원래 SQL 텍스트의 사본을 포함합니다. 이로 인해&lt;a href=&quot;#sqlite3_step&quot;&gt; sqlite3_step ()&lt;/a&gt; 인터페이스는 세 가지 방식으로 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="31c4a31d37db839c6c488798a5abc3fd1e42192d" translate="yes" xml:space="preserve">
          <source>The sqlite3_prepare_v2(), sqlite3_prepare_v3(), sqlite3_prepare16_v2(), and sqlite3_prepare16_v3() interfaces are recommended for all new programs. The older interfaces (sqlite3_prepare() and sqlite3_prepare16()) are retained for backwards compatibility, but their use is discouraged. In the &quot;vX&quot; interfaces, the prepared statement that is returned (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; object) contains a copy of the original SQL text. This causes the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; interface to behave differently in three ways:</source>
          <target state="translated">sqlite3_prepare_v2 (), sqlite3_prepare_v3 (), sqlite3_prepare16_v2 () 및 sqlite3_prepare16_v3 () 인터페이스는 모든 새 프로그램에 권장됩니다. 이전 인터페이스 (sqlite3_prepare () 및 sqlite3_prepare16 ())는 이전 버전과의 호환성을 위해 유지되지만 사용을 권장하지 않습니다. &quot;vX&quot;인터페이스에서 리턴 된 준비된 명령문 ( &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt&lt;/a&gt; 오브젝트)은 원래 SQL 텍스트의 사본을 포함합니다. 이로 인해&lt;a href=&quot;step&quot;&gt; sqlite3_step ()&lt;/a&gt; 인터페이스는 세 가지 방식으로 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1133258b4a9a31b0c0513ddc50dd402acde6047e" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler (D, N, X, P) 인터페이스는 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 장기 호출을하는 동안 콜백 함수 X가 주기적으로 호출되도록합니다.&lt;a href=&quot;#sqlite3_free_table&quot;&gt;&lt;/a&gt; 데이터베이스 연결 D에 대한 sqlite3_get_table () 을 합니다.이 인터페이스의 사용 예는 다음과 같습니다. 큰 쿼리 중에 GUI를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="6ede9775015331a2dade498d028dbb0b1a89b661" translate="yes" xml:space="preserve">
          <source>The sqlite3_progress_handler(D,N,X,P) interface causes the callback function X to be invoked periodically during long running calls to &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; for database connection D. An example use for this interface is to keep a GUI updated during a large query.</source>
          <target state="translated">sqlite3_progress_handler (D, N, X, P) 인터페이스는 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; , &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 &lt;a href=&quot;free_table&quot;&gt;sqlite3_get_table ()을&lt;/a&gt; 오랫동안 실행하는 동안 콜백 함수 X가 주기적으로 호출되도록합니다. 데이터베이스 연결 D에 대한 을 합니다.이 인터페이스의 사용 예는 다음과 같습니다. 큰 쿼리 중에 GUI를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="92b3414b60e6ff01e63206d0ac8d5d46b8bec0e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc(X,N) interface attempts to resize a prior memory allocation X to be at least N bytes. If the X parameter to sqlite3_realloc(X,N) is a NULL pointer then its behavior is identical to calling sqlite3_malloc(N). If the N parameter to sqlite3_realloc(X,N) is zero or negative then the behavior is exactly the same as calling sqlite3_free(X). sqlite3_realloc(X,N) returns a pointer to a memory allocation of at least N bytes in size or NULL if insufficient memory is available. If M is the size of the prior allocation, then min(N,M) bytes of the prior allocation are copied into the beginning of buffer returned by sqlite3_realloc(X,N) and the prior allocation is freed. If sqlite3_realloc(X,N) returns NULL and N is positive, then the prior allocation is not freed.</source>
          <target state="translated">sqlite3_realloc (X, N) 인터페이스는 이전 메모리 할당 X의 크기를 최소 N 바이트로 조정하려고 시도합니다. sqlite3_realloc (X, N)에 대한 X 매개 변수가 NULL 포인터이면 sqlite3_malloc (N) 호출과 동일합니다. sqlite3_realloc (X, N)에 대한 N 매개 변수가 0이거나 음수이면 동작은 sqlite3_free (X)를 호출하는 것과 정확히 동일합니다. sqlite3_realloc (X, N)은 사용 가능한 메모리가 충분하지 않은 경우 크기가 N 바이트 이상이거나 NULL 인 메모리 할당에 대한 포인터를 반환합니다. M이 이전 할당의 크기이면, 이전 할당의 min (N, M) 바이트가 sqlite3_realloc (X, N)에 의해 리턴 된 버퍼의 시작 부분에 복사되고 이전 할당이 해제됩니다. sqlite3_realloc (X, N)이 NULL을 반환하고 N이 양수이면 이전 할당이 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e95adede07a7a66375653b101c394b5d26a89fcd" translate="yes" xml:space="preserve">
          <source>The sqlite3_realloc64(X,N) interfaces works the same as sqlite3_realloc(X,N) except that N is a 64-bit unsigned integer instead of a 32-bit signed integer.</source>
          <target state="translated">sqlite3_realloc64 (X, N) 인터페이스는 sqlite3_realloc (X, N)과 동일하게 작동합니다. N은 32 비트 부호있는 정수 대신 64 비트 부호없는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c45df4cf90bd7042631d9142c52fed7adb90361e" translate="yes" xml:space="preserve">
          <source>The sqlite3_rebaser object is deleted by calling sqlite3rebaser_delete().</source>
          <target state="translated">sqlite3rebaser_delete ()를 호출하면 sqlite3_rebaser 객체가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4a286ff8214a968ca30b48466d6f539d2ffd723c" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory () 인터페이스는 데이터베이스 라이브러리가 보유한 비 필수 메모리 할당을 할당 해제하여 N 바이트의 힙 메모리를 해제하려고 시도합니다. 성능 향상을 위해 데이터베이스 페이지를 캐시하는 데 사용되는 메모리는 필수적이지 않은 메모리의 예입니다. sqlite3_release_memory ()는 실제로 해제 된 바이트 수를 반환합니다. 이는 요청 된 양보다 많거나 적을 수 있습니다. SQLite가 다음과 같이 컴파일되지 않은 경우 sqlite3_release_memory () 루틴은 0을 반환하는 no-op입니다&lt;a href=&quot;../compile#enable_memory_management&quot;&gt; SQLITE_ENABLE_MEMORY_MANAGEMENT로&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e641eb92f089a94b694e1eb10428491e684eab1f" translate="yes" xml:space="preserve">
          <source>The sqlite3_release_memory() interface attempts to free N bytes of heap memory by deallocating non-essential memory allocations held by the database library. Memory used to cache database pages to improve performance is an example of non-essential memory. sqlite3_release_memory() returns the number of bytes actually freed, which might be more or less than the amount requested. The sqlite3_release_memory() routine is a no-op returning zero if SQLite is not compiled with &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">sqlite3_release_memory () 인터페이스는 데이터베이스 라이브러리가 보유한 비 필수 메모리 할당을 할당 해제하여 N 바이트의 힙 메모리를 해제하려고 시도합니다. 성능 향상을 위해 데이터베이스 페이지를 캐시하는 데 사용되는 메모리는 필수적이지 않은 메모리의 예입니다. sqlite3_release_memory ()는 실제로 해제 된 바이트 수를 반환합니다. 이는 요청 된 양보다 많거나 적을 수 있습니다. SQLite가 다음과 같이 컴파일되지 않은 경우 sqlite3_release_memory () 루틴은 0을 반환하는 no-op입니다&lt;a href=&quot;compile#enable_memory_management&quot;&gt; SQLITE_ENABLE_MEMORY_MANAGEMENT로&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="54ae89d5ac2183e89297de25b936056b80fa288f" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset () 함수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트를 초기 상태로 다시 설정하여 다시 실행할 준비가되도록 호출됩니다 . &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind _ * () API를&lt;/a&gt; 사용하여 값이 바인드 된 모든 SQL 문 변수는 해당 값을 유지합니다. 사용하다&lt;a href=&quot;#sqlite3_clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; 를 하여 바인딩을 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="55cabea2592a4db5b69eb055b74aa3254a909a13" translate="yes" xml:space="preserve">
          <source>The sqlite3_reset() function is called to reset a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object back to its initial state, ready to be re-executed. Any SQL statement variables that had values bound to them using the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_*() API&lt;/a&gt; retain their values. Use &lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings()&lt;/a&gt; to reset the bindings.</source>
          <target state="translated">sqlite3_reset () 함수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트를 초기 상태로 다시 설정하여 다시 실행할 준비가되도록 호출됩니다 . &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind _ * () API를&lt;/a&gt; 사용하여 값이 바인드 된 모든 SQL 문 변수는 해당 값을 유지합니다. 사용하다&lt;a href=&quot;clear_bindings&quot;&gt;sqlite3_clear_bindings ()&lt;/a&gt; 를 하여 바인딩을 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ee8a502aaf09ac296b4bb201f29d8a4e68054a04" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_blob() interface sets the result from an application-defined function to be the BLOB whose content is pointed to by the second parameter and which is N bytes long where N is the third parameter.</source>
          <target state="translated">sqlite3_result_blob () 인터페이스는 응용 프로그램 정의 함수의 결과를 내용이 두 번째 매개 변수로 가리키고 N 바이트 길이 인 BLOB가되도록 설정합니다. 여기서 N은 세 번째 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="b7904572bea3279794f2bcc9179991e08e12d408" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_double() interface sets the result from an application-defined function to be a floating point value specified by its 2nd argument.</source>
          <target state="translated">sqlite3_result_double () 인터페이스는 응용 프로그램 정의 함수의 결과를 두 번째 인수로 지정된 부동 소수점 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ea6209b4564a5f3773fd6febf3293c65522a4bc0" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 in native byte order. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error () 및 sqlite3_result_error16 () 함수는 구현 된 SQL 함수에서 예외를 발생시킵니다. SQLite는 sqlite3_result_error () 또는 sqlite3_result_error16 ()의 두 번째 매개 변수가 가리키는 문자열을 오류 메시지의 텍스트로 사용합니다. SQLite는 sqlite3_result_error ()의 오류 메시지 문자열을 UTF-8로 해석합니다. SQLite는 sqlite3_result_error16 ()의 문자열을 원시 바이트 순서로 UTF-16으로 해석합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 세 번째 매개 변수가 음수이면 SQLite는 첫 번째 0 문자를 통해 모든 텍스트를 오류 메시지로 사용합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 세 번째 매개 변수가 음이 아닌 경우 SQLite는 두 번째 매개 변수에서 문자 수가 아닌 많은 바이트를 오류 메시지로 사용합니다.sqlite3_result_error () 및 sqlite3_result_error16 () 루틴은 오류 메시지 텍스트가 리턴되기 전에 개인용 사본을 작성합니다. 따라서 호출 기능은 텍스트가 해를 끼치 지 않고 반환 된 후에 텍스트를 할당 해제하거나 수정할 수 있습니다. sqlite3_result_error_code () 함수는 함수 오류의 결과로 SQLite가 리턴 한 오류 코드를 변경합니다. 기본적으로 오류 코드는 SQLITE_ERROR입니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="29f28f42596987edc9ab24a265ebb7acbdeb19a7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error () 및 sqlite3_result_error16 () 함수는 구현 된 SQL 함수가 예외를 발생 시키도록합니다. SQLite는 sqlite3_result_error () 또는 sqlite3_result_error16 ()의 두 번째 매개 변수가 가리키는 문자열을 오류 메시지의 텍스트로 사용합니다. SQLite는 sqlite3_result_error ()의 오류 메시지 문자열을 UTF-8로 해석합니다. SQLite는 동일한 사용 UTF-16 sqlite3_result_error16 ()으로부터 문자열 해석 &lt;a href=&quot;#byteorderdeterminationrules&quot;&gt;바이트 순서 결정 규칙&lt;/a&gt; 등 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;) (sqlite3_bind_text16을&lt;/a&gt;. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수이면 SQLite는 첫 번째 0 문자까지 모든 텍스트를 오류 메시지로 간주합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수가 아닌 경우 SQLite는 두 번째 매개 변수에서 오류 메시지로 많은 바이트 (문자가 아님)를 가져옵니다. sqlite3_result_error () 및 sqlite3_result_error16 () 루틴은 반환되기 전에 오류 메시지 텍스트의 개인 복사본을 만듭니다. 따라서 호출 함수는 텍스트가 손상없이 반환 된 후 할당을 취소하거나 수정할 수 있습니다. sqlite3_result_error_code () 함수는 함수 오류의 결과로 SQLite가 반환하는 오류 코드를 변경합니다. 기본적으로 오류 코드는 SQLITE_ERROR입니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="c5a0bd3f253d68fda2502decfe5e0f0d13527f91" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error() and sqlite3_result_error16() functions cause the implemented SQL function to throw an exception. SQLite uses the string pointed to by the 2nd parameter of sqlite3_result_error() or sqlite3_result_error16() as the text of an error message. SQLite interprets the error message string from sqlite3_result_error() as UTF-8. SQLite interprets the string from sqlite3_result_error16() as UTF-16 using the same &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;byte-order determination rules&lt;/a&gt; as &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_text16()&lt;/a&gt;. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is negative then SQLite takes as the error message all text up through the first zero character. If the third parameter to sqlite3_result_error() or sqlite3_result_error16() is non-negative then SQLite takes that many bytes (not characters) from the 2nd parameter as the error message. The sqlite3_result_error() and sqlite3_result_error16() routines make a private copy of the error message text before they return. Hence, the calling function can deallocate or modify the text after they return without harm. The sqlite3_result_error_code() function changes the error code returned by SQLite as a result of an error in a function. By default, the error code is SQLITE_ERROR. A subsequent call to sqlite3_result_error() or sqlite3_result_error16() resets the error code to SQLITE_ERROR.</source>
          <target state="translated">sqlite3_result_error () 및 sqlite3_result_error16 () 함수는 구현 된 SQL 함수가 예외를 발생 시키도록합니다. SQLite는 sqlite3_result_error () 또는 sqlite3_result_error16 ()의 두 번째 매개 변수가 가리키는 문자열을 오류 메시지의 텍스트로 사용합니다. SQLite는 sqlite3_result_error ()의 오류 메시지 문자열을 UTF-8로 해석합니다. SQLite는 동일한 사용 UTF-16 sqlite3_result_error16 ()으로부터 문자열 해석 &lt;a href=&quot;bind_blob#byteorderdeterminationrules&quot;&gt;바이트 순서 결정 규칙&lt;/a&gt; 등 &lt;a href=&quot;bind_blob&quot;&gt;) (sqlite3_bind_text16을&lt;/a&gt;. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수이면 SQLite는 첫 번째 0 문자까지 모든 텍스트를 오류 메시지로 간주합니다. sqlite3_result_error () 또는 sqlite3_result_error16 ()의 세 번째 매개 변수가 음수가 아닌 경우 SQLite는 두 번째 매개 변수에서 오류 메시지로 많은 바이트 (문자가 아님)를 가져옵니다. sqlite3_result_error () 및 sqlite3_result_error16 () 루틴은 반환되기 전에 오류 메시지 텍스트의 개인 복사본을 만듭니다. 따라서 호출 함수는 텍스트가 손상없이 반환 된 후 할당을 취소하거나 수정할 수 있습니다. sqlite3_result_error_code () 함수는 함수 오류의 결과로 SQLite가 반환하는 오류 코드를 변경합니다. 기본적으로 오류 코드는 SQLITE_ERROR입니다.sqlite3_result_error () 또는 sqlite3_result_error16 ()에 대한 후속 호출은 오류 코드를 SQLITE_ERROR로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="9161e1bf262f2df329446fa1f6bc65f20e7794e5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_nomem() interface causes SQLite to throw an error indicating that a memory allocation failed.</source>
          <target state="translated">sqlite3_result_error_nomem () 인터페이스는 SQLite가 메모리 할당 실패를 나타내는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9e5d46d0dedea736182a8b4b5fc9e97d872ed801" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_error_toobig() interface causes SQLite to throw an error indicating that a string or BLOB is too long to represent.</source>
          <target state="translated">sqlite3_result_error_toobig () 인터페이스는 SQLite가 문자열 또는 BLOB가 표현하기에 너무 길다는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f6cfb870f85ac1c6d72052f09d1c9de9769820e3" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_int() interface sets the return value of the application-defined function to be the 32-bit signed integer value given in the 2nd argument. The sqlite3_result_int64() interface sets the return value of the application-defined function to be the 64-bit signed integer value given in the 2nd argument.</source>
          <target state="translated">sqlite3_result_int () 인터페이스는 응용 프로그램 정의 함수의 반환 값을 두 번째 인수에 지정된 32 비트 부호있는 정수 값으로 설정합니다. sqlite3_result_int64 () 인터페이스는 응용 프로그램 정의 함수의 반환 값을 두 번째 인수에 지정된 64 비트 부호있는 정수 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6279fe7ee925bdc0e3f640e0b50cfa7f6bf20e52" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_null() interface sets the return value of the application-defined function to be NULL.</source>
          <target state="translated">sqlite3_result_null () 인터페이스는 응용 프로그램 정의 함수의 반환 값을 NULL로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="16d6bb7320a3240a335aa7ac5ed9b9a1d6945bef" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 와 마찬가지로 결과를 SQL NULL 값으로 설정합니다. 단 , 호스트 언어 포인터 P 또는 유형 T도 NULL 값과 연관되어 포인터가됩니다. &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아닌 경우 P 매개 변수의 소멸자에 대한 포인터입니다. SQLite가 P로 끝났을 때 SQLite는 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이어야합니다. sqlite3_result_pointer () 루틴은 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 SQLite 3.20.0에 추가 된 .</target>
        </trans-unit>
        <trans-unit id="2141ed898fc1d1e35a1c686aae779faa61d104a5" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 과 마찬가지로 결과를 SQL NULL 값으로 설정 하지만 호스트 언어 포인터 P 또는 유형 T를 해당 NULL 값과 연결하여 포인터 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아니면 P 매개 변수에 대한 소멸자를 가리키는 포인터입니다. SQLite는 SQLite가 P로 완료 될 때 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이 바람직합니다. sqlite3_result_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="abeb9a4e536ac73c7793be889cbe18ade4a8329e" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 과 마찬가지로 결과를 SQL NULL 값으로 설정 하지만 호스트 언어 포인터 P 또는 유형 T를 해당 NULL 값과 연결하여 포인터 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아니면 P 매개 변수에 대한 소멸자를 가리키는 포인터입니다. SQLite는 SQLite가 P로 완료 될 때 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이 바람직합니다. sqlite3_result_pointer () 루틴은 SQLite 3.20.0에 추가 된 &lt;a href=&quot;../bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="870667722e41d2c1c37c185e96c88c88778eea77" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_pointer(C,P,T,D) interface sets the result to an SQL NULL value, just like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null(C)&lt;/a&gt;, except that it also associates the host-language pointer P or type T with that NULL value such that the pointer can be retrieved within an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; using &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;. If the D parameter is not NULL, then it is a pointer to a destructor for the P parameter. SQLite invokes D with P as its only argument when SQLite is finished with P. The T parameter should be a static string and preferably a string literal. The sqlite3_result_pointer() routine is part of the &lt;a href=&quot;../bindptr&quot;&gt;pointer passing interface&lt;/a&gt; added for SQLite 3.20.0.</source>
          <target state="translated">sqlite3_result_pointer (C, P, T, D) 인터페이스는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_null (C)&lt;/a&gt; 와 마찬가지로 결과를 SQL NULL 값으로 설정합니다. 단 , 호스트 언어 포인터 P 또는 유형 T도 NULL 값과 연관되어 포인터가됩니다. &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_pointer ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 내에서 검색 할 수 있습니다 . D 매개 변수가 NULL이 아닌 경우 P 매개 변수의 소멸자에 대한 포인터입니다. SQLite가 P로 끝났을 때 SQLite는 유일한 인수로 P를 사용하여 D를 호출합니다. T 매개 변수는 정적 문자열이어야하며 문자열 리터럴이어야합니다. sqlite3_result_pointer () 루틴은 &lt;a href=&quot;../bindptr&quot;&gt;포인터 전달 인터페이스의&lt;/a&gt; 일부입니다 SQLite 3.20.0에 추가 된 .</target>
        </trans-unit>
        <trans-unit id="a4e926904c44e1c10338c3ed629ffd93dee056e2" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype은 (C, T)의 함수의 결과의 아류 발생 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context을&lt;/a&gt; C를 값 T가되게합니다. 버전 T의 하위 8 비트 만 현재 버전의 SQLite에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite에서 유지되는 하위 유형 바이트 수는 이후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b620485a8968d2bc78129bd173a352a06dd552" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype (C, T) 함수는 &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C를 사용 하는 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 결과 하위 유형이 값 T가되도록합니다. 하위 유형 T의 하위 8 비트 만 SQLite의 현재 버전에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite가 보존하는 하위 유형 바이트 수는 향후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b466179681aeddfbf231a03d679d2648006d92dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype (C, T) 함수는 &lt;a href=&quot;#sqlite3_context&quot;&gt;sqlite3_context&lt;/a&gt; C를 사용 하는 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 결과 하위 유형이 값 T가되도록합니다. 하위 유형 T의 하위 8 비트 만 SQLite의 현재 버전에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite가 보존하는 하위 유형 바이트 수는 향후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d462f96f6d4a97e8d351d18ac7f1c494815765c7" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_subtype(C,T) function causes the subtype of the result from the &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; with &lt;a href=&quot;context&quot;&gt;sqlite3_context&lt;/a&gt; C to be the value T. Only the lower 8 bits of the subtype T are preserved in current versions of SQLite; higher order bits are discarded. The number of subtype bytes preserved by SQLite might increase in future releases of SQLite.</source>
          <target state="translated">sqlite3_result_subtype은 (C, T)의 함수의 결과의 아류 발생 &lt;a href=&quot;create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 와 &lt;a href=&quot;context&quot;&gt;sqlite3_context을&lt;/a&gt; C를 값 T가되게합니다. 버전 T의 하위 8 비트 만 현재 버전의 SQLite에서 보존됩니다. 상위 비트는 폐기됩니다. SQLite에서 유지되는 하위 유형 바이트 수는 이후 SQLite 릴리스에서 증가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fc6882e24d42f347f5ab25fb2f2b1c639f2f020" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () 및 sqlite3_result_text16be () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 UTF-8, UTF-16 기본 바이트 순서, UTF-로 표시되는 텍스트 문자열로 설정합니다. 16 리틀 엔디안 또는 UTF-16 빅 엔디안 sqlite3_result_text64 () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 다섯 번째 (마지막) 매개 변수로 지정된 인코딩의 텍스트 문자열로 설정합니다. 이는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 중 하나 여야합니다 또는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite는 sqlite3_result_text * 인터페이스의 두 번째 매개 변수에서 응용 프로그램의 텍스트 결과를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 세 번째 매개 변수가 음수이면 SQLite는 두 번째 매개 변수에서 첫 번째 0 문자를 통해 결과 텍스트를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 3 번째 매개 변수가 음수가 아닌 경우, 2 번째 매개 변수가 가리키는 텍스트의 바이트 수 (문자가 아닌)가 응용 프로그램 정의 함수 결과로 간주됩니다. 세 번째 매개 변수가 음수가 아닌 경우 NUL이 종료 된 문자열 인 경우 NUL 종료자가 표시되는 문자열로의 바이트 오프셋이어야합니다. 3 번째 매개 변수의 값보다 작은 바이트 오프셋에서 문자열에 NUL 문자가 있으면,결과 문자열에는 포함 된 NUL이 포함되며 NUL이 포함 된 문자열에서 작동하는 표현식의 결과는 정의되지 않습니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 널 (NULL)이 아닌 포인터 인 경우 SQLite는 해당 결과의 사용이 완료되면 텍스트 또는 BLOB 결과에서 소멸자로 기능을 호출합니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_STATIC 인 경우 SQLite는 텍스트 또는 BLOB 결과가 일정한 공간에 있다고 가정하고 매개 변수의 컨텐츠를 복사하지 않거나 컨텐츠가있는 경우 컨텐츠에서 소멸자를 호출하지 않습니다. 그 결과 사용을 마쳤습니다.sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_TRANSIENT 인 경우 SQLite는 결과를 공간에서 얻은 공간으로 복사합니다.&lt;a href=&quot;#sqlite3_free&quot;&gt;&lt;/a&gt;반환하기 전에 sqlite3_malloc () .</target>
        </trans-unit>
        <trans-unit id="ffc0515c64350de79930cdbbfae27bfbd23133bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_text(), sqlite3_result_text16(), sqlite3_result_text16le(), and sqlite3_result_text16be() interfaces set the return value of the application-defined function to be a text string which is represented as UTF-8, UTF-16 native byte order, UTF-16 little endian, or UTF-16 big endian, respectively. The sqlite3_result_text64() interface sets the return value of an application-defined function to be a text string in an encoding specified by the fifth (and last) parameter, which must be one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;. SQLite takes the text result from the application from the 2nd parameter of the sqlite3_result_text* interfaces. If the 3rd parameter to the sqlite3_result_text* interfaces is negative, then SQLite takes result text from the 2nd parameter through the first zero character. If the 3rd parameter to the sqlite3_result_text* interfaces is non-negative, then as many bytes (not characters) of the text pointed to by the 2nd parameter are taken as the application-defined function result. If the 3rd parameter is non-negative, then it must be the byte offset into the string where the NUL terminator would appear if the string where NUL terminated. If any NUL characters occur in the string at a byte offset that is less than the value of the 3rd parameter, then the resulting string will contain embedded NULs and the result of expressions operating on strings with embedded NULs is undefined. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is a non-NULL pointer, then SQLite calls that function as the destructor on the text or BLOB result when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or to sqlite3_result_blob is the special constant SQLITE_STATIC, then SQLite assumes that the text or BLOB result is in constant space and does not copy the content of the parameter nor call a destructor on the content when it has finished using that result. If the 4th parameter to the sqlite3_result_text* interfaces or sqlite3_result_blob is the special constant SQLITE_TRANSIENT then SQLite makes a copy of the result into space obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; before it returns.</source>
          <target state="translated">sqlite3_result_text (), sqlite3_result_text16 (), sqlite3_result_text16le () 및 sqlite3_result_text16be () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 UTF-8, UTF-16 기본 바이트 순서, UTF-로 표시되는 텍스트 문자열로 설정합니다. 16 리틀 엔디안 또는 UTF-16 빅 엔디안 sqlite3_result_text64 () 인터페이스는 애플리케이션 정의 함수의 리턴 값을 다섯 번째 (마지막) 매개 변수로 지정된 인코딩의 텍스트 문자열로 설정합니다. 이는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 또는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 중 하나 여야합니다. SQLite는 sqlite3_result_text * 인터페이스의 두 번째 매개 변수에서 응용 프로그램의 텍스트 결과를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 세 번째 매개 변수가 음수이면 SQLite는 두 번째 매개 변수에서 첫 번째 0 문자를 통해 결과 텍스트를 가져옵니다. sqlite3_result_text * 인터페이스에 대한 3 번째 매개 변수가 음수가 아닌 경우, 2 번째 매개 변수가 가리키는 텍스트의 바이트 수 (문자가 아닌)가 응용 프로그램 정의 함수 결과로 간주됩니다. 세 번째 매개 변수가 음수가 아닌 경우 NUL이 종료 된 문자열 인 경우 NUL 종료자가 표시되는 문자열로의 바이트 오프셋이어야합니다. 3 번째 매개 변수의 값보다 작은 바이트 오프셋에서 문자열에 NUL 문자가 있으면,결과 문자열에는 포함 된 NUL이 포함되며 NUL이 포함 된 문자열에서 작동하는 표현식의 결과는 정의되지 않습니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 널 (NULL)이 아닌 포인터 인 경우 SQLite는 해당 결과의 사용이 완료되면 텍스트 또는 BLOB 결과에서 소멸자로 기능을 호출합니다. sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_STATIC 인 경우 SQLite는 텍스트 또는 BLOB 결과가 일정한 공간에 있다고 가정하고 매개 변수의 컨텐츠를 복사하지 않거나 컨텐츠가있는 경우 컨텐츠에서 소멸자를 호출하지 않습니다. 그 결과 사용을 마쳤습니다.sqlite3_result_text * 인터페이스 또는 sqlite3_result_blob에 대한 네 번째 매개 변수가 특수 상수 SQLITE_TRANSIENT 인 경우 SQLite는 결과를 공간에서 얻은 공간으로 복사합니다.&lt;a href=&quot;free&quot;&gt;&lt;/a&gt;반환하기 전에 sqlite3_malloc () .</target>
        </trans-unit>
        <trans-unit id="66d19148a84e04f07a639f83744f212454fd9d54" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value () 인터페이스는 응용 프로그램 정의 함수의 결과를 2 차 매개 변수로 지정된 &lt;a href=&quot;#sqlite3_value&quot;&gt;비보호 sqlite3_value&lt;/a&gt; 오브젝트 의 사본으로 설정합니다 . sqlite3_result_value () 인터페이스는 사본하게 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value을&lt;/a&gt; 있도록 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 매개 변수에 지정된 변경하거나 피해없이 sqlite3_result_value ()의 복귀 후 해제 될 수있다. &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 객체는 항상 어디에 사용할 수 있습니다 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체가 필요합니다, 그래서 두 가지 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 목적이 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c611bb0b94d5204b93fd73ea02598841b3b449f" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_value() interface sets the result of the application-defined function to be a copy of the &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object specified by the 2nd parameter. The sqlite3_result_value() interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; so that the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; specified in the parameter may change or be deallocated after sqlite3_result_value() returns without harm. A &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object may always be used where an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; object is required, so either kind of &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object can be used with this interface.</source>
          <target state="translated">sqlite3_result_value () 인터페이스는 응용 프로그램 정의 함수의 결과를 2 차 매개 변수로 지정된 &lt;a href=&quot;value&quot;&gt;비보호 sqlite3_value&lt;/a&gt; 오브젝트 의 사본으로 설정합니다 . sqlite3_result_value () 인터페이스는 사본하게 &lt;a href=&quot;value&quot;&gt;sqlite3_value을&lt;/a&gt; 있도록 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 매개 변수에 지정된 변경하거나 피해없이 sqlite3_result_value ()의 복귀 후 해제 될 수있다. &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 객체는 항상 어디에 사용할 수 있습니다 &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 객체가 필요합니다, 그래서 두 가지 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 목적이 인터페이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b2bde2ed5663531d681bf21defe3755de5aa926" translate="yes" xml:space="preserve">
          <source>The sqlite3_result_zeroblob(C,N) and sqlite3_result_zeroblob64(C,N) interfaces set the result of the application-defined function to be a BLOB containing all zero bytes and N bytes in size.</source>
          <target state="translated">sqlite3_result_zeroblob (C, N) 및 sqlite3_result_zeroblob64 (C, N) 인터페이스는 애플리케이션 정의 함수의 결과를 0 바이트 및 N 바이트 크기를 모두 포함하는 BLOB로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="38bbbf7ab9a0945b32615ce5c77fecc3dda2b8bb" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_geometry structure that the first argument to the xGeom callback points to has a structure shown below. The exact same sqlite3_rtree_geometry structure is used for every callback for same MATCH operator in the same query. The contents of the sqlite3_rtree_geometry structure are initialized by SQLite but are not subsequently modified. The callback is free to make changes to the pUser and xDelUser elements of the structure if desired.</source>
          <target state="translated">xGeom 콜백에 대한 첫 번째 인수가 가리키는 sqlite3_rtree_geometry 구조는 다음과 같은 구조를 갖습니다. 동일한 쿼리에서 동일한 MATCH 연산자에 대한 모든 콜백에 정확히 동일한 sqlite3_rtree_geometry 구조가 사용됩니다. sqlite3_rtree_geometry 구조의 내용은 SQLite에 의해 초기화되지만 나중에 수정되지는 않습니다. 콜백은 원하는 경우 구조의 pUser 및 xDelUser 요소를 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23ca7c4bc54ebb3192ebcd695698caa11c607135" translate="yes" xml:space="preserve">
          <source>The sqlite3_rtree_query_callback() became available with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;version 3.8.5&lt;/a&gt; (2014-06-04) and is the preferred interface. The sqlite3_rtree_geometry_callback() is an older and less flexible interface that is supported for backwards compatibility.</source>
          <target state="translated">sqlite3_rtree_query_callback ()은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_5.html&quot;&gt;버전 3.8.5&lt;/a&gt; (2014-06-04)에서 사용 가능해 졌으며 선호되는 인터페이스입니다. sqlite3_rtree_geometry_callback ()은 이전 버전과의 호환성을 위해 지원되는 오래되고 덜 유연한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="a4141688a761802a4dde7063e989412b5ba08576" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize (D, S, P, F) 인터페이스는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 S 데이터베이스의 직렬화 인 메모리에 대한 포인터를 리턴 합니다 . P가 NULL 포인터가 아닌 경우 데이터베이스 의 크기 (바이트)는 *에 기록됩니다. 피.</target>
        </trans-unit>
        <trans-unit id="fd8828a508df0b7bef3d1d62a2ae33a5520d58f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory that is a serialization of the S database on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D. If P is not a NULL pointer, then the size of the database in bytes is written into *P.</source>
          <target state="translated">sqlite3_serialize (D, S, P, F) 인터페이스는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에서 S 데이터베이스의 직렬화 인 메모리에 대한 포인터를 리턴 합니다 . P가 NULL 포인터가 아닌 경우 데이터베이스 의 크기 (바이트)는 *에 기록됩니다. 피.</target>
        </trans-unit>
        <trans-unit id="d9311ad5ed8e88f0e0e396fbe1a059c5d4e870f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_auxdata(C,N,P,X) interface saves P as metadata for the N-th argument of the application-defined function. Subsequent calls to sqlite3_get_auxdata(C,N) return P from the most recent sqlite3_set_auxdata(C,N,P,X) call if the metadata is still valid or NULL if the metadata has been discarded. After each call to sqlite3_set_auxdata(C,N,P,X) where X is not NULL, SQLite will invoke the destructor function X with parameter P exactly once, when the metadata is discarded. SQLite is free to discard the metadata at any time, including:</source>
          <target state="translated">sqlite3_set_auxdata (C, N, P, X) 인터페이스는 P를 응용 프로그램 정의 함수의 N 번째 인수에 대한 메타 데이터로 저장합니다. sqlite3_get_auxdata (C, N)에 대한 후속 호출은 메타 데이터가 여전히 유효한 경우 가장 최근의 sqlite3_set_auxdata (C, N, P, X) 호출에서 P를 반환하고 메타 데이터가 삭제 된 경우 NULL입니다. X가 NULL이 아닌 sqlite3_set_auxdata (C, N, P, X)를 호출 할 때마다 SQLite는 메타 데이터가 삭제 될 때 매개 변수 P를 사용하여 소멸자 함수 X를 정확히 한 번만 호출합니다. SQLite는 다음을 포함하여 언제든지 메타 데이터를 자유롭게 버립니다.</target>
        </trans-unit>
        <trans-unit id="ce7e4094de25df6c5d0672255fe4f34354822777" translate="yes" xml:space="preserve">
          <source>The sqlite3_set_last_insert_rowid(D, R) method allows the application to set the value returned by calling sqlite3_last_insert_rowid(D) to R without inserting a row into the database.</source>
          <target state="translated">sqlite3_set_last_insert_rowid (D, R) 메소드를 사용하면 데이터베이스에 행을 삽입하지 않고 sqlite3_last_insert_rowid (D)를 R로 호출하여 리턴 된 값을 애플리케이션이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bb92256471e00d9337dbe91acedaceec62010e" translate="yes" xml:space="preserve">
          <source>The sqlite3_sleep() function causes the current thread to suspend execution for at least a number of milliseconds specified in its parameter.</source>
          <target state="translated">sqlite3_sleep () 함수는 현재 스레드가 해당 매개 변수에 지정된 수 밀리 초 동안 실행을 일시 중단시킵니다.</target>
        </trans-unit>
        <trans-unit id="932dc970d1649bf3cbe1cd6e521c5a774af59735" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot object records state information about an historical version of the database file so that it is possible to later open a new read transaction that sees that historical version of the database rather than the most recent version.</source>
          <target state="translated">sqlite3_snapshot 오브젝트는 데이터베이스 파일의 히스토리 버전에 대한 상태 정보를 기록하므로 나중에 최신 버전이 아닌 해당 히스토리 버전의 데이터베이스를 보는 새 읽기 트랜잭션을 나중에 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242ec5992913a3f34748a4cb2f4099b50b723004" translate="yes" xml:space="preserve">
          <source>The sqlite3_snapshot_cmp(P1, P2) interface is used to compare the ages of two valid snapshot handles.</source>
          <target state="translated">sqlite3_snapshot_cmp (P1, P2) 인터페이스는 두 개의 유효한 스냅 샷 핸들의 수명을 비교하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="01e7a2ddf509d560437f8041b7f083cd66113cd5" translate="yes" xml:space="preserve">
          <source>The sqlite3_snprintf() routine is similar to &quot;snprintf()&quot; from the standard C library. The result is written into the buffer supplied as the second parameter whose size is given by the first parameter. Note that the order of the first two parameters is reversed from snprintf(). This is an historical accident that cannot be fixed without breaking backwards compatibility. Note also that sqlite3_snprintf() returns a pointer to its buffer instead of the number of characters actually written into the buffer. We admit that the number of characters written would be a more useful return value but we cannot change the implementation of sqlite3_snprintf() now without breaking compatibility.</source>
          <target state="translated">sqlite3_snprintf () 루틴은 표준 C 라이브러리의 &quot;snprintf ()&quot;와 유사합니다. 결과는 첫 번째 매개 변수에 의해 크기가 주어진 두 번째 매개 변수로 제공된 버퍼에 기록됩니다. 처음 두 매개 변수의 순서는 snprintf ()와 반대입니다. 이는 이전 버전과의 호환성을 유지하지 않으면 해결할 수없는 역사적 사고입니다. sqlite3_snprintf ()는 실제로 버퍼에 쓴 문자 수 대신 버퍼에 대한 포인터를 반환합니다. 우리는 쓰여진 문자의 수가 더 유용한 반환 값일 것이라는 점을 인정하지만 호환성을 유지하지 않으면 서 sqlite3_snprintf ()의 구현을 지금 변경할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="a1e7c63d0192b11455ed615eabf6f8b339d7c44c" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64 () 인터페이스는 SQLite에 의해 할당 될 수있는 힙 메모리의 양에 대한 소프트 한계를 설정 및 / 또는 쿼리합니다. SQLite는 힙 메모리 사용량이 한계에 도달함에 따라 페이지 캐시에 보유 된 페이지 수를 줄임으로써 힙 메모리 사용량을 소프트 힙 한계 아래로 유지하려고 노력합니다. 소프트 힙 한계는 &quot;소프트&quot;입니다. 왜냐하면 SQLite가 한계 아래로 유지하려고 노력하더라도 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 오류를 생성하는 것이 아니라 한계를 초과합니다 . 다시 말해 소프트 힙 제한은 권고에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="d5aefe7f58cf6098f950ef6aaad46d0524e32f68" translate="yes" xml:space="preserve">
          <source>The sqlite3_soft_heap_limit64() interface sets and/or queries the soft limit on the amount of heap memory that may be allocated by SQLite. SQLite strives to keep heap memory utilization below the soft heap limit by reducing the number of pages held in the page cache as heap memory usages approaches the limit. The soft heap limit is &quot;soft&quot; because even though SQLite strives to stay below the limit, it will exceed the limit rather than generate an &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; error. In other words, the soft heap limit is advisory only.</source>
          <target state="translated">sqlite3_soft_heap_limit64 () 인터페이스는 SQLite에 의해 할당 될 수있는 힙 메모리의 양에 대한 소프트 한계를 설정 및 / 또는 쿼리합니다. SQLite는 힙 메모리 사용량이 한계에 도달함에 따라 페이지 캐시에 보유 된 페이지 수를 줄임으로써 힙 메모리 사용량을 소프트 힙 한계 아래로 유지하려고 노력합니다. 소프트 힙 한계는 &quot;소프트&quot;입니다. 왜냐하면 SQLite가 한계 아래로 유지하려고 노력하더라도 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 오류를 생성하는 것이 아니라 한계를 초과합니다 . 다시 말해 소프트 힙 제한은 권고에 불과합니다.</target>
        </trans-unit>
        <trans-unit id="b94ad72c9e1e61f387a8b9571668f6ee1d93f6d1" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">sqlite3_sql (P) 인터페이스는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()에&lt;/a&gt; 의해 P가 작성된 경우 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 를 작성하는 데 사용 된 UTF-8 SQL 텍스트의 사본에 대한 포인터를 리턴합니다 . sqlite3_expanded_sql (P) 인터페이스는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수가&lt;/a&gt; 확장 된 준비된 명령문 P의 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다 . sqlite3_normalized_sql (P) 인터페이스는 준비된 명령문 P의 정규화 된 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다. SQL 문을 정규화하는 데 사용되는 시맨틱은 지정되지 않으며 변경 될 수 있습니다. 최소한 리터럴 값은 적절한 자리 표시 자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="45ba0cce80e217739aee37fc8f257b9f4497c286" translate="yes" xml:space="preserve">
          <source>The sqlite3_sql(P) interface returns a pointer to a copy of the UTF-8 SQL text used to create &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; P if P was created by &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;. The sqlite3_expanded_sql(P) interface returns a pointer to a UTF-8 string containing the SQL text of prepared statement P with &lt;a href=&quot;../lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; expanded. The sqlite3_normalized_sql(P) interface returns a pointer to a UTF-8 string containing the normalized SQL text of prepared statement P. The semantics used to normalize a SQL statement are unspecified and subject to change. At a minimum, literal values will be replaced with suitable placeholders.</source>
          <target state="translated">sqlite3_sql (P) 인터페이스는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()에&lt;/a&gt; 의해 P가 작성된 경우 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; P 를 작성하는 데 사용 된 UTF-8 SQL 텍스트의 사본에 대한 포인터를 리턴합니다 . sqlite3_expanded_sql (P) 인터페이스는 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;바운드 매개 변수가&lt;/a&gt; 확장 된 준비된 명령문 P의 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다 . sqlite3_normalized_sql (P) 인터페이스는 준비된 명령문 P의 정규화 된 SQL 텍스트를 포함하는 UTF-8 문자열에 대한 포인터를 리턴합니다. SQL 문을 정규화하는 데 사용되는 시맨틱은 지정되지 않으며 변경 될 수 있습니다. 최소한 리터럴 값은 적절한 자리 표시 자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="e775091a2d75ef8eec628ca58240bb3a4c44f41a" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status () 및 sqlite3_status64 () 루틴은 성공하면 SQLITE_OK를, 실패 하면 0이 아닌 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="08017cba5dea56fb38bd261f36812b68e5da595b" translate="yes" xml:space="preserve">
          <source>The sqlite3_status() and sqlite3_status64() routines return SQLITE_OK on success and a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; on failure.</source>
          <target state="translated">sqlite3_status () 및 sqlite3_status64 () 루틴은 성공하면 SQLITE_OK를, 실패 하면 0이 아닌 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="8844a5c0b1eb32242054752c1e25f36f36feae1a" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() interface returns SQLITE_BUSY if it is unable to commit a change because of a lock</source>
          <target state="translated">sqlite3_step () 인터페이스는 잠금으로 인해 변경을 커밋 할 수없는 경우 SQLITE_BUSY를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="aadfbac7c6cbfe9d27468ec7c9a622af76c3660e" translate="yes" xml:space="preserve">
          <source>The sqlite3_step() routine return SQLITE_ROW if it is returning a single row of the result set, or SQLITE_DONE if execution has completed, either normally or due to an error. It might also return SQLITE_BUSY if it is unable to open the database file. If the return value is SQLITE_ROW, then the following routines can be used to extract information about that row of the result set:</source>
          <target state="translated">sqlite3_step () 루틴은 결과 세트의 단일 행을 리턴하는 경우 SQLITE_ROW를 리턴하거나 정상적으로 완료되었거나 오류로 인해 실행이 완료된 경우 SQLITE_DONE을 리턴합니다. 데이터베이스 파일을 열 수 없으면 SQLITE_BUSY를 리턴 할 수도 있습니다. 리턴 값이 SQLITE_ROW 인 경우 다음 루틴을 사용하여 결과 세트의 해당 행에 대한 정보를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68ecf4c95ec171ac99c79d0f7b7218a0a2a7996e" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">sqlite3_stmt_busy은 (S) 인터페이스 true를 반환 (비 제로)이 경우 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; S가 사용되면 적어도 강화 된 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)을&lt;/a&gt; 하지만, 어느 쪽도 (반환 완료 될 때까지 실행하지 않았다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; 에서 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 사용하여 재설정)도 있었다 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset을 ( S)&lt;/a&gt; . S가 NULL 포인터 인 경우 sqlite3_stmt_busy (S) 인터페이스는 false를 반환합니다. S가 NULL 포인터가 아니고 유효한 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트에 대한 포인터가 아닌 경우 , 동작은 정의되지 않았으며 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30e9a2351b8f1f389c8c1f5ed3bb5643292d6719" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_busy(S) interface returns true (non-zero) if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; S has been stepped at least once using &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt; but has neither run to completion (returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; from &lt;a href=&quot;step&quot;&gt;sqlite3_step(S)&lt;/a&gt;) nor been reset using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset(S)&lt;/a&gt;. The sqlite3_stmt_busy(S) interface returns false if S is a NULL pointer. If S is not a NULL pointer and is not a pointer to a valid &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; object, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">sqlite3_stmt_busy은 (S) 인터페이스 true를 반환 (비 제로)이 경우 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; S가 사용되면 적어도 강화 된 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)을&lt;/a&gt; 하지만, 어느 쪽도 (반환 완료 될 때까지 실행하지 않았다 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; 에서 &lt;a href=&quot;step&quot;&gt;sqlite3_step (S)&lt;/a&gt; 사용하여 재설정)도 있었다 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset을 ( S)&lt;/a&gt; . S가 NULL 포인터 인 경우 sqlite3_stmt_busy (S) 인터페이스는 false를 반환합니다. S가 NULL 포인터가 아니고 유효한 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트에 대한 포인터가 아닌 경우 , 동작은 정의되지 않았으며 바람직하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90793b88a180a777be3c4f2d53caba9bba6af112" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_isexplain(S) interface returns 1 if the prepared statement S is an EXPLAIN statement, or 2 if the statement S is an EXPLAIN QUERY PLAN. The sqlite3_stmt_isexplain(S) interface returns 0 if S is an ordinary statement or a NULL pointer.</source>
          <target state="translated">sqlite3_stmt_isexplain (S) 인터페이스는 준비된 명령문 S가 EXPLAIN 문인 경우 1을 리턴하고 명령문 S가 EXPLAIN QUERY PLAN 인 경우 2를 리턴합니다. S가 일반 명령문이거나 NULL 포인터 인 경우 sqlite3_stmt_isexplain (S) 인터페이스는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="959c0941832b79e09f96d36c140b66399c0579af" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly (X) 인터페이스는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; X가 데이터베이스 파일의 내용을 직접 변경하지 않는 경우에만 true (0이 아님)를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ac5964bf97c9886f6e336072767ae1979506a3cb" translate="yes" xml:space="preserve">
          <source>The sqlite3_stmt_readonly(X) interface returns true (non-zero) if and only if the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; X makes no direct changes to the content of the database file.</source>
          <target state="translated">sqlite3_stmt_readonly (X) 인터페이스는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; X가 데이터베이스 파일의 내용을 직접 변경하지 않는 경우에만 true (0이 아님)를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="46d5fb0793437180a07e66953d44f2fda8b50c88" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str 객체는 &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()를&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="58bd138876e3ab72759402d62d6773f8d1b76c11" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is created using &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_str 객체는 &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()를&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="709d2526ae98679c1dec5db36348e5bd59a7a2cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str 오브젝트가 삭제되고 작성된 문자열이 &lt;a href=&quot;#sqlite3_str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; 인터페이스를 사용하여 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="17671bb4cfc45e29421b502c0583cd6458abaa8b" translate="yes" xml:space="preserve">
          <source>The sqlite3_str object is destroyed and the string it created is returned using the &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish()&lt;/a&gt; interface.</source>
          <target state="translated">sqlite3_str 오브젝트가 삭제되고 작성된 문자열이 &lt;a href=&quot;str_finish&quot;&gt;sqlite3_str_finish ()&lt;/a&gt; 인터페이스를 사용하여 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="9c1806bb938001e1be73835ffc5a99f71985fc2b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에서 테이블 T의 열 C에 대한 정보를 리턴합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 리턴하고 NULL이 아닌 포인터를 채 웁니다. 지정된 열이 존재하면 적절한 값을 가진 마지막 다섯 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이 없으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우,이 루틴은 단순히 테이블의 존재를 점검하고 테이블이 존재하면 SQLITE_OK를, 그렇지 않으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata (X, D, T, C, ...)에 대한 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1a9220a600a9fb3a4c23d26f17dc0f839445989b" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에있는 테이블 T의 열 C에 대한 정보를 반환합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 반환하고 NULL이 아닌 포인터를 지정된 열이있는 경우 적절한 값을 가진 마지막 5 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이없는 경우 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우이 루틴은 단순히 테이블의 존재를 확인하고 테이블이 존재하면 SQLITE_OK를 반환하고 그렇지 않으면 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata (X, D, T, C, ...) 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="14811f3f6309b7a46fb7b07e8c86e4e522dd9f2d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR and if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에서 테이블 T의 열 C에 대한 정보를 리턴합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 리턴하고 NULL이 아닌 포인터를 채 웁니다. 지정된 열이 존재하면 적절한 값을 가진 마지막 다섯 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이 없으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우,이 루틴은 단순히 테이블의 존재를 점검하고 테이블이 존재하면 SQLITE_OK를, 그렇지 않으면 SQLITE_ERROR를 리턴합니다. sqlite3_table_column_metadata (X, D, T, C, ...)에 대한 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1c11863e106d03a5d69e9f5e41b5782d50d0ba8d" translate="yes" xml:space="preserve">
          <source>The sqlite3_table_column_metadata(X,D,T,C,....) routine returns information about column C of table T in database D on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; X. The sqlite3_table_column_metadata() interface returns SQLITE_OK and fills in the non-NULL pointers in the final five arguments with appropriate values if the specified column exists. The sqlite3_table_column_metadata() interface returns SQLITE_ERROR if the specified column does not exist. If the column-name parameter to sqlite3_table_column_metadata() is a NULL pointer, then this routine simply checks for the existence of the table and returns SQLITE_OK if the table exists and SQLITE_ERROR if it does not. If the table name parameter T in a call to sqlite3_table_column_metadata(X,D,T,C,...) is NULL then the result is undefined behavior.</source>
          <target state="translated">sqlite3_table_column_metadata (X, D, T, C, ....) 루틴은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; X의 데이터베이스 D에있는 테이블 T의 열 C에 대한 정보를 반환합니다 . sqlite3_table_column_metadata () 인터페이스는 SQLITE_OK를 반환하고 NULL이 아닌 포인터를 지정된 열이있는 경우 적절한 값을 가진 마지막 5 개의 인수. sqlite3_table_column_metadata () 인터페이스는 지정된 열이없는 경우 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata ()에 대한 column-name 매개 변수가 NULL 포인터 인 경우이 루틴은 단순히 테이블의 존재를 확인하고 테이블이 존재하면 SQLITE_OK를 반환하고 그렇지 않으면 SQLITE_ERROR를 반환합니다. sqlite3_table_column_metadata (X, D, T, C, ...) 호출에서 테이블 이름 매개 변수 T가 NULL이면 결과는 정의되지 않은 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b6f71c56bc991c72ab07825bab1be2b2926a3b41" translate="yes" xml:space="preserve">
          <source>The sqlite3_test_control() interface is used to read out internal state of SQLite and to inject faults into SQLite for testing purposes. The first parameter is an operation code that determines the number, meaning, and operation of all subsequent parameters.</source>
          <target state="translated">sqlite3_test_control () 인터페이스는 SQLite의 내부 상태를 읽고 테스트 목적으로 SQLite에 결함을 주입하는 데 사용됩니다. 첫 번째 매개 변수는 모든 후속 매개 변수의 수, 의미 및 작업을 결정하는 작업 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5082c0760e0921243970779b3672c52191342376" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe () 함수는 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 컴파일 타임 옵션이 0으로 설정되어 mutexing 코드가 생략 된 상태에서 SQLite가 컴파일 된 경우에만 0을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a21f6ed50c99e2696e83c890474c76bf238b4d0d" translate="yes" xml:space="preserve">
          <source>The sqlite3_threadsafe() function returns zero if and only if SQLite was compiled with mutexing code omitted due to the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time option being set to 0.</source>
          <target state="translated">sqlite3_threadsafe () 함수는 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 컴파일 타임 옵션이 0으로 설정되어 mutexing 코드가 생략 된 상태에서 SQLite가 컴파일 된 경우에만 0을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="bda43267162a3774849f8ead3ae62d9dfab76a35" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace() callbacks occur before each statement is executed, not when the statement is compiled.</source>
          <target state="translated">sqlite3_trace () 콜백은 명령문이 컴파일 될 때가 아니라 각 명령문이 실행되기 전에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1ffc76f2d02a8dff2313298df0260161ca209b9b" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2 () 인터페이스는 더 이상 사용되지 않는 레거시 인터페이스 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 을 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="377ad2a0a4bd528d9de5514af64376270faee9cf" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2() interface is intended to replace the legacy interfaces &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt;, both of which are deprecated.</source>
          <target state="translated">sqlite3_trace_v2 () 인터페이스는 더 이상 사용되지 않는 레거시 인터페이스 &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 및 &lt;a href=&quot;profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 을 대체하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="423d6e23fa8d1a2ce23d8999f3685bde80941a45" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2 (D, M, X, P) 인터페이스는 특성 마스크 M 및 컨텍스트 포인터 P를 사용하여 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에 대해 추적 콜백 함수 X 를 등록합니다. X 콜백이 NULL이거나 M 마스크가 0이면 추적이 사용 불가능합니다. . M 인수는 0 개 이상의 &lt;a href=&quot;#SQLITE_TRACE&quot;&gt;SQLITE_TRACE&lt;/a&gt; 상수 의 비트 단위 OR 조합 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c43af05001b13bd414732905f7825bbbb97dce0a" translate="yes" xml:space="preserve">
          <source>The sqlite3_trace_v2(D,M,X,P) interface registers a trace callback function X against &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, using property mask M and context pointer P. If the X callback is NULL or if the M mask is zero, then tracing is disabled. The M argument should be the bitwise OR-ed combination of zero or more &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; constants.</source>
          <target state="translated">sqlite3_trace_v2 (D, M, X, P) 인터페이스는 특성 마스크 M 및 컨텍스트 포인터 P를 사용하여 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 에 대해 추적 콜백 함수 X 를 등록합니다. X 콜백이 NULL이거나 M 마스크가 0이면 추적이 사용 불가능합니다. . M 인수는 0 개 이상의 &lt;a href=&quot;c_trace&quot;&gt;SQLITE_TRACE&lt;/a&gt; 상수 의 비트 단위 OR 조합 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="99807c4e04d2f72ca0bf7cd79e0b0ccb8d1cdec6" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook () 인터페이스 는 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서 행이 업데이트, 삽입 또는 삭제 될 때마다 호출 될 첫 번째 인수로 식별 된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 콜백 함수를 등록 합니다 . 동일한 데이터베이스 연결에 대해이 함수에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f13c4b8c3d5b462597549f85fa26ca8898f02c2a" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook() interface registers a callback function with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; identified by the first argument to be invoked whenever a row is updated, inserted or deleted in a &lt;a href=&quot;../rowidtable&quot;&gt;rowid table&lt;/a&gt;. Any callback set by a previous call to this function for the same database connection is overridden.</source>
          <target state="translated">sqlite3_update_hook () 인터페이스 는 &lt;a href=&quot;../rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서 행이 업데이트, 삽입 또는 삭제 될 때마다 호출 될 첫 번째 인수로 식별 된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 콜백 함수를 등록 합니다 . 동일한 데이터베이스 연결에 대해이 함수에 대한 이전 호출로 설정된 모든 콜백이 재정의됩니다.</target>
        </trans-unit>
        <trans-unit id="299c5d8dbf8312233913ebdfb7abe735c08c4d12" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook (D, C, P) 함수는 동일한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 이전 호출에서 P 인수를 리턴 하거나 D의 첫 번째 호출에 대해서는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b7813b4170b9b916299f8d86a0cb2ffbf096aaa5" translate="yes" xml:space="preserve">
          <source>The sqlite3_update_hook(D,C,P) function returns the P argument from the previous call on the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D, or NULL for the first call on D.</source>
          <target state="translated">sqlite3_update_hook (D, C, P) 함수는 동일한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 이전 호출에서 P 인수를 리턴 하거나 D의 첫 번째 호출에 대해서는 NULL을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9e5c2049439d88f4f1e900d8863f9c93f3ca0ab3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean (F, P, B) 루틴은 P가 부울 매개 변수라고 가정하고 P의 값에 따라 true (1) 또는 false (0)를 리턴합니다. sqlite3_uri_boolean (F, P, B) 루틴은 true (1)를 리턴합니다. 쿼리 매개 변수 P의 값이 &quot;yes&quot;, &quot;true&quot;또는 &quot;on&quot;중 하나 인 경우 또는 값이 0이 아닌 숫자로 시작하는 경우 sqlite3_uri_boolean (F, P, B) 루틴은 쿼리 매개 변수 P의 값이 &quot;no&quot;, &quot;false&quot;또는 &quot;off&quot;중 하나이거나 값이 숫자 0으로 시작하는 경우 false (0)를 반환합니다. P가 F의 쿼리 매개 변수가 아니거나 P의 값이 위와 일치하지 않는 경우 sqlite3_uri_boolean (F, P, B)는 (B! = 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="07d5885fa75b35071ed61bef7a0d72dc8a43c3b7" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_boolean(F,P,B) routine assumes that P is a boolean parameter and returns true (1) or false (0) according to the value of P. The sqlite3_uri_boolean(F,P,B) routine returns true (1) if the value of query parameter P is one of &quot;yes&quot;, &quot;true&quot;, or &quot;on&quot; in any case or if the value begins with a non-zero number. The sqlite3_uri_boolean(F,P,B) routines returns false (0) if the value of query parameter P is one of &quot;no&quot;, &quot;false&quot;, or &quot;off&quot; in any case or if the value begins with a numeric zero. If P is not a query parameter on F or if the value of P is does not match any of the above, then sqlite3_uri_boolean(F,P,B) returns (B!=0).</source>
          <target state="translated">sqlite3_uri_boolean (F, P, B) 루틴은 P가 부울 매개 변수라고 가정하고 P 값에 따라 true (1) 또는 false (0)를 리턴합니다. sqlite3_uri_boolean (F, P, B) 루틴은 true (1)를 리턴합니다. 쿼리 매개 변수 P의 값이 &quot;yes&quot;, &quot;true&quot;또는 &quot;on&quot;중 하나이거나 값이 0이 아닌 숫자로 시작하는 경우 sqlite3_uri_boolean (F, P, B) 루틴은 조회 매개 변수 P의 값이 &quot;no&quot;, &quot;false&quot;또는 &quot;off&quot;중 하나이거나 값이 숫자 0으로 시작하는 경우 false (0)를 리턴합니다. P가 F의 쿼리 매개 변수가 아니거나 P의 값이 위의 값과 일치하지 않으면 sqlite3_uri_boolean (F, P, B)는 (B! = 0)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d8465d3a607ae26cbee19418630adba78c7f16b3" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_int64(F,P,D) routine converts the value of P into a 64-bit signed integer and returns that integer, or D if P does not exist. If the value of P is something other than an integer, then zero is returned.</source>
          <target state="translated">sqlite3_uri_int64 (F, P, D) 루틴은 P의 값을 부호있는 64 비트 정수로 변환하고 해당 정수를 반환하거나 P가 없으면 D를 반환합니다. P의 값이 정수 이외의 값이면 0이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="00f6b921b58342af7827ee6740ce3bd7da1204bf" translate="yes" xml:space="preserve">
          <source>The sqlite3_uri_key(F,N) returns a pointer to the name (not the value) of the N-th query parameter for filename F, or a NULL pointer if N is less than zero or greater than the number of query parameters minus 1. The N value is zero-based so N should be 0 to obtain the name of the first query parameter, 1 for the second parameter, and so forth.</source>
          <target state="translated">sqlite3_uri_key (F, N)는 파일 이름 F에 대한 N 번째 쿼리 매개 변수의 이름 (값이 아님)에 대한 포인터를 반환하거나 N이 0보다 작거나 쿼리 매개 변수 수에서 1을 뺀 값보다 큰 경우 NULL 포인터를 반환합니다. N 값은 0부터 시작하므로 N은 첫 번째 쿼리 매개 변수의 이름을 가져 오려면 0, 두 번째 매개 변수의 경우 1 등이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4924027328fd6dc74b1360ec20381b3f6724812a" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data () 인터페이스는 원래 응용 프로그램 정의 함수를 등록한 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 루틴 의 pUserData 매개 변수 (5 번째 매개 변수) 인 포인터의 사본을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="bf548778e52386bbdaeeb7ac3a4e8320cb6164f6" translate="yes" xml:space="preserve">
          <source>The sqlite3_user_data() interface returns a copy of the pointer that was the pUserData parameter (the 5th parameter) of the &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; routines that originally registered the application defined function.</source>
          <target state="translated">sqlite3_user_data () 인터페이스는 원래 응용 프로그램 정의 함수를 등록한 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 루틴 의 pUserData 매개 변수 (5 번째 매개 변수) 인 포인터의 사본을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="ea63e7ca04dfc54c7a9a4dfd28964eb4fb6446f1" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달 된 sqlite3_value 오브젝트 가 보호됩니다. &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 리턴 된 sqlite3_value 오브젝트 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="878c26369032034cf1577de94a30701d2b72bfbf" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달되는 sqlite3_value 오브젝트 는 보호됩니다. &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 sqlite3_value 객체 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5d8545cde1bbfc4f37da956f6919362a532aef6b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달되는 sqlite3_value 오브젝트 는 보호됩니다. &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 반환 된 sqlite3_value 객체 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d38041b5ccb2d09a369551e816f131ddba2abad9" translate="yes" xml:space="preserve">
          <source>The sqlite3_value objects that are passed as parameters into the implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are protected. The sqlite3_value object returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value()&lt;/a&gt; is unprotected. Unprotected sqlite3_value objects may only be used as arguments to &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value()&lt;/a&gt;, &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value()&lt;/a&gt;, and &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. The &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type()&lt;/a&gt; family of interfaces require protected sqlite3_value objects.</source>
          <target state="translated">&lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 구현에 매개 변수로 전달 된 sqlite3_value 오브젝트 가 보호됩니다. &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_value ()에&lt;/a&gt; 의해 리턴 된 sqlite3_value 오브젝트 는 보호되지 않습니다. 보호되지 않은 sqlite3_value 객체는 &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_value ()&lt;/a&gt; , &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind_value ()&lt;/a&gt; 및 &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()에 대한&lt;/a&gt; 인수로만 사용할 수 있습니다 . &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_type ()&lt;/a&gt; 인터페이스의 가족은 sqlite3_value 개체를 보호 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a0129b60c59e08fad26659c0f3fdb0270cff463d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup (V) 인터페이스는 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 D 의 사본을 작성하고 해당 사본에 대한 포인터를 리턴합니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 반환은이다 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 입력이없는 경우에도 객체입니다. sqlite3_value_dup (V) 인터페이스는 V가 NULL이거나 메모리 할당이 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0aa98b18c314b7d86c75837f6de77eb6d3e0637d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_dup(V) interface makes a copy of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object D and returns a pointer to that copy. The &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; returned is a &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object even if the input is not. The sqlite3_value_dup(V) interface returns NULL if V is NULL or if a memory allocation fails.</source>
          <target state="translated">sqlite3_value_dup (V) 인터페이스는 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 D 의 사본을 작성하고 해당 사본에 대한 포인터를 리턴합니다. &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 반환은이다 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 입력이없는 경우에도 객체입니다. sqlite3_value_dup (V) 인터페이스는 V가 NULL이거나 메모리 할당이 실패하면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0414ddee749e340e753046c8b57c08bdec5a9dc" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free (V) 인터페이스는 &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 에서 이전에 얻은 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 객체를 해제합니다 . V가 NULL 포인터이면 sqlite3_value_free (V)는 무해한 무 작동입니다.</target>
        </trans-unit>
        <trans-unit id="e1cbff52a059b27e36ab50ec612e0a1c2d7433c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_free(V) interface frees an &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object previously obtained from &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt;. If V is a NULL pointer then sqlite3_value_free(V) is a harmless no-op.</source>
          <target state="translated">sqlite3_value_free (V) 인터페이스는 &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 에서 이전에 얻은 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 객체를 해제합니다 . V가 NULL 포인터이면 sqlite3_value_free (V)는 무해한 무 작동입니다.</target>
        </trans-unit>
        <trans-unit id="7d48e35fde2b5031a0a61511df13116d92432d3c" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">값 X가 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 sqlite3_value_frombind (X) 인터페이스는 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값 또는 테이블 열 및 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="80d4668ad9e2d92c3db76ff20be74213c969d9ff" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">sqlite3_value_frombind (X) 인터페이스는 값 X가 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값, 테이블 열 또는 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4099e909bffc50f671788cefdd0e00a496608c5a" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, and expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">값 X가 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 sqlite3_value_frombind (X) 인터페이스는 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값 또는 테이블 열 및 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d098066d168e6b39abb688284c2a26c07f3bcf76" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_frombind(X) interface returns non-zero if the value X originated from one of the &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; interfaces. If X comes from an SQL literal value, or a table column, or an expression, then sqlite3_value_frombind(X) returns zero.</source>
          <target state="translated">sqlite3_value_frombind (X) 인터페이스는 값 X가 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 인터페이스 중 하나에서 시작된 경우 0이 아닌 값을 반환합니다 . X가 SQL 리터럴 값, 테이블 열 또는 표현식에서 오는 경우 sqlite3_value_frombind (X)는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4ba714b8f0c8b8a0a85eade6cc85a5f85674f5b" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type () 인터페이스는 값에 숫자 선호도를 적용하려고 시도합니다. 이는 값을 정수 또는 부동 소수점으로 변환하려고 시도 함을 의미합니다. 정보의 손실없이 이러한 변환이 가능하면 (즉, 값이 숫자처럼 보이는 문자열 인 경우) 변환이 수행됩니다. 그렇지 않으면 변환이 발생하지 않습니다. &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;데이터 형식&lt;/a&gt; 변환 후이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d57e13a61eeb32fc6ccab4def9ab890b09fb83b8" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_numeric_type() interface attempts to apply numeric affinity to the value. This means that an attempt is made to convert the value to an integer or floating point. If such a conversion is possible without loss of information (in other words, if the value is a string that looks like a number) then the conversion is performed. Otherwise no conversion occurs. The &lt;a href=&quot;c_blob&quot;&gt;datatype&lt;/a&gt; after conversion is returned.</source>
          <target state="translated">sqlite3_value_numeric_type () 인터페이스는 값에 숫자 선호도를 적용하려고 시도합니다. 이는 값을 정수 또는 부동 소수점으로 변환하려고 시도 함을 의미합니다. 정보의 손실없이 이러한 변환이 가능하면 (즉, 값이 숫자처럼 보이는 문자열 인 경우) 변환이 수행됩니다. 그렇지 않으면 변환이 발생하지 않습니다. &lt;a href=&quot;c_blob&quot;&gt;데이터 형식&lt;/a&gt; 변환 후이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4ec72e1543814b021a25a90d5cb860b5227da9f5" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 의 서브 타입을 리턴합니다. 인수 V에 대한 서브 타입 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용될 수 있습니다. &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype ()&lt;/a&gt; 루틴을 사용하여 SQL 함수의 리턴 값에 대한 하위 유형을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ac784313e8a1c8814ecb1722aed4c17998bb6a84" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 인수 V에 대한 하위 유형을 리턴합니다. 하위 유형 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용할 수 있습니다. SQL 함수의 리턴 값에 대한 &lt;a href=&quot;result_subtype&quot;&gt;부속&lt;/a&gt; 유형을 설정 하려면 sqlite3_result_subtype () 루틴을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9482d5c89729cab0c852ef903cf3adcd7fd134d" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 인수 V에 대한 하위 유형을 리턴합니다. 하위 유형 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용할 수 있습니다. SQL 함수의 리턴 값에 대한 &lt;a href=&quot;#sqlite3_result_subtype&quot;&gt;부속&lt;/a&gt; 유형을 설정 하려면 sqlite3_result_subtype () 루틴을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff11a55e63d67f21f428483b7880706f081aadf2" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_subtype(V) function returns the subtype for an &lt;a href=&quot;create_function&quot;&gt;application-defined SQL function&lt;/a&gt; argument V. The subtype information can be used to pass a limited amount of context from one SQL function to another. Use the &lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; routine to set the subtype for the return value of an SQL function.</source>
          <target state="translated">sqlite3_value_subtype (V) 함수는 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 인수 V에 대한 서브 타입을 리턴합니다. 서브 타입 정보는 한 SQL 함수에서 다른 SQL 함수로 제한된 양의 컨텍스트를 전달하는 데 사용될 수 있습니다. 사용&lt;a href=&quot;result_subtype&quot;&gt;sqlite3_result_subtype ()&lt;/a&gt; 루틴을 SQL 함수의 리턴 값에 대한 하위 유형을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b0e636524c92f0e1651fb00be6db5e8d57af0255" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_text16() interface extracts a UTF-16 string in the native byte-order of the host machine. The sqlite3_value_text16be() and sqlite3_value_text16le() interfaces extract UTF-16 strings as big-endian and little-endian respectively.</source>
          <target state="translated">sqlite3_value_text16 () 인터페이스는 호스트 시스템의 기본 바이트 순서로 UTF-16 문자열을 추출합니다. sqlite3_value_text16be () 및 sqlite3_value_text16le () 인터페이스는 각각 UTF-16 문자열을 빅 엔디안 및 리틀 엔디안으로 추출합니다.</target>
        </trans-unit>
        <trans-unit id="abd8dcf49d86f46dedd1a279c57c33b107030fa7" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type (V) 인터페이스는 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 V의 초기 데이터 유형에 대한 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;데이터 유형 코드&lt;/a&gt; 를 리턴합니다. 리턴 된 값은 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_BLOB&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_BLOB&quot;&gt;SQLITE_NULL&lt;/a&gt; 중 하나입니다. . 다른 인터페이스는 sqlite3_value 객체의 데이터 유형을 변경할 수 있습니다. 예를 들어, 데이터 유형이 처음에 SQLITE_INTEGER이고 해당 정수에 대한 텍스트 값을 추출하기 위해 sqlite3_value_text (V)가 호출 된 경우 sqlite3_value_type (V)에 대한 후속 호출은 SQLITE_TEXT를 리턴 할 수 있습니다. 지속적 내부 데이터 유형 변환이 발생하는지 여부는 정의되어 있지 않으며 SQLite의 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cdf3c345651dd059fa86a01b992ffdfc67b3546" translate="yes" xml:space="preserve">
          <source>The sqlite3_value_type(V) interface returns the &lt;a href=&quot;c_blob&quot;&gt;datatype code&lt;/a&gt; for the initial datatype of the &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; object V. The returned value is one of &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt;, &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt;, or &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt;. Other interfaces might change the datatype for an sqlite3_value object. For example, if the datatype is initially SQLITE_INTEGER and sqlite3_value_text(V) is called to extract a text value for that integer, then subsequent calls to sqlite3_value_type(V) might return SQLITE_TEXT. Whether or not a persistent internal datatype conversion occurs is undefined and may change from one release of SQLite to the next.</source>
          <target state="translated">sqlite3_value_type (V) 인터페이스는 &lt;a href=&quot;value&quot;&gt;sqlite3_value&lt;/a&gt; 오브젝트 V의 초기 데이터 유형에 대한 &lt;a href=&quot;c_blob&quot;&gt;데이터 유형 코드&lt;/a&gt; 를 리턴합니다. 리턴 된 값은 &lt;a href=&quot;c_blob&quot;&gt;SQLITE_INTEGER&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_FLOAT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_TEXT&lt;/a&gt; , &lt;a href=&quot;c_blob&quot;&gt;SQLITE_BLOB&lt;/a&gt; 또는 &lt;a href=&quot;c_blob&quot;&gt;SQLITE_NULL&lt;/a&gt; 중 하나입니다. . 다른 인터페이스는 sqlite3_value 객체의 데이터 유형을 변경할 수 있습니다. 예를 들어, 데이터 유형이 처음에 SQLITE_INTEGER이고 해당 정수에 대한 텍스트 값을 추출하기 위해 sqlite3_value_text (V)가 호출 된 경우 sqlite3_value_type (V)에 대한 후속 호출은 SQLITE_TEXT를 리턴 할 수 있습니다. 지속적 내부 데이터 유형 변환이 발생하는지 여부는 정의되어 있지 않으며 SQLite의 릴리스마다 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fd8993db96d6be0a53b95ff8fe5c5a06191a2c2" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version [] 문자열 상수에는 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; 매크로 의 텍스트가 포함 됩니다. sqlite3_libversion () 함수는 sqlite3_version [] 문자열 상수에 대한 포인터를 리턴합니다. sqlite3_libversion () 함수는 DLL 사용자가 일반적으로 DLL 내의 문자열 상수에 직접 액세스 할 수 없으므로 DLL에서 사용하기 위해 제공됩니다. sqlite3_libversion_number () 함수는 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER와&lt;/a&gt; 동일한 정수를 리턴합니다 . sqlite3_sourceid () 함수는 값이 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전 처리기 매크로 와 동일한 문자열 상수에 대한 포인터를 리턴합니다 . SQLite가 편집 된 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; 사본을 사용하여 빌드 된 경우를 제외하고 해시의 마지막 네 문자는 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a807d081504ff9864c4a0f322dee10127ba34ee0" translate="yes" xml:space="preserve">
          <source>The sqlite3_version[] string constant contains the text of &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; macro. The sqlite3_libversion() function returns a pointer to the to the sqlite3_version[] string constant. The sqlite3_libversion() function is provided for use in DLLs since DLL users usually do not have direct access to string constants within the DLL. The sqlite3_libversion_number() function returns an integer equal to &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;. The sqlite3_sourceid() function returns a pointer to a string constant whose value is the same as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macro. Except if SQLite is built using an edited copy of &lt;a href=&quot;../amalgamation&quot;&gt;the amalgamation&lt;/a&gt;, then the last four characters of the hash might be different from &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;.</source>
          <target state="translated">sqlite3_version [] 문자열 상수에는 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; 매크로 의 텍스트가 포함 됩니다. sqlite3_libversion () 함수는 sqlite3_version [] 문자열 상수에 대한 포인터를 리턴합니다. sqlite3_libversion () 함수는 DLL 사용자가 일반적으로 DLL 내의 문자열 상수에 직접 액세스 할 수 없으므로 DLL에서 사용하기 위해 제공됩니다. sqlite3_libversion_number () 함수는 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER와&lt;/a&gt; 동일한 정수를 리턴합니다 . sqlite3_sourceid () 함수는 값이 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전 처리기 매크로 와 동일한 문자열 상수에 대한 포인터를 리턴합니다 . SQLite가 편집 된 &lt;a href=&quot;../amalgamation&quot;&gt;amalgamation&lt;/a&gt; 사본을 사용하여 빌드 된 경우를 제외하고 해시의 마지막 네 문자는 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7f0635e95ae6f97edbc2a13b7ebfc89ee7bf9a3" translate="yes" xml:space="preserve">
          <source>The sqlite3_vfs_find() interface returns a pointer to a VFS given its name. Names are case sensitive. Names are zero-terminated UTF-8 strings. If there is no match, a NULL pointer is returned. If zVfsName is NULL then the default VFS is returned.</source>
          <target state="translated">sqlite3_vfs_find () 인터페이스는 이름이 지정된 VFS에 대한 포인터를 반환합니다. 이름은 대소 문자를 구분합니다. 이름은 0으로 끝나는 UTF-8 문자열입니다. 일치하는 것이 없으면 NULL 포인터가 반환됩니다. zVfsName이 NULL이면 기본 VFS가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="88892501427d74185f6b1bff1e11e202173ae158" translate="yes" xml:space="preserve">
          <source>The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().</source>
          <target state="translated">sqlite3_vsnprintf () 루틴은 varlites 버전의 sqlite3_snprintf ()입니다.</target>
        </trans-unit>
        <trans-unit id="bfe11fb394a04090848d426f27d7f821bd426298" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint (D, X)는 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5b2980a50de42ca24a7d3c803dbeadfa7a488ca" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint(D,X) is equivalent to &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt;(D,X,&lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt;,0,0).</source>
          <target state="translated">sqlite3_wal_checkpoint (D, X)는 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2&lt;/a&gt; (D, X, &lt;a href=&quot;c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_PASSIVE&lt;/a&gt; , 0,0)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f281b26d80df2d4297decb3bb5684de63641309" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2 (D, X, M, L, C) 인터페이스는 M 모드에서 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 데이터베이스 X에 대해 체크 포인트 조작을 실행 합니다. 상태 정보는 L 및 C가 가리키는 정수로 다시 기록됩니다. M 매개 변수는 유효해야합니다. &lt;a href=&quot;#SQLITE_CHECKPOINT_FULL&quot;&gt;체크 포인트 모드&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4f16d84b1dffbf24b61871d0a39f458136f5ce78" translate="yes" xml:space="preserve">
          <source>The sqlite3_wal_checkpoint_v2(D,X,M,L,C) interface runs a checkpoint operation on database X of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D in mode M. Status information is written back into integers pointed to by L and C. The M parameter must be a valid &lt;a href=&quot;c_checkpoint_full&quot;&gt;checkpoint mode&lt;/a&gt;:</source>
          <target state="translated">sqlite3_wal_checkpoint_v2 (D, X, M, L, C) 인터페이스는 M 모드에서 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 데이터베이스 X에 대해 체크 포인트 조작을 실행 합니다. 상태 정보는 L 및 C가 가리키는 정수로 다시 기록됩니다. M 매개 변수는 유효해야합니다. &lt;a href=&quot;c_checkpoint_full&quot;&gt;체크 포인트 모드&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="121e4ad510585a0237e3a007626cc2d427159cf6" translate="yes" xml:space="preserve">
          <source>The sqlite3changeset_apply() function automatically converts the zero-length blob back to a NULL value when updating the sqlite_stat1 table. However, if the application calls sqlite3changeset_new(), sqlite3changeset_old() or sqlite3changeset_conflict on a changeset iterator directly (including on a changeset iterator passed to a conflict-handler callback) then the X'' value is returned. The application must translate X'' to NULL itself if required.</source>
          <target state="translated">sqlite3changeset_apply () 함수는 sqlite_stat1 테이블을 업데이트 할 때 길이가 0 인 얼룩을 NULL 값으로 자동 변환합니다. 그러나 애플리케이션이 변경 세트 반복자에서 직접 sqlite3changeset_new (), sqlite3changeset_old () 또는 sqlite3changeset_conflict를 호출하면 (충돌 핸들러 콜백에 전달 된 변경 세트 반복자를 포함하여) X ''값이 리턴됩니다. 필요한 경우 응용 프로그램은 X ''를 NULL로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab7530db4d4c9fc320d8eb6c02294cea75207425" translate="yes" xml:space="preserve">
          <source>The sqlite3rbu_open(T,A,S) function returns a pointer to an &quot;sqlite3rbu&quot; object, which is then passed into the subsequent interfaces.</source>
          <target state="translated">sqlite3rbu_open (T, A, S) 함수는 &quot;sqlite3rbu&quot;오브젝트에 대한 포인터를 리턴 한 후 후속 인터페이스로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc8971708ade277f3f9ba38012f5db2060092ea" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is not threadsafe. If it is invoked while any other thread is inside any other sessions method then the results are undefined. Furthermore, if it is invoked after any sessions related objects have been created, the results are also undefined.</source>
          <target state="translated">sqlite3session_config () 인터페이스는 스레드 세이프가 아닙니다. 다른 스레드가 다른 세션 메소드 내에있는 동안 호출되면 결과가 정의되지 않습니다. 또한 세션 관련 오브젝트가 작성된 후에 호출되면 결과도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ed3502dd7610ba7f06fbfad0a9a6bcb2eec2c983" translate="yes" xml:space="preserve">
          <source>The sqlite3session_config() interface is used to make global configuration changes to the sessions module in order to tune it to the specific needs of the application.</source>
          <target state="translated">sqlite3session_config () 인터페이스는 응용 프로그램의 특정 요구에 맞게 세션 모듈을 전체적으로 구성 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="517ed7f5443765d182eb47f3b8b955f48af65e6e" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_get() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; C/C++ function. This routine returns the N-th compile-time option used to build SQLite or NULL if N is out of range. See also the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">sqlite_compileoption_get () SQL 함수는 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get ()&lt;/a&gt; C / C ++ 함수 주위의 랩퍼 입니다. 이 루틴은 SQLite를 빌드하는 데 사용 된 N 번째 컴파일 타임 옵션을 반환하거나 N이 범위를 벗어난 경우 NULL을 반환합니다. &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="62942f05e5a1956f6b33c8235e025eeea5e49332" translate="yes" xml:space="preserve">
          <source>The sqlite_compileoption_used() SQL function is a wrapper around the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; C/C++ function. When the argument X to sqlite_compileoption_used(X) is a string which is the name of a compile-time option, this routine returns true (1) or false (0) depending on whether or not that option was used during the build.</source>
          <target state="translated">sqlite_compileoption_used () SQL 함수는 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used ()&lt;/a&gt; 주위의 랩퍼입니다. C / C ++ 함수 입니다. sqlite_compileoption_used (X)에 대한 인수 X가 컴파일 타임 옵션의 이름 인 문자열 인 경우,이 루틴은 빌드 중 해당 옵션의 사용 여부에 따라 true (1) 또는 false (0)를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="029c047f81979126902e66d7c2206be9ceebe6ff" translate="yes" xml:space="preserve">
          <source>The sqlite_master table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_master table itself. The sqlite_master table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_master 테이블에는 sqlite_master 테이블 자체에 대한 항목이없는 경우를 제외하고 데이터베이스 스키마의 각 테이블, 인덱스, 뷰 및 트리거 (총칭하여 &quot;개체&quot;)에 대해 하나의 행이 포함됩니다. sqlite_master 테이블에는 애플리케이션 및 프로그래머 정의 오브젝트 외에 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 스키마 오브젝트&lt;/a&gt; 에 대한 항목이 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="9e701356a8021b4fb9727300fa9f7200eddb250b" translate="yes" xml:space="preserve">
          <source>The sqlite_master.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_master entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_master entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_master.name 컬럼은 오브젝트의 이름을 보유합니다. 테이블의 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건으로 인해 SQLite는 &quot;sqlite_autoindex_TABLE_N&quot;형식의 이름으로 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스&lt;/a&gt; 를 생성 합니다. 여기서 TABLE은 제약 조건이 포함 된 테이블의 이름으로 대체되고 N은 1로 시작하고 각 제약 조건마다 하나씩 증가하는 정수입니다. 테이블 정의에서 볼 수 있습니다. A의 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID없이&lt;/a&gt; 테이블, 기본 키에 대한있는 sqlite_master 항목이 없지만,있는 sqlite_master 항목이 존재했던 것처럼 &quot;sqlite_autoindex_TABLE_N&quot;이름은 PRIMARY KEY 위해 따로 설정되어 있습니다. 이는 후속 UNIQUE 제약 조건의 번호 지정에 영향을줍니다. &quot;sqlite_autoindex_TABLE_N&quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY 에는 이름이 할당되지 않습니다&lt;/a&gt;rowid 테이블 또는 WITHOUT ROWID 테이블에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bae42f70521e9e8cd4db2168d1d1babca7ff5fa" translate="yes" xml:space="preserve">
          <source>The sqlite_master.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_master.rootpage 열은 테이블 및 인덱스에 대한 루트 b- 트리 페이지의 페이지 번호를 저장합니다. 뷰, 트리거 및 가상 테이블을 정의하는 행의 경우 루트 페이지 열은 0 또는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="ccb922e59255362de7628494ea2946015486eb28" translate="yes" xml:space="preserve">
          <source>The sqlite_master.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_master.sql 열은 객체를 설명하는 SQL 텍스트를 저장합니다. 이 SQL 텍스트는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문으로, 데이터베이스 파일이 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 기본 데이터베이스 일 때 데이터베이스 파일에 대해 평가되는 경우 오브젝트를 다시 작성합니다. 텍스트는 일반적으로 오브젝트를 작성하는 데 사용 된 원래 명령문의 사본이지만 텍스트가 다음 규칙을 준수하도록 정규화가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8ef76cce54ac5ead8c9ecfb2e98b71a272278d61" translate="yes" xml:space="preserve">
          <source>The sqlite_master.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_master.tbl_name 컬럼은 오브젝트가 연관된 테이블 또는 뷰의 이름을 보유합니다. 테이블 또는 뷰의 경우 tbl_name 컬럼은 이름 컬럼의 사본입니다. 인덱스의 경우 tbl_name은 인덱스 된 테이블의 이름입니다. 트리거의 경우 tbl_name 컬럼은 트리거를 발생시키는 테이블 또는 뷰의 이름을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="1161ce8b03e8867e67c57e405c9c72a8e7f39824" translate="yes" xml:space="preserve">
          <source>The sqlite_master.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_master.type 열은 정의 된 객체 유형에 따라 'table', 'index', 'view'또는 'trigger'텍스트 문자열 중 하나입니다. 'table'문자열은 일반 &lt;a href=&quot;vtab&quot;&gt;테이블&lt;/a&gt; 과 가상 테이블 모두에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a4ecb6a492d4b0952a80c0d2b263ba43418de02" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) SQL function is only available if SQLite is built using the &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; compile-time option.</source>
          <target state="translated">sqlite_offset (X) SQL 함수는 &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; 컴파일 타임 옵션을 사용하여 SQLite를 빌드 한 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f36120db3cfab77bf49cfde55bfe4a03928e953b" translate="yes" xml:space="preserve">
          <source>The sqlite_offset(X) function returns the byte offset in the database file for the beginning of the record from which value would be read. If X is not a column in an ordinary table, then sqlite_offset(X) returns NULL. The value returned by sqlite_offset(X) might reference either the original table or an index, depending on the query. If the value X would normally be extracted from an index, the sqlite_offset(X) returns the offset to the corresponding index record. If the value X would be extracted from the original table, then sqlite_offset(X) returns the offset to the table record.</source>
          <target state="translated">sqlite_offset (X) 함수는 값을 읽을 레코드의 시작 부분에 대한 데이터베이스 파일의 바이트 오프셋을 리턴합니다. X가 일반 테이블의 열이 아닌 경우 sqlite_offset (X)는 NULL을 반환합니다. sqlite_offset (X)에 의해 리턴 된 값은 쿼리에 따라 원래 테이블 또는 인덱스를 참조 할 수 있습니다. 값 X가 일반적으로 인덱스에서 추출되면 sqlite_offset (X)는 해당 인덱스 레코드에 오프셋을 리턴합니다. 값 X가 원래 테이블에서 추출되면 sqlite_offset (X)는 테이블 레코드에 오프셋을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7edde881cc83be6805465c505116db44a7c10317" translate="yes" xml:space="preserve">
          <source>The sqlite_schema table contains one row for each table, index, view, and trigger (collectively &quot;objects&quot;) in the database schema, except there is no entry for the sqlite_schema table itself. The sqlite_schema table contains entries for &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal schema objects&lt;/a&gt; in addition to application- and programmer-defined objects.</source>
          <target state="translated">sqlite_schema 테이블은 sqlite_schema 테이블 자체에 대한 항목이 없다는 점을 제외하고 데이터베이스 스키마의 각 테이블, 인덱스, 뷰 및 트리거 (총칭하여 &quot;객체&quot;)에 대해 하나의 행을 포함합니다. sqlite_schema 테이블에는 응용 프로그램 및 프로그래머 정의 개체 외에도 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 스키마 개체&lt;/a&gt; 에 대한 항목이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02071e2d759314e2fb363a98ec697450c31c3a5" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.name column will hold the name of the object. &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on tables cause SQLite to create &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; with names of the form &quot;sqlite_autoindex_TABLE_N&quot; where TABLE is replaced by the name of the table that contains the constraint and N is an integer beginning with 1 and increasing by one with each constraint seen in the table definition. In a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, there is no sqlite_schema entry for the PRIMARY KEY, but the &quot;sqlite_autoindex_TABLE_N&quot; name is set aside for the PRIMARY KEY as if the sqlite_schema entry did exist. This will affect the numbering of subsequent UNIQUE constraints. The &quot;sqlite_autoindex_TABLE_N&quot; name is never allocated for an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, either in rowid tables or WITHOUT ROWID tables.</source>
          <target state="translated">sqlite_schema.name 열은 객체의 이름을 보유합니다. 테이블에 대한 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건으로 인해 SQLite는 &quot;sqlite_autoindex_TABLE_N&quot;형식의 이름을 가진 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스&lt;/a&gt; 를 생성 합니다. 여기서 TABLE은 제약 조건을 포함하는 테이블의 이름으로 대체되고 N은 1로 시작하여 각 제약 조건에 따라 1 씩 증가하는 정수입니다. 테이블 정의에서 볼 수 있습니다. A의 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID없이&lt;/a&gt; 테이블, 기본 키에 대한 sqlite_schema 항목이 없지만, sqlite_schema 항목이 존재했던 것처럼 &quot;sqlite_autoindex_TABLE_N&quot;이름은 PRIMARY KEY 위해 따로 설정되어 있습니다. 이는 후속 UNIQUE 제약 조건의 번호 지정에 영향을줍니다. &quot;sqlite_autoindex_TABLE_N&quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY에 이름이 할당되지 않았습니다.&lt;/a&gt;, rowid 테이블 또는 WITHOUT ROWID 테이블에서.</target>
        </trans-unit>
        <trans-unit id="b54e4469dd50abde5034fd8f801a4d0306037ed0" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.rootpage column stores the page number of the root b-tree page for tables and indexes. For rows that define views, triggers, and virtual tables, the rootpage column is 0 or NULL.</source>
          <target state="translated">sqlite_schema.rootpage 열은 테이블 및 인덱스에 대한 루트 B- 트리 페이지의 페이지 번호를 저장합니다. 뷰, 트리거 및 가상 테이블을 정의하는 행의 경우 rootpage 열은 0 또는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="ee6bcf89a71c75b0fa182495e5015131f7df248c" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.sql column stores SQL text that describes the object. This SQL text is a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt;, or &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; statement that if evaluated against the database file when it is the main database of a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; would recreate the object. The text is usually a copy of the original statement used to create the object but with normalizations applied so that the text conforms to the following rules:</source>
          <target state="translated">sqlite_schema.sql 열은 객체를 설명하는 SQL 텍스트를 저장합니다. 이 SQL 텍스트는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt; 문으로, &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 주 데이터베이스 일 때 데이터베이스 파일에 대해 평가 하면 개체가 다시 생성됩니다. 텍스트는 일반적으로 개체를 만드는 데 사용 된 원본 문의 복사본이지만 텍스트가 다음 규칙을 따르도록 정규화가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d911ebef016f1f15b28a4875cf26c113309d9fa3" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.tbl_name column holds the name of a table or view that the object is associated with. For a table or view, the tbl_name column is a copy of the name column. For an index, the tbl_name is the name of the table that is indexed. For a trigger, the tbl_name column stores the name of the table or view that causes the trigger to fire.</source>
          <target state="translated">sqlite_schema.tbl_name 컬럼은 오브젝트가 연관된 테이블 또는 뷰의 이름을 보유합니다. 테이블 또는 뷰의 경우 tbl_name 열은 이름 열의 복사본입니다. 인덱스의 경우 tbl_name은 인덱싱 된 테이블의 이름입니다. 트리거의 경우 tbl_name 열은 트리거를 발생시키는 테이블 또는 뷰의 이름을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="02a28099cf1bad8380c62abb7ce56059bbeb63ba" translate="yes" xml:space="preserve">
          <source>The sqlite_schema.type column will be one of the following text strings: 'table', 'index', 'view', or 'trigger' according to the type of object defined. The 'table' string is used for both ordinary and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">sqlite_schema.type 열은 정의 된 객체 유형에 따라 'table', 'index', 'view'또는 'trigger'텍스트 문자열 중 하나입니다. 'table'문자열은 일반 &lt;a href=&quot;vtab&quot;&gt;테이블&lt;/a&gt; 과 가상 테이블 모두에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4f99e581aad3bfe8af33ed6ae438c6f190e18bdd" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_master table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence 테이블은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 구현을 돕는 데 사용되는 내부 테이블 입니다. sqlite_sequence 테이블은 AUTOINCREMENT 정수 기본 키가있는 일반 테이블이 작성 될 때마다 자동으로 작성됩니다. 일단 sqlite_sequence 테이블은 sqlite_master 테이블에 영원히 존재합니다. 떨어 뜨릴 수 없습니다. sqlite_sequence 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45d57d826d6c576b74670b2e5b7c281dbdfadbab" translate="yes" xml:space="preserve">
          <source>The sqlite_sequence table is an internal table used to help implement &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt;. The sqlite_sequence table is created automatically whenever any ordinary table with an AUTOINCREMENT integer primary key is created. Once created, the sqlite_sequence table exists in the sqlite_schema table forever; it cannot be dropped. The schema for the sqlite_sequence table is:</source>
          <target state="translated">sqlite_sequence 테이블은 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 구현을 돕는 데 사용되는 내부 테이블 입니다. sqlite_sequence 테이블은 AUTOINCREMENT 정수 기본 키가있는 일반 테이블이 생성 될 때마다 자동으로 생성됩니다. 일단 생성되면 sqlite_sequence 테이블은 sqlite_schema 테이블에 영원히 존재합니다. 삭제할 수 없습니다. sqlite_sequence 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2336dfb15c81a1bc2e023f4a5ddff1cb80eb4aa" translate="yes" xml:space="preserve">
          <source>The sqlite_source_id() function returns a string that identifies the specific version of the source code that was used to build the SQLite library. The string returned by sqlite_source_id() is the date and time that the source code was checked in followed by the SHA1 hash for that check-in. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt; C interface.</source>
          <target state="translated">sqlite_source_id () 함수는 SQLite 라이브러리를 빌드하는 데 사용 된 특정 버전의 소스 코드를 식별하는 문자열을 리턴합니다. sqlite_source_id ()에 의해 리턴 된 문자열은 소스 코드가 체크인 된 날짜 및 시간과 그 체크인에 대한 SHA1 해시입니다. 이 함수는 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; C 인터페이스 주위의 SQL 랩퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="7f3f3c25482d0c81576dfc7ce696a273cc1dcba3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat1 is an internal table created by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used to hold supplemental information about tables and indexes that the query planner can use to help it find better ways of performing queries. Applications can update, delete from, insert into or drop the sqlite_stat1 table, but may not create or alter the sqlite_stat1 table. The schema of the sqlite_stat1 table is as follows:</source>
          <target state="translated">sqlite_stat1은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령으로 작성된 내부 테이블이며 쿼리 플래너가 더 나은 쿼리 수행 방법을 찾는 데 사용할 수있는 테이블 및 인덱스에 대한 보충 정보를 보유하는 데 사용됩니다. 애플리케이션은 sqlite_stat1 테이블을 업데이트, 삭제, 삽입 또는 삭제할 수 있지만 sqlite_stat1 테이블을 작성하거나 변경할 수는 없습니다. sqlite_stat1 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eac5f10d8bfa6fc7cd030e9acfc883c862434c99" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 entries for an index that have sqlite_stat2.sampleno between 0 and 9 inclusive are samples of the left-most key value in the index taken at evenly spaced points along the index. Let C be the number of rows in the index. Then the sampled rows are given by</source>
          <target state="translated">sqlite_stat2.sampleno가 0에서 9 사이 인 인덱스의 sqlite_stat2 항목은 인덱스를 따라 균일 한 간격으로 점에서 가져온 인덱스의 가장 왼쪽 키 값 샘플입니다. C를 색인의 행 수로 설정하십시오. 그런 다음 샘플링 된 행은</target>
        </trans-unit>
        <trans-unit id="db07f0500ccc51725e75c485f7f2868bee244cc2" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2 is only created and is only used if SQLite is compiled with SQLITE_ENABLE_STAT2 and if the SQLite version number is between 3.6.18 (2009-09-11) and 3.7.8 (2011-09-19). The sqlite_stat2 table is neither read nor written by any version of SQLite before 3.6.18 nor after 3.7.8. The sqlite_stat2 table contains additional information about the distribution of keys within an index. The schema of the sqlite_stat2 table is as follows:</source>
          <target state="translated">sqlite_stat2는 SQLite가 SQLITE_ENABLE_STAT2로 컴파일되고 SQLite 버전 번호가 3.6.18 (2009-09-11)과 3.7.8 (2011-09-19) 사이 인 경우에만 작성되며 사용됩니다. sqlite_stat2 테이블은 3.6.18 이전 또는 3.7.8 이후의 SQLite 버전에서 읽거나 쓰지 않습니다. sqlite_stat2 테이블에는 인덱스 내 키 분배에 대한 추가 정보가 포함되어 있습니다. sqlite_stat2 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e0f4c3583a4ba1380f140be5cb19d805481ba5e" translate="yes" xml:space="preserve">
          <source>The sqlite_stat2.idx column and the sqlite_stat2.tbl column in each row of the sqlite_stat2 table identify an index described by that row. There are usually 10 rows in the sqlite_stat2 table for each index.</source>
          <target state="translated">sqlite_stat2 테이블의 각 행에있는 sqlite_stat2.idx 열과 sqlite_stat2.tbl 열은 해당 행에서 설명하는 인덱스를 식별합니다. sqlite_stat2 테이블에는 일반적으로 각 인덱스에 대해 10 개의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f0561169a2bdda1f406d666ccb3f34136d53934" translate="yes" xml:space="preserve">
          <source>The sqlite_stat3 is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.7.9 (2011-11-01) or greater. The sqlite_stat3 table is neither read nor written by any version of SQLite before 3.7.9. If the &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; compile-time option is used and the SQLite version number is 3.8.1 (2013-10-17) or greater, then sqlite_stat3 might be read but not written. The sqlite_stat3 table contains additional information about the distribution of keys within an index, information that the query planner can use to devise better and faster query algorithms. The schema of the sqlite_stat3 table is as follows:</source>
          <target state="translated">sqlite_stat3은 SQLite가 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4로&lt;/a&gt; 컴파일되고 SQLite 버전 번호가 3.7.9 (2011-11-01) 이상인 경우에만 사용됩니다 . sqlite_stat3 테이블은 3.7.9 이전의 모든 SQLite 버전에서 읽거나 쓰지 않습니다. 는 IF &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 컴파일시 옵션을 사용하고, SQLite는 버전 번호가 3.8.1 (2013년 10월 17일) 이상이다, 다음 sqlite_stat3 읽을 수는 있지만 기록되지 수 있습니다. sqlite_stat3 테이블에는 인덱스 내의 키 분배에 대한 추가 정보, 쿼리 플래너가 더 빠르고 빠른 쿼리 알고리즘을 고안하는 데 사용할 수있는 정보가 포함되어 있습니다. sqlite_stat3 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00890c07b6c2c2c2cdb8874e2a1b39eb7801c048" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is a generalization of the sqlite_stat3 table. The sqlite_stat3 table provides information about the left-most column of an index whereas the sqlite_stat4 table provides information about all columns of the index.</source>
          <target state="translated">sqlite_stat4는 sqlite_stat3 테이블의 일반화입니다. sqlite_stat3 테이블은 인덱스의 가장 왼쪽 열에 대한 정보를 제공하고 sqlite_stat4 테이블은 인덱스의 모든 열에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="17be4a34aae6ba200b1b6b315d0554ec130a710a" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4 is only created and is only used if SQLite is compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; and if the SQLite version number is 3.8.1 (2013-10-17) or greater. The sqlite_stat4 table is neither read nor written by any version of SQLite before 3.8.1. The sqlite_stat4 table contains additional information about the distribution of keys within an index or the distribution of keys in the primary key of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table. The query planner can sometimes use the additional information in the sqlite_stat4 table to devise better and faster query algorithms. The schema of the sqlite_stat4 table is as follows:</source>
          <target state="translated">sqlite_stat4는 SQLite가 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 로 컴파일되고 SQLite 버전 번호가 3.8.1 (2013-10-17) 이상인 경우에만 작성되며 사용됩니다 . sqlite_stat4 테이블은 3.8.1 이전의 SQLite 버전에서 읽거나 쓰지 않습니다. sqlite_stat4 테이블에는 인덱스 내 키 분배 또는 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 의 기본 키 키 분배에 대한 추가 정보가 있습니다. 쿼리 플래너는 sqlite_stat4 테이블의 추가 정보를 사용하여 더 빠르고 더 빠른 쿼리 알고리즘을 고안 할 수 있습니다. sqlite_stat4 테이블의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc1ec4b833f86cdac2f0f4646210820d900eb53f" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.idx column holds name of the index that the row describes, or in the case of an sqlite_stat4 entry for a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table, the name of the table itself.</source>
          <target state="translated">sqlite_stat4.idx 열에는 행이 설명하는 인덱스 이름이 있거나 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 에 대한 sqlite_stat4 항목 의 경우 테이블 자체의 이름이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1916f53e908a81ccd0bcf17da67632c5df8295de" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nDLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index that are distinct in the first K columns and where the left-most K columns are collectively less than the left-most K columns of the sample.</source>
          <target state="translated">sqlite_stat4.nDLt 열은 N 개의 정수 목록을 보유합니다. 여기서 K 번째 정수는 첫 번째 K 열에서 구별되는 색인의 대략적인 항목 수이며 가장 왼쪽의 K 열이 집합 적으로 가장 왼쪽보다 작습니다 샘플의 K 열.</target>
        </trans-unit>
        <trans-unit id="dc87c0d99b695b0cfc2da2e070670a4e3020def1" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nEq column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose left-most K columns exactly match the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nEq 열에는 N 개의 정수 목록이 있습니다. 여기서 K 번째 정수는 가장 왼쪽의 K 열이 샘플의 K 가장 왼쪽 열과 정확히 일치하는 색인의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="9c81743d3d82af763c76e0a7b4201b09b9bf99f3" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.nLt column holds a list of N integers where the K-th integer is the approximate number of entries in the index whose K left-most columns are collectively less than the K left-most columns of the sample.</source>
          <target state="translated">sqlite_stat4.nLt 열에는 N 개의 정수 목록이 있습니다. 여기서 K 번째 정수는 K의 가장 왼쪽 열이 집합 적으로 샘플의 K 가장 왼쪽 열보다 작은 인덱스의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="d2e1c17126c7777e5bb111d59ea8156e8e7627c8" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.sample column holds a BLOB in the &lt;a href=&quot;fileformat2#record_format&quot;&gt;record format&lt;/a&gt; that encodes the indexed columns followed by the rowid for a rowid table or by the columns of the primary key for a WITHOUT ROWID table. The sqlite_stat4.sample BLOB for the WITHOUT ROWID table itself contains just the columns of the primary key. Let the number of columns encoded by the sqlite_stat4.sample blob be N. For indexes on an ordinary rowid table, N will be one more than the number of columns indexed. For indexes on WITHOUT ROWID tables, N will be the number of columns indexed plus the number of columns in the primary key. For a WITHOUT ROWID table, N will be the number of columns in the primary key.</source>
          <target state="translated">sqlite_stat4.sample 컬럼은 색인화 컬럼 다음에 rowid 테이블에 대한 rowid 또는 WITHOUT ROWID 테이블에 대한 기본 키의 컬럼을 인코딩 하는 &lt;a href=&quot;fileformat2#record_format&quot;&gt;레코드 형식&lt;/a&gt; 의 BLOB를 보유 합니다. WITHOUT ROWID 테이블 자체의 sqlite_stat4.sample BLOB에는 기본 키의 열만 포함됩니다. sqlite_stat4.sample Blob에 의해 인코딩 된 열 수를 N으로 설정하십시오. 일반 rowid 테이블의 인덱스의 경우 N은 인덱스 된 열 수의 1보다 큽니다. WITHOUT ROWID 테이블에 대한 인덱스의 경우 N은 인덱스 된 열 수에 기본 키의 열 수를 더한 값입니다. WITHOUT ROWID 테이블의 경우 N은 기본 키의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="d3368a66552678e4208326d2b99cb82cd670c435" translate="yes" xml:space="preserve">
          <source>The sqlite_stat4.tbl column holds name of the table that owns the index that the row describes</source>
          <target state="translated">sqlite_stat4.tbl 열은 행이 설명하는 색인을 소유 한 테이블의 이름을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b005c74909d1b6008d9a724163e0fb64f6a832fd" translate="yes" xml:space="preserve">
          <source>The sqlite_version() function returns the version string for the SQLite library that is running. This function is an SQL wrapper around the &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt; C-interface.</source>
          <target state="translated">sqlite_version () 함수는 실행중인 SQLite 라이브러리의 버전 문자열을 리턴합니다. 이 함수는 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; C 인터페이스 주위의 SQL 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="eeb9bf4120a8b3a5d3dfa457114e73704c247a52" translate="yes" xml:space="preserve">
          <source>The stability of the SQLite database file format and the fact that the file format is cross-platform combine to make SQLite database files an excellent choice as an &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt;. The US Library Of Congress acknowledges this by listing SQLite as a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term preservation of digital content.</source>
          <target state="translated">SQLite 데이터베이스 파일 형식의 안정성과 파일 형식이 크로스 플랫폼이라는 사실은 SQLite 데이터베이스 파일을 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식&lt;/a&gt; 으로 탁월한 선택으로 만들기 위해 결합됩니다 . 미국 의회 도서관 은 디지털 컨텐츠의 장기 보존을 위해 SQLite를 &lt;a href=&quot;locrsf&quot;&gt;권장 스토리지 형식&lt;/a&gt; 으로 표시함으로써이를 인정 합니다.</target>
        </trans-unit>
        <trans-unit id="edcbc0ddf3b476ae82b56edb901d58f590378e61" translate="yes" xml:space="preserve">
          <source>The standard SQLite source tree contains built-in VFSes for unix and windows. Alternative VFSes can be added at start-time or run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">표준 SQLite 소스 트리에는 유닉스 및 윈도우 용 내장 VFS가 포함되어 있습니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 시작 또는 런타임에 대체 VFS를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3afa9cfa18cab2a00e2e2667b20527102ceccaa0" translate="yes" xml:space="preserve">
          <source>The state of the computer when a database connection is first opened is shown conceptually by the diagram at the right. The area of the diagram on the extreme right (labeled &quot;Disk&quot;) represents information stored on the mass storage device. Each rectangle is a sector. The blue color represents that the sectors contain original data. The middle area is the operating systems disk cache. At the onset of our example, the cache is cold and this is represented by leaving the rectangles of the disk cache empty. The left area of the diagram shows the content of memory for the process that is using SQLite. The database connection has just been opened and no information has been read yet, so the user space is empty.</source>
          <target state="translated">데이터베이스 연결이 처음 열릴 때의 컴퓨터 상태는 오른쪽 다이어그램에 개념적으로 표시됩니다. 맨 오른쪽의 다이어그램 영역 ( &quot;디스크&quot;라고 표시됨)은 대용량 저장 장치에 저장된 정보를 나타냅니다. 각 사각형은 섹터입니다. 파란색은 섹터에 원본 데이터가 포함되어 있음을 나타냅니다. 중간 영역은 운영 체제 디스크 캐시입니다. 이 예의 시작에서 캐시는 차갑고 디스크 캐시의 사각형을 비워 두어 표시됩니다. 다이어그램의 왼쪽 영역에는 SQLite를 사용중인 프로세스의 메모리 내용이 표시됩니다. 데이터베이스 연결이 열려 있고 정보를 아직 읽지 않았으므로 사용자 공간이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2357c705a667a06ce3b401fc40060cc2044167c" translate="yes" xml:space="preserve">
          <source>The statement above creates a new geopoly table named &quot;newtab&quot;. Every geopoly table contains a built-in integer &quot;rowid&quot; column and a &quot;_shape&quot; column that contains the polygon associated with that row of the table. The example above also defines three auxiliary data columns named &quot;a&quot;, &quot;b&quot;, and &quot;c&quot; that can store whatever additional information the application needs to associate with each polygon. If there is no need to store auxiliary information, the list of auxiliary columns can be omitted.</source>
          <target state="translated">위의 설명은 &quot;newtab&quot;이라는 새 지오 폴리 테이블을 만듭니다. 모든 지오 폴리 테이블에는 내장 정수 &quot;rowid&quot;열과 테이블의 해당 행과 관련된 다각형이 포함 된 &quot;_shape&quot;열이 포함됩니다. 위의 예에서는 응용 프로그램이 각 다각형과 연결하는 데 필요한 추가 정보를 저장할 수있는 &quot;a&quot;, &quot;b&quot;및 &quot;c&quot;라는 세 개의 보조 데이터 열도 정의합니다. 보조 정보를 저장할 필요가없는 경우 보조 열 목록을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab1aefcd821f7c6a31149043d5432c19acbdf4f" translate="yes" xml:space="preserve">
          <source>The statement above may appear syntactically incorrect to some. Refer to the section describing the &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;simple fts queries&lt;/a&gt; for an explanation.</source>
          <target state="translated">위의 내용은 일부 구문 상 구문 상 부정확 할 수 있습니다. 설명은 &lt;a href=&quot;fts3#simple_fts_queries&quot;&gt;간단한 fts 쿼리&lt;/a&gt; 를 설명하는 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecd0da773db50485ad79c3fe0dd58ba001f98f02" translate="yes" xml:space="preserve">
          <source>The statement journal is given a randomized name, not necessarily in the same directory as the main database, and is automatically deleted at the conclusion of the transaction. The size of the statement journal is proportional to the size of the change implemented by the UPDATE or INSERT statement that caused the statement journal to be created.</source>
          <target state="translated">명세서 일지는 기본 데이터베이스와 동일한 디렉토리에있을 필요는없는 무작위 이름으로 주어지며, 거래가 끝나면 자동으로 삭제됩니다. 명령문 저널의 크기는 명령문 저널이 작성되게하는 UPDATE 또는 INSERT 문에 의해 구현 된 변경 크기에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="abce2a89006a756ad8f25f400ff4bbb7de7fef61" translate="yes" xml:space="preserve">
          <source>The status method is basically a wrapper on the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; C-language interface.</source>
          <target state="translated">상태 메소드는 기본적으로 &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; C 언어 인터페이스 의 랩퍼입니다 .</target>
        </trans-unit>
        <trans-unit id="2957b92cef7bca913b9349499bded01bd701447b" translate="yes" xml:space="preserve">
          <source>The strategy is to compile a single SQL statement using &lt;b&gt;sqlite_compile&lt;/b&gt; then invoke &lt;b&gt;sqlite_step&lt;/b&gt; multiple times, once for each row of output, and finally call &lt;b&gt;sqlite_finalize&lt;/b&gt; to clean up after the SQL has finished execution.</source>
          <target state="translated">전략은 &lt;b&gt;sqlite_compile&lt;/b&gt; 을 사용하여 단일 SQL 문을 컴파일 한 다음 각 출력 행에 대해 &lt;b&gt;sqlite_step을&lt;/b&gt; 여러 번 호출 한 다음 SQL 실행이 완료된 후 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출 하여 정리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7809402bc982c32307d88a8090b6d47f604ca513" translate="yes" xml:space="preserve">
          <source>The string value P4 of length P1 (bytes) is stored in register P2.</source>
          <target state="translated">길이 P1 (바이트)의 문자열 값 P4는 레지스터 P2에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9a7f87028156aaa8a8bf754d55b553e046a12fec" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">이 루틴에서 반환 된 문자열 값은 데이터베이스 연결에서 소유하고 관리합니다. 값은 데이터베이스 N이 &lt;a href=&quot;../lang_detach&quot;&gt;DETACH&lt;/a&gt; -ed가 될 때까지 또는 데이터베이스 연결이 닫힐 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="cb38b0feb448edc668a127b1d9c6a6f2f876060a" translate="yes" xml:space="preserve">
          <source>The string value returned by this routine is owned and managed by the database connection. The value will be valid until the database N is &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt;-ed or until the database connection closes.</source>
          <target state="translated">이 루틴에서 반환 된 문자열 값은 데이터베이스 연결에서 소유하고 관리합니다. 값은 데이터베이스 N이 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; -ed가 될 때까지 또는 데이터베이스 연결이 닫힐 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="995f4878031e82187c641f145afc9d059e07a6dd" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql (P) 및 sqlite3_normalized_sql (P)에 의해 리턴 된 문자열은 SQLite에 의해 관리되며 준비된 명령문이 완료되면 자동으로 해제됩니다. 반면에 sqlite3_expanded_sql (P)에 의해 반환 된 문자열은 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 가져 와서 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 에 전달하여 응용 프로그램에서 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6988de3a51ce0d23769efda8a1dd27ed60344374" translate="yes" xml:space="preserve">
          <source>The strings returned by sqlite3_sql(P) and sqlite3_normalized_sql(P) are managed by SQLite and are automatically freed when the prepared statement is finalized. The string returned by sqlite3_expanded_sql(P), on the other hand, is obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and must be free by the application by passing it to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;.</source>
          <target state="translated">sqlite3_sql (P) 및 sqlite3_normalized_sql (P)에 의해 리턴 된 문자열은 SQLite에 의해 관리되며 준비된 명령문이 완료되면 자동으로 해제됩니다. 반면에 sqlite3_expanded_sql (P)에 의해 반환 된 문자열은 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 가져 와서 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 에 전달하여 응용 프로그램에서 해제해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3deeab5872c796defa91ce886ebd57387fbb18a8" translate="yes" xml:space="preserve">
          <source>The subquery and outer query do not both use LIMIT.</source>
          <target state="translated">하위 쿼리와 외부 쿼리는 모두 LIMIT를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77e0e5365d2489d6a42fa705340d96f457af3864" translate="yes" xml:space="preserve">
          <source>The subquery and the outer query do not both have ORDER BY clauses.</source>
          <target state="translated">부속 조회와 외부 조회 모두에 ORDER BY 절이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c18b6359aac0e334ed733af3b59f97a0357158e6" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query does not use aggregates.</source>
          <target state="translated">부속 조회는 LIMIT를 사용하지 않거나 외부 조회는 집계를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b5bd1b6abc2be3885b869265a72b70231dcb2d09" translate="yes" xml:space="preserve">
          <source>The subquery does not use LIMIT or the outer query is not a join.</source>
          <target state="translated">부속 조회가 LIMIT를 사용하지 않거나 외부 조회가 결합이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9a0c8ea79566123f0e4ecc1c9a70135357fff910" translate="yes" xml:space="preserve">
          <source>The subquery does not use OFFSET.</source>
          <target state="translated">부속 조회는 OFFSET을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e09a48cd0d988ee9dac8cadad6cdbfcea3b74f2" translate="yes" xml:space="preserve">
          <source>The subquery has a FROM clause.</source>
          <target state="translated">부속 조회에는 FROM 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f95cae80ab7a78b4e298e8fc4b136f62be389f" translate="yes" xml:space="preserve">
          <source>The subquery in the FROM clause computes the amount by which the inventory should be reduced for each itemId. That subquery is joined against the inventory table and the quantity of each affected inventory row is reduced by the appropriate amount.</source>
          <target state="translated">FROM 절의 하위 쿼리는 각 itemId에 대해 재고를 줄여야하는 양을 계산합니다. 해당 하위 쿼리는 인벤토리 테이블에 대해 조인되고 영향을받는 각 인벤토리 행의 수량은 적절한 양만큼 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="14960c81162a6f569b4caa226a699f43010d4c7e" translate="yes" xml:space="preserve">
          <source>The subquery is not DISTINCT.</source>
          <target state="translated">하위 쿼리는 DISTINCT가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="560b14fd5f0c196e23d6c05b79eac72d5d601e25" translate="yes" xml:space="preserve">
          <source>The subquery may not be a recursive CTE.</source>
          <target state="translated">하위 쿼리는 재귀 CTE가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7577bd701d8770ad9fc4050124549876822aa978" translate="yes" xml:space="preserve">
          <source>The substitute character (unicode codepoint 26).</source>
          <target state="translated">대체 문자 (유니 코드 코드 포인트 26).</target>
        </trans-unit>
        <trans-unit id="1b25cfaa2f051cde5a374dd5fbd3d25bcae8f82b" translate="yes" xml:space="preserve">
          <source>The substr() function in the SQL view above returns the text of the rbu_control argument with the first character (the one corresponding to column &quot;i&quot;, which is not required by the FTS table) removed.</source>
          <target state="translated">위의 SQL 뷰에서 substr () 함수는 첫 번째 문자 (FTS 테이블에 필요하지 않은 &quot;i&quot;열에 해당하는 문자)가 제거 된 rbu_control 인수의 텍스트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1eb749257ff54f4f9f61b55605ad1eef34135ccf" translate="yes" xml:space="preserve">
          <source>The substr(X,Y,Z) function returns a substring of input string X that begins with the Y-th character and which is Z characters long. If Z is omitted then substr(X,Y) returns all characters through the end of the string X beginning with the Y-th. The left-most character of X is number 1. If Y is negative then the first character of the substring is found by counting from the right rather than the left. If Z is negative then the abs(Z) characters preceding the Y-th character are returned. If X is a string then characters indices refer to actual UTF-8 characters. If X is a BLOB then the indices refer to bytes.</source>
          <target state="translated">substr (X, Y, Z) 함수는 Y 번째 문자로 시작하고 Z 자 길이 인 입력 문자열 X의 하위 문자열을 반환합니다. Z가 생략되면 substr (X, Y)는 Y 번째로 시작하는 문자열 X의 끝을 통해 모든 문자를 반환합니다. X의 가장 왼쪽 문자는 1입니다. Y가 음수이면 부분 문자열의 첫 번째 문자는 왼쪽이 아니라 오른쪽에서 세어집니다. Z가 음수이면 Y 번째 문자 앞에 오는 abs (Z) 문자가 반환됩니다. X가 문자열이면 문자 색인은 실제 UTF-8 문자를 나타냅니다. X가 BLOB이면 인덱스는 바이트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8f8f72577e48839e2c6e724a5bcfafdf7566b512" translate="yes" xml:space="preserve">
          <source>The sum of all &quot;four&quot; values. This is used to compute &quot;avg(four)&quot;.</source>
          <target state="translated">모든 &quot;4&quot;값의 합입니다. 이것은 &quot;avg (four)&quot;를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a5f1cfa6e3d0c304a8016c9b0a8f3f6f7afd998" translate="yes" xml:space="preserve">
          <source>The sum() and total() aggregate functions return sum of all non-NULL values in the group. If there are no non-NULL input rows then sum() returns NULL but total() returns 0.0. NULL is not normally a helpful result for the sum of no rows but the SQL standard requires it and most other SQL database engines implement sum() that way so SQLite does it in the same way in order to be compatible. The non-standard total() function is provided as a convenient way to work around this design problem in the SQL language.</source>
          <target state="translated">sum () 및 total () 집계 함수는 그룹의 모든 NULL이 아닌 값의 합계를 반환합니다. NULL이 아닌 입력 행이 없으면 sum ()은 NULL을 반환하지만 total ()은 0.0을 반환합니다. NULL은 일반적으로 행이없는 합계에 유용한 결과는 아니지만 SQL 표준에서는이를 필요로하며 대부분의 다른 SQL 데이터베이스 엔진은 sum ()을 이런 식으로 구현하므로 SQLite가 호환되도록 동일한 방식으로 수행합니다. 비표준 total () 함수는이 디자인 문제를 SQL 언어로 해결할 수있는 편리한 방법으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c8cc59294c9d81aba99fd5de24fb6dc6b41b0132" translate="yes" xml:space="preserve">
          <source>The super-journal file is only created for &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operations that involve multiple database files where at least two of the databases meet all of the following requirements:</source>
          <target state="translated">수퍼 저널 파일은 최소 두 개의 데이터베이스가 다음 요구 사항을 모두 충족하는 여러 데이터베이스 파일을 포함하는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 작업에 대해서만 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ee67fa1e83c36dfa202c1d70aacf19927252737" translate="yes" xml:space="preserve">
          <source>The super-journal file is used as part of the atomic commit process when a single transaction makes changes to multiple databases that have been added to a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. The super-journal file is always located in the same directory as the main database file (the main database file is the database that is identified in the original &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; call that created the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;) with a randomized suffix. The super-journal file contains the names of all of the various attached auxiliary databases that were changed during the transaction. The multi-database transaction commits when the super-journal file is deleted. See the documentation titled &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; for additional detail.</source>
          <target state="translated">수퍼 저널 파일은 단일 트랜잭션이 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문을 사용하여 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 추가 된 여러 데이터베이스를 변경할 때 원자 적 커밋 프로세스의 일부로 사용됩니다 . 수퍼 저널 파일은 항상 기본 데이터베이스 파일과 동일한 디렉토리에 있습니다 (기본 데이터베이스 파일은 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 생성 한 원래 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 호출 에서 식별되는 데이터베이스입니다 ))를 무작위 접미사로 지정합니다. 수퍼 저널 파일에는 트랜잭션 중에 변경된 다양한 연결된 보조 데이터베이스의 이름이 모두 포함되어 있습니다. 수퍼 저널 파일이 삭제되면 다중 데이터베이스 트랜잭션이 커밋됩니다. 자세한 내용은 &lt;a href=&quot;atomiccommit&quot;&gt;Atomic Commit In SQLite&lt;/a&gt; 라는 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b11b2e43da7a9faed114feb7f008a51dec0a5a77" translate="yes" xml:space="preserve">
          <source>The suppression of redundant columns in the key suffix of an index entry only occurs in WITHOUT ROWID tables. In an ordinary rowid table, the index entry always ends with the rowid even if the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column is one of the columns being indexed.</source>
          <target state="translated">인덱스 항목의 키 접미 부에서 중복 컬럼을 억제하는 것은 WITHOUT ROWID 테이블에서만 발생합니다. 일반 rowid 테이블에서 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY 인&lt;/a&gt; 경우에도 색인 항목은 항상 rowid로 끝납니다. 열이 색인화되는 열 중 하나 인 .</target>
        </trans-unit>
        <trans-unit id="2572ed867faedb74714d50c5898bcb75f0754e78" translate="yes" xml:space="preserve">
          <source>The swarmvtab implementation may open or close databases at any point. By default, it attempts to limit the maximum number of simultaneously open database files to nine. This is not a hard limit - it is possible to construct a scenario that will cause swarmvtab to exceed it.</source>
          <target state="translated">swarmvtab 구현은 언제든지 데이터베이스를 열거 나 닫을 수 있습니다. 기본적으로 동시에 열려있는 데이터베이스 파일의 최대 수를 9 개로 제한하려고합니다. 이는 하드 제한이 아니며 swarmvtab이이를 초과하는 시나리오를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f9e99aa51f888cdf6630598d938ef39ae15f9a3" translate="yes" xml:space="preserve">
          <source>The sync operations that SQLite performs to help ensure integrity can be disabled at run-time using the &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;synchronous pragma&lt;/a&gt;. By setting PRAGMA synchronous=OFF, all sync operations are omitted. This makes SQLite seem to run faster, but it also allows the operating system to freely reorder writes, which could result in database corruption if a power failure or hard reset occurs prior to all content reaching persistent storage.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;동기식 pragma를&lt;/a&gt; 사용하여 런타임시 무결성을 비활성화 할 수 있도록 SQLite가 수행하는 동기화 작업 . PRAGMA synchronous = OFF를 설정하면 모든 동기화 작업이 생략됩니다. 이로 인해 SQLite가 더 빨리 실행되는 것처럼 보이지만 운영 체제가 자유롭게 쓰기 순서를 바꿀 수 있으므로 모든 콘텐츠가 영구 저장소에 도달하기 전에 정전 또는 하드 리셋이 발생하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ed0f1cf6ef82d0d97320ed63cceee25b526aa88" translate="yes" xml:space="preserve">
          <source>The synchronous version of SQLite is the slowest of the group in this test, but the asynchronous version is the fastest. The difference is the extra time needed to execute fsync().</source>
          <target state="translated">이 테스트에서 SQLite의 동기 버전이 가장 느리지 만 비동기 버전이 가장 빠릅니다. 차이점은 fsync ()를 실행하는 데 필요한 추가 시간입니다.</target>
        </trans-unit>
        <trans-unit id="88535ccaca4588c188d3dec59b74e5b6c648c437" translate="yes" xml:space="preserve">
          <source>The syntax for a window function is like this:</source>
          <target state="translated">윈도우 함수의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e97f2e6030323368e9626fb51e9e8ff6dc7c7f0a" translate="yes" xml:space="preserve">
          <source>The syntax for integer and floating point literals (collectively &quot;numeric literals&quot;) is shown by the following diagram:</source>
          <target state="translated">정수 및 부동 소수점 리터럴 (통칭하여 &quot;숫자 리터럴&quot;)의 구문은 다음 다이어그램으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c1140f24a0825da092ba683013464dc50c75b952" translate="yes" xml:space="preserve">
          <source>The syntax for row values and the circumstances in which row values can be used are illustrated in examples below.</source>
          <target state="translated">행 값의 구문과 행 값을 사용할 수있는 환경이 아래 예에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0601104dedcf396efbb0c30203a6d31fd40a4a67" translate="yes" xml:space="preserve">
          <source>The syntax for the ON CONFLICT clause is as shown above for the CREATE TABLE command. For the INSERT and UPDATE commands, the keywords &quot;ON CONFLICT&quot; are replaced by &quot;OR&quot; so that the syntax reads more naturally. For example, instead of &quot;INSERT ON CONFLICT IGNORE&quot; we have &quot;INSERT OR IGNORE&quot;. The keywords change but the meaning of the clause is the same either way.</source>
          <target state="translated">ON CONFLICT 절의 구문은 CREATE TABLE 명령에서 위와 같습니다. INSERT 및 UPDATE 명령의 경우 키워드 &quot;ON CONFLICT&quot;가 &quot;OR&quot;로 바뀌어 구문이보다 자연스럽게 읽 힙니다. 예를 들어 &quot;INSERT ON CONFLICT IGNORE&quot;대신 &quot;INSERT OR IGNORE&quot;가 있습니다. 키워드는 변경되지만 절의 의미는 어느 쪽이든 동일합니다.</target>
        </trans-unit>
        <trans-unit id="f067d61a53dcb338fdf63bf3df528ef6a0487e73" translate="yes" xml:space="preserve">
          <source>The syntax looks like this:</source>
          <target state="translated">구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a61a22c417283e11aa14f2ba9ecd8cd0c90ce62d" translate="yes" xml:space="preserve">
          <source>The syntax of the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt;, &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt;, &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt;, &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt;, &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;, &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; and many other commands all permit the user to specify a database object either by its name alone, or by a combination of its name and the name of its database. If no database is specified as part of the object reference, then SQLite searches the main, temp and all attached databases for an object with a matching name. The temp database is searched first, followed by the main database, followed all attached databases in the order that they were attached. The reference resolves to the first match found. For example:</source>
          <target state="translated">&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; , &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; , &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; , &lt;a href=&quot;lang_droptrigger&quot;&gt;DROP TRIGGER&lt;/a&gt; , &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; , &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 및 기타 여러 명령 의 구문을 통해 사용자는 이름 만 또는 이름과 이름의 조합으로 데이터베이스 오브젝트를 지정할 수 있습니다 데이터베이스. 데이터베이스가 객체 참조의 일부로 지정되지 않으면 SQLite는 기본, 임시 및 연결된 모든 데이터베이스에서 이름이 일치하는 객체를 검색합니다. 임시 데이터베이스를 먼저 검색 한 다음 기본 데이터베이스를 검색 한 다음 연결된 순서대로 모든 연결된 데이터베이스를 검색합니다. 참조는 발견 된 첫 번째 일치로 해석됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="070a4a12a4cd8479f973f088343e30dee884b914" translate="yes" xml:space="preserve">
          <source>The syntax that occurs in between the &quot;ON CONFLICT&quot; and &quot;DO&quot; keywords is called the &quot;conflict target&quot;. The conflict target specifies a specific uniqueness constraint that will trigger the upsert. The conflict target is required for DO UPDATE upserts, but is optional for DO NOTHING. When the conflict target is omitted, the upsert behavior is triggered by a violation of any uniqueness constraint on the table of the INSERT.</source>
          <target state="translated">&quot;ON CONFLICT&quot;와 &quot;DO&quot;키워드 사이에서 발생하는 구문을 &quot;충돌 대상&quot;이라고합니다. 충돌 대상은 upsert를 트리거 할 특정 고유 제한 조건을 지정합니다. DO UPDATE upsert에는 충돌 대상이 필요하지만 DO NOTHING의 경우 선택적입니다. 충돌 대상을 생략하면 INSERT 테이블의 고유성 제약 조건을 위반하여 업 사트 동작이 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="6578fb33b7ba1ef0fa58c80688a069c9340aa258" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size in bytes of the structure that defines an open file: the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object. This object will be described more fully below. The point here is that each VFS implementation can define its own &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object containing whatever information the VFS implementation needs to store about an open file. SQLite needs to know how big this object is, however, in order to preallocate enough space to hold it.</source>
          <target state="translated">szOsFile 필드는 열린 파일 인 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체 를 정의하는 구조의 크기 (바이트)입니다 . 이 객체는 아래에서 더 자세히 설명 될 것이다. 여기서 중요한 것은 각 VFS 구현 이 VFS 구현이 열린 파일에 대해 저장해야하는 정보를 포함하는 자체 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 객체를 정의 할 수 있다는 것 입니다. 그러나 SQLite는 객체를 보유하기에 충분한 공간을 사전 할당하기 위해이 객체의 크기를 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="4160b3968588675d955230ce2bf92a9066be0932" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile 필드는 이 VFS가 사용 하는 서브 클래스 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 의 크기입니다 . mxPathname은이 VFS에서 경로 이름의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="0c08ad2486a604361da59adedd8095e01f05af8a" translate="yes" xml:space="preserve">
          <source>The szOsFile field is the size of the subclassed &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure used by this VFS. mxPathname is the maximum length of a pathname in this VFS.</source>
          <target state="translated">szOsFile 필드는 이 VFS가 사용 하는 서브 클래스 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 의 크기입니다 . mxPathname은이 VFS에서 경로 이름의 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="34b2e05f8be89f8919f89034a92c2255013098b0" translate="yes" xml:space="preserve">
          <source>The t2 table is completely unused in the query above, and so the query planner is able to implement the query as if it were written:</source>
          <target state="translated">t2 테이블은 위의 쿼리에서 완전히 사용되지 않으므로 쿼리 플래너는 작성된 것처럼 쿼리를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4238f21507c2ee050a84b88e1b8452b278b7cbd3" translate="yes" xml:space="preserve">
          <source>The table &quot;t1&quot; has four columns &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;d&quot; that have no particular datatype assigned. You can store anything you want in any of those columns.</source>
          <target state="translated">테이블 &quot;t1&quot;에는 특정 데이터 유형이 할당되지 않은 네 개의 열 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;및 &quot;d&quot;가 있습니다. 이러한 열에 원하는 것은 무엇이든 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69666453d6f0a7ffe136a772a15ed97e78f29762" translate="yes" xml:space="preserve">
          <source>The table being clear is in the main database file if P2==0. If P2==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P2 == 0 인 경우 지워지는 테이블은 기본 데이터베이스 파일에 있습니다. P2 == 1 인 경우 지울 테이블은 CREATE TEMPORARY TABLE을 사용하여 작성하는 테이블을 저장하는 데 사용되는 보조 데이터베이스 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84cc68d91e3409f1edcdf58fc339f372294c1e2" translate="yes" xml:space="preserve">
          <source>The table being destroyed is in the main database file if P3==0. If P3==1 then the table to be clear is in the auxiliary database file that is used to store tables create using CREATE TEMPORARY TABLE.</source>
          <target state="translated">P3 == 0 인 경우 파괴되는 테이블이 기본 데이터베이스 파일에 있습니다. P3 == 1 인 경우 지울 테이블은 CREATE TEMPORARY TABLE을 사용하여 작성하는 테이블을 저장하는 데 사용되는 보조 데이터베이스 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="41f345ab868d88acd8992e4784839c2d5c1e8639" translate="yes" xml:space="preserve">
          <source>The table below lists a few of the virtual tables implementations available for SQLite. Developers can deploy these virtual tables in their own applications, or use the implementations shown below as templates for writing their own virtual tables.</source>
          <target state="translated">아래 표에는 SQLite에 사용 가능한 몇 가지 가상 테이블 구현이 나와 있습니다. 개발자는 이러한 가상 테이블을 자체 응용 프로그램에 배포하거나 아래에 표시된 구현을 자체 가상 테이블을 작성하기위한 템플릿으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d5035ee89279b64afd0eeb8d11272d1a3924472" translate="yes" xml:space="preserve">
          <source>The table conceptually has a number of rows and columns. But these numbers are not part of the result table itself. These numbers are obtained separately. Let N be the number of rows and M be the number of columns.</source>
          <target state="translated">테이블에는 개념적으로 많은 행과 열이 있습니다. 그러나이 숫자는 결과표 자체의 일부가 아닙니다. 이 숫자는 별도로 구합니다. N을 행 수로하고 M을 열 수로하십시오.</target>
        </trans-unit>
        <trans-unit id="dcf57858fad384bb52da74fd124071a651012ac9" translate="yes" xml:space="preserve">
          <source>The table has at least as many columns as recorded in the changeset, and</source>
          <target state="translated">테이블에는 변경 집합에 기록 된 열 수 이상이 있으며</target>
        </trans-unit>
        <trans-unit id="c59c86844961ecda887187879536aa8941add7f6" translate="yes" xml:space="preserve">
          <source>The table has primary key columns in the same position as recorded in the changeset.</source>
          <target state="translated">테이블에는 변경 세트에 기록 된 것과 동일한 위치에 기본 키 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f1ee5eb53df523cde7e4859fa53a41bb0e9f57" translate="yes" xml:space="preserve">
          <source>The table has the same name as the name recorded in the changeset, and</source>
          <target state="translated">테이블의 이름은 변경 집합에 기록 된 이름과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="7d27b581c3631a8cd2d37de114b2996daa06d034" translate="yes" xml:space="preserve">
          <source>The table named in the table_info pragma can also be a view.</source>
          <target state="translated">table_info pragma에 명명 된 테이블도 뷰가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79bd6ebb5ebe8eca1811d6164c483996ae2dbb59" translate="yes" xml:space="preserve">
          <source>The table named on the left-hand side of the AS keyword must appear exactly once in the FROM clause of the right-most SELECT statement of the compound select, and nowhere else.</source>
          <target state="translated">AS 키워드의 왼쪽에 명명 된 테이블은 복합 select의 가장 오른쪽 SELECT 문의 FROM 절에 정확히 한 번만 나타나야합니다.</target>
        </trans-unit>
        <trans-unit id="747fb24ebf8caf800f314099b86fad330ec2bb21" translate="yes" xml:space="preserve">
          <source>The table that is being changed</source>
          <target state="translated">변경중인 테이블</target>
        </trans-unit>
        <trans-unit id="e089550b926c62bbc2dcb5b20ca60a982f76e723" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of a DELETE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">트리거 본문 내에서 DELETE 문의 일부로 지정된 table-name은 규정되지 않아야합니다. 다시 말해</target>
        </trans-unit>
        <trans-unit id="f34e54cb0abeaba37df0e01490317583d5a035fb" translate="yes" xml:space="preserve">
          <source>The table-name specified as part of an UPDATE statement within a trigger body must be unqualified. In other words, the</source>
          <target state="translated">트리거 본문 내에서 UPDATE 문의 일부로 지정된 table-name은 규정되지 않아야합니다. 다시 말해</target>
        </trans-unit>
        <trans-unit id="234e68825ade4fb4c6a3d0e2fe2ac2487e1f2eea" translate="yes" xml:space="preserve">
          <source>The table-valued function returns one row for each record (file, directory or symbolic link) in the zip archive. Each row has the following columns:</source>
          <target state="translated">테이블 반환 함수는 zip 아카이브의 각 레코드 (파일, 디렉토리 또는 기호 링크)에 대해 하나의 행을 반환합니다. 각 행에는 다음과 같은 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7dc1f7c6b1a5d93554b66158b8eab41e9fa0f02" translate="yes" xml:space="preserve">
          <source>The table-valued function syntax may also be used to specify an alternative ranking function. In this case the text describing the ranking function should be specified as the second table-valued function argument. The following three queries are equivalent:</source>
          <target state="translated">테이블 반환 함수 구문을 사용하여 대체 순위 함수를 지정할 수도 있습니다. 이 경우 순위 함수를 설명하는 텍스트는 두 번째 테이블 반환 함수 인수로 지정해야합니다. 다음 세 가지 쿼리는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="194c5b8001842ee44aaaa2c4539d9e178d7c37bd" translate="yes" xml:space="preserve">
          <source>The table-valued functions for PRAGMA feature was added in SQLite version 3.16.0 (2017-01-02). Prior versions of SQLite cannot use this feature.</source>
          <target state="translated">PRAGMA 기능에 대한 테이블 반환 함수는 SQLite 버전 3.16.0 (2017-01-02)에 추가되었습니다. 이전 버전의 SQLite는이 기능을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="273bdbb137f334009fcac2c6deba9c8d09edc07d" translate="yes" xml:space="preserve">
          <source>The tableZ table has a single column named &quot;INTEGER&quot;. That column has no datatype specified, but it is the PRIMARY KEY. The column is &lt;em&gt;not&lt;/em&gt; the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; for the table because it has no datatype. The &quot;INTEGER&quot; token is used as an identifier for the column name, not as a datatype keyword.</source>
          <target state="translated">tableZ 테이블에는 &quot;INTEGER&quot;라는 단일 열이 있습니다. 해당 열에는 지정된 데이터 유형이 없지만 PRIMARY KEY입니다. 열은 &lt;em&gt;하지 &lt;/em&gt;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY 키&lt;/a&gt; 가 더 데이터 형식이 없기 때문에 테이블에 대한. &quot;INTEGER&quot;토큰은 데이터 유형 키워드가 아닌 열 이름의 식별자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1296ca23d366e0c8b6ad53b34a86a007a9e6fcba" translate="yes" xml:space="preserve">
          <source>The tables necessary to do full and proper unicode case folding are larger than the whole SQLite library.</source>
          <target state="translated">완전하고 적절한 유니 코드 케이스 폴딩을 수행하는 데 필요한 테이블은 전체 SQLite 라이브러리보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="1fa68f636ed5379e184e8d386d825c36877f4a63" translate="yes" xml:space="preserve">
          <source>The tables that participate in a union-vtab can be in the same database file, or they can be in separate databases files that are &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;-ed to the same database connection.</source>
          <target state="translated">노조-vtab에 참여하는 테이블이 동일한 데이터베이스 파일에있을 수 있습니다, 또는 그들이하는 별도의 데이터베이스 파일에있을 수 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH가&lt;/a&gt; 동일한 데이터베이스 연결에 -ed.</target>
        </trans-unit>
        <trans-unit id="30590c6f42ddca035bfcfa04a6fd54a5c5428cad" translate="yes" xml:space="preserve">
          <source>The target database may already contain a row with the same PRIMARY KEY values as specified by the INSERT change.</source>
          <target state="translated">대상 데이터베이스에 INSERT 변경으로 지정된 것과 동일한 PRIMARY KEY 값을 가진 행이 이미 포함되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddffb3a24b55dea30b114ff8f89840fe90c8c752" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the current values of the fields that will be modified by the change may not match the original values stored within the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">대상 데이터베이스에 지정된 PRIMARY KEY 값이있는 행이 포함될 수 있지만 변경으로 수정 될 필드의 현재 값이 변경 세트에 저장된 원래 값과 일치하지 않을 수 있습니다. 패치 세트를 사용할 때는 이러한 유형의 충돌이 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9637f3da3aa12d5bcfe7a6adc7e68c320df396f3" translate="yes" xml:space="preserve">
          <source>The target database may contain a row with the specified PRIMARY KEY values, but the other fields may contain values that do not match those stored as part of the changeset. This type of conflict is not detected when using a patchset.</source>
          <target state="translated">대상 데이터베이스에 지정된 PRIMARY KEY 값이있는 행이 포함될 수 있지만 다른 필드에는 변경 세트의 일부로 저장된 값과 일치하지 않는 값이있을 수 있습니다. 패치 세트를 사용할 때는 이러한 유형의 충돌이 감지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11c37f0367cfc6691a61d3fba7a936ab62a7d348" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to delete.</source>
          <target state="translated">대상 데이터베이스에 삭제할 PRIMARY KEY 값이 지정된 행이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b06a833985a4c35aa0208799ae843a7b65a575" translate="yes" xml:space="preserve">
          <source>The target database may contain no row with the specified PRIMARY KEY values to modify.</source>
          <target state="translated">대상 데이터베이스에 수정할 PRIMARY KEY 값이 지정된 행이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f87cac991eff302d9976172f7bdf73e926bb9c2" translate="yes" xml:space="preserve">
          <source>The target database may not be in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">대상 데이터베이스가 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e79db16e64c18b69803344025e269d729d3745a5" translate="yes" xml:space="preserve">
          <source>The target table is not included in the FROM clause, unless the intent is to do a self-join against the target table. In the event of a self-join, the table in the FROM clause must be aliased to a different name than the target table.</source>
          <target state="translated">대상 테이블에 대해 자체 조인을 수행하려는 의도가 아니라면 대상 테이블은 FROM 절에 포함되지 않습니다. 자체 조인의 경우 FROM 절의 테이블은 대상 테이블과 다른 이름으로 별칭을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="711e958f26b3fdef5ca444454f4ee0f963fc86d6" translate="yes" xml:space="preserve">
          <source>The task of the &quot;query planner&quot; is to figure out the best algorithm or &quot;query plan&quot; to accomplish an SQL statement. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), the query planner component has been rewritten so that it runs faster and generates better plans. The rewrite is called the &quot;next generation query planner&quot; or &quot;NGQP&quot;.</source>
          <target state="translated">&quot;조회 계획자&quot;의 임무는 SQL 문을 달성하기위한 최상의 알고리즘 또는 &quot;조회 계획&quot;을 파악하는 것입니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 부터 쿼리 플래너 구성 요소가 더 빨리 실행되고 더 나은 계획을 생성하도록 다시 작성되었습니다. 재 작성을 &quot;차세대 쿼리 플래너&quot;또는 &quot;NGQP&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="42a7ae31a25e761d6c699099d742c17f30af41a6" translate="yes" xml:space="preserve">
          <source>The team_id field cannot be unique because there usually multiple people on the same team. One cannot make the combination of team_id and is_team_leader unique since there are usually multiple non-leaders on each team. The solution to enforcing one leader per team is to create a unique index on team_id but restricted to those entries for which is_team_leader is true:</source>
          <target state="translated">일반적으로 같은 팀에 여러 사람이 있으므로 team_id 필드는 고유 할 수 없습니다. 각 팀에는 일반적으로 여러 명의 비 지도자가 있기 때문에 team_id와 is_team_leader의 조합을 고유하게 만들 수 없습니다. 팀당 하나의 리더를 시행하는 솔루션은 team_id에 고유 인덱스를 작성하는 것이지만 is_team_leader가 true 인 항목으로 제한하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0785e2dbbfabdba0d3916b209d305b3e5683f44f" translate="yes" xml:space="preserve">
          <source>The technique of having xFindFunction() return values of &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; was initially used in the implementation of the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;. The xFindFunction() method of that module returns SQLITE_INDEX_CONSTRAINT_FUNCTION for the &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap()&lt;/a&gt; SQL function and it returns SQLITE_INDEX_CONSTRAINT_FUNCTION+1 for the &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within()&lt;/a&gt; SQL function. This permits search optimizations for queries such as:</source>
          <target state="translated">xFindFunction을 갖는 기술은 ()의 반환 값 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION는&lt;/a&gt; 초기의 구현에 사용 된 &lt;a href=&quot;geopoly&quot;&gt;Geopoly 모듈&lt;/a&gt; . xFindFunction ()을위한 모듈이 리턴 SQLITE_INDEX_CONSTRAINT_FUNCTION 방법 &lt;a href=&quot;geopoly#goverlap&quot;&gt;geopoly_overlap ()&lt;/a&gt; SQL 함수 및 그것을위한 SQLITE_INDEX_CONSTRAINT_FUNCTION + 1을 리턴 &lt;a href=&quot;geopoly#gwithin&quot;&gt;geopoly_within ()&lt;/a&gt; SQL 함수. 이를 통해 다음과 같은 쿼리에 대한 검색 최적화가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="2710792de033b547bac6e441ea1f9b9d8e9fc431" translate="yes" xml:space="preserve">
          <source>The temp.sqlite_parameters table only provides values for parameters in the command-line shell. The temp.sqlite_parameter table has no effect on queries that are run directly using the SQLite C-language API. Individual applications are expected to implement their own parameter binding. You can search for &quot;sqlite_parameters&quot; in the &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;command-line shell source code&lt;/a&gt; to see how the command-line shell does parameter binding, and use that as a hint for how to implement it yourself.</source>
          <target state="translated">temp.sqlite_parameters 테이블은 명령 줄 셸의 매개 변수 값만 제공합니다. temp.sqlite_parameter 테이블은 SQLite C 언어 API를 사용하여 직접 실행되는 쿼리에는 영향을 미치지 않습니다. 개별 응용 프로그램은 자체 매개 변수 바인딩을 구현해야합니다. &lt;a href=&quot;https://sqlite.org/src/file/src/shell.c.in&quot;&gt;명령 행 쉘 소스 코드&lt;/a&gt; 에서 &quot;sqlite_parameters&quot;를 검색 하여 명령 행 쉘이 매개 변수 바인딩을 수행하는 방법을보고이를 직접 구현하는 방법에 대한 힌트로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0243e43a9e092811e1870e88e873ed47024b50d" translate="yes" xml:space="preserve">
          <source>The temporary file created by the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command exists only for the duration of the command itself. The size of the temporary file will be no larger than the original database.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령으로 작성된 임시 파일 은 명령 기간 동안 만 존재합니다. 임시 파일의 크기는 원래 데이터베이스보다 크지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2f2df5fab6b729ca7d2c3e78798e53760ca0b74f" translate="yes" xml:space="preserve">
          <source>The temporary files associated with the TEMP database and its rollback journal are only created if the application makes use of the &quot;CREATE TEMP TABLE&quot; statement.</source>
          <target state="translated">TEMP 데이터베이스 및 해당 롤백 저널과 연관된 임시 파일은 응용 프로그램이 &quot;CREATE TEMP TABLE&quot;문을 사용하는 경우에만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="f07c39bdad21f0453b3d046fa930925221ebb2c1" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, master journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, master, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">트랜잭션 제어와 관련된 임시 파일, 즉 롤백 저널, 마스터 저널, WAL (Write-Ahead Log) 파일 및 공유 메모리 파일은 항상 디스크에 기록됩니다. 그러나 다른 종류의 임시 파일은 메모리에만 저장되고 디스크에는 쓰지 않을 수 있습니다. 롤백, 마스터 및 명령문 저널 이외의 임시 파일이 디스크에 기록되거나 메모리에만 저장 &lt;a href=&quot;compile#temp_store&quot;&gt;되는지&lt;/a&gt; 여부는 SQLITE_TEMP_STORE 컴파일 타임 매개 변수, &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 및 임시 파일의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="408ca6d25d3ec064e51ba766d2fa74811ccbfcc3" translate="yes" xml:space="preserve">
          <source>The temporary files associated with transaction control, namely the rollback journal, super-journal, write-ahead log (WAL) files, and shared-memory files, are always written to disk. But the other kinds of temporary files might be stored in memory only and never written to disk. Whether or not temporary files other than the rollback, super, and statement journals are written to disk or stored only in memory depends on the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter, the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;, and on the size of the temporary file.</source>
          <target state="translated">트랜잭션 제어와 관련된 임시 파일, 즉 롤백 저널, 수퍼 저널, 미리 쓰기 로그 (WAL) 파일 및 공유 메모리 파일은 항상 디스크에 기록됩니다. 그러나 다른 종류의 임시 파일은 메모리에만 저장되고 디스크에 기록되지 않을 수 있습니다. 롤백, 수퍼 및 명령문 저널 이외의 임시 파일이 디스크에 기록되는지 또는 메모리에만 저장 &lt;a href=&quot;compile#temp_store&quot;&gt;되는지&lt;/a&gt; 여부는 SQLITE_TEMP_STORE 컴파일 시간 매개 변수, &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 및 임시 파일의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="42ee5d948678f086d276ab61d7dad5de2797f6e5" translate="yes" xml:space="preserve">
          <source>The term number of the matching term within the full-text query expression. Terms within a query expression are numbered starting from 0 in the order that they occur.</source>
          <target state="translated">전체 텍스트 쿼리 식 내에서 일치하는 용어의 용어 번호입니다. 쿼리 표현식 내의 용어는 발생 순서대로 0부터 시작하여 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="2146ad4958dfdca7b01896ef7e97e3c556f6bfc0" translate="yes" xml:space="preserve">
          <source>The term, as stored in the FTS5 index.</source>
          <target state="translated">FTS5 색인에 저장된 용어입니다.</target>
        </trans-unit>
        <trans-unit id="efaf8ed4fd273fae5234c31a87ca20e1f921ce05" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">&quot;보호 된&quot;및 &quot;비보호 된&quot;이라는 용어는 뮤텍스가 보유되는지 여부를 지칭한다. 내부 뮤텍스는 보호 된 sqlite3_value 객체에 대해 유지되지만 보호되지 않은 sqlite3_value 객체에 대해서는 뮤텍스가 유지되지 않습니다. SQLite가 단일 스레드 ( &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 및 &lt;a href=&quot;threadsafe&quot;&gt;sqlite3_threadsafe ()가&lt;/a&gt; 0을 리턴 함 ) 로 컴파일 되거나 SQLite가 감소 된 뮤텍스 모드 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; 또는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 중 하나로 실행되는 경우 보호 된 sqlite3_value 오브젝트와 구별되지 않는 sqlite3_value 오브젝트간에 구별이 없으며 상호 교환하여 사용하십시오. 그러나 코드 이식성을 최대화하려면 엄격하게 요구되지 않는 경우에도 애플리케이션이 보호 된 sqlite3_value 오브젝트를 여전히 구별하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9b59119835d0c98638847083b9be8651dcfed7b3" translate="yes" xml:space="preserve">
          <source>The terms &quot;protected&quot; and &quot;unprotected&quot; refer to whether or not a mutex is held. An internal mutex is held for a protected sqlite3_value object but no mutex is held for an unprotected sqlite3_value object. If SQLite is compiled to be single-threaded (with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; and with &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; returning 0) or if SQLite is run in one of reduced mutex modes &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; or &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; then there is no distinction between protected and unprotected sqlite3_value objects and they can be used interchangeably. However, for maximum code portability it is recommended that applications still make the distinction between protected and unprotected sqlite3_value objects even when not strictly required.</source>
          <target state="translated">&quot;보호 된&quot;및 &quot;비보호 된&quot;이라는 용어는 뮤텍스가 보유되는지 여부를 지칭한다. 내부 뮤텍스는 보호 된 sqlite3_value 객체에 대해 유지되지만 보호되지 않은 sqlite3_value 객체에 대해서는 뮤텍스가 유지되지 않습니다. SQLite가 단일 스레드 ( &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_threadsafe&quot;&gt;sqlite3_threadsafe ()가&lt;/a&gt; 0을 리턴 함 ) 로 컴파일 되거나 SQLite가 감소 된 뮤텍스 모드 &lt;a href=&quot;#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; 또는 &lt;a href=&quot;#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 중 하나로 실행되는 경우 보호 된 sqlite3_value 오브젝트와 구별되지 않는 sqlite3_value 오브젝트간에 구별이 없으며 상호 교환하여 사용하십시오. 그러나 코드 이식성을 최대화하려면 엄격하게 요구되지 않는 경우에도 애플리케이션이 보호 된 sqlite3_value 오브젝트를 여전히 구별하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d0d8bb329a3e29ad5aa4a494be22dcdfc57447c5" translate="yes" xml:space="preserve">
          <source>The terms in W and X must match exactly. SQLite does not do algebra to try to get them to look the same. The term &quot;b=6&quot; does not match &quot;b=3+3&quot; or &quot;b-6=0&quot; or &quot;b BETWEEN 6 AND 6&quot;. &quot;b=6&quot; will match to &quot;6=b&quot; as long as &quot;b=6&quot; is on the index and &quot;6=b&quot; is in the query. If a term of the form &quot;6=b&quot; appears in the index, it will never match anything.</source>
          <target state="translated">W와 X의 용어는 정확히 일치해야합니다. SQLite는 똑같이 보이도록 대수를하지 않습니다. &quot;b = 6&quot;이라는 용어는 &quot;b = 3 + 3&quot;또는 &quot;b-6 = 0&quot;또는 &quot;b 6과 6 사이&quot;와 일치하지 않습니다. &quot;b = 6&quot;이 인덱스에 있고 &quot;6 = b&quot;가 쿼리에 있으면 &quot;b = 6&quot;은 &quot;6 = b&quot;와 일치합니다. 색인에 &quot;6 = b&quot;형식의 용어가 나타나면 아무 것도 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a91aabb1ee8a98e3573519dc568a9cdcf09f371" translate="yes" xml:space="preserve">
          <source>The test infrastructure verifies that SQLite does not misuse dynamically allocated memory by using a specially instrumented memory allocator. The instrumented memory allocator is enabled at compile-time using the &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; option. The instrumented memory allocator is much slower than the default memory allocator and so its use is not recommended in production. But when enabled during testing, the instrumented memory allocator performs the following checks:</source>
          <target state="translated">테스트 인프라는 SQLite가 특별히 계측 된 메모리 할당자를 사용하여 동적으로 할당 된 메모리를 오용하지 않는지 확인합니다. 인스트루먼트 된 메모리 할당자는 &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; 옵션을 사용하여 컴파일시 사용 가능합니다 . 인스트루먼트 된 메모리 할당자는 기본 메모리 할당 기보다 훨씬 느리므로 프로덕션 환경에서는 사용하지 않는 것이 좋습니다. 그러나 테스트 중에 활성화되면 인스트루먼트 된 메모리 할당자는 다음 점검을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="23d89111adcbe2ab0ff1f685425a6f5892695526" translate="yes" xml:space="preserve">
          <source>The test suite is designed to be run three times, once for each of the ALWAYS() and NEVER() definitions shown above. All three test runs should yield exactly the same result. There is a run-time test using the &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt;(&lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt;, ...) interface that can be used to verify that the macros are correctly set to the first form (the pass-through form) for deployment.</source>
          <target state="translated">테스트 스위트는 위에 표시된 각 ALWAYS () 및 NEVER () 정의마다 한 번씩 세 번 실행되도록 설계되었습니다. 세 가지 테스트 실행 모두 정확히 동일한 결과를 가져와야합니다. &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_ALWAYS&lt;/a&gt; , ...) 인터페이스를 사용하는 런타임 테스트 가 있으며 이는 배치를 위해 매크로가 첫 번째 양식 (통과 양식)으로 올바르게 설정되었는지 검증하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77fbf4494f9eeac6c3dd3e8030fecebddc25654d" translate="yes" xml:space="preserve">
          <source>The test suites for SQLite also explore the result of stacking multiple failures. For example, tests are run to ensure correct behavior when an I/O error or OOM fault occurs while trying to recover from a prior crash.</source>
          <target state="translated">SQLite 용 테스트 스위트는 또한 여러 오류를 스태킹 한 결과를 탐색합니다. 예를 들어, 이전 충돌에서 복구하려고 시도하는 동안 I / O 오류 또는 OOM 오류가 발생할 때 올바른 동작을 보장하기 위해 테스트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a7eb514323fac72f4df40162cf2fb7ca6826d6f1" translate="yes" xml:space="preserve">
          <source>The test1.dir directory will contain 100,000 files with names like &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot; and so forth but the test1.tree directory will contain the same files in subdirectories like &quot;00/00/00&quot;, &quot;00/00/01&quot;, and so on. The test1.dir and test1.test directories take up approximately the same amount of space, though test1.test is very slightly larger due to the extra directory entries.</source>
          <target state="translated">test1.dir 디렉토리는 &quot;000000&quot;, &quot;000001&quot;, &quot;000002&quot;등과 같은 이름을 가진 100,000 개의 파일을 포함하지만 test1.tree 디렉토리는 &quot;00/00/00&quot;, &quot;00과 같은 서브 디렉토리에 동일한 파일을 포함합니다. / 00 / 01 &quot;등. test1.dir 및 test1.test 디렉토리는 대략 동일한 공간을 차지하지만 test1.test는 추가 디렉토리 항목으로 인해 약간 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="833841004a13aff638c7a47f3f35a8f25f41ac0a" translate="yes" xml:space="preserve">
          <source>The test_async.c drive now does full file locking and works correctly when used simultaneously by multiple processes on the same database.</source>
          <target state="translated">test_async.c 드라이브는 이제 전체 파일 잠금을 수행하고 동일한 데이터베이스의 여러 프로세스에서 동시에 사용될 때 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eb420a5e9808216cc66d2c072d0472129ab690a9" translate="yes" xml:space="preserve">
          <source>The testcase() macro is often used to verify that boundary cases of an inequality comparison are checked. For example, at &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&lt;/a&gt;. These kind of checks help to prevent off-by-one errors.</source>
          <target state="translated">testcase () 매크로는 종종 불평등 비교의 경계 사례가 확인되었는지 확인하는 데 사용됩니다. 예를 들어 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5766&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5766에&lt;/a&gt; 있습니다. 이러한 종류의 검사는 개별 오류를 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd50a8b5d17dc1d197a2f0aeffde22600cc3d5e" translate="yes" xml:space="preserve">
          <source>The testcase(X) macro is normally a no-op, but for a coverage test build it does generate a small amount of extra code that includes at least one branch, in order to verify that test cases exist for which X is both true and false.</source>
          <target state="translated">testcase (X) 매크로는 일반적으로 no-op이지만, 적용 범위 테스트 빌드의 경우 X가 true 및 X 인 테스트 케이스가 있는지 확인하기 위해 하나 이상의 브랜치를 포함하는 소량의 추가 코드를 생성합니다. 그릇된.</target>
        </trans-unit>
        <trans-unit id="198025ed4b90dd540b423fcfb30efac73a9076a6" translate="yes" xml:space="preserve">
          <source>The testing process for SQLite is described in the &lt;a href=&quot;testing&quot;&gt;testing&lt;/a&gt; document. Testing objectives include:</source>
          <target state="translated">SQLite의 테스트 프로세스는 &lt;a href=&quot;testing&quot;&gt;테스트&lt;/a&gt; 문서에 설명되어 있습니다. 테스트 목표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f341b9da6892f9f513eb1e23029aaad7d1945bb" translate="yes" xml:space="preserve">
          <source>The testing process is controlled by the &lt;a href=&quot;testing#cklist&quot;&gt;release testing checklists&lt;/a&gt;. The checklists succinctly summary all steps necessary to fully validate SQLite, and they record when and by whom each validation step was performed.</source>
          <target state="translated">테스트 프로세스는 &lt;a href=&quot;testing#cklist&quot;&gt;릴리스 테스트 체크리스트에&lt;/a&gt; 의해 제어됩니다 . 체크리스트는 SQLite를 완전히 검증하는 데 필요한 모든 단계를 간결하게 요약하고 각 검증 단계가 수행 된시기와 대상을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="b10a0b7612e25fb69c97ba29101b2f64b4a7581b" translate="yes" xml:space="preserve">
          <source>The text format is pure SQL so you can also use the .dump command to export an SQLite database into other popular SQL database engines. Like this:</source>
          <target state="translated">텍스트 형식은 순수한 SQL이므로 .dump 명령을 사용하여 SQLite 데이터베이스를 다른 인기있는 SQL 데이터베이스 엔진으로 내보낼 수도 있습니다. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="002ca6dfea0de9e1d73a68077f123004fa9755de" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_master.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_master.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_master.sql 열의 텍스트는 위에서 설명한대로 정규화되고 후속 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 문 으로 수정 된 경우를 제외하고 객체를 만든 원래 CREATE 문 텍스트의 복사본입니다 . &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건에 의해 자동으로 생성되는 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스&lt;/a&gt; 의 경우 sqlite_master.sql은 NULL입니다 .</target>
        </trans-unit>
        <trans-unit id="df540746bab5e3cce21edce12d96e726e4a223e9" translate="yes" xml:space="preserve">
          <source>The text in the sqlite_schema.sql column is a copy of the original CREATE statement text that created the object, except normalized as described above and as modified by subsequent &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statements. The sqlite_schema.sql is NULL for the &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal indexes&lt;/a&gt; that are automatically created by &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints.</source>
          <target state="translated">sqlite_schema.sql 열의 텍스트는 위에서 설명한대로 정규화되고 후속 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 문에 의해 수정 된 경우를 제외하고 개체를 생성 한 원래 CREATE 문 텍스트의 복사본입니다 . sqlite_schema.sql은 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건에 의해 자동으로 생성되는 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 인덱스의&lt;/a&gt; 경우 NULL입니다 .</target>
        </trans-unit>
        <trans-unit id="3362b59e42a116b494bb787cf561f00b28111a39" translate="yes" xml:space="preserve">
          <source>The text of query parameters is appended to the filename argument of the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. Any %HH escape sequences in the query parameters are resolved prior to being appended to the xOpen filename. A single zero-byte separates the xOpen filename argument from the key of the first query parameters, each key and value, and each subsequent key from the prior value. The list of query parameters appended to the xOpen filename is terminated by a single zero-length key. Note that the value of a query parameter can be an empty string.</source>
          <target state="translated">조회 매개 변수의 텍스트는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xOpen 메소드의 파일 이름 인수에 추가됩니다 . 쿼리 매개 변수의 % HH 이스케이프 시퀀스는 xOpen 파일 이름에 추가되기 전에 확인됩니다. 단일 0 바이트는 xOpen 파일 이름 인수를 첫 번째 쿼리 매개 변수의 키, 각 키 및 값, 각 후속 키를 이전 값과 구분합니다. xOpen 파일 이름에 추가 된 쿼리 매개 변수 목록은 길이가 0 인 단일 키로 종료됩니다. 쿼리 매개 변수의 값은 빈 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f010a4aeda05a6fff949d6b23c4d99edd507a5b9" translate="yes" xml:space="preserve">
          <source>The text of the word that matches the pattern. Both word and pattern can contain unicode characters and can be mixed case.</source>
          <target state="translated">패턴과 일치하는 단어의 텍스트입니다. 단어와 패턴 모두 유니 코드 문자를 포함 할 수 있으며 대소 문자를 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34ac3915c6fa697bff1880701cc84fcf41ef0614" translate="yes" xml:space="preserve">
          <source>The text to add to the start or end of the selected text to indicate that the returned text does not occur at the start or end of its column, respectively.</source>
          <target state="translated">선택한 텍스트의 시작 또는 끝에 추가 할 텍스트는 반환 된 텍스트가 해당 열의 시작 또는 끝에서 각각 발생하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5d227441e585adc9dccb7fd5119a447b09eeb780" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match within the returned text.</source>
          <target state="translated">각 문구 뒤에 삽입 할 텍스트는 반환 된 텍스트 내에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c372789c27ae2ac063bb79f99aab7639b81bdf47" translate="yes" xml:space="preserve">
          <source>The text to insert after each phrase match.</source>
          <target state="translated">각 구가 일치 한 후 삽입 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="98deed99ebb119a4eabb19891d9d80c8f6d99766" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match within the returned text.</source>
          <target state="translated">각 문구 앞에 삽입 할 텍스트는 반환 된 텍스트 내에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="011020fd80da1d64051ffd57ff7d4f9db6949595" translate="yes" xml:space="preserve">
          <source>The text to insert before each phrase match.</source>
          <target state="translated">각 구가 일치하기 전에 삽입 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="41db7390257d3e1c83cfe7262fbe75efa4098374" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 140 terabytes will be reached first. A 140 terabytes database can hold no more than approximately 1e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">테이블의 이론상 최대 행 수는 2 &lt;sup&gt;&lt;small&gt;64입니다&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 또는 약 1.8e + 19). 최대 140 테라 바이트의 데이터베이스 크기에 먼저 도달하므로이 한계에 도달 할 수 없습니다. 140 테라 바이트 데이터베이스는 대략 1e + 13 개의 행을 보유 할 수 있으며, 인덱스가없고 각 행에 데이터가 거의없는 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9c469d0a6dd7814f8f536d83dd0c0d4f9236b847" translate="yes" xml:space="preserve">
          <source>The theoretical maximum number of rows in a table is 2&lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 or about 1.8e+19). This limit is unreachable since the maximum database size of 281 terabytes will be reached first. A 281 terabytes database can hold no more than approximately 2e+13 rows, and then only if there are no indices and if each row contains very little data.</source>
          <target state="translated">테이블의 이론적 인 최대 행 수는 2 &lt;sup&gt;&lt;small&gt;64&lt;/small&gt;&lt;/sup&gt; (18446744073709551616 또는 약 1.8e + 19)입니다. 최대 데이터베이스 크기 인 281TB에 먼저 도달하므로이 제한에 도달 할 수 없습니다. 281 테라 바이트 데이터베이스는 약 2e + 13 행을 보유 할 수 있으며, 인덱스가없고 각 행에 매우 적은 데이터가 포함 된 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e681320a770693ff8880c2fe787c3d46c58d6fe" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">이러한 루틴은 결과의 데이터 유형 변환을 시도 할 수 있습니다. 예를 들어, 내부 표현이 FLOAT이고 텍스트 결과가 요청 된 경우 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 가 내부적으로 사용되어 자동으로 변환을 수행합니다. 다음 표에는 적용되는 변환이 자세히 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="d45ababe332de0d6a9b7d204a8229a091726f141" translate="yes" xml:space="preserve">
          <source>The these routines may attempt to convert the datatype of the result. For example, if the internal representation is FLOAT and a text result is requested, &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; is used internally to perform the conversion automatically. The following table details the conversions that are applied:</source>
          <target state="translated">이러한 루틴은 결과의 데이터 유형 변환을 시도 할 수 있습니다. 예를 들어, 내부 표현이 FLOAT이고 텍스트 결과가 요청 된 경우 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 가 내부적으로 사용되어 자동으로 변환을 수행합니다. 다음 표에는 적용되는 변환이 자세히 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29b8fd84fbcfd59fccde21c2067cc383b5612cf" translate="yes" xml:space="preserve">
          <source>The third and fourth parameters to this function are the table and column name of the desired column, respectively.</source>
          <target state="translated">이 함수의 세 번째 및 네 번째 매개 변수는 각각 원하는 열의 테이블 및 열 이름입니다.</target>
        </trans-unit>
        <trans-unit id="5dad7ccfb7adf02e60a4718cd1bfaf6cc7ad8094" translate="yes" xml:space="preserve">
          <source>The third argument (eTextRep) must be one of the constants:</source>
          <target state="translated">세 번째 인수 (eTextRep)는 상수 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a12fbbce4ea7f98c6f3257e48e8cfdd9d6a7f402" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null().</source>
          <target state="translated">세 번째 인수는 매개 변수에 바인딩 할 값입니다. sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_blob ()의 세 번째 매개 변수가 NULL 포인터 인 경우 네 번째 매개 변수는 무시되고 최종 결과는 sqlite3_bind_null ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfd2994dc5175da09229d952b2be33f11c05e0da" translate="yes" xml:space="preserve">
          <source>The third argument is the value to bind to the parameter. If the third parameter to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_blob() is a NULL pointer then the fourth parameter is ignored and the end result is the same as sqlite3_bind_null(). If the third parameter to sqlite3_bind_text() is not NULL, then it should be a pointer to well-formed UTF8 text. If the third parameter to sqlite3_bind_text16() is not NULL, then it should be a pointer to well-formed UTF16 text. If the third parameter to sqlite3_bind_text64() is not NULL, then it should be a pointer to a well-formed unicode string that is either UTF8 if the sixth parameter is SQLITE_UTF8, or UTF16 otherwise.</source>
          <target state="translated">세 번째 인수는 매개 변수에 바인딩 할 값입니다. sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_blob ()의 세 번째 매개 변수가 NULL 포인터이면 네 번째 매개 변수는 무시되고 최종 결과는 sqlite3_bind_null ()과 동일합니다. sqlite3_bind_text ()의 세 번째 매개 변수가 NULL이 아니면 올바른 형식의 UTF8 텍스트에 대한 포인터 여야합니다. sqlite3_bind_text16 ()에 대한 세 번째 매개 변수가 NULL이 아니면 올바른 형식의 UTF16 텍스트에 대한 포인터 여야합니다. sqlite3_bind_text64 ()에 대한 세 번째 매개 변수가 NULL이 아니면 여섯 번째 매개 변수가 SQLITE_UTF8이면 UTF8이고 그렇지 않으면 UTF16 인 올바른 형식의 유니 코드 문자열에 대한 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="8896799f29c2adcd495a7004a3dfd8ef2c595b55" translate="yes" xml:space="preserve">
          <source>The third argument to the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt;,...) interface (the &quot;pData&quot; argument in the example above) is a pointer to arbitrary data. SQLite passes this pointer through to the first argument of the error logger callback. The pointer can be used to pass application-specific setup or state information, if desired. Or it can simply be a NULL pointer which is ignored by the callback.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; , ...) 인터페이스에 대한 세 번째 인수 ( 위의 예에서 &quot;pData&quot;인수)는 임의의 데이터에 대한 포인터입니다. SQLite는이 포인터를 오류 로거 콜백의 첫 번째 인수로 전달합니다. 원하는 경우 포인터를 사용하여 응용 프로그램 별 설정 또는 상태 정보를 전달할 수 있습니다. 또는 단순히 콜백에서 무시되는 NULL 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e80d3a19f53ad5c94b48f6b4deace1bd8cd6a01" translate="yes" xml:space="preserve">
          <source>The third chart shows that reading blob content out of SQLite can be twice as fast as reading from individual files on disk for Mac and Android, and an amazing ten times faster for Windows.</source>
          <target state="translated">세 번째 차트는 SQLite에서 Blob 내용을 읽는 것이 Mac 및 Android 용 디스크의 개별 파일을 읽는 것보다 두 배 빠르며 Windows의 경우 10 배 더 빠르다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ce81cfaf801aa960a0d4e258e6f72c47aaf642db" translate="yes" xml:space="preserve">
          <source>The third column is the minimum value for any rowid in the table.</source>
          <target state="translated">세 번째 열은 테이블에있는 모든 rowid의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="66b245a2c0333e9c6e002eaadabc21caae3f20aa" translate="yes" xml:space="preserve">
          <source>The third form of an INSERT statement is with DEFAULT VALUES. The INSERT ... DEFAULT VALUES statement inserts a single new row into the named table. Each column of the new row is populated with its &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;default value&lt;/a&gt;, or with a NULL if no default value is specified as part of the column definition in the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. The &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; is not supported after DEFAULT VALUES.</source>
          <target state="translated">INSERT 문의 세 번째 형식은 DEFAULT VALUES입니다. INSERT ... DEFAULT VALUES 문은 이름 지정된 테이블에 하나의 새 행을 삽입합니다. 새 행의 각 열은 &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;기본값으로&lt;/a&gt; 채워지 거나 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에서 열 정의의 일부로 기본값이 지정되지 않은 경우 NULL 로 채워집니다 . DEFAULT VALUES 이후 에는 &lt;a href=&quot;syntax/upsert-clause&quot;&gt;upsert-clause&lt;/a&gt; 가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80211bcbcab262c368d4da63de6e8f61d55d7f66" translate="yes" xml:space="preserve">
          <source>The third line of the example shows the virtual table being used, to read all content of the CSV file. This is perhaps the simplest possible use of the virtual table. The CSV virtual table can be used anywhere an ordinary virtual table can be used. One can use the CSV virtual table inside subqueries, or &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; or add WHERE, GROUP BY, HAVING, ORDER BY, and LIMIT clauses as required.</source>
          <target state="translated">예제의 세 번째 줄은 CSV 파일의 모든 내용을 읽는 데 사용되는 가상 테이블을 보여줍니다. 이것은 아마도 가상 테이블의 가장 간단한 사용 일 것입니다. CSV 가상 테이블은 일반 가상 테이블을 사용할 수있는 모든 곳에서 사용할 수 있습니다. 서브 쿼리 또는 &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 에서 CSV 가상 테이블을 사용 하거나 필요에 따라 WHERE, GROUP BY, HAVING, ORDER BY 및 LIMIT 절을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37d0f732f75ffbc9298be10c6e109dfc37fa5d4b" translate="yes" xml:space="preserve">
          <source>The third number Z is incremented for releases consisting of only small changes that implement performance enhancements and/or bug fixes.</source>
          <target state="translated">세 번째 숫자 Z는 성능 향상 및 / 또는 버그 수정을 구현하는 작은 변경 사항만으로 구성된 릴리스에 대해 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d43fa02ec7a69fa0b5cb4656ab69a4413a6918c8" translate="yes" xml:space="preserve">
          <source>The third optimization, zeroing the journal file header rather than deleting the rollback journal file, does not depend on holding an exclusive lock at all times. This optimization can be set independently of exclusive lock mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; as described in &lt;a href=&quot;#section_7_6&quot;&gt;section 7.6&lt;/a&gt; below.</source>
          <target state="translated">롤백 저널 파일을 삭제하지 않고 저널 파일 헤더를 0으로 만드는 세 번째 최적화는 항상 독점 잠금을 유지하는 데 의존하지 않습니다. 이 최적화는 아래 &lt;a href=&quot;#section_7_6&quot;&gt;섹션 7.6에&lt;/a&gt; 설명 된 것처럼 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; 를 사용하여 배타적 잠금 모드와 독립적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="226219f131eebb1bb82e3a9e80c20160ef9e49d4" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">세 번째 매개 변수 (nArg)는 SQL 함수 또는 집계가 취하는 인수 수입니다. 이 매개 변수가 -1이면 SQL 함수 또는 집계는 0과 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; )에 의해 설정된 한계 사이에서 임의의 수의 인수를 취할 수 있습니다 . 세 번째 매개 변수가 -1보다 작거나 127보다 큰 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11f56952c8e04a9269627afb8274637d6b360ea2" translate="yes" xml:space="preserve">
          <source>The third parameter (nArg) is the number of arguments that the SQL function or aggregate takes. If this parameter is -1, then the SQL function or aggregate may take any number of arguments between 0 and the limit set by &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt;). If the third parameter is less than -1 or greater than 127 then the behavior is undefined.</source>
          <target state="translated">세 번째 매개 변수 (nArg)는 SQL 함수 또는 집계가 취하는 인수 수입니다. 이 매개 변수가 -1이면 SQL 함수 또는 집계는 0과 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c_limit_attached#sqlitelimitfunctionarg&quot;&gt;SQLITE_LIMIT_FUNCTION_ARG&lt;/a&gt; )에 의해 설정된 한계 사이에서 임의의 수의 인수를 취할 수 있습니다 . 세 번째 매개 변수가 -1보다 작거나 127보다 큰 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7effa7c199d796ec9c7957d5b06f69295ac44ef2" translate="yes" xml:space="preserve">
          <source>The third step starts with the four shortest two-node paths and finds the four shortest three-node paths:</source>
          <target state="translated">세 번째 단계는 4 개의 가장 짧은 2 노드 경로로 시작하여 4 개의 가장 짧은 3 노드 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="97390ca779620e87876318d53cdbb5c0eb4c1782" translate="yes" xml:space="preserve">
          <source>The threading mode can be selected at compile-time (when the SQLite library is being compiled from source code) or at start-time (when the application that intends to use SQLite is initializing) or at run-time (when a new SQLite database connection is being created). Generally speaking, run-time overrides start-time and start-time overrides compile-time. Except, single-thread mode cannot be overridden once selected.</source>
          <target state="translated">스레딩 모드는 컴파일 타임 (SQLite 라이브러리가 소스 코드에서 컴파일 될 때) 또는 시작 시간 (SQLite를 사용하려는 응용 프로그램이 초기화 될 때) 또는 런타임 (새 SQLite 데이터베이스 인 경우)에서 선택할 수 있습니다. 연결 중입니다). 일반적으로 런타임은 시작 시간을 재정의하고 시작 시간은 컴파일 타임을 재정의합니다. 단, 단일 스레드 모드는 일단 선택한 후에는 재정의 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a0e198fd0423256115863d78eac9cac1343e176" translate="yes" xml:space="preserve">
          <source>The threading mode for an individual database connection is determined by flags given as the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX&lt;/a&gt; flag causes the database connection to be in the multi-thread mode and the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX&lt;/a&gt; flag causes the connection to be in serialized mode. If neither flag is specified or if &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; are used instead of &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, then the default mode determined by the compile-time and start-time settings is used.</source>
          <target state="translated">개별 데이터베이스 연결의 스레딩 모드는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()에&lt;/a&gt; 대한 세 번째 인수로 지정된 플래그에 의해 결정됩니다 . &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_NOMUTEX의&lt;/a&gt; 플래그는 데이터베이스 연결이 멀티 스레드 모드로 원인과 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_FULLMUTEX의&lt;/a&gt; 플래그는 직렬화 모드로 연결됩니다. 어느 플래그가 지정된 경우, 또는 경우 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 대신에 사용된다 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; , 디폴트 모드 설정을 사용-시작 시간 컴파일 시간에 의해 결정합니다.</target>
        </trans-unit>
        <trans-unit id="a70f1f8b6fb5520108a2b27f649a3322d3c256dc" translate="yes" xml:space="preserve">
          <source>The three auxiliary functions are only useful within a SELECT statement that uses the FTS table's full-text index. If used within a SELECT that uses the &quot;query by rowid&quot; or &quot;linear scan&quot; strategies, then the snippet and offsets both return an empty string, and the matchinfo function returns a blob value zero bytes in size.</source>
          <target state="translated">세 가지 보조 함수는 FTS 테이블의 전체 텍스트 인덱스를 사용하는 SELECT 문에서만 유용합니다. &quot;rowid로 쿼리&quot;또는 &quot;선형 스캔&quot;전략을 사용하는 SELECT 내에서 스 니펫과 오프셋은 모두 빈 문자열을 반환하고 matchinfo 함수는 크기가 0 바이트 인 블롭 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6eb0a1f7b89a823f8bdbde0d13568a18262e614a" translate="yes" xml:space="preserve">
          <source>The three basic query types described above may be used to query the full-text index for the set of documents that match the specified criteria. Using the FTS query expression language it is possible to perform various set operations on the results of basic queries. There are currently three supported operations:</source>
          <target state="translated">위에서 설명한 세 가지 기본 쿼리 유형을 사용하여 지정된 기준과 일치하는 문서 집합에 대한 전체 텍스트 인덱스를 쿼리 할 수 ​​있습니다. FTS 쿼리 표현식 언어를 사용하면 기본 쿼리 결과에 대해 다양한 세트 작업을 수행 할 수 있습니다. 현재 지원되는 세 가지 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7097964beca5dc252968954049e7c0946f78e4a9" translate="yes" xml:space="preserve">
          <source>The three leftmost columns of a zipfile virtual table, &quot;name&quot;, &quot;mode&quot; and &quot;mtime&quot;, may each be set to any value that may be inserted into the same column (see above). If either &quot;mode&quot; or &quot;mtime&quot; is set to NULL, the final value is determined as described for an INSERT of a NULL value - the current time for &quot;mtime&quot; and either 33188 or 16877 for &quot;mode&quot;, depending on whether or not the values specified for the next four columns of the zipfile table indicate that the entry is a directory or a file.</source>
          <target state="translated">zipfile 가상 테이블의 가장 왼쪽 열인 &quot;name&quot;, &quot;mode&quot;및 &quot;mtime&quot;은 각각 동일한 열에 삽입 될 수있는 값으로 설정 될 수 있습니다 (위 참조). &quot;mode&quot;또는 &quot;mtime&quot;이 NULL로 설정된 경우 최종 값은 NULL 값의 INSERT에 대해 설명 된대로 결정됩니다. &quot;mtime&quot;의 현재 시간 및 &quot;mode&quot;의 경우 33188 또는 16877입니다. zipfile 테이블의 다음 네 열에 지정된 값이 아니라면 항목이 디렉토리 또는 파일임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3411dedba6408ea6c13a17f75aea9b87b7d91fad" translate="yes" xml:space="preserve">
          <source>The time string can be followed by zero or more modifiers that alter date and/or time. Each modifier is a transformation that is applied to the time value to its left. Modifiers are applied from left to right; order is important. The available modifiers are as follows.</source>
          <target state="translated">시간 문자열 다음에는 날짜 및 / 또는 시간을 변경하는 0 개 이상의 수정자가 올 수 있습니다. 각 수정자는 왼쪽의 시간 값에 적용되는 변환입니다. 수정자는 왼쪽에서 오른쪽으로 적용됩니다. 순서가 중요합니다. 사용 가능한 수정자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30024a74e5aefa6cc166b0948a8f34eea1be4641" translate="yes" xml:space="preserve">
          <source>The time taken to execute each virtual machine operation can vary based on many factors. A typical value for a 1 GHz PC is between half and three million per second but may be much higher or lower, depending on the query. As such it is difficult to schedule background operations based on virtual machine operations. Instead, it is recommended that a callback be scheduled relatively frequently (say every 1000 instructions) and external timer routines used to determine whether or not background jobs need to be run.</source>
          <target state="translated">각 가상 머신 작업을 실행하는 데 걸리는 시간은 여러 요인에 따라 달라질 수 있습니다. 1GHz PC의 일반적인 값은 초당 50 만에서 3 백만 사이이지만 쿼리에 따라 훨씬 높거나 낮을 수 있습니다. 따라서 가상 머신 작업을 기반으로 백그라운드 작업을 예약하기가 어렵습니다. 대신 콜백을 비교적 자주 예약하고 (예 : 1000 개의 명령마다) 백그라운드 작업을 실행해야하는지 여부를 결정하는 데 사용되는 외부 타이머 루틴을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d31d23c9c6ce92ba1161f4e9fe89ef4c4bc1cceb" translate="yes" xml:space="preserve">
          <source>The times reported on all tests represent wall-clock time in seconds. Two separate time values are reported for SQLite. The first value is for SQLite in its default configuration with full disk synchronization turned on. With synchronization turned on, SQLite executes an &lt;b&gt;fsync()&lt;/b&gt; system call (or the equivalent) at key points to make certain that critical data has actually been written to the disk drive surface. Synchronization is necessary to guarantee the integrity of the database if the operating system crashes or the computer powers down unexpectedly in the middle of a database update. The second time reported for SQLite is when synchronization is turned off. With synchronization off, SQLite is sometimes much faster, but there is a risk that an operating system crash or an unexpected power failure could damage the database. Generally speaking, the synchronous SQLite times are for comparison against PostgreSQL (which is also synchronous) and the asynchronous SQLite times are for comparison against the asynchronous MySQL engine.</source>
          <target state="translated">모든 테스트에서보고 된 시간은 초 단위의 벽시계 시간을 나타냅니다. SQLite에 대해 두 개의 개별 시간 값이보고됩니다. 첫 번째 값은 전체 디스크 동기화가 설정된 기본 구성의 SQLite입니다. 동기화가 설정되면 SQLite는 &lt;b&gt;fsync ()를&lt;/b&gt; 실행합니다.&lt;b&gt;&lt;/b&gt;중요한 데이터가 실제로 디스크 드라이브 표면에 기록되었는지 확인하기 위해 주요 지점에서 시스템 호출 (또는 이에 상응하는 기능). 데이터베이스 업데이트 도중 운영 체제가 충돌하거나 컴퓨터 전원이 예기치 않게 꺼지는 경우 데이터베이스의 무결성을 보장하기 위해 동기화가 필요합니다. SQLite에 대해보고 된 두 번째 시간은 동기화가 해제 된 경우입니다. 동기화를 해제하면 SQLite가 훨씬 빠르지 만 운영 체제 충돌 또는 예기치 않은 정전으로 인해 데이터베이스가 손상 될 수 있습니다. 일반적으로, 동기 SQLite 시간은 PostgreSQL (동기)과 비교하기위한 것이고 비동기 SQLite 시간은 비동기 MySQL 엔진과 비교하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fc05e4c39e5e71215073020483f372e45a3d893" translate="yes" xml:space="preserve">
          <source>The total amount of free space on a b-tree page consists of the size of the unallocated region plus the total size of all freeblocks plus the number of fragmented free bytes. SQLite may from time to time reorganize a b-tree page so that there are no freeblocks or fragment bytes, all unused bytes are contained in the unallocated space region, and all cells are packed tightly at the end of the page. This is called &quot;defragmenting&quot; the b-tree page.</source>
          <target state="translated">b- 트리 페이지의 사용 가능한 총 공간 크기는 할당되지 않은 영역의 크기와 모든 사용 가능한 블록의 전체 크기에 조각난 사용 가능한 바이트 수를 더한 값으로 구성됩니다. SQLite는 때때로 프리 블록 또는 프래그먼트 바이트가없고, 사용되지 않은 모든 바이트가 할당되지 않은 공간 영역에 포함되며 모든 셀이 페이지의 끝에 단단히 묶여 있도록 b- 트리 페이지를 재구성 할 수 있습니다. 이것을 b- 트리 페이지 &quot;조각 모음&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="460e85c11483674a3089f1a062d5d6ad1f387294" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term in the entire FTS5 table.</source>
          <target state="translated">전체 FTS5 테이블에서 용어의 총 인스턴스 수입니다.</target>
        </trans-unit>
        <trans-unit id="8456fd817ff013feb889e3e84d49e1da8d0b8117" translate="yes" xml:space="preserve">
          <source>The total number of instances of the term that appear in column $col of the FTS5 table (considering all rows).</source>
          <target state="translated">FTS5 테이블의 $ col 열에 나타나는 용어의 총 인스턴스 수입니다 (모든 행을 고려).</target>
        </trans-unit>
        <trans-unit id="8b23a01c6d0371374c2abef2c4b0a82ba4134902" translate="yes" xml:space="preserve">
          <source>The total number of pages in the btree for the current row</source>
          <target state="translated">현재 행에 대한 btree의 총 페이지 수</target>
        </trans-unit>
        <trans-unit id="6e6d24f273b69a04a7a37a510d51811f2500b867" translate="yes" xml:space="preserve">
          <source>The total number of rows in the FTS table for which the column contains at least one instance of the phrase.</source>
          <target state="translated">FTS 테이블에서 열에 하나 이상의 문구 인스턴스가 포함 된 총 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="36827e0806ceb5dc326cee16a98d2a59022e566e" translate="yes" xml:space="preserve">
          <source>The total number of times the phrase appears in the column in all rows in the FTS table.</source>
          <target state="translated">FTS 테이블의 모든 행에서 열에 문구가 나타나는 총 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="cf5b068f292efb4fb2def2e783aac8fbf8f0464d" translate="yes" xml:space="preserve">
          <source>The total_changes() function returns the number of row changes caused by INSERT, UPDATE or DELETE statements since the current database connection was opened. This function is a wrapper around the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; C/C++ interface.</source>
          <target state="translated">total_changes () 함수는 현재 데이터베이스 연결이 열린 이후 INSERT, UPDATE 또는 DELETE 문으로 인한 행 변경 수를 리턴합니다. 이 함수는 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; C / C ++ 인터페이스를 감싸는 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="e56b60d01d475c54e2abcd03a315a64862d2471f" translate="yes" xml:space="preserve">
          <source>The traditional rollback journal works by writing a copy of the original unchanged database content into a separate rollback journal file and then writing changes directly into the database file. In the event of a crash or &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;, the original content contained in the rollback journal is played back into the database file to revert the database file to its original state. The &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs when the rollback journal is deleted.</source>
          <target state="translated">기존의 롤백 저널은 변경되지 않은 원래 데이터베이스 컨텐츠의 사본을 별도의 롤백 저널 파일에 기록한 다음 변경 사항을 데이터베이스 파일에 직접 기록하여 작동합니다. 충돌 또는 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK의&lt;/a&gt; 경우 롤백 저널에 포함 된 원래 컨텐츠가 데이터베이스 파일로 재생되어 데이터베이스 파일을 원래 상태로 되돌립니다. 는 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 롤백 저널이 삭제 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa45945065730186850cef64d952ee165c9cc090" translate="yes" xml:space="preserve">
          <source>The traditional way of communicating this information was to transform a C-language pointer into a BLOB or a 64-bit integer, then move that BLOB or integer through SQLite using the usual interfaces like &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;, &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt; or the integer equivalents.</source>
          <target state="translated">이 정보를 전달하는 전통적인 방법은 C 언어 포인터를 BLOB 또는 64 비트 정수로 변환 한 다음 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; , &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; 또는 정수 등가</target>
        </trans-unit>
        <trans-unit id="c2d0f49e1ec0a4672583f25736f97bcbd3e6ba07" translate="yes" xml:space="preserve">
          <source>The transaction command can be used to group together several SQLite commands in a safe way. You can always start transactions manually using BEGIN, of course. But if an error occurs so that the COMMIT or ROLLBACK are never run, then the database will remain locked indefinitely. Also, BEGIN does not nest, so you have to make sure no other transactions are active before starting a new one. The &quot;transaction&quot; method takes care of all of these details automatically.</source>
          <target state="translated">트랜잭션 명령을 사용하여 여러 SQLite 명령을 안전하게 그룹화 할 수 있습니다. 물론 BEGIN을 사용하여 수동으로 거래를 시작할 수 있습니다. 그러나 COMMIT 또는 ROLLBACK이 실행되지 않도록 오류가 발생하면 데이터베이스는 무기한으로 잠금 상태를 유지합니다. 또한 BEGIN은 중첩되지 않으므로 새 트랜잭션을 시작하기 전에 다른 트랜잭션이 활성화되어 있지 않은지 확인해야합니다. &quot;트랜잭션&quot;방법은 이러한 모든 세부 사항을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="66431b524eb3e3d97e40f460537f3aa544382bf9" translate="yes" xml:space="preserve">
          <source>The transaction has already committed at this point so timing is not critical in the deletion of the rollback journals. The current implementation deletes a single rollback journal then unlocks the corresponding database file before proceeding to the next rollback journal. But in the future we might change this so that all rollback journals are deleted before any database files are unlocked. As long as the rollback journal is deleted before its corresponding database file is unlocked it does not matter in what order the rollback journals are deleted or the database files are unlocked.</source>
          <target state="translated">이 시점에서 트랜잭션이 이미 커밋되었으므로 롤백 저널 삭제시 타이밍이 중요하지 않습니다. 현재 구현은 단일 롤백 저널을 삭제 한 후 다음 롤백 저널로 진행하기 전에 해당 데이터베이스 파일을 잠금 해제합니다. 그러나 앞으로는 데이터베이스 파일을 잠금 해제하기 전에 모든 롤백 저널이 삭제되도록이를 변경할 수 있습니다. 해당 데이터베이스 파일이 잠금 해제되기 전에 롤백 저널이 삭제되는 한 롤백 저널이 삭제되거나 데이터베이스 파일이 잠금 해제되는 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="439b3c25010ac483338852bbf167e17f82acaecb" translate="yes" xml:space="preserve">
          <source>The transformation converts each vertex of the polygon according to the following formula:</source>
          <target state="translated">변환은 다음 공식에 따라 다각형의 각 정점을 변환합니다.</target>
        </trans-unit>
        <trans-unit id="970a22ffd83744a201d5b074bf5b2eed9b68c352" translate="yes" xml:space="preserve">
          <source>The transient table in which the result is built is created by instruction 0. Three loops then follow. The loop at instructions 5 through 10 implements the first SELECT statement. The second SELECT statement is implemented by the loop at instructions 14 through 19. Finally, a loop at instructions 22 through 25 reads the transient table and invokes the callback once for each row in the result.</source>
          <target state="translated">결과가 작성되는 임시 테이블은 명령 0으로 작성됩니다. 그런 다음 세 개의 루프가 이어집니다. 명령어 5-10의 루프는 첫 번째 SELECT 문을 구현합니다. 두 번째 SELECT 문은 명령 14-19에서 루프로 구현됩니다. 마지막으로 명령 22-25의 루프는 임시 테이블을 읽고 결과의 각 행에 대해 콜백을 한 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="952fc2249e617c46359543a66e348109d3087d3d" translate="yes" xml:space="preserve">
          <source>The transient table in which the results of the inner SELECT are stored is created by the &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; instruction at 0. This opcode is used for tables that exist for the duration of a single SQL statement only. The transient cursor is always opened read/write even if the main database is read-only. The transient table is deleted automatically when the cursor is closed. The P2 value of 1 means the cursor points to a BTree index, which has no data but can have an arbitrary key.</source>
          <target state="translated">내부 SELECT의 결과가 저장되는 임시 테이블은 &lt;a href=&quot;opcode#OpenTemp&quot;&gt;OpenTemp&lt;/a&gt; 명령에 의해 0에 작성됩니다. 이 opcode는 단일 SQL 문 기간 동안 존재하는 테이블에 사용됩니다. 기본 데이터베이스가 읽기 전용 인 경우에도 임시 커서는 항상 읽기 / 쓰기로 열립니다. 커서가 닫히면 임시 테이블이 자동으로 삭제됩니다. P2 값 1은 커서가 데이터는 없지만 임의의 키를 가질 수있는 BTree 인덱스를 가리킴을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="592350be0cb11625e2bd092767c6171c56d03c65" translate="yes" xml:space="preserve">
          <source>The transition from SQLite version 3.4.2 to 3.5.0 is a major change. Every source code file in the SQLite core had to be modified, some extensively. And the change introduced some minor incompatibilities in the C interface. But we feel that the benefits of the transition from 3.4.2 to 3.5.0 far outweigh the pain of porting. The new VFS layer is now well-defined and stable and should simplify future customizations. The VFS layer, and the separable memory allocator and mutex subsystems allow a standard SQLite source code amalgamation to be used in an embedded project without change, greatly simplifying configuration management. And the resulting system is much more tolerant of highly threaded designs.</source>
          <target state="translated">SQLite 버전 3.4.2에서 3.5.0으로의 전환이 크게 변경되었습니다. SQLite 코어의 모든 소스 코드 파일은 광범위하게 수정되어야했습니다. 그리고이 변경으로 인해 C 인터페이스에서 약간의 비 호환성이 발생했습니다. 그러나 우리는 3.4.2에서 3.5.0으로의 전환의 이점이 이식의 고통보다 훨씬 크다고 생각합니다. 새로운 VFS 계층은 이제 잘 정의되고 안정적이며 향후 사용자 지정을 단순화해야합니다. VFS 계층과 분리 가능한 메모리 할당 기 및 뮤텍스 하위 시스템을 통해 표준 SQLite 소스 코드 통합을 변경없이 포함 된 프로젝트에서 사용할 수 있으므로 구성 관리가 크게 간소화됩니다. 그리고 결과 시스템은 높은 스레드 설계에 훨씬 더 견딜 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0ecdf62ac64721b60f0c811bc6ae15d2a3d1b27" translate="yes" xml:space="preserve">
          <source>The trick here is the -DTCLSH=1 option. The TCL interface module for SQLite includes a &lt;b&gt;main()&lt;/b&gt; procedure that initializes a TCL interpreter and enters a command-line loop when it is compiled with -DTCLSH=1. The command above works on both Linux and Mac OS X, though one may need to adjust the library options depending on the platform and which version of TCL one is linking against.</source>
          <target state="translated">트릭은 -DTCLSH = 1 옵션입니다. SQLite 용 TCL 인터페이스 모듈에는 TCL 인터프리터를 초기화하고 -DTCLSH = 1로 컴파일 될 때 명령 행 루프를 입력 하는 &lt;b&gt;main ()&lt;/b&gt; 프로 시저가 포함되어 있습니다. 위의 명령은 Linux 및 Mac OS X에서 모두 작동하지만 플랫폼 및 TCL 버전에 따라 라이브러리 옵션을 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc5d00c95debe18bbcee9e720337d19dcab11f5a" translate="yes" xml:space="preserve">
          <source>The trigger created by the previous statement is named &quot;AFTER&quot; and it is a &quot;BEFORE&quot; trigger. The &quot;AFTER&quot; token is used as an identifier instead of as a keyword, as that is the only way to parse the statement. Another example:</source>
          <target state="translated">이전 명령문에 의해 생성 된 트리거의 이름은 &quot;AFTER&quot;이며 &quot;BEFORE&quot;트리거입니다. &quot;AFTER&quot;토큰은 문을 구문 분석하는 유일한 방법이므로 키워드 대신 식별자로 사용됩니다. 다른 예시:</target>
        </trans-unit>
        <trans-unit id="3b9b7cf0a7967eed621bbbad3863190e29c44d61" translate="yes" xml:space="preserve">
          <source>The trim(X,Y) function returns a string formed by removing any and all characters that appear in Y from both ends of X. If the Y argument is omitted, trim(X) removes spaces from both ends of X.</source>
          <target state="translated">trim (X, Y) 함수는 X의 양쪽 끝에서 Y에 나타나는 모든 문자를 제거하여 형성된 문자열을 반환합니다. Y 인수가 생략되면 trim (X)는 X의 양쪽 끝에서 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="02041028dd7a37adeacbb35b1200b0b1a6b27a53" translate="yes" xml:space="preserve">
          <source>The true primary key for a rowid table (the value that is used as the key to look up rows in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine) is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;.</source>
          <target state="translated">rowid 테이블의 실제 기본 키 (기본 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 스토리지 엔진 에서 행을 조회하는 키로 사용되는 값 )는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f9dae6c570b0f408d716bb105a5e25850cccf9f" translate="yes" xml:space="preserve">
          <source>The truncate optimization can also be disabled at runtime using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface. If an authorizer callback returns &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; for an &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; action code, then the DELETE operation will proceed but the truncate optimization will be bypassed and rows will be deleted one by one.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 절단 최적화를 비활성화 할 수도 있습니다 . 권한 부 여자 콜백 이 &lt;a href=&quot;c3ref/c_alter_table&quot;&gt;SQLITE_DELETE&lt;/a&gt; 조치 코드에 대해 &lt;a href=&quot;c3ref/c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; 를 리턴 하면 DELETE 조작은 진행되지만 절단 최적화는 생략되고 행은 하나씩 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="7489f83785acf46d79dbedce76141d020e3a30b4" translate="yes" xml:space="preserve">
          <source>The truncate optimization can be permanently disabled for all queries by recompiling SQLite with the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time switch.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; 컴파일 타임 스위치를 사용하여 SQLite를 다시 컴파일하면 모든 쿼리에 대해 잘림 최적화를 영구적으로 사용하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="30f49567fa43c7d2e5e26ee8efe4338c93c45898" translate="yes" xml:space="preserve">
          <source>The trusted_schema setting is a per-connection boolean that determines whether or not SQL functions and virtual tables that have not been security audited are allowed to be run by views, triggers, or in expressions of the schema such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, and/or &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;. This setting can also be controlled using the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,...) C-language interface.</source>
          <target state="translated">trusted_schema 설정은 뷰에 의해 운영 될 수 있습니다 감사 보안되지 않았습니다 여부 SQL 기능과 가상 테이블을 결정하는 당 연결 부울이다, 트리거, 또는 같은 스키마의 표현에 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;gencol&quot;&gt;생성 열&lt;/a&gt; , &lt;a href=&quot;expridx&quot;&gt;표현식 색인&lt;/a&gt; 및 / 또는 &lt;a href=&quot;partialindex&quot;&gt;부분 색인&lt;/a&gt; . 이 설정은 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; , ...) C 언어 인터페이스를 사용하여 제어 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e242c8734781e20213900394ec30db10b58ee560" translate="yes" xml:space="preserve">
          <source>The two &quot;0&quot; parameters do server a purpose in some contexts, but for using these routine to print a parse tree as ASCII-art on the terminal, they should both be &quot;0&quot;.</source>
          <target state="translated">두 가지 &quot;0&quot;매개 변수는 일부 상황에서 서버를 목적으로 사용하지만 이러한 루틴을 사용하여 구문 분석 트리를 터미널에서 ASCII 아트로 인쇄하려면 둘 다 &quot;0&quot;이어야합니다.</target>
        </trans-unit>
        <trans-unit id="46623d6b4b79b06cc3078e791041446a91edf407" translate="yes" xml:space="preserve">
          <source>The two 4-byte big-endian integers at offsets 52 and 64 are used to manage the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes. If the integer at offset 52 is zero then pointer-map (ptrmap) pages are omitted from the database file and neither auto_vacuum nor incremental_vacuum are supported. If the integer at offset 52 is non-zero then it is the page number of the largest root page in the database file, the database file will contain ptrmap pages, and the mode must be either auto_vacuum or incremental_vacuum. In this latter case, the integer at offset 64 is true for incremental_vacuum and false for auto_vacuum. If the integer at offset 52 is zero then the integer at offset 64 must also be zero.</source>
          <target state="translated">오프셋 52 및 64에서 2 개의 4 바이트 빅 엔디안 정수는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 모드 를 관리하는 데 사용됩니다 . 오프셋 52의 정수가 0이면 포인터 맵 (ptrmap) 페이지가 데이터베이스 파일에서 생략되고 auto_vacuum 또는 incremental_vacuum이 지원되지 않습니다. 오프셋 52의 정수가 0이 아닌 경우 데이터베이스 파일에서 가장 큰 루트 페이지의 페이지 번호이며 데이터베이스 파일에는 ptrmap 페이지가 포함되며 모드는 auto_vacuum 또는 incremental_vacuum이어야합니다. 후자의 경우 오프셋 64의 정수는 incremental_vacuum의 경우 true이고 auto_vacuum의 경우 false입니다. 오프셋 52의 정수가 0이면 오프셋 64의 정수도 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d5cec8b4b21ae2b9d4802acdeb66477068dae88" translate="yes" xml:space="preserve">
          <source>The two &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; are:</source>
          <target state="translated">두 가지 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60d1d8fda3bbd4cfca022cc996f0d5a823d5b6ed" translate="yes" xml:space="preserve">
          <source>The two exceptions are:</source>
          <target state="translated">두 가지 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1f0bf58781420b540ac606f0e7579a8a2be4378" translate="yes" xml:space="preserve">
          <source>The two fragments of SQL below are similar, but not entirely equivalent, as the latter will fail if the definition of window &quot;win&quot; contains a frame specification.</source>
          <target state="translated">윈도우 &quot;win&quot;정의에 프레임 스펙이 포함되어 있으면 후자의 SQL이 실패하므로 아래의 두 SQL 조각은 비슷하지만 완전히 동일하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9a92735a6c1a485477340ad1399f41bdfef6983" translate="yes" xml:space="preserve">
          <source>The two remaining tables, %_segments and %_segdir, are used to store the full-text index. Conceptually, this index is a lookup table that maps each term (word) to the set of docid values corresponding to records in the %_content table that contain one or more occurrences of the term. To retrieve all documents that contain a specified term, the FTS module queries this index to determine the set of docid values for records that contain the term, then retrieves the required documents from the %_content table. Regardless of the schema of the FTS virtual table, the %_segments and %_segdir tables are always created as follows:</source>
          <target state="translated">나머지 두 테이블 인 % _segments 및 % _segdir은 전체 텍스트 인덱스를 저장하는 데 사용됩니다. 개념적으로이 인덱스는 각 용어 (워드)를 하나 이상의 용어가 포함 된 % _content 테이블의 레코드에 해당하는 docid 값 집합에 매핑하는 조회 테이블입니다. 지정된 용어가 포함 된 모든 문서를 검색하기 위해 FTS 모듈은이 인덱스를 쿼리하여 용어가 포함 된 레코드의 문서 값 집합을 결정한 다음 % _content 테이블에서 필요한 문서를 검색합니다. FTS 가상 테이블의 스키마에 관계없이 % _segments 및 % _segdir 테이블은 항상 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="57eb59a7de5c1f2eacd1a8c2e2793991396d4104" translate="yes" xml:space="preserve">
          <source>The two salt value copied from the WAL file header. These values are in the byte-order of the WAL file, which might be different from the native byte-order of the machine.</source>
          <target state="translated">WAL 파일 헤더에서 복사 된 2 개의 솔트 값입니다. 이 값은 WAL 파일의 바이트 순서이며 시스템의 기본 바이트 순서와 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccc9e431ebc7fabfa6726082e51ef8838fff247f" translate="yes" xml:space="preserve">
          <source>The two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; accepts a pointer to the tokenizer method object even without the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;) setting if the second argument is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 의 두 인수 버전은 두 번째 인수가 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인드 된 매개 변수 인&lt;/a&gt; 경우 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; ) 설정 없이도 토크 나이저 메소드 오브젝트에 대한 포인터를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6b8d35e3a824a79bc7ce101b6a6ae7997418f4f7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 1 gives the start of the first freeblock on the page, or is zero if there are no freeblocks.</source>
          <target state="translated">오프셋 1의 2 바이트 정수는 페이지에서 첫 번째 여유 블록의 시작을 제공하거나 여유 블록이없는 경우 0입니다.</target>
        </trans-unit>
        <trans-unit id="c4473928239ae1bda74a9fb4bb8276860fc5ffb5" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 3 gives the number of cells on the page.</source>
          <target state="translated">오프셋 3의 2 바이트 정수는 페이지의 셀 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a06521372b9101f2c70d6a3c29239fdaf5cbc5a7" translate="yes" xml:space="preserve">
          <source>The two-byte integer at offset 5 designates the start of the cell content area. A zero value for this integer is interpreted as 65536.</source>
          <target state="translated">오프셋 5의 2 바이트 정수는 셀 내용 영역의 시작을 나타냅니다. 이 정수의 0 값은 65536으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="85da2eb104aa5ac23b3d2218d186677a6dbc8b7e" translate="yes" xml:space="preserve">
          <source>The two-byte value beginning at offset 16 determines the page size of the database. For SQLite versions 3.7.0.1 (2010-08-04) and earlier, this value is interpreted as a big-endian integer and must be a power of two between 512 and 32768, inclusive. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;version 3.7.1&lt;/a&gt; (2010-08-23), a page size of 65536 bytes is supported. The value 65536 will not fit in a two-byte integer, so to specify a 65536-byte page size, the value at offset 16 is 0x00 0x01. This value can be interpreted as a big-endian 1 and thought of as a magic number to represent the 65536 page size. Or one can view the two-byte field as a little endian number and say that it represents the page size divided by 256. These two interpretations of the page-size field are equivalent.</source>
          <target state="translated">오프셋 16에서 시작하는 2 바이트 값은 데이터베이스의 페이지 크기를 결정합니다. SQLite 버전 3.7.0.1 (2010-08-04) 이하의 경우이 값은 빅 엔디안 정수로 해석되며 512에서 32768 사이의 2의 제곱이어야합니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_1.html&quot;&gt;버전 3.7.1&lt;/a&gt; (2010-08-23) 부터는 페이지 크기 65536 바이트가 지원됩니다. 65536 값은 2 바이트 정수에 맞지 않으므로 65536 바이트 페이지 크기를 지정하려면 오프셋 16의 값은 0x00 0x01입니다. 이 값은 빅 엔디안 1로 해석 될 수 있으며 65536 페이지 크기를 나타내는 마법의 숫자로 생각됩니다. 또는 2 바이트 필드를 리틀 엔디안 숫자로보고 페이지 크기를 256으로 나눈 값을 나타냅니다.이 두 페이지 크기 필드 해석은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="d620a0d4c1327669927184e30780adb142926606" translate="yes" xml:space="preserve">
          <source>The typedef is necessary to work around problems in certain C++ compilers.</source>
          <target state="translated">특정 C ++ 컴파일러에서 문제를 해결하려면 typedef가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2acee6be58c92d0d4d1c18a3c705f7ce6eca583d" translate="yes" xml:space="preserve">
          <source>The typeof(X) function returns a string that indicates the &lt;a href=&quot;datatype3&quot;&gt;datatype&lt;/a&gt; of the expression X: &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;, or &quot;blob&quot;.</source>
          <target state="translated">typeof (X) 함수는 표현식 X 의 &lt;a href=&quot;datatype3&quot;&gt;데이터 유형&lt;/a&gt; &quot;null&quot;, &quot;integer&quot;, &quot;real&quot;, &quot;text&quot;또는 &quot;blob&quot; 를 나타내는 문자열을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7de0eb427df1bd72e4d6981f084f01d2fd7b104b" translate="yes" xml:space="preserve">
          <source>The types and default collation sequences attached to each column must be the same for all component tables.</source>
          <target state="translated">각 열에 첨부 된 유형 및 기본 데이터 정렬 순서는 모든 구성 요소 테이블에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="7a193d6baad5e9eae89c634a076cd20d9e39a2d0" translate="yes" xml:space="preserve">
          <source>The unary operator</source>
          <target state="translated">단항 연산자</target>
        </trans-unit>
        <trans-unit id="5de3e6de824f9a3c28afdefed054e3e170c8e0d8" translate="yes" xml:space="preserve">
          <source>The uncompress function should uncompress data previously compressed by the compress function. In other words, for all SQLite values X, it should be true that uncompress(compress(X)) equals X. When data that has been compressed by the compress function is read from the database by FTS4, it is passed to the uncompress function before it is used.</source>
          <target state="translated">압축 해제 기능은 압축 기능에 의해 이전에 압축 된 데이터를 압축 해제해야합니다. 다시 말해, 모든 SQLite 값 X에 대해 uncompress (compress (X))가 X와 같다는 것이 사실이어야합니다. 압축 함수로 압축 된 데이터를 FTS4가 데이터베이스에서 읽을 때 압축 해제 기능으로 전달됩니다. 사용하기 전에.</target>
        </trans-unit>
        <trans-unit id="04cb6e28b7a92f43a8ce66195a1ea7614bfeaae5" translate="yes" xml:space="preserve">
          <source>The underlying implementation can support some subset of these locking levels as long as it meets the other requirements of this paragraph. The locking level is specified as the second argument to both xLock and xUnlock. The xLock method increases the locking level to the specified locking level or higher. The xUnlock method decreases the locking level to no lower than the level specified. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; means that the file is unlocked. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; gives permission to read the file. Multiple database connections can hold &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; at the same time. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; is like &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; in that it is permission to read the file. But only a single connection can hold a reserved lock at any point in time. The &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING&lt;/a&gt; is also permission to read the file. Other connections can continue to read the file as well, but no other connection is allowed to escalate a lock from none to shared. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; is permission to write on the file. Only a single connection can hold an exclusive lock and no other connection can hold any lock (other than &quot;none&quot;) while one connection holds an exclusive lock. The xLock returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if it is unable to obtain the lock, or &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK&lt;/a&gt; if something else goes wrong. The xUnlock method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; for problems.</source>
          <target state="translated">기본 구현은이 단락의 다른 요구 사항을 충족하는 한 이러한 잠금 수준의 일부를 지원할 수 있습니다. 잠금 수준은 xLock 및 xUnlock에 대한 두 번째 인수로 지정됩니다. xLock 메소드는 잠금 레벨을 지정된 잠금 레벨 이상으로 증가시킵니다. xUnlock 메소드는 잠금 레벨을 지정된 레벨 이상으로 줄입니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_NONE&lt;/a&gt; 은 파일이 잠금 해제 되었음을 의미합니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; 는 파일을 읽을 수있는 권한을 부여합니다. 다중 데이터베이스 연결은 &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_SHARED&lt;/a&gt; 를 동시에 보유 할 수 있습니다 . &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_RESERVED&lt;/a&gt; 는 SQLITE_LOCK_SHARED 와 &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;같습니다.&lt;/a&gt;파일을 읽을 수있는 권한이라는 점에서 그러나 어느 시점에서든 단일 연결 만 예약 잠금을 유지할 수 있습니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_PENDING는&lt;/a&gt; 또한 파일을 읽을 수있는 권한입니다. 다른 연결에서도 파일을 계속 읽을 수 있지만 다른 연결에서는 잠금을 없음에서 공유로 에스컬레이션 할 수 없습니다. &lt;a href=&quot;c3ref/c_lock_exclusive&quot;&gt;SQLITE_LOCK_EXCLUSIVE&lt;/a&gt; 는 파일에 쓸 수있는 권한입니다. 단일 연결 만 단독 잠금을 보유 할 수 있으며 다른 연결은 &quot;없음&quot;이외의 다른 잠금을 보유 할 수 없지만 한 연결은 단독 잠금을 보유합니다. XLOCK 반환 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK을&lt;/a&gt; , 성공 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 는 잠금, 또는 취득 할 수없는 경우 &lt;a href=&quot;rescode#ioerr_rdlock&quot;&gt;SQLITE_IOERR_RDLOCK을&lt;/a&gt; 다른 뭔가가 잘못되면. xUnlock 메소드는&lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 성공에 &lt;a href=&quot;rescode#ioerr_unlock&quot;&gt;SQLITE_IOERR_UNLOCK&lt;/a&gt; 문제.</target>
        </trans-unit>
        <trans-unit id="0269000c82eb39065f294879a620aecf2c6e833d" translate="yes" xml:space="preserve">
          <source>The underscore character (unicode codepoint 96).</source>
          <target state="translated">밑줄 문자 (유니 코드 코드 포인트 96).</target>
        </trans-unit>
        <trans-unit id="94b1d236b1b1bdea969b9f218085fccfc7fb6de3" translate="yes" xml:space="preserve">
          <source>The undo::activate command creates temporary triggers in the database that record all changes made to the tables named in the arguments.</source>
          <target state="translated">undo :: activate 명령은 인수에 이름이 지정된 테이블의 모든 변경 사항을 기록하는 임시 트리거를 데이터베이스에 작성합니다.</target>
        </trans-unit>
        <trans-unit id="9d719f9a44e55c933ab5b5fa11156ee426d1545d" translate="yes" xml:space="preserve">
          <source>The undocumented &lt;b&gt;sqlite3_os_switch()&lt;/b&gt; interface has been removed.</source>
          <target state="translated">문서화되지 않은 &lt;b&gt;sqlite3_os_switch ()&lt;/b&gt; 인터페이스가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="93cdbdaae25242141056e83b2feecd9f656881a8" translate="yes" xml:space="preserve">
          <source>The unicode tokenizer classifies all unicode characters as either &quot;separator&quot; or &quot;token&quot; characters. By default all space and punctuation characters, as defined by Unicode 6.1, are considered separators, and all other characters as token characters. More specifically, all unicode characters assigned to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt; general category&lt;/a&gt; beginning with &quot;L&quot; or &quot;N&quot; (letters and numbers, specifically) or to category &quot;Co&quot; (&quot;other, private use&quot;) are considered tokens. All other characters are separators.</source>
          <target state="translated">유니 코드 토크 나이 저는 모든 유니 코드 문자를 &quot;구분자&quot;또는 &quot;토큰&quot;문자로 분류합니다. 기본적으로 유니 코드 6.1에 정의 된대로 모든 공백 및 문장 부호 문자는 구분 기호로 간주되고 다른 모든 문자는 토큰 문자로 간주됩니다. 보다 구체적으로, &quot;L&quot;또는 &quot;N&quot;(특히 문자 및 숫자)으로 시작 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Unicode_character_property#General_Category&quot;&gt;일반 범주&lt;/a&gt; 또는 &quot;Co&quot;( &quot;기타 개인 용도&quot;) 범주에 할당 된 모든 유니 코드 문자 는 토큰으로 간주됩니다. 다른 모든 문자는 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="8359d1281537e2db390ccb27a011cf0c1e07387b" translate="yes" xml:space="preserve">
          <source>The unicode(X) function returns the numeric unicode code point corresponding to the first character of the string X. If the argument to unicode(X) is not a string then the result is undefined.</source>
          <target state="translated">unicode (X) 함수는 문자열 X의 첫 번째 문자에 해당하는 숫자 유니 코드 코드 포인트를 리턴합니다. unicode (X)에 대한 인수가 문자열이 아닌 경우 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b06912261f5bb2d984a2ea7d12c5ea40ed3062a1" translate="yes" xml:space="preserve">
          <source>The union-vtab is not built into SQLite. Union-vtab is a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;. The source code for union-vtab is contained in a single file located at &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext/misc/unionvtab.c&lt;/a&gt; in the SQLite source tree.</source>
          <target state="translated">union-vtab은 SQLite에 내장되어 있지 않습니다. Union-vtab은 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 입니다. union-vtab의 소스 코드 는 SQLite 소스 트리의 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;ext / misc / unionvtab.c&lt;/a&gt; 에 있는 단일 파일에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70f606d5ad9373cd7360030770268b87dc04b4a8" translate="yes" xml:space="preserve">
          <source>The union-vtab is read-only. Support for writing may be added at a later time, but writing is not a part of the initial implementation.</source>
          <target state="translated">union-vtab은 읽기 전용입니다. 쓰기 지원은 나중에 추가 될 수 있지만 쓰기는 초기 구현의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="217c127b8d7dc9166357c6c852e4edb92e8bd2cc" translate="yes" xml:space="preserve">
          <source>The union-vtab shall optimize access to the underlying real tables when the constraints on the query are among forms shown below. Other kinds of constraints may be optimized in the future, but only these constraints are optimized in the initial implementation.</source>
          <target state="translated">union-vtab은 쿼리의 제약 조건이 아래에 표시된 형식 중 하나 인 경우 기본 실제 테이블에 대한 액세스를 최적화해야합니다. 앞으로 다른 종류의 제약이 최적화 될 수 있지만 초기 구현에서는 이러한 제약 만이 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="5ad25f83f6534911bf90077b4a8c2d24284bf894" translate="yes" xml:space="preserve">
          <source>The unique id (INTEGER PRIMARY KEY)</source>
          <target state="translated">고유 ID (INTEGER PRIMARY KEY)</target>
        </trans-unit>
        <trans-unit id="37c73afc15f55751239631e696091c5fb7a86756" translate="yes" xml:space="preserve">
          <source>The unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; will never use a file descriptor less than</source>
          <target state="translated">유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 파일 디스크립터를</target>
        </trans-unit>
        <trans-unit id="ae8287e8b161fa1549dd3442fa8607f53d8dfe62" translate="yes" xml:space="preserve">
          <source>The unlikely(X) function returns the argument X unchanged. The unlikely(X) function is a no-op that the code generator optimizes away so that it consumes no CPU cycles at run-time (that is, during calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;). The purpose of the unlikely(X) function is to provide a hint to the query planner that the argument X is a boolean value that is usually not true. The unlikely(X) function is equivalent to &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood&lt;/a&gt;(X, 0.0625).</source>
          <target state="translated">unlikely (X) 함수는 변경되지 않은 인수 X를 리턴합니다. 가능하지 않은 (X) 함수는 코드 생성기가 최적화하여 런타임에 (즉, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 호출하는 동안) CPU주기를 소비하지 않도록 최적화 합니다. unlikely (X) 함수의 목적은 쿼리 플래너에 인수 X가 일반적으로 true가 아닌 부울 값이라는 힌트를 제공하는 것입니다. 가능하지 않은 (X) 함수는 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;가능성&lt;/a&gt; (X, 0.0625)과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f74bf3865d4b8d380ed09cdf9682ebd8ba365f80" translate="yes" xml:space="preserve">
          <source>The unlock-notify callback is not reentrant. If an application invokes any sqlite3_xxx API functions from within an unlock-notify callback, a crash or deadlock may be the result.</source>
          <target state="translated">잠금 해제 알림 콜백은 재진입이 아닙니다. 애플리케이션이 unlock-notify 콜백 내에서 sqlite3_xxx API 함수를 호출하면 충돌 또는 교착 상태가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f10c2e623337226e56371f152fe9704c596a75e" translate="yes" xml:space="preserve">
          <source>The unlock_notify method is used access the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface to the SQLite core library for testing purposes. The use of this method by applications is discouraged.</source>
          <target state="translated">unlock_notify 메소드는 테스트 목적으로 SQLite 코어 라이브러리에 대한 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스에 액세스하는 데 사용 됩니다. 응용 프로그램에서이 방법을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0db7fcedecb648c350c1b6f11ba954f23165737" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">업데이트 후크 구현은 업데이트 후크를 호출 한 데이터베이스 연결을 수정하는 작업을 수행하지 않아야합니다. 데이터베이스 연결을 수정하기위한 모든 조치 는 업데이트 후크를 트리거 한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출이 완료 될 때까지 연기되어야합니다 . 참고 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="09532968164962481e11046837aaa8bacbe59ea0" translate="yes" xml:space="preserve">
          <source>The update hook implementation must not do anything that will modify the database connection that invoked the update hook. Any actions to modify the database connection must be deferred until after the completion of the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; call that triggered the update hook. Note that &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; both modify their database connections for the meaning of &quot;modify&quot; in this paragraph.</source>
          <target state="translated">업데이트 후크 구현은 업데이트 후크를 호출 한 데이터베이스 연결을 수정하는 작업을 수행하지 않아야합니다. 데이터베이스 연결을 수정하기위한 모든 조치 는 업데이트 후크를 트리거 한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출이 완료 될 때까지 연기되어야합니다 . 참고 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 와 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()를&lt;/a&gt; 모두이 항에서 &quot;수정&quot;의 의미에 대한 자신의 데이터베이스 연결을 수정합니다.</target>
        </trans-unit>
        <trans-unit id="f188e349260d6d862bd1151de1aa0b41c96135c8" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 (예 : sqlite_master 및 sqlite_sequence) 업데이트 후크가 호출되지 않습니다. &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d4c3b215f10d00c42f1094ebb70e270136be0ef6" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_master and sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 (예 : sqlite_master 및 sqlite_sequence) 업데이트 후크가 호출되지 않습니다. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f04fa9936d514fac1b991da703764bce23461785" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 (예 : sqlite_sequence). &lt;a href=&quot;../withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 되면 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8b14dc5637688b2512ff9a25b9caa046cb0c8fc2" translate="yes" xml:space="preserve">
          <source>The update hook is not invoked when internal system tables are modified (i.e. sqlite_sequence). The update hook is not invoked when &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables are modified.</source>
          <target state="translated">내부 시스템 테이블이 수정 될 때 업데이트 후크가 호출되지 않습니다 (예 : sqlite_sequence). &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블이 수정 되면 업데이트 후크가 호출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7b3d709a5bf6d8d9c48b677160252ac4da74295a" translate="yes" xml:space="preserve">
          <source>The upper bound on the database &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache size&lt;/a&gt; has traditionally defaulted to 2000 pages. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; also changes this default setting to be &quot;-2000&quot; which means 2000*1024 bytes, regardless of page size. So, the upper bound on the amount of memory used for the page cache is unchanged.</source>
          <target state="translated">데이터베이스 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;캐시 크기&lt;/a&gt; 의 상한 은 기본적으로 2000 페이지로 기본 설정되었습니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; 은이 기본 설정을 &quot;-2000&quot;으로 변경하여 페이지 크기에 관계없이 2000 * 1024 바이트를 의미합니다. 따라서 페이지 캐시에 사용 된 메모리 양의 상한은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55e210be964a43ed3f79f81acfb0252d2ec508a2" translate="yes" xml:space="preserve">
          <source>The upper(X) function returns a copy of input string X in which all lower-case ASCII characters are converted to their upper-case equivalent.</source>
          <target state="translated">upper (X) 함수는 모든 소문자 ASCII 문자가 대문자로 변환되는 입력 문자열 X의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2ff3bb49a7df2e57465c506adbfbac36859c676c" translate="yes" xml:space="preserve">
          <source>The upsert above inserts the new vocabulary word &quot;jovial&quot; if that word is not already in the dictionary, or if it is already in the dictionary, it increments the counter. The &quot;count+1&quot; expression could also be written as &quot;vocabulary.count&quot;. PostgreSQL requires the second form, but SQLite accepts either.</source>
          <target state="translated">위의 upsert는 해당 단어가 사전에 없거나 사전에 있으면 새 어휘 &quot;jovial&quot;을 삽입합니다. &quot;count + 1&quot;표현식은 &quot;vocabulary.count&quot;로 쓸 수도 있습니다. PostgreSQL에는 두 번째 형식이 필요하지만 SQLite는 두 가지 형식 중 하나를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f98914d65daf1eee948f9cf4215d1bc155ef41fa" translate="yes" xml:space="preserve">
          <source>The usage of pagecache memory is somewhat harder to control in SQLite version 3.6.1, though mechanisms are planned for subsequent releases that will make controlling pagecache memory much easier. Prior to the introduction of these new mechanisms, the only way to control pagecache memory is using the &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma&lt;/a&gt;.</source>
          <target state="translated">페이지 캐시 메모리의 사용은 SQLite 버전 3.6.1에서 제어하기가 다소 어렵지만 페이지 캐시 메모리를 훨씬 쉽게 제어 할 수있는 후속 릴리스에 대한 메커니즘이 계획되어 있습니다. 이러한 새로운 메커니즘을 도입하기 전에 pagecache 메모리를 제어하는 ​​유일한 방법은 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;cache_size pragma를&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="83c37f6e9e518d22e126d6f49713b321c1f31d9b" translate="yes" xml:space="preserve">
          <source>The use of &quot;:&quot; instead of &quot;$&quot; before the name of a variable can sometimes be useful if the SQL text is enclosed in double-quotes &quot;...&quot; instead of curly-braces {...}. When the SQL is contained within double-quotes &quot;...&quot; then TCL will do the substitution of $-variables, which can lead to SQL injection if extreme care is not used. But TCL will never substitute a :-variable regardless of whether double-quotes &quot;...&quot; or curly-braces {...} are used to enclose the SQL, so the use of :-variables adds an extra measure of defense against SQL injection.</source>
          <target state="translated">변수 이름 앞에 &quot;$&quot;대신 &quot;:&quot;을 사용하면 SQL 텍스트가 중괄호 {...} 대신 큰 따옴표 &quot;...&quot;로 묶인 경우 유용 할 수 있습니다. SQL이 큰 따옴표 &quot;...&quot;안에 포함되어 있으면 TCL은 $ -variables를 대체하므로주의를 기울이지 않으면 SQL 삽입이 발생할 수 있습니다. 그러나 TCL은 큰 따옴표 &quot;...&quot;또는 중괄호 {...}가 SQL을 묶는 데 사용되는지 여부에 관계없이 : -variable을 대체하지 않으므로 : -variables를 사용하면 추가적인 방어 수단이 추가됩니다. SQL 주입.</target>
        </trans-unit>
        <trans-unit id="53ba0fe6640d81c27b2028a34ac03622ddcd61d3" translate="yes" xml:space="preserve">
          <source>The use of a ZIP archive to encapsulate XML files plus resources is an elegant approach to an application file format. It is clearly superior to a custom binary file format. But using an SQLite database as the container, instead of ZIP, would be more elegant still.</source>
          <target state="translated">ZIP 파일을 사용하여 XML 파일과 리소스를 캡슐화하는 것은 응용 프로그램 파일 형식에 대한 우아한 접근 방식입니다. 사용자 정의 이진 파일 형식보다 분명히 우수합니다. 그러나 ZIP 대신 SQLite 데이터베이스를 컨테이너로 사용하는 것이 더 우아합니다.</target>
        </trans-unit>
        <trans-unit id="62a1d7ca77be3f3b5567800401dc0bf052c2aaae" translate="yes" xml:space="preserve">
          <source>The use of a virtual machine in SQLite has been a great benefit to the library's development. The virtual machine provides a crisp, well-defined junction between the front-end of SQLite (the part that parses SQL statements and generates virtual machine code) and the back-end (the part that executes the virtual machine code and computes a result.) The virtual machine allows the developers to see clearly and in an easily readable form what SQLite is trying to do with each statement it compiles, which is a tremendous help in debugging. Depending on how it is compiled, SQLite also has the capability of tracing the execution of the virtual machine - printing each virtual machine instruction and its result as it executes.</source>
          <target state="translated">SQLite에서 가상 머신을 사용하면 라이브러리 개발에 큰 이점이 있습니다. 가상 머신은 SQLite의 프런트 엔드 (SQL 문을 구문 분석하고 가상 머신 코드를 생성하는 부분)와 백엔드 (가상 머신 코드를 실행하고 결과를 계산하는 부분) 사이에 명확하고 정의 된 정션을 제공합니다. ) 가상 머신을 사용하면 개발자는 SQLite가 컴파일하는 각 명령문으로 수행하려는 작업을 명확하고 쉽게 읽을 수있는 형식으로 볼 수 있습니다. 이는 디버깅에 큰 도움이됩니다. SQLite는 컴파일 방식에 따라 가상 머신의 실행을 추적하는 기능도 가지고 있습니다. 각 가상 머신 명령어와 실행 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="9d27ce1c6f5449fceeec41db3a7baef374e89122" translate="yes" xml:space="preserve">
          <source>The use of each of these methods will be explained in the sequel, though not in the order shown above.</source>
          <target state="translated">이들 방법 각각의 사용은 상기 도시 된 순서가 아닌 후속편에 설명 될 것이다.</target>
        </trans-unit>
        <trans-unit id="ac3e9e4d3a0d1a6a51dbf276370664c84cd0bc3c" translate="yes" xml:space="preserve">
          <source>The use of persistent journal mode provides a noticeable performance improvement on many systems. Of course, the drawback is that the journal files remain on the disk, using disk space and cluttering directories, long after the transaction commits. The only safe way to delete a persistent journal file is to commit a transaction with journaling mode set to DELETE:</source>
          <target state="translated">지속적 저널 모드를 사용하면 많은 시스템에서 눈에 띄는 성능 향상을 제공합니다. 물론, 트랜잭션이 커밋 된 후에도 저널 파일이 디스크 공간과 복잡한 디렉토리를 사용하여 디스크에 남아 있다는 단점이 있습니다. 지속적 저널 파일을 삭제하는 유일한 안전한 방법은 저널링 모드가 DELETE로 설정된 트랜잭션을 커미트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac2e1cc15280219a058aa01cbdd9d14acc3c174c" translate="yes" xml:space="preserve">
          <source>The use of pointer-passing is an advanced technique that should be used infrequently and cautiously. Pointer-passing should not be used haphazardly or carelessly. Pointer-passing is a sharp tool that can leave deep scars if misused.</source>
          <target state="translated">포인터 전달의 사용은 드물고 신중하게 사용해야하는 고급 기술입니다. 포인터 전달을 우연히 또는 부주의하게 사용해서는 안됩니다. 포인터 통과는 잘못 사용하면 깊은 상처를 남길 수있는 날카로운 도구입니다.</target>
        </trans-unit>
        <trans-unit id="716439e76a7ceab1c8c91b09a2f76c73c53bf8c1" translate="yes" xml:space="preserve">
          <source>The use of subtypes on pointers prevented pointer forgery using pure SQL. But subtypes do nothing to prevent an attacker from reading the values of pointers. In other words, subtypes on pointer values prevent attacks using SQL statements like this:</source>
          <target state="translated">포인터에 하위 유형을 사용하면 순수한 SQL을 사용하는 포인터 위조가 방지되었습니다. 그러나 하위 유형은 공격자가 포인터 값을 읽지 못하도록하기 위해 아무 것도하지 않습니다. 즉, 포인터 값의 하위 유형은 다음과 같은 SQL 문을 사용하는 공격을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d8ed607375ddfb8582a61f0a5132f51fb52c53b0" translate="yes" xml:space="preserve">
          <source>The use of the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is recommended for all applications.</source>
          <target state="translated">모든 응용 분야에 &lt;a href=&quot;amalgamation&quot;&gt;아말감&lt;/a&gt; 사용을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="789c46abbb3fc4976d476150773395da4c1e0a98" translate="yes" xml:space="preserve">
          <source>The use of the UTF-8 interfaces is preferred, as SQLite currently does all parsing using UTF-8. The UTF-16 interfaces are provided as a convenience. The UTF-16 interfaces work by converting the input text into UTF-8, then invoking the corresponding UTF-8 interface.</source>
          <target state="translated">SQLite는 현재 UTF-8을 사용하여 모든 구문 분석을 수행하므로 UTF-8 인터페이스를 사용하는 것이 좋습니다. UTF-16 인터페이스는 편의상 제공됩니다. UTF-16 인터페이스는 입력 텍스트를 UTF-8로 변환 한 다음 해당 UTF-8 인터페이스를 호출하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7ed5c8c8570cfb3a0d0049b76c3fa5c381dc896c" translate="yes" xml:space="preserve">
          <source>The use of the error logger callback is highly recommended. The debugging information that the error logger provides has proven very useful in tracking down obscure problems that occurs with applications after they get into the field. The error logger callback has also proven useful in catching errors occasional errors that the application misses because of inconsistent checking of API return codes. Developers are encouraged to implement an error logger callback early in the development cycle in order to spot unexpected behavior quickly, and to leave the error logger callback turned on through deployment. If the error logger never finds a problem, then no harm is done. But failure to set up an appropriate error logger might compromise diagnostic capabilities later on.</source>
          <target state="translated">오류 로거 콜백을 사용하는 것이 좋습니다. 오류 로거가 제공하는 디버깅 정보는 응용 프로그램이 현장에 들어간 후 발생하는 모호한 문제를 추적하는 데 매우 유용한 것으로 입증되었습니다. 오류 로거 콜백은 API 리턴 코드의 일관성 검사로 인해 응용 프로그램에서 누락되는 오류를 포착하는 데 유용하다는 것이 입증되었습니다. 개발자는 예기치 않은 동작을 신속하게 발견하고 배포를 통해 오류 로거 콜백을 켜두려면 개발주기 초기에 오류 로거 콜백을 구현하는 것이 좋습니다. 오류 로거가 문제를 찾지 못하면 아무런 해가 없습니다. 그러나 적절한 오류 로거를 설정하지 않으면 나중에 진단 기능이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a848d528e6bb7ea17daf03362baa03e736e192f7" translate="yes" xml:space="preserve">
          <source>The use of the standardized speedtest1.c workload and cachegrind has enabled significant performance improvement. However, it is important to recognize the limitations of this approach:</source>
          <target state="translated">표준화 된 speedtest1.c 워크로드 및 캐시 그라인드를 사용하면 성능이 크게 향상되었습니다. 그러나이 방법의 한계를 인식하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="fbf470196dd9e32d7a6c5961b17698cfadfdbb60" translate="yes" xml:space="preserve">
          <source>The use of variable-length records by SQLite has a number of advantages. It results in smaller database files, obviously. It also makes the database run faster, since there is less information to move to and from disk. And, the use of variable-length records makes it possible for SQLite to employ manifest typing instead of static typing.</source>
          <target state="translated">SQLite에서 가변 길이 레코드를 사용하면 여러 가지 장점이 있습니다. 분명히 작은 데이터베이스 파일이 만들어집니다. 또한 디스크로 이동하는 정보가 적기 때문에 데이터베이스를 더 빠르게 실행할 수 있습니다. 또한 가변 길이 레코드를 사용하면 SQLite에서 정적 입력 대신 매니페스트 입력을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f495ec4a4bf3743c12d1f50425c742888001cad3" translate="yes" xml:space="preserve">
          <source>The user_version pragma will to get or set the value of the user-version integer at offset 60 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt;. The user-version is an integer that is available to applications to use however they want. SQLite makes no use of the user-version itself.</source>
          <target state="translated">user_version pragma는 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 헤더의&lt;/a&gt; 오프셋 60에서 사용자 버전 정수 값을 가져 오거나 설정합니다 . 사용자 버전은 응용 프로그램에서 원하는대로 사용할 수있는 정수입니다. SQLite는 사용자 버전 자체를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81fbf2e7b21c5d201e92f96deae7ccf53bbeeddc" translate="yes" xml:space="preserve">
          <source>The usermerge option is similar to the automerge and crisismerge options. It is the minimum number of b-tree segments that will be merged together by a 'merge' command with a positive parameter. For example:</source>
          <target state="translated">usermerge 옵션은 automerge 및 crisismerge 옵션과 유사합니다. 양수 매개 변수와 함께 '병합'명령으로 병합되는 최소 b- 트리 세그먼트 수입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7380a4170d0b89318a355604d7dab9b3376f5f00" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; commands work on an R*Tree index just like on regular tables. So to insert some data into our sample R*Tree index, we can do something like this:</source>
          <target state="translated">일반적인 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 명령은 일반 테이블과 마찬가지로 R * Tree 인덱스에서 작동합니다. 따라서 샘플 R * Tree 인덱스에 일부 데이터를 삽입하기 위해 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7245ad2ccb3652b74420857f1f81436b120932a2" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">일반적인 경우 sqlite3_serialize ()는 데이터베이스의 직렬화를 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 복사하고 해당 메모리에 대한 포인터를 반환합니다. 호출자는 메모리 누수를 피하기 위해 반환 된 값을 해제해야합니다. 그러나 F 인수에 SQLITE_SERIALIZE_NOCOPY 비트가 포함되어 있으면 메모리 할당이 이루어지지 않으며 sqlite3_serialize () 함수는 SQLite가 현재 해당 데이터베이스에 사용중인 데이터베이스의 연속 메모리 표시에 대한 포인터를 리턴합니다. 데이터베이스의 이러한 연속적인 메모리 표현이 존재합니다. 데이터베이스의 연속 메모리 표현은 일반적으로 &lt;a href=&quot;#sqlite3_deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; 에 대한 사전 호출이있는 경우에만 존재합니다 .SQLITE_SERIALIZE_NOCOPY 비트가 설정되었지만 데이터베이스의 연속 사본이없는 경우에도 데이터베이스의 크기는 * P에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="69659aa2e08fcc19f80f4fa144bcabaf8c7b3ed8" translate="yes" xml:space="preserve">
          <source>The usual case is that sqlite3_serialize() copies the serialization of the database into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and returns a pointer to that memory. The caller is responsible for freeing the returned value to avoid a memory leak. However, if the F argument contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations are made, and the sqlite3_serialize() function will return a pointer to the contiguous memory representation of the database that SQLite is currently using for that database, or NULL if the no such contiguous memory representation of the database exists. A contiguous memory representation of the database will usually only exist if there has been a prior call to &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize(D,S,...)&lt;/a&gt; with the same values of D and S. The size of the database is written into *P even if the SQLITE_SERIALIZE_NOCOPY bit is set but no contiguous copy of the database exists.</source>
          <target state="translated">일반적인 경우 sqlite3_serialize ()는 데이터베이스의 직렬화를 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 에서 얻은 메모리에 복사하고 해당 메모리에 대한 포인터를 반환합니다. 호출자는 메모리 누수를 피하기 위해 반환 된 값을 해제해야합니다. 그러나 F 인수에 SQLITE_SERIALIZE_NOCOPY 비트가 포함되어 있으면 메모리 할당이 이루어지지 않으며 sqlite3_serialize () 함수는 SQLite가 현재 해당 데이터베이스에 사용중인 데이터베이스의 연속 메모리 표시에 대한 포인터를 리턴합니다. 데이터베이스의 이러한 연속적인 메모리 표현이 존재합니다. 데이터베이스의 연속 메모리 표현은 일반적으로 &lt;a href=&quot;deserialize&quot;&gt;sqlite3_deserialize (D, S, ...)&lt;/a&gt; 에 대한 사전 호출이있는 경우에만 존재합니다 .SQLITE_SERIALIZE_NOCOPY 비트가 설정되었지만 데이터베이스의 연속 사본이없는 경우에도 데이터베이스의 크기는 * P에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="2878cf43bc017da229299a9eeb8ee3b6c95340de" translate="yes" xml:space="preserve">
          <source>The usual case is that the entire database file is checked. However, if the argument is</source>
          <target state="translated">일반적인 경우는 전체 데이터베이스 파일을 확인하는 것입니다. 그러나 인수가</target>
        </trans-unit>
        <trans-unit id="0fc6512389ff21ec6ba0d889f8647d34fa1771be" translate="yes" xml:space="preserve">
          <source>The usual output is an SQL script that will transform database1.sqlite (the &quot;source&quot; database) into database2.sqlite (the &quot;destination&quot; database). This behavior can be altered using command-line switches:</source>
          <target state="translated">일반적인 출력은 database1.sqlite ( &quot;소스&quot;데이터베이스)를 database2.sqlite ( &quot;대상&quot;데이터베이스)로 변환하는 SQL 스크립트입니다. 이 동작은 명령 행 스위치를 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ebe7d136ea02a608354f8bf5123226386a80e2bf" translate="yes" xml:space="preserve">
          <source>The usual usage pattern for an sqlite3_changegroup object is as follows:</source>
          <target state="translated">sqlite3_changegroup 객체의 일반적인 사용 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f006b61943f366c81b0414ad0d7a764b14620096" translate="yes" xml:space="preserve">
          <source>The usual way of storing a date in a database table is as a single field, as either a unix timestamp, a julian day number, or an ISO-8601 dates string. But some application store dates as three separate fields for the year, month, and day.</source>
          <target state="translated">데이터베이스 테이블에 날짜를 저장하는 일반적인 방법은 단일 필드, 유닉스 타임 스탬프, julian day number 또는 ISO-8601 날짜 문자열입니다. 그러나 일부 응용 프로그램 저장소는 연도, 월 및 일에 대해 세 개의 별도 필드로 날짜가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e446494ebae458b5aea2681dfd535005a9fb5001" translate="yes" xml:space="preserve">
          <source>The value</source>
          <target state="translated">가치</target>
        </trans-unit>
        <trans-unit id="1493e5c49d89b37715d26870b14178bb98eff899" translate="yes" xml:space="preserve">
          <source>The value extracted is stored in register P3.</source>
          <target state="translated">추출 된 값은 레지스터 P3에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b67d4fe7f5972a61b5da20c2ef9a98c84328f043" translate="yes" xml:space="preserve">
          <source>The value of NEW.rowid is undefined in a BEFORE INSERT trigger in which the rowid is not explicitly set to an integer.</source>
          <target state="translated">NEW.rowid의 값은 rowid가 명시 적으로 정수로 설정되지 않은 BEFORE INSERT 트리거에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ccbeb6aa89a69300ffd6eb190f7535f8bc566cf" translate="yes" xml:space="preserve">
          <source>The value of SQLITE_THREADSAFE can be determined at run-time using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_THREADSAFE의 값은 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 판별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d5ab5daf4c7771df3bc76b4527132dffd8bea934" translate="yes" xml:space="preserve">
          <source>The value of an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column must always be a non-NULL integer. The PRIMARY KEY columns of a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table are also required to be non-NULL.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열의 값은 항상 NULL이 아닌 정수 여야합니다. &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 의 PRIMARY KEY 열도 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="94d5eebfcf21e24cf605bf00db4a0642798783cd" translate="yes" xml:space="preserve">
          <source>The value of the N parameter to these interfaces should be non-negative. Future enhancements may make use of negative N values to define new kinds of function caching behavior.</source>
          <target state="translated">이러한 인터페이스에 대한 N 매개 변수의 값은 음수가 아니어야합니다. 향후 개선 사항은 새로운 종류의 함수 캐싱 동작을 정의하기 위해 음수 N 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7bdc3b5bd50bd43536e1eeee3d4c188a48e335" translate="yes" xml:space="preserve">
          <source>The value of the change counter is copied to the database handle change counter (returned by subsequent calls to sqlite3_changes()). Then the VMs internal change counter resets to 0. This is used by trigger programs.</source>
          <target state="translated">변경 카운터의 값은 데이터베이스 핸들 변경 카운터에 복사됩니다 (sqlite3_changes ()에 대한 후속 호출로 리턴 됨). 그런 다음 VM 내부 변경 카운터가 0으로 재설정됩니다. 이는 트리거 프로그램에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4a5b194cd44f85aade16e1c37ccac8a115177304" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step () 완료 여부에 관계없이 sqlite3_backup_step () 오류가 발생하지 않으면 sqlite3_backup_finish에 의해 리턴되는 값은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 입니다. 동일한 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 에서 이전 sqlite3_backup_step () 호출 중에 메모리 부족 조건 또는 IO 오류가 발생 하면 sqlite3_backup_finish ()는 해당 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a8b2a631496d509ee2b275504f995fbe8e4ff87c" translate="yes" xml:space="preserve">
          <source>The value returned by sqlite3_backup_finish is &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if no sqlite3_backup_step() errors occurred, regardless or whether or not sqlite3_backup_step() completed. If an out-of-memory condition or IO error occurred during any prior sqlite3_backup_step() call on the same &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object, then sqlite3_backup_finish() returns the corresponding &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">sqlite3_backup_step () 완료 여부에 관계없이 sqlite3_backup_step () 오류가 발생하지 않으면 sqlite3_backup_finish에 의해 리턴되는 값은 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 입니다. 동일한 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트 에서 이전 sqlite3_backup_step () 호출 중에 메모리 부족 조건 또는 IO 오류가 발생 하면 sqlite3_backup_finish ()는 해당 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bc51fa501b0d744e2b8200daac75839a3f391d4e" translate="yes" xml:space="preserve">
          <source>The values &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are properties of the application. If an application is constructed in such a way that both &lt;b&gt;M&lt;/b&gt; and &lt;b&gt;n&lt;/b&gt; are known, or at least have known upper bounds, and if the application uses the &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt; memory allocator and is provided with &lt;b&gt;N&lt;/b&gt; bytes of available memory space using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP&lt;/a&gt; then Robson proves that no memory allocation request will ever fail within the application. To put this another way, the application developer can select a value for &lt;b&gt;N&lt;/b&gt; that will guarantee that no call to any SQLite interface will ever return &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;. The memory pool will never become so fragmented that a new memory allocation request cannot be satisfied. This is an important property for applications where a software fault could cause injury, physical harm, or loss of irreplaceable data.</source>
          <target state="translated">값 &lt;b&gt;M&lt;/b&gt; 과 &lt;b&gt;n&lt;/b&gt; 은 응용 프로그램의 속성입니다. 애플리케이션이 이러한 방식으로 구성되는 경우에 모두 있다는 &lt;b&gt;M&lt;/b&gt; 및 &lt;b&gt;N은&lt;/b&gt; 공지되어 있거나, 적어도 상부 경계를 알고 있고, 응용 프로그램이 사용하는 경우 &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5의&lt;/a&gt; 메모리 할당과 함께 제공되는 &lt;b&gt;N&lt;/b&gt; 사용 가능한 메모리 공간 바이트 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigheap&quot;&gt;SQLITE_CONFIG_HEAP를&lt;/a&gt; 다음 롭슨 증명 응용 프로그램 내에서 메모리 할당 요청이 실패하지 않습니다. 다른 방법으로, 응용 프로그램 개발자는 &lt;b&gt;N에&lt;/b&gt; 대한 값을 선택하여 SQLite 인터페이스를 호출 &lt;a href=&quot;rescode#nomem&quot;&gt;해도 SQLITE_NOMEM을&lt;/a&gt; 반환하지 않습니다.. 메모리 풀은 조각화되지 않으므로 새 메모리 할당 요청을 충족 할 수 없습니다. 이는 소프트웨어 결함으로 인해 부상, 물리적 손상 또는 대체 할 수없는 데이터 손실이 발생할 수있는 응용 프로그램의 중요한 속성입니다.</target>
        </trans-unit>
        <trans-unit id="22f534f2da25c6b7c05e8783b8e5bfbbc59c87e8" translate="yes" xml:space="preserve">
          <source>The values for each column in the record immediately follow the header. For serial types 0, 8, 9, 12, and 13, the value is zero bytes in length. If all columns are of these types then the body section of the record is empty.</source>
          <target state="translated">레코드의 각 열 값은 헤더 바로 다음에옵니다. 직렬 유형 0, 8, 9, 12 및 13의 경우 값의 길이는 0 바이트입니다. 모든 열이 이러한 유형 인 경우 레코드의 본문 섹션이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d128efd1de498da70d20d12d2513201d5001c97a" translate="yes" xml:space="preserve">
          <source>The values for each column of the row are stored in these columns. The &quot;.recover&quot; command creates the lost_and_found table with as many columns as required by the longest orphaned row.</source>
          <target state="translated">행의 각 열에 대한 값이이 열에 저장됩니다. &quot;.recover&quot;명령은 가장 긴 분리 된 행에 필요한만큼의 열이있는 lost_and_found 테이블을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="fd6b2ec514a48d20f0372d7449abd69ec8081347" translate="yes" xml:space="preserve">
          <source>The values placed in the sqlite_stat1 table by an approximate ANALYZE are not exactly the same as what would be computed by an unrestricted analysis. But they are usually close enough. The index statistics in the sqlite_stat1 table are approximations in any case, so the fact that the results of an approximate ANALYZE are slightly different from a traditional full scan ANALYZE has little practical impact. It is possible to construct a pathological case where an approximate ANALYZE is noticeably inferior to a full-scan ANALYZE, but such cases rare in real-world problems.</source>
          <target state="translated">대략적인 ANALYZE에 의해 sqlite_stat1 테이블에 배치 된 값은 무제한 분석으로 계산되는 값과 정확히 동일하지 않습니다. 그러나 그들은 일반적으로 충분히 가깝습니다. sqlite_stat1 테이블의 인덱스 통계는 어떤 경우에도 근사치이므로 근사 ANALYZE의 결과가 기존 전체 스캔 ANALYZE와 약간 다르다는 사실은 실질적인 영향이 거의 없습니다. 대략적인 ANALYZE가 full-scan ANALYZE보다 눈에 띄게 열등한 병리학 적 사례를 구성 할 수 있지만 실제 문제에서는 이러한 사례가 드뭅니다.</target>
        </trans-unit>
        <trans-unit id="61332fb4ed04580474ae395b4c8e0cfc53138b43" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴 된 값 은 문자열 끝에 0 종결 자를 포함하지 않습니다. 명확성을 위해 : &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴되는 값 은 문자 수가 아닌 문자열의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="56d75a71d4310cb50689d453693c130f5e211175" translate="yes" xml:space="preserve">
          <source>The values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; do not include the zero terminators at the end of the string. For clarity: the values returned by &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes()&lt;/a&gt; and &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16()&lt;/a&gt; are the number of bytes in the string, not the number of characters.</source>
          <target state="translated">&lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴 된 값 은 문자열 끝에 0 종결 자를 포함하지 않습니다. 명확성을 위해 : &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes ()&lt;/a&gt; 및 &lt;a href=&quot;column_blob&quot;&gt;sqlite3_column_bytes16 ()에&lt;/a&gt; 의해 리턴되는 값 은 문자 수가 아닌 문자열의 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="9a34a413d802292386ca8ed35bad50613a2e40f9" translate="yes" xml:space="preserve">
          <source>The values returned by sqlite3_errcode() and/or sqlite3_extended_errcode() might change with each API call. Except, there are some interfaces that are guaranteed to never change the value of the error code. The error-code preserving interfaces are:</source>
          <target state="translated">sqlite3_errcode () 및 / 또는 sqlite3_extended_errcode ()에 의해 리턴 된 값은 각 API 호출에 따라 변경 될 수 있습니다. 단, 오류 코드의 값을 절대로 변경하지 않는 인터페이스가 있습니다. 오류 코드 보존 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af0883b91a2c32edd6bb6e8adf9674294de318ba" translate="yes" xml:space="preserve">
          <source>The variable &lt;b&gt;$x&lt;/b&gt; is set by the above code to</source>
          <target state="translated">변수 &lt;b&gt;$ x&lt;/b&gt; 는 위의 코드에서</target>
        </trans-unit>
        <trans-unit id="e81b821adc588b80803661eb9435ef7daf5e77e6" translate="yes" xml:space="preserve">
          <source>The variable i in the previous expression varies between 0 and 9. Conceptually, the index space is divided into 10 uniform buckets and the samples are the middle row from each bucket.</source>
          <target state="translated">이전 식에서 변수 i는 0과 9 사이에서 변합니다. 개념적으로 인덱스 공간은 10 개의 균일 한 버킷으로 나뉘며 샘플은 각 버킷의 가운데 행입니다.</target>
        </trans-unit>
        <trans-unit id="e46969b4d5144ef5a3ecc1c7c5e86080c0dd5e34" translate="yes" xml:space="preserve">
          <source>The various &lt;b&gt;sqlite_stat&lt;/b&gt;</source>
          <target state="translated">다양한 &lt;b&gt;sqlite_stat&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4ea0a2ad541e7dfd246d5e09a98161b66d983211" translate="yes" xml:space="preserve">
          <source>The various SQLite Archive Archive commands are implemented using SQL statements. Application developers can easily add SQLite Archive Archive reading and writing support to their own projects by running the appropriate SQL.</source>
          <target state="translated">다양한 SQLite Archive Archive 명령은 SQL 문을 사용하여 구현됩니다. 응용 프로그램 개발자는 적절한 SQL을 실행하여 자신의 프로젝트에 SQLite Archive Archive 읽기 및 쓰기 지원을 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f8ca9c7ec1168dbb45b57fd3ebfbf3e9d60926" translate="yes" xml:space="preserve">
          <source>The various assert()-like macros behave differently according to how SQLite is built.</source>
          <target state="translated">다양한 assert ()와 유사한 매크로는 SQLite의 빌드 방식에 따라 다르게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="8789a3da4f75d5b0392ef189d216e2c9312d1546" translate="yes" xml:space="preserve">
          <source>The various unix VFSes differ only in the way they handle file locking - they share most of their implementation in common with one another and are all located in the same SQLite source file: &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c&lt;/a&gt;. Note that except for &quot;unix&quot; and &quot;unix-excl&quot;, the various unix VFSes all use incompatible locking implementations. If two processes are accessing the same SQLite database using different unix VFSes, they may not see each others locks and may end up interfering with one another, resulting in database corruption. The &quot;unix-none&quot; VFS in particular does no locking at all and will easily result in database corruption if used by two or more database connections at the same time. Programmers are encouraged to use only &quot;unix&quot; or &quot;unix-excl&quot; unless there is a compelling reason to do otherwise.</source>
          <target state="translated">다양한 유닉스 VFS는 파일 잠금을 처리하는 방식에서만 차이가 있습니다. 대부분의 구현을 서로 공통으로 공유하며 모두 동일한 SQLite 소스 파일 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/os_unix.c&quot;&gt;os_unix.c에&lt;/a&gt; 있습니다. &quot;unix&quot;및 &quot;unix-excl&quot;을 제외하고 다양한 유닉스 VFS는 모두 호환되지 않는 잠금 구현을 사용합니다. 두 프로세스가 서로 다른 유닉스 VFS를 사용하여 동일한 SQLite 데이터베이스에 액세스하는 경우 서로의 잠금을 보지 못하고 서로 방해하여 데이터베이스가 손상 될 수 있습니다. &quot;unix-none&quot;VFS는 특히 전혀 잠금을 수행하지 않으며 동시에 둘 이상의 데이터베이스 연결에서 사용하는 경우 데이터베이스가 손상 될 수 있습니다. 프로그래머는 &quot;unix&quot;또는 &quot;unix-excl&quot;만 사용하는 것이 좋습니다.달리해야 할 강력한 이유가없는 한.</target>
        </trans-unit>
        <trans-unit id="c5ffe5eea46cbcd5a1594ce73f72bf62a68d39e3" translate="yes" xml:space="preserve">
          <source>The versions of SQLite that come preinstalled on Apple Mac OS X computers contain a version of SQLite that has been extended to use alternative locking strategies that work on all network filesystems that Apple supports. These extensions used by Apple work great as long as all processes are accessing the database file in the same way. Unfortunately, the locking mechanisms do not exclude one another, so if one process is accessing a file using (for example) AFP locking and another process (perhaps on a different machine) is using dot-file locks, the two processes might collide because AFP locks do not exclude dot-file locks or vice versa.</source>
          <target state="translated">Apple Mac OS X 컴퓨터에 사전 설치된 SQLite 버전에는 Apple이 지원하는 모든 네트워크 파일 시스템에서 작동하는 대체 잠금 전략을 사용하도록 확장 된 SQLite 버전이 포함되어 있습니다. Apple에서 사용하는 이러한 확장은 모든 프로세스가 동일한 방식으로 데이터베이스 파일에 액세스하는 한 효과적입니다. 불행히도 잠금 메커니즘은 서로를 배제하지 않으므로 한 프로세스가 (예를 들어) AFP 잠금을 사용하여 파일에 액세스하고 다른 프로세스 (아마 다른 시스템에 있음)가 도트 파일 잠금을 사용하는 경우 AFP 때문에 두 프로세스가 충돌 할 수 있습니다 잠금은 도트 파일 잠금을 제외하지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="27a68965a58736f6647ab050fea465e20bf8ddef" translate="yes" xml:space="preserve">
          <source>The versions of the SQLite amalgamation that are supplied on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; are normally adequate for most users. However, some projects may want or need to build their own amalgamations. A common reason for building a custom amalgamation is in order to use certain &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; to customize the SQLite library. Recall that the SQLite amalgamation contains a lot of C-code that is generated by auxiliary programs and scripts. Many of the compile-time options effect this generated code and must be supplied to the code generators before the amalgamation is assembled. The set of compile-time options that must be passed into the code generators can vary from one release of SQLite to the next, but at the time of this writing (circa SQLite 3.6.20, 2009-11-04) the set of options that must be known by the code generators includes:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에 제공되는 SQLite 통합의 버전 은 일반적으로 대부분의 사용자에게 적합합니다. 그러나 일부 프로젝트는 자체 융합을 원하거나 필요로 할 수 있습니다. 사용자 지정 합병을 만드는 일반적인 이유는 특정 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션&lt;/a&gt; 을 사용하기위한 것입니다.SQLite 라이브러리를 사용자 정의합니다. SQLite 통합에는 보조 프로그램 및 스크립트에 의해 생성되는 많은 C 코드가 포함되어 있습니다. 많은 컴파일 타임 옵션이이 생성 된 코드에 영향을 미치며 통합하기 전에 코드 생성기에 제공되어야합니다. 코드 생성기로 전달되어야하는 컴파일 타임 옵션 세트는 SQLite 릴리스마다 다를 수 있지만이 시점 (SQLite 3.6.20, 2009-11-04 경)에는 옵션 세트가 있습니다. 코드 생성기에서 알아야 할 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d08eefb01c3e7948c8ed07ad520422cff4b9225d" translate="yes" xml:space="preserve">
          <source>The very name &quot;Structured Query Language&quot; tells us that SQL should support nested queries. And, in fact, two different kinds of nesting are supported. Any SELECT statement that returns a single-row, single-column result can be used as a term in an expression of another SELECT statement. And, a SELECT statement that returns a single-column, multi-row result can be used as the right-hand operand of the IN and NOT IN operators. We will begin this section with an example of the first kind of nesting, where a single-row, single-column SELECT is used as a term in an expression of another SELECT. Here is our example:</source>
          <target state="translated">&quot;Structured Query Language&quot;라는 이름은 SQL이 중첩 쿼리를 지원해야 함을 나타냅니다. 실제로 두 가지 종류의 중첩이 지원됩니다. 단일 행, 단일 열 결과를 리턴하는 SELECT 문은 다른 SELECT 문의 표현식에서 용어로 사용될 수 있습니다. 또한 단일 열, 다중 행 결과를 반환하는 SELECT 문을 IN 및 NOT IN 연산자의 오른쪽 피연산자로 사용할 수 있습니다. 첫 번째 종류의 중첩 예제로이 섹션을 시작하겠습니다. 여기서 단일 행, 단일 열 SELECT가 다른 SELECT의 표현식에서 용어로 사용됩니다. 우리의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20c4a011c8e3b37249d4469eb52a0ff7a1d9c48e" translate="yes" xml:space="preserve">
          <source>The vfs query parameter causes the database connection to be opened using the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; called</source>
          <target state="translated">VFS에 쿼리 매개 변수를 사용하여 열 수 데이터베이스 연결을 일으키는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 전화를</target>
        </trans-unit>
        <trans-unit id="7fc9c565eeb1c6123557989180ff5a163d06934e" translate="yes" xml:space="preserve">
          <source>The view to drop is identified by the view-name and optional schema-name specified as part of the DROP VIEW statement. This reference is resolved using the standard procedure for &lt;a href=&quot;lang_naming&quot;&gt;object resolution&lt;/a&gt;.</source>
          <target state="translated">제거 할 뷰는 DROP VIEW 문의 일부로 지정된 view-name 및 선택적 schema-name으로 식별됩니다. 이 참조는 &lt;a href=&quot;lang_naming&quot;&gt;객체 해상도에&lt;/a&gt; 대한 표준 절차를 사용하여 해결 됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2c6960eedc019bcf13fce258370b16a245ba89" translate="yes" xml:space="preserve">
          <source>The view v1 cannot be &lt;a href=&quot;optoverview#flattening&quot;&gt;flattened&lt;/a&gt; because it is DISTINCT. It must instead be run as a subquery with the results being stored in a transient table, then the join is performed between t2 and the transient table. The push-down optimization pushes down the &quot;b BETWEEN 10 AND 20&quot; term into the view. This makes the transient table smaller, and helps the subquery to run faster if there is an index on t1.b. The resulting evaluation is like this:</source>
          <target state="translated">뷰 V1을 할 수없는 &lt;a href=&quot;optoverview#flattening&quot;&gt;평평&lt;/a&gt; 가 DISTINCT 때문이다. 대신 결과가 임시 테이블에 저장된 서브 쿼리로 실행되어야하며 조인은 t2와 임시 테이블 사이에서 수행됩니다. 푸시 다운 최적화는 &quot;b와 10 사이의 b&quot;용어를보기로 푸시 다운합니다. 이는 임시 테이블을 더 작게 만들고 t1.b에 인덱스가있는 경우 서브 쿼리를 더 빨리 실행하는 데 도움이됩니다. 결과 평가는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ce6b93653a867ff824a137b275a2d8a4b5929427" translate="yes" xml:space="preserve">
          <source>The virtual machine itself is entirely contained in a single source file &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h&lt;/a&gt; header file defines an interface between the virtual machine and the rest of the SQLite library and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; which defines structures and interfaces that are private the virtual machine itself. Various other &lt;b&gt;vdbe*.c&lt;/b&gt; files are helpers to the virtual machine. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c&lt;/a&gt; file contains utilities used by the virtual machine and interface modules used by the rest of the library to construct VM programs. The &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; file contains external interfaces to the virtual machine such as the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int()&lt;/a&gt; and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. Individual values (strings, integer, floating point numbers, and BLOBs) are stored in an internal object named &quot;Mem&quot; which is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c&lt;/a&gt;.</source>
          <target state="translated">가상 머신 자체는 단일 소스 파일 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.c&quot;&gt;vdbe.c&lt;/a&gt; 에 완전히 포함되어 있습니다. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbe.h&quot;&gt;vdbe.h의&lt;/a&gt; 헤더 파일은 가상 머신과 SQLite는 라이브러리의 나머지 사이의 인터페이스를 정의 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeInt.h&quot;&gt;vdbeInt.h&lt;/a&gt; 가상 머신 자체 비공개 구조와 인터페이스를 정의한다. 다른 여러 &lt;b&gt;vdbe * .c&lt;/b&gt; 파일은 가상 머신의 도우미입니다. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeaux.c&quot;&gt;vdbeaux.c의&lt;/a&gt; 파일은 VM 프로그램을 구성하는 라이브러리의 나머지 부분에서 사용되는 가상 머신 및 인터페이스 모듈에 의해 사용되는 유틸리티가 포함되어 있습니다. &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c의&lt;/a&gt; 파일 등과 같은 가상 머신의 외부 인터페이스를 포함 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_int ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()를&lt;/a&gt;. 개별 값 (문자열, 정수, 부동 소수점 숫자 및 BLOB)은 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbemem.c&quot;&gt;vdbemem.c에&lt;/a&gt; 의해 구현되는 &quot;Mem&quot;이라는 내부 객체에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="00bcd77d6dec3bc1a5f96c0e0f3985aefbea69f9" translate="yes" xml:space="preserve">
          <source>The virtual table contains an xShadowName method.</source>
          <target state="translated">가상 테이블에는 xShadowName 메서드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="aba94b8d1e25fe7120c464dc013b1d34868edb66" translate="yes" xml:space="preserve">
          <source>The virtual table mechanism allows an application to publish interfaces that are accessible from SQL statements as if they were tables. SQL statements can do almost anything to a virtual table that they can do to a real table, with the following exceptions:</source>
          <target state="translated">가상 테이블 메커니즘을 통해 애플리케이션은 SQL 문에서 액세스 할 수있는 인터페이스를 테이블 인 것처럼 공개 할 수 있습니다. SQL 문은 다음을 제외하고 실제 테이블에 대해 수행 할 수있는 거의 모든 작업을 가상 테이블에 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7616eb3efb8cfc2b544466ae9f36f2a81289f276" translate="yes" xml:space="preserve">
          <source>The virtual table will return one row of output for each token in the input string. The &quot;token&quot; column is the text of the token. The &quot;start&quot; and &quot;end&quot; columns are the byte offset to the beginning and end of the token in the original input string. The &quot;position&quot; column is the sequence number of the token in the original input string. There is also an &quot;input&quot; column which is simply a copy of the input string that is specified in the WHERE clause. Note that a constraint of the form &quot;input=?&quot; must appear in the WHERE clause or else the virtual table will have no input to tokenize and will return no rows. The example above generates the following output:</source>
          <target state="translated">가상 테이블은 입력 문자열의 각 토큰에 대해 하나의 출력 행을 반환합니다. &quot;토큰&quot;열은 토큰의 텍스트입니다. &quot;start&quot;및 &quot;end&quot;열은 원래 입력 문자열에서 토큰의 시작과 끝에 대한 바이트 오프셋입니다. &quot;위치&quot;열은 원래 입력 문자열에서 토큰의 시퀀스 번호입니다. WHERE 절에 지정된 입력 문자열의 복사 본인 &quot;입력&quot;열도 있습니다. &quot;input =?&quot;형식의 제한 조건에 유의하십시오. WHERE 절에 나타나야합니다. 그렇지 않으면 가상 테이블에 토큰화할 입력이없고 행을 반환하지 않습니다. 위의 예제는 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e7d6d48d0123dd78c2ece991b5f7661cea292174" translate="yes" xml:space="preserve">
          <source>The wal-index file or &quot;shm&quot; file is not actually used as a file. Rather, individual database clients mmap the shm file and use it as shared memory for coordinating access to the database and as a cache for quickly locating frame within the wal file. The name of the shm file is the main database file name with the four characters &quot;-shm&quot; appended. Or, for 8+3 filesystems, the shm file is the main database file with the suffix changed to &quot;.SHM&quot;.</source>
          <target state="translated">wal-index 파일 또는 &quot;shm&quot;파일은 실제로 파일로 사용되지 않습니다. 오히려 개별 데이터베이스 클라이언트는 shm 파일을 mmap하여 데이터베이스에 대한 액세스를 조정하기위한 공유 메모리 및 wal 파일 내에서 프레임을 빠르게 찾을 수있는 캐시로 사용합니다. shm 파일의 이름은 4 개의 문자 &quot;-shm&quot;이 추가 된 기본 데이터베이스 파일 이름입니다. 또는 8 + 3 파일 시스템의 경우 shm 파일은 접미사가 &quot;.SHM&quot;으로 변경된 주 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2705cff44fec902d1ca3ce2af3b554cabc339fb3" translate="yes" xml:space="preserve">
          <source>The wal-index file, usually named &quot;X-shm&quot;.</source>
          <target state="translated">일반적으로 &quot;X-shm&quot;이라는 wal-index 파일입니다.</target>
        </trans-unit>
        <trans-unit id="3164ee82328b180dbc8289eddc9db733f9109901" translate="yes" xml:space="preserve">
          <source>The wal-index is transient. After a crash, the wal-index is reconstructed from the original WAL file. The VFS is required to either truncate or zero the header of the wal-index when the last connection to it closes. Because the wal-index is transient, it can use an architecture-specific format; it does not have to be cross-platform. Hence, unlike the database and WAL file formats which store all values as big endian, the wal-index stores multi-byte values in the native byte order of the host computer.</source>
          <target state="translated">월 인덱스는 일시적입니다. 충돌 후 wal-index는 원래 WAL 파일에서 재구성됩니다. VFS는 마지막 연결이 닫힐 때 wal-index의 헤더를 자르거나 0으로 만들어야합니다. 월 인덱스는 일시적이므로 아키텍처 별 형식을 사용할 수 있습니다. 크로스 플랫폼 일 필요는 없습니다. 따라서 모든 값을 big endian으로 저장하는 데이터베이스 및 WAL 파일 형식과 달리 wal-index는 멀티 바이트 값을 호스트 컴퓨터의 기본 바이트 순서로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f37728360280f92c82e5f63eda2235cd3fe649d8" translate="yes" xml:space="preserve">
          <source>The wal_checkpoint pragma returns a single row with three integer columns. The first column is usually 0 but will be 1 if a RESTART or FULL or TRUNCATE checkpoint was blocked from completing, for example because another thread or process was actively using the database. In other words, the first column is 0 if the equivalent call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; would have returned &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or 1 if the equivalent call would have returned &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;. The second column is the number of modified pages that have been written to the write-ahead log file. The third column is the number of pages in the write-ahead log file that have been successfully moved back into the database file at the conclusion of the checkpoint. The second and third column are -1 if there is no write-ahead log, for example if this pragma is invoked on a database connection that is not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">wal_checkpoint pragma는 3 개의 정수 열이있는 단일 행을 반환합니다. 첫 번째 열은 일반적으로 0이지만 다른 스레드 또는 프로세스가 데이터베이스를 적극적으로 사용하고 있기 때문에 RESTART, FULL 또는 TRUNCATE 검사 점이 완료되지 않도록 차단 된 경우 1입니다. 즉, &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()에&lt;/a&gt; 대한 동등한 호출이 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 한 경우 첫 번째 열은 0이고 동등한 호출이 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY를&lt;/a&gt; 리턴 한 경우 1 인 첫 번째 열은 0입니다. 두 번째 열은 미리 쓰기 로그 파일에 기록 된 수정 된 페이지 수입니다. 세 번째 열은 체크 포인트가 끝날 때 미리 쓰기 로그 파일에서 데이터베이스 파일로 다시 이동 된 페이지 수입니다. 두 번째 및 세 번째 열은 미리 쓰기 로그가없는 경우 (예 : &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 가 아닌 데이터베이스 연결에서이 pragma가 호출 된 경우) -1 입니다.</target>
        </trans-unit>
        <trans-unit id="7abca67d3b2f6649a3ed46e41721882b254d1af5" translate="yes" xml:space="preserve">
          <source>The way SQLite deals with this is to first run the inner SELECT (the one against examp2) and store its result in a private memory cell. SQLite then substitutes the value of this private memory cell for the inner SELECT when it evaluates the outer SELECT. The code looks like this:</source>
          <target state="translated">SQLite가 이것을 다루는 방법은 먼저 내부 SELECT (testp2에 대한 것)를 실행하고 그 결과를 개인 메모리 셀에 저장하는 것입니다. 그런 다음 SQLite는 외부 SELECT를 평가할 때이 개인용 메모리 셀의 값을 내부 SELECT로 대체합니다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d9f0711eae8ce05c73449f6cd3513a09a5b0c229" translate="yes" xml:space="preserve">
          <source>The way in which the IN and NOT IN operators handle NULL values in their right-hand expressions has been brought into compliance with the SQL standard and with other SQL database engines.</source>
          <target state="translated">IN 및 NOT IN 연산자가 오른쪽 표현식에서 NULL 값을 처리하는 방식은 SQL 표준 및 기타 SQL 데이터베이스 엔진을 준수합니다.</target>
        </trans-unit>
        <trans-unit id="1bcbf2e1391b1aa7e3ebafdb83d7f3bc20c48ce0" translate="yes" xml:space="preserve">
          <source>The whole point of the xShadowName method is to protect the content of shadow tables from being corrupted by hostile SQL. Every virtual table implementation that uses shadow tables should be able to detect and cope with corrupted shadow table content. However, bugs in particular virtual table implementation might allow a deliberately corrupted shadow table to cause a crash or other malfunction. The xShadowName mechanism seeks to avoid zero-day exploits by preventing ordinary SQL statements from deliberately corrupting shadow tables.</source>
          <target state="translated">xShadowName 메서드의 요점은 섀도우 테이블의 내용이 악의적 인 SQL에 의해 손상되지 않도록 보호하는 것입니다. 새도우 테이블을 사용하는 모든 가상 테이블 구현은 손상된 새도우 테이블 컨텐츠를 감지하고 대처할 수 있어야합니다. 그러나 특정 가상 테이블 구현의 버그로 인해 의도적으로 손상된 새도우 테이블로 인해 충돌 또는 기타 오작동이 발생할 수 있습니다. xShadowName 메커니즘은 일반 SQL 문이 의도적으로 새도우 테이블을 손상시키지 못하게함으로써 제로 데이 악용을 피하려고합니다.</target>
        </trans-unit>
        <trans-unit id="7ba3625dd3002c676817bb5d0641f1c309f9b35c" translate="yes" xml:space="preserve">
          <source>The width field specifies the minimum width of the substituted value in the output. If the string or number that is written into the output is shorter than the width, then the value is padded. Padding is on the left (the value is right-justified) by default. If the &quot;-&quot; flag is used, then the padding is on the right and the value is left-justified.</source>
          <target state="translated">너비 필드는 출력에서 ​​대체 된 값의 최소 너비를 지정합니다. 출력에 쓰여지는 문자열 또는 숫자가 너비보다 짧으면 값이 채워집니다. 패딩은 기본적으로 왼쪽에 있습니다 (값은 오른쪽 정렬 됨). &quot;-&quot;플래그가 사용되면 패딩이 오른쪽에 있고 값이 왼쪽 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a12aad5ee5dbe2d3fff555e1c8b3c9090a69eb38" translate="yes" xml:space="preserve">
          <source>The width is measured in bytes by default. However, if the &quot;!&quot; flag is present then the width is in characters. This only makes a difference for multi-byte utf-8 characters, and those only occur on string substitutions.</source>
          <target state="translated">너비는 기본적으로 바이트 단위로 측정됩니다. 그러나 &quot;!&quot; 플래그가 있으면 너비는 문자입니다. 이는 멀티 바이트 utf-8 문자에만 차이가 있으며 문자열 대체에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bb37fe25186c24e9c2d6b18924cc12e6bf999427" translate="yes" xml:space="preserve">
          <source>The word transliterated into lower-case ASCII. There is a standard table of mappings from non-ASCII characters into ASCII. Examples: &quot;&amp;aelig;&quot; -&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot; -&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot; -&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot; -&amp;gt; &quot;a&quot;, ... The accessory function spellfix1_translit(X) will do the non-ASCII to ASCII mapping. The built-in lower(X) function will convert to lower-case. Thus: k1 = lower(spellfix1_translit(word)). If the word is already all lower-case ASCII, then the k1 column will contain a NULL. This reduces the storage requirements for the %_vocab table and helps spellfix to run a little faster. Therefore, it is advantageous to populate as much of the spellfix table as possible using lower-case ASCII vocabulary.</source>
          <target state="translated">이 단어는 소문자 ASCII로 음역되었습니다. 비 ASCII 문자에서 ASCII 로의 표준 맵핑 테이블이 있습니다. 예 : &quot;&amp;aelig;&quot;-&amp;gt; &quot;ae&quot;, &quot;&amp;thorn;&quot;-&amp;gt; &quot;th&quot;, &quot;&amp;szlig;&quot;-&amp;gt; &quot;ss&quot;, &quot;&amp;aacute;&quot;-&amp;gt; &quot;a&quot;, ... 보조 기능 spellfix1_translit (X)는 비 ASCII에서 ASCII 로의 맵핑 내장 된 lower (X) 함수는 소문자로 변환됩니다. 따라서 : k1 = lower (spellfix1_translit (word)). 단어가 이미 모두 소문자 ASCII이면 k1 열에 NULL이 포함됩니다. 이로 인해 % _vocab 테이블의 스토리지 요구 사항이 줄어들고 철자가 약간 더 빨리 실행되도록 도와줍니다. 따라서 소문자 ASCII 어휘를 사용하여 가능한 많은 철자 테이블을 채우는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2aea0dad5536afb073da7952899f42822308cf24" translate="yes" xml:space="preserve">
          <source>The working directory</source>
          <target state="translated">작업 디렉토리</target>
        </trans-unit>
        <trans-unit id="1191da9cfb737ab513b0974862b6931c34d468a3" translate="yes" xml:space="preserve">
          <source>The write-ahead log file, usually named &quot;X-wal&quot;.</source>
          <target state="translated">미리 쓰기 로그 파일 (일반적으로 &quot;X-wal&quot;)</target>
        </trans-unit>
        <trans-unit id="aa76cd0207c05b41731ac87f189a853ae60f3634" translate="yes" xml:space="preserve">
          <source>The write-ahead log or &quot;wal&quot; file is a roll-forward journal that records transactions that have been committed but not yet applied to the main database. Details on the format of the wal file are describe in the &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL format&lt;/a&gt; subsection of the main &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; document. The wal file is named by appending the four characters &quot;-wal&quot; to the end of the name of the main database file. Except on 8+3 filesystems, such names are not allowed, and in that case the file suffix is changed to &quot;.WAL&quot;. But as 8+3 filesystems are increasingly rare, that exceptional case can usually be ignored.</source>
          <target state="translated">미리 쓰기 로그 또는 &quot;wal&quot;파일은 커밋되었지만 아직 주 데이터베이스에 적용되지 않은 트랜잭션을 기록하는 롤 포워드 저널입니다. wal 파일의 형식에 대한 자세한 내용 은 기본 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 문서 의 &lt;a href=&quot;fileformat2#walformat&quot;&gt;WAL 형식&lt;/a&gt; 하위 섹션에 설명되어 있습니다. wal 파일은 기본 데이터베이스 파일 이름 끝에 네 개의 문자 &quot;-wal&quot;을 추가하여 이름이 지정됩니다. 8 + 3 파일 시스템을 제외하고 이러한 이름은 허용되지 않으며이 경우 파일 접미사가 &quot;.WAL&quot;로 변경됩니다. 그러나 8 + 3 파일 시스템이 점점 더 드물기 때문에 예외적 인 경우는 대개 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fcf91986e20f3838e989f19567544d31cd8c593" translate="yes" xml:space="preserve">
          <source>The writefile(X,Y) SQL function write the blob Y into the file named X and returns the number of bytes written. Use this function to extract the content of a single table column into a file. For example:</source>
          <target state="translated">writefile (X, Y) SQL 함수는 Blob Y를 X라는 파일에 기록하고 기록 된 바이트 수를 리턴합니다. 단일 테이블 열의 내용을 파일로 추출하려면이 기능을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35efa113638256d189c7bffd527a8b95982adee0" translate="yes" xml:space="preserve">
          <source>The writing test above is not completely fair, since SQLite is doing &lt;a href=&quot;transactional&quot;&gt;power-safe transactions&lt;/a&gt; whereas the direct-to-disk writing is not. To put the tests on a more equal footing, add either the --nosync option to the SQLite writes to disable calling fsync() or FlushFileBuffers() to force content to disk, or using the --fsync option for the direct-to-disk tests to force them to invoke fsync() or FlushFileBuffers() when updating disk files.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;transactional&quot;&gt;전원 안전 트랜잭션을 수행&lt;/a&gt; 하는 반면 디스크 직접 쓰기는 수행하지 않기 때문에 위의 쓰기 테스트는 완전히 공평 하지 않습니다. 테스트를보다 평등 한 위치에 두려면 --nosync 옵션을 SQLite 쓰기에 추가하여 fsync () 또는 FlushFileBuffers () 호출을 비활성화하여 내용을 디스크에 강제로 적용하거나 --fsync 옵션을 사용하여 direct-to-- 디스크 테스트시 디스크 파일을 업데이트 할 때 fsync () 또는 FlushFileBuffers ()를 강제로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3500eedb790da60f6c7c2c2fe42347161ad2dc7e" translate="yes" xml:space="preserve">
          <source>The xAccess method is used to check for access permissions on a file. The filename will be UTF-8 encoded. The flags argument will be &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS&lt;/a&gt; to check for the existence of the file, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE&lt;/a&gt; to check to see if the file is both readable and writable, or &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; to check to see if the file is at least readable. The &quot;file&quot; named by the second parameter might be a directory or folder name.</source>
          <target state="translated">xAccess 메서드는 파일에 대한 액세스 권한을 확인하는 데 사용됩니다. 파일 이름은 UTF-8로 인코딩됩니다. 플래그 인수가 될 것입니다 &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_EXISTS이&lt;/a&gt; 파일의 존재를 확인하기 위해, &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READWRITE는&lt;/a&gt; 파일을 읽고 쓸 수, 또는 두 가지 모두 있는지 확인합니다 &lt;a href=&quot;c3ref/c_access_exists&quot;&gt;SQLITE_ACCESS_READ&lt;/a&gt; 파일이 적어도 읽을 수 있는지 확인합니다. 두 번째 매개 변수로 명명 된 &quot;파일&quot;은 디렉토리 또는 폴더 이름 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e3dceb3a3d82f8b52bd7f5b2f951ed3b0619691" translate="yes" xml:space="preserve">
          <source>The xAccess() method is invoked again to detect if the journal file is still in the file system. If it is, then it is a hot-journal file and SQLite tries to roll it back (see section</source>
          <target state="translated">저널 파일이 여전히 파일 시스템에 있는지 여부를 감지하기 위해 xAccess () 메소드가 다시 호출됩니다. 그렇다면 핫 저널 파일이고 SQLite는 롤백을 시도합니다 (섹션 참조).</target>
        </trans-unit>
        <trans-unit id="be1521ac61f6da801d0f89ccb40ef26362bd2aea" translate="yes" xml:space="preserve">
          <source>The xAccess() method of the VFS is allowed to return -1 to signal a memory allocation error.</source>
          <target state="translated">VFS의 xAccess () 메소드는 메모리 할당 오류를 알리기 위해 -1을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb116d3015d148d9aef4ab4eaf91f8dc7699911" translate="yes" xml:space="preserve">
          <source>The xBestIndex function may have requested the values of certain expressions using the aConstraintUsage[].argvIndex values of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure. Those values are passed to xFilter using the argc and argv parameters.</source>
          <target state="translated">xBestIndex 함수가 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 aConstraintUsage []. argvIndex 값을 사용하여 특정 표현식의 값을 요청했을 수 있습니다 . 이러한 값은 argc 및 argv 매개 변수를 사용하여 xFilter로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e673068c08d7f626c7139b66b363abe588afdbfb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method fills the idxNum and idxStr fields with information that communicates an indexing strategy to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. The information in idxNum and idxStr is arbitrary as far as the SQLite core is concerned. The SQLite core just copies the information through to the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method. Any desired meaning can be assigned to idxNum and idxStr as long as xBestIndex and xFilter agree on what that meaning is.</source>
          <target state="translated">xBestIndex 메소드는 색인 전략을 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 와 통신하는 정보로 idxNum 및 idxStr 필드를 채 웁니다 . idxNum 및 idxStr의 정보는 SQLite 코어에 관한 한 임의적입니다. SQLite 코어는 정보를 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드 로 복사합니다 . xBestIndex 및 xFilter가 해당 의미에 동의하는 한 원하는 의미를 idxNum 및 idxStr에 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7549b2c421b13b6947674708c7a5360fc1373a57" translate="yes" xml:space="preserve">
          <source>The xBestIndex method is required for every virtual table implementation.</source>
          <target state="translated">xBestIndex 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="6671b4241ef5e4b25933598f6cbd513b0faa9c69" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may optionally populate the idxFlags field with a mask of SQLITE_INDEX_SCAN_* flags. Currently there is only one such flag - SQLITE_INDEX_SCAN_UNIQUE. If the xBestIndex method sets this flag, SQLite assumes that the strategy may visit at most one row.</source>
          <target state="translated">xBestIndex 메소드는 선택적으로 idxFlags 필드를 SQLITE_INDEX_SCAN_ * 플래그의 마스크로 채울 수 있습니다. 현재 SQLITE_INDEX_SCAN_UNIQUE 플래그는 하나뿐입니다. xBestIndex 메소드가이 플래그를 설정하면 SQLite는 전략이 최대 하나의 행을 방문 할 수 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="60dc1bff84d7b24ecf260c549a70a2e550acd608" translate="yes" xml:space="preserve">
          <source>The xBestIndex method may set aConstraintUsage[].argvIndex entries to values greater than zero. Exactly one entry should be set to 1, another to 2, another to 3, and so forth up to as many or as few as the xBestIndex method wants. The EXPR of the corresponding constraints will then be passed in as the argv[] parameters to xFilter.</source>
          <target state="translated">xBestIndex 메소드는 aConstraintUsage []. argvIndex 항목을 0보다 큰 값으로 설정할 수 있습니다. 정확히 하나의 항목은 1, 다른 항목은 2, 다른 항목은 3 등으로 설정해야하며 xBestIndex 메소드가 원하는만큼 또는 그 이하로 설정해야합니다. 해당 제한 조건의 EXPR은 argv [] 매개 변수로 xFilter에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b0c67bb7b3ba635b9cd74ad89d5155e843f934eb" translate="yes" xml:space="preserve">
          <source>The xBestIndex method should return SQLITE_OK on success. If any kind of fatal error occurs, an appropriate error code (ex: &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;) should be returned instead.</source>
          <target state="translated">xBestIndex 메소드는 성공시 SQLITE_OK를 리턴해야합니다. 치명적인 오류가 발생하면 적절한 오류 코드 (예 : &lt;a href=&quot;rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; )가 대신 반환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6e2147722085d4c968213130f4ef993a32c73b66" translate="yes" xml:space="preserve">
          <source>The xBestIndex method will be invoked once for each of the potential plans above. For plan 1, the aConstraint[].usable flag for for the SQLITE_CONSTRAINT_EQ constraint on the param1 column will be true because the right-hand side value for the &quot;param1 = ?&quot; constraint will be known, since it is determined by the outer realtab loop. But for plan 2, the aConstraint[].usable flag for &quot;param1 = ?&quot; will be false because the right-hand side value is determined by an inner loop and is thus an unknown quantity. Because param1 is a required input to the table-valued functions, the xBestIndex method should return SQLITE_CONSTRAINT when presented with plan 2, indicating that a required input is missing. This forces the query planner to select plan 1.</source>
          <target state="translated">xBestIndex 메소드는 위의 각 잠재적 계획마다 한 번씩 호출됩니다. 계획 1의 경우 &quot;param1 =?&quot;의 오른쪽 값 때문에 param1 열의 SQLITE_CONSTRAINT_EQ 제약 조건에 대한 aConstraint []. usable 플래그가 true가됩니다. 제약 조건은 외부 realtab 루프에 의해 결정되므로 알 수 있습니다. 그러나 계획 2의 경우 &quot;param1 =?&quot;에 대한 aConstraint []. usable 플래그 오른쪽 값은 내부 루프에 의해 결정되므로 알 수없는 수량이기 때문에 false입니다. param1은 테이블 반환 함수에 대한 필수 입력이므로 계획 2가 표시되면 xBestIndex 메서드가 SQLITE_CONSTRAINT를 반환하여 필수 입력이 누락되었음을 나타냅니다. 쿼리 플래너가 계획 1을 선택하도록합니다.</target>
        </trans-unit>
        <trans-unit id="c5e6a28d9d92d2bf9deb3f28a367d165a9d141f6" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">xCachesize () 메소드는 언제든지 SQLite에 의해 호출되어 제안 된 최대 캐시 크기 (저장된 페이지 수)를 첫 번째 인수로 전달 된 캐시 인스턴스로 설정할 수 있습니다. 이것은 SQLite &quot; &lt;a href=&quot;../pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;명령을 사용하여 구성된 값 입니다. bPurgeable 매개 변수와 마찬가지로 구현시이 값으로 작업을 수행 할 필요는 없습니다. 단지 자문 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="64860c154593114b929547aef1bfe359a445dd93" translate="yes" xml:space="preserve">
          <source>The xCachesize() method may be called at any time by SQLite to set the suggested maximum cache-size (number of pages stored by) the cache instance passed as the first argument. This is the value configured using the SQLite &quot;&lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt;&quot; command. As with the bPurgeable parameter, the implementation is not required to do anything with this value; it is advisory only.</source>
          <target state="translated">xCachesize () 메소드는 언제든지 SQLite에 의해 호출되어 제안 된 최대 캐시 크기 (저장된 페이지 수)를 첫 번째 인수로 전달 된 캐시 인스턴스로 설정할 수 있습니다. 이것은 SQLite &quot; &lt;a href=&quot;pragma#pragma_cache_size&quot; id=&quot;thexcachesizepagecachemethod&quot;&gt;PRAGMA cache_size&lt;/a&gt; &quot;명령을 사용하여 구성된 값 입니다. bPurgeable 매개 변수와 마찬가지로 구현시이 값으로 작업을 수행 할 필요는 없습니다. 단지 자문 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="76bfcc9d387b84934d7209d1ccf2568a52cae2ff" translate="yes" xml:space="preserve">
          <source>The xCheckReservedLock() method checks to see if another connection or another process is currently holding a reserved, pending, or exclusive lock on the file. It returns true or false.</source>
          <target state="translated">xCheckReservedLock () 메소드는 다른 연결 또는 다른 프로세스가 현재 파일에 대해 예약, 보류 또는 독점 잠금을 보유하고 있는지 확인합니다. true 또는 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5108534fb3c98c994a35c533b42cb72d472a86d4" translate="yes" xml:space="preserve">
          <source>The xClose method closes a cursor previously opened by &lt;a href=&quot;vtab#xopen&quot;&gt;xOpen&lt;/a&gt;. The SQLite core will always call xClose once for each cursor opened using xOpen.</source>
          <target state="translated">xClose 방법은 이전에 열 커서 닫 &lt;a href=&quot;vtab#xopen&quot;&gt;XOPEN을&lt;/a&gt; . SQLite 코어는 xOpen을 사용하여 열린 각 커서에 대해 항상 xClose를 한 번 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a1fcaec496244ffb2502893506be9bff99222ddb" translate="yes" xml:space="preserve">
          <source>The xClose method closes the file. The space for the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; structure is deallocated by the caller. But if the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; contains pointers to other allocated memory or resources, those allocations should be released by the xClose method.</source>
          <target state="translated">xClose 메소드는 파일을 닫습니다. &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 구조를 위한 공간 은 호출자가 할당 해제합니다. 그러나 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 에 다른 할당 된 메모리 나 자원에 대한 포인터가 포함되어 있으면 xClose 메소드로 해당 할당을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="2af5d67c2c34fed358127148fe670412a17ae024" translate="yes" xml:space="preserve">
          <source>The xClose method is required for every virtual table implementation.</source>
          <target state="translated">xClose 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="57537332c9edcb104197db5e7bb9793f5df28547" translate="yes" xml:space="preserve">
          <source>The xColumn method is required for every virtual table implementation.</source>
          <target state="translated">xColumn 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ef93eeb561a6057de6700b4a7eda4c4170148438" translate="yes" xml:space="preserve">
          <source>The xColumnSize API always returns -1. There is no way to determine the number of tokens in a value stored within a contentless FTS5 table configured with columnsize=0.</source>
          <target state="translated">xColumnSize API는 항상 -1을 반환합니다. columnsize = 0으로 구성된 contentless FTS5 테이블에 저장된 값의 토큰 수를 결정하는 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e2d00478c87bed4be4b97709f42f53211a90ec1" translate="yes" xml:space="preserve">
          <source>The xConnect method is required for every virtual table implementation, though the &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; and xConnect pointers of the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; object may point to the same function if the virtual table does not need to initialize backing store.</source>
          <target state="translated">&lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 및 xConnect 포인터 이지만 xConnect 메소드는 모든 가상 테이블 구현에 필요합니다.가상 테이블이 백업 저장소를 초기화 할 필요가없는 경우 객체 동일한 기능을 가리킬 수 .</target>
        </trans-unit>
        <trans-unit id="3a84b2667247b1e27fdcdd3d4cc56221f573c090" translate="yes" xml:space="preserve">
          <source>The xConnect method is very similar to &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt;. It has the same parameters and constructs a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure just like xCreate. And it must also call &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; like xCreate.</source>
          <target state="translated">xConnect 방법은 매우 유사하다 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; . 동일한 매개 변수를 가지며 xCreate와 마찬가지로 새로운 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조를 구성합니다 . 또한 xCreate와 같이 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()을&lt;/a&gt; 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ec50befd1d20d9f6756f231c4255cc685afba32" translate="yes" xml:space="preserve">
          <source>The xConnect method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">xConnect 방법은 반환해야합니다 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 이 새로운 가상 테이블 또는 생성에 성공하면 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 가 성공하지 못한 경우. 성공하지 못하면 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조를 할당 하면 안됩니다 . 실패하면 * pzErr에 오류 메시지가 선택적으로 리턴 될 수 있습니다. SQLite 코어가 오류가 애플리케이션에보고 된 후 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 사용하여 공간을 확보하려고 시도하므로 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 와 같은 SQLite 메모리 할당 함수를 사용하여 오류 메시지 문자열을 보유 할 공간을 할당해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6920f3a6545664c297cabaad1f1d797cb28640a2" translate="yes" xml:space="preserve">
          <source>The xCreate and xConnect methods are only different when the virtual table has some kind of backing store that must be initialized the first time the virtual table is created. The xCreate method creates and initializes the backing store. The xConnect method just connects to an existing backing store. When xCreate and xConnect are the same, the table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;.</source>
          <target state="translated">xCreate 및 xConnect 메소드는 가상 테이블에 가상 테이블이 처음 생성 될 때 초기화되어야하는 일종의 백업 저장소가있는 경우에만 다릅니다. xCreate 메소드는 백업 저장소를 작성하고 초기화합니다. xConnect 메소드는 기존 백업 저장소에 연결합니다. xCreate와 xConnect가 동일한 경우 테이블은 &lt;a href=&quot;vtab#epovtab&quot;&gt;가상 가상 테이블&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dcf39a347f064ec02d2e007cec689340fd805ffc" translate="yes" xml:space="preserve">
          <source>The xCreate method is called to create a new instance of a virtual table in response to a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. If the xCreate method is the same pointer as the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method, then the virtual table is an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt;. If the xCreate method is omitted (if it is a NULL pointer) then the virtual table is an &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문 에 대한 응답으로 가상 테이블의 새 인스턴스를 작성하기 위해 xCreate 메소드가 호출됩니다 . xCreate 방법은 같은 포인터 경우 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect에&lt;/a&gt; 있어서, 다음 가상 테이블은 인 &lt;a href=&quot;vtab#epovtab&quot;&gt;시조 가상 테이블&lt;/a&gt; . xCreate 메소드가 생략 된 경우 (NULL 포인터 인 경우) 가상 테이블은 시상 &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;전용 가상 테이블&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fa820ae673d5a152c6735ecfbe5a6902d1afc09" translate="yes" xml:space="preserve">
          <source>The xCreate method need not initialize the pModule, nRef, and zErrMsg fields of the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; object. The SQLite core will take care of that chore.</source>
          <target state="translated">xCreate 메소드는 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 오브젝트 의 pModule, nRef 및 zErrMsg 필드를 초기화하지 않아도 됩니다. SQLite 코어가 그 일을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="06c7e419a8719bf400eb11e6ddbab813f843fcfc" translate="yes" xml:space="preserve">
          <source>The xCreate should return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if it is successful in creating the new virtual table, or &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if it is not successful. If not successful, the &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure must not be allocated. An error message may optionally be returned in *pzErr if unsuccessful. Space to hold the error message string must be allocated using an SQLite memory allocation function like &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; as the SQLite core will attempt to free the space using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; after the error has been reported up to the application.</source>
          <target state="translated">xCreate은 반환해야 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 이 새로운 가상 테이블 또는 생성에 성공하면 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 가 성공하지 못한 경우. 성공하지 못하면 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조를 할당 하면 안됩니다 . 실패하면 * pzErr에 오류 메시지가 선택적으로 리턴 될 수 있습니다. SQLite 코어가 오류가 애플리케이션에보고 된 후 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 사용하여 공간을 확보하려고 시도하므로 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 와 같은 SQLite 메모리 할당 함수를 사용하여 오류 메시지 문자열을 보유 할 공간을 할당해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f958ace0be88d27965e6fd7b0b417f1f44eb7a29" translate="yes" xml:space="preserve">
          <source>The xCurrentTime method finds the current time and date and writes the result as a double-precision floating point value into pointer provided by the second parameter. The time and date is in coordinated universal time (UTC) and is a fractional Julian day number.</source>
          <target state="translated">xCurrentTime 메소드는 현재 시간과 날짜를 찾고 결과를 배정 밀도 부동 소수점 값으로 두 번째 매개 변수가 제공하는 포인터에 씁니다. 시간과 날짜는 협정 세계시 (UTC)이며 소수 줄리안 일수입니다.</target>
        </trans-unit>
        <trans-unit id="6df2a95b2c02a08ca9301c1af593f076dcec3de1" translate="yes" xml:space="preserve">
          <source>The xDelete callback, if one is specified, is also invoked on the auxiliary data pointer after the FTS5 query has finished.</source>
          <target state="translated">지정된 경우 xDelete 콜백도 FTS5 쿼리가 완료된 후 보조 데이터 포인터에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="684db9583b8006f9c3587ed123a3291e36233a15" translate="yes" xml:space="preserve">
          <source>The xDelete method in the built-in &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; now return SQLITE_IOERR_DELETE_NOENT if the file to be deleted does not exist.</source>
          <target state="translated">내장의 xDelete 방법 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; 파일이 삭제 될 경우 지금 돌아 SQLITE_IOERR_DELETE_NOENT가 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8acbdfc184b8627360b75ab194ff6c7691155e56" translate="yes" xml:space="preserve">
          <source>The xDelete method is used to delete a file. The name of the file is given in the second parameter. The filename will be in UTF-8. The VFS must convert the filename into whatever character representation the underlying operating system expects. If the syncDir parameter is true, then the xDelete method should not return until the change to the directory contents for the directory containing the deleted file have been synced to disk in order to ensure that the file does not &quot;reappear&quot; if a power failure occurs soon after.</source>
          <target state="translated">xDelete 메소드는 파일을 삭제하는 데 사용됩니다. 파일 이름은 두 번째 매개 변수에 제공됩니다. 파일 이름은 UTF-8입니다. VFS는 파일 이름을 기본 운영 체제가 기대하는 문자 표현으로 변환해야합니다. syncDir 매개 변수가 true 인 경우 정전이 발생한 경우 파일이 &quot;다시 나타나지&quot;않도록하기 위해 삭제 된 파일을 포함하는 디렉토리의 디렉토리 내용 변경이 디스크에 동기화 될 때까지 xDelete 메소드가 리턴되지 않아야합니다. 곧바로.</target>
        </trans-unit>
        <trans-unit id="11b2a4e02961f3a81754bcacd1c2618edac811a1" translate="yes" xml:space="preserve">
          <source>The xDestroy callback is &lt;u&gt;not&lt;/u&gt; called if the sqlite3_create_collation_v2() function fails. Applications that invoke sqlite3_create_collation_v2() with a non-NULL xDestroy argument should check the return code and dispose of the application data pointer themselves rather than expecting SQLite to deal with it for them. This is different from every other SQLite interface. The inconsistency is unfortunate but cannot be changed without breaking backwards compatibility.</source>
          <target state="translated">sqlite3_create_collation_v2 () 함수가 실패하면 xDestroy 콜백이 호출 &lt;u&gt;되지 않습니다&lt;/u&gt; . NULL이 아닌 xDestroy 인수로 sqlite3_create_collation_v2 ()를 호출하는 응용 프로그램은 리턴 코드를 점검하고 SQLite가 처리 할 것으로 예상하지 않고 응용 프로그램 데이터 포인터 자체를 처리해야합니다. 이것은 다른 모든 SQLite 인터페이스와 다릅니다. 불일치는 유감 스럽지만 이전 버전과의 호환성을 유지하지 않으면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="82fcb2416a6d15ad9c7eed2868bb3c1083659be9" translate="yes" xml:space="preserve">
          <source>The xDestroy method is required for every virtual table implementation, though it is acceptable for the &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; and xDestroy methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">xDisstroy 메소드는 모든 가상 테이블 구현에 필요하지만 &lt;a href=&quot;vtab#xdisconnect&quot;&gt;xDisconnect&lt;/a&gt; 및 xDestroy 메소드가 특정 가상 테이블에 적합한 경우 동일한 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="433eafbb64ee6df6fcf2cd0863165758dd2318f2" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy () 메소드는 xCreate ()에 의해 할당 된 캐시를 삭제하는 데 사용됩니다. 지정된 캐시와 연관된 모든 자원을 해제해야합니다. xitestroy () 메소드를 호출 한 후 SQLite는 &lt;a href=&quot;#sqlite3_pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; 핸들이 유효하지 않은 것으로 간주하고 다른 sqlite3_pcache_methods2 함수와 함께 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8baf35611bcad0c5db55f35fee163e2aa0c149e9" translate="yes" xml:space="preserve">
          <source>The xDestroy() method is used to delete a cache allocated by xCreate(). All resources associated with the specified cache should be freed. After calling the xDestroy() method, SQLite considers the &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache*&lt;/a&gt; handle invalid, and will not use it with any other sqlite3_pcache_methods2 functions.</source>
          <target state="translated">xDestroy () 메소드는 xCreate ()에 의해 할당 된 캐시를 삭제하는 데 사용됩니다. 지정된 캐시와 연관된 모든 자원을 해제해야합니다. xitestroy () 메소드를 호출 한 후 SQLite는 &lt;a href=&quot;pcache&quot; id=&quot;thexdestroypagecachemethod&quot;&gt;sqlite3_pcache *&lt;/a&gt; 핸들이 유효하지 않은 것으로 간주하고 다른 sqlite3_pcache_methods2 함수와 함께 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="604385447aab898766cb3896d8016d04ab97fc0d" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xDeviceCharacteristics 메소드 는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 참조 하는 파일을 보유하는 대용량 저장 장치의 I / O 특성을 나타내는 이러한 비트 값의 벡터 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b98ec973b9735d7dd446dd0f56fe3b7eb0a27d7c" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object returns an integer which is a vector of these bit values expressing I/O characteristics of the mass storage device that holds the file that the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; refers to.</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xDeviceCharacteristics 메소드 는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods가&lt;/a&gt; 참조 하는 파일을 보유하는 대용량 저장 장치의 I / O 특성을 나타내는 이러한 비트 값의 벡터 인 정수를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c2e8466b1e208836960d6bb4f90ed3ea7832fd67" translate="yes" xml:space="preserve">
          <source>The xDeviceCharacteristics method returns an integer bit vector that defines any special properties that the underlying storage medium might have that SQLite can use to increase performance. The allowed return is the bit-wise OR of the following values:</source>
          <target state="translated">xDeviceCharacteristics 메소드는 기본 저장 매체가 SQLite가 성능 향상을 위해 사용할 수있는 특수 특성을 정의하는 정수 비트 벡터를 리턴합니다. 허용되는 반환 값은 다음 값의 비트 단위 OR입니다.</target>
        </trans-unit>
        <trans-unit id="1262b3501d52f25dbe2da92b37772cb17c293d40" translate="yes" xml:space="preserve">
          <source>The xDisconnect method is required for every virtual table implementation, though it is acceptable for the xDisconnect and &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; methods to be the same function if that makes sense for the particular virtual table.</source>
          <target state="translated">xDisconnect 메소드는 모든 가상 테이블 구현에 필요하지만 xDisconnect 및 &lt;a href=&quot;vtab#sqlite3_module.xDestroy&quot;&gt;xDestroy&lt;/a&gt; 메소드가 특정 가상 테이블에 적합한 경우 동일한 기능이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80202d349ad4d59a55548ad8afd689feeefba61b" translate="yes" xml:space="preserve">
          <source>The xDlOpen, xDlError, xDlSym, and xDlClose methods are all used for accessing shared libraries at run-time. These methods may be omitted (and their pointers set to zero) if the library is compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; or if the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface is never used to enable dynamic extension loading. The xDlOpen method opens a shared library or DLL and returns a pointer to a handle. NULL is returned if the open fails. If the open fails, the xDlError method can be used to obtain a text error message. The message is written into the zErrMsg buffer of the third parameter which is at least nByte bytes in length. The xDlSym returns a pointer to a symbol in the shared library. The name of the symbol is given by the second parameter. UTF-8 encoding is assumed. If the symbol is not found a NULL pointer is returned. The xDlClose routine closes the shared library.</source>
          <target state="translated">xDlOpen, xDlError, xDlSym 및 xDlClose 메소드는 모두 런타임시 공유 라이브러리에 액세스하는 데 사용됩니다. 라이브러리가 &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; 으로 컴파일 되거나 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension () 인&lt;/a&gt; 경우 이러한 메소드를 생략하고 포인터를 0으로 설정할 수 있습니다.인터페이스는 동적 확장 로딩을 활성화하는 데 사용되지 않습니다. xDlOpen 메소드는 공유 라이브러리 또는 DLL을 열고 핸들에 대한 포인터를 리턴합니다. 열기에 실패하면 NULL이 반환됩니다. 열기에 실패하면 xDlError 메소드를 사용하여 텍스트 오류 메시지를 얻을 수 있습니다. 메시지는 적어도 nByte 바이트 길이 인 세 번째 매개 변수의 zErrMsg 버퍼에 기록됩니다. xDlSym은 공유 라이브러리의 심볼에 대한 포인터를 반환합니다. 심볼의 이름은 두 번째 매개 변수로 제공됩니다. UTF-8 인코딩이 가정됩니다. 기호가 없으면 NULL 포인터가 반환됩니다. xDlClose 루틴은 공유 라이브러리를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="2a328c23f376e27049c3463e790fd30ea24be07c" translate="yes" xml:space="preserve">
          <source>The xEof method is required for every virtual table implementation.</source>
          <target state="translated">xEof 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2f524de9f6418ba3f20971cbbb6e678439f267fb" translate="yes" xml:space="preserve">
          <source>The xEof method must return false (zero) if the specified cursor currently points to a valid row of data, or true (non-zero) otherwise. This method is called by the SQL engine immediately after each &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; and &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; invocation.</source>
          <target state="translated">지정된 커서가 현재 유효한 데이터 행을 가리키는 경우 xEof 메소드는 false (0)를 리턴하고 그렇지 않으면 true (0이 아닌)를 리턴해야합니다. 이 메소드는 각 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 및 &lt;a href=&quot;vtab#xnext&quot;&gt;xNext&lt;/a&gt; 호출 직후 SQL 엔진에 의해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="31055a962a7bb13c9dfa534ee5cb14dc7402ab08" translate="yes" xml:space="preserve">
          <source>The xFetch() method locates a page in the cache and returns a pointer to an sqlite3_pcache_page object associated with that page, or a NULL pointer. The pBuf element of the returned sqlite3_pcache_page object will be a pointer to a buffer of szPage bytes used to store the content of a single database page. The pExtra element of sqlite3_pcache_page will be a pointer to the szExtra bytes of extra storage that SQLite has requested for each entry in the page cache.</source>
          <target state="translated">xFetch () 메소드는 캐시에서 페이지를 찾아 해당 페이지와 연관된 sqlite3_pcache_page 오브젝트에 대한 포인터 또는 NULL 포인터를 리턴합니다. 리턴 된 sqlite3_pcache_page 오브젝트의 pBuf 요소는 단일 데이터베이스 페이지의 컨텐츠를 저장하는 데 사용되는 szPage 바이트 버퍼에 대한 포인터입니다. sqlite3_pcache_page의 pExtra 요소는 SQLite가 페이지 캐시의 각 항목에 대해 요청한 추가 스토리지의 szExtra 바이트에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="eec30896c07568e6756a1fd11de9a9be38006b51" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the (new and experimental) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer which is intended to be a pointer to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves opcodes less than 100 for its own use. A &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts.</source>
          <target state="translated">xFileControl () 메소드는 커스텀 VFS 구현이 (신규 및 실험적) &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 열린 파일을 직접 제어 할 수있는 일반 인터페이스입니다 . 두 번째 &quot;op&quot;인수는 정수 opcode입니다. 세 번째 인수는 반환 값을 쓸 인수 또는 공백을 포함 할 수있는 구조에 대한 포인터를 가리키는 일반 포인터입니다. xFileControl ()의 잠재적 사용은 시간 초과로 잠금을 차단하고 잠금 전략을 변경하거나 (예 : 도트 파일 잠금을 사용하여) 잠금 상태를 문의하거나 오래된 잠금을 해제하는 기능 일 수 있습니다. SQLite 코어는 자체 사용을 위해 opcode를 100 미만으로 예약합니다. ㅏ&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntllockstate&quot;&gt; 옵 코드의 목록&lt;/a&gt;100 개 미만이 사용 가능합니다. 사용자 정의 xFileControl 메소드를 정의하는 응용 프로그램은 충돌을 피하기 위해 100보다 큰 opcode를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dddf7acfafd6d3f8269f8f981d3bcbe57970b96a" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl () 메소드는 사용자 정의 VFS 구현이 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 열린 파일을 직접 제어 할 수있는 일반 인터페이스입니다 . 두 번째 &quot;op&quot;인수는 정수 opcode입니다. 세 번째 인수는 반환 값을 쓸 인수 또는 공백을 포함 할 수있는 구조를 가리키는 일반 포인터입니다. xFileControl ()의 잠재적 사용은 시간 초과로 잠금을 차단하고 잠금 전략을 변경하거나 (예 : 도트 파일 잠금을 사용하여) 잠금 상태를 문의하거나 오래된 잠금을 해제하는 기능 일 수 있습니다. SQLite 코어는 자체 사용을 위해 모든 opcode를 100 미만으로 예약합니다. &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;옵 코드의 목록&lt;/a&gt;100 개 미만이 사용 가능합니다. 사용자 정의 xFileControl 메소드를 정의하는 응용 프로그램은 충돌을 피하기 위해 100보다 큰 opcode를 사용해야합니다. VFS 구현은 인식하지 못하는 파일 제어 opcode에 대해 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0cff0bc514819c033ff2d05910e11b13ceab5fce" translate="yes" xml:space="preserve">
          <source>The xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface. The second &quot;op&quot; argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;list of opcodes&lt;/a&gt; less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; for file control opcodes that they do not recognize.</source>
          <target state="translated">xFileControl () 메소드는 사용자 정의 VFS 구현이 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스를 사용하여 열린 파일을 직접 제어 할 수있는 일반 인터페이스입니다 . 두 번째 &quot;op&quot;인수는 정수 opcode입니다. 세 번째 인수는 반환 값을 쓸 인수 또는 공백을 포함 할 수있는 구조를 가리키는 일반 포인터입니다. xFileControl ()의 잠재적 사용은 시간 초과로 잠금을 차단하고 잠금 전략을 변경하거나 (예 : 도트 파일 잠금을 사용하여) 잠금 상태를 문의하거나 오래된 잠금을 해제하는 기능 일 수 있습니다. SQLite 코어는 자체 사용을 위해 모든 opcode를 100 미만으로 예약합니다. ㅏ&lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;옵 코드의 목록&lt;/a&gt;100 개 미만이 사용 가능합니다. 사용자 정의 xFileControl 메소드를 정의하는 응용 프로그램은 충돌을 피하기 위해 100보다 큰 opcode를 사용해야합니다. VFS 구현은 인식하지 못하는 파일 제어 opcode에 대해 &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; 를 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3203c926180842d31c782d904c037633ddf2f91f" translate="yes" xml:space="preserve">
          <source>The xFileSize() method determines the current size of the file in bytes and writes that value into *pSize. It returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; if something goes wrong.</source>
          <target state="translated">xFileSize () 메소드는 파일의 현재 크기를 바이트 단위로 판별하여 해당 값을 * pSize에 씁니다. 성공 하면 &lt;a href=&quot;rescode#ioerr_fstat&quot;&gt;SQLITE_OK를&lt;/a&gt; , 무언가 잘못되면 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_IOERR_FSTAT&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="96653ab4bb654a8e871b1a8c14aa48716aadb8ae" translate="yes" xml:space="preserve">
          <source>The xFilter method is required for every virtual table implementation.</source>
          <target state="translated">모든 가상 테이블 구현에 xFilter 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4479f4bd625e3440b28fa60e755d9671817cfbcf" translate="yes" xml:space="preserve">
          <source>The xFullPathname method is used to convert a relative pathname into a full pathname. The resulting full pathname is written into the buffer provided by the third parameter. SQLite will size the output buffer to at least mxPathname bytes. Both the input and output names should be in UTF-8.</source>
          <target state="translated">xFullPathname 메소드는 상대 경로 이름을 전체 경로 이름으로 변환하는 데 사용됩니다. 결과 전체 경로 이름은 세 번째 매개 변수에서 제공 한 버퍼에 기록됩니다. SQLite는 출력 버퍼의 크기를 mxPathname 바이트 이상으로 조정합니다. 입력 및 출력 이름은 모두 UTF-8이어야합니다.</target>
        </trans-unit>
        <trans-unit id="5dbd41bd881211c13a1dbbcb8c736851e1bf5d97" translate="yes" xml:space="preserve">
          <source>The xGeom callback always does a depth-first search of the r-tree.</source>
          <target state="translated">xGeom 콜백은 항상 r- 트리의 깊이 우선 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="454e11b15802805175a3b539debe13d361beb72d" translate="yes" xml:space="preserve">
          <source>The xGetTempName method computes the name of a temporary file that SQLite can use. The name should be written into the buffer given by the second parameter. SQLite will size that buffer to hold at least mxPathname bytes. The generated filename should be in UTF-8. To avoid security problems, the generated temporary filename should contain enough randomness to prevent an attacker from guessing the temporary filename in advance.</source>
          <target state="translated">xGetTempName 메소드는 SQLite가 사용할 수있는 임시 파일의 이름을 계산합니다. 이름은 두 번째 매개 변수가 제공 한 버퍼에 작성해야합니다. SQLite는 mxPathname 바이트 이상을 보유하도록 해당 버퍼의 크기를 조정합니다. 생성 된 파일 이름은 UTF-8이어야합니다. 보안 문제를 피하려면 생성 된 임시 파일 이름에 공격자가 임시 파일 이름을 미리 추측하지 못하도록 충분한 임의성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5d25f32f0f944f020730e420a59b761837d6fa20" translate="yes" xml:space="preserve">
          <source>The xGetTempname method has been removed from &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt;. In its place, the xOpen method is enhanced to open a temporary file of its own invention when the filename parameter is NULL.</source>
          <target state="translated">xGetTempname 메소드가 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 에서 제거되었습니다 . 대신, filename 매개 변수가 NULL 인 경우 xOpen 메소드가 자체 발명의 임시 파일을 열도록 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="e9de98bc73bd358a33146535bc6a4c0838edf0ac" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메소드는 메모리 할당자를 초기화합니다. 예를 들어, 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에 의해 획득 된 모든 자원을 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa9fa67f04b6378191cf480be2d31d4ea4b3e4c" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any require mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메소드는 메모리 할당자를 초기화합니다. 예를 들어, 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메소드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에 의해 획득 된 모든 자원을 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b5977e9a51901888e399d44616a096c8dd4ad36a" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메서드는 메모리 할당자를 초기화합니다. 예를 들어 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메서드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에서 획득 한 모든 리소스를 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f9b210b9a34cdea6b00c84f118c3818052de5137" translate="yes" xml:space="preserve">
          <source>The xInit method initializes the memory allocator. For example, it might allocate any required mutexes or initialize internal data structures. The xShutdown method is invoked (indirectly) by &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; and should deallocate any resources acquired by xInit. The pAppData pointer is used as the only parameter to xInit and xShutdown.</source>
          <target state="translated">xInit 메서드는 메모리 할당자를 초기화합니다. 예를 들어 필요한 뮤텍스를 할당하거나 내부 데이터 구조를 초기화 할 수 있습니다. xShutdown 메서드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 (간접적으로) 호출 되며 xInit에서 획득 한 모든 리소스를 할당 해제해야합니다. pAppData 포인터는 xInit 및 xShutdown에 대한 유일한 매개 변수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="928f04710edbd4aadd8a60154ed8a2e307eed0ef" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit () 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출에 대해 한 번만 호출됩니다 (일반적으로 프로세스 수명 동안 한 번만). xInit () 메소드에는 sqlite3_pcache_methods2.pArg 값의 사본이 전달됩니다. xInit () 메소드의 목적은 사용자 정의 페이지 캐시 구현에 필요한 글로벌 데이터 구조를 설정하는 것입니다. xInit () 메소드가 NULL이면 응용 프로그램 정의 페이지 캐시 대신 기본 제공 기본 페이지 캐시가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ba32c8d759124102ccc057ecbe6a0c1c85fb3b5" translate="yes" xml:space="preserve">
          <source>The xInit() method is called once for each effective call to &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize()&lt;/a&gt; (usually only once during the lifetime of the process). The xInit() method is passed a copy of the sqlite3_pcache_methods2.pArg value. The intent of the xInit() method is to set up global data structures required by the custom page cache implementation. If the xInit() method is NULL, then the built-in default page cache is used instead of the application defined page cache.</source>
          <target state="translated">xInit () 메소드는 &lt;a href=&quot;initialize&quot; id=&quot;thexinitpagecachemethod&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출에 대해 한 번만 호출됩니다 (일반적으로 프로세스 수명 동안 한 번만). xInit () 메소드에는 sqlite3_pcache_methods2.pArg 값의 사본이 전달됩니다. xInit () 메소드의 목적은 사용자 정의 페이지 캐시 구현에 필요한 글로벌 데이터 구조를 설정하는 것입니다. xInit () 메소드가 NULL이면 응용 프로그램 정의 페이지 캐시 대신 기본 제공 기본 페이지 캐시가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a32ff6fcc7d9e120e222fe6ef8bbf8b9661df8a" translate="yes" xml:space="preserve">
          <source>The xLock and xUnlock methods are used to set and clear file locks. SQLite supports five levels of file locks, in order:</source>
          <target state="translated">xLock 및 xUnlock 메소드는 파일 잠금을 설정하고 지우는 데 사용됩니다. SQLite는 5 가지 수준의 파일 잠금을 순서대로 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8a5c74b276f4ba001214e303873304b1cefc6f0e" translate="yes" xml:space="preserve">
          <source>The xMalloc, xRealloc, and xFree methods must work like the malloc(), realloc() and free() functions from the standard C library. SQLite guarantees that the second argument to xRealloc is always a value returned by a prior call to xRoundup.</source>
          <target state="translated">xMalloc, xRealloc 및 xFree 메소드는 표준 C 라이브러리의 malloc (), realloc () 및 free () 함수와 같이 작동해야합니다. SQLite는 xRealloc에 ​​대한 두 번째 인수가 항상 xRoundup에 대한 이전 호출에서 반환 된 값임을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="f3c67d901eafc4b8170f137f64b1ed5325131c31" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexEnd 메소드는 sqlite3_shutdown () 함수에 의해 시스템 종료의 일부로 호출됩니다. 이 메소드의 구현은, 뮤텍스 메소드 구현에 의해 취득 된 모든 미해결 자원, 특히 xMutexInit 메소드에 의해 취득 된 미해결 자원을 모두 공개 할 것으로 예상됩니다. xMutexEnd () 인터페이스는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()을&lt;/a&gt; 호출 할 때마다 정확히 한 번 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="29460abd69ce976afdb57bd86f856a912e6b2129" translate="yes" xml:space="preserve">
          <source>The xMutexEnd method defined by this structure is invoked as part of system shutdown by the sqlite3_shutdown() function. The implementation of this method is expected to release all outstanding resources obtained by the mutex methods implementation, especially those obtained by the xMutexInit method. The xMutexEnd() interface is invoked exactly once for each call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexEnd 메소드는 sqlite3_shutdown () 함수에 의해 시스템 종료의 일부로 호출됩니다. 이 메소드의 구현은, 뮤텍스 메소드 구현에 의해 취득 된 모든 미해결 자원, 특히 xMutexInit 메소드에 의해 취득 된 미해결 자원을 모두 공개 할 것으로 예상됩니다. xMutexEnd () 인터페이스는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()을&lt;/a&gt; 호출 할 때마다 정확히 한 번 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="cd4f06c8938e3564cfbf224eac3d8cf5b5b06a0d" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexInit 메소드는 sqlite3_initialize () 함수에 의한 시스템 초기화의 일부로 호출됩니다. SQLite는 xMutexInit 루틴을 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출마다 정확히 한 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dab4cb79a586f29424445d440e5fffbfe8ba4495" translate="yes" xml:space="preserve">
          <source>The xMutexInit method defined by this structure is invoked as part of system initialization by the sqlite3_initialize() function. The xMutexInit routine is called by SQLite exactly once for each effective call to &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt;.</source>
          <target state="translated">이 구조에 의해 정의 된 xMutexInit 메소드는 sqlite3_initialize () 함수에 의한 시스템 초기화의 일부로 호출됩니다. SQLite는 xMutexInit 루틴을 &lt;a href=&quot;initialize&quot;&gt;sqlite3_initialize ()에&lt;/a&gt; 대한 각 효과적인 호출마다 정확히 한 번 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="89ac720acef7b2cd1f40cadc5a9b4008a6051773" translate="yes" xml:space="preserve">
          <source>The xMutexInit() method must be threadsafe. It must be harmless to invoke xMutexInit() multiple times within the same process and without intervening calls to xMutexEnd(). Second and subsequent calls to xMutexInit() must be no-ops.</source>
          <target state="translated">xMutexInit () 메소드는 스레드 안전해야합니다. 동일한 프로세스 내에서 xMutexEnd ()를 호출하지 않고 xMutexInit ()를 여러 번 호출하는 것은 무해해야합니다. xMutexInit ()에 대한 두 번째 및 후속 호출은 no-ops 여야합니다.</target>
        </trans-unit>
        <trans-unit id="35cc67c51c972e7defc85a2cd19b646cf64aa418" translate="yes" xml:space="preserve">
          <source>The xNext method advances a &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;virtual table cursor&lt;/a&gt; to the next row of a result set initiated by &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;. If the cursor is already pointing at the last row when this routine is called, then the cursor no longer points to valid data and a subsequent call to the &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; method must return true (non-zero). If the cursor is successfully advanced to another row of content, then subsequent calls to &lt;a href=&quot;vtab#xeof&quot;&gt;xEof&lt;/a&gt; must return false (zero).</source>
          <target state="translated">xNext 메소드 는 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter가&lt;/a&gt; 시작한 결과 세트의 다음 행으로 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;가상 테이블 커서&lt;/a&gt; 를 진행 시킵니다 . 이 루틴이 호출 될 때 커서가 이미 마지막 행을 가리키는 경우, 커서는 더 이상 유효한 데이터를 가리 &lt;a href=&quot;vtab#xeof&quot;&gt;키지 않으며 xEof&lt;/a&gt; 메소드에 대한 후속 호출 은 true (0이 아님)를 리턴해야합니다. 커서가 다른 내용의 행으로 성공적으로 이동 한 경우 &lt;a href=&quot;vtab#xeof&quot;&gt;xEof에 대한&lt;/a&gt; 후속 호출 은 false (영)를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c07bbf2e5005e8108d2f1c166d0b989d5b0ef5de" translate="yes" xml:space="preserve">
          <source>The xNext method is required for every virtual table implementation.</source>
          <target state="translated">모든 가상 테이블 구현에는 xNext 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eee0d952c4251db31a384eceabf2a26d2118eb4d" translate="yes" xml:space="preserve">
          <source>The xOpen method creates a new cursor used for accessing (read and/or writing) a virtual table. A successful invocation of this method will allocate the memory for the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (or a subclass), initialize the new object, and make *ppCursor point to the new object. The successful call then returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;.</source>
          <target state="translated">xOpen 메소드는 가상 테이블에 액세스 (읽기 및 / 또는 쓰기)하는 데 사용되는 새 커서를 작성합니다. 이 메소드를 성공적으로 호출하면 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; (또는 서브 클래스)에 메모리를 할당 하고 새 오브젝트를 초기화하고 * ppCursor가 새 오브젝트를 가리키게합니다. 그런 다음 성공적인 호출은 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="00b35252e3240b77ad5fc35ac862013d23c8ea89" translate="yes" xml:space="preserve">
          <source>The xOpen method is required for every virtual table implementation.</source>
          <target state="translated">모든 가상 테이블 구현에는 xOpen 메소드가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fe219d8e760e2d5872424a8a4fa6980f7d9bd820" translate="yes" xml:space="preserve">
          <source>The xOpen method need not initialize the pVtab field of the &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; structure. The SQLite core will take care of that chore automatically.</source>
          <target state="translated">xOpen 메소드는 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; 구조 의 pVtab 필드를 초기화하지 않아도 됩니다. SQLite 코어는 해당 작업을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5883a2e08ea426f3d0e98ebbcc84b207e43eeb5d" translate="yes" xml:space="preserve">
          <source>The xOutput callback is invoked zero or more times to return data to the application. The first parameter passed to each call is a copy of the pOut pointer supplied by the application. The second parameter, pData, points to a buffer nData bytes in size containing the chunk of output data being returned. If the xOutput callback successfully processes the supplied data, it should return SQLITE_OK to indicate success. Otherwise, it should return some other SQLite error code. In this case processing is immediately abandoned and the streaming API function returns a copy of the xOutput error code to the application.</source>
          <target state="translated">데이터를 애플리케이션으로 리턴하기 위해 xOutput 콜백이 0 회 이상 호출됩니다. 각 호출에 전달되는 첫 번째 매개 변수는 응용 프로그램에서 제공 한 pOut 포인터의 사본입니다. 두 번째 매개 변수 pData는 반환되는 출력 데이터 청크를 포함하는 크기의 버퍼 nData 바이트를 가리 킵니다. xOutput 콜백이 제공된 데이터를 성공적으로 처리하면 성공을 표시하기 위해 SQLITE_OK를 리턴해야합니다. 그렇지 않으면 다른 SQLite 오류 코드를 반환해야합니다. 이 경우 처리가 즉시 중단되고 스트리밍 API 함수는 xOutput 오류 코드의 사본을 애플리케이션에 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4fdec734fe0825d4b45223206e7ef21a40dca7d6" translate="yes" xml:space="preserve">
          <source>The xPagecount() method must return the number of pages currently stored in the cache, both pinned and unpinned.</source>
          <target state="translated">xPagecount () 메소드는 현재 캐시에 저장된 페이지 수 (고정 및 비 고정)를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7670800549df532ce782308a5027526fc2bbf4f" translate="yes" xml:space="preserve">
          <source>The xQueryFunc must set the eWithin field of sqlite3_rtree_query_info to one of the values NOT_WITHIN, PARTLY_WITHIN, or FULLY_WITHIN depending on whether or not the bounding box defined by aCoord[] is completely outside the region, overlaps the region, or is completely inside the region, respectively. In addition, the xQueryFunc must set the rScore field to a non-negative value that indicates the order in which subtrees and entries of the query should be analyzed and returned. Smaller scores are processed first.</source>
          <target state="translated">xQueryFunc는 aCoord []에 의해 정의 된 경계 상자가 영역 외부에 있는지, 영역과 겹치거나 영역에 완전히 있는지 여부에 따라 sqlite3_rtree_query_info의 eWithin 필드를 NOT_WITHIN, PARTLY_WITHIN 또는 FULLY_WITHIN 값 중 하나로 설정해야합니다. 각기. 또한 xQueryFunc는 rScore 필드를 음수가 아닌 값으로 설정하여 쿼리의 하위 트리와 항목을 분석하고 반환해야하는 순서를 나타냅니다. 작은 점수가 먼저 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="243e65d787818469363333eb640b0b44f38c6ec4" translate="yes" xml:space="preserve">
          <source>The xRandomness method is used exactly once to initialize the pseudo-random number generator (PRNG) inside of SQLite. Only the xRandomness method on the default VFS is used. The xRandomness methods on other VFSes are never accessed by SQLite. The xRandomness routine requests that nByte bytes of randomness be written into zOut. The routine returns the actual number of bytes of randomness obtained. The quality of the randomness so obtained will determine the quality of the randomness generated by built-in SQLite functions such as random() and randomblob(). SQLite also uses its PRNG to generate temporary file names. On some platforms (ex: Windows) SQLite assumes that temporary file names are unique without actually testing for collisions, so it is important to have good-quality randomness even if the random() and randomblob() functions are never used.</source>
          <target state="translated">xRandomness 메소드는 SQLite 내에서 의사 난수 생성기 (PRNG)를 초기화하기 위해 정확히 한 번만 사용됩니다. 기본 VFS의 xRandomness 방법 만 사용됩니다. 다른 VFS의 xRandomness 메소드는 SQLite에서 액세스하지 않습니다. xRandomness 루틴은 임의의 nByte 바이트를 zOut에 기록하도록 요청합니다. 루틴은 획득 한 임의의 실제 바이트 수를 리턴합니다. 이렇게 얻은 난수의 품질은 random () 및 randomblob ()와 같은 내장 SQLite 함수에 의해 생성 된 난수의 품질을 결정합니다. SQLite는 PRNG를 사용하여 임시 파일 이름을 생성합니다. 일부 플랫폼 (예 : Windows)에서 SQLite는 임시 파일 이름이 실제로 충돌을 테스트하지 않고 고유하다고 가정하므로 random () 및 randomblob () 함수를 사용하지 않더라도 양질의 임의성을 갖는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2203fe5d9da94fc2d593e73757d6951b646a5aac" translate="yes" xml:space="preserve">
          <source>The xRandomness(), xSleep(), xCurrentTime(), and xCurrentTimeInt64() interfaces are not strictly a part of the filesystem, but they are included in the VFS structure for completeness. The xRandomness() function attempts to return nBytes bytes of good-quality randomness into zOut. The return value is the actual number of bytes of randomness obtained. The xSleep() method causes the calling thread to sleep for at least the number of microseconds given. The xCurrentTime() method returns a Julian Day Number for the current date and time as a floating point value. The xCurrentTimeInt64() method returns, as an integer, the Julian Day Number multiplied by 86400000 (the number of milliseconds in a 24-hour day). SQLite will use the xCurrentTimeInt64() method to get the current date and time if that method is available (if iVersion is 2 or greater and the function pointer is not NULL) and will fall back to xCurrentTime() if xCurrentTimeInt64() is unavailable.</source>
          <target state="translated">xRandomness (), xSleep (), xCurrentTime () 및 xCurrentTimeInt64 () 인터페이스는 파일 시스템의 일부가 아니지만 완전성을 위해 VFS 구조에 포함됩니다. xRandomness () 함수는 양질의 임의성 nBytes 바이트를 zOut으로 리턴하려고 시도합니다. 리턴 값은 획득 된 실제 임의 바이트 수입니다. xSleep () 메소드는 호출 스레드가 최소한 지정된 마이크로 초 동안 휴면 상태가되도록합니다. xCurrentTime () 메소드는 현재 날짜 및 시간에 대한 율리우스 일 수를 부동 소수점 값으로 리턴합니다. xCurrentTimeInt64 () 메소드는 율리우스 일 수에 86400000 (24 시간 동안 밀리 초 수)을 곱한 값을 정수로 리턴합니다.SQLite는 해당 메소드를 사용할 수있는 경우 (iVersion이 2 이상이고 함수 포인터가 NULL이 아닌 경우) xCurrentTimeInt64 () 메소드를 사용하여 현재 날짜 및 시간을 가져오고 xCurrentTimeInt64 ()를 사용할 수없는 경우 xCurrentTime ()으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="9578c347ea12c88b2a68bb1b8891cc899dd6f688" translate="yes" xml:space="preserve">
          <source>The xRead method reads iAmt bytes from the file beginning at a byte offset to iOfst. The data read is stored in the pointer of the second parameter. xRead returns the &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success, &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; if it was not able to read the full number of bytes because it reached end-of-file, or &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; for any other error.</source>
          <target state="translated">xRead 메소드는 파일에서 바이트 오프셋에서 iOfst로 iAmt 바이트를 읽습니다. 읽은 데이터는 두 번째 매개 변수의 포인터에 저장됩니다. xRead는 반환 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; , 성공을 &lt;a href=&quot;rescode#ioerr_short_read&quot;&gt;SQLITE_IOERR_SHORT_READ&lt;/a&gt; 이 파일의 마지막에 도달, 또는 때문에 바이트의 전체 수를 읽을 수 없습니다 경우 &lt;a href=&quot;rescode#ioerr_read&quot;&gt;SQLITE_IOERR_READ&lt;/a&gt; 다른 오류.</target>
        </trans-unit>
        <trans-unit id="179305437ddf972de11f25d6c031548629b7dbeb" translate="yes" xml:space="preserve">
          <source>The xRekey() method is used to change the key value associated with the page passed as the second argument. If the cache previously contains an entry associated with newKey, it must be discarded. Any prior cache entry associated with newKey is guaranteed not to be pinned.</source>
          <target state="translated">xRekey () 메소드는 두 번째 인수로 전달 된 페이지와 연관된 키 값을 변경하는 데 사용됩니다. 캐시에 이전에 newKey와 연관된 항목이 포함 된 경우이를 버려야합니다. newKey와 관련된 이전 캐시 항목은 고정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee97077a16637439ff4f073f89fa74d3ae66efba" translate="yes" xml:space="preserve">
          <source>The xRename method is optional. If omitted, then the virtual table may not be renamed using the ALTER TABLE RENAME command.</source>
          <target state="translated">xRename 방법은 선택 사항입니다. 생략하면 ALTER TABLE RENAME 명령을 사용하여 가상 테이블의 이름을 바꿀 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac1529fc1db9096e5e7532c56994cf7e11a7e7d4" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup 메소드는 특정 요청 크기가 주어진 경우 할당 된 메모리 할당 크기를 반환합니다. 대부분의 메모리 할당자는 메모리 할당을 8의 다음 배수로 반올림합니다. 일부 할당자는 더 큰 배수 또는 2의 거듭 제곱으로 올림합니다. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 을 통해 들어오는 모든 메모리 할당 요청은 먼저 xRoundup을 호출합니다. xRoundup이 0을 반환하면 해당 메모리 할당이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="5558ee9f292501795b089dc2d3175bf349258bae" translate="yes" xml:space="preserve">
          <source>The xRoundup method returns what would be the allocated size of a memory allocation given a particular requested size. Most memory allocators round up memory allocations at least to the next multiple of 8. Some allocators round up to a larger multiple or to a power of 2. Every memory allocation request coming in through &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; or &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; first calls xRoundup. If xRoundup returns 0, that causes the corresponding memory allocation to fail.</source>
          <target state="translated">xRoundup 메소드는 특정 요청 크기가 주어진 경우 할당 된 메모리 할당 크기를 반환합니다. 대부분의 메모리 할당자는 메모리 할당을 8의 다음 배수로 반올림합니다. 일부 할당자는 더 큰 배수 또는 2의 거듭 제곱으로 올림합니다. &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 또는 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 을 통해 들어오는 모든 메모리 할당 요청은 먼저 xRoundup을 호출합니다. xRoundup이 0을 반환하면 해당 메모리 할당이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ac776ca96c027496fe8cb024585d72e01e0bde03" translate="yes" xml:space="preserve">
          <source>The xRowid method is required for every virtual table implementation.</source>
          <target state="translated">xRowid 메소드는 모든 가상 테이블 구현에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f91951a49d3cd2a19053a4c5034726651d8bcc0a" translate="yes" xml:space="preserve">
          <source>The xSectorSize returns the &quot;sector size&quot; of the underlying non-volatile media. A &quot;sector&quot; is defined as the smallest unit of storage that can be written without disturbing adjacent storage. On a disk drive the &quot;sector size&quot; has until recently been 512 bytes, though there is a push to increase this value to 4KiB. SQLite needs to know the sector size so that it can write a full sector at a time, and thus avoid corrupting adjacent storage space if a power loss occurs in the middle of a write.</source>
          <target state="translated">xSectorSize는 기본 비 휘발성 매체의 &quot;섹터 크기&quot;를 반환합니다. &quot;섹터&quot;는 인접한 스토리지를 방해하지 않고 기록 할 수있는 가장 작은 스토리지 단위로 정의됩니다. 디스크 드라이브에서 &quot;섹터 크기&quot;는 최근까지 512 바이트 였지만이 값을 4KiB로 올리려는 노력이있었습니다. SQLite는 한 번에 전체 섹터를 쓸 수 있도록 섹터 크기를 알아야하므로 쓰기 도중에 전원 손실이 발생할 경우 인접한 스토리지 공간이 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7905596593f9a3650933e2dff7d4278590e16d18" translate="yes" xml:space="preserve">
          <source>The xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:</source>
          <target state="translated">xSectorSize () 메서드는 파일의 기반이되는 장치의 섹터 크기를 반환합니다. 섹터 크기는 파일의 다른 바이트를 방해하지 않고 수행 할 수있는 최소 쓰기입니다. xDeviceCharacteristics () 메서드는 기본 장치의 동작을 설명하는 비트 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c28ec934424705226c30dba3dc7fb3bbb1c98c66" translate="yes" xml:space="preserve">
          <source>The xSetSystemCall(), xGetSystemCall(), and xNestSystemCall() interfaces are not used by the SQLite core. These optional interfaces are provided by some VFSes to facilitate testing of the VFS code. By overriding system calls with functions under its control, a test program can simulate faults and error conditions that would otherwise be difficult or impossible to induce. The set of system calls that can be overridden varies from one VFS to another, and from one version of the same VFS to the next. Applications that use these interfaces must be prepared for any or all of these interfaces to be NULL or for their behavior to change from one release to the next. Applications must not attempt to access any of these methods if the iVersion of the VFS is less than 3.</source>
          <target state="translated">xSetSystemCall (), xGetSystemCall () 및 xNestSystemCall () 인터페이스는 SQLite 코어에서 사용되지 않습니다. 이러한 선택적 인터페이스는 VFS 코드 테스트를 용이하게하기 위해 일부 VFS에서 제공합니다. 테스트 프로그램은 제어하에 함수로 시스템 호출을 재정의함으로써 유도하기 어렵거나 불가능한 결함 및 오류 조건을 시뮬레이션 할 수 있습니다. 재정의 할 수있는 시스템 호출 집합은 VFS마다 다르고 동일한 VFS 버전마다 다릅니다. 이러한 인터페이스를 사용하는 응용 프로그램은 이러한 인터페이스 중 일부 또는 전부가 NULL이거나 동작이 한 릴리스에서 다음 릴리스로 변경되도록 준비해야합니다. VFS의 iVersion이 3보다 작은 경우 응용 프로그램은 이러한 방법 중 하나에 액세스하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="5423cabb179d0301d2f1838406af9e345543b685" translate="yes" xml:space="preserve">
          <source>The xShadowName method exists to allow SQLite to determine whether a certain real table is in fact a shadow table for a virtual table.</source>
          <target state="translated">xitedowName 메소드는 SQLite가 특정 실제 테이블이 실제로 가상 테이블의 새도우 테이블인지 여부를 판별 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="947c2bf35d5cbfd4ce5579dacd8c602d7123b2d2" translate="yes" xml:space="preserve">
          <source>The xShadowName method returns true when its input is the part of the table name past the last &quot;_&quot; character.</source>
          <target state="translated">xShadowName 메소드는 입력이 마지막 &quot;_&quot;문자를 지난 테이블 이름의 일부인 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bb9ed2671c0267a52c772896119a40dfbdf41d3e" translate="yes" xml:space="preserve">
          <source>The xShmLock method can transition between unlocked and SHARED or between unlocked and EXCLUSIVE. It cannot transition between SHARED and EXCLUSIVE.</source>
          <target state="translated">xShmLock 메소드는 잠금 해제와 공유 사이 또는 잠금 해제와 독점 사이에서 전환 할 수 있습니다. SHARED와 EXCLUSIVE간에 전환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b138a7b2ca75c6da01e38d919aae9bc4beaeeca" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드 는 0과이 상한 사이의 값을 &quot;오프셋&quot;인수로 사용할 수 있습니다. SQLite 코어는이 범위를 벗어난 잠금을 획득하거나 해제하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99e14d7c5dc9f436dda83c4868de4dcfa29aa8e2" translate="yes" xml:space="preserve">
          <source>The xShmLock method on &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; may use values between 0 and this upper bound as its &quot;offset&quot; argument. The SQLite core will never attempt to acquire or release a lock outside of this range</source>
          <target state="translated">&lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드 는 0과이 상한 사이의 값을 &quot;오프셋&quot;인수로 사용할 수 있습니다. SQLite 코어는이 범위를 벗어난 잠금을 획득하거나 해제하려고 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9d6171767cbe080777a834fc404f8313c3bd7a0" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown () 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 호출됩니다 . 필요한 경우 프로세스 종료 전에 미해결 리소스를 정리하는 데 사용할 수 있습니다. xShutdown () 메소드는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b517d093efdb5642222dcbac94dd78a355996a" translate="yes" xml:space="preserve">
          <source>The xShutdown() method is called by &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown()&lt;/a&gt;. It can be used to clean up any outstanding resources before process shutdown, if required. The xShutdown() method may be NULL.</source>
          <target state="translated">xShutdown () 메소드는 &lt;a href=&quot;initialize&quot; id=&quot;thexshutdownpagecachemethod&quot;&gt;sqlite3_shutdown ()에&lt;/a&gt; 의해 호출됩니다 . 필요한 경우 프로세스 종료 전에 미해결 리소스를 정리하는 데 사용할 수 있습니다. xShutdown () 메소드는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="809b6a168241db65edee19e686edd4e9bd3b2bfa" translate="yes" xml:space="preserve">
          <source>The xSleep method is used to suspend the calling thread for at least the number of microseconds given. This method is used to implement the &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; and &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; APIs. In the case of &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep()&lt;/a&gt; the xSleep method of the default VFS is always used. If the underlying system does not have a microsecond resolution sleep capability, then the sleep time should be rounded up. xSleep returns this rounded-up value.</source>
          <target state="translated">xSleep 메소드는 최소한 주어진 마이크로 초 동안 호출 스레드를 일시 중단하는 데 사용됩니다. 이 메소드는 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; API 를 구현하는 데 사용됩니다 . 의 경우 &lt;a href=&quot;c3ref/sleep&quot;&gt;sqlite3_sleep ()&lt;/a&gt; 디폴트의 xSleep 방법 VFS는 항상 사용됩니다. 기본 시스템에 마이크로 초 해상도 절전 기능이 없으면 절전 시간을 반올림해야합니다. xSleep는이 반올림 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="097b3f659c15f2c222834063189d1813c9097500" translate="yes" xml:space="preserve">
          <source>The xSync method is called again, to ensure that the update to the</source>
          <target state="translated">xSync 메소드가 다시 호출되어</target>
        </trans-unit>
        <trans-unit id="c43866c10fb70246bff455fcc260272ec7695054" translate="yes" xml:space="preserve">
          <source>The xSync method is used to force previously written data out of operating system cache and into non-volatile memory. The second parameter is usually &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt;. If the second parameter is &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; then the xSync method should make sure that data has also been flushed through the disk controllers cache. The &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; parameter is the equivalent of the F_FULLSYNC ioctl() on Mac OS X. The xSync method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xSync 방법은 이전에 기록 된 데이터를 운영 체제 캐시 및 비 휘발성 메모리에 강제로 저장하는 데 사용됩니다. 두 번째 매개 변수는 일반적으로 &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_NORMAL&lt;/a&gt; 입니다. 두 번째 매개 변수 인 경우 &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL&lt;/a&gt; 다음 xSync 방법이 있는지 데이터는 디스크 컨트롤러 캐시를 플러시되어 있는지 확인해야합니다. &lt;a href=&quot;c3ref/c_sync_dataonly&quot;&gt;SQLITE_SYNC_FULL의&lt;/a&gt; 매개 변수는 맥 OS X의 xSync 방법 반환에 F_FULLSYNC ioctl을 ()에 해당합니다 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 성공에 &lt;a href=&quot;rescode#ioerr_fsync&quot;&gt;SQLITE_IOERR_FSYNC&lt;/a&gt; 아무것도 잘못되면.</target>
        </trans-unit>
        <trans-unit id="d363e92ec2dbc091f6f79c8b02f677c3bfbb4dc4" translate="yes" xml:space="preserve">
          <source>The xSync method of the file-handle opened on the journal file is called. This operation ensures that all</source>
          <target state="translated">저널 파일에서 열린 파일 핸들의 xSync 메소드가 호출됩니다. 이 작업은 모든</target>
        </trans-unit>
        <trans-unit id="2abc7e1d2661195eacab3734a083049181c96938" translate="yes" xml:space="preserve">
          <source>The xTruncate method truncates a file to be nByte bytes in length. If the file is already nByte bytes or less in length then this method is a no-op. The xTruncate method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success and &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;SQLITE_IOERR_TRUNCATE&lt;/a&gt; if anything goes wrong.</source>
          <target state="translated">xTruncate 메소드는 파일을 길이가 nByte 바이트로 절단합니다. 파일 길이가 이미 nByte 바이트 이하인 경우이 방법은 작동하지 않습니다. xTruncate 메소드는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴 하고 &lt;a href=&quot;rescode#ioerr_truncate&quot;&gt;문제가&lt;/a&gt; 발생하면 SQLITE_IOERR_TRUNCATE 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="264cd9fc05e84b4a4186bdf81ed3b9dddd14f364" translate="yes" xml:space="preserve">
          <source>The xUpdate method is optional. If the xUpdate pointer in the &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; for a virtual table is a NULL pointer, then the virtual table is read-only.</source>
          <target state="translated">xUpdate 방법은 선택 사항입니다. 가상 테이블 에 대한 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 의 xUpdate 포인터 가 NULL 포인터 인 경우 가상 테이블은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="e7991b9300a6d5d1e9dd517f980e91bd729b810d" translate="yes" xml:space="preserve">
          <source>The xUpdate method must return &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; if and only if it is successful. If a failure occurs, the xUpdate must return an appropriate &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;. On a failure, the pVTab-&amp;gt;zErrMsg element may optionally be replaced with error message text stored in memory allocated from SQLite using functions such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;.</source>
          <target state="translated">xUpdate 메소드는 &lt;a href=&quot;rescode#ok&quot;&gt;성공한&lt;/a&gt; 경우에만 SQLITE_OK 를 리턴해야합니다 . 장애가 발생하면 xUpdate는 적절한 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 반환해야합니다 . 실패시 pVTab-&amp;gt; zErrMsg 요소는 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 과 같은 함수를 사용하여 SQLite에서 할당 된 메모리에 저장된 오류 메시지 텍스트로 선택적으로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4f4c20f5295bf2671dba3e7fbec564fd71238ee3" translate="yes" xml:space="preserve">
          <source>The xUpdate method will do a DELETE or an INSERT or both. The argv[0] element (which corresponds to memory cell P3) is the rowid of a row to delete. If argv[0] is NULL then no deletion occurs. The argv[1] element is the rowid of the new row. This can be NULL to have the virtual table select the new rowid for itself. The subsequent elements in the array are the values of columns in the new row.</source>
          <target state="translated">xUpdate 메소드는 DELETE 또는 INSERT 또는 둘 다를 수행합니다. argv [0] 요소 (메모리 셀 P3에 해당)는 삭제할 행의 rowid입니다. argv [0]이 NULL이면 삭제가 발생하지 않습니다. argv [1] 요소는 새 행의 rowid입니다. 가상 테이블이 자체적으로 새 rowid를 선택하도록하려면 NULL 일 수 있습니다. 배열의 후속 요소는 새 행의 열 값입니다.</target>
        </trans-unit>
        <trans-unit id="dce6593181b88387e0232c4fe3315ea114b78c31" translate="yes" xml:space="preserve">
          <source>The xWrite method writes iAmt bytes of data from the second parameter into the file beginning at an offset of iOfst bytes. If the size of the file is less than iOfst bytes prior to the write, then xWrite should ensure that the file is extended with zeros up to iOfst bytes prior to beginning its write. xWrite continues to extends the file as necessary so that the size of the file is at least iAmt+iOfst bytes at the conclusion of the xWrite call. The xWrite method returns &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; on success. If the write cannot complete because the underlying storage medium is full, then &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; is returned. &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; should be returned for any other error.</source>
          <target state="translated">xWrite 메소드는 iOfst 바이트 오프셋에서 시작하여 두 번째 매개 변수의 iAmt 바이트 데이터를 파일에 기록합니다. 파일 크기가 쓰기 전에 iOfst 바이트보다 작 으면 xWrite는 파일이 쓰기를 시작하기 전에 iOfst 바이트까지 0으로 확장되는지 확인해야합니다. xWrite 호출이 끝날 때 파일 크기가 iAmt + iOfst 바이트 이상이되도록 xWrite는 필요에 따라 파일을 계속 확장합니다. xWrite 메소드는 성공시 &lt;a href=&quot;rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 를 리턴합니다 . 기본 저장 매체가 가득 차서 쓰기를 완료 할 수 없으면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 이 리턴됩니다. 다른 오류에 대해서는 &lt;a href=&quot;rescode#ioerr_write&quot;&gt;SQLITE_IOERR_WRITE&lt;/a&gt; 가 리턴되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d58a45ae0f446bdb86db23efea40a4365e8b2411" translate="yes" xml:space="preserve">
          <source>The zFormat string must not be NULL.</source>
          <target state="translated">zFormat 문자열은 NULL이 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="4f80fc797d2d3e861743d9ee1212caa09c71f3bc" translate="yes" xml:space="preserve">
          <source>The zName field holds the name of the VFS module. The name must be unique across all VFS modules.</source>
          <target state="translated">zName 필드에는 VFS 모듈의 이름이 있습니다. 이름은 모든 VFS 모듈에서 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="2e8507d62c194c1ae3ea2e8955ca09d80822bd5b" translate="yes" xml:space="preserve">
          <source>The zName field is the symbolic name of the VFS. This is the name that the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; compares against when it is looking for a VFS.</source>
          <target state="translated">zName 필드는 VFS의 기호 이름입니다. 이것은 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 가 VFS를 찾을 때 비교 하는 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="159171a13f5482b6256b050c73e581c3c1ed7fde" translate="yes" xml:space="preserve">
          <source>The zeroblob(N) function returns a BLOB consisting of N bytes of 0x00. SQLite manages these zeroblobs very efficiently. Zeroblobs can be used to reserve space for a BLOB that is later written using &lt;a href=&quot;c3ref/blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt;. This SQL function is implemented using the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob()&lt;/a&gt; routine from the C/C++ interface.</source>
          <target state="translated">zeroblob (N) 함수는 N 바이트 0x00으로 구성된 BLOB를 반환합니다. SQLite는 이러한 제로 블롭을 매우 효율적으로 관리합니다. Zeroblobs는 &lt;a href=&quot;c3ref/blob_open&quot;&gt;BLOB I / O를&lt;/a&gt; 사용하여 나중에 작성된 BLOB의 공간을 예약하는 데 사용할 수 있습니다 . 이 SQL 함수는 C / C ++ 인터페이스에서 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob ()&lt;/a&gt; 루틴을 사용하여 구현 됩니다.</target>
        </trans-unit>
        <trans-unit id="211680c2a7f3cd39edd65730ba2dc5798231d4d2" translate="yes" xml:space="preserve">
          <source>The zipfile module provides read/write access to simple &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archives&lt;/a&gt;. The current implementation has the following restrictions:</source>
          <target state="translated">zipfile 모듈은 간단한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP 아카이브에&lt;/a&gt; 대한 읽기 / 쓰기 액세스를 제공합니다 . 현재 구현에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b7b70776cb9a79f5d42a047fb481e44592ef0cc" translate="yes" xml:space="preserve">
          <source>The zipfile module provides three similar interfaces for accessing, updating and creating zip file archives:</source>
          <target state="translated">zipfile 모듈은 zip 파일 아카이브에 액세스, 업데이트 및 작성하기위한 세 가지 유사한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3bf102cd7b1098b918321543923b0fbcf9afd25" translate="yes" xml:space="preserve">
          <source>The zipfile module provides two similar interfaces for accessing zip archives. A table-valued function, which provides read-only access to existing archives, and a virtual table interface, which provides both read and write access.</source>
          <target state="translated">zipfile 모듈은 zip 아카이브에 액세스하기위한 두 개의 유사한 인터페이스를 제공합니다. 기존 아카이브에 대한 읽기 전용 액세스를 제공하는 테이블 반환 함수와 읽기 및 쓰기 액세스를 모두 제공하는 가상 테이블 인터페이스</target>
        </trans-unit>
        <trans-unit id="7f26831f509249abeae6c04bd252c7253425a19e" translate="yes" xml:space="preserve">
          <source>The zipfile() aggregate function may be called with 2, 4 or 5 arguments. If it is called with 5 arguments, then the entry added to the archive is equivalent to inserting the same values into the &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot; and &quot;method&quot; columns of a zipfile virtual table.</source>
          <target state="translated">zipfile () 집계 함수는 2, 4 또는 5 개의 인수와 함께 호출 될 수 있습니다. 5 개의 인수로 호출 된 경우 아카이브에 추가 된 항목은 zipfile 가상 테이블의 &quot;name&quot;, &quot;mode&quot;, &quot;mtime&quot;, &quot;data&quot;및 &quot;method&quot;열에 동일한 값을 삽입하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fda3c54068d6592ac94595a28e9ae2b5a7631d94" translate="yes" xml:space="preserve">
          <source>Then any query that uses operators =, &amp;lt;, &amp;gt;, &amp;lt;=, &amp;gt;=, &amp;lt;&amp;gt;, IN, LIKE, or GLOB on column &quot;c&quot; would be usable with the partial index because those comparison operators are only true if &quot;c&quot; is not NULL. So the following query could use the partial index:</source>
          <target state="translated">그러면 열 &quot;c&quot;에서 연산자 =, &amp;lt;,&amp;gt;, &amp;lt;=,&amp;gt; =, &amp;lt;&amp;gt;, IN, LIKE 또는 GLOB를 사용하는 쿼리는 &quot;c&quot;인 경우에만 비교 연산자가 참이므로 부분 인덱스와 함께 사용할 수 있습니다. NULL이 아닙니다. 따라서 다음 쿼리는 부분 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d38e46789e87cb85236cff516beec8a98a69642c" translate="yes" xml:space="preserve">
          <source>Then continue to merge the changes in &quot;trunk&quot; with your &quot;private&quot; changes as described in section 3.7.</source>
          <target state="translated">그런 다음 3.7 절에 설명 된대로 &quot;트렁크&quot;의 변경 사항을 &quot;개인&quot;변경 사항과 계속 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="4221ef1a5952683847cd93186bb995482d485923" translate="yes" xml:space="preserve">
          <source>Then creating &lt;a href=&quot;lang_createview&quot;&gt;VIEWs&lt;/a&gt; in that schema that implement the official information schema tables using table-valued PRAGMA functions.</source>
          <target state="translated">그런 다음 테이블 값 PRAGMA 함수를 사용하여 공식 정보 스키마 테이블을 구현하는 해당 스키마에서 &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; 를 작성 하십시오.</target>
        </trans-unit>
        <trans-unit id="24143dcd35d1fb5f0ef327aba489cfb57e18e5f5" translate="yes" xml:space="preserve">
          <source>Then download the new version of the SQLite sources and overwrite the files that are in the checkout.</source>
          <target state="translated">그런 다음 새 버전의 SQLite 소스를 다운로드하고 체크 아웃에있는 파일을 겹쳐 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="350d0a66ff74448747b37fd69238737bb7294306" translate="yes" xml:space="preserve">
          <source>Then either of the two queries below may be executed to find the number of documents in the database that contain the word &quot;linux&quot; (351). Using one desktop PC hardware configuration, the query on the FTS3 table returns in approximately 0.03 seconds, versus 22.5 for querying the ordinary table.</source>
          <target state="translated">그런 다음 아래의 두 쿼리 중 하나를 실행하여 &quot;linux&quot;(351)라는 단어가 포함 된 데이터베이스의 문서 수를 찾을 수 있습니다. 하나의 데스크톱 PC 하드웨어 구성을 사용하면 FTS3 테이블의 쿼리는 일반 테이블 쿼리의 경우 22.5에 비해 약 0.03 초 후에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dec93deaca5432fc2b3655d16d3eb7b184d40788" translate="yes" xml:space="preserve">
          <source>Then for each &quot;id&quot; value returned, suppose the application creates an UPDATE statement like the following and binds the &quot;id&quot; value returned against the &quot;?1&quot; parameter:</source>
          <target state="translated">그런 다음 반환 된 각 &quot;id&quot;값에 대해 응용 프로그램이 다음과 같은 UPDATE 문을 만들고 &quot;? 1&quot;매개 변수에 대해 반환 된 &quot;id&quot;값을 바인딩한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b72f2d807bd1572c917e30647dff75353e7ffc89" translate="yes" xml:space="preserve">
          <source>Then let the application maintain a separate pool of larger lookaside memory buffers that it can distribute to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; as they are created. In the common case, the application will only have a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; and so the lookaside memory pool can consist of a single large buffer.</source>
          <target state="translated">그런 다음 응용 프로그램 이 작성 될 때 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 분배 할 수있는 더 큰 lookaside 메모리 버퍼 풀을 유지 보수하십시오 . 일반적인 경우 응용 프로그램은 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 만 가지 므로 lookaside 메모리 풀은 하나의 큰 버퍼로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13bc76c23a2d1597cb4fa248a96e4ed2a6339b15" translate="yes" xml:space="preserve">
          <source>Then one of the constraints would be on the &quot;a&quot; column with operator &quot;=&quot; and an expression of &quot;5&quot;. Constraints need not have a literal representation of the WHERE clause. The query optimizer might make transformations to the WHERE clause in order to extract as many constraints as it can. So, for example, if the WHERE clause contained something like this:</source>
          <target state="translated">그런 다음 제약 조건 중 하나는 연산자 &quot;=&quot;및 표현식 &quot;5&quot;가있는 &quot;a&quot;열에 있습니다. 제약 조건에는 WHERE 절을 문자 그대로 나타낼 필요가 없습니다. 쿼리 최적화 프로그램은 가능한 한 많은 제약 조건을 추출하기 위해 WHERE 절을 변환 할 수 있습니다. 예를 들어 WHERE 절에 다음과 같은 내용이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="a6d85a4cee37097aa0048aa17c7e903390d7845d" translate="yes" xml:space="preserve">
          <source>Then run &quot;sh speed-check.sh trunk&quot;.</source>
          <target state="translated">그런 다음 &quot;sh speed-check.sh trunk&quot;를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="5af7ca0994a03bba6845a3d09f85ba03527c6bbf" translate="yes" xml:space="preserve">
          <source>Then that term is rewritten as follows:</source>
          <target state="translated">그런 다음 해당 용어는 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="89cb6c0dfe329a7ee49493775fd34d7651a1097e" translate="yes" xml:space="preserve">
          <source>Then the LIKE operator pays attention to case and the example above would evaluate to false. Note that case insensitivity only applies to latin1 characters - basically the upper and lower case letters of English in the lower 127 byte codes of ASCII. International character sets are case sensitive in SQLite unless an application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#like&quot;&gt;like() SQL function&lt;/a&gt; are provided that take non-ASCII characters into account. But if an application-defined collating sequence and/or like() SQL function are provided, the LIKE optimization described here will never be taken.</source>
          <target state="translated">그런 다음 LIKE 연산자는 사례에주의를 기울이고 위의 예는 false로 평가됩니다. 대소 문자 구분은 라틴어 1 문자에만 적용됩니다 (기본적으로 ASCII의 127 바이트 코드에서 영어의 대문자와 소문자). 비 ASCII 문자를 고려 하는 응용 프로그램 정의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#like&quot;&gt;like () SQL 함수&lt;/a&gt; 가 제공 되지 않으면 다국어 문자 세트는 SQLite에서 대소 문자를 구분합니다. 그러나 응용 프로그램 정의 조합 순서 및 / 또는 like () SQL 함수가 제공되면 여기에 설명 된 LIKE 최적화는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be60a7454a5a8c066c86b3ca9b68995e4f6f1ddf" translate="yes" xml:space="preserve">
          <source>Then the RBU database should contain:</source>
          <target state="translated">그런 다음 RBU 데이터베이스에는 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="afb35789040d9830a99208d5f4ddcf476245eb59" translate="yes" xml:space="preserve">
          <source>Then the UPDATE might fail with an SQLITE_LOCKED error. The reason is that the initial query has not run to completion. It is remembering its place in the middle of a scan of the R-Tree. So an update to the R-Tree cannot be tolerated as this would disrupt the scan.</source>
          <target state="translated">그런 다음 SQLITE_LOCKED 오류와 함께 UPDATE가 실패 할 수 있습니다. 그 이유는 초기 쿼리가 완료되지 않았기 때문입니다. R-Tree 스캔 중간에 위치를 기억하고 있습니다. 따라서 R-Tree에 대한 업데이트는 스캔을 방해 할 수 있으므로 허용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="996a8ef99f82edf5bb93411418cadd30d4e95347" translate="yes" xml:space="preserve">
          <source>Then the generated SQL will look like the following:</source>
          <target state="translated">그런 다음 생성 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e329a491713b53943766e19e0cd3bc2370d4353" translate="yes" xml:space="preserve">
          <source>Then the index is usable by the query because the &quot;b=6&quot; term appears in both the index definition and in the query. Remember: terms in the index should be OR-connected and terms in the query should be AND-connected.</source>
          <target state="translated">그러면 &quot;b = 6&quot;용어가 인덱스 정의와 쿼리 모두에 나타나므로 쿼리에서 인덱스를 사용할 수 있습니다. 색인의 용어는 OR로 연결되어야하고 쿼리의 용어는 AND로 연결되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2efe4248a37f7b9e147bfa69326ac21ae4833059" translate="yes" xml:space="preserve">
          <source>Then the index might be used if the initial columns of the index (columns a, b, and so forth) appear in WHERE clause terms. The initial columns of the index must be used with the *=* or *IN* or *IS* operators. The right-most column that is used can employ inequalities. For the right-most column of an index that is used, there can be up to two inequalities that must sandwich the allowed values of the column between two extremes.</source>
          <target state="translated">그런 다음 인덱스의 초기 열 (열 a, b 등)이 WHERE 절 용어에 나타나는 경우 인덱스를 사용할 수 있습니다. 색인의 초기 컬럼은 * = * 또는 * IN * 또는 * IS * 연산자와 함께 사용해야합니다. 사용되는 가장 오른쪽 열은 불평등을 사용할 수 있습니다. 사용되는 인덱스의 가장 오른쪽 열에 대해 허용 된 열 값을 두 극단 사이에 두어야하는 최대 2 개의 부등식이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f563dfd5bcb7f2cd99d04f3adadee6fc2e0e90d8" translate="yes" xml:space="preserve">
          <source>Then the index will &lt;u&gt;not&lt;/u&gt; be used because the expression on the CREATE INDEX statement (x+y) is not the same as the expression as it appears in the query (y+x). The two expressions might be mathematically equivalent, but the SQLite query planner insists that they be the same, not merely equivalent. Consider rewriting the query thusly:</source>
          <target state="translated">그런 다음 인덱스는 것이다 &lt;u&gt;되지&lt;/u&gt; 는 쿼리 (Y + X)에 나타나는 인덱스를 CREATE 문 (X + Y)에 대한 표현은 표현과 동일하지 않기 때문에 사용할 수. 두 표현식은 수학적으로 동일하지만 SQLite 쿼리 플래너는 단순히 동등한 것이 아니라 동일하다고 주장합니다. 쿼리를 다음과 같이 다시 작성해보십시오.</target>
        </trans-unit>
        <trans-unit id="faa0b455785c0547f03cc054aee1b96482863f25" translate="yes" xml:space="preserve">
          <source>Then the locking mode applies only to the named database. If no database name qualifier precedes the &quot;locking_mode&quot; keyword then the locking mode is applied to all databases, including any new databases added by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; commands.</source>
          <target state="translated">그런 다음 잠금 모드는 명명 된 데이터베이스에만 적용됩니다. &quot;locking_mode&quot;키워드 앞에 데이터베이스 이름 규정자가 없으면 후속 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령으로 추가 된 새 데이터베이스를 포함하여 모든 데이터베이스에 잠금 모드가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ace62cf521cfc04b47d7dad558287516162d423" translate="yes" xml:space="preserve">
          <source>Then the virtual table would be created with two hidden columns, and with datatypes of &quot;VARCHAR(12)&quot; and &quot;INTEGER&quot;.</source>
          <target state="translated">그런 다음 두 개의 숨겨진 열과 &quot;VARCHAR (12)&quot;및 &quot;INTEGER&quot;데이터 유형으로 가상 테이블이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="b398879a2efe1c2e2e8691470971432fd8ac7954" translate="yes" xml:space="preserve">
          <source>Then to read the first page of that database file, one merely runs:</source>
          <target state="translated">그런 다음 해당 데이터베이스 파일의 첫 페이지를 읽으려면 다음 중 하나만 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9a0f2cc8cc7905afb88e588449e50b02e607b774" translate="yes" xml:space="preserve">
          <source>Then two &quot;virtual&quot; terms are added as follows:</source>
          <target state="translated">그런 다음 두 개의 &quot;가상&quot;용어가 다음과 같이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ca7fe30da623ecbcc16dc68b6763c7b9a4af11d0" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX ()&lt;/a&gt; 함수를 사용하여 큰 문자열 값을 SQL 문에 바인딩합니다. 바인딩을 사용하면 문자열에서 따옴표 문자를 이스케이프 할 필요가 없어 SQL 주입 공격의 위험이 줄어 듭니다. 또한 큰 문자열을 많이 구문 분석하거나 복사 할 필요가 없기 때문에 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="1d3ddffeb2cfef8ef81678864135303a52c1015f" translate="yes" xml:space="preserve">
          <source>Then use the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX()&lt;/a&gt; functions to bind your large string values to the SQL statement. The use of binding obviates the need to escape quote characters in the string, reducing the risk of SQL injection attacks. It is also runs faster since the large string does not need to be parsed or copied as much.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_XXXX ()&lt;/a&gt; 함수를 사용하여 큰 문자열 값을 SQL 문에 바인드하십시오. 바인딩을 사용하면 문자열에서 따옴표 문자를 이스케이프 할 필요가 없으므로 SQL 삽입 공격의 위험이 줄어 듭니다. 큰 문자열을 구문 분석하거나 복사 할 필요가 없으므로 더 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="265606c9637ac4024a4237e1919b8d5a2a194605" translate="yes" xml:space="preserve">
          <source>Then, love your neighbor as yourself.</source>
          <target state="translated">그런 다음 이웃을 자신처럼 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="3cfbc622cd136a62d323c5b8bab5c8bc5876d69e" translate="yes" xml:space="preserve">
          <source>There are &lt;a href=&quot;vtablist&quot;&gt;many other virtual table implementations&lt;/a&gt; in the SQLite source tree that can be used as examples. Locate these other virtual table implementations by searching for &quot;sqlite3_create_module&quot;.</source>
          <target state="translated">있습니다 &lt;a href=&quot;vtablist&quot;&gt;많은 다른 가상 테이블 구현&lt;/a&gt; 예제로 사용할 수 있습니다 SQLite는 소스 트리에가. &quot;sqlite3_create_module&quot;을 검색하여 이러한 다른 가상 테이블 구현을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="cf0cc9442c93b87173641af3ce48fe6ba6a56819" translate="yes" xml:space="preserve">
          <source>There are U or more such b-trees on a single level (see the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for an explanation of b-tree levels), where U is the value assigned to the &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge option&lt;/a&gt; option.</source>
          <target state="translated">단일 레벨에 U 개 이상의 이러한 b- 트리가 있습니다 ( b- 트리 레벨에 대한 설명은 &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 자동 병합 옵션&lt;/a&gt; 문서 참조 ). 여기서 U는 &lt;a href=&quot;fts5#the_usermerge_configuration_option&quot;&gt;FTS5 usermerge 옵션&lt;/a&gt; 옵션에 지정된 값 입니다.</target>
        </trans-unit>
        <trans-unit id="fd10b08d9cff8fbc86ae03afd572ce0a4529a480" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;&lt;a href=&quot;zeroconf&quot;&gt;zero-configuration&lt;/a&gt;&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">서버리스가되는 장점과 단점이 있습니다. 주요 이점은 설치, 설정, 구성, 초기화, 관리 및 문제 해결을위한 별도의 서버 프로세스가 없다는 것입니다. 이것이 SQLite가 &quot; &lt;a href=&quot;zeroconf&quot;&gt;제로 구성&lt;/a&gt; &quot;데이터베이스 엔진 인 이유 중 하나 입니다. SQLite를 사용하는 프로그램은 실행하기 전에 데이터베이스 엔진을 설정하기위한 관리 지원이 필요하지 않습니다. 디스크에 액세스 할 수있는 모든 프로그램은 SQLite 데이터베이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e47d4a7ae3779b3ce3872907368c2ebe6ca93d1" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to being serverless. The main advantage is that there is no separate server process to install, setup, configure, initialize, manage, and troubleshoot. This is one reason why SQLite is a &quot;zero-configuration&quot; database engine. Programs that use SQLite require no administrative support for setting up the database engine before they are run. Any program that is able to access the disk is able to use an SQLite database.</source>
          <target state="translated">서버리스가되는 장점과 단점이 있습니다. 주요 이점은 설치, 설정, 구성, 초기화, 관리 및 문제 해결을위한 별도의 서버 프로세스가 없다는 것입니다. 이것이 SQLite가 &quot;제로 구성&quot;데이터베이스 엔진 인 이유 중 하나입니다. SQLite를 사용하는 프로그램은 실행하기 전에 데이터베이스 엔진을 설정하기위한 관리 지원이 필요하지 않습니다. 디스크에 액세스 할 수있는 모든 프로그램은 SQLite 데이터베이스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a00099ff32dd16c72c3ea081a513584d8f3c38e0" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using WAL instead of a rollback journal. Advantages include:</source>
          <target state="translated">롤백 저널 대신 WAL을 사용하면 장단점이 있습니다. 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3093b427039bbfacae2cf7cc0c20cdff14795a5c" translate="yes" xml:space="preserve">
          <source>There are advantages and disadvantages to using memory-mapped I/O. Advantages include:</source>
          <target state="translated">메모리 매핑 된 I / O를 사용하면 장단점이 있습니다. 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79bd071128837bce919057f74da96b8e84ac063f" translate="yes" xml:space="preserve">
          <source>There are certain reasonable restrictions on expressions that appear in CREATE INDEX statements:</source>
          <target state="translated">CREATE INDEX 문에 나타나는 표현식에 대한 합리적인 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0440cacf20ea4b02e6a0db0e8999f07d0748bd04" translate="yes" xml:space="preserve">
          <source>There are compile-time options that will set upper bounds on the sizes of various structures in SQLite. The compile-time options normally set a hard upper bound that can be changed at run-time on individual &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface.</source>
          <target state="translated">SQLite의 다양한 구조의 크기에 상한을 설정하는 컴파일 타임 옵션이 있습니다. 컴파일 타임 옵션은 일반적으로 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 인터페이스를 사용하여 개별 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 런타임시 변경할 수있는 하드 상한을 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5db06d3cdfac9a23d2859adb4baf70db2e25be47" translate="yes" xml:space="preserve">
          <source>There are currently 170 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">가상 머신에 의해 현재 170 개의 opcode가 정의되어 있습니다. 현재 정의 된 모든 opcode가 아래 표에 설명되어 있습니다. 이 테이블은 &lt;a href=&quot;http://www.sqlite.org/src/artifact/da4030a71acf42be18001b9b7067d6d34ffb76610603ce6fafa52854b9e52936&quot;&gt;vdbe.c&lt;/a&gt; 파일에서 소스 코드를 스캔하여 자동으로 생성 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3d151e494351273cc5176bb466ee794220518dba" translate="yes" xml:space="preserve">
          <source>There are currently 175 opcodes defined by the virtual machine. All currently defined opcodes are described in the table below. This table was generated automatically by scanning the source code from the file &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt;.</source>
          <target state="translated">현재 가상 머신에 정의 된 175 개의 opcode가 있습니다. 현재 정의 된 모든 opcode는 아래 표에 설명되어 있습니다. 이 테이블은 &lt;a href=&quot;http://www.sqlite.org/src/artifact/e9f7f818f128c8600058c0eabb6b3975974c95153a104d340f419adabbc15b9f&quot;&gt;vdbe.c&lt;/a&gt; 파일에서 소스 코드를 스캔하여 자동으로 생성 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2f94a164918f438c0d1173d53f7a4f94c08b35d7" translate="yes" xml:space="preserve">
          <source>There are currently the following configuration options:</source>
          <target state="translated">현재 다음 구성 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c95acf82c00de5d5751bda48036e2a0038274e3" translate="yes" xml:space="preserve">
          <source>There are details to fill in here. Perhaps a screen can be provided that displays a history changes (perhaps with a graph) allowing the user to select which version they want to view or edit. Perhaps some facility can be provided to merge forks that might occur in the version history. And perhaps the application should provide a means to purge old and unwanted versions. The key point is that using an SQLite database to store the content, rather than a ZIP archive, makes all of these features much, much easier to implement, which increases the possibility that they will eventually get implemented.</source>
          <target state="translated">여기에 기입해야 할 세부 사항이 있습니다. 아마도 사용자가 보거나 편집 할 버전을 선택할 수 있도록 내역 변경 (그래프와 함께)을 표시하는 화면이 제공 될 수 있습니다. 버전 기록에서 발생할 수있는 포크를 병합하기 위해 일부 기능을 제공 할 수 있습니다. 그리고 아마도 응용 프로그램은 이전 버전과 원하지 않는 버전을 제거하는 수단을 제공해야합니다. 중요한 점은 ZIP 아카이브가 아닌 SQLite 데이터베이스를 사용하여 컨텐츠를 저장하면 이러한 모든 기능을 훨씬 쉽게 구현할 수있게되어 결국 구현 될 가능성이 높아진다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="98cb1601f44f3fee5a33f8d40abfeb82b5e7251a" translate="yes" xml:space="preserve">
          <source>There are five separate read locks, numbers 0 through 4. Read locks may be either SHARED or EXCLUSIVE. Connections obtain a shared lock on one of the read locks bytes while they are within a transaction. Connections also obtain an exclusive lock on read locks, one at a time, for the brief moment while they are updating the values of the corresponding read-marks. Read locks 1 through 4 are held exclusively when running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">0에서 4까지의 5 개의 개별 읽기 잠금이 있습니다. 읽기 잠금은 SHARED 또는 EXCLUSIVE 일 수 있습니다. 연결은 트랜잭션 내에있는 동안 읽기 잠금 바이트 중 하나에서 공유 잠금을 얻습니다. 또한 연결은 해당 읽기 표시의 값을 업데이트하는 동안 잠시 동안 읽기 잠금에 대해 독점 잠금을 얻습니다. 읽기 잠금 1-4는 &lt;a href=&quot;walformat#recovery&quot;&gt;복구를&lt;/a&gt; 실행할 때 독점적으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="c457ee41ba8d1b7387ba8e7edc9a0ac19be4f375" translate="yes" xml:space="preserve">
          <source>There are five ways to describe starting and ending frame boundaries:</source>
          <target state="translated">시작 및 끝 프레임 경계를 설명하는 5 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2ce0d23c5814413e2c1fb5364c7eef30a6e31f7" translate="yes" xml:space="preserve">
          <source>There are four independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">핵심 SQLite 라이브러리를 테스트하는 데 사용되는 4 개의 독립적 인 테스트 도구가 있습니다. 각 테스트 장치는 다른 장치와 별도로 설계, 유지 관리 및 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="4083c54b42aa73500fa86d4b0409e55690866a09" translate="yes" xml:space="preserve">
          <source>There are many advantages to using SQLite as an application file format, including:</source>
          <target state="translated">SQLite를 응용 프로그램 파일 형식으로 사용하면 다음과 같은 많은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e1c62962db715e611550a655ba502415a8c24f6" translate="yes" xml:space="preserve">
          <source>There are many benefits to this approach, including improved performance, reduced cost and complexity, and improved reliability. See technical notes &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; and &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; for more information. This use case is closely related to the &lt;a href=&quot;#wireproto&quot;&gt;data transfer format&lt;/a&gt; and &lt;a href=&quot;#container&quot;&gt;data container&lt;/a&gt; use cases below.</source>
          <target state="translated">이 방법에는 성능 향상, 비용 및 복잡성 감소, 안정성 향상 등 많은 이점이 있습니다. 기술 노트를 참조하십시오 &lt;a href=&quot;aff_short&quot;&gt;&quot;aff_short.html&quot;&lt;/a&gt; 및 &lt;a href=&quot;appfileformat&quot;&gt;&quot;appfileformat.html&quot;&lt;/a&gt; 및 &lt;a href=&quot;fasterthanfs&quot;&gt;&quot;fasterthanfs.html&quot;&lt;/a&gt; 자세한 내용을. 이 사용 사례는 아래 의 &lt;a href=&quot;#wireproto&quot;&gt;데이터 전송 형식&lt;/a&gt; 및 &lt;a href=&quot;#container&quot;&gt;데이터 컨테이너&lt;/a&gt; 사용 사례 와 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dd1c1ec54122d1cd8a41e77d633d60c4de1054" translate="yes" xml:space="preserve">
          <source>There are many different extended result codes for I/O errors that identify the specific I/O operation that failed.</source>
          <target state="translated">실패한 특정 I / O 조작을 식별하는 I / O 오류에 대한 여러 가지 확장 된 결과 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f265782324871b5641aee92d51fefe1edfb475af" translate="yes" xml:space="preserve">
          <source>There are many fraudulent USB sticks in circulation that report to have a high capacity (ex: 8GB) but are really only capable of storing a much smaller amount (ex: 1GB). Attempts to write on these devices will often result in unrelated files being overwritten. Any use of a fraudulent flash memory device can easily lead to database corruption, therefore. Internet searches such as &quot;fake capacity usb&quot; will turn up lots of disturbing information about this problem.</source>
          <target state="translated">고용량 (예 : 8GB)을 가지고 있지만 실제로는 훨씬 적은 양 (예 : 1GB) 만 저장할 수있는 사기성 USB 스틱이 많이 유통되고 있습니다. 이러한 장치에 쓰려고하면 관련없는 파일을 덮어 쓰는 경우가 종종 있습니다. 따라서 사기성 플래시 메모리 장치를 사용하면 데이터베이스가 쉽게 손상 될 수 있습니다. &quot;가짜 용량 USB&quot;와 같은 인터넷 검색은이 문제에 대한 많은 방해 정보를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a53dc58a565490cefd808a058bfaad47e191a084" translate="yes" xml:space="preserve">
          <source>There are many more features not listed above. SQLite may be small in size and have &quot;Lite&quot; in its name, but it is not lacking in capability.</source>
          <target state="translated">위에 나열되지 않은 더 많은 기능이 있습니다. SQLite는 크기가 작고 이름에 &quot;Lite&quot;가있을 수 있지만 기능이 부족하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="60f662540321a06d796e68831dc73409bf49f397" translate="yes" xml:space="preserve">
          <source>There are many other dot-commands available in the command-line shell. See the &quot;.help&quot; command for a complete list for any particular version and build of SQLite.</source>
          <target state="translated">명령 줄 셸에서 사용할 수있는 다른 많은 도트 명령이 있습니다. SQLite의 특정 버전 및 빌드에 대한 전체 목록은 &quot;.help&quot;명령을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="53f739b37a172fddf027f7c8afb4029bf933f8fe" translate="yes" xml:space="preserve">
          <source>There are many other testing options, which can be seen by running the command:</source>
          <target state="translated">명령을 실행하여 볼 수있는 다른 많은 테스트 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="461c7676d827031f4cd64d05f3d67e68ce256daf" translate="yes" xml:space="preserve">
          <source>There are many ways to measure test coverage. The most popular metric is &quot;statement coverage&quot;. When you hear someone say that their program as &quot;XX% test coverage&quot; without further explanation, they usually mean statement coverage. Statement coverage measures what percentage of lines of code are executed at least once by the test suite.</source>
          <target state="translated">테스트 범위를 측정하는 방법에는 여러 가지가 있습니다. 가장 많이 사용되는 메트릭은 &quot;statement coverage&quot;입니다. 더 이상의 설명없이 자신의 프로그램이 &quot;XX % 테스트 적용 범위&quot;라고 말하는 것을들을 때 일반적으로 진술 범위를 의미합니다. 명령문 적용 범위는 테스트 제품군에서 최소 한 번 실행 된 코드 줄 백분율을 측정합니다.</target>
        </trans-unit>
        <trans-unit id="15784824361af8c293ec21cb8076051131fb442d" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits in TH3. One could generate a single test program that contained all test modules and all configuration files. However, such a test program might be too large to deploy on embedded platforms. (As of 2018-05-19, a full-up TH3 test is over 850,000 lines and 58MB of C code.) TH3 provides the ability to break the library of test modules up into smaller, more easily digested pieces.</source>
          <target state="translated">TH3에는 임의의 제한이 없습니다. 모든 테스트 모듈과 모든 구성 파일을 포함하는 단일 테스트 프로그램을 생성 할 수 있습니다. 그러나 이러한 테스트 프로그램은 너무 커서 임베디드 플랫폼에 배포 할 수 없습니다. (2018 년 5 월 19 일 현재 전체 TH3 테스트는 80 만 라인 이상, C 코드는 58MB 이상입니다.) TH3은 테스트 모듈 라이브러리를 더 작고 더 쉽게 소화 할 수있는 조각으로 나눌 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="67165e227e06a66e9e2a7c9a359bffd814ca48a8" translate="yes" xml:space="preserve">
          <source>There are no arbitrary limits on the number of indices that can be attached to a single table. The number of columns in an index is limited to the value set by &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt;,...).</source>
          <target state="translated">단일 테이블에 첨부 할 수있는 인덱스 수에는 임의의 제한이 없습니다. 인덱스의 열 수는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitcolumn&quot;&gt;SQLITE_LIMIT_COLUMN&lt;/a&gt; , ...)에 의해 설정된 값으로 제한됩니다 .</target>
        </trans-unit>
        <trans-unit id="75e5745eabbe1f0d9742be6d3047103706a06632" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 다중 스레드로 설정합니다 . 즉, &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트 에서 mutexing을 사용하지 않습니다 . 응용 프로그램은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화해야 합니다 . 그러나 두 개의 스레드가 동일한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에 사용하려고 시도하지 않는 한 다중 스레드 환경에서 SQLite를 안전하게 사용할 수 있도록 다른 뮤텍스가 활성화 됩니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 다중 스레드 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 및 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 설정할 수 없습니다반환 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="438fea25e22862b67e0b2e195af310125649fa4d" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 직렬화로 설정합니다 . 즉,이 옵션은 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 재귀 뮤텍스 와 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 객체를 포함하여 모든 뮤텍스를 활성화 합니다. 이 모드 (SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1로&lt;/a&gt; 컴파일 될 때 기본값 임 )에서 SQLite 라이브러리는 자체적으로 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화 하여 애플리케이션이 다른 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 에서 동일한 데이터베이스 연결 또는 동일한 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 자유롭게 사용할 수 있도록합니다. 동시에. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0으로&lt;/a&gt; 컴파일 된 경우다음은 직렬화 설정할 수 없습니다 옵션을 컴파일시 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 와 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 반환합니다 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_SERIALIZED 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4b86fd3dbc8c8ae83073b70ec3ca59694912ef28" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 단일 스레드로 설정합니다 . 즉, 모든 뮤텍스를 비활성화하고 SQLite를 단일 스레드에서만 사용할 수있는 모드로 만듭니다. SQLite가 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 기본값 인 단일 스레드 에서 변경할 수 없으므로 SQLITE_CONFIG_SINGLETHREAD 구성 옵션으로 호출하면 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 는 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="e6b294707b24261f0f532c64902934c051eedbd1" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Multi-thread. In other words, it disables mutexing on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. The application is responsible for serializing access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;. But other mutexes are enabled so that SQLite will be safe to use in a multi-threaded environment as long as no two threads attempt to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Multi-thread &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_MULTITHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 다중 스레드로 설정합니다 . 즉, &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 오브젝트 에서 mutexing을 사용하지 않습니다 . 응용 프로그램은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화해야 합니다 . 그러나 두 개의 스레드가 동일한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에 사용하려고 시도하지 않는 한 다중 스레드 환경에서 SQLite를 안전하게 사용할 수 있도록 다른 뮤텍스가 활성화 됩니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 시간 옵션으로 컴파일 된 경우 다중 스레드 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 를 설정할 수 없습니다반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_MULTITHREAD 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="955a610f066915f2766fca467b944718d1ee6aea" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Serialized. In other words, this option enables all mutexes including the recursive mutexes on &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; objects. In this mode (which is the default when SQLite is compiled with &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=1&lt;/a&gt;) the SQLite library will itself serialize access to &lt;a href=&quot;#sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt; so that the application is free to use the same &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; or the same &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; in different threads at the same time. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to set the Serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; and &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SERIALIZED configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 직렬화로 설정합니다 . 즉,이 옵션은 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 의 재귀 뮤텍스 와 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 객체를 포함하여 모든 뮤텍스를 활성화 합니다. 이 모드 (SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 1로&lt;/a&gt; 컴파일 될 때 기본값 임 )에서 SQLite 라이브러리는 자체적으로 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 액세스를 직렬화 하여 애플리케이션이 다른 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 에서 동일한 데이터베이스 연결 또는 동일한 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 자유롭게 사용할 수 있도록합니다. 동시에. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0으로&lt;/a&gt; 컴파일 된 경우다음은 직렬화 설정할 수 없습니다 옵션을 컴파일시 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()를&lt;/a&gt; 반환합니다 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR을&lt;/a&gt; SQLITE_CONFIG_SERIALIZED 구성 옵션으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="1bc66a3a72545b16257e521a7b7467b7b7fb116b" translate="yes" xml:space="preserve">
          <source>There are no arguments to this option. This option sets the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; to Single-thread. In other words, it disables all mutexing and puts SQLite into a mode where it can only be used by a single thread. If SQLite is compiled with the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE=0&lt;/a&gt; compile-time option then it is not possible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; from its default value of Single-thread and so &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if called with the SQLITE_CONFIG_SINGLETHREAD configuration option.</source>
          <target state="translated">이 옵션에 대한 인수는 없습니다. 이 옵션은 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 단일 스레드로 설정합니다 . 즉, 모든 뮤텍스를 비활성화하고 SQLite를 단일 스레드에서만 사용할 수있는 모드로 만듭니다. SQLite가 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE = 0&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 된 경우 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 기본값 인 단일 스레드 에서 변경할 수 없으므로 SQLITE_CONFIG_SINGLETHREAD 구성 옵션으로 호출하면 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="33e0331165757b835edb3c42bfc1d34942851312" translate="yes" xml:space="preserve">
          <source>There are numerous test cases that verify that SQLite is able to deal with malformed database files. These tests first build a well-formed database file, then add corruption by changing one or more bytes in the file by some means other than SQLite. Then SQLite is used to read the database. In some cases, the bytes changes are in the middle of data. This causes the content of the database to change while keeping the database well-formed. In other cases, unused bytes of the file are modified, which has no effect on the integrity of the database. The interesting cases are when bytes of the file that define database structure get changed. The malformed database tests verify that SQLite finds the file format errors and reports them using the &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; return code without overflowing buffers, dereferencing NULL pointers, or performing other unwholesome actions.</source>
          <target state="translated">SQLite가 잘못된 데이터베이스 파일을 처리 할 수 ​​있는지 확인하는 수많은 테스트 사례가 있습니다. 이 테스트는 먼저 올바른 형식의 데이터베이스 파일을 작성한 다음 SQLite 이외의 다른 방법으로 파일에서 하나 이상의 바이트를 변경하여 손상을 추가합니다. 그런 다음 SQLite를 사용하여 데이터베이스를 읽습니다. 경우에 따라 바이트 변경이 데이터 중간에 있습니다. 이로 인해 데이터베이스의 형식을 유지하면서 데이터베이스의 내용이 변경됩니다. 다른 경우에는 파일의 사용되지 않는 바이트가 수정되어 데이터베이스의 무결성에 영향을 미치지 않습니다. 흥미로운 경우는 데이터베이스 구조를 정의하는 파일의 바이트가 변경되는 경우입니다. 잘못된 데이터베이스 테스트는 SQLite가 파일 형식 오류를 찾아서 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT를&lt;/a&gt; 사용하여보고하는지 확인합니다. 버퍼 오버 플로우, NULL 포인터 역 참조 또는 기타 부적절한 동작을 수행하지 않고 리턴 코드.</target>
        </trans-unit>
        <trans-unit id="f9afe2547739122b5f898fca4cf352f033d81b8f" translate="yes" xml:space="preserve">
          <source>There are only two reasonable ways to implement this query. (There are many other possible algorithms, but none of the others are contenders for being the &quot;best&quot; algorithm.)</source>
          <target state="translated">이 쿼리를 구현하는 데는 두 가지 합리적인 방법이 있습니다. (가능한 다른 알고리즘이 많이 있지만, &quot;최상의&quot;알고리즘에 대한 경쟁자는 없습니다.)</target>
        </trans-unit>
        <trans-unit id="35c4953b7b40ec225a59ad1651360c7dbd0086b0" translate="yes" xml:space="preserve">
          <source>There are other SQL database engines with liberal licenses that allow the code to be broadly and freely used. But those other engines are still governed by copyright law. SQLite is different in that copyright law simply does not apply.</source>
          <target state="translated">코드를 광범위하고 자유롭게 사용할 수있는 자유 라이센스가있는 다른 SQL 데이터베이스 엔진이 있습니다. 그러나 다른 엔진에는 여전히 저작권법이 적용됩니다. SQLite는 저작권법이 단순히 적용되지 않는다는 점에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="00840e534b3409464615b9e5469c1789e0356b07" translate="yes" xml:space="preserve">
          <source>There are other VFS implementations both in the core SQLite source code library and in available extensions. The list above is not meant to be exhaustive but merely representative of the kinds of features that can be realized using the VFS interface.</source>
          <target state="translated">핵심 SQLite 소스 코드 라이브러리와 사용 가능한 확장 모두에 다른 VFS 구현이 있습니다. 위의 목록은 완전한 것이 아니라 VFS 인터페이스를 사용하여 실현할 수있는 기능의 종류를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="fe657852dc4212647e79b2906ecbf326edcfcb96" translate="yes" xml:space="preserve">
          <source>There are several other ways to add an equivalent foreign key declaration to a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement. Refer to the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE documentation&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문에 동등한 외래 키 선언을 추가하는 몇 가지 다른 방법이 있습니다 . 자세한 내용은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="14687afe7afa4066d985b4f03845594063586e18" translate="yes" xml:space="preserve">
          <source>There are several ways of thinking about the RELEASE command:</source>
          <target state="translated">RELEASE 명령에 대해 여러 가지 방법으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22c57ea3a56c1a621fcb33ba044a6de73ca1f510" translate="yes" xml:space="preserve">
          <source>There are several ways to approach this in FTS5:</source>
          <target state="translated">FTS5에는 몇 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="de40b756c06e57b21f4c7c518f428b201082172b" translate="yes" xml:space="preserve">
          <source>There are some contexts in SQLite that do not allow the use of non-deterministic functions:</source>
          <target state="translated">비 결정적 함수의 사용을 허용하지 않는 일부 컨텍스트는 SQLite에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffb257ce26a3636acdb1a9134b8ec418a490f506" translate="yes" xml:space="preserve">
          <source>There are some restrictions on the use of a VALUES clause that are not shown on the syntax diagrams:</source>
          <target state="translated">구문 다이어그램에 표시되지 않은 VALUES 절 사용에는 몇 가지 제한 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc9c795ba02424df295c5bd8e19a42a3240738c" translate="yes" xml:space="preserve">
          <source>There are three frame types: ROWS, GROUPS, and RANGE. The frame type determines how the starting and ending boundaries of the frame are measured.</source>
          <target state="translated">ROWS, GROUPS 및 RANGE의 세 가지 프레임 유형이 있습니다. 프레임 유형에 따라 프레임의 시작 및 끝 경계가 측정되는 방식이 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="b1e7d89744d05b6a27dde7db2836b2617aa1bbd6" translate="yes" xml:space="preserve">
          <source>There are three independent test harnesses used for testing the core SQLite library. Each test harness is designed, maintained, and managed separately from the others.</source>
          <target state="translated">핵심 SQLite 라이브러리를 테스트하는 데 사용되는 세 개의 독립적 인 테스트 하네스가 있습니다. 각 테스트 하니스는 다른 테스트 하니스와 별도로 설계, 유지 보수 및 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="045c3584370eb289c548f60cb3b6ecaf401b3ed3" translate="yes" xml:space="preserve">
          <source>There are three levels to the shared-cache locking model, transaction level locking, table level locking and schema level locking. They are described in the following three sub-sections.</source>
          <target state="translated">공유 캐시 잠금 모델, 트랜잭션 수준 잠금, 테이블 수준 잠금 및 스키마 수준 잠금에는 세 가지 수준이 있습니다. 다음 세 가지 하위 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="944bcf56eaccf2f8d8f73507f47a4f5f610aa075" translate="yes" xml:space="preserve">
          <source>There are three reasons to set the locking-mode to EXCLUSIVE.</source>
          <target state="translated">잠금 모드를 독점으로 설정해야하는 세 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e889a4b513747e6b54c292e814d5a011df18d8e5" translate="yes" xml:space="preserve">
          <source>There are three special-case entries in the cost table:</source>
          <target state="translated">비용 테이블에는 세 가지 특수한 경우 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e8f3752e4f9aab9d7f5e605906342c5eeca4178" translate="yes" xml:space="preserve">
          <source>There are two advantages to using the SQLite printf functions instead of &lt;b&gt;sprintf&lt;/b&gt;. First of all, with the SQLite printf routines, there is never a danger of overflowing a static buffer as there is with &lt;b&gt;sprintf&lt;/b&gt;. The SQLite printf routines automatically allocate (and later frees) as much memory as is necessary to hold the SQL statements generated.</source>
          <target state="translated">&lt;b&gt;sprintf&lt;/b&gt; 대신 SQLite printf 함수를 사용하면 두 가지 장점이 있습니다 . 우선, SQLite printf 루틴을 사용하면 &lt;b&gt;sprintf&lt;/b&gt; 와 같이 정적 버퍼가 오버플로 될 위험이 없습니다 . SQLite printf 루틴은 생성 된 SQL 문을 보유하는 데 필요한만큼의 메모리를 자동으로 할당 (및 나중에 해제)합니다.</target>
        </trans-unit>
        <trans-unit id="391950a505dd77c6d9de2b0a8bf9dd26b935ed51" translate="yes" xml:space="preserve">
          <source>There are two aggregate SQL functions:</source>
          <target state="translated">두 가지 집계 SQL 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="631b7dfac93f3d53c23db92b1bef743005732dff" translate="yes" xml:space="preserve">
          <source>There are two cases to consider: (1) Table &quot;tab1&quot; does not previously exist and (2) table &quot;tab1&quot; does already exist.</source>
          <target state="translated">고려해야 할 두 가지 경우가 있습니다. (1) 테이블 &quot;tab1&quot;이 존재하지 않고 (2) 테이블 &quot;tab1&quot;이 이미 존재합니다.</target>
        </trans-unit>
        <trans-unit id="b8b8531dc422d3e33d42cc7bdad0abd37870f1fe" translate="yes" xml:space="preserve">
          <source>There are two column (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array names azResult. Then azResult holds this content:</source>
          <target state="translated">두 개의 열 (M == 2)과 세 개의 행 (N == 3)이 있습니다. 따라서 결과 테이블에는 8 개의 항목이 있습니다. 결과 테이블이 배열 이름 azResult에 저장되어 있다고 가정하십시오. 그런 다음 azResult는 다음 내용을 보유합니다.</target>
        </trans-unit>
        <trans-unit id="e8adb25d367ffc51207827de29ffc66a0b34c609" translate="yes" xml:space="preserve">
          <source>There are two columns (M==2) and three rows (N==3). Thus the result table has 8 entries. Suppose the result table is stored in an array named azResult. Then azResult holds this content:</source>
          <target state="translated">두 개의 열 (M == 2)과 세 개의 행 (N == 3)이 있습니다. 따라서 결과 테이블에는 8 개의 항목이 있습니다. 결과 테이블이 azResult라는 배열에 저장되어 있다고 가정합니다. 그런 다음 azResult는 다음 콘텐츠를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="928a963ad2407ff0d2d21e12347ddb23d756bb64" translate="yes" xml:space="preserve">
          <source>There are two differences in this variation. The initial-select is &quot;SELECT 1&quot; instead of &quot;VALUES(1)&quot;. But those are just different syntaxes for saying exactly the same thing. The other change is that the recursion is stopped by a LIMIT rather than a WHERE clause. The use of LIMIT means that when the one-millionth row is added to the &quot;cnt&quot; table (and returned by the main SELECT, thanks to the query optimizer) then the recursion stops immediately regardless of how many rows might be left in the queue. On more complex queries, it can sometimes be difficult to ensure that the WHERE clause will eventually cause the queue to drain and the recursion to terminate. But the LIMIT clause will always stop the recursion. So it is good practice to always include a LIMIT clause as a safety if an upper bound on the size of the recursion is known.</source>
          <target state="translated">이 변형에는 두 가지 차이점이 있습니다. 초기 선택은 &quot;VALUES (1)&quot;대신 &quot;SELECT 1&quot;입니다. 그러나 이것들은 정확히 같은 것을 말하는 다른 구문입니다. 다른 변경은 재귀가 WHERE 절이 아닌 LIMIT에 의해 중지된다는 것입니다. LIMIT를 사용하면 1 백만 번째 행이 &quot;cnt&quot;테이블에 추가되고 (쿼리 최적화 프로그램으로 인해 기본 SELECT에 의해 리턴 될 때) 큐에 남아있는 행 수에 관계없이 재귀가 즉시 중지됩니다. . 보다 복잡한 쿼리에서는 WHERE 절이 결국 큐를 비우고 재귀가 종료되도록하는 것이 어려울 수 있습니다. 그러나 LIMIT 절은 항상 재귀를 중지합니다.따라서 재귀 크기의 상한을 알고있는 경우 항상 LIMIT 절을 안전으로 포함하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bb5962b52c02f4df27314354c0118e64e476f288" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">togethr 또는 개별적으로 사용할 수있는 두 가지 별도의 구성 변경 사항이 있습니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD의&lt;/a&gt; 설정은에 직렬화 액세스 것을 뮤텍스 비활성화 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 객체와 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체. 이 설정을 사용하면 응용 프로그램이 여러 스레드에서 SQLite는 무료로 사용할 수 있지만 두 개의 스레드가 같은 액세스하려고하지보다가 있는지 확인해야합니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 같은과 관련된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에합니다. 두 스레드는 동시에 SQLite를 사용할 수 있지만 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 사용해야 합니다 . 두 번째 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;설정은 모든 미해결 메모리 할당 요청의 총 크기를 추적하는 SQLite의 메커니즘을 비활성화합니다. 이렇게하면 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()에 대한&lt;/a&gt; 각 호출을 뮤텍스 할 필요가 없으므로 엄청난 수의 뮤텍스 작업이 절약됩니다. 그러나 메모리 통계 메커니즘을 비활성화하면 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10f943413bc9e88ca64edb6cc154e6b7583f6c77" translate="yes" xml:space="preserve">
          <source>There are two separate configuration changes here which can be used either togethr or separately. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; setting disables the mutexes that serialize access to &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; objects. With this setting, the application is free to use SQLite from multiple threads, but it must make sure than no two threads try to access the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; or any &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; associated with the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at the same time. Two threads can use SQLite at the same time, but they must use separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;. The second &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; setting disables the mechanism in SQLite that tracks the total size of all outstanding memory allocation requests. This omits the need to mutex each call to &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt; and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, which saves a huge number of mutex operations. But a consequence of disabling the memory statistics mechanism is that the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt;, &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt;, and &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interfaces cease to work.</source>
          <target state="translated">여기서는 getgethr 또는 별도로 사용할 수있는 두 가지 구성 변경이 있습니다. &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD의&lt;/a&gt; 설정은에 직렬화 액세스 것을 뮤텍스 비활성화 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 객체와 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체. 이 설정을 사용하면 응용 프로그램이 여러 스레드에서 SQLite는 무료로 사용할 수 있지만 두 개의 스레드가 같은 액세스하려고하지보다가 있는지 확인해야합니다 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 같은과 관련된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 동시에합니다. 두 개의 스레드가 동시에 SQLite를 사용할 수 있지만 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 사용해야 합니다 . 두 번째 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;설정은 모든 미해결 메모리 할당 요청의 총 크기를 추적하는 SQLite의 메커니즘을 비활성화합니다. 따라서 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()에 대한&lt;/a&gt; 각 호출을 mutex 할 필요가 없으므로 많은 수의 mutex 작업이 절약됩니다. 그러나 메모리 통계 메커니즘을 비활성화하면 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; , &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 인터페이스가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03b9684a8e7902c26ab2183576e54dd70242a272" translate="yes" xml:space="preserve">
          <source>There are two types of simple SELECT statement - aggregate and non-aggregate queries. A simple SELECT statement is an aggregate query if it contains either a GROUP BY clause or one or more aggregate functions in the result-set. Otherwise, if a simple SELECT contains no aggregate functions or a GROUP BY clause, it is a non-aggregate query.</source>
          <target state="translated">간단한 SELECT 문에는 집계 및 비 집계 쿼리라는 두 가지 유형이 있습니다. 간단한 SELECT 문은 결과 집합에 GROUP BY 절 또는 하나 이상의 집계 함수가 포함 된 경우 집계 쿼리입니다. 그렇지 않으면 간단한 SELECT에 집계 함수 나 GROUP BY 절이 포함되어 있지 않으면 집계되지 않은 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="265655ffc7236582ade45c905963724f97d22dc0" translate="yes" xml:space="preserve">
          <source>There are two ways to use the &quot;content&quot; option:</source>
          <target state="translated">&quot;content&quot;옵션을 사용하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c855557ba4350c988043164f7d90199d18c9af0" translate="yes" xml:space="preserve">
          <source>There are typically between 10 to 40 entries in the sqlite_stat4 table for each index for which statistics are available, however these limits are not hard bounds. The meanings of the columns in the sqlite_stat4 table are as follows:</source>
          <target state="translated">통계가 사용 가능한 각 인덱스에 대해 sqlite_stat4 테이블에 일반적으로 10-40 개의 항목이 있지만 이러한 한계는 하드 한계가 아닙니다. sqlite_stat4 테이블에서 열의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cc2860dd2126e117e20cc785f2f36fc98950f36" translate="yes" xml:space="preserve">
          <source>There are usually multiple entries in the sqlite_stat3 table for each index. The sqlite_stat3.sample column holds the value of the left-most field of an index identified by sqlite_stat3.idx and sqlite_stat3.tbl. The sqlite_stat3.nEq column holds the approximate number of entries in the index whose left-most column exactly matches the sample. The sqlite_stat3.nLt holds the approximate number of entries in the index whose left-most column is less than the sample. The sqlite_stat3.nDLt column holds the approximate number of distinct left-most entries in the index that are less than the sample.</source>
          <target state="translated">sqlite_stat3 테이블에는 일반적으로 각 색인에 대한 여러 항목이 있습니다. sqlite_stat3.sample 컬럼은 sqlite_stat3.idx 및 sqlite_stat3.tbl에 의해 식별 된 색인의 가장 왼쪽 필드 값을 보유합니다. sqlite_stat3.nEq 열은 가장 왼쪽 열이 샘플과 정확히 일치하는 색인의 대략적인 항목 수를 보유합니다. sqlite_stat3.nLt는 가장 왼쪽 열이 샘플보다 작은 인덱스의 대략적인 항목 수를 보유합니다. sqlite_stat3.nDLt 열은 샘플보다 적은 인덱스에서 가장 왼쪽에있는 고유 한 항목 수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="3bc8ca2faf5f82d403479bc810eea0e330c59fbe" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat3 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat3 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">인덱스 당 임의의 수의 sqlite_stat3 항목이있을 수 있습니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령은 일반적으로 키 공간을 가로 질러 큰 NEQ 값으로 분포되어 10 ~ 40 샘플을 포함 sqlite_stat3 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="76781503806bdc9ca573d5796b00968614643484" translate="yes" xml:space="preserve">
          <source>There can be an arbitrary number of sqlite_stat4 entries per index. The &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command will typically generate sqlite_stat4 tables that contain between 10 and 40 samples that are distributed across the key space and with large nEq values.</source>
          <target state="translated">인덱스 당 임의의 수의 sqlite_stat4 항목이있을 수 있습니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령은 일반적으로 키 공간을 가로 질러 큰 NEQ 값으로 분포되어 10 ~ 40 샘플을 포함 sqlite_stat4 테이블을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4935a4962bbd49a87bfec8ba26bcb0ee96e2bc65" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">각 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만 정의 될 수 있습니다 . 새로운 통화 중 처리기를 설정하면 이전에 설정된 처리기가 지워집니다. &lt;a href=&quot;#sqlite3_busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N을&lt;/a&gt; 평가 하면 사용중인 핸들러가 변경되어 이전에 설정된 사용중인 핸들러가 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="595614b4fea7d83eeee9eca9b82c7f15a616950a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler defined for each &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;. Setting a new busy handler clears any previously set handler. Note that calling &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; or evaluating &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout=N&lt;/a&gt; will change the busy handler and thus clear any previously set busy handler.</source>
          <target state="translated">각 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만 정의 될 수 있습니다 . 새로운 통화 중 처리기를 설정하면 이전에 설정된 처리기가 지워집니다. &lt;a href=&quot;busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 을 호출 하거나 &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout = N을&lt;/a&gt; 평가 하면 사용중인 핸들러가 변경되어 이전에 설정된 사용중인 핸들러가 지워집니다 .</target>
        </trans-unit>
        <trans-unit id="4557f81c54cd198ad30dafda03e1a7688c37ee6a" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">특정 시점에 특정 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만있을 수 있습니다 . 이 루틴을 호출하기 전에 다른 사용중인 핸들러가 정의 된 경우 ( &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;sqlite3_busy_handler () 사용&lt;/a&gt; ) 해당 다른 사용중인 핸들러가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="6c5612f166f3c19adb75f5b9420223d984d062bf" translate="yes" xml:space="preserve">
          <source>There can only be a single busy handler for a particular &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; at any given moment. If another busy handler was defined (using &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt;) prior to calling this routine, that other busy handler is cleared.</source>
          <target state="translated">특정 시점에 특정 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 대해 하나의 사용중인 핸들러 만있을 수 있습니다 . 이 루틴을 호출하기 전에 다른 사용중인 핸들러가 정의 된 경우 ( &lt;a href=&quot;busy_handler&quot;&gt;sqlite3_busy_handler () 사용&lt;/a&gt; ) 해당 다른 사용중인 핸들러가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="da947c700e89a2839d81ef99abfdba549201cf04" translate="yes" xml:space="preserve">
          <source>There can only be a single error logging callback per process. The error logging callback is registered at start-time using C-code similar to the following:</source>
          <target state="translated">프로세스 당 하나의 오류 로깅 콜백 만있을 수 있습니다. 오류 로깅 콜백은 시작시 다음과 유사한 C 코드를 사용하여 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="297da7a4ca1508d9a0851c1993606776e3a61cd5" translate="yes" xml:space="preserve">
          <source>There can only be a single trace callback registered on a database connection. Each use of &quot;trace&quot; or &quot;trace_v2&quot; cancels all prior trace callback.</source>
          <target state="translated">데이터베이스 연결에 등록 된 단일 추적 콜백 만있을 수 있습니다. &quot;trace&quot;또는 &quot;trace_v2&quot;를 사용할 때마다 모든 이전 추적 콜백이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="13fe35de43729e33636f83c267efada945c04a07" translate="yes" xml:space="preserve">
          <source>There exists some subtle problem with mmap() on QNX such that making a second mmap() call against a single file descriptor can cause the memory obtained from the first mmap() call to be zeroed. SQLite on unix uses mmap() to create a shared memory region for transaction coordination in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, and it will call mmap() multiple times for large transactions. The QNX mmap() has been demonstrated to corrupt database file under that scenario. QNX engineers are aware of this problem and are working on a solution; the problem may have already been fixed by the time you read this.</source>
          <target state="translated">단일 파일 디스크립터에 대해 두 번째 mmap () 호출을 수행하면 첫 번째 mmap () 호출에서 얻은 메모리가 0이 될 수 있도록 QNX에서 mmap ()에 미묘한 문제가 있습니다. Unix의 SQLite는 mmap ()을 사용하여 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 트랜잭션 조정을위한 공유 메모리 영역을 작성하며 대규모 트랜잭션의 경우 mmap ()을 여러 번 호출합니다. QNX mmap ()은 해당 시나리오에서 데이터베이스 파일을 손상시키는 것으로 입증되었습니다. QNX 엔지니어는이 문제를 알고 있으며 해결책을 찾고 있습니다. 이 내용을 읽을 때 문제가 이미 해결되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d56d459074bf9b196b2551c494a4c7bec9d94df2" translate="yes" xml:space="preserve">
          <source>There has lately been a lot of interest in &quot;safe&quot; programming languages like Rust or Go in which it is impossible, or is at least difficult, to make common programming errors like memory leaks or array overruns. So the question often arises as to why SQLite is not coded in a &quot;safe&quot; language.</source>
          <target state="translated">최근 Rust 또는 Go와 같은 &quot;안전한&quot;프로그래밍 언어에 관심이있어 메모리 누수 나 어레이 오버런과 같은 일반적인 프로그래밍 오류를 만드는 것이 불가능하거나 적어도 어렵다. 따라서 SQLite가 &quot;안전한&quot;언어로 코딩되지 않은 이유에 대한 의문이 종종 발생합니다.</target>
        </trans-unit>
        <trans-unit id="52072b3d340cc958b2ff6cebc4a70e99aba7da9e" translate="yes" xml:space="preserve">
          <source>There have been three historical file formats for SQLite. SQLite 1.0 through 1.0.32 used the &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; library as its storage engine. SQLite 2.0.0 through 2.8.17 used a custom b-tree storage engine that supported only text keys and data. All modern versions of SQLite (3.0.0 to present) use a b-tree storage engine that has full support for binary data and Unicode.</source>
          <target state="translated">SQLite에 대한 세 가지 히스토리 파일 형식이 있습니다. SQLite 1.0부터 1.0.32까지는 &lt;a href=&quot;https://www.gnu.org/software/gdbm/gdbm.html&quot;&gt;gdbm&lt;/a&gt; 라이브러리를 스토리지 엔진으로 사용했습니다. SQLite 2.0.0부터 2.8.17까지는 텍스트 키와 데이터 만 지원하는 사용자 지정 b- 트리 저장소 엔진을 사용했습니다. 모든 최신 버전의 SQLite (3.0.0부터 현재)는 이진 데이터 및 유니 코드를 완벽하게 지원하는 b- 트리 스토리지 엔진을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3be8d2f16b71e4444f7f725739b5254eb08f103c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; which will return the integer key for the most recent insert operation.</source>
          <target state="translated">&lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 라는 함수 가 있으며 가장 최근의 삽입 작업에 대한 정수 키를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c4047eace270e4351576190943319e0de00174c" translate="yes" xml:space="preserve">
          <source>There is a limit, set using &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt;, to the number of databases that can be simultaneously attached to a single database connection.</source>
          <target state="translated">&lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitattached&quot;&gt;SQLITE_LIMIT_ATTACHED&lt;/a&gt; 를 사용하여 단일 데이터베이스 연결에 동시에 연결할 수있는 데이터베이스 수에 한계 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03b97c401c9a348f14fea8d291ce117238dc810" translate="yes" xml:space="preserve">
          <source>There is a long list of conditions that must all be met in order for query flattening to occur. Some of the constraints are marked as obsolete by italic text. These extra constraints are retained in the documentation to preserve the numbering of the other constraints.</source>
          <target state="translated">쿼리 병합을 수행하기 위해 충족해야하는 조건 목록이 많이 있습니다. 일부 제약 조건은 기울임 꼴 텍스트에서 더 이상 사용되지 않는 것으로 표시됩니다. 이러한 추가 제약 조건은 다른 제약 조건의 번호를 유지하기 위해 설명서에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="098b1868e66c13228c4371a548aa26b3bfac10d5" translate="yes" xml:space="preserve">
          <source>There is a new TypeOf() function used to determine if an expression is numeric or text.</source>
          <target state="translated">표현식이 숫자인지 텍스트인지 판별하는 데 사용되는 새로운 TypeOf () 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6da2fbcc052924976fcf688d82595c343604804" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_master.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">sqlite_sequence 테이블에는 AUTOINCREMENT를 사용하는 각 일반 테이블에 대한 단일 행이 있습니다. sqlite_master.name에 표시되는 테이블 이름은 sqlite_sequence.main 필드에 있으며 해당 테이블에 삽입 된 최대 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 는 sqlite_sequence.seq 필드에 있습니다. AUTOINCREMENT 테이블에 대해 새로 자동 생성 된 정수 기본 키는 해당 테이블의 sqlite_sequence.seq 필드보다 커야합니다. AUTOINCREMENT 테이블의 sqlite_sequence.seq 필드가 이미 가장 큰 정수 값 (9223372036854775807) 인 경우 자동으로 생성 된 정수 1 차로 해당 테이블에 새 행을 추가하려고 시도하면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 과 함께 실패합니다 .오류. sqlite_sequence.seq 필드는 새 항목이 AUTOINCREMENT 테이블에 삽입 될 때 필요한 경우 자동으로 업데이트됩니다. AUTOINCREMENT 테이블의 sqlite_sequence 행은 테이블이 삭제 될 때 자동으로 삭제됩니다. AUTOINCREMENT 테이블이 갱신 될 때 AUTOINCREMENT 테이블에 대한 sqlite_sequence 행이 존재하지 않으면, 새로운 sqlite_sequence 행이 작성됩니다. AUTOINCREMENT 테이블의 sqlite_sequence.seq 값을 수동으로 정수 이외의 값으로 설정 한 후 AUTOINCREMENT 테이블을 삽입하거나 업데이트하려는 후속 시도가 있으면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="873101a14a572759e5a45b0dc79cf0cd42bbd9dd" translate="yes" xml:space="preserve">
          <source>There is a single row in the sqlite_sequence table for each ordinary table that uses AUTOINCREMENT. The name of the table (as it appears in sqlite_schema.name) is in the sqlite_sequence.main field and the largest &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ever inserted into that table is in the sqlite_sequence.seq field. New automatically generated integer primary keys for AUTOINCREMENT tables are guaranteed to be larger than the sqlite_sequence.seq field for that table. If the sqlite_sequence.seq field of an AUTOINCREMENT table is already at the largest integer value (9223372036854775807) then attempts to add new rows to that table with an automatically generated integer primary will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error. The sqlite_sequence.seq field is automatically updated if required when new entries are inserted to an AUTOINCREMENT table. The sqlite_sequence row for an AUTOINCREMENT table is automatically deleted when the table is dropped. If the sqlite_sequence row for an AUTOINCREMENT table does not exist when the AUTOINCREMENT table is updated, then a new sqlite_sequence row is created. If the sqlite_sequence.seq value for an AUTOINCREMENT table is manually set to something other than an integer and there is a subsequent attempt to insert the or update the AUTOINCREMENT table, then the behavior is undefined.</source>
          <target state="translated">AUTOINCREMENT를 사용하는 각 일반 테이블에 대한 sqlite_sequence 테이블에는 단일 행이 있습니다. 테이블 이름 (sqlite_schema.name에 표시됨)은 sqlite_sequence.main 필드에 있으며 해당 테이블에 삽입 된 가장 큰 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 는 sqlite_sequence.seq 필드에 있습니다. AUTOINCREMENT 테이블에 대해 자동으로 생성 된 새로 생성 된 정수 기본 키는 해당 테이블의 sqlite_sequence.seq 필드보다 큰 것이 보장됩니다. AUTOINCREMENT 테이블의 sqlite_sequence.seq 필드가 이미 가장 큰 정수 값 (9223372036854775807)에있는 경우 자동으로 생성 된 정수 기본을 사용하여 해당 테이블에 새 행을 추가하려고하면 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 과 함께 실패합니다 .오류. sqlite_sequence.seq 필드는 AUTOINCREMENT 테이블에 새 항목이 삽입 될 때 필요한 경우 자동으로 업데이트됩니다. AUTOINCREMENT 테이블의 sqlite_sequence 행은 테이블이 삭제 될 때 자동으로 삭제됩니다. AUTOINCREMENT 테이블이 업데이트 될 때 AUTOINCREMENT 테이블에 대한 sqlite_sequence 행이 없으면 새 sqlite_sequence 행이 생성됩니다. AUTOINCREMENT 테이블에 대한 sqlite_sequence.seq 값이 정수가 아닌 다른 값으로 수동 설정되고 이후에 AUTOINCREMENT 테이블을 삽입하거나 업데이트하려는 시도가있는 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f02c79b70988445eed051dee5ef879c5abc0fcef" translate="yes" xml:space="preserve">
          <source>There is a single row of the dbstat table for each page in the database file. Freelist pages, the lock page, and pointer-map pages of the database file do not appear in the dbstat virtual table.</source>
          <target state="translated">데이터베이스 파일의 각 페이지에 대해 dbstat 테이블의 단일 행이 있습니다. 데이터베이스 파일의 프리리스트 페이지, 잠금 페이지 및 포인터 맵 페이지가 dbstat 가상 테이블에 나타나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aad819f0714ba351410884e15d9171da8c02d268" translate="yes" xml:space="preserve">
          <source>There is also a &quot;.once -e&quot; command which works similarly, except that it names the temporary file with a &quot;.txt&quot; suffix so that the default text editor for the system will be invoked, instead of the default spreadsheet.</source>
          <target state="translated">&quot;.once -e&quot;명령도 있습니다. 기본 스프레드 시트 대신 시스템의 기본 텍스트 편집기가 호출되도록 임시 파일의 이름을 &quot;.txt&quot;접미어로 지정한다는 점을 제외하면 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d689365d69d51f44124dabea5ed23d15cbc239dd" translate="yes" xml:space="preserve">
          <source>There is also a function for computing the Wagner edit distance or the Levenshtein distance between a pattern and a word. This function is exposed as spellfix1_editdist(X,Y). The edit distance function returns the &quot;cost&quot; of converting X into Y. Some transformations cost more than others. Changing one vowel into a different vowel, for example is relatively cheap, as is doubling a constant, or omitting the second character of a double-constant. Other transformations or more expensive. The idea is that the edit distance function returns a low cost for words that are similar and a higher cost for words that are further apart. In this implementation, the maximum cost of any single-character edit (delete, insert, or substitute) is 100, with lower costs for some edits (such as transforming vowels).</source>
          <target state="translated">패턴과 단어 사이의 Wagner 편집 거리 또는 Levenshtein 거리를 계산하는 기능도 있습니다. 이 함수는 spellfix1_editdist (X, Y)로 노출됩니다. 거리 편집 기능은 X를 Y로 변환하는 &quot;비용&quot;을 반환합니다. 일부 변환은 다른 변환보다 비용이 많이 듭니다. 예를 들어, 하나의 모음을 다른 모음으로 변경하는 것은 상수를 두 배로 늘리거나 이중 상수의 두 번째 문자를 생략하는 것처럼 비교적 저렴합니다. 다른 변형 또는 더 비쌉니다. 아이디어는 거리 편집 기능이 유사한 단어에 대해서는 저렴한 비용을, 더 떨어져있는 단어에는 더 높은 비용을 반환한다는 것입니다. 이 구현에서 단일 문자 편집 (삭제, 삽입 또는 대체)의 최대 비용은 100이며 일부 편집 (예 : 모음 변환)에 대한 비용이 저렴합니다.</target>
        </trans-unit>
        <trans-unit id="8f729e8ad1be217b3b85bb1dbd08e4580826f423" translate="yes" xml:space="preserve">
          <source>There is also a new &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode for the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; that allows an application to query the powersafe overwrite property for a database file.</source>
          <target state="translated">또한 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()에&lt;/a&gt; 대한 새로운 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpowersafeoverwrite&quot;&gt;SQLITE_FCNTL_POWERSAFE_OVERWRITE&lt;/a&gt; opcode가 있어 응용 프로그램이 데이터베이스 파일의 powersafe 겹쳐 쓰기 특성을 조회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5d98dc46e0aff9a749813616cdf742a9f8913ea" translate="yes" xml:space="preserve">
          <source>There is also an SQL function that can be used to load extensions: &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension(X,Y)&lt;/a&gt;. It works just like the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C interface.</source>
          <target state="translated">확장을로드하는 데 사용할 수있는 SQL 함수도 있습니다 : &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension (X, Y)&lt;/a&gt; . &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C 인터페이스 와 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="043cd14b86c980f673cef92a152d79c2c6e3cf2c" translate="yes" xml:space="preserve">
          <source>There is always a default VFS. The legacy interfaces &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; always use the default VFS. The new interface for creating database connections, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, allows you to specify which VFS you want to use by name.</source>
          <target state="translated">항상 기본 VFS가 있습니다. 레거시 인터페이스 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()은&lt;/a&gt; 항상 기본 VFS를 사용합니다. 데이터베이스 연결 작성을위한 새로운 인터페이스 인 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 사용하면 이름으로 사용할 VFS를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a75d63f61cb222d77eadc6074711ab25e460df12" translate="yes" xml:space="preserve">
          <source>There is always one VFS which is the default VFS. On unix systems, the &quot;unix&quot; VFS comes up as the default and on windows it is &quot;win32&quot;. If no other actions are taken, new database connections will make use of the default VFS.</source>
          <target state="translated">기본 VFS 인 VFS는 항상 하나입니다. 유닉스 시스템에서는 &quot;unix&quot;VFS가 기본값으로 나타나고 Windows에서는 &quot;win32&quot;입니다. 다른 조치를 취하지 않으면 새 데이터베이스 연결에서 기본 VFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a07e87b2dfc85be098248de6c63083968b9cc2a5" translate="yes" xml:space="preserve">
          <source>There is an additional quasi-persistent &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; file and &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; shared memory file associated with each database, which can make SQLite less appealing for use as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;.</source>
          <target state="translated">각 데이터베이스와 연관된 추가 준 지속적 &quot; &lt;code&gt;-wal&lt;/code&gt; &quot;파일 및 &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;공유 메모리 파일이 있으므로 SQLite를 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용하기에 덜 매력적일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c15ef6d2dec509f5afb1c6ad236607cae0e66e0" translate="yes" xml:space="preserve">
          <source>There is an assortment of sqlite3_bind routines used to assign values to wildcards in a prepared SQL statement. Unbound wildcards are interpreted as NULLs. Bindings are not reset by sqlite3_reset(). But wildcards can be rebound to new values after an sqlite3_reset().</source>
          <target state="translated">준비된 SQL 문에서 와일드 카드에 값을 지정하는 데 사용되는 sqlite3_bind 루틴이 있습니다. 언 바운드 와일드 카드는 NULL로 해석됩니다. 바인딩은 sqlite3_reset ()에 의해 재설정되지 않습니다. 그러나 sqlite3_reset () 다음에 와일드 카드를 새 값으로 리 바인드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cba197f7f4cf87333685b6d55dd8ea7d285abdf" translate="yes" xml:space="preserve">
          <source>There is an implied &quot;&lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot; instruction inserted at the very end of every program. So a jump past the last instruction of the program is the same as executing &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt;.</source>
          <target state="translated">모든 프로그램의 맨 끝에 묵시적 &quot; &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 0 0 0&quot;명령이 삽입되었습니다. 따라서 프로그램의 마지막 명령을 뛰어 넘는 것은 &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; 실행과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="16ef4ec82cf13cdae86f5bf01316c19576909f0f" translate="yes" xml:space="preserve">
          <source>There is an unofficial and unsanctioned Git clone of this repository at &lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/mackyle/sqlite&quot;&gt;https://github.com/mackyle/sqlite&lt;/a&gt; 에이 저장소의 비공식 및 승인되지 않은 Git 복제본이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bea5c372cd0bf0b6a49c619c32079d5921e4aed3" translate="yes" xml:space="preserve">
          <source>There is another, deprecated, method for invoking the optimize operation using a SELECT statement. New code should use statements similar to the INSERT above to optimize FTS structures.</source>
          <target state="translated">SELECT 문을 사용하여 최적화 작업을 호출하는 더 이상 사용되지 않는 다른 방법이 있습니다. 새 코드는 위의 INSERT와 유사한 명령문을 사용하여 FTS 구조를 최적화해야합니다.</target>
        </trans-unit>
        <trans-unit id="b085a1ad6ab5d12c0b0eb9f325abf631b21418bf" translate="yes" xml:space="preserve">
          <source>There is no &quot;CREATE TEMP VIRTUAL TABLE&quot; statement. To create a temporary virtual table, add the &quot;temp&quot; schema before the virtual table name.</source>
          <target state="translated">&quot;CREATE TEMP VIRTUAL TABLE&quot;문이 없습니다. 임시 가상 테이블을 작성하려면 가상 테이블 이름 앞에 &quot;temp&quot;스키마를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f17db4bcecd606fe4d51c30c972432fc774cef49" translate="yes" xml:space="preserve">
          <source>There is no RESERVED lock on the corresponding database file.</source>
          <target state="translated">해당 데이터베이스 파일에 예약 된 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e99ed00de2d6f07769da563a3ed2aa8bf01a7e2e" translate="yes" xml:space="preserve">
          <source>There is no agreement on what the C datatype for a UTF-16 string should be. Therefore, SQLite uses a generic type of void* to refer to UTF-16 strings. Client software can cast the void* to whatever datatype is appropriate for their system.</source>
          <target state="translated">UTF-16 문자열에 대한 C 데이터 유형이 무엇인지에 대해서는 동의하지 않습니다. 따라서 SQLite는 일반적인 유형의 void *를 사용하여 UTF-16 문자열을 참조합니다. 클라이언트 소프트웨어는 시스템에 적합한 데이터 유형으로 void *를 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c505515229e6ccfbb2128baeaa4350ad9e337f7c" translate="yes" xml:space="preserve">
          <source>There is no conflicting row in this case. The results of invoking the sqlite3changeset_conflict() API are undefined.</source>
          <target state="translated">이 경우 충돌하는 행이 없습니다. sqlite3changeset_conflict () API를 호출 한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a04b936246a75ee50e5104c87c5e5c3bc05ae139" translate="yes" xml:space="preserve">
          <source>There is no pre-defined release cycle. Releases occur when there is a critical mass of feature enhancements and/or bug fixes. Historically, releases have occurred about 5 or 6 times per year. Users of SQLite pick up new releases from the website on an as-needed basis.</source>
          <target state="translated">사전 정의 된 릴리스주기가 없습니다. 많은 기능 향상 및 / 또는 버그 수정이있을 때 릴리스가 발생합니다. 역사적으로 릴리스는 매년 약 5-6 회 발생했습니다. SQLite 사용자는 필요에 따라 웹 사이트에서 새 릴리스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="dd71d330015524aacf28e91f9c23458da952387d" translate="yes" xml:space="preserve">
          <source>There is no reserved lock on the main database file.</source>
          <target state="translated">기본 데이터베이스 파일에는 예약 된 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7df732794b7961185fb08c11a413b1539639964a" translate="yes" xml:space="preserve">
          <source>There is no support for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;. Changes to virtual tables are not captured.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 지원되지 않습니다 . 가상 테이블의 변경 사항이 캡처되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11d7bfeb25e84c6d1e9766a1abf1f94079350c5e" translate="yes" xml:space="preserve">
          <source>There is normally one row per index, with the index identified by the name in the sqlite_stat1.idx column. The sqlite_stat1.tbl column is the name of the table to which the index belongs. In each such row, the sqlite_stat.stat column will be a string consisting of a list of integers followed by zero or more arguments. The first integer in this list is the approximate number of rows in the index. (The number of rows in the index is the same as the number of rows in the table, except for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.) The second integer is the approximate number of rows in the index that have the same value in the first column of the index. The third integer is the number number of rows in the index that have the same value for the first two columns. The N-th integer (for N&amp;gt;1) is the estimated average number of rows in the index which have the same value for the first N-1 columns. For a K-column index, there will be K+1 integers in the stat column. If the index is unique, then the last integer will be 1.</source>
          <target state="translated">일반적으로 인덱스 당 하나의 행이 있으며 인덱스는 sqlite_stat1.idx 열의 이름으로 식별됩니다. sqlite_stat1.tbl 열은 인덱스가 속한 테이블의 이름입니다. 이러한 각 행에서 sqlite_stat.stat 열은 정수 목록과 0 개 이상의 인수로 구성된 문자열입니다. 이 목록의 첫 번째 정수는 색인의 대략적인 행 수입니다. (인덱스의 행 수는 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스를&lt;/a&gt; 제외하고 테이블의 행 수와 동일 합니다..) 두 번째 정수는 인덱스의 첫 번째 열에서 동일한 값을 갖는 인덱스의 대략적인 행 수입니다. 세 번째 정수는 처음 두 열에 대해 동일한 값을 갖는 인덱스의 행 수입니다. N 번째 정수 (N&amp;gt; 1의 경우)는 인덱스에서 첫 번째 N-1 열에 대해 동일한 값을 갖는 예상 평균 행 수입니다. K- 컬럼 인덱스의 경우 통계 열에 K + 1 정수가 있습니다. 인덱스가 고유하면 마지막 정수는 1입니다.</target>
        </trans-unit>
        <trans-unit id="c9c3e6d9120e8e4bfa41b1d6a3111f7343cb6f19" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative malloc()/free() implementations without having to modify any core SQLite code.</source>
          <target state="translated">응용 프로그램이 핵심 SQLite 코드를 수정하지 않고도 대체 malloc () / free () 구현을 정의 할 수있는 컴파일 타임 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62ae2b58bd448bf76ec1b9c9d9ded56906eaff1" translate="yes" xml:space="preserve">
          <source>There is now a compile-time option that allows an application to define alternative mutex implementations without having to modify any core SQLite code.</source>
          <target state="translated">응용 프로그램이 핵심 SQLite 코드를 수정하지 않고도 대체 뮤텍스 구현을 정의 할 수있는 컴파일 타임 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cb6058c59ace1351641df9e565cb12b51e73fe" translate="yes" xml:space="preserve">
          <source>There is one entry in the %_node table for each R*Tree node. An R*Tree node consists of one or more entries that are proximate to one another. The nodes of an R*Tree for a tree. All nodes other than the root have an entry in the %_parent shadow table that identifies the parent node. Each entry in an R*Tree has a rowid. The %_rowid shadow table maps entry rowids to the node that contains that entry.</source>
          <target state="translated">% _node 테이블에는 각 R * Tree 노드마다 하나의 항목이 있습니다. R * Tree 노드는 서로 근접한 하나 이상의 항목으로 구성됩니다. 트리에 대한 R * Tree의 노드입니다. 루트 이외의 모든 노드에는 % _parent 새도우 테이블에 상위 노드를 식별하는 항목이 있습니다. R * Tree의 각 항목에는 rowid가 있습니다. % _rowid 새도우 테이블은 항목 rowid를 해당 항목이 포함 된 노드에 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="91aa566670abb0466fc190ee57ffd69271a7af7c" translate="yes" xml:space="preserve">
          <source>There is one exception to the previous paragraph: when a row is inserted, updated or deleted, if one or more of its primary key columns contain a NULL value, no record of the change is made.</source>
          <target state="translated">이전 단락에는 한 가지 예외가 있습니다. 행을 삽입, 업데이트 또는 삭제하는 경우 하나 이상의 기본 키 열에 NULL 값이 포함되어 있으면 변경 기록이 없습니다.</target>
        </trans-unit>
        <trans-unit id="545885bb104866881571615fd910604fef6b0f44" translate="yes" xml:space="preserve">
          <source>There is one important difference between ON UPDATE foreign key actions and SQL triggers. An ON UPDATE action is only taken if the values of the parent key are modified so that the new parent key values are not equal to the old. For example:</source>
          <target state="translated">ON UPDATE 외래 키 동작과 SQL 트리거 사이에는 중요한 차이점이 있습니다. ON UPDATE 조치는 새 상위 키 값이 이전 값과 같지 않도록 상위 키 값이 수정 된 경우에만 수행됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67f4030e1b4840bae9054c024eff72bf5cb42560" translate="yes" xml:space="preserve">
          <source>There is one other subtle difference between &quot;docid&quot; and the normal SQLite aliases for the rowid column. Normally, if an INSERT or UPDATE statement assigns discrete values to two or more aliases of the rowid column, SQLite writes the rightmost of such values specified in the INSERT or UPDATE statement to the database. However, assigning a non-NULL value to both the &quot;docid&quot; and one or more of the SQLite rowid aliases when inserting or updating an FTS table is considered an error. See below for an example.</source>
          <target state="translated">&quot;docid&quot;와 rowid 열의 일반 SQLite 별명 간에는 미묘한 차이가 있습니다. 일반적으로 INSERT 또는 UPDATE 문이 이산 값을 rowid 열의 둘 이상의 별칭에 할당하면 SQLite는 INSERT 또는 UPDATE 문에 지정된 값 중 가장 오른쪽을 데이터베이스에 씁니다. 그러나 FTS 테이블을 삽입하거나 갱신 할 때 &quot;docid&quot;및 하나 이상의 SQLite rowid 별명 모두에 NULL이 아닌 값을 지정하는 것은 오류로 간주됩니다. 예는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f856aedc1ad69cfc42357d4bdb200682208f50ab" translate="yes" xml:space="preserve">
          <source>There is only one sorter object, so there are no instructions to open or close it. It is opened automatically when needed, and it is closed when the VDBE program halts.</source>
          <target state="translated">분류기 개체가 하나뿐이므로이를 열거 나 닫는 지침이 없습니다. 필요할 때 자동으로 열리고 VDBE 프로그램이 중지되면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="6e50e0d48c576b86d93a31befcc02f54e14b5267" translate="yes" xml:space="preserve">
          <source>There is the extra operation of &lt;a href=&quot;wal#ckpt&quot;&gt;checkpointing&lt;/a&gt; which, though automatic by default, is still something that application developers need to be mindful of.</source>
          <target state="translated">기본적으로 자동이지만 응용 프로그램 개발자가 염두에 두어야 할 추가 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업이 있습니다.</target>
        </trans-unit>
        <trans-unit id="62428f96be095192850e1858e6283c21fe02dd48" translate="yes" xml:space="preserve">
          <source>There is write permission on the directory containing the database so that the &lt;code&gt;-shm&lt;/code&gt; and &lt;code&gt;-wal&lt;/code&gt; files can be created.</source>
          <target state="translated">&lt;code&gt;-shm&lt;/code&gt; 및 &lt;code&gt;-wal&lt;/code&gt; 파일을 작성할 수 있도록 데이터베이스가 포함 된 디렉토리에 대한 쓰기 권한 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6352389dca7ff834f53599bb4e1238c6a257d8" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">차단 된 연결로 등록 된 최대 하나의 잠금 해제 알림 콜백이있을 수 있습니다. 차단 된 연결에 이미 등록 된 잠금 해제 알림 콜백이있을 때 sqlite3_unlock_notify ()가 호출되면 새 콜백이 이전 콜백을 대체합니다. sqlite3_unlock_notify ()가 두 번째 인수로 NULL 포인터를 사용하여 호출되면 기존 잠금 해제 알림 콜백이 취소됩니다. &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 차단 된 연결을 닫으면 차단 된 연결 잠금 해제 알림 콜백도 취소 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="474f04800d7576cb1df432f79959d44e97ec88c4" translate="yes" xml:space="preserve">
          <source>There may be at most one unlock-notify callback registered by a blocked connection. If sqlite3_unlock_notify() is called when the blocked connection already has a registered unlock-notify callback, then the new callback replaces the old. If sqlite3_unlock_notify() is called with a NULL pointer as its second argument, then any existing unlock-notify callback is canceled. The blocked connections unlock-notify callback may also be canceled by closing the blocked connection using &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">차단 된 연결로 등록 된 최대 하나의 잠금 해제 알림 콜백이있을 수 있습니다. 차단 된 연결에 이미 등록 된 잠금 해제 알림 콜백이있을 때 sqlite3_unlock_notify ()가 호출되면 새 콜백이 이전 콜백을 대체합니다. sqlite3_unlock_notify ()가 두 번째 인수로 NULL 포인터를 사용하여 호출되면 기존 잠금 해제 알림 콜백이 취소됩니다. &lt;a href=&quot;close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 차단 된 연결을 닫으면 차단 된 연결 잠금 해제 알림 콜백도 취소 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51e2e6b0569ca6a8c745966ed3e14378d13e60a9" translate="yes" xml:space="preserve">
          <source>There might be merge conflicts. In other words, it might be that the changes from (2) to (3) are incompatible with the changes from (1) to (4). In that case, the maintainer will have to manually resolve the conflicts. Hopefully conflicts will not come up that often. Conflicts are less likely to occur when the private edits are kept to a minimum.</source>
          <target state="translated">병합 충돌이있을 수 있습니다. 즉, (2)에서 (3)으로 변경 한 내용이 (1)에서 (4)로 변경 한 내용과 호환되지 않을 수 있습니다. 이 경우 관리자는 충돌을 수동으로 해결해야합니다. 바라건대 갈등이 자주 일어나지 않을 것입니다. 개인 편집 내용을 최소로 유지하면 충돌이 발생할 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="c1f15675484de7896b9f4cea6917b5f96c0a2c61" translate="yes" xml:space="preserve">
          <source>There might be one or more &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; objects open and in use on the virtual table instance and perhaps even on the row of the virtual table when the xUpdate method is invoked. The implementation of xUpdate must be prepared for attempts to delete or modify rows of the table out from other existing cursors. If the virtual table cannot accommodate such changes, the xUpdate method must return an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">가상 테이블 인스턴스 및 xUpdate 메소드가 호출 될 때 가상 테이블의 행에서 하나 이상의 &lt;a href=&quot;c3ref/vtab_cursor&quot;&gt;sqlite3_vtab_cursor&lt;/a&gt; 오브젝트가 열려 있고 사용 중일 수 있습니다. 다른 기존 커서에서 테이블의 행을 삭제하거나 수정하려는 경우 xUpdate 구현을 준비해야합니다. 가상 테이블이 그러한 변경을 수용 할 수없는 경우 xUpdate 메소드는 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f17a65d092891c67c0c7c0d6ffba57606e51c65a" translate="yes" xml:space="preserve">
          <source>There must be a read-lock on the database (either a transaction must be started or there must be an open cursor) before executing this instruction.</source>
          <target state="translated">이 명령어를 실행하기 전에 데이터베이스에 읽기 잠금이 있어야합니다 (트랜잭션을 시작해야하거나 열린 커서가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="838abced0ca5c629a232ce0c8ac382dc2a5201e9" translate="yes" xml:space="preserve">
          <source>There must be no overlap in the bands of rowids for the various tables in a union-vtab.</source>
          <target state="translated">union-vtab의 다양한 테이블에 대한 rowid 밴드에는 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2f109c8b1d1e372963703dc38ccb68fefa2006aa" translate="yes" xml:space="preserve">
          <source>There must be no overlapping rowid ranges in the rows returned by the SQL statement. It is an error if there are.</source>
          <target state="translated">SQL 문이 리턴 한 행에 겹치는 rowid 범위가 없어야합니다. 있으면 오류입니다.</target>
        </trans-unit>
        <trans-unit id="af3fe573da439b499f0025edd3eb3c7aa3d7e8cd" translate="yes" xml:space="preserve">
          <source>There must not be a write transaction open on schema S of database connection D.</source>
          <target state="translated">데이터베이스 연결 D의 스키마 S에서 열려있는 쓰기 트랜잭션이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d41940c4561987aa3b448b06598e8d1c6472839" translate="yes" xml:space="preserve">
          <source>There should be exactly one call to sqlite3_backup_finish() for each successful call to sqlite3_backup_init().</source>
          <target state="translated">sqlite3_backup_init ()를 성공적으로 호출 할 때마다 sqlite3_backup_finish ()를 정확히 한 번 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cf5a0f0e6851073aea7c635470af127d9d907d8" translate="yes" xml:space="preserve">
          <source>There were reports that SQLite did not perform as well on an indexed table. This test was recently added to disprove those rumors. It is true that SQLite is not as fast at creating new index entries as the other engines (see Test 6 below) but its overall speed is still better.</source>
          <target state="translated">인덱싱 된 테이블에서 SQLite가 제대로 수행되지 않았다는보고가있었습니다. 이 테스트는 최근 그 소문을 반증하기 위해 추가되었습니다. SQLite가 다른 엔진처럼 새 인덱스 항목을 만드는 데 빠르지는 않지만 (아래 테스트 6 참조) 전체 속도는 여전히 낫습니다.</target>
        </trans-unit>
        <trans-unit id="7cdb3ca5132a0c3bc86c19fe3abd0889729f8701" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">이 API는 라이브러리가 &lt;a href=&quot;../compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C 프리 프로세서 기호 로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="04c8e718505dcab90cfc6233e2bd22375b7164d1" translate="yes" xml:space="preserve">
          <source>These APIs are only available if the library was compiled with the &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C-preprocessor symbol.</source>
          <target state="translated">이 API는 라이브러리가 &lt;a href=&quot;compile#enable_column_metadata&quot;&gt;SQLITE_ENABLE_COLUMN_METADATA&lt;/a&gt; C 프리 프로세서 기호 로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="c0bacb531ef3c143611b93d8575c5722c7b86645" translate="yes" xml:space="preserve">
          <source>These action code values signify what kind of operation is to be authorized. The 3rd and 4th parameters to the authorization callback function will be parameters or NULL depending on which of these codes is used as the second parameter. The 5th parameter to the authorizer callback is the name of the database (&quot;main&quot;, &quot;temp&quot;, etc.) if applicable. The 6th parameter to the authorizer callback is the name of the inner-most trigger or view that is responsible for the access attempt or NULL if this access attempt is directly from top-level SQL code.</source>
          <target state="translated">이 조치 코드 값은 어떤 종류의 조작이 권한 부여되는지를 나타냅니다. 권한 부여 콜백 함수의 3 번째 및 4 번째 매개 변수는 두 번째 매개 변수로 사용되는 코드에 따라 매개 변수 또는 NULL입니다. 권한 부 여자 콜백에 대한 다섯 번째 매개 변수는 해당되는 경우 데이터베이스 이름 ( &quot;main&quot;, &quot;temp&quot;등)입니다. 권한 부 여자 콜백의 6 번째 매개 변수는 액세스 시도를 담당하는 가장 안쪽 트리거 또는보기의 이름이거나이 액세스 시도가 최상위 SQL 코드에서 직접 수행 된 경우 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="08d99679f060455eb057ba3c4cf117bfe450c567" translate="yes" xml:space="preserve">
          <source>These and other similar syntax restrictions are described in the text.</source>
          <target state="translated">이러한 구문 및 기타 유사한 구문 제한 사항은 텍스트에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="373ccf29c36481aabf98cf8d5fcf341e72288794" translate="yes" xml:space="preserve">
          <source>These are just a few of the benefits of using SQLite as an application file format &amp;mdash; the benefits that seem most likely to improve the user experience for applications like OpenOffice. Other applications might benefit from SQLite in different ways. See the &lt;a href=&quot;appfileformat&quot;&gt;Application File Format&lt;/a&gt; document for additional ideas.</source>
          <target state="translated">이는 SQLite를 응용 프로그램 파일 형식으로 사용함으로써 얻을 수있는 이점 중 일부입니다. OpenOffice와 같은 응용 프로그램의 사용자 경험을 향상시킬 가능성이 가장 높습니다. 다른 응용 프로그램은 다른 방식으로 SQLite를 활용할 수 있습니다. 추가 아이디어 는 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="840704459c7bebebba604f0b7c84031cf12ac5c7" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; 와 같은 루틴에 최종 인수로 전달되는 소멸자에 대한 특수 값입니다 . 소멸자 인수가 SQLITE_STATIC 인 경우 컨텐츠 포인터가 일정하고 변경되지 않음을 의미합니다. 파괴 할 필요가 없습니다. SQLITE_TRANSIENT 값은 가까운 시일 내에 컨텐츠가 변경 될 가능성이 있으며 SQLite는 리턴하기 전에 자체 컨텐츠 사본을 작성해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3097b1326f3eb788f48bb5e49292e793f88d3f73" translate="yes" xml:space="preserve">
          <source>These are special values for the destructor that is passed in as the final argument to routines like &lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob()&lt;/a&gt;. If the destructor argument is SQLITE_STATIC, it means that the content pointer is constant and will never change. It does not need to be destroyed. The SQLITE_TRANSIENT value means that the content will likely change in the near future and that SQLite should make its own private copy of the content before returning.</source>
          <target state="translated">&lt;a href=&quot;result_blob&quot;&gt;sqlite3_result_blob ()&lt;/a&gt; 와 같은 루틴에 최종 인수로 전달되는 소멸자에 대한 특수 값입니다 . 소멸자 인수가 SQLITE_STATIC 인 경우 컨텐츠 포인터가 일정하고 변경되지 않음을 의미합니다. 파괴 할 필요가 없습니다. SQLITE_TRANSIENT 값은 가까운 시일 내에 컨텐츠가 변경 될 가능성이 있으며 SQLite는 리턴하기 전에 자체 컨텐츠 사본을 작성해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="49e507a42bf99a1526a38fb0d00d4e955eae6280" translate="yes" xml:space="preserve">
          <source>These are the eight locks supported:</source>
          <target state="translated">지원되는 8 개의 잠금 장치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b356241fa91bdf09876f0517086180731227ee47" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;../vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">이들은 &lt;a href=&quot;../vfs&quot;&gt;사용자 정의 VFS 구현에&lt;/a&gt; 유용한 유틸리티 루틴으로, 데이터베이스 파일이 특정 쿼리 매개 변수를 포함하는 URI인지 확인하고, 그렇다면 해당 쿼리 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="56ef0cc4c32969ca19f4793dd10614a44d9a509c" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt;, that check if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">이들은 &lt;a href=&quot;vfs&quot;&gt;사용자 정의 VFS 구현에&lt;/a&gt; 유용한 유틸리티 루틴으로, 데이터베이스 파일이 특정 쿼리 매개 변수를 포함하는 URI인지 확인하고, 그렇다면 해당 쿼리 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d61de6a061e0e9a67e085323db1a55d01abf6a99" translate="yes" xml:space="preserve">
          <source>These are utility routines, useful to VFS implementations, that check to see if a database file was a URI that contained a specific query parameter, and if so obtains the value of that query parameter.</source>
          <target state="translated">이들은 VFS 구현에 유용한 유틸리티 루틴으로, 데이터베이스 파일이 특정 쿼리 매개 변수를 포함하는 URI인지 확인하여 해당 쿼리 매개 변수의 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0ae1c1d92689387597a221cbf4a8586463c0d9b8" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">이 비트 값은 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스에 대한 세 번째 매개 변수 및 &lt;a href=&quot;#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드 에 대한 네 번째 매개 변수에서 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="091c1cd775270574b7e8fe92576bddaa3dc774e3" translate="yes" xml:space="preserve">
          <source>These bit values are intended for use in the 3rd parameter to the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface and in the 4th parameter to the &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; method.</source>
          <target state="translated">이 비트 값은 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스에 대한 세 번째 매개 변수 및 &lt;a href=&quot;vfs#sqlite3vfsxopen&quot;&gt;sqlite3_vfs.xOpen&lt;/a&gt; 메소드 에 대한 네 번째 매개 변수에서 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="7379d4e0ce4f6675fd9028087eadfa8eb7ff4976" translate="yes" xml:space="preserve">
          <source>These changes in the default behavior of SQLite are not a compatibility break. All legacy database files continue to be readable and writable by newer versions of SQLite, and all newly created database files continue to be readable and writable by legacy versions of the SQLite library. The only thing that is changing is some default settings. This should result in a performance increase for many applications.</source>
          <target state="translated">SQLite의 기본 동작에서 이러한 변경 사항은 호환성이 아닙니다. 모든 레거시 데이터베이스 파일은 최신 버전의 SQLite에서 계속 읽고 쓸 수 있으며 새로 작성된 모든 데이터베이스 파일은 레거시 버전의 SQLite 라이브러리에서 계속 읽고 쓸 수 있습니다. 변경되는 유일한 것은 일부 기본 설정입니다. 이로 인해 많은 응용 프로그램의 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="f8b6f19362cf61de4d3d35983b38ffd9c2bbd4d6" translate="yes" xml:space="preserve">
          <source>These constant define integer codes that represent the various text encodings supported by SQLite.</source>
          <target state="translated">이 상수는 SQLite가 지원하는 다양한 텍스트 인코딩을 나타내는 정수 코드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="28ee7781baba8510621fd94348e40d728944ee20" translate="yes" xml:space="preserve">
          <source>These constants are codes for each of those types.</source>
          <target state="translated">이 상수는 각 유형에 대한 코드입니다.</target>
        </trans-unit>
        <trans-unit id="5d678085fc410906abd9ecdf3f62895a2bdac8f9" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 에 의해 리턴되어 평가중인 SQL 문에 대한 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드가 무엇인지 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="8d5af3a6c05bd2fcca2c0f972b2fd66256957f31" translate="yes" xml:space="preserve">
          <source>These constants are returned by &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; to inform a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation what the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode is for the SQL statement being evaluated.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 에 의해 리턴되어 평가중인 SQL 문에 대한 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드가 무엇인지 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 에 알립니다 .</target>
        </trans-unit>
        <trans-unit id="e0814beadd7fffeacf97b8f77142e48bc418e590" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 &quot;verbs&quot;입니다 .</target>
        </trans-unit>
        <trans-unit id="ee8e50c4c247f1789de616c3122fcd5d75fef481" translate="yes" xml:space="preserve">
          <source>These constants are the available integer &quot;verbs&quot; that can be passed as the second argument to the &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 &quot;verbs&quot;입니다 .</target>
        </trans-unit>
        <trans-unit id="5685826d85b489c4a4722d59958f312636d778f9" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스에 첫 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="cb2ae78ea5b1ae2e5bfc176e2229bcc4eaa83a74" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the first argument to the &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스에 첫 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="b8b83f50bcee4d621ab3350b27ae006d83053d8d" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="bfdbb7c579979335802d5433a0c4351cc2e64138" translate="yes" xml:space="preserve">
          <source>These constants are the available integer configuration options that can be passed as the second argument to the &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스에 두 번째 인수로 전달할 수있는 사용 가능한 정수 구성 옵션입니다 .</target>
        </trans-unit>
        <trans-unit id="adcbc56bb51ca533b4d845770250da49d6cb92e5" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 의 첫 번째 인수로 사용 된 유효한 작업 코드 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="c9e83fda514b191357ca2f8a433c34a6a2561552" translate="yes" xml:space="preserve">
          <source>These constants are the valid operation code parameters used as the first argument to &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 의 첫 번째 인수로 사용 된 유효한 작업 코드 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="01b7633fac6735c207dc2ef793e2ed3c159bf015" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스에 세 번째 매개 변수로 전달 된 &quot;체크 포인트 모드&quot;에 유효한 모든 값을 정의합니다 . 이러한 각 검사 점 모드의 의미에 대한 자세한 내용은 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1096d3bfc46b56a1b04a8f3fad11f5e8e55e3e9f" translate="yes" xml:space="preserve">
          <source>These constants define all valid values for the &quot;checkpoint mode&quot; passed as the third parameter to the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface. See the &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for details on the meaning of each of these checkpoint modes.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스에 세 번째 매개 변수로 전달 된 &quot;체크 포인트 모드&quot;에 유효한 모든 값을 정의합니다 . 이러한 각 검사 점 모드의 의미에 대한 자세한 내용은 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f262688fc8aaf9f38b8c78556de1b6829b6de723" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 인터페이스 의 &quot;prepFlags&quot;매개 변수로 전달 될 수있는 다양한 플래그를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="52a7e652cd3193b904625b47cf5fc5b4007943d0" translate="yes" xml:space="preserve">
          <source>These constants define various flags that can be passed into &quot;prepFlags&quot; parameter of the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; 및 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 인터페이스 의 &quot;prepFlags&quot;매개 변수로 전달 될 수있는 다양한 플래그를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="f4779c39284f3e8f89de78b1cf22bb4300a2dde2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 런타임에 낮출 수있는 다양한 성능 한계를 정의 합니다. 다양한 한계의 의미에 대한 개요는 다음과 같습니다. 추가 정보는 &lt;a href=&quot;limits&quot;&gt;SQLite의 한계에서&lt;/a&gt; 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="dc33a9fdf99d3b7c3164b92212d61358e77ed2b2" translate="yes" xml:space="preserve">
          <source>These constants define various performance limits that can be lowered at run-time using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt;. The synopsis of the meanings of the various limits is shown below. Additional information is available at &lt;a href=&quot;../limits&quot;&gt;Limits in SQLite&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 런타임에 낮출 수있는 다양한 성능 한계를 정의 합니다. 다양한 한계의 의미에 대한 개요는 다음과 같습니다. 추가 정보는 &lt;a href=&quot;../limits&quot;&gt;SQLite의 한계에서&lt;/a&gt; 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="2d9ca50401c9fc616026596d32b3930da4b3846d" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 추적 논리를 사용하여 모니터링 할 수있는 이벤트 클래스를 식별 합니다. &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 (D, M, X, P)&lt;/a&gt; 에 대한 M 인수 는 다음 상수 중 하나 이상의 OR 조합입니다. 추적 콜백에 대한 첫 번째 인수는 다음 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ed407cdd4869216425bae7d051975b3bcd0fdc3b" translate="yes" xml:space="preserve">
          <source>These constants identify classes of events that can be monitored using the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; tracing logic. The M argument to &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2(D,M,X,P)&lt;/a&gt; is an OR-ed combination of one or more of the following constants. The first argument to the trace callback is one of the following constants.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 추적 논리를 사용하여 모니터링 할 수있는 이벤트 클래스를 식별 합니다. &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 (D, M, X, P)&lt;/a&gt; 에 대한 M 인수 는 다음 상수 중 하나 이상의 OR 조합입니다. 추적 콜백에 대한 첫 번째 인수는 다음 상수 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="14266cc61d0db9a630a6d1107d408c2e2d4959a8" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;#SQLITE_ANY&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function_v2 ()에&lt;/a&gt; 대한 네 번째 인수로 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;선호하는 텍스트 인코딩&lt;/a&gt; 과 함께 OR 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e4c2775c736d10a648ec5f64c5240681b8a597f" translate="yes" xml:space="preserve">
          <source>These constants may be ORed together with the &lt;a href=&quot;c_any&quot;&gt;preferred text encoding&lt;/a&gt; as the fourth argument to &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;, &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt;, or &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; , &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 또는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function_v2 ()에&lt;/a&gt; 대한 네 번째 인수로 &lt;a href=&quot;c_any&quot;&gt;선호하는 텍스트 인코딩&lt;/a&gt; 과 함께 OR 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d452c2a5987467cef42875b2093f98a07b801c06" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">이러한 함수 (통칭하여 &quot;함수 작성 루틴&quot;이라고 함)는 SQL 함수 또는 집계를 추가하거나 기존 SQL 함수 또는 집계의 동작을 재정의하는 데 사용됩니다. 세 가지 &quot;sqlite3_create_function *&quot;루틴의 유일한 차이점은 두 번째 매개 변수에 대해 예상되는 텍스트 인코딩 (작성중인 함수의 이름)과 애플리케이션 데이터 포인터에 대한 소멸자 콜백의 존재 여부입니다. sqlite3_create_window_function () 함수는 비슷하지만 사용자가 &lt;a href=&quot;../windowfunctions#aggwinfunc&quot;&gt;집계 창 함수에&lt;/a&gt; 필요한 추가 콜백 함수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="460bddf16e550adbe692fb026aea91fd5c1a8fa1" translate="yes" xml:space="preserve">
          <source>These functions (collectively known as &quot;function creation routines&quot;) are used to add SQL functions or aggregates or to redefine the behavior of existing SQL functions or aggregates. The only differences between the three &quot;sqlite3_create_function*&quot; routines are the text encoding expected for the second parameter (the name of the function being created) and the presence or absence of a destructor callback for the application data pointer. Function sqlite3_create_window_function() is similar, but allows the user to supply the extra callback functions needed by &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">이러한 함수 (통칭하여 &quot;함수 작성 루틴&quot;이라고 함)는 SQL 함수 또는 집계를 추가하거나 기존 SQL 함수 또는 집계의 동작을 재정의하는 데 사용됩니다. 세 가지 &quot;sqlite3_create_function *&quot;루틴의 유일한 차이점은 두 번째 매개 변수에 대해 예상되는 텍스트 인코딩 (작성중인 함수의 이름)과 애플리케이션 데이터 포인터에 대한 소멸자 콜백의 존재 여부입니다. sqlite3_create_window_function () 함수는 비슷하지만 사용자가 &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;집계 창 함수에&lt;/a&gt; 필요한 추가 콜백 함수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f5aa8ee7f5d5dcd17c7a255e21fd6564afc6f3cb" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;../datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">이 함수 는 첫 번째 인수로 지정된 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 관련된 &lt;a href=&quot;../datatype3#collation&quot;&gt;데이터 정렬을&lt;/a&gt; 추가, 제거 또는 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="ed63a5a7289985766e806cdca8d318ceb652f682" translate="yes" xml:space="preserve">
          <source>These functions add, remove, or modify a &lt;a href=&quot;datatype3#collation&quot;&gt;collation&lt;/a&gt; associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; specified as the first argument.</source>
          <target state="translated">이 함수 는 첫 번째 인수로 지정된 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 과 관련된 &lt;a href=&quot;datatype3#collation&quot;&gt;데이터 정렬을&lt;/a&gt; 추가, 제거 또는 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="e828096ae0ef377574b3a48a5e49c755665e8418" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;capi3ref&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; . 이전 코드와의 호환성을 유지하기 위해 이러한 기능은 계속 지원됩니다. 그러나 새 응용 프로그램에서는 이러한 기능을 사용하지 않아야합니다. 프로그래머가 이러한 기능을 피하도록 장려하기 위해 우리는 그 기능을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a53c5b52778acbd5177be1207d66b6e2855a89a9" translate="yes" xml:space="preserve">
          <source>These functions are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;. In order to maintain backwards compatibility with older code, these functions continue to be supported. However, new applications should avoid the use of these functions. To encourage programmers to avoid these functions, we will not explain what they do.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;experimental&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; . 이전 코드와의 호환성을 유지하기 위해 이러한 기능은 계속 지원됩니다. 그러나 새 응용 프로그램에서는 이러한 기능을 사용하지 않아야합니다. 프로그래머가 이러한 기능을 피하도록 장려하기 위해 우리는 그 기능을 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20e0d52fc906194ab3c598ecb16113bb7e27244d" translate="yes" xml:space="preserve">
          <source>These functions may be used by (non-aggregate) SQL functions to associate metadata with argument values. If the same value is passed to multiple invocations of the same SQL function during query execution, under some circumstances the associated metadata may be preserved. An example of where this might be useful is in a regular-expression matching function. The compiled version of the regular expression can be stored as metadata associated with the pattern string. Then as long as the pattern string remains the same, the compiled regular expression can be reused on multiple invocations of the same function.</source>
          <target state="translated">이러한 함수는 (비 집계) SQL 함수에서 메타 데이터를 인수 값과 연결하는 데 사용할 수 있습니다. 쿼리 실행 중 동일한 값이 동일한 SQL 함수의 여러 호출에 전달되면 일부 상황에서 관련 메타 데이터가 보존 될 수 있습니다. 이것이 유용한 곳의 예는 정규식 일치 함수입니다. 정규식의 컴파일 된 버전은 패턴 문자열과 연관된 메타 데이터로 저장 될 수 있습니다. 그런 다음 패턴 문자열이 동일하게 유지되는 한 컴파일 된 정규식을 동일한 함수의 여러 호출에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6522a9f48ff48fe82ed5d5982cbd1db9ee5c56d5" translate="yes" xml:space="preserve">
          <source>These functions only work for dates between 0000-01-01 00:00:00 and 9999-12-31 23:59:59 (julian day numbers 1721059.5 through 5373484.5). For dates outside that range, the results of these functions are undefined.</source>
          <target state="translated">이 함수는 0000-01-01 00:00:00과 9999-12-31 23:59:59 사이의 날짜에만 작동합니다 (줄리아 일수 1721059.5 ~ 5373484.5). 해당 범위를 벗어난 날짜의 경우 이러한 함수의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8d304d80363d45f2a701bb02157d9c038cae0f9" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">이러한 함수 는 준비된 명령문에서 값을 호스트 매개 변수에 바인드하는 데 사용되는 함수의 함수 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;바인딩&lt;/a&gt; 함수 와 매우 유사합니다 . 추가 정보 는 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b317ce2527b91fa298699867534154a11da36ac3" translate="yes" xml:space="preserve">
          <source>These functions work very much like the &lt;a href=&quot;bind_blob&quot;&gt;parameter binding&lt;/a&gt; family of functions used to bind values to host parameters in prepared statements. Refer to the &lt;a href=&quot;bind_blob&quot;&gt;SQL parameter&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">이러한 함수 는 준비된 명령문에서 값을 호스트 매개 변수에 바인드하는 데 사용되는 함수의 함수 &lt;a href=&quot;bind_blob&quot;&gt;바인딩&lt;/a&gt; 함수 와 매우 유사합니다 . 추가 정보 는 &lt;a href=&quot;bind_blob&quot;&gt;SQL 매개 변수&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab78522f9e6af4ebb0a819cdbba908125b1aa9de" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xFileControl 메소드 및 &lt;a href=&quot;#sqlite3_file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스의 opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="a38e815d9a81f8a36563593031ac86d208aff3ef" translate="yes" xml:space="preserve">
          <source>These integer constants are opcodes for the xFileControl method of the &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object and for the &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 의 xFileControl 메소드 및 &lt;a href=&quot;file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 인터페이스의 opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="ea60b84c9e9ef3033a276fcbd9184666b77d102f" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xAccess 메서드에 대한 세 번째 매개 변수로 사용할 수 있습니다 . 그들은 xAccess 메소드가 어떤 종류의 권한을 찾고 있는지 결정합니다. SQLITE_ACCESS_EXISTS를 사용하면 xAccess 메소드는 단순히 파일이 존재하는지 여부를 확인합니다. SQLITE_ACCESS_READWRITE를 사용하여 xAccess 메소드는 이름 지정된 디렉토리가 읽기 가능하고 쓰기 가능한지 여부를 확인합니다 (즉, 디렉토리 내에서 파일을 추가, 제거 및 이름을 바꿀 수있는 경우). SQLITE_ACCESS_READWRITE 상수는 현재 &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; 에서만 사용됩니다., 향후 SQLite 릴리스에서 변경 될 수 있습니다. SQLITE_ACCESS_READ를 사용하여 xAccess 메소드는 파일을 읽을 수 있는지 여부를 확인합니다. SQLITE_ACCESS_READ 상수는 현재 사용되지 않지만 향후 SQLite 릴리스에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311aa59e56c46be41f406ebc987fb4c56872151d" translate="yes" xml:space="preserve">
          <source>These integer constants can be used as the third parameter to the xAccess method of an &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. They determine what kind of permissions the xAccess method is looking for. With SQLITE_ACCESS_EXISTS, the xAccess method simply checks whether the file exists. With SQLITE_ACCESS_READWRITE, the xAccess method checks whether the named directory is both readable and writable (in other words, if files can be added, removed, and renamed within the directory). The SQLITE_ACCESS_READWRITE constant is currently used only by the &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt;, though this could change in a future release of SQLite. With SQLITE_ACCESS_READ, the xAccess method checks whether the file is readable. The SQLITE_ACCESS_READ constant is currently unused, though it might be used in a future release of SQLite.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xAccess 메서드에 대한 세 번째 매개 변수로 사용할 수 있습니다 . 그들은 xAccess 메소드가 어떤 종류의 권한을 찾고 있는지 결정합니다. SQLITE_ACCESS_EXISTS를 사용하면 xAccess 메소드는 단순히 파일이 존재하는지 여부를 확인합니다. SQLITE_ACCESS_READWRITE를 사용하여 xAccess 메소드는 이름 지정된 디렉토리가 읽기 가능하고 쓰기 가능한지 여부를 확인합니다 (즉, 디렉토리 내에서 파일을 추가, 제거 및 이름을 바꿀 수있는 경우). SQLITE_ACCESS_READWRITE 상수는 현재 &lt;a href=&quot;../pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory pragma&lt;/a&gt; 에서만 사용됩니다., 향후 SQLite 릴리스에서 변경 될 수 있습니다. SQLITE_ACCESS_READ를 사용하여 xAccess 메소드는 파일을 읽을 수 있는지 여부를 확인합니다. SQLITE_ACCESS_READ 상수는 현재 사용되지 않지만 향후 SQLite 릴리스에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e30f4610e846824046fcc55a5610ab368656db0" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드가 허용하는 다양한 잠금 조작을 정의합니다 . 다음은 xShmLock 메소드에 대한 플래그의 올바른 조합입니다.</target>
        </trans-unit>
        <trans-unit id="63c61207725308cbbebcd362e48d34bfbbce9eff" translate="yes" xml:space="preserve">
          <source>These integer constants define the various locking operations allowed by the xShmLock method of &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;. The following are the only legal combinations of flags to the xShmLock method:</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 의 xShmLock 메소드가 허용하는 다양한 잠금 조작을 정의합니다 . 다음은 xShmLock 메소드에 대한 플래그의 올바른 조합입니다.</target>
        </trans-unit>
        <trans-unit id="46be45c61b7407297842f2bf5d770d15053c4ac4" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()에&lt;/a&gt; 의해 리턴 될 수있는 다양한 런타임 상태 매개 변수를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="9d8a64fd442238eaa787788726abe76149b5cae0" translate="yes" xml:space="preserve">
          <source>These integer constants designate various run-time status parameters that can be returned by &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt;.</source>
          <target state="translated">이 정수 상수는 &lt;a href=&quot;status&quot;&gt;sqlite3_status ()에&lt;/a&gt; 의해 리턴 될 수있는 다양한 런타임 상태 매개 변수를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="1dd74d0b7bde7f62eaef94d29d31baa355fc24b9" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">이러한 인터페이스는 &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; 에서 이전에 얻은 sqlite3_str 객체에 내용을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="f4c68aa7a2ee53b8d7d01e966ec46bd4df66a0b8" translate="yes" xml:space="preserve">
          <source>These interfaces add content to an sqlite3_str object previously obtained from &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;.</source>
          <target state="translated">이러한 인터페이스는 &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt; 에서 이전에 얻은 sqlite3_str 객체에 내용을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="37d07c864bda5264afb416a4db651631968abf92" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">이 인터페이스는 Windows에서만 사용 가능합니다. &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스는 관련된 값으로 설정하는 데 사용되는 &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; type 매개 변수의 값에 따라 zValue하는 변수. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free&lt;/a&gt; 를 통해 이전 값을 해제하려면 zValue 매개 변수가 NULL이어야합니다 . NULL이 아닌 값은 사용하기 전에 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 복사 됩니다. &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; , 성공을 표시하는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 유형이 지원되지 않는 경우, 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;메모리를 할당 할 수없는 경우 &lt;a href=&quot;#sqlite3_data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 변수 의 값은 해당 개념이 존재하지 않는 Win32의 하위 플랫폼 (예 : WinRT 및 UWP)에서 현재 디렉토리를 대체하는 역할을합니다. &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; 문자열 파라미터 인터페이스 sqlite3_win32_set_directory 제외한 각각 UTF-8 또는 UTF-16가되어야하므로, 인터페이스 똑같은 동작.</target>
        </trans-unit>
        <trans-unit id="e3077cf84285d5d0c77e1603a1b1cc3c809c60d7" translate="yes" xml:space="preserve">
          <source>These interfaces are available only on Windows. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface is used to set the value associated with the &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; or &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable, to zValue, depending on the value of the type parameter. The zValue parameter should be NULL to cause the previous value to be freed via &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt;; a non-NULL value will be copied into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; prior to being used. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; to indicate success, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; if the type is unsupported, or &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt; if memory could not be allocated. The value of the &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; variable is intended to act as a replacement for the current directory on the sub-platforms of Win32 where that concept is not present, e.g. WinRT and UWP. The &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; and &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; interfaces behave exactly the same as the sqlite3_win32_set_directory interface except the string parameter must be UTF-8 or UTF-16, respectively.</source>
          <target state="translated">이 인터페이스는 Windows에서만 사용 가능합니다. &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스는 관련된 값으로 설정하는 데 사용되는 &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 또는 &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; type 매개 변수의 값에 따라 zValue하는 변수. &lt;a href=&quot;free&quot;&gt;sqlite3_free&lt;/a&gt; 를 통해 이전 값을 해제하려면 zValue 매개 변수가 NULL이어야합니다 . NULL이 아닌 값은 사용하기 전에 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc&lt;/a&gt; 에서 얻은 메모리에 복사 됩니다. &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스 반환 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; , 성공을 표시하는 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR를&lt;/a&gt; 유형이 지원되지 않는 경우, 또는 &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;메모리를 할당 할 수없는 경우 &lt;a href=&quot;data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 변수 의 값은 해당 개념이 존재하지 않는 Win32의 하위 플랫폼 (예 : WinRT 및 UWP)에서 현재 디렉토리를 대체하는 역할을합니다. &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory8&lt;/a&gt; 및 &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory16&lt;/a&gt; 문자열 파라미터 인터페이스 sqlite3_win32_set_directory 제외한 각각 UTF-8 또는 UTF-16가되어야하므로, 인터페이스 똑같은 동작.</target>
        </trans-unit>
        <trans-unit id="bf73a94780de490a8f9c02eb38be04e9aad9c703" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">이러한 인터페이스는 SQLite가 &lt;a href=&quot;../compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; 컴파일 시간 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="2573d74316b2beb50fe8b93933b238b687b3e25f" translate="yes" xml:space="preserve">
          <source>These interfaces are only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; compile-time option.</source>
          <target state="translated">이러한 인터페이스는 SQLite가 &lt;a href=&quot;compile#enable_preupdate_hook&quot;&gt;SQLITE_ENABLE_PREUPDATE_HOOK&lt;/a&gt; 컴파일 시간 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="1dfbcb8f183f59b84e1cdc3c799c0026a4da7b1c" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">이 인터페이스는 SQLite의 성능에 대한 런타임 상태 정보를 검색하고 선택적으로 다양한 상한 표시를 재설정하는 데 사용됩니다. 첫 번째 인수는 측정 할 특정 매개 변수의 정수 코드입니다. 인식되는 정수 코드는 &lt;a href=&quot;#SQLITE_STATUS_MALLOC_COUNT&quot;&gt;SQLITE_STATUS _...&lt;/a&gt; 형식 입니다. 매개 변수의 현재 값은 * pCurrent로 리턴됩니다. 기록 된 최고 값은 * pHighwater로 리턴됩니다. resetFlag가 true이면 * pHighwater가 기록 된 후 가장 높은 레코드 값이 재설정됩니다. 일부 매개 변수는 가장 높은 값을 기록하지 않습니다. 이러한 매개 변수의 경우 * pHighwater에 아무것도 기록되지 않으며 resetFlag는 무시됩니다. 다른 매개 변수는 현재 값이 아닌 최고 사용 표시 점 만 기록합니다. 후자의 매개 변수의 경우 * pCurrent에 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a006bb7b78680fec3ca85a8c33bf946ae2c290a" translate="yes" xml:space="preserve">
          <source>These interfaces are used to retrieve runtime status information about the performance of SQLite, and optionally to reset various highwater marks. The first argument is an integer code for the specific parameter to measure. Recognized integer codes are of the form &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS_...&lt;/a&gt;. The current value of the parameter is returned into *pCurrent. The highest recorded value is returned in *pHighwater. If the resetFlag is true, then the highest record value is reset after *pHighwater is written. Some parameters do not record the highest value. For those parameters nothing is written into *pHighwater and the resetFlag is ignored. Other parameters record only the highwater mark and not the current value. For these latter parameters nothing is written into *pCurrent.</source>
          <target state="translated">이 인터페이스는 SQLite의 성능에 대한 런타임 상태 정보를 검색하고 선택적으로 다양한 상한 표시를 재설정하는 데 사용됩니다. 첫 번째 인수는 측정 할 특정 매개 변수의 정수 코드입니다. 인식되는 정수 코드는 &lt;a href=&quot;c_status_malloc_count&quot;&gt;SQLITE_STATUS _...&lt;/a&gt; 형식 입니다. 매개 변수의 현재 값은 * pCurrent로 리턴됩니다. 기록 된 최고 값은 * pHighwater로 리턴됩니다. resetFlag가 true이면 * pHighwater가 기록 된 후 가장 높은 레코드 값이 재설정됩니다. 일부 매개 변수는 가장 높은 값을 기록하지 않습니다. 이러한 매개 변수의 경우 * pHighwater에 아무것도 기록되지 않으며 resetFlag는 무시됩니다. 다른 매개 변수는 현재 값이 아닌 최고 사용 표시 점 만 기록합니다. 후자의 매개 변수의 경우 * pCurrent에 아무것도 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a26bb8a6cfb99470baf86e2f9ba8d8fe1ec3d04" translate="yes" xml:space="preserve">
          <source>These interfaces can be used by an application to monitor how much memory SQLite is using. The &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used()&lt;/a&gt; routine returns the number of bytes of memory currently in use and the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; returns the maximum instantaneous memory usage. Neither routine includes the overhead associated with the memory allocator. These routines are provided for use by the application. SQLite never invokes them itself. So if the application is providing its own memory allocation subsystem, it can omit these interfaces if desired.</source>
          <target state="translated">이러한 인터페이스는 응용 프로그램에서 SQLite가 사용중인 메모리 양을 모니터링하는 데 사용할 수 있습니다. &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_used ()&lt;/a&gt; 으로 돌아 간다 현재 사용중인 메모리의 바이트 수와 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 최대 순간 메모리 사용을 반환합니다. 어느 루틴도 메모리 할당 자와 관련된 오버 헤드를 포함하지 않습니다. 이 루틴은 응용 프로그램에서 사용하기 위해 제공됩니다. SQLite는 결코 그들 자신을 호출하지 않습니다. 따라서 애플리케이션이 자체 메모리 할당 서브 시스템을 제공하는 경우 원하는 경우 이러한 인터페이스를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6bfb4cf13a4a1ec7a21d1345619d3a829697d4" translate="yes" xml:space="preserve">
          <source>These interfaces impose limits on the amount of heap memory that will be by all database connections within a single process.</source>
          <target state="translated">이러한 인터페이스는 단일 프로세스 내의 모든 데이터베이스 연결에 사용되는 힙 메모리 양을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="5d867180f3b3d1ed5572faf6a624799c6449d787" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">이 인터페이스는 같은 정보를 제공 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION&lt;/a&gt; , &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_VERSION_NUMBER을&lt;/a&gt; 하고 &lt;a href=&quot;#SQLITE_SOURCE_ID&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전처리 매크로하지만 라이브러리 대신 헤더 파일과 연결되어 있습니다. 신중한 프로그래머는 응용 프로그램에 assert () 문을 포함하여 이러한 인터페이스에서 반환 된 값이 헤더의 매크로와 일치하는지 확인하여 응용 프로그램이 일치하는 라이브러리 및 헤더 파일로 컴파일되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e7f85933d01fbbc2719e5dc64309e8e175f6d5d" translate="yes" xml:space="preserve">
          <source>These interfaces provide the same information as the &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt;, &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER&lt;/a&gt;, and &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C preprocessor macros but are associated with the library instead of the header file. Cautious programmers might include assert() statements in their application to verify that values returned by these interfaces match the macros in the header, and thus ensure that the application is compiled with matching library and header files.</source>
          <target state="translated">이 인터페이스는 같은 정보를 제공 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION&lt;/a&gt; , &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_VERSION_NUMBER을&lt;/a&gt; 하고 &lt;a href=&quot;c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; C 전처리 매크로하지만 라이브러리 대신 헤더 파일과 연결되어 있습니다. 신중한 프로그래머는 응용 프로그램에 assert () 문을 포함하여 이러한 인터페이스에서 반환 된 값이 헤더의 매크로와 일치하는지 확인하여 응용 프로그램이 일치하는 라이브러리 및 헤더 파일로 컴파일되었는지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f3967be8dcb65457d2a35a639ddbcd4e8748853" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 의 현재 상태를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9f4d86f27a761f3cf1b6a9d1b51464453bd7acc2" translate="yes" xml:space="preserve">
          <source>These interfaces return the current status of an &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 객체 의 현재 상태를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="edf2097b32647c30069fed117ef937baf26e2654" translate="yes" xml:space="preserve">
          <source>These interfces are provided for use by &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations and are not useful outside of that context.</source>
          <target state="translated">이러한 interfces는 &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; 구현 에서 사용하기 위해 제공되며 해당 컨텍스트 외부에서는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1a8d7ae768abbd8bdb6f16b4e0e326ba78812f7" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">이 매크로는 Windows에서만 사용할 수 있습니다. 형식 인수에 허용되는 값을 &lt;a href=&quot;#sqlite3_win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스에 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a687dbdbbc158f7b1d8247c45af66df0ad45cf41" translate="yes" xml:space="preserve">
          <source>These macros are only available on Windows. They define the allowed values for the type argument to the &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; interface.</source>
          <target state="translated">이 매크로는 Windows에서만 사용할 수 있습니다. 형식 인수에 허용되는 값을 &lt;a href=&quot;win32_set_directory&quot;&gt;sqlite3_win32_set_directory&lt;/a&gt; 인터페이스에 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="a53b463320023e1da4e50fb5fb587f4bc7e0b044" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이러한 매크로는 &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의합니다 . 각 값은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에있는 제약 조건의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="285af12f9b73f8c383619a138a0750effc7e59e8" translate="yes" xml:space="preserve">
          <source>These macros define the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이러한 매크로는 &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의합니다 . 각 값은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에있는 제약 조건의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8efdced9c4da4c580aa62b3a5a3c4685a1b1ed67" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">이 매크로 는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현이 동작을 사용자 정의하고 최적화하는 데 사용할 수 있는 &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; 인터페이스에 대한 다양한 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="648697ac8bc614b007ee6a86dba8449e42be0af2" translate="yes" xml:space="preserve">
          <source>These macros define the various options to the &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface that &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementations can use to customize and optimize their behavior.</source>
          <target state="translated">이 매크로 는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현이 동작을 사용자 정의하고 최적화하는 데 사용할 수 있는 &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; 인터페이스에 대한 다양한 옵션을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="e2c086e3788cfb99a6897d54171eed03d73b01e8" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의했습니다 . 각 값은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에서 제약 조건 용어의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="fa39882fd7522d6ac624eca8d9d3a80dde9e04fa" translate="yes" xml:space="preserve">
          <source>These macros defined the allowed values for the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.aConstraint[].op field. Each value represents an operator that is part of a constraint term in the wHERE clause of a query that uses a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 매크로는 &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .aConstraint []. op 필드에 허용되는 값을 정의했습니다 . 각 값은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용하는 쿼리의 wHERE 절에서 제약 조건 용어의 일부인 연산자를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cef481ad6fa7db18e075879f04ed74ee515d6f8c" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 결과 코드를 리턴하지 않습니다. 오류가 발생하면 해당 사실은 &lt;a href=&quot;#sqlite3_str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 기록되며 후속 &lt;a href=&quot;#sqlite3_str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 호출로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf9638bb05ccc82e92352f4c91e50e88181ed764" translate="yes" xml:space="preserve">
          <source>These methods do not return a result code. If an error occurs, that fact is recorded in the &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; object and can be recovered by a subsequent call to &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode(X)&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 결과 코드를 리턴하지 않습니다. 오류가 발생하면 해당 사실은 &lt;a href=&quot;str&quot;&gt;sqlite3_str&lt;/a&gt; 오브젝트에 기록되며 후속 &lt;a href=&quot;str_errcode&quot;&gt;sqlite3_str_errcode (X)&lt;/a&gt; 호출로 복구 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8abab119f90d9828a9a200b591657ce6dda56d7" translate="yes" xml:space="preserve">
          <source>These methods provide the virtual table implementation an opportunity to implement nested transactions. They are always optional and will only be called in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23) and later.</source>
          <target state="translated">이러한 메소드는 가상 테이블 구현에 중첩 트랜잭션을 구현할 수있는 기회를 제공합니다. 이들은 항상 선택적이며 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;버전 3.7.7&lt;/a&gt; (2011-06-23) 이상 에서만 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="46bde550196023cbdbd528e902d936fa4e39c988" translate="yes" xml:space="preserve">
          <source>These operations are described in detail in section</source>
          <target state="translated">이러한 작업은 섹션에 자세히 설명되어 있습니다</target>
        </trans-unit>
        <trans-unit id="8a581a47ac4eaa711b3f420b4ba4930e1f71a44b" translate="yes" xml:space="preserve">
          <source>These options are obsolete and should not be used by new code. They are retained for backwards compatibility but are now no-ops.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않으며 새 코드에서 사용해서는 안됩니다. 이전 버전과의 호환성을 위해 유지되지만 이제는 운영 체제가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="559388a0d9af9b6cbe52d397cd3542b5b1c78fdd" translate="yes" xml:space="preserve">
          <source>These pages are intended to be precise and detailed specification. For a tutorial introduction, see instead:</source>
          <target state="translated">이 페이지는 정확하고 자세한 사양으로 작성되었습니다. 튜토리얼 소개는 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6abb0e63f8d45e8d38ed1d32dbd7bc6804598807" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">이러한 매개 변수 및 의미는 예고없이 변경 될 수 있습니다. 이 값은 테스트 목적으로 만 사용됩니다. 응용 프로그램은 이러한 매개 변수 또는 &lt;a href=&quot;#sqlite3_test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 인터페이스를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="572f36fd8fcb5b2b9a0c163c10706d2d9c69fa95" translate="yes" xml:space="preserve">
          <source>These parameters and their meanings are subject to change without notice. These values are for testing purposes only. Applications should not use any of these parameters or the &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt; interface.</source>
          <target state="translated">이러한 매개 변수 및 의미는 예고없이 변경 될 수 있습니다. 이 값은 테스트 목적으로 만 사용됩니다. 응용 프로그램은 이러한 매개 변수 또는 &lt;a href=&quot;test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 인터페이스를 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="f8a0b86303fc051c5fd0870031ccb3460d4da0f7" translate="yes" xml:space="preserve">
          <source>These pragmas are only available in builds using non-standard compile-time options.</source>
          <target state="translated">이 pragma는 비표준 컴파일 시간 옵션을 사용하는 빌드에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d1b3b12b0e1a81b824764e591a7c4f5ca02302c" translate="yes" xml:space="preserve">
          <source>These pragmas are used for testing SQLite and are not recommended for use in application programs.</source>
          <target state="translated">이 pragma는 SQLite 테스트에 사용되며 응용 프로그램에서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="995493d489d94b8be4b015e9bc63ccee86968693" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">이러한 전 처리기 매크로는 &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스 와 관련된 카운터 값의 이름을 지정하는 정수 코드를 정의합니다 . 다양한 카운터의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45f1f746bd34bc0ce563d83def09a125c5bf05c1" translate="yes" xml:space="preserve">
          <source>These preprocessor macros define integer codes that name counter values associated with the &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface. The meanings of the various counters are as follows:</source>
          <target state="translated">이러한 전 처리기 매크로는 &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스 와 관련된 카운터 값의 이름을 지정하는 정수 코드를 정의합니다 . 다양한 카운터의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c705c2e0cd7b6320d8503e4412e5e99c6ba613d2" translate="yes" xml:space="preserve">
          <source>These routines are available to &lt;a href=&quot;vfs&quot;&gt;custom VFS implementations&lt;/a&gt; for translating filenames between the main database file, the journal file, and the WAL file.</source>
          <target state="translated">이러한 루틴은 기본 데이터베이스 파일, 저널 파일 및 WAL 파일 간의 파일 이름을 변환 &lt;a href=&quot;vfs&quot;&gt;하기&lt;/a&gt; 위해 사용자 지정 VFS 구현 에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2638c6822db8d54f4bd5ddffbdd3a5cd063ac265" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">이 루틴은 더 이상 사용되지 않습니다. 사용 &lt;a href=&quot;#sqlite3_trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 루틴은 여기에 설명 대신 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="79eec12a37e6ba999a536376578f3d7f9c0f472e" translate="yes" xml:space="preserve">
          <source>These routines are deprecated. Use the &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt; interface instead of the routines described here.</source>
          <target state="translated">이 루틴은 더 이상 사용되지 않습니다. 사용 &lt;a href=&quot;trace_v2&quot;&gt;sqlite3_trace_v2 ()&lt;/a&gt; 루틴은 여기에 설명 대신 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="88da5c4ccf3f13c2b355a0a8cea0eee5123dacc4" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">이 루틴은 SQL 함수 및 집계를 구현하는 xFunc 또는 xFinal 콜백에서 사용됩니다. 추가 정보는 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ac11b77df30733555a1b785ff3b36747aa22425" translate="yes" xml:space="preserve">
          <source>These routines are used by the xFunc or xFinal callbacks that implement SQL functions and aggregates. See &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16()&lt;/a&gt; for additional information.</source>
          <target state="translated">이 루틴은 SQL 함수 및 집계를 구현하는 xFunc 또는 xFinal 콜백에서 사용됩니다. 추가 정보는 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 &lt;a href=&quot;create_function&quot;&gt;sqlite3_create_function16 ()&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a645fc58a9b80b5d58439099cf576c18383cf676" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">이 루틴은 새로운 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 이름 을 등록하는 데 사용됩니다 . 모듈을 사용하여 새 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 작성하기 전에 그리고 모듈에 대해 기존 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용 하기 전에 모듈 이름을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="947d0c2cba6cd0b29a7af62bdccba7526d0c92de" translate="yes" xml:space="preserve">
          <source>These routines are used to register a new &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt; name. Module names must be registered before creating a new &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; using the module and before using a preexisting &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; for the module.</source>
          <target state="translated">이 루틴은 새로운 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 이름 을 등록하는 데 사용됩니다 . 모듈을 사용하여 새 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 작성하기 전에 그리고 모듈에 대해 기존 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 사용 하기 전에 모듈 이름을 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="52698fd9d4ddf179ee30cea3431e78d27c345761" translate="yes" xml:space="preserve">
          <source>These routines are useful during command-line input to determine if the currently entered text seems to form a complete SQL statement or if additional input is needed before sending the text into SQLite for parsing. These routines return 1 if the input string appears to be a complete SQL statement. A statement is judged to be complete if it ends with a semicolon token and is not a prefix of a well-formed CREATE TRIGGER statement. Semicolons that are embedded within string literals or quoted identifier names or comments are not independent tokens (they are part of the token in which they are embedded) and thus do not count as a statement terminator. Whitespace and comments that follow the final semicolon are ignored.</source>
          <target state="translated">이 루틴은 명령 행 입력 중에 현재 입력 한 텍스트가 완전한 SQL 문을 형성하는 것으로 보이는지 또는 구문 분석을 위해 텍스트를 SQLite로 보내기 전에 추가 입력이 필요한지 판별하는 데 유용합니다. 입력 문자열이 완전한 SQL 문인 경우이 루틴은 1을 리턴합니다. 명령문은 세미콜론 토큰으로 끝나고 올바르게 구성된 CREATE TRIGGER 문의 접 두부가 아닌 경우 완료된 것으로 판단됩니다. 문자열 리터럴 또는 인용 된 식별자 이름 또는 주석 내에 포함 된 세미콜론은 독립적 인 토큰이 아니며 (포함 된 토큰의 일부 임) 명령문 종결 자로 계산되지 않습니다. 마지막 세미콜론 뒤에 나오는 공백과 주석은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1eee207918e3686e6a6a0aff77d6f8f4cd324299" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;../printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;../printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;../printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;../printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">이러한 루틴은 표준 C 라이브러리의 &quot;printf ()&quot;함수 제품군과 유사합니다. 이 루틴은 표준 라이브러리 printf () 및 일부 비표준 형식 ( &lt;a href=&quot;../printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;../printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;../printf#percentw&quot;&gt;% w&lt;/a&gt; 및 &lt;a href=&quot;../printf#percentz&quot;&gt;% z&lt;/a&gt; ) 의 일반적인 형식 옵션 대부분을 이해 합니다. 자세한 내용은 &lt;a href=&quot;../printf&quot;&gt;내장 printf ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d6ce4df9ede9c6a9b8604117d8eeec42326da1e" translate="yes" xml:space="preserve">
          <source>These routines are work-alikes of the &quot;printf()&quot; family of functions from the standard C library. These routines understand most of the common formatting options from the standard library printf() plus some additional non-standard formats (&lt;a href=&quot;printf#percentq&quot;&gt;%q&lt;/a&gt;, &lt;a href=&quot;printf#percentq&quot;&gt;%Q&lt;/a&gt;, &lt;a href=&quot;printf#percentw&quot;&gt;%w&lt;/a&gt;, and &lt;a href=&quot;printf#percentz&quot;&gt;%z&lt;/a&gt;). See the &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt; documentation for details.</source>
          <target state="translated">이러한 루틴은 표준 C 라이브러리의 &quot;printf ()&quot;함수 제품군과 유사합니다. 이 루틴은 표준 라이브러리 printf () 및 일부 비표준 형식 ( &lt;a href=&quot;printf#percentq&quot;&gt;% q&lt;/a&gt; , &lt;a href=&quot;printf#percentq&quot;&gt;% Q&lt;/a&gt; , &lt;a href=&quot;printf#percentw&quot;&gt;% w&lt;/a&gt; 및 &lt;a href=&quot;printf#percentz&quot;&gt;% z&lt;/a&gt; ) 의 일반적인 형식 옵션 대부분을 이해 합니다. 자세한 내용은 &lt;a href=&quot;printf&quot;&gt;내장 printf ()&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d695b797410a06f75931294f55b67ec9c439fcc7" translate="yes" xml:space="preserve">
          <source>These routines do not parse the SQL statements thus will not detect syntactically incorrect SQL.</source>
          <target state="translated">이 루틴은 SQL 문을 구문 분석하지 않으므로 구문 상 올바르지 않은 SQL을 감지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7531da5fcda9441742ab989cffc3d5a7ea0da49d" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서 유형, 크기 및 컨텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 오브젝트는 매개 변수 정보를 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;vtab&quot;&gt;가상 테이블의&lt;/a&gt; 구현으로 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="780ed181ddbb53bd0cd75f887c1efe5a712dae77" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 개체 에서 유형, 크기 및 콘텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 객체는 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 구현하는 함수로 매개 변수 정보를 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c79baca34267204233cef0f72fa563f702ea3b9b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into implementation of &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서 유형, 크기 및 컨텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 오브젝트는 매개 변수 정보를 &lt;a href=&quot;create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블의&lt;/a&gt; 구현으로 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="080e4929a8edf88eab58f3131b66975c555d313b" translate="yes" xml:space="preserve">
          <source>These routines extract type, size, and content information from &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Protected sqlite3_value objects are used to pass parameter information into the functions that implement &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; and &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 개체 에서 유형, 크기 및 콘텐츠 정보를 추출 합니다. 보호 된 sqlite3_value 객체는 &lt;a href=&quot;../appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 및 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 을 구현하는 함수로 매개 변수 정보를 전달하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b6356562f1a7ea967d47e4aa35dbd596cfeb17ce" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;sqlite3_value *&lt;/a&gt; 매개 변수 를 제공 한 SQL 함수와 동일한 스레드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea74f3659cddc5ce0c6b4fa5c6b8b6ea6fcf9692" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread as the SQL function that supplied the &lt;a href=&quot;value&quot;&gt;sqlite3_value*&lt;/a&gt; parameters.</source>
          <target state="translated">이러한 루틴은 &lt;a href=&quot;value&quot;&gt;sqlite3_value *&lt;/a&gt; 매개 변수 를 제공 한 SQL 함수와 동일한 스레드에서 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a54537ed3c843a1d7c75c98c519dd12715dd5904" translate="yes" xml:space="preserve">
          <source>These routines must be called from the same thread in which the SQL function is running.</source>
          <target state="translated">이 루틴은 SQL 함수가 실행중인 동일한 스레드에서 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="aea4f6b4200dc559c39531008b13c73c4dca39ea" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">이 루틴은 filename 인수로 지정된대로 SQLite 데이터베이스 파일을 엽니 다. filename 인수는 sqlite3_open () 및 sqlite3_open_v2 ()의 경우 UTF-8로, sqlite3_open16 ()의 기본 바이트 순서에서 UTF-16으로 해석됩니다. &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들은 일반적으로 오류가 발생하는 경우에도 * ppDb에 반환됩니다. 유일한 예외는 SQLite는이 개최 메모리를 할당 할 수없는 경우이다 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체를하는 NULL은 포인터 대신 * ppDb에 기록 될 것입니다 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체입니다. 데이터베이스가 성공적으로 열리거나 작성되면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴됩니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다. &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt;루틴은 sqlite3_open () 루틴이 실패한 후 오류에 대한 영어 설명을 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24814302ce83d408ddc70164757005571a98a1af" translate="yes" xml:space="preserve">
          <source>These routines open an SQLite database file as specified by the filename argument. The filename argument is interpreted as UTF-8 for sqlite3_open() and sqlite3_open_v2() and as UTF-16 in the native byte order for sqlite3_open16(). A &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle is usually returned in *ppDb, even if an error occurs. The only exception is that if SQLite is unable to allocate memory to hold the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object, a NULL will be written into *ppDb instead of a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object. If the database is opened (and/or created) successfully, then &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned. The &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; or &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16()&lt;/a&gt; routines can be used to obtain an English language description of the error following a failure of any of the sqlite3_open() routines.</source>
          <target state="translated">이 루틴은 filename 인수로 지정된대로 SQLite 데이터베이스 파일을 엽니 다. filename 인수는 sqlite3_open () 및 sqlite3_open_v2 ()의 경우 UTF-8로, sqlite3_open16 ()의 기본 바이트 순서에서 UTF-16으로 해석됩니다. &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들은 일반적으로 오류가 발생하는 경우에도 * ppDb에 반환됩니다. 유일한 예외는 SQLite는이 개최 메모리를 할당 할 수없는 경우이다 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체를하는 NULL은 포인터 대신 * ppDb에 기록 될 것입니다 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를의&lt;/a&gt; 객체입니다. 데이터베이스가 성공적으로 열리거나 작성되면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴됩니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다. &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 또는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg16 ()&lt;/a&gt;루틴은 sqlite3_open () 루틴이 실패한 후 오류에 대한 영어 설명을 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb0a6ed5fd628702f759fa88fc57a08522ef219" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문 에서 특정 결과 컬럼의 원점 인 데이터베이스, 테이블 및 테이블 컬럼을 판별하는 수단을 제공합니다 . 데이터베이스 또는 테이블 또는 열의 이름은 UTF-8 또는 UTF-16 문자열로 리턴 될 수 있습니다. _database_ 루틴은 데이터베이스 이름을 리턴하고 _table_ 루틴은 테이블 이름을 리턴하며 origin_ 루틴은 컬럼 이름을 리턴합니다. 리턴 된 문자열은 &lt;a href=&quot;finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 삭제 될 때까지 또는 특정 실행에 대한 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 동일한 정보가 다른 인코딩으로 다시 요청 될 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="6747cec9622a96ae1091ed2adc2461d962bf2710" translate="yes" xml:space="preserve">
          <source>These routines provide a means to determine the database, table, and table column that is the origin of a particular result column in &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The name of the database or table or column can be returned as either a UTF-8 or UTF-16 string. The _database_ routines return the database name, the _table_ routines return the table name, and the origin_ routines return the column name. The returned string is valid until the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; is destroyed using &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; or until the statement is automatically reprepared by the first call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; for a particular run or until the same information is requested again in a different encoding.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문 에서 특정 결과 컬럼의 원점 인 데이터베이스, 테이블 및 테이블 컬럼을 판별하는 수단을 제공합니다 . 데이터베이스 또는 테이블 또는 열의 이름은 UTF-8 또는 UTF-16 문자열로 리턴 될 수 있습니다. _database_ 루틴은 데이터베이스 이름을 리턴하고 _table_ 루틴은 테이블 이름을 리턴하며 origin_ 루틴은 컬럼 이름을 리턴합니다. 리턴 된 문자열은 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;sqlite3_finalize ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 삭제 될 때까지 또는 특정 실행에 대한 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 첫 번째 호출에 의해 명령문이 자동으로 다시 준비 될 때까지 또는 동일한 정보가 다른 인코딩으로 다시 요청 될 때까지 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="723ec7b5764e01bb470a171ac81db6f1bccacf01" translate="yes" xml:space="preserve">
          <source>These routines provide access to the set of SQL language keywords recognized by SQLite. Applications can uses these routines to determine whether or not a specific identifier needs to be escaped (for example, by enclosing in double-quotes) so as not to confuse the parser.</source>
          <target state="translated">이 루틴은 SQLite가 인식하는 SQL 언어 키워드 세트에 대한 액세스를 제공합니다. 응용 프로그램은 이러한 루틴을 사용하여 구문 분석기를 혼동하지 않도록 특정 식별자를 이스케이프해야하는지 여부를 결정합니다 (예 : 큰 따옴표로 묶음).</target>
        </trans-unit>
        <trans-unit id="c63151a5ae56c785b897a0325e0c6f8aa37ea7fb" translate="yes" xml:space="preserve">
          <source>These routines provide direct access to the version of the Wagner edit-distance function that allows for application-defined weights on edit operations. The first two forms of this function compare pattern P against word W and return the edit distance. In the first function, the langid is assumed to be 0 and in the second, the langid is given by the L parameter. The third form of this function reloads edit distance coefficients from the table named by T.</source>
          <target state="translated">이 루틴을 통해 Wagner Edit-Distance 기능 버전에 직접 액세스 할 수있어 편집 작업시 애플리케이션 정의 가중치를 사용할 수 있습니다. 이 함수의 처음 두 형태는 패턴 P를 단어 W와 비교하고 편집 거리를 반환합니다. 첫 번째 함수에서 langid는 0으로 가정하고 두 번째 함수에서는 langid가 L 매개 변수로 제공됩니다. 이 함수의 세 번째 형식은 T로 명명 ​​된 테이블에서 편집 거리 계수를 다시로드합니다.</target>
        </trans-unit>
        <trans-unit id="6ece6463ac2989d7eff64fecae9f2305cb234cc2" translate="yes" xml:space="preserve">
          <source>These routines register callback functions that can be used for tracing and profiling the execution of SQL statements.</source>
          <target state="translated">이 루틴은 SQL 문 실행 추적 및 프로파일 링에 사용할 수있는 콜백 함수를 등록합니다.</target>
        </trans-unit>
        <trans-unit id="40a118423314c412a0ead5a2681ebf518ed77f67" translate="yes" xml:space="preserve">
          <source>These routines return 0 if the statement is incomplete. If a memory allocation fails, then SQLITE_NOMEM is returned.</source>
          <target state="translated">명령문이 완료되지 않으면이 루틴은 0을 리턴합니다. 메모리 할당이 실패하면 SQLITE_NOMEM이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="324c17666cfb5119bcfea9a10a94bbaee6b00643" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 조회의 현재 결과 행의 단일 열에 대한 정보를 리턴합니다. 모든 경우에 첫 번째 인수는 평가중인 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; ( &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 해당 변형 중 하나 에서 리턴 된 sqlite3_stmt &lt;a href=&quot;#sqlite3_stmt&quot;&gt;*&lt;/a&gt; )에 대한 포인터 이고 두 번째 인수는 정보를 리턴 할 열의 색인입니다. . 결과 집합의 가장 왼쪽 열에는 인덱스 0이 있습니다. 결과의 열 수는 &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count ()를&lt;/a&gt; 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5435456a1f2380e65f87b371b45464ea838877ae" translate="yes" xml:space="preserve">
          <source>These routines return information about a single column of the current result row of a query. In every case the first argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that is being evaluated (the &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; that was returned from &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or one of its variants) and the second argument is the index of the column for which information should be returned. The leftmost column of the result set has the index 0. The number of columns in the result can be determined using &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 조회의 현재 결과 행의 단일 열에 대한 정보를 리턴합니다. 모든 경우에 첫 번째 인수는 평가중인 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; ( &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 해당 변형 중 하나 에서 리턴 된 sqlite3_stmt &lt;a href=&quot;stmt&quot;&gt;*&lt;/a&gt; )에 대한 포인터 이고 두 번째 인수는 정보를 리턴 할 열의 색인입니다. . 결과 집합의 가장 왼쪽 열에는 인덱스 0이 있습니다. 결과의 열 수는 &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count ()를&lt;/a&gt; 사용하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86c424b8734fe7ddecb01d35115c043c61c06f29" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 세트에서 특정 열에 지정된 이름을 리턴합니다 . sqlite3_column_name () 인터페이스는 0으로 끝나는 UTF-8 문자열에 대한 포인터를 반환하고 sqlite3_column_name16 ()은 0으로 끝나는 UTF-16 문자열에 대한 포인터를 반환합니다. 첫 번째 매개 변수는 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문 을 구현하는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 입니다 . 두 번째 매개 변수는 열 번호입니다. 가장 왼쪽 열은 숫자 0입니다.</target>
        </trans-unit>
        <trans-unit id="c92c0a5a51a4b6415e4465e481831e591f5adbb3" translate="yes" xml:space="preserve">
          <source>These routines return the name assigned to a particular column in the result set of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The sqlite3_column_name() interface returns a pointer to a zero-terminated UTF-8 string and sqlite3_column_name16() returns a pointer to a zero-terminated UTF-16 string. The first parameter is the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; that implements the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement. The second parameter is the column number. The leftmost column is number 0.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 세트에서 특정 열에 지정된 이름을 리턴합니다 . sqlite3_column_name () 인터페이스는 0으로 끝나는 UTF-8 문자열에 대한 포인터를 반환하고 sqlite3_column_name16 ()은 0으로 끝나는 UTF-16 문자열에 대한 포인터를 반환합니다. 첫 번째 매개 변수는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문 을 구현하는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 입니다 . 두 번째 매개 변수는 열 번호입니다. 가장 왼쪽 열은 숫자 0입니다.</target>
        </trans-unit>
        <trans-unit id="5de2bfd9e6d919b373b4c3d1b80a7310909f2955" translate="yes" xml:space="preserve">
          <source>These routines should return true if the mutex in their argument is held or not held, respectively, by the calling thread.</source>
          <target state="translated">이 루틴은 인수의 뮤텍스가 호출 스레드에 의해 각각 보유 또는 보유되지 않은 경우 true를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="afa365b8dc52497e4284392ecbb9654dff91e29b" translate="yes" xml:space="preserve">
          <source>These routines throw an error if the first JSON argument is not well-formed or if any PATH argument is not well-formed or if any argument is a BLOB.</source>
          <target state="translated">이러한 루틴은 첫 번째 JSON 인수의 형식이 올바르지 않거나 PATH 인수의 형식이 올바르지 않거나 인수가 BLOB 인 경우 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="040db3ed336324c99d540be07030ca6b73dfe1d9" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">이러한 루틴 은 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 포인터 및 정수 열 번호 대신 단일 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 오브젝트 포인터를 사용 한다는 점을 제외하고 해당 &lt;a href=&quot;#sqlite3_column_blob&quot;&gt;열 액세스 기능과&lt;/a&gt; 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="8f8d6c3e862ca519958d58c8125484847b89c711" translate="yes" xml:space="preserve">
          <source>These routines work just like the corresponding &lt;a href=&quot;column_blob&quot;&gt;column access functions&lt;/a&gt; except that these routines take a single &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; object pointer instead of a &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; pointer and an integer column number.</source>
          <target state="translated">이러한 루틴 은 &lt;a href=&quot;stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 포인터 및 정수 열 번호 대신 단일 &lt;a href=&quot;value&quot;&gt;보호 sqlite3_value&lt;/a&gt; 오브젝트 포인터를 사용 한다는 점을 제외하고 해당 &lt;a href=&quot;column_blob&quot;&gt;열 액세스 기능과&lt;/a&gt; 동일하게 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="95d389aedaf4f8ce85f9804703017919fd80feca" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;#sqlite3_value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;#sqlite3_value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;#sqlite3_value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서만 작동 합니다. &lt;a href=&quot;#sqlite3_value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 에서 이러한 루틴을 사용하려는 시도 는 스레드 안전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7a8ed928c1fb3dc4a20d3be2fb5cfe01bd35f70b" translate="yes" xml:space="preserve">
          <source>These routines work only with &lt;a href=&quot;value&quot;&gt;protected sqlite3_value&lt;/a&gt; objects. Any attempt to use these routines on an &lt;a href=&quot;value&quot;&gt;unprotected sqlite3_value&lt;/a&gt; is not threadsafe.</source>
          <target state="translated">이 루틴은 &lt;a href=&quot;value&quot;&gt;보호 된 sqlite3_value&lt;/a&gt; 오브젝트 에서만 작동 합니다. &lt;a href=&quot;value&quot;&gt;보호되지 않은 sqlite3_value&lt;/a&gt; 에서 이러한 루틴을 사용하려는 시도 는 스레드 안전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="cf9c078687c96682c6a85bb7a67b91a68491a0f8" translate="yes" xml:space="preserve">
          <source>These static mutexes are reserved for use internally by SQLite and should not be used by the application. The static mutexes are all non-recursive.</source>
          <target state="translated">이 정적 뮤텍스는 SQLite에서 내부 용으로 예약되어 있으므로 응용 프로그램에서 사용해서는 안됩니다. 정적 뮤텍스는 모두 비재 귀적입니다.</target>
        </trans-unit>
        <trans-unit id="a11e17b224413c41480316935dad79b1f586c189" translate="yes" xml:space="preserve">
          <source>These techniques are designed to aid in understanding the core SQLite library itself, not applications that merely use SQLite.</source>
          <target state="translated">이러한 기술은 SQLite를 사용하는 애플리케이션이 아니라 핵심 SQLite 라이브러리 자체를 이해하는 데 도움이되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f9968558d6525a5e69fdd942a06f1a35ab390ef" translate="yes" xml:space="preserve">
          <source>These tests are on a relatively small (approximately 14 megabyte) database. They do not measure how well the database engines scale to larger problems.</source>
          <target state="translated">이러한 테스트는 상대적으로 작은 (약 14MB) 데이터베이스에서 수행됩니다. 데이터베이스 엔진이 더 큰 문제로 얼마나 잘 확장되는지 측정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f97df2bc02e2ab86d912a22d332def150459caf8" translate="yes" xml:space="preserve">
          <source>These tests did not attempt to measure multi-user performance or optimization of complex queries involving multiple joins and subqueries.</source>
          <target state="translated">이러한 테스트에서는 다중 조인 및 하위 쿼리와 관련된 복잡한 쿼리의 다중 사용자 성능 또는 최적화를 측정하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="dd70aa0fe10c02751ca4c43bd10acab99e561495" translate="yes" xml:space="preserve">
          <source>These three ways of committing a transaction correspond to the DELETE, TRUNCATE, and PERSIST settings, respectively, of the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">트랜잭션을 커밋하는이 세 가지 방법은 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt; 의 DELETE, TRUNCATE 및 PERSIST 설정에 각각 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="8f79d49bdd4e3aeeeb4789bde61715a9a01e430c" translate="yes" xml:space="preserve">
          <source>These two rules describe how the query planner for SQLite works as of this writing (2013-08-01). And the rules above will always be honored. However, future versions of SQLite might incorporate a better theorem prover that can find other cases where W&amp;rArr;X is true and thus may find more instances where partial indexes are useful.</source>
          <target state="translated">이 두 규칙은이 글을 작성할 때 SQLite 용 쿼리 플래너가 어떻게 작동하는지 설명합니다 (2013-08-01). 그리고 위의 규칙은 항상 존중됩니다. 그러나 향후 버전의 SQLite는 W&amp;rArr;X가 참인 다른 경우를 찾을 수있는 더 나은 정리 증명을 통합 할 수 있으므로 부분 인덱스가 유용한 경우를 더 많이 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8fd956e215d583a512e53c2c78546d08e30ff46" translate="yes" xml:space="preserve">
          <source>Things That Can Go Wrong</source>
          <target state="translated">잘못 될 수있는 것</target>
        </trans-unit>
        <trans-unit id="42067c10086226bb2498180a8a023f3ac259d639" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">트리거 프로그램이 실행되는 동안 sqlite3_changes () 함수가 실행되면 상황이 더 복잡합니다. 프로그램이 &lt;a href=&quot;../lang_corefunc#changes&quot;&gt;changes () SQL 함수&lt;/a&gt; 를 사용하거나 다른 콜백 함수가 sqlite3_changes ()를 직접 호출하는 경우에 발생할 수 있습니다. 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="53a7af1ec1bf96fe1cf7aeeb3a8a96e5b6a416b2" translate="yes" xml:space="preserve">
          <source>Things are more complicated if the sqlite3_changes() function is executed while a trigger program is running. This may happen if the program uses the &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes() SQL function&lt;/a&gt;, or if some other callback function invokes sqlite3_changes() directly. Essentially:</source>
          <target state="translated">트리거 프로그램이 실행되는 동안 sqlite3_changes () 함수가 실행되면 상황이 더 복잡합니다. 프로그램이 &lt;a href=&quot;lang_corefunc#changes&quot;&gt;changes () SQL 함수&lt;/a&gt; 를 사용하거나 다른 콜백 함수가 sqlite3_changes ()를 직접 호출하는 경우에 발생할 수 있습니다. 본질적으로 :</target>
        </trans-unit>
        <trans-unit id="774483139813d257b6024c3ca6cbcda75578301f" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a separate computer program. The original SQL text is source code. A prepared statement object is the compiled object code. All SQL must be converted into a prepared statement before it can be run.</source>
          <target state="translated">각 SQL 문을 별도의 컴퓨터 프로그램으로 생각하십시오. 원본 SQL 텍스트는 소스 코드입니다. 준비된 명령문 오브젝트는 컴파일 된 오브젝트 코드입니다. 실행하기 전에 모든 SQL을 준비된 명령문으로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2f8cd345a6425d660448be637505c8f25ad1aef9" translate="yes" xml:space="preserve">
          <source>Think of each SQL statement as a small computer program. The purpose of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is to compile that program into object code. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is the object code. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface then runs the object code to get a result.</source>
          <target state="translated">각 SQL 문을 작은 컴퓨터 프로그램으로 생각하십시오. &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 의 목적은 해당 프로그램을 객체 코드로 컴파일하는 것입니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문은&lt;/a&gt; 오브젝트 코드입니다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 결과를 얻을 수있는 오브젝트 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="cfafbb2da361739c04c43a8272cc38856e9c67a7" translate="yes" xml:space="preserve">
          <source>Third Improvement: Versioning</source>
          <target state="translated">세 번째 개선 : 버전 관리</target>
        </trans-unit>
        <trans-unit id="865c9c12492c3442466282bf437772709b257a8a" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirstColumn() set iCol to -1).</source>
          <target state="translated">&quot;detail = none&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다. FTS5 테이블이 &quot;detail = none&quot; &quot;content =&quot;옵션으로 작성되면 (즉, 내용이없는 테이블 인 경우)이 API는 항상 빈 세트를 반복합니다 (xPhraseFirstColumn ()에 대한 모든 호출은 iCol을 -1로 설정) .</target>
        </trans-unit>
        <trans-unit id="ebf79b4cb55761477acdbbee63fd4654b2112a93" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option.</source>
          <target state="translated">&quot;detail = none&quot;또는 &quot;detail = column&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="320a596dec5edeedf6c5c2728a533311ecff7379" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always iterates through an empty set (all calls to xPhraseFirst() set iCol to -1).</source>
          <target state="translated">&quot;detail = none&quot;또는 &quot;detail = column&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다. FTS5 테이블이 &quot;detail = none&quot;또는 &quot;detail = column&quot;및 &quot;content =&quot;옵션 (즉, 내용이없는 테이블 인 경우)으로 작성되는 경우이 API는 항상 빈 세트 (xPhraseFirst ( ) iCol을 -1)로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="f65fb946e21f0df296308a1267bfc8d75459c36f" translate="yes" xml:space="preserve">
          <source>This API can be quite slow if used with an FTS5 table created with the &quot;detail=none&quot; or &quot;detail=column&quot; option. If the FTS5 table is created with either &quot;detail=none&quot; or &quot;detail=column&quot; and &quot;content=&quot; option (i.e. if it is a contentless table), then this API always returns 0.</source>
          <target state="translated">&quot;detail = none&quot;또는 &quot;detail = column&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하면이 API가 느려질 수 있습니다. FTS5 테이블이 &quot;detail = none&quot;또는 &quot;detail = column&quot;및 &quot;content =&quot;옵션 (즉, 내용이없는 테이블 인 경우)으로 작성되면이 API는 항상 0을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="43444bfacf757a80f8f09485afde0ead5f0a776e" translate="yes" xml:space="preserve">
          <source>This API function is used to query the FTS table for phrase iPhrase of the current query. Specifically, a query equivalent to:</source>
          <target state="translated">이 API 함수는 현재 쿼리의 문구 iPhrase에 대한 FTS 테이블을 쿼리하는 데 사용됩니다. 특히 다음과 같은 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="d89725045237fc9113c1fa0f974917002e582aec" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">이 API는 라이브러리가 사전 프로세서 기호 &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS가&lt;/a&gt; 정의 된 상태로 빌드 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="48dac83568aa304395644b3c39b1c1984d8ea7c3" translate="yes" xml:space="preserve">
          <source>This API is only available if the library is built with pre-processor symbol &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; defined.</source>
          <target state="translated">이 API는 라이브러리가 사전 프로세서 기호 &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS가&lt;/a&gt; 정의 된 상태로 빌드 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f548cc5880d8bc2ce8ab0c825c0274336bee682c" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 API는 특정 이름과 매개 변수 수를 가진 함수의 글로벌 버전이 존재하는지 확인합니다. 이 API가 호출되기 전에 그러한 함수가 존재하지 않으면 새로운 함수가 작성됩니다. 새 함수를 구현하면 항상 예외가 발생합니다. 따라서 새로운 기능은 그 자체로는 좋지 않습니다. 그것의 유일한 목적은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블에&lt;/a&gt; 의해 오버로드 될 수있는 자리 표시 자 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="8540f6a2004da77a77789ccfaf202735cf5c6ba1" translate="yes" xml:space="preserve">
          <source>This API makes sure a global version of a function with a particular name and number of parameters exists. If no such function exists before this API is called, a new function is created. The implementation of the new function always causes an exception to be thrown. So the new function is not good for anything by itself. Its only purpose is to be a placeholder function that can be overloaded by a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 API는 특정 이름과 매개 변수 수를 가진 함수의 글로벌 버전이 존재하는지 확인합니다. 이 API가 호출되기 전에 그러한 함수가 존재하지 않으면 새로운 함수가 작성됩니다. 새 함수를 구현하면 항상 예외가 발생합니다. 따라서 새로운 기능은 그 자체로는 좋지 않습니다. 그것의 유일한 목적은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블에&lt;/a&gt; 의해 오버로드 될 수있는 자리 표시 자 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="6ab96b1e97da69a025cb8ca96b99b710398cad45" translate="yes" xml:space="preserve">
          <source>This C-preprocess macro determines the default setting of the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; configuration setting. It defaults to 1 (on) which means that covering indices are used for full table scans where possible, in order to reduce I/O and improve performance. However, the use of a covering index for a full scan will cause results to appear in a different order from legacy, which could cause some (incorrectly-coded) legacy applications to break. Hence, the covering index scan option can be disabled at compile-time on systems that what to minimize their risk of exposing errors in legacy applications.</source>
          <target state="translated">이 C 전처리 매크로는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigcoveringindexscan&quot;&gt;SQLITE_CONFIG_COVERING_INDEX_SCAN&lt;/a&gt; 구성 설정 의 기본 설정을 결정 합니다. 기본값은 1 (켜기)입니다. 즉, 가능한 경우 전체 인덱스 스캔에 커버링 인덱스가 사용되어 I / O를 줄이고 성능을 향상시킵니다. 그러나 전체 검색에 적용 인덱스를 사용하면 레거시와 다른 순서로 결과가 표시되어 일부 (올바르게 코딩 된) 레거시 응용 프로그램이 중단 될 수 있습니다. 따라서 레거시 응용 프로그램에서 오류가 노출 될 위험을 최소화 할 수있는 시스템에서 컴파일 타임에 커버링 인덱스 스캔 옵션을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6673eaea3893e3fceb60fe446b80a1ff19d0e8" translate="yes" xml:space="preserve">
          <source>This DELETE statement will remove every record from the &quot;examp&quot; table where the &quot;two&quot; column is less than 50. The code generated to do this is as follows:</source>
          <target state="translated">이 DELETE 문은 &quot;examp&quot;테이블에서 &quot;two&quot;열이 50보다 작은 모든 레코드를 제거합니다.이를 수행하기 위해 생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0bfab415a485beb9edddb8d5188d00815376867" translate="yes" xml:space="preserve">
          <source>This allows optimizations: (a) when P4==0 there is no need to test the RowSet object for P3, as it is guaranteed not to contain it, (b) when P4==-1 there is no need to insert the value, as it will never be tested for, and (c) when a value that is part of set X is inserted, there is no need to search to see if the same value was previously inserted as part of set X (only if it was previously inserted as part of some other set).</source>
          <target state="translated">이를 통해 최적화가 가능합니다. (a) P4 == 0 인 경우 P3에 대해 RowSet 객체를 테스트 할 필요가 없습니다. 포함하지 않을 것이므로 (b) P4 ==-1 인 경우 값을 삽입 할 필요가 없습니다. (c) 집합 X의 일부인 값이 삽입 될 때 이전에 설정된 X의 일부로 동일한 값이 삽입되었는지 여부를 검색 할 필요가 없습니다. 이전에 다른 세트의 일부로 삽입 됨).</target>
        </trans-unit>
        <trans-unit id="e9de882f0fc5b21571717171f0fcc8e049f8f4b3" translate="yes" xml:space="preserve">
          <source>This allows separate database connections to share the same in-memory database. Of course, all database connections sharing the in-memory database need to be in the same process. The database is automatically deleted and memory is reclaimed when the last connection to the database closes.</source>
          <target state="translated">이를 통해 별도의 데이터베이스 연결이 동일한 인 메모리 데이터베이스를 공유 할 수 있습니다. 물론 인 메모리 데이터베이스를 공유하는 모든 데이터베이스 연결은 동일한 프로세스에 있어야합니다. 데이터베이스에 대한 마지막 연결이 닫히면 데이터베이스가 자동으로 삭제되고 메모리가 회수됩니다.</target>
        </trans-unit>
        <trans-unit id="c92e98ecc01f031d3a1efe7cd735db9a008161b9" translate="yes" xml:space="preserve">
          <source>This article also uses the terms &quot;bytecode program&quot; and &quot;prepared statement&quot; interchangeably, as they are mostly the same thing.</source>
          <target state="translated">또한이 기사에서는 &quot;바이트 코드 프로그램&quot;과 &quot;준비된 명령문&quot;이라는 용어를 같은 의미로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9af0cbe702f19f3f49888228ef0df406a0e5175" translate="yes" xml:space="preserve">
          <source>This article defines what the limits of SQLite are and how they can be customized for specific applications. The default settings for limits are normally quite large and adequate for almost every application. Some applications may want to increase a limit here or there, but we expect such needs to be rare. More commonly, an application might want to recompile SQLite with much lower limits to avoid excess resource utilization in the event of bug in higher-level SQL statement generators or to help thwart attackers who inject malicious SQL statements.</source>
          <target state="translated">이 기사에서는 SQLite의 한계와 특정 애플리케이션에 맞게 SQLite를 사용자 정의하는 방법을 정의합니다. 제한의 기본 설정은 일반적으로 거의 모든 응용 프로그램에 매우 크고 적절합니다. 일부 응용 프로그램은 여기 또는 여기에서 제한을 늘리기를 원할 수 있지만 그러한 요구는 드물 것으로 예상됩니다. 보다 일반적으로 응용 프로그램은 상위 SQL 문 생성기에서 버그가 발생할 경우 과도한 리소스 사용률을 피하거나 악의적 인 SQL 문을 주입하는 공격자를 막기 위해 훨씬 더 낮은 제한으로 SQLite를 다시 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316fd7167581f1bf3b1521c621172952b269d34a" translate="yes" xml:space="preserve">
          <source>This article describes how the SQLite developers measure CPU usage, what those measurements actually mean, and the techniques used by SQLite developers on their continuing quest to further reduce the CPU usage of the SQLite library.</source>
          <target state="translated">이 기사에서는 SQLite 개발자가 CPU 사용량을 측정하는 방법, 이러한 측정의 실제 의미 및 SQLite 개발자가 SQLite 라이브러리의 CPU 사용량을 더 줄이기 위해 계속 노력하는 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="926f25884d306babc2c568ebac87d0360fd509bf" translate="yes" xml:space="preserve">
          <source>This article describes the SQLite OS portability layer or &quot;VFS&quot; - the module at the bottom of the SQLite implementation stack that provides portability across operating systems.</source>
          <target state="translated">이 기사에서는 운영 체제 전반에서 이식성을 제공하는 SQLite 구현 스택의 맨 아래에있는 모듈 인 SQLite OS 이식성 계층 또는 &quot;VFS&quot;에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e9493c358448eb3b281eac84dedc92f4531c0a0b" translate="yes" xml:space="preserve">
          <source>This article describes the techniques used by SQLite to create the illusion of atomic commit.</source>
          <target state="translated">이 기사에서는 SQLite가 원자 커밋의 환상을 만들기 위해 사용하는 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c7354274b5f5ad835c3ba9869336d09f507f1b91" translate="yes" xml:space="preserve">
          <source>This article describes the various temporary files that SQLite creates and uses. It describes when the files are created, when they are deleted, what they are used for, why they are important, and how to avoid them on systems where creating temporary files is expensive.</source>
          <target state="translated">이 기사는 SQLite가 만들고 사용하는 다양한 임시 파일을 설명합니다. 파일 작성시기, 삭제시기, 용도, 중요한 이유 및 임시 파일 작성 비용이 많이 드는 시스템에서 파일을 피하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bf37adfcb2e68d7e2d42601f83e22affd6226d10" translate="yes" xml:space="preserve">
          <source>This article does not contain a step-by-step recipe for compiling SQLite. That would be difficult since each development situation is different. Rather, this article describes and illustrates the principals behind the compilation of SQLite. Typical compilation commands are provided as examples with the expectation that application developers can use these examples as guidance for developing their own custom compilation procedures. In other words, this article provides ideas and insights, not turnkey solutions.</source>
          <target state="translated">이 기사에는 SQLite를 컴파일하기위한 단계별 레시피가 포함되어 있지 않습니다. 각 개발 상황이 다르기 때문에 어려울 것입니다. 오히려이 기사는 SQLite 컴파일의 기본 원리를 설명하고 설명합니다. 일반적인 컴파일 명령은 응용 프로그램 개발자가 자신의 사용자 지정 컴파일 절차를 개발하기위한 지침으로 이러한 예제를 사용할 수있을 것으로 예상되는 예입니다. 즉,이 기사는 턴키 솔루션이 아니라 아이디어와 통찰력을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="945df33c68655603cf7dd0502f5d42134ad32f1a" translate="yes" xml:space="preserve">
          <source>This article has been revised multiple times in an attempt to improve clarity, address concerns and misgivings, and to fix errors identified on &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; and &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt;. The complete edit history can be seen at &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt;. (Usage hint: Click on any two nodes of the graph for a diff.)</source>
          <target state="translated">이 기사는 명확성을 개선하고 우려 사항과 오해를 해결하고 &lt;a href=&quot;https://news.ycombinator.com/item?id=16806114&quot;&gt;Hacker News&lt;/a&gt; , &lt;a href=&quot;https://www.reddit.com/r/programming/comments/8c2niw/why_sqlite_does_not_use_git/&quot;&gt;Reddit&lt;/a&gt; 및 &lt;a href=&quot;https://lobste.rs/s/slcntl/why_sqlite_does_not_use_git&quot;&gt;Lobsters&lt;/a&gt; 에서 식별 된 오류를 수정하기 위해 여러 번 개정되었습니다 . 전체 편집 내역은 &lt;a href=&quot;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&quot;&gt;https://sqlite.org/docsrc/finfo/pages/whynotgit.in&lt;/a&gt; 에서 확인할 수 있습니다 . (사용 힌트 : diff에 대한 그래프의 두 노드를 클릭하십시오.)</target>
        </trans-unit>
        <trans-unit id="62a4071d7245439102f2788bb499d61e09713933" translate="yes" xml:space="preserve">
          <source>This article has reviewed all of the major techniques used by SQLite's VDBE to implement SQL statements. What has not been shown is that most of these techniques can be used in combination to generate code for an appropriately complex query statement. For example, we have shown how sorting is accomplished on a simple query and we have shown how to implement a compound query. But we did not give an example of sorting in a compound query. This is because sorting a compound query does not introduce any new concepts: it merely combines two previous ideas (sorting and compounding) in the same VDBE program.</source>
          <target state="translated">이 기사에서는 SQLite의 VDBE가 SQL 문을 구현하는 데 사용하는 모든 주요 기술을 검토했습니다. 도시되지 않은 것은 이들 기술의 대부분이 조합되어 적절히 복잡한 질의 문에 대한 코드를 생성 할 수 있다는 것이다. 예를 들어 간단한 쿼리에서 정렬이 수행되는 방식을 보여 주었고 복합 쿼리를 구현하는 방법을 보여주었습니다. 그러나 복합 쿼리에서 정렬하는 예는 제공하지 않았습니다. 복합 쿼리를 정렬 할 때 새로운 개념이 도입되지 않기 때문입니다. 동일한 VDBE 프로그램에서 이전의 두 가지 아이디어 (정렬 및 복합) 만 결합한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a20be3ae1245d83ff9c73306d203b42ad8b16c54" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; a comparison between Fossil and Git. See &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; for one comparison of the two systems. There are others as well.</source>
          <target state="translated">이 기사는 화석과 Git의 비교 가 &lt;u&gt;아닙니다&lt;/u&gt; . 두 시스템의 비교는 &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/fossil-v-git.wiki&lt;/a&gt; 를 참조 하십시오 . 다른 것도 있습니다.</target>
        </trans-unit>
        <trans-unit id="afdaa5ec4a00df9435f74fca69ef2e683fab815e" translate="yes" xml:space="preserve">
          <source>This article is &lt;u&gt;not&lt;/u&gt; advocating that you switch your projects away from Git. You can use whatever version control system you want. If you are perfectly happy with Git, then by all means keep using Git. But, if you are wondering if there isn't something better, then maybe try to understand the perspectives presented below. Use the insights thus obtained to find or write a different and better version control system, or to just make improvements to Git itself.</source>
          <target state="translated">이 기사에서는 Git에서 프로젝트를 전환한다고 주장 &lt;u&gt;하지 않습니다&lt;/u&gt; . 원하는 버전 제어 시스템을 사용할 수 있습니다. Git에 완벽하게 만족한다면 반드시 Git을 계속 사용하십시오. 그러나 더 좋은 것이 없는지 궁금하다면 아래 제시된 관점을 이해하려고 노력하십시오. 이렇게 얻은 통찰력을 사용하여 더 좋고 다른 버전 제어 시스템을 찾거나 작성하거나 Git 자체를 개선하십시오.</target>
        </trans-unit>
        <trans-unit id="7e8b2b9b07235888ae1de754eef75c5cbe3b972b" translate="yes" xml:space="preserve">
          <source>This article is a brief introduction to how the VDBE works and in particular how the various VDBE instructions (documented &lt;a href=&quot;opcode&quot;&gt;here&lt;/a&gt;) work together to do useful things with the database. The style is tutorial, beginning with simple tasks and working toward solving more complex problems. Along the way we will visit most submodules in the SQLite library. After completing this tutorial, you should have a pretty good understanding of how SQLite works and will be ready to begin studying the actual source code.</source>
          <target state="translated">이 기사는 VDBE의 작동 방식, 특히 다양한 VDBE 명령어 ( &lt;a href=&quot;opcode&quot;&gt;여기에 설명되어 있음&lt;/a&gt; )가 데이터베이스에서 유용한 작업을 수행 하는 방법에 대한 간략한 소개 입니다. 이 스타일은 간단한 작업부터 시작하여 더 복잡한 문제를 해결하기위한 자습서입니다. 그 과정에서 우리는 SQLite 라이브러리에서 대부분의 하위 모듈을 방문 할 것입니다. 이 학습서를 완료하면 SQLite의 작동 방식을 잘 이해하고 실제 소스 코드를 연구 할 준비가됩니다.</target>
        </trans-unit>
        <trans-unit id="2a689ac1a6bfa9fdba228a490c8ca90cb86bfd11" translate="yes" xml:space="preserve">
          <source>This article is about the bottom layer.</source>
          <target state="translated">이 기사는 최하위 계층에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8376dd4be0a7eabaff5c0a359df7f198ffdee0ed" translate="yes" xml:space="preserve">
          <source>This article only mentions the most important and most commonly used SQLite interfaces. The SQLite library includes many other APIs implementing useful features that are not described here. A &lt;a href=&quot;c3ref/funclist&quot;&gt;complete list of functions&lt;/a&gt; that form the SQLite application programming interface is found at the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ Interface Specification&lt;/a&gt;. Refer to that document for complete and authoritative information about all SQLite interfaces.</source>
          <target state="translated">이 기사는 가장 중요하고 가장 일반적으로 사용되는 SQLite 인터페이스에 대해서만 언급합니다. SQLite 라이브러리에는 여기에 설명되지 않은 유용한 기능을 구현하는 다른 많은 API가 포함되어 있습니다. SQLite 애플리케이션 프로그래밍 인터페이스를 구성 하는 &lt;a href=&quot;c3ref/funclist&quot;&gt;전체 기능 목록은 &lt;/a&gt;&lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++ 인터페이스 사양에&lt;/a&gt; 있습니다. 모든 SQLite 인터페이스에 대한 완전하고 권위있는 정보는 해당 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecb82abd11a7741bac191b285785a86679cd3dd8" translate="yes" xml:space="preserve">
          <source>This article outlines one possible method for keeping a private branch of SQLite in sync with the public SQLite source code. There are many ways of maintaining a private branch, of course. Nobody is compelled to use the method describe here. This article is not trying to impose a particular procedure on maintainers of private branches. The point of this article is to offer an example of one process for maintaining a private branch which can be used as a template for designing processes best suited for the circumstances of each individual project.</source>
          <target state="translated">이 기사에서는 SQLite의 개인 브랜치를 공개 SQLite 소스 코드와 동기화하는 방법 중 하나를 설명합니다. 물론 개인 지점을 유지 관리하는 방법에는 여러 가지가 있습니다. 아무도 여기에 설명 된 방법을 사용하도록 강요 당하지 않습니다. 이 기사는 개인 브랜치의 관리자에게 특정 절차를 강요하지 않습니다. 이 기사의 요점은 각 개별 프로젝트의 상황에 가장 적합한 프로세스를 설계하기위한 템플리트로 사용될 수있는 개인 브랜치를 유지하기위한 하나의 프로세스의 예를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6e9369c9e16c87662c003b06c9e9f9920fb45e35" translate="yes" xml:space="preserve">
          <source>This article overviews the importance of query planning, describes some of the problems inherent to query planning, and outlines how the NGQP solves those problems.</source>
          <target state="translated">이 문서에서는 쿼리 계획의 중요성을 설명하고 쿼리 계획에 내재 된 일부 문제에 대해 설명하고 NGQP가 이러한 문제를 해결하는 방법을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="edd2ab1205dd1a38d5ce29f020d2d454461aadbe" translate="yes" xml:space="preserve">
          <source>This article presents a technique using the SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface such that calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; block until the required locks are available instead of returning SQLITE_LOCKED immediately. If the sqlite3_blocking_step() or sqlite3_blocking_prepare_v2() functions presented to the left return SQLITE_LOCKED, this indicates that to block would deadlock the system.</source>
          <target state="translated">이 기사에서는 SQLite_LOCKED를 즉시 리턴하는 대신 필요한 잠금을 사용할 수있을 때까지 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 블록 을 호출하도록 SQLite &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스를 사용하는 기술을 설명합니다. 왼쪽에 제시된 sqlite3_blocking_step () 또는 sqlite3_blocking_prepare_v2 () 함수가 SQLITE_LOCKED를 리턴하면 시스템을 교착 상태로 막을 것임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9498c6cd8712f6376d65af391550cc9e3ffdabcd" translate="yes" xml:space="preserve">
          <source>This block of instruction cleans up the VDBE program. Three of these instructions aren't really required, but are generated by the SQLite parser from its code templates, which are designed to handle more complicated cases.</source>
          <target state="translated">이 명령어 블록은 VDBE 프로그램을 정리합니다. 이러한 명령어 중 3 개는 실제로 필요하지는 않지만 더 복잡한 경우를 처리하도록 설계된 코드 템플릿에서 SQLite 파서에 의해 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4a01a06f54367b20ad3750e286b70148e2c847d5" translate="yes" xml:space="preserve">
          <source>This built-in window function calculates the window frame for each row in the same way as an aggregate window function. It returns the value of</source>
          <target state="translated">이 내장 창 함수는 집계 창 함수와 같은 방식으로 각 행의 창 프레임을 계산합니다. 의 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="20ec5d83d88c2da3b16c3295bcff75c38125962e" translate="yes" xml:space="preserve">
          <source>This change is an exception to the version number rule described above in that it is neither forwards or backwards compatible. A complete reload of the database is required. This is the only exception.</source>
          <target state="translated">이 변경은 앞뒤로 호환되지 않는다는 점에서 위에서 설명한 버전 번호 규칙의 예외입니다. 데이터베이스를 완전히 다시로드해야합니다. 이것은 유일한 예외입니다.</target>
        </trans-unit>
        <trans-unit id="c6a5f96c5622bed501ea8661519073e0de4f52cd" translate="yes" xml:space="preserve">
          <source>This column also always contains an integer value greater than zero.</source>
          <target state="translated">이 열에는 항상 0보다 큰 정수 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="fb0358a44a2292d9d05f4777b69d5f05939eb420" translate="yes" xml:space="preserve">
          <source>This column always contains an integer value greater than zero.</source>
          <target state="translated">이 열에는 항상 0보다 큰 정수 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1713bd9e06b77e4bbf5df2753a784a802e3933b6" translate="yes" xml:space="preserve">
          <source>This column determines which &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;languageid&lt;/a&gt; is used to extract vocabulary from the FTS3/4 table.</source>
          <target state="translated">이 열 은 FTS3 / 4 테이블에서 어휘를 추출하는 데 사용 되는 &lt;a href=&quot;fts3#*fts4languageid&quot; id=&quot;f4alid&quot;&gt;언어&lt;/a&gt; ID를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="285c275d9591ca00ecba379d1be0f439e124856e" translate="yes" xml:space="preserve">
          <source>This column may contain either the text value '*' (i.e. a single character, U+002a) or an integer between 0 and N-1, where N is again the number of user-defined columns in the corresponding FTS table.</source>
          <target state="translated">이 열은 텍스트 값 '*'(즉, 단일 문자, U + 002a) 또는 0과 N-1 사이의 정수를 포함 할 수 있습니다. 여기서 N은 다시 해당 FTS 테이블의 사용자 정의 열 수입니다.</target>
        </trans-unit>
        <trans-unit id="65f82075152c89e2aff2366597dc220e2a3e5878" translate="yes" xml:space="preserve">
          <source>This column must be set to NULL. If a non-NULL value is inserted into this column, or if a new non-NULL value is provided using an UPDATE statement, it is an error.</source>
          <target state="translated">이 열은 NULL로 설정해야합니다. NULL이 아닌 값이이 열에 삽입되거나 UPDATE 문을 사용하여 새로운 NULL이 아닌 값이 제공되는 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="e9e3819e4d76ebe92176deabc7d0279eab9fbfc8" translate="yes" xml:space="preserve">
          <source>This column shows the phonetic hash prefix that was used to restrict the search. For any given query, this column should be the same for every row. This information is available for diagnostic purposes and is not normally considered useful in real applications.</source>
          <target state="translated">이 열에는 검색을 제한하는 데 사용 된 발음 해시 접두사가 표시됩니다. 주어진 쿼리에 대해이 열은 모든 행에서 동일해야합니다. 이 정보는 진단용으로 제공되며 일반적으로 실제 응용 프로그램에는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01288c4cfddc172d238625a965b9f1003be61617" translate="yes" xml:space="preserve">
          <source>This command both creates the new repository and populates it with all the latest SQLite code. You can then create a private branch as described in section 3.4.</source>
          <target state="translated">이 명령은 새 저장소를 작성하고 모든 최신 SQLite 코드로 채 웁니다. 그런 다음 섹션 3.4에 설명 된대로 개인 브랜치를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ca6b6ac38f5b817649e53a976402c687ab2fa8" translate="yes" xml:space="preserve">
          <source>This command causes SQLite to disconnect from the previous database and reattach to an in-memory database with the content in</source>
          <target state="translated">이 명령은 SQLite가 이전 데이터베이스에서 연결을 끊고 내용이 다음과 같이 메모리 내 데이터베이스에 다시 연결되도록합니다.</target>
        </trans-unit>
        <trans-unit id="52245829743ea4e1b3e2fa49a0972f85d14c8fbb" translate="yes" xml:space="preserve">
          <source>This command causes the &quot;callback&quot; script to be invoked whenever certain conditions occurs. The conditions are determined by the</source>
          <target state="translated">이 명령을 사용하면 특정 조건이 발생할 때마다 &quot;콜백&quot;스크립트가 호출됩니다. 조건은</target>
        </trans-unit>
        <trans-unit id="13f59d1cb3e06c83ff056103acea107f7910080d" translate="yes" xml:space="preserve">
          <source>This command first deletes the entire full-text index, then rebuilds it based on the contents of the table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">이 명령은 먼저 전체 전체 텍스트 인덱스를 삭제 한 다음 테이블 또는 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;컨텐츠 테이블&lt;/a&gt; 의 컨텐츠를 기반으로 인덱스를 다시 작성합니다 . 내용이없는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;테이블&lt;/a&gt; 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fe5638fc83b6cdbce8fdc02e570b8e2b10a1482f" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It deletes all entries from the full-text index.</source>
          <target state="translated">이 명령은에서만 사용할 수 있습니다 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 콘텐츠&lt;/a&gt; 와 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는&lt;/a&gt; 테이블. 전체 텍스트 인덱스에서 모든 항목을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="7489ecbcacef562551b65244089f9307c364a891" translate="yes" xml:space="preserve">
          <source>This command is only available with &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; and &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; tables. It is used to delete the index entries associated with a single row from the full-text index. This command and the &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; command are the only ways to remove entries from the full-text index of a contentless table.</source>
          <target state="translated">이 명령은에서만 사용할 수 있습니다 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 콘텐츠&lt;/a&gt; 와 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는&lt;/a&gt; 테이블. 전체 텍스트 인덱스에서 단일 행과 관련된 인덱스 항목을 삭제하는 데 사용됩니다. 이 명령과 &lt;a href=&quot;fts5#the_delete_all_command&quot;&gt;delete-all&lt;/a&gt; 명령은 내용이없는 테이블의 전체 텍스트 인덱스에서 항목을 제거하는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="a1d13a5c03e8731ed6d7cfb96b7277fb1a9eb4b2" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;pgsz&quot; option.</source>
          <target state="translated">이 명령은 지속적 &quot;pgsz&quot;옵션을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b39428042e588fc7d00e73c6e90326dc9e9ea85b" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;rank&quot; option.</source>
          <target state="translated">이 명령은 지속적 &quot;rank&quot;옵션을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="85b16bab1c29894a0c668469c8830c0b869b0913" translate="yes" xml:space="preserve">
          <source>This command is used to set the persistent &quot;usermerge&quot; option.</source>
          <target state="translated">이 명령은 지속적 &quot;usermerge&quot;옵션을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3730a7c5668daaf6af3f627c894d5a241eb8942e" translate="yes" xml:space="preserve">
          <source>This command is used to verify that the full-text index is consistent with the contents of the FTS5 table or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;content table&lt;/a&gt;. It is not available with &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless tables&lt;/a&gt;.</source>
          <target state="translated">이 명령은 전체 텍스트 인덱스가 FTS5 테이블 또는 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;내용 테이블&lt;/a&gt; 의 내용과 일치하는지 확인하는 데 사용됩니다 . 내용이없는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;테이블&lt;/a&gt; 에는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1a574335749833522810d0e9deb16c3b1a8c4736" translate="yes" xml:space="preserve">
          <source>This command may also be used with ordinary FTS4 tables, for example if the implementation of the tokenizer changes. It is an error to attempt to rebuild the full-text index maintained by a contentless FTS4 table, since no content will be available to do the rebuilding.</source>
          <target state="translated">이 명령은 예를 들어 토크 나이저의 구현이 변경되는 경우 일반 FTS4 테이블과 함께 사용될 수도 있습니다. 컨텐츠를 다시 작성할 수있는 컨텐츠가 없으므로 컨텐츠가없는 FTS4 테이블에서 유지 보수하는 전체 텍스트 인덱스를 재 구축하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="61072f8fd085f0b1c6b3c6456d8203db4cf536aa" translate="yes" xml:space="preserve">
          <source>This command merges all individual b-trees that currently make up the full-text index into a single large b-tree structure. This ensures that the full-text index consumes the minimum space within the database and is in the fastest form to query.</source>
          <target state="translated">이 명령은 현재 전체 텍스트 인덱스를 구성하는 모든 개별 b- 트리를 하나의 큰 b- 트리 구조로 병합합니다. 이렇게하면 전체 텍스트 인덱스가 데이터베이스 내에서 최소 공간을 사용하고 쿼리하기 가장 빠른 형식으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="51ac15b2185be7d66cfb5466a048917c1313d8ae" translate="yes" xml:space="preserve">
          <source>This command merges b-tree structures together until roughly N pages of merged data have been written to the database, where N is the absolute value of the parameter specified as part of the 'merge' command. The size of each page is as configured by the &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz option&lt;/a&gt;.</source>
          <target state="translated">이 명령은 대략 N 페이지의 병합 된 데이터가 데이터베이스에 기록 될 때까지 b- 트리 구조를 병합합니다. 여기서 N은 'merge'명령의 일부로 지정된 매개 변수의 절대 값입니다. 각 페이지의 크기는 &lt;a href=&quot;fts5#the_pgsz_configuration_option&quot;&gt;FTS5 pgsz 옵션&lt;/a&gt; 으로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f6ccb891d0018f34c8b539ed4ad53a6be49ac1c9" translate="yes" xml:space="preserve">
          <source>This command sequence is a lot to memorize and type. (One would want to create a bash alias or short shell script if it were used frequently.) Furthermore, it is not quite the same thing. The command above gives one a list of descendents without showing the branching structure, which is important for understanding what happened. In contrast, Fossil offers displays such as &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt;, which is a tremendous help in analyzing the aftermath of historical changes.</source>
          <target state="translated">이 명령 순서는 암기하고 입력하는 것이 많습니다. (빈번하게 사용된다면 bash 별명이나 짧은 쉘 스크립트를 만들고 싶을 것이다.) 게다가, 그것은 똑같지 않다. 위의 명령은 분기 구조를 보여주지 않고 자손 목록을 제공하며, 이는 발생한 일을 이해하는 데 중요합니다. 대조적으로, Fossil은 &lt;a href=&quot;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&quot;&gt;https://sqlite.org/src/timeline?d=8a439a6dda390d74&amp;amp;n=15&lt;/a&gt; 와 같은 디스플레이를 제공하며 , 이는 역사적 변화의 여파를 분석하는 데 큰 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="309dfaa9b377c5a8af4ac33fa681865f1bffbfb3" translate="yes" xml:space="preserve">
          <source>This command will create a new branch named &quot;private&quot; (you can use a different name if you like) and assign it a background color of light blue (&quot;#add8e8&quot;). You can omit the background color if you want, though having a distinct background does make it easier to tell the branch from the &quot;trunk&quot; (the public branch) on timeline displays. You can change the background color of the private branch or of the public branch (the &quot;trunk&quot;) using the web interface if you like.</source>
          <target state="translated">이 명령은 &quot;private&quot;이라는 새 분기를 만들고 (원하는 경우 다른 이름을 사용할 수 있음) 연한 파랑의 배경색 ( &quot;# add8e8&quot;)을 지정합니다. 원하는 경우 배경색을 생략 할 수 있지만, 고유 한 배경을 사용하면 타임 라인 디스플레이의 &quot;트렁크&quot;(공개 지점)에서 분기를 쉽게 알 수 있습니다. 원하는 경우 웹 인터페이스를 사용하여 개인 지점 또는 공용 지점 ( &quot;트렁크&quot;)의 배경색을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5db5e98e2fd20bba8ab658518e972deb34aab3ef" translate="yes" xml:space="preserve">
          <source>This command-line shell leaves unnamed parameters unbound, meaning that they will have a value of an SQL NULL, but named parameters might be assigned values. If there exists a TEMP table named &quot;sqlite_parameters&quot; with a schema like this:</source>
          <target state="translated">이 명령 줄 셸은 명명되지 않은 매개 변수를 바인딩되지 않은 상태로 둡니다. 즉, SQL NULL 값을 가지지 만 명명 된 매개 변수에는 값이 할당 될 수 있습니다. &quot;sqlite_parameters&quot;라는 TEMP 테이블이 다음과 같은 스키마가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="4c4b4e9517b3e559a4264bd38d883b4075b15dd6" translate="yes" xml:space="preserve">
          <source>This compile-time option affects the SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator only and has no impact on the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; C-language interface.</source>
          <target state="translated">이 컴파일 타임 옵션은 SQL &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자에만 영향을 주며 &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; C 언어 인터페이스 에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6c67f3211a79226589052fa652c6121f10cd5b9d" translate="yes" xml:space="preserve">
          <source>This compile-time option causes the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator to always return False if either operand is a BLOB. The default behavior of &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; is that BLOB operands are cast to TEXT before the comparison is done.</source>
          <target state="translated">이 컴파일 타임 옵션을 사용하면 피연산자 중 하나가 BLOB 인 경우 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자가 항상 False를 반환합니다. &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 의 기본 동작은 비교를 수행하기 전에 BLOB 피연산자가 TEXT로 캐스트되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b087b90d5f82c6cd11bb4d6150e1edc15e3c7080" translate="yes" xml:space="preserve">
          <source>This compile-time option changes the default setting of the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;. When this option is not used, secure_delete defaults to off. When this option is present, secure_delete defaults to on.</source>
          <target state="translated">이 컴파일 타임 옵션은 &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt; 의 기본 설정을 변경합니다 . 이 옵션을 사용하지 않으면 secure_delete는 기본적으로 해제되어 있습니다. 이 옵션이 있으면 secure_delete의 기본값은 on입니다.</target>
        </trans-unit>
        <trans-unit id="ec3013abfee74643b8705338ad5e107049f5af6c" translate="yes" xml:space="preserve">
          <source>This compile-time option disables the &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; command.</source>
          <target state="translated">이 컴파일 타임 옵션은 &lt;a href=&quot;pragma#pragma_case_sensitive_like&quot;&gt;PRAGMA case_sensitive_like&lt;/a&gt; 명령을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="3400d01afcac3cfb7345138b17405acb7d27f932" translate="yes" xml:space="preserve">
          <source>This compile-time option enables SQLite to take advantage batch atomic write capabilities in the underlying filesystem. As of SQLite version 3.21.0 (2017-10-24) this is only supported on &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt;. However, the interface is implemented generically, using &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; with &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; so the capability can be added to other filesystem times in the future. When this option is enabled, SQLite automatically detects that the underlying filesystem supports batch atomic writes, and when it does so it avoids writing the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; for transaction control. This can make transactions over twice as fast, while simultaneously reducing wear on SSD storage devices.</source>
          <target state="translated">이 컴파일 타임 옵션을 통해 SQLite는 기본 파일 시스템에서 배치 원자 쓰기 기능을 활용할 수 있습니다. SQLite는 버전 3.21.0 (2017년 10월 24일) 현재이 만 지원됩니다 &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS&lt;/a&gt; . 그러나 인터페이스는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbeginatomicwrite&quot;&gt;SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlcommitatomicwrite&quot;&gt;SQLITE_FCNTL_COMMIT_ATOMIC_WRITE&lt;/a&gt; 와 함께 &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control ()&lt;/a&gt; 을 사용하여 일반적으로 구현 되므로 나중에 다른 파일 시스템 시간에 기능을 추가 할 수 있습니다. 이 옵션이 활성화되면 SQLite는 기본 파일 시스템이 배치 원자 쓰기를 지원 하는지를 자동으로 감지하고, 그렇게하면 트랜잭션 제어를위한 쓰기를 피합니다 . 이는 SSD 저장 장치의 마모를 줄이면서 동시에 두 배 이상 빠른 트랜잭션을 수행 할 수 있습니다.&lt;a href=&quot;lockingv3#rollback&quot;&gt; 롤백 저널&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a47cb88e70b43c326cbb7cc659779aee23f98fe" translate="yes" xml:space="preserve">
          <source>This compile-time option enables the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; logic.</source>
          <target state="translated">이 컴파일 타임 옵션은 &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT 가상 테이블&lt;/a&gt; 로직을 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="ff47a638485535b8abdf68c6579ec40497b2ae91" translate="yes" xml:space="preserve">
          <source>This compile-time option has been renamed to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt;.</source>
          <target state="translated">이 컴파일 타임 옵션의 이름이 &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; 로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e0b75f253921594adb213c37bae38c55286027e5" translate="yes" xml:space="preserve">
          <source>This compile-time option is deprecated and untested.</source>
          <target state="translated">이 컴파일 타임 옵션은 더 이상 사용되지 않으며 테스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3be0a309752742e7707ae2403c4dadee6c132ddc" translate="yes" xml:space="preserve">
          <source>This compile-time option is no longer used.</source>
          <target state="translated">이 컴파일 타임 옵션은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4333e0a432302d984fdf33eabb1d1ed8fc11d61a" translate="yes" xml:space="preserve">
          <source>This compile-time option makes SQLite run more efficiently when processing queries that use the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator, at the expense of breaking backwards compatibility. However, the backwards compatibility break may be only a technicality. There was a long-standing bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; processing logic (see &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f&lt;/a&gt;) that caused it to misbehavior for BLOB operands and nobody observed that bug in nearly 10 years of active use. So for more users, it is probably safe to enable this compile-time option and thereby save a little CPU time on LIKE queries.</source>
          <target state="translated">이 컴파일 타임 옵션을 사용하면 이전 버전과의 호환성을 유지하면서 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자 를 사용하는 쿼리를 처리 할 때 SQLite를보다 효율적으로 실행할 수 있습니다 . 그러나 이전 버전과의 호환성 중단은 기술적 인 것일 수 있습니다. &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 처리 로직 ( &lt;a href=&quot;https://www.sqlite.org/src/info/05f43be8fdda9f&quot;&gt;https://www.sqlite.org/src/info/05f43be8fdda9f 참조&lt;/a&gt; ) 에 오랫동안 버그 가 발생하여 BLOB 피연산자에 대해 오작동을 일으켰으며 거의 ​​10 년 동안 활발하게 사용 된 버그는 아무도 관찰하지 못했습니다. . 따라서 더 많은 사용자의 경우이 컴파일 타임 옵션을 활성화하면 LIKE 쿼리에서 약간의 CPU 시간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65b9357f2e420dd3508c81b4ae3257d2786b19ca" translate="yes" xml:space="preserve">
          <source>This constraint arises from the fact that numbers do not sort in lexicographical order. For example: 9&amp;lt;10 but '9'&amp;gt;'10'.</source>
          <target state="translated">이 제약은 숫자가 사전 식 순서로 정렬되지 않기 때문에 발생합니다. 예를 들어 9 &amp;lt;10이지만 '9'&amp;gt; '10'입니다.</target>
        </trans-unit>
        <trans-unit id="187432feb7a09e6addc8b4c1a243d9ef78920104" translate="yes" xml:space="preserve">
          <source>This design note considers the database to be a collection of objects. Each SQL table is a class. Each row is an instance of that class. There are, of course, other ways to interpret an SQL database schema, and the techniques described here work equally well under alternative interpretations, but an object-oriented view seems be more natural to most contemporary programmers.</source>
          <target state="translated">이 디자인 노트에서는 데이터베이스를 객체 모음으로 간주합니다. 각 SQL 테이블은 클래스입니다. 각 행은 해당 클래스의 인스턴스입니다. 물론 SQL 데이터베이스 스키마를 해석하는 다른 방법이 있으며 여기에 설명 된 기술은 대체 해석에서도 동일하게 작동하지만 객체 지향적 관점은 대부분의 현대 프로그래머에게 더 자연스러운 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f5cd63f8a1306fc33b54e6f33d75fb0c8f5824b" translate="yes" xml:space="preserve">
          <source>This document describes SQLite internals. The information provided here is not needed for routine application development using SQLite. This document is intended for people who want to delve more deeply into the internal operation of SQLite.</source>
          <target state="translated">이 문서는 SQLite 내부를 설명합니다. 여기에 제공된 정보는 SQLite를 사용한 일상적인 응용 프로그램 개발에는 필요하지 않습니다. 이 문서는 SQLite의 내부 운영에 대해 더 깊이 탐구하고자하는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="29000c12ac32a9037c669c50606cdb73ab6f60c1" translate="yes" xml:space="preserve">
          <source>This document describes and defines the on-disk database file format used by all releases of SQLite since version 3.0.0 (2004-06-18).</source>
          <target state="translated">이 문서는 버전 3.0.0 (2004-06-18) 이후의 모든 SQLite 릴리스에서 사용되는 디스크 내장 데이터베이스 파일 형식을 설명하고 정의합니다.</target>
        </trans-unit>
        <trans-unit id="dc53982e7fc871bc167dd841afd5d1fa7b1536a4" translate="yes" xml:space="preserve">
          <source>This document describes how to obtain the canonical source code for SQLite - the raw source files from which the amalgamation is built. See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page for additional information on what to do with the canonical source code once it is obtained.</source>
          <target state="translated">이 문서는 SQLite에 대한 표준 소스 코드 (아말감이 빌드 된 원시 소스 파일)를 얻는 방법을 설명합니다. 표준 소스 코드를 확보 한 후 수행 할 작업에 대한 추가 정보는 &lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일&lt;/a&gt; 하는 방법 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cb17c7b427d4b622c77f47d250d842b7e4339f9" translate="yes" xml:space="preserve">
          <source>This document describes in detail the way that SQLite uses the API provided by the VFS adaptor component to solve the problems and implement the strategies enumerated above. It also specifies the assumptions made about the properties of the system that the VFS adaptor provides access to. For example, specific assumptions about the extent of data corruption that may occur if a power failure occurs while a database file is being updated are presented in section</source>
          <target state="translated">이 문서는 SQLite가 VFS 어댑터 구성 요소가 제공하는 API를 사용하여 문제점을 해결하고 위에 열거 된 전략을 구현하는 방법을 자세히 설명합니다. 또한 VFS 어댑터가 액세스 할 수있는 시스템 특성에 대한 가정을 지정합니다. 예를 들어, 데이터베이스 파일을 업데이트하는 동안 정전이 발생하면 발생할 수있는 데이터 손상 정도에 대한 특정 가정이 섹션에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da4581d4d5128e1ce5220b57b58fd4271a11dba" translate="yes" xml:space="preserve">
          <source>This document describes incompatibilities that have occurred in SQLite prior to 2004. Since 2004, there have been enhancements to SQLite such that newer database files are unreadable by older versions of the SQLite library. But the most recent versions of the SQLite library should be able to read and write any older SQLite database file without any problems.</source>
          <target state="translated">이 문서는 2004 년 이전의 SQLite에서 발생한 비 호환성에 대해 설명합니다. 2004 년 이후, 이전 버전의 SQLite 라이브러리에서 최신 데이터베이스 파일을 읽을 수 없도록 SQLite가 향상되었습니다. 그러나 최신 버전의 SQLite 라이브러리는 문제없이 이전 SQLite 데이터베이스 파일을 읽고 쓸 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="522199e4ebe6e710a972b890a7a5a64190cc5d3b" translate="yes" xml:space="preserve">
          <source>This document describes low-level details on how &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is implemented on unix and windows.</source>
          <target state="translated">이 문서는 유닉스와 윈도우에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 가 어떻게 구현 되는지에 대한 저수준 세부 사항을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="86876920b62069808dcd8a4f6cfa725666d13fe3" translate="yes" xml:space="preserve">
          <source>This document describes the architecture of the SQLite library. The information here is useful to those who want to understand or modify the inner workings of SQLite.</source>
          <target state="translated">이 문서는 SQLite 라이브러리의 아키텍처를 설명합니다. 여기에있는 정보는 SQLite의 내부 작업을 이해하거나 수정하려는 사람들에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d320774e9898d3525e4d8d7e2967bd5937be4b0" translate="yes" xml:space="preserve">
          <source>This document describes the support for SQL foreign key constraints introduced in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14).</source>
          <target state="translated">이 문서는 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; (2009-10-14)에 도입 된 SQL 외래 키 제약 조건에 대한 지원을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc5a2a4190725779b47fa8957802675b43bcdcd" translate="yes" xml:space="preserve">
          <source>This document does not contain a full description of the syntax used to create foreign key constraints in SQLite. This may be found as part of the documentation for the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement.</source>
          <target state="translated">이 문서에는 SQLite에서 외래 키 제약 조건을 만드는 데 사용되는 구문에 대한 자세한 설명이 없습니다. 이것은 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 에 대한 문서의 일부로 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a95f5bdc9ff03cc2aba9a9f1c4e965180076c32" translate="yes" xml:space="preserve">
          <source>This document does not specify the details of the interface that must be implemented by the VFS adaptor component, that is left to</source>
          <target state="translated">이 문서는 VFS 어댑터 구성 요소에 의해 구현되어야하는 인터페이스의 세부 사항을 지정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4458da44ee2dc70541cbb9f7f722e55f2e9b165b" translate="yes" xml:space="preserve">
          <source>This document focuses on the NGQP. For a more general overview of the SQLite query planner that encompasses the entire history of SQLite, see the &quot;&lt;a href=&quot;optoverview&quot;&gt;The SQLite Query Optimizer Overview&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;queryplanner&quot;&gt;How Indexes Work&lt;/a&gt;&quot; documents.</source>
          <target state="translated">이 문서는 NGQP에 중점을 둡니다. 전체 SQLite 히스토리를 포함하는 SQLite 쿼리 플래너에 대한보다 일반적인 개요는 &quot; &lt;a href=&quot;optoverview&quot;&gt;SQLite Query Optimizer 개요&lt;/a&gt; &quot;및 &quot; &lt;a href=&quot;queryplanner&quot;&gt;인덱스 작동 방식&lt;/a&gt; &quot;문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="da2a96113e96df4cba87ef0ebb6ecd70e207ec5c" translate="yes" xml:space="preserve">
          <source>This document gives an overview of the Tcl programming interface for SQLite.</source>
          <target state="translated">이 문서는 SQLite 용 Tcl 프로그래밍 인터페이스에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a5a4e1d46e6e2a3f39086d506303b41bc25dcc9a" translate="yes" xml:space="preserve">
          <source>This document is a quick introduction to the changes for SQLite 3.0 for users who are already familiar with SQLite version 2.8.</source>
          <target state="translated">이 문서는 SQLite 버전 2.8에 이미 익숙한 사용자를위한 SQLite 3.0의 변경 사항에 대한 빠른 소개입니다.</target>
        </trans-unit>
        <trans-unit id="c1c02e760418d224f0c07cba5a70ec82e928ba41" translate="yes" xml:space="preserve">
          <source>This document is an introduction to the session extension. The details of the interface are in the separate &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C-language Interface&lt;/a&gt; document.</source>
          <target state="translated">이 문서는 세션 확장에 대한 소개입니다. 인터페이스의 세부 사항은 별도의 &lt;a href=&quot;https://sqlite.org/session/intro.html&quot;&gt;Session Extension C 언어 인터페이스&lt;/a&gt; 문서에 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ff7ff01849be2d401b1d6230764460ab55eb57e" translate="yes" xml:space="preserve">
          <source>This document is concerned with the persistent state of the database file, and since the wal-index is a transient structure, no further information about the format of the wal-index will be provided here. Additional details on the format of the wal-index are contained in the separate &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; document.</source>
          <target state="translated">이 문서는 데이터베이스 파일의 지속 상태와 관련이 있으며 wal-index는 일시적인 구조이므로 wal-index 형식에 대한 추가 정보는 여기에 제공되지 않습니다. wal-index 형식에 대한 자세한 내용은 별도의 &lt;a href=&quot;walformat#walidxfmt&quot;&gt;WAL-index File Format&lt;/a&gt; 문서에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce4f9d4c36f7d70e8b9276d0825d097968bc414d" translate="yes" xml:space="preserve">
          <source>This document is created by a script which scans comments in the source code file sqlite3session.h.</source>
          <target state="translated">이 문서는 소스 코드 파일 sqlite3session.h에서 주석을 스캔하는 스크립트로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="d12748856fa96aaf8fec02bb978ea061f37e25d7" translate="yes" xml:space="preserve">
          <source>This document is still sometimes used as a &quot;Code of Conduct&quot; on supplier registration forms. But it is not a Code of Conduct in the same sense that many communities mean a Code of Conduct. Rather, this document describes the ethical principles upon which SQLite is based. Another way to look at this document is as a succinct description of the SQLite Founder's idea of what it means to be &quot;virtuous&quot;.</source>
          <target state="translated">이 문서는 여전히 공급 업체 등록 양식에서 &quot;행동 강령&quot;으로 사용되기도합니다. 그러나 많은 공동체가 행동 강령을 의미하는 것과 같은 의미에서 행동 강령이 아닙니다. 오히려이 문서는 SQLite의 기반이되는 윤리적 원칙을 설명합니다. 이 문서를 보는 또 다른 방법은 SQLite Founder가 &quot;가상&quot;이라는 의미에 대한 간결한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="6ead8dcfb3bc7787acee358a9c3c6b55198ad643" translate="yes" xml:space="preserve">
          <source>This document proposes to use &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;fossil&lt;/a&gt;, but any other distributed software configuration management system such as &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;monotone&lt;/a&gt; or &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;mercurial&lt;/a&gt; (a.k.a. &quot;hg&quot;), or &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; could serve just as well. The concept will be the same, though the specifics of the procedure will vary.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 사용을 제안 하지만 &lt;a href=&quot;http://www.monotone.ca/&quot;&gt;모노톤&lt;/a&gt; 또는 &lt;a href=&quot;http://www.selenic.com/mercurial/wiki/&quot;&gt;수은&lt;/a&gt; (일명 &quot;hg&quot;) 또는 &lt;a href=&quot;http://www.git-scm.org/&quot;&gt;git&lt;/a&gt; 과 같은 다른 분산 소프트웨어 구성 관리 시스템 도 사용할 수 있습니다. 절차의 세부 사항은 다양하지만 개념은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="98d1415d454d0b20f9e20df74b68698917685b9f" translate="yes" xml:space="preserve">
          <source>This document provides an overview of dynamic memory allocation within SQLite. The target audience is software engineers who are tuning their use of SQLite for peak performance in demanding environments. Nothing in this document is required knowledge for using SQLite. The default settings and configuration for SQLite will work well in most applications. However, the information contained in this document may be useful to engineers who are tuning SQLite to comply with special requirements or to run under unusual circumstances.</source>
          <target state="translated">이 문서는 SQLite 내 동적 메모리 할당에 대한 개요를 제공합니다. 대상 고객은 까다로운 환경에서 최고의 성능을 위해 SQLite 사용을 조정하는 소프트웨어 엔지니어입니다. 이 문서의 어느 것도 SQLite 사용에 필요한 지식이 없습니다. SQLite의 기본 설정 및 구성은 대부분의 응용 프로그램에서 잘 작동합니다. 그러나이 문서에 포함 된 정보는 SQLite를 특별 요구 사항을 준수하거나 특수한 상황에서 실행하도록 조정하는 엔지니어에게 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c06afae30b0b7293df04fe27c7c538132693e4c6" translate="yes" xml:space="preserve">
          <source>This document provides an overview of how the query planner and optimizer for SQLite works.</source>
          <target state="translated">이 문서는 쿼리 플래너 및 SQLite 용 최적화 프로그램의 작동 방식에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="54a3569b4cf066b2b50e3e942ef2c48ddc1b1732" translate="yes" xml:space="preserve">
          <source>This document provides background information about how the SQLite query planner and query engine work. Programmers can use this information to help create better indexes, and provide hints to help the query planner when needed.</source>
          <target state="translated">이 문서는 SQLite 쿼리 플래너 및 쿼리 엔진의 작동 방식에 대한 배경 정보를 제공합니다. 프로그래머는이 정보를 사용하여 더 나은 색인을 작성하고 필요할 때 조회 계획자를 돕는 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db48c0715525eb5ade6fdd8bc0b1d41936f8012f" translate="yes" xml:space="preserve">
          <source>This document strives to highlight the principal differences between SQLite and other SQL implementations, as an aid to developers that are porting to or from SQLite or who are trying to build a system that works across multiple database engines.</source>
          <target state="translated">이 문서는 SQLite로 포팅하거나 SQLite를 포팅하거나 여러 데이터베이스 엔진에서 작동하는 시스템을 구축하려는 개발자에게 도움이되도록 SQLite와 다른 SQL 구현의 주요 차이점을 강조하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="499e5ba33e0583ef7d40d010da72b3c26c5f57b3" translate="yes" xml:space="preserve">
          <source>This document was originally called a &quot;Code of Conduct&quot; and was created (in a slightly different format) for the purpose of filling in a box on &quot;supplier registration&quot; forms submitted to the SQLite developers by various minor clients. However, we subsequently learned that &quot;Code of Conduct&quot; has a specific technical meaning within many software development communities, a meaning which was at odds with the intent of this document. Hence, this document is now renamed and replaced by a &lt;a href=&quot;codeofconduct&quot;&gt;Code of Conduct&lt;/a&gt; that does comply with the specific technical requirements was inserted in the place of the old name.</source>
          <target state="translated">이 문서는 원래 &quot;행동 강령&quot;이라고하며, 다양한 소규모 클라이언트가 SQLite 개발자에게 제출 한 &quot;공급자 등록&quot;양식에 대한 상자를 작성하기 위해 작성되었습니다 (약간 다른 형식). 그러나 &quot;행동 강령&quot;은 많은 소프트웨어 개발 커뮤니티 내에서 특정한 기술적 의미를 지니고 있으며 이는 본 문서의 의도와 상충되는 의미입니다. 따라서이 문서의 이름이 바뀌고 &lt;a href=&quot;codeofconduct&quot;&gt;행동 강령으로&lt;/a&gt; 대체되었습니다. 특정 기술 요구 사항을 준수하는 .</target>
        </trans-unit>
        <trans-unit id="9f4b3397370025bf1fdba593094ae6486be0fecb" translate="yes" xml:space="preserve">
          <source>This document was originally created in early 2004 when SQLite version 2 was still in widespread use and was written to introduce the new concepts of SQLite version 3 to readers who were already familiar with SQLite version 2. But these days, most readers of this document have probably never seen SQLite version 2 and are only familiar with SQLite version 3. Nevertheless, this document continues to serve as an authoritative reference to how database file locking works in SQLite version 3.</source>
          <target state="translated">이 문서는 원래 2004 년 초에 SQLite 버전 2가 널리 보급되어 이미 SQLite 버전 2에 익숙한 독자들에게 SQLite 버전 3의 새로운 개념을 소개하기 위해 작성되었습니다. 그러나 오늘날이 문서의 독자 대부분은 SQLite 버전 2는 본 적이 없으며 SQLite 버전 3에만 익숙합니다. 그럼에도 불구하고이 문서는 데이터베이스 파일 잠금이 SQLite 버전 3에서 작동하는 방식에 대한 권위있는 참조로 계속 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="efa34a5056d6c01d0548b0f2be11ce7b6109059b" translate="yes" xml:space="preserve">
          <source>This experimental &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; provides information about a single &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; in a database file, such as the depth, and estimated number of pages and number of entries, and so forth.</source>
          <target state="translated">이 실험적인 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 는 데이터베이스 파일에서 깊이, 예상 페이지 수 및 항목 수 등과 같은 단일 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 에 대한 정보를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="0902999854d1422342b1343c7db1457520c25f82" translate="yes" xml:space="preserve">
          <source>This facility is provided for WinRT which does not have an OS mechanism for reading or changing the current working directory. The use of this pragma in any other context is discouraged and may be disallowed in future releases.</source>
          <target state="translated">이 기능은 현재 작업 디렉토리를 읽거나 변경하기위한 OS 메커니즘이없는 WinRT에 제공됩니다. 다른 상황에서이 pragma를 사용하는 것은 권장되지 않으며 향후 릴리스에서는 허용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a16ab751fe0e625eef00360bec04f5c6e2724bea" translate="yes" xml:space="preserve">
          <source>This feature could be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;information schema&lt;/a&gt; by first creating a separate schema using</source>
          <target state="translated">이 기능은 먼저 다음을 사용하여 별도의 스키마를 만들어 &lt;a href=&quot;https://en.wikipedia.org/wiki/Information_schema&quot;&gt;정보 스키마&lt;/a&gt; 를 구현하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc13030cdb5706fbe971e91e53cd50c5af469f0" translate="yes" xml:space="preserve">
          <source>This feature is experimental and is subject to change. Further documentation will become available if and when the table-valued functions for PRAGMAs feature becomes officially supported.</source>
          <target state="translated">이 기능은 실험용이며 변경 될 수 있습니다. PRAGMAs 기능에 대한 테이블 반환 함수가 공식적으로 지원되는 경우 추가 설명서를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18abc550835bcdb0029b1a86390eaca991d2351b" translate="yes" xml:space="preserve">
          <source>This field contains a checksum value, calculated based on the contents of the journaled database page data (the previous field) and the values stored in the</source>
          <target state="translated">이 필드에는 저널링 된 데이터베이스 페이지 데이터의 내용 (이전 필드)과</target>
        </trans-unit>
        <trans-unit id="e3760b531cd8fa332f7ee70ed518883a43ad81f8" translate="yes" xml:space="preserve">
          <source>This field contains the original data for the page, exactly as it appeared in the database file before the</source>
          <target state="translated">이 필드에는 페이지 이전의 데이터베이스 파일에 표시된대로 페이지의 원래 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae121150e2dd424e68324ff08f7e0c6c1d0a2a0" translate="yes" xml:space="preserve">
          <source>This field holds a phonetic code derived from coalesce(k1,word). Letters that have similar sounds are mapped into the same symbol. For example, all vowels and vowel clusters become the single symbol &quot;A&quot;. And the letters &quot;p&quot;, &quot;b&quot;, &quot;f&quot;, and &quot;v&quot; all become &quot;B&quot;. All nasal sounds are represented as &quot;N&quot;. And so forth. The mapping is based on ideas found in Soundex, Metaphone, and other long-standing phonetic matching systems. This key can be generated by the function spellfix1_phonehash(X). Hence: k2 = spellfix1_phonehash(coalesce(k1,word))</source>
          <target state="translated">이 필드는 coalesce (k1, word)에서 파생 된 음성 코드를 보유합니다. 비슷한 소리를 가진 글자는 같은 기호로 매핑됩니다. 예를 들어 모든 모음과 모음 클러스터는 단일 기호 &quot;A&quot;가됩니다. 문자 &quot;p&quot;, &quot;b&quot;, &quot;f&quot;및 &quot;v&quot;는 모두 &quot;B&quot;가됩니다. 모든 코 소리는 &quot;N&quot;으로 표시됩니다. 기타 등등. 매핑은 Soundex, Metaphone 및 기타 오랜 음성 일치 시스템에서 발견 된 아이디어를 기반으로합니다. 이 키는 spellfix1_phonehash (X) 함수로 생성 할 수 있습니다. 따라서 : k2 = spellfix1_phonehash (coalesce (k1, word))</target>
        </trans-unit>
        <trans-unit id="7981d385aa4b9ca4b4f9844539885d4afde0da8a" translate="yes" xml:space="preserve">
          <source>This field may contain either an integer or a text field consisting of two integers separated by a space character (unicode codepoint 0x20).</source>
          <target state="translated">이 필드는 정수 또는 공백 문자 (유니 코드 코드 포인트 0x20)로 구분 된 두 개의 정수로 구성된 텍스트 필드를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de591efb54fdb80ffddf1b7c9525e6ab9978c95c" translate="yes" xml:space="preserve">
          <source>This field must be set one of integer values 0 and 8, or else to NULL.</source>
          <target state="translated">이 필드는 정수 값 0과 8 중 하나 또는 NULL로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e75b74f43def5b21dd19f54d176219e2332fba0" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;database page count&lt;/b&gt;, is set to the number of pages that the</source>
          <target state="translated">&lt;b&gt;데이터베이스 페이지&lt;/b&gt; 수인 이 필드는 &lt;b&gt;페이지 수로&lt;/b&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4ce138fa916045f081e00c343e7762b51298df38" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;locking page number&lt;/b&gt;, is always set to the page number of the database</source>
          <target state="translated">이 &lt;b&gt;페이지 인 잠금 페이지 번호&lt;/b&gt; 는 항상 데이터베이스의 페이지 번호로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="825eef8a444b33cb8e93566d91167c3eabd02df8" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;record count&lt;/b&gt;, is set to the number of</source>
          <target state="translated">이 필드 인 &lt;b&gt;레코드&lt;/b&gt; 수는</target>
        </trans-unit>
        <trans-unit id="f631e740c08280177f2a7f6f8390e6ab3758fda5" translate="yes" xml:space="preserve">
          <source>This field, the &lt;b&gt;sector size&lt;/b&gt;, is set to the</source>
          <target state="translated">이 필드 인 &lt;b&gt;섹터 크기&lt;/b&gt; 는</target>
        </trans-unit>
        <trans-unit id="caf63c1c58b9f87489297844a819efb8d6633a40" translate="yes" xml:space="preserve">
          <source>This flag causes comma-separators to be added to the output of %d and %i substitutions, between every 3 digits from the left. This can help humans to more easily discern the magnitude of large integer values. For example, the value 2147483647 would be rendered as &quot;2147483647&quot; using &quot;%d&quot; but would appear as &quot;2,147,483,647&quot; with &quot;%,d&quot;. This flag is a non-standard extension.</source>
          <target state="translated">이 플래그는 쉼표로 구분자가 왼쪽에서 3 자리마다 % d 및 % i 대체의 출력에 추가되도록합니다. 이를 통해 인간은 큰 정수 값의 크기를 더 쉽게 식별 할 수 있습니다. 예를 들어, 값 2147483647은 &quot;% d&quot;를 사용하여 &quot;2147483647&quot;으로 렌더링되지만 &quot;%, d&quot;와 함께 &quot;2,147,483,647&quot;으로 나타납니다. 이 플래그는 비표준 확장입니다.</target>
        </trans-unit>
        <trans-unit id="a5b80382a268dfe85ecc58efaaccd407cc41e4b2" translate="yes" xml:space="preserve">
          <source>This function adds a set of changes to the session object that could be used to update the table in database zFrom (call this the &quot;from-table&quot;) so that its content is the same as the table attached to the session object (call this the &quot;to-table&quot;). Specifically:</source>
          <target state="translated">이 함수는 zFrom 데이터베이스에서 테이블을 업데이트하는 데 사용할 수있는 일련의 변경 사항을 세션 오브젝트에 추가하여 (이를 &quot;from-table&quot;이라고 함) 내용이 세션 오브젝트에 첨부 된 테이블과 동일하도록합니다 (이것을 호출하십시오) &quot;테이블까지&quot;). 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="3b5d7e99038e4d5b072061176057f97dc299323e" translate="yes" xml:space="preserve">
          <source>This function and xPhraseNextColumn() are similar to the xPhraseFirst() and xPhraseNext() APIs described above. The difference is that instead of iterating through all instances of a phrase in the current row, these APIs are used to iterate through the set of columns in the current row that contain one or more instances of a specified phrase. For example:</source>
          <target state="translated">이 함수 및 xPhraseNextColumn ()은 위에서 설명한 xPhraseFirst () 및 xPhraseNext () API와 유사합니다. 차이점은 현재 행에서 구의 모든 인스턴스를 반복하는 대신이 API를 사용하여 지정된 구의 하나 이상의 인스턴스를 포함하는 현재 행의 열 세트를 반복합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80988b461d2df6302b49f4dceec8b27b005d6908" translate="yes" xml:space="preserve">
          <source>This function attempts to retrieve the text of column iCol of the current document. If successful, (*pz) is set to point to a buffer containing the text in utf-8 encoding, (*pn) is set to the size in bytes (not characters) of the buffer and SQLITE_OK is returned. Otherwise, if an error occurs, an SQLite error code is returned and the final values of (*pz) and (*pn) are undefined.</source>
          <target state="translated">이 함수는 현재 문서의 iCol 열의 텍스트를 검색하려고 시도합니다. 성공하면 (* pz)가 utf-8 인코딩의 텍스트를 포함하는 버퍼를 가리 키도록 설정되고 (* pn)이 버퍼의 크기 (문자가 아닌)로 설정되고 SQLITE_OK가 리턴됩니다. 그렇지 않으면 오류가 발생하면 SQLite 오류 코드가 리턴되고 (* pz) 및 (* pn)의 최종 값이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28a6bb3de337284487682e360c8a725a543916e4" translate="yes" xml:space="preserve">
          <source>This function attempts to scan the WAL file associated with database zDb of database handle db and make all valid snapshots available to sqlite3_snapshot_open(). It is an error if there is already a read transaction open on the database, or if the database is not a WAL mode database.</source>
          <target state="translated">이 함수는 데이터베이스 핸들 db의 데이터베이스 zDb와 연관된 WAL 파일을 스캔하고 sqlite3_snapshot_open ()에서 유효한 모든 스냅 샷을 사용할 수있게합니다. 데이터베이스에 이미 읽기 트랜잭션이 열려 있거나 데이터베이스가 WAL 모드 데이터베이스가 아닌 경우 오류입니다.</target>
        </trans-unit>
        <trans-unit id="27eaa9cd67b4a77bfd0fe868cf2e24b92591db2f" translate="yes" xml:space="preserve">
          <source>This function causes all database schemas to be read from disk and parsed, if that has not already been done, and returns an error if any errors are encountered while loading the schema.</source>
          <target state="translated">이 함수는 디스크에서 모든 데이터베이스 스키마를 읽고 구문 분석합니다 (아직 수행되지 않은 경우). 스키마를로드하는 동안 오류가 발생하면 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7d871089984a2a55cb6c89bf16fcd0bc4a023753" translate="yes" xml:space="preserve">
          <source>This function causes any pending database operation to abort and return at its earliest opportunity. This routine is typically called in response to a user action such as pressing &quot;Cancel&quot; or Ctrl-C where the user wants a long query operation to halt immediately.</source>
          <target state="translated">이 기능을 사용하면 보류중인 데이터베이스 작업이 최대한 빨리 중단되고 반환됩니다. 이 루틴은 일반적으로 사용자가 긴 쿼리 조작을 즉시 중지하려는 &quot;취소&quot;또는 Ctrl-C 누르기와 같은 사용자 조치에 대한 응답으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="84f0a277d8eb36da2c14763cce01f3221d3f3be5" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 닫습니다 . BLOB 핸들은 무조건 닫힙니다. 이 루틴이 오류 코드를 리턴하더라도 핸들은 여전히 ​​닫힙니다.</target>
        </trans-unit>
        <trans-unit id="c52c6ec750ee5ca8bf8f3568aa703ede60385a7a" translate="yes" xml:space="preserve">
          <source>This function closes an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt;. The BLOB handle is closed unconditionally. Even if this routine returns an error code, the handle is still closed.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 닫습니다 . BLOB 핸들은 무조건 닫힙니다. 이 루틴이 오류 코드를 리턴하더라도 핸들은 여전히 ​​닫힙니다.</target>
        </trans-unit>
        <trans-unit id="dcb5cb2e9c08e0b9f3037428dbe4920c74c2b405" translate="yes" xml:space="preserve">
          <source>This function combines the two input changesets using an sqlite3_changegroup object. Calling it produces similar results as the following code fragment:</source>
          <target state="translated">이 함수는 sqlite3_changegroup 객체를 사용하여 두 개의 입력 변경 세트를 결합합니다. 호출하면 다음 코드 조각과 유사한 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4624a9200d853f2e32a44b7a98a35021843efd43" translate="yes" xml:space="preserve">
          <source>This function does not change the order in which changes appear within the changeset. It merely reverses the sense of each individual change.</source>
          <target state="translated">이 기능은 변경 세트 내에서 변경이 나타나는 순서를 변경하지 않습니다. 그것은 단지 각각의 개별적인 변화의 감각을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="d7cbc42833b432d19d25054e50c1379caf39e23d" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 함수 가 리턴 한 데이터베이스 핸들 오류 코드 또는 메시지를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2c015e6f1fde0378f350b940649e6bb977266a40" translate="yes" xml:space="preserve">
          <source>This function does not set the database handle error code or message returned by the &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; functions.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 함수 가 리턴 한 데이터베이스 핸들 오류 코드 또는 메시지를 설정하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6303b7057e9914dac072c1b4a0b74b270e4dc698" translate="yes" xml:space="preserve">
          <source>This function fails with SQLITE_ERROR if any of the following are true:</source>
          <target state="translated">다음 중 하나에 해당하면이 함수는 SQLITE_ERROR와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="870ceb33e21de66e2ccc8a5ce1caa06026ee0a3c" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid () SQL 함수&lt;/a&gt; 를 통해 SQL 문에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ed24a06a5fab16f67d5f77a45744a9d31cdf2e0" translate="yes" xml:space="preserve">
          <source>This function is accessible to SQL statements via the &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid() SQL function&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;lang_corefunc#last_insert_rowid&quot;&gt;last_insert_rowid () SQL 함수&lt;/a&gt; 를 통해 SQL 문에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ba56f71e7eaf44d8bff350353ce98793aa844743" translate="yes" xml:space="preserve">
          <source>This function is expected to tokenize the nText byte string indicated by argument pText. pText may or may not be nul-terminated. The first argument passed to this function is a pointer to an Fts5Tokenizer object returned by an earlier call to xCreate().</source>
          <target state="translated">이 함수는 pText 인수로 표시되는 nText 바이트 문자열을 토큰 화해야합니다. pText는 널 종료되거나 종료되지 않을 수 있습니다. 이 함수에 전달 된 첫 번째 인수는 이전 xCreate () 호출로 반환 된 Fts5Tokenizer 객체에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c0f6fbfd19fbfc44b1560cfd2b05948b7fed7c50" translate="yes" xml:space="preserve">
          <source>This function is invoked to delete a tokenizer handle previously allocated using xCreate(). Fts5 guarantees that this function will be invoked exactly once for each successful call to xCreate().</source>
          <target state="translated">이 함수는 xCreate ()를 사용하여 이전에 할당 된 토크 나이저 핸들을 삭제하기 위해 호출됩니다. Fts5는 xCreate ()를 성공적으로 호출 할 때마다이 함수가 정확히 한 번만 호출되도록합니다.</target>
        </trans-unit>
        <trans-unit id="fcde84651450f2b10b0843fe43cf87cdc47c8be9" translate="yes" xml:space="preserve">
          <source>This function is used to &quot;invert&quot; a changeset object. Applying an inverted changeset to a database reverses the effects of applying the uninverted changeset. Specifically:</source>
          <target state="translated">이 기능은 변경 세트 객체를 &quot;반전&quot;시키는 데 사용됩니다. 반전 된 변경 세트를 데이터베이스에 적용하면 반전되지 않은 변경 세트를 적용한 결과가 반대로됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="29ae82377275c7b1f1384fc8e2d212e8da0789d4" translate="yes" xml:space="preserve">
          <source>This function is used to allocate and initialize a tokenizer instance. A tokenizer instance is required to actually tokenize text.</source>
          <target state="translated">이 함수는 토크 나이저 인스턴스를 할당하고 초기화하는 데 사용됩니다. 텍스트를 실제로 토큰 화하려면 토크 나이저 인스턴스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="24b74a85f4b47c195bc0b6fe21af9724e0d1ed94" translate="yes" xml:space="preserve">
          <source>This function is used to concatenate two changesets, A and B, into a single changeset. The result is a changeset equivalent to applying changeset A followed by changeset B.</source>
          <target state="translated">이 기능은 두 개의 변경 세트 A와 B를 단일 변경 세트로 연결하는 데 사용됩니다. 결과는 변경 세트 A를 적용한 다음 변경 세트 B를 적용하는 것과 동일한 변경 세트입니다.</target>
        </trans-unit>
        <trans-unit id="69eb445f771165e9cf3bdc2eef0ebd4932045f16" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()로&lt;/a&gt; 할당 된 반복자를 마무리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b35815e34122016382887fcb96a49b58070b37da" translate="yes" xml:space="preserve">
          <source>This function is used to finalize an iterator allocated with &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()로&lt;/a&gt; 할당 된 반복자를 마무리하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2cfec4fd8864b11036478634ce0c848102b439e0" translate="yes" xml:space="preserve">
          <source>This function is used to find which columns comprise the PRIMARY KEY of the table modified by the change that iterator pIter currently points to. If successful, *pabPK is set to point to an array of nCol entries, where nCol is the number of columns in the table. Elements of *pabPK are set to 0x01 if the corresponding column is part of the tables primary key, or 0x00 if it is not.</source>
          <target state="translated">이 함수는 반복자 pIter가 현재 가리키는 변경에 의해 수정 된 테이블의 PRIMARY KEY를 구성하는 열을 찾는 데 사용됩니다. 성공하면 * pabPK는 nCol 항목의 배열을 가리 키도록 설정됩니다. 여기서 nCol은 테이블의 열 수입니다. * pabPK의 요소는 해당 컬럼이 테이블 기본 키의 일부인 경우 0x01로 설정되고 그렇지 않은 경우 0x00으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e114c8bad40f12de287f68c473424a8e6e66648d" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">이 함수는 기존 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 이동 하여 동일한 데이터베이스 테이블의 다른 행을 가리 키도록하는 데 사용됩니다 . 새 행은 두 번째 인수로 전달 된 rowid 값으로 식별됩니다. 행만 변경할 수 있습니다. Blob 핸들이 열려있는 데이터베이스, 테이블 및 열은 동일하게 유지됩니다. 기존 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 새 행으로 옮기는 것이 기존 핸들 을 닫고 새 핸들을 여는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="308c798f0a295eb0c4645e5b7f42fbabbc544780" translate="yes" xml:space="preserve">
          <source>This function is used to move an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; so that it points to a different row of the same database table. The new row is identified by the rowid value passed as the second argument. Only the row can be changed. The database, table and column on which the blob handle is open remain the same. Moving an existing &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; to a new row is faster than closing the existing handle and opening a new one.</source>
          <target state="translated">이 함수는 기존 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 이동 하여 동일한 데이터베이스 테이블의 다른 행을 가리 키도록하는 데 사용됩니다 . 새 행은 두 번째 인수로 전달 된 rowid 값으로 식별됩니다. 행만 변경할 수 있습니다. Blob 핸들이 열려있는 데이터베이스, 테이블 및 열은 동일하게 유지됩니다. 기존 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 새 행으로 옮기는 것이 기존 핸들 을 닫고 새 핸들을 여는 것보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="4b885ede0001de9f5c638f038a437a23ced24dd6" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 호출자 제공 버퍼로 데이터를 읽는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 열린 BLOB에서 N 바이트의 데이터가 버퍼 Z에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="21272222209bb70a086675dada0f2b2f97f0f8e4" translate="yes" xml:space="preserve">
          <source>This function is used to read data from an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; into a caller-supplied buffer. N bytes of data are copied into buffer Z from the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 호출자 제공 버퍼로 데이터를 읽는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 열린 BLOB에서 N 바이트의 데이터가 버퍼 Z에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="9f3667d662139e493e6cf3b56b1b782512c8bc44" translate="yes" xml:space="preserve">
          <source>This function is used to retrieve the total number of rows in the table. In other words, the same value that would be returned by:</source>
          <target state="translated">이 함수는 테이블에서 총 행 수를 검색하는 데 사용됩니다. 즉, 다음과 같은 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b651a758789810b674e3ae5146e089dc27672b54" translate="yes" xml:space="preserve">
          <source>This function is used to set, clear or query the session object indirect flag. If the second argument passed to this function is zero, then the indirect flag is cleared. If it is greater than zero, the indirect flag is set. Passing a value less than zero does not modify the current value of the indirect flag, and may be used to query the current state of the indirect flag for the specified session object.</source>
          <target state="translated">이 함수는 세션 객체 간접 플래그를 설정, 해제 또는 쿼리하는 데 사용됩니다. 이 함수에 전달 된 두 번째 인수가 0이면 간접 플래그가 지워집니다. 0보다 크면 간접 플래그가 설정됩니다. 0보다 작은 값을 전달해도 간접 플래그의 현재 값은 수정되지 않으며 지정된 세션 객체에 대한 간접 플래그의 현재 상태를 쿼리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a1761e9d0e1762347b4943de9494b5f2f5f8cc" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 호출자 제공 버퍼에서 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들에&lt;/a&gt; 데이터를 쓰는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 N 바이트의 데이터가 버퍼 Z에서 열린 BLOB으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="959745cc981e8eae46a52bb0e5894da3fa5cff9f" translate="yes" xml:space="preserve">
          <source>This function is used to write data into an open &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; from a caller-supplied buffer. N bytes of data are copied from the buffer Z into the open BLOB, starting at offset iOffset.</source>
          <target state="translated">이 함수는 호출자 제공 버퍼에서 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들에&lt;/a&gt; 데이터를 쓰는 데 사용됩니다 . 오프셋 iOffset에서 시작하여 N 바이트의 데이터가 버퍼 Z에서 열린 BLOB으로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="1483892d5daffd0f4eda8275dee22e2f701b626d" translate="yes" xml:space="preserve">
          <source>This function is used, along with type Fts5PhraseIter and the xPhraseNext method, to iterate through all instances of a single query phrase within the current row. This is the same information as is accessible via the xInstCount/xInst APIs. While the xInstCount/xInst APIs are more convenient to use, this API may be faster under some circumstances. To iterate through instances of phrase iPhrase, use the following code:</source>
          <target state="translated">이 함수는 Fts5PhraseIter 유형 및 xPhraseNext 메소드와 함께 사용되어 현재 행 내에서 단일 쿼리 구문의 모든 인스턴스를 반복합니다. 이는 xInstCount / xInst API를 통해 액세스 할 수있는 정보와 동일합니다. xInstCount / xInst API를 사용하는 것이 더 편리하지만 일부 상황에서는이 API가 더 빠를 수 있습니다. 문구 iPhrase의 인스턴스를 반복하려면 다음 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2e540303404a447a74d8a0d678f9bad1c3c4058d" translate="yes" xml:space="preserve">
          <source>This function maps every page number into an integer between 0 and 8191 inclusive. The aHash field of each 32768-byte shm file unit maps P values into indexes of the aPgno field of the same unit as follows:</source>
          <target state="translated">이 함수는 모든 페이지 번호를 0에서 8191 사이의 정수로 매핑합니다. 각 32768 바이트 shm 파일 단위의 aHash 필드는 다음과 같이 P 값을 동일한 단위의 aPgno 필드 색인으로 맵핑합니다.</target>
        </trans-unit>
        <trans-unit id="b474b368c95d2db3e02f8d968fb517ea9f808a38" translate="yes" xml:space="preserve">
          <source>This function may also return SQLITE_NOMEM. If it is called with the database handle in autocommit mode but fails for some other reason, whether or not a read transaction is opened on schema S is undefined.</source>
          <target state="translated">이 함수는 SQLITE_NOMEM을 반환 할 수도 있습니다. 자동 커미트 모드에서 데이터베이스 핸들로 호출되었지만 다른 이유로 실패한 경우 스키마 S에서 읽기 트랜잭션이 열리는 지 여부는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d107c7c4ed710ea3330eefcfd44db3b75a5ff363" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메소드에 의해 호출되어 가상 테이블 인터페이스의 다양한 측면을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="436450a55b61a947a304f65e4e9be131ade57dc9" translate="yes" xml:space="preserve">
          <source>This function may be called by either the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation to configure various facets of the virtual table interface.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 메소드에 의해 호출되어 가상 테이블 인터페이스의 다양한 측면을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892823d34401462a7936657244cacf73ba9d16a7" translate="yes" xml:space="preserve">
          <source>This function may be quite inefficient if used with an FTS5 table created with the &quot;columnsize=0&quot; option.</source>
          <target state="translated">이 함수는 &quot;columnsize = 0&quot;옵션으로 작성된 FTS5 테이블과 함께 사용하는 경우 비효율적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c728fb74daea7a42a0d0a89203b1fbf38464ae" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="651e6e671ae629015a6ac3d4f4c461902dc827bb" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;c_fail&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 INSERT 또는 UPDATE 조작에 대한 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 . 리턴 된 값은 &lt;a href=&quot;c_fail&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt; , &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;c_fail&quot;&gt;SQLITE_FAIL&lt;/a&gt; , &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는&lt;a href=&quot;c_fail&quot;&gt;&lt;/a&gt; 은 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드에 대한 호출을 트리거 한 SQL 문의 &lt;a href=&quot;../lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드 에 따라 SQLITE_REPLACE .</target>
        </trans-unit>
        <trans-unit id="a16a26f00d528f2a67fb084167cd62426f17fa64" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a48f675a9216b80779894ce906eb64bd5d832356" translate="yes" xml:space="preserve">
          <source>This function may only be called from within a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementation for an INSERT or UPDATE operation. The value returned is one of &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt;, &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt;, &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_REPLACE&lt;/a&gt;, according to the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; mode of the SQL statement that triggered the call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;.</source>
          <target state="translated">이 함수는 INSERT 또는 UPDATE 조작에 대한 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 호출 내에서만 호출 할 수 있습니다 . 리턴 된 값 은 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드에 대한 호출을 트리거 한 SQL 문의 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 모드 에 따라 &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_ROLLBACK&lt;/a&gt; , &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; , &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;SQLITE_FAIL&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는&lt;a href=&quot;#SQLITE_FAIL&quot;&gt; SQLITE_REPLACE&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="9f4b868b197498e92e7be98a22186e8a9d0ec008" translate="yes" xml:space="preserve">
          <source>This function may only be called with an iterator passed to an SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case it sets the output variable to the total number of known foreign key violations in the destination database and returns SQLITE_OK.</source>
          <target state="translated">이 함수는 반복자가 SQLITE_CHANGESET_FOREIGN_KEY 충돌 처리기 콜백으로 전달 된 경우에만 호출 할 수 있습니다. 이 경우 출력 변수를 대상 데이터베이스에서 알려진 외래 키 위반의 총 수로 설정하고 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6aefcc013460f98a7eaca0c2faea39955530e82b" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수로 작성된 반복자와 함께 만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러 콜백으로 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 리턴되고 호출은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b40997bef104535dd0852dc311c81d541b71952" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수로 작성된 반복자와 함께 만 사용할 수 있습니다 . &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 핸들러 콜백으로 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 리턴되고 호출은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="81dcfaa530f9bc3b0cf4ff6ac3dd711bd8249deb" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수에 의해 생성 된 이터레이터에서만 사용할 수 있습니다 . &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 처리기 콜백에 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 반환되고 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2a7a3750664d2ff5967d620601e32e54729a198" translate="yes" xml:space="preserve">
          <source>This function may only be used with iterators created by the function &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;. If it is called on an iterator passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, SQLITE_MISUSE is returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수에 의해 생성 된 이터레이터에서만 사용할 수 있습니다 . &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 의해 충돌 처리기 콜백에 전달 된 반복자 에서 호출되면 SQLITE_MISUSE가 반환되고 호출은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd3cebc479567b581aaea382b042cd658c5a6fd2" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">이 함수는 BLOB의 내용 만 수정할 수 있습니다. 이 API를 사용하여 BLOB의 크기를 늘릴 수는 없습니다. BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다. BLOB의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 . N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc4415e783325c61d6eb500d3a2195a9814914cb" translate="yes" xml:space="preserve">
          <source>This function may only modify the contents of the BLOB; it is not possible to increase the size of a BLOB using this API. If offset iOffset is less than N bytes from the end of the BLOB, &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written. The size of the BLOB (and hence the maximum value of N+iOffset) can be determined using the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface. If N or iOffset are less than zero &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; is returned and no data is written.</source>
          <target state="translated">이 함수는 BLOB의 내용 만 수정할 수 있습니다. 이 API를 사용하여 BLOB의 크기를 늘릴 수는 없습니다. BLOB 끝에서 오프셋 iOffset이 N 바이트보다 작 으면 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다. BLOB의 크기 (따라서 N + iOffset의 최대 값)는 &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 인터페이스를 사용하여 판별 할 수 있습니다 . N 또는 iOffset이 0보다 작은 경우 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 가 리턴되고 데이터가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e611001e69d55801c25d56986ec39153bc754108" translate="yes" xml:space="preserve">
          <source>This function returns SQLITE_OK if successful, or an SQLite error code otherwise.</source>
          <target state="translated">이 함수는 성공하면 SQLITE_OK를, 그렇지 않으면 SQLite 오류 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1c2517d3cf09b0cdb52fd7581d781f148fee8f8f" translate="yes" xml:space="preserve">
          <source>This function returns the number of rows modified, inserted or deleted by the most recently completed INSERT, UPDATE or DELETE statement on the database connection specified by the only parameter. Executing any other type of SQL statement does not modify the value returned by this function.</source>
          <target state="translated">이 함수는 유일한 매개 변수로 지정된 데이터베이스 연결에서 가장 최근에 완료된 INSERT, UPDATE 또는 DELETE 문에 의해 수정, 삽입 또는 삭제 된 행 수를 리턴합니다. 다른 유형의 SQL 문을 실행해도이 함수가 리턴 한 값은 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b76b4997f936492171845d7baebab3de049f79f" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">이 함수는 트리거 프로그램의 일부로 실행 된 행을 포함하여 데이터베이스 연결이 열린 후 완료된 모든 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;../lang_delete&quot;&gt;DELETE&lt;/a&gt; 문에 의해 삽입, 수정 또는 삭제 된 총 행 수를 리턴합니다 . 다른 유형의 SQL 문을 실행해도 sqlite3_total_changes ()에 의해 리턴 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="adf4834644160b8bd2e8b37a1e591e556b1afb6a" translate="yes" xml:space="preserve">
          <source>This function returns the total number of rows inserted, modified or deleted by all &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements completed since the database connection was opened, including those executed as part of trigger programs. Executing any other type of SQL statement does not affect the value returned by sqlite3_total_changes().</source>
          <target state="translated">이 함수는 트리거 프로그램의 일부로 실행 된 행을 포함하여 데이터베이스 연결이 열린 후 완료된 모든 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문에 의해 삽입, 수정 또는 삭제 된 총 행 수를 리턴합니다 . 다른 유형의 SQL 문을 실행해도 sqlite3_total_changes ()에 의해 리턴 된 값에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8213d08301f09db1801edcdcc6b6898d5bedde17" translate="yes" xml:space="preserve">
          <source>This function sets the database handle error code and message.</source>
          <target state="translated">이 함수는 데이터베이스 핸들 오류 코드 및 메시지를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="dc027be02604df0d93fb0c7fd87bd8fb650c8db3" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수를 사용하여 만든 반복자에서만 호출해야 합니다. 응용 프로그램에 의해 충돌 핸들러에 전달 반복자로이 함수를 호출하는 경우 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;) sqlite3changeset_apply (&lt;/a&gt; , &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE은&lt;/a&gt; 즉시 반환하고 통화는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2df7e3d1377d5e8297acef52974006d62b57703e" translate="yes" xml:space="preserve">
          <source>This function should only be called on iterators created using the &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt; function. If an application calls this function with an iterator passed to a conflict-handler by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is immediately returned and the call has no effect.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; 함수를 사용하여 만든 반복자에서만 호출해야 합니다. 응용 프로그램에 의해 충돌 핸들러에 전달 반복자로이 함수를 호출하는 경우 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;) sqlite3changeset_apply (&lt;/a&gt; , &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE은&lt;/a&gt; 즉시 반환하고 통화는 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6644624c994928cadd1595cf7f165d3a9a2ca4f0" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; 에 의해 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_CHANGESET_CONFLICT&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; 를 사용하여 충돌 핸들러 콜백에 전달 된 반복자 객체에만 사용해야합니다 . 이 함수가 다른 반복자에서 호출되면 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="548141af0246ca4eef33b575f89c5796207c5a05" translate="yes" xml:space="preserve">
          <source>This function should only be used with iterator objects passed to a conflict-handler callback by &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt; with either &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; or &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt;. If this function is called on any other iterator, &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()&lt;/a&gt; 에 의해 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_DATA&lt;/a&gt; 또는 &lt;a href=&quot;c_changeset_conflict&quot;&gt;SQLITE_CHANGESET_CONFLICT&lt;/a&gt; 를 사용하여 충돌 핸들러 콜백에 전달 된 반복자 객체에만 사용해야합니다 . 이 함수가 다른 반복자에서 호출되면 &lt;a href=&quot;../rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="aabca26792420e3dedde38828f3aa35b5f3a0612" translate="yes" xml:space="preserve">
          <source>This generates a file named &lt;b&gt;ex1.dump.gz&lt;/b&gt; that contains everything you need to reconstruct the database at a later time, or on another machine. To reconstruct the database, just type:</source>
          <target state="translated">그러면 나중에 또는 다른 시스템에서 데이터베이스를 재구성하는 데 필요한 모든 것이 포함 된 &lt;b&gt;ex1.dump.gz&lt;/b&gt; 라는 파일이 생성 됩니다. 데이터베이스를 재구성하려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="311cc4fab23f9723b1a4efe300a30ad45967a776" translate="yes" xml:space="preserve">
          <source>This graph is acyclic. And we assume that the mtime of every child checkin is no less than the mtime of all its parents. But unlike the earlier examples, this graph might have multiple paths of differing lengths between any two checkins.</source>
          <target state="translated">이 그래프는 비 주기적입니다. 그리고 우리는 모든 어린이 체크인의 mtime이 모든 부모의 mtime 이상이라고 가정합니다. 그러나 이전 예제와 달리이 그래프에는 두 체크인 사이에 길이가 다른 여러 경로가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0e2bf6a1863b49e18b3cb7db1999e03d428ead" translate="yes" xml:space="preserve">
          <source>This historical version numbering system used a two-, three-, or four-number version: W.X, W.X.Y, or W.X.Y.Z. W was the file format: 1 or 2 or 3. X was the major version. Y was the minor version. Z was used only for patch releases to fix bugs.</source>
          <target state="translated">이 히스토리 버전 번호 매기기 시스템은 2, 3 또는 4 번호 버전을 사용했습니다. WX, WXY 또는 WXYZ W는 파일 형식 : 1 또는 2 또는 3입니다. X는 주 버전입니다. Y는 부 버전이었습니다. Z는 버그를 수정하기 위해 패치 릴리스에만 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="9f4676d0afd51e8fa37c9aa0283801b026a1b72b" translate="yes" xml:space="preserve">
          <source>This instruction causes the VM to halt.</source>
          <target state="translated">이 명령으로 인해 VM이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="fdc444b74a87e964e8bcc2b42a370bbc5df69c15" translate="yes" xml:space="preserve">
          <source>This instruction makes a deep copy of the value. A duplicate is made of any string or blob constant. See also &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;.</source>
          <target state="translated">이 명령어는 값의 깊은 사본을 만듭니다. 문자열이나 얼룩 상수로 복제됩니다. &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dad5db056b0ca8e5a487c8ab6c8e6dc7e0f2672" translate="yes" xml:space="preserve">
          <source>This instruction makes a shallow copy of the value. If the value is a string or blob, then the copy is only a pointer to the original and hence if the original changes so will the copy. Worse, if the original is deallocated, the copy becomes invalid. Thus the program must guarantee that the original will not change during the lifetime of the copy. Use &lt;a href=&quot;opcode#Copy&quot;&gt;Copy&lt;/a&gt; to make a complete copy.</source>
          <target state="translated">이 명령어는 값의 얕은 사본을 만듭니다. 값이 문자열 또는 얼룩 인 경우 사본은 원본에 대한 포인터 일 뿐이므로 원본이 변경되면 사본도 변경됩니다. 게다가 원본을 할당 해제하면 사본이 유효하지 않게됩니다. 따라서 프로그램은 사본의 수명 동안 원본이 변경되지 않도록 보장해야합니다. 전체 &lt;a href=&quot;opcode#Copy&quot;&gt;복사&lt;/a&gt; 를 하려면 복사 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4df251f100bd98635ac20986854a4f9d3558bf05" translate="yes" xml:space="preserve">
          <source>This instruction only works for indices. The equivalent instruction for tables is &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt;.</source>
          <target state="translated">이 지침은 인덱스에만 적용됩니다. 테이블에 해당하는 명령어는 &lt;a href=&quot;opcode#Insert&quot;&gt;Insert&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="724c5d92359b2812711bd98fdbbd0ee48ff16933" translate="yes" xml:space="preserve">
          <source>This instruction only works on tables. The equivalent instruction for indices is &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt;.</source>
          <target state="translated">이 명령어는 테이블에서만 작동합니다. 인덱스에 해당하는 명령어는 &lt;a href=&quot;opcode#IdxInsert&quot;&gt;IdxInsert&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cc342418f5a1b7e3edc039b6124a9b746a56c8e5" translate="yes" xml:space="preserve">
          <source>This instruction throws an error if the memory cell is not initially an integer.</source>
          <target state="translated">메모리 셀이 처음에 정수가 아닌 경우이 명령어는 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b8399072455bb3b6ee2757655f5f7b2af59230c1" translate="yes" xml:space="preserve">
          <source>This instruction works like &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; except that it opens the cursor in read/write mode.</source>
          <target state="translated">이 명령어 는 커서를 읽기 / 쓰기 모드로 여는 &lt;a href=&quot;opcode#OpenRead&quot;&gt;것을&lt;/a&gt; 제외하고 OpenRead 와 유사하게 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="849ae2eb4b736949542c4487e7de5222b770b0b6" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">이 인터페이스를 사용하면 다양한 구성의 크기를 연결별로 연결별로 제한 할 수 있습니다. 첫 번째 매개 변수는 한계를 설정하거나 조회 할 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 두 번째 매개 변수는 구조 클래스를 크기 제한으로 정의하는 &lt;a href=&quot;#SQLITE_LIMIT_ATTACHED&quot;&gt;제한 범주&lt;/a&gt; 중 하나입니다 . 세 번째 매개 변수는 해당 구성에 대한 새로운 한계입니다.</target>
        </trans-unit>
        <trans-unit id="6687035e8ed6fa147345334bd3634ec9e7ff5918" translate="yes" xml:space="preserve">
          <source>This interface allows the size of various constructs to be limited on a connection by connection basis. The first parameter is the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; whose limit is to be set or queried. The second parameter is one of the &lt;a href=&quot;c_limit_attached&quot;&gt;limit categories&lt;/a&gt; that define a class of constructs to be size limited. The third parameter is the new limit for that construct.</source>
          <target state="translated">이 인터페이스를 사용하면 다양한 구성의 크기를 연결별로 연결별로 제한 할 수 있습니다. 첫 번째 매개 변수는 한계를 설정하거나 조회 할 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 입니다. 두 번째 매개 변수는 구조 클래스를 크기 제한으로 정의하는 &lt;a href=&quot;c_limit_attached&quot;&gt;제한 범주&lt;/a&gt; 중 하나입니다 . 세 번째 매개 변수는 해당 구성에 대한 새로운 한계입니다.</target>
        </trans-unit>
        <trans-unit id="9256e21c25ccdf9db985fbb93738819f3d6d967d" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">이 인터페이스는 애플리케이션이 연결하는 SQLite 버전이 원하는 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 매크로 설정으로 컴파일되었는지 확인하기 위해 애플리케이션에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32dc361b08c9c60505d75103bdc36b57584e9fcf" translate="yes" xml:space="preserve">
          <source>This interface can be used by an application to make sure that the version of SQLite that it is linking against was compiled with the desired setting of the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro.</source>
          <target state="translated">이 인터페이스는 애플리케이션이 연결하는 SQLite 버전이 원하는 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 매크로 설정으로 컴파일되었는지 확인하기 위해 애플리케이션에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25ebb19095f954c7ae8a2ed499bdbfed83aadaa6" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; 와 함께 사용하여 재설정이 필요한 데이터베이스 연결과 연관된 모든 준비된 명령문을 찾을 수 있습니다 . 예를 들어, 진단 루틴에서 트랜잭션을 열린 상태로 준비된 명령문을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d607ef96133a79a067aeb3d80e9e814bdda87569" translate="yes" xml:space="preserve">
          <source>This interface can be used in combination &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; to locate all prepared statements associated with a database connection that are in need of being reset. This can be used, for example, in diagnostic routines to search for prepared statements that are holding a transaction open.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;next_stmt&quot;&gt;sqlite3_next_stmt ()&lt;/a&gt; 와 함께 사용하여 재설정이 필요한 데이터베이스 연결과 연관된 모든 준비된 명령문을 찾을 수 있습니다 . 예를 들어, 진단 루틴에서 트랜잭션을 열린 상태로 준비된 명령문을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d798abdc7bea34806f312f897736975cfc379c7c" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">이 인터페이스 는 작성된 새 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 마다 xEntryPoint () 함수가 호출되도록합니다 . 여기서 xEntryPoint ()는 모든 새 데이터베이스 연결에 자동으로로드 되는 정적으로 링크 된 &lt;a href=&quot;loadext&quot;&gt;SQLite 확장의&lt;/a&gt; 시작점 이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a18b59c5465abea2190a535937651aa6f4f67fb4" translate="yes" xml:space="preserve">
          <source>This interface causes the xEntryPoint() function to be invoked for each new &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is created. The idea here is that xEntryPoint() is the entry point for a statically linked &lt;a href=&quot;../loadext&quot;&gt;SQLite extension&lt;/a&gt; that is to be automatically loaded into all new database connections.</source>
          <target state="translated">이 인터페이스 는 작성된 새 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 마다 xEntryPoint () 함수가 호출되도록합니다 . 여기서 xEntryPoint ()는 모든 새 데이터베이스 연결에 자동으로로드 되는 정적으로 링크 된 &lt;a href=&quot;../loadext&quot;&gt;SQLite 확장의&lt;/a&gt; 시작점 이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9786ef1ecb8c77d789971c3f849525761d5d38c2" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;#sqlite3_auto_extension&quot;&gt;sqlite3_auto_extension ()을&lt;/a&gt; 사용하여 이전에 등록 된 모든 자동 확장을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="2b9c0cbd974b30f6431515e1186211476ca08e78" translate="yes" xml:space="preserve">
          <source>This interface disables all automatic extensions previously registered using &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt;.</source>
          <target state="translated">이 인터페이스는 &lt;a href=&quot;auto_extension&quot;&gt;sqlite3_auto_extension ()을&lt;/a&gt; 사용하여 이전에 등록 된 모든 자동 확장을 비활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="8736a85b1a1bcc4c800c4ff7d229eb677c9e2f70" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">이 인터페이스는 C-API &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 및 SQL 함수 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()을&lt;/a&gt; 모두 활성화하거나 비활성화합니다 . 사용 &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (dB, &lt;a href=&quot;#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION는&lt;/a&gt; ..)을 사용하거나 사용하지 않도록 설정에만 C-API입니다.</target>
        </trans-unit>
        <trans-unit id="ab1cdc93fe51f37fdae78544827ec5e365f941a3" translate="yes" xml:space="preserve">
          <source>This interface enables or disables both the C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; and the SQL function &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt;. Use &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;,..) to enable or disable only the C-API.</source>
          <target state="translated">이 인터페이스는 C-API &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 및 SQL 함수 &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension ()을&lt;/a&gt; 모두 활성화하거나 비활성화합니다 . 사용 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (dB, &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION는&lt;/a&gt; ..)을 사용하거나 사용하지 않도록 설정에만 C-API입니다.</target>
        </trans-unit>
        <trans-unit id="737d038457ffc2dd705bbf7d3e67fd74eca8f49b" translate="yes" xml:space="preserve">
          <source>This interface is not for use by applications. It exists solely for verifying the correct operation of the SQLite library. Depending on how the SQLite library is compiled, this interface might not exist.</source>
          <target state="translated">이 인터페이스는 응용 프로그램에서 사용하지 않습니다. SQLite 라이브러리의 올바른 작동을 확인하기 위해서만 존재합니다. SQLite 라이브러리가 컴파일되는 방법에 따라이 인터페이스가 존재하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec74db456b76b7c855d3cb1358c040acad3ef05" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;../compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="5c93fb0edc37eb4be652a31e1dc573b6923060cf" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;../compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="17b0e4d3f046d7d363af1d959e76e0c4d41dedec" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f287e88e4474f60d3222ad14486a836ab2470ef3" translate="yes" xml:space="preserve">
          <source>This interface is only available if SQLite is compiled with the &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; option.</source>
          <target state="translated">이 인터페이스는 SQLite가 &lt;a href=&quot;compile#enable_snapshot&quot;&gt;SQLITE_ENABLE_SNAPSHOT&lt;/a&gt; 옵션으로 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
