<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">gcov 테스트 실행과 두 번째 실제 테스트 실행이 모두 동일한 출력을 제공하는지 확인하는 것이 중요합니다. 출력의 차이는 SQLite 코드에서 정의되지 않거나 결정되지 않은 동작 (또는 버그)을 사용하거나 컴파일러의 버그를 나타냅니다. 지난 10 년 동안 SQLite는 각 GCC, Clang 및 MSVC에서 버그를 발견했습니다. 컴파일러 버그는 드물지만 발생하므로 제공된 구성으로 코드를 테스트하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">SQLite에 대해 가능한 모든 컴파일 시간 옵션 조합을 테스트하는 것은 불가능합니다. 그러나 다음 컴파일 타임 옵션 세트는 항상 완전히 테스트 된 구성입니다.</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">물론 실제 정전을 사용하여 충돌 테스트를 수행하는 것은 비현실적이므로 충돌 테스트는 시뮬레이션에서 수행됩니다. 테스트 하네스가 충돌 후 데이터베이스 파일의 상태를 시뮬레이션 할 수 있는 대체 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">명명 된 테이블이 데이터베이스에없는 경우 오류가 아닙니다. 명명 된 테이블에 PRIMARY KEY가 없으면 오류도 아닙니다. 그러나 이러한 시나리오 중 하나에서 변경 내용이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">기존 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 와 이름이 같은 테이블을 작성하는 것은 오류가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">평가하는 것이 일반적으로 유용하지 않다 &lt;em&gt;정확한&lt;/em&gt; 번 이상 같은 SQL 문을. 더 자주, 비슷한 진술을 평가하려고합니다. 예를 들어, 다른 값으로 INSERT 문을 여러 번 평가할 수 있습니다. 또는 WHERE 절에서 다른 키를 사용하여 동일한 쿼리를 여러 번 평가할 수 있습니다. 이를 수용하기 위해 SQLite는 SQL 문 이 평가되기 전에 값에 &quot;바운드&quot;된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 를 포함 할 수 있도록합니다 . 이 값은 나중에 변경 될 수 있으며 새로운 값을 사용하여 동일한 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 두 번째로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">Git에서 체크인의 자손을 찾는 것은 불가능하지 않습니다. 단지 어렵다. 예를 들어, 유닉스에서 체크인의 하위 항목을 찾기위한 명령 순서를 보여주는 &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow 페이지&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">해당 인덱스를 사용하기 위해 인덱스의 모든 열이 WHERE 절 용어에 나타날 필요는 없습니다. 그러나 사용되는 인덱스 열에는 차이가있을 수 없습니다. 따라서 위의 인덱스 예에서 c 열을 제한하는 WHERE 절 용어가없는 경우 a 열과 b 열을 제한하는 항을 인덱스와 함께 사용할 수 있지만 d-z 열을 제한하는 항은 사용할 수 없습니다. 마찬가지로, 인덱스 열이 부등식으로 만 제한되는 열의 오른쪽에있는 경우 인덱싱 목적으로 일반적으로 사용되지 않습니다. ( 예외는 아래 의 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">세션 세트 또는 패치 세트를 추출한 후 세션 오브젝트를 삭제할 필요는 없습니다. 데이터베이스 핸들에 연결된 채로 둘 수 있으며 이전과 같이 구성된 테이블의 변경 사항을 계속 모니터링합니다. 그러나 세션 객체에서 &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 또는 &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()을&lt;/a&gt; 두 번 호출하면 변경 세트 또는 패치 세트에는 세션이 작성된 이후 연결에서 발생한 &lt;em&gt;모든&lt;/em&gt; 변경 사항 이 포함됩니다 . 즉, sqlite3session_changeset () 또는 sqlite3session_patchset ()에 대한 호출로 세션 객체가 재설정되거나 제로화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">첫 번째 트랜잭션 이후 트랜잭션의 데이터베이스 헤더에서 변경 카운터를 증가시킬 필요는 없습니다. 이것은 종종 페이지 1의 쓰기를 롤백 저널과 기본 데이터베이스 파일 모두에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">sqlite3_column_type ()에 의해 지정된 형식으로 데이터를 검색 할 필요는 없습니다. 다른 형식이 요청되면 데이터가 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">단일 FTS 쿼리가 다른 languageid 값을 가진 행을 반환 할 수 없습니다. 다른 연산자를 사용하는 WHERE 절을 추가 한 결과 (예 : lid! = 5 또는 lid &amp;lt;= 5)는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">내용이없는 FTS4 테이블에 저장된 행을 업데이트하거나 삭제하는 것은 불가능합니다. 시도하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">비어있는 데이터베이스 나 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 사용 하거나 &lt;a href=&quot;backup&quot;&gt;백업 API를&lt;/a&gt; 사용하여 백업 에서 복원 하여 WAL 모드를 시작한 후에 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 를 변경할 수 없습니다 . 페이지 크기를 변경하려면 롤백 저널 모드에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;다중 문 트랜잭션 중에&lt;/a&gt; SQLite가 &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;자동 커밋 모드&lt;/a&gt; 가 아닌 경우 외래 키 제약 조건을 활성화하거나 비활성화 할 수 없습니다 . 그렇게하려고해도 오류가 반환되지 않습니다. 단순히 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">새 열의 기본값이 NULL이 아닌 경우 &quot;ALTER TABLE ... ADD COLUMN&quot;구문을 사용하여 REFERENCES 절을 포함하는 열을 추가 할 수 없습니다. 이렇게하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">한 번에 둘 이상의 스레드에서이 변수를 읽거나 수정하는 것은 안전하지 않습니다. &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 별도의 스레드에서 동시에 사용되는 경우이 변수를 읽거나 수정하는 것은 안전하지 않습니다 . 이 변수는 프로세스 초기화의 일부로 한 번 설정되고 SQLite 인터페이스 루틴이 호출되기 전에 설정되며 그 이후에는이 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">한 번에 둘 이상의 스레드에서이 변수를 읽거나 수정하는 것은 안전하지 않습니다. &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 별도의 스레드에서 동시에 사용되는 경우이 변수를 읽거나 수정하는 것은 안전하지 않습니다 . 이 변수는 프로세스 초기화의 일부로 한 번 설정되고 SQLite 인터페이스 루틴이 호출되기 전에 설정되며 그 이후에는이 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">각 항목마다 다른 소리 같은 값이있는 한 동일한 단어에 대해 여러 항목을 입력해도됩니다. soundslike 값을 지정하지 않으면 soundslike의 기본값은 단어 자체입니다.</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">둘 이상의 확장을 정적으로 연결하는 경우 일반 &quot;sqlite3_extension_init&quot;진입 점 이름 대신 확장명 파일 이름을 기반으로하는 진입 점 이름을 사용하는 것이 특히 중요합니다. 일반 이름을 사용하면 동일한 기호에 대한 여러 정의가 있으며 링크가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">동일한 이름을 갖지만 다른 수의 인수 또는 다른 선호하는 텍스트 인코딩으로 동일한 함수의 여러 구현을 등록 할 수 있습니다. SQLite는 SQL 함수가 사용되는 방식과 가장 일치하는 구현을 사용합니다. 음수가 아닌 nArg 매개 변수를 사용한 함수 구현은 음수가 nArg 인 함수 구현보다 더 적합합니다. 기본 텍스트 인코딩이 데이터베이스 인코딩과 일치하는 기능은 인코딩이 다른 기능보다 더 적합합니다. 인코딩 차이가 UTF16le과 UTF16be 사이에있는 함수는 인코딩 차이가 UTF8과 UTF16 사이에있는 함수와 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">라이브러리 컴파일 타임 C 전 처리기 기호 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 가이 pragma 설정을 대체 할 수 있습니다. 다음 표는 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 전 처리기 매크로와 temp_store pragma 의 상호 작용을 요약 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">Prover에 대한 향후 향상을 통해 특정 내장 함수에 대한 NULL 입력이 항상 NULL 응답을 초래한다는 것을 인식 할 수 있습니다. 그러나 모든 내장 함수에 해당 속성이있는 것은 아니며 (예 : &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ) 물론 증명자는 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수에&lt;/a&gt; 대해 추론 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">미래의 검증 자 향상으로 인해 특정 내장 함수에 대한 NULL 입력으로 인해 항상 NULL 응답이 발생 함을 인식 할 수 있습니다. 그러나 모든 내장 함수가 해당 특성을 갖는 것은 아니며 (예 : &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ) 물론 입증자는 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수에&lt;/a&gt; 대해 추론 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">미리 결정된 SQLITE_OMIT _... 옵션 세트와 함께 작동 하는 특수 &lt;a href=&quot;amalgamation&quot;&gt;병합&lt;/a&gt; 이 가능합니다 . 이를위한 지시 사항은 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _... 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">단일 데이터베이스 핸들에 첨부 된 여러 세션 오브젝트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">물론 사용자 정의 또는 파일 더미 형식을 확장 할 수도 있지만 작업이 훨씬 더 어렵습니다. 인덱스가 추가되면 해당 테이블을 변경하는 모든 애플리케이션 코드를 찾아서 수정하여 해당 인덱스를 최신 상태로 유지해야합니다. 열이 추가되면 해당 테이블에 액세스하는 모든 응용 프로그램 코드를 찾아 수정하여 새 열을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">함수의 두 형식에 대한 인수 수가 다른 경우 간단한 함수와 이름이 같은 집계 함수를 가질 수 있습니다. 예를 들어, 단일 인수를 가진 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; 함수는 집계이고 두 개 이상의 인수를 가진 &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max ()&lt;/a&gt; 함수는 간단한 함수입니다. 집계 함수는 일반적으로 창 함수로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">SQLite가 SELECT DISTINCT 및 UNION의 목적으로 NULL을 고유하게 처리하도록 할 수 있습니다. 그렇게하려면 &lt;code&gt;sqliteInt.h&lt;/code&gt; 소스 파일 에서 NULL_ALWAYS_DISTINCT #define 값을 변경 하고 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">명령 실행 전후에 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; API가 리턴 한 값을 확인하여 'merge'명령이 병합 할 b-tree를 찾았는지 여부를 알 수 있습니다 . 두 값의 차이가 2 이상이면 작업이 수행 된 것입니다. 차이가 2보다 작 으면 '병합'명령이 작동하지 않습니다. 이 경우 최소한 FTS 테이블이 다음에 업데이트 될 때까지 동일한 '병합'명령을 다시 실행할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">&quot;t2&quot;테이블에 쓸 수 있으므로 인덱스의 내용을 변경할 수 있습니다. 그러나 이렇게하면 &quot;t1bc&quot;인덱스가 상위 테이블 &quot;t1&quot;과 동기화되지 않습니다. 동기화되지 않은 인덱스는 잘못된 쿼리 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">응용 프로그램은 ROLLBACK 명령을 명시 적으로 실행하여 위에 나열된 오류에 응답하는 것이 좋습니다. 오류 응답으로 트랜잭션이 이미 자동으로 롤백 된 경우 ROLLBACK 명령이 오류와 함께 실패하지만 이로 인한 피해는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">현재 데이터베이스 작업을 실행중인 스레드와 다른 스레드에서이 루틴을 호출하는 것이 안전합니다. 그러나 sqlite3_interrupt ()가 리턴되기 전에 닫히거나 닫힐 수 있는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 연결로이 루틴을 호출하는 것은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">현재 데이터베이스 작업을 실행중인 스레드와 다른 스레드에서이 루틴을 호출하는 것이 안전합니다. 그러나 sqlite3_interrupt ()가 리턴되기 전에 닫히거나 닫힐 수 있는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 연결로이 루틴을 호출하는 것은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="translated">xConflict 콜백 내에서 콜백과 관련된 테이블에 쓰는 SQL 문을 포함하여 SQL 문을 실행하는 것이 안전합니다. 이것은 응용 프로그램의 충돌 해결 전략을 추가로 사용자 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">xConflict 콜백 내에서 콜백과 관련된 테이블에 쓰는 명령문을 포함하여 SQL 문을 실행하는 것이 안전합니다. 이는 응용 프로그램 충돌 해결 전략을 추가로 사용자 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">SQLite 확장이 하위 구성 요소 간 또는 확장과 응용 프로그램간에 비 SQL 값을 통신하는 것이 편리한 경우가 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">외부 컨텐츠 FTS5 테이블의 컨텐츠가 컨텐츠 테이블을 통해 최신 상태로 유지되도록하는 것은 여전히 ​​사용자의 책임입니다. 이를 수행하는 한 가지 방법은 트리거를 사용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="translated">모든 쓰기가 트리를 근본적으로 재구성하고 프로세스에서 노드의 스캔 순서를 변경하는 것은 Guttman R-Tree 알고리즘의 특성입니다. 이러한 이유로 일반적으로 R-Tree 쿼리 도중에 R-Tree를 수정할 수 없습니다. 이렇게하면 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;데이터베이스 테이블이 잠겼습니다&quot;오류 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">이 함수를 성공적으로 호출 한 후 버퍼 할당을 해제하려면 * ppOut 포인터에서 sqlite3_free ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">호출자를 &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize ()&lt;/a&gt; 에 전달하여 반복자를 파괴하는 것은 호출자의 책임입니다 . 변경 세트 (pChangeset)를 포함하는 버퍼는 반복자가 소멸 될 때까지 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">호출자를 &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize ()&lt;/a&gt; 에 전달하여 반복자를 파괴하는 것은 호출자의 책임입니다 . 변경 세트 (pChangeset)를 포함하는 버퍼는 반복자가 소멸 될 때까지 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">응용 프로그램이 때때로 신뢰할 수없는 소스에서 완전한 이진 SQLite 데이터베이스 파일을 가져 오는 경우가 많으며 이러한 가져 오기로 인해 가능한 공격 경로가 발생할 수 있습니다. 그러나 SQLite의 코드 경로는 제한되어 있으며 테스트가 매우 잘되었습니다. 또한 사전 검증 루틴을 사용하여 신뢰할 수있는 데이터베이스를 읽고 사용하기 전에 가능한 공격을 탐지 할 수있는 응용 프로그램을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">동일한 이름의 테이블, 인덱스 또는 뷰가 이미 포함 된 데이터베이스에 새 테이블을 만들려고하면 일반적으로 오류가 발생합니다. 그러나 &quot;IF NOT EXISTS&quot;절이 CREATE TABLE 문의 일부로 지정되고 동일한 이름의 테이블 또는 뷰가 이미 존재하면 CREATE TABLE 명령은 아무런 영향을 미치지 않습니다 (오류 메시지가 리턴되지 않음). &quot;IF NOT EXISTS&quot;절이 지정된 경우에도 기존 색인으로 인해 테이블을 작성할 수없는 경우 오류가 계속 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;식에 대한 인덱스&lt;/a&gt; 가 포함 된 데이터베이스에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">병합에 충돌이있을 수 있습니다. 동일한 코드 줄이 원 (1)과 (4) 대 원 (2)와 (3) 사이에서 다른 방식으로 변경되면 충돌이 발생합니다. merge 명령은 충돌을 알리고 출력에 충돌하는 두 버전의 라인을 모두 포함합니다. 충돌이 포함 된 파일을 불러 와서 수동으로 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">왼쪽에 숫자 값 (문자열 또는 블로 브 대신)을 사용하여 LIKE 또는 GLOB 연산자를 true로 만들 수 없어야합니다. 이것은 다음 중 하나를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">데이터베이스 파일 형식에 호환되지 않는 변경이 필요하기 때문에 이러한 기능을 구현하려면 버전 3.0으로 이동해야했습니다. API 정리와 같은 다른 호환되지 않는 변경 사항은 호환되지 않는 변경 사항을 한 번에 모두 없애는 것이 가장 좋다는 이론하에 동시에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">유니 코드 (UTF8) 텍스트와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">마스터 저널이 존재하거나 마스터 저널 이름이 빈 문자열이고</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">크기가 512 바이트보다 크고</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="translated">수퍼 저널이 있거나 수퍼 저널 이름이 빈 문자열 인 경우</target>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">JM 롭슨 &quot;동적 스토리지 할당에 관한 일부 기능의 경계&quot;.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON 지원</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">주문 가입</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">조인 재정렬은 자동이며 일반적으로 프로그래머가 그것에 대해 생각할 필요가 없을 정도로 잘 작동합니다. 특히 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 사용하여 사용 가능한 인덱스에 대한 통계를 수집하는 경우. 그러나 때때로 프로그래머의 힌트가 필요합니다. 예를 들어 다음 스키마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">저널 파일 형식</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">저널 헤더 형식</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">저널 레코드 형식</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">전산 기계 학회지</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">데이터베이스 페이지 저널링</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">페이지 저널링</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">줄리안 일수</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">레지스터 P1의 값이 False이면 P2로 이동합니다. 숫자 값이 0이면 값이 false로 간주됩니다. P1의 값이 NULL이면 P3이 0이 아닌 경우에만 점프를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">레지스터 P1의 값이 NULL이면 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">레지스터 P1의 값이 NULL이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">레지스터 P1의 값이 참이면 P2로 이동합니다. 숫자이고 0이 아닌 경우 값은 true로 간주됩니다. P1의 값이 NULL이면 P3이 0이 아닌 경우에만 점프를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">가장 최근의 &lt;a href=&quot;opcode#Compare&quot;&gt;비교&lt;/a&gt; 명령어에서 P1 벡터가 P2 벡터보다 작거나 같은지 여부에 따라 주소 P1, P2 또는 P3의 명령어로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">레지스터 P1의 주소 다음에 나오는 다음 명령으로 이동하십시오. 점프 후 레지스터 P1은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">ZIP 아카이브를 관리하는 &quot;zip&quot;프로그램과 &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;Tarball&lt;/a&gt; 을 관리하는 &quot;tar&quot;프로그램이있는 것처럼 &quot;sqlar&quot;프로그램 은 SQL 아카이브를 관리하기 위해 존재합니다. &quot;sqlar&quot;프로그램은 새 SQLite Archive를 작성하고 기존 아카이브의 컨텐츠를 나열하며 아카이브에서 파일을 추가 또는 제거하거나 아카이브에서 파일을 추출 할 수 있습니다. 별도의 &quot;sqlarfs&quot;프로그램은 SQLite Archive를 &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt; 으로 마운트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">당신의 삶의 행동을 끊임없이 경계하십시오.</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">눈 앞에 매일 죽음을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">NUMERIC으로 캐스트 할 때 정수의 정밀도를 유지하십시오 (가능한 경우). 티켓 # 2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">키 포인트:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">이 글의 주요 내용 :</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">원시 데이터베이스 파일 컨텐츠의 키 / 값 저장소 키는 페이지 번호이고 값은 이진 페이지 내용입니다.</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">키워드 인수는 선택적으로 따옴표로 표시 할 수 있습니다. (예 : &lt;code&gt;'yes' [FALSE]&lt;/code&gt; .) 일부 pragma는 문자열 리터럴을 인수로 사용합니다. pragma는 키워드 인수를 사용할 때 일반적으로 동등한 숫자도 사용합니다. 예를 들어, &quot;0&quot;과 &quot;no&quot;는 &quot;1&quot;과 &quot;yes&quot;와 같은 의미입니다. 설정 값을 쿼리 할 때 많은 pragma가 키워드 대신 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">하나님 께서 당신을 모든 곳에서 보신다는 것을 확실히하십시오.</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">왼쪽 가입</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOIN이 뷰 내부에서 사용될 때 LEFT JOIN 제거가 종종 발생하고 LEFT JOIN의 오른쪽 테이블 열이 참조되지 않는 방식으로 뷰가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN 강도 감소 최적화</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">LEFT OUTER JOIN이 구현되었지만 RIGHT OUTER JOIN 또는 FULL OUTER JOIN이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">같은 최적화</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">LIKE 최적화는 이제 COLLATE NOCASE가있는 열에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0은 이제 행을 보여주지 않습니다. 모든 행을 보려면 LIMIT -1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0은 이제 서브 쿼리에서 작동합니다</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">큰 WAL 파일</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">마지막 삽입 Rowid</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">나중에 다이어그램에서 원 (4)로 표시된 것처럼 SQLite 버전 3.6.16이 릴리스됩니다. 이 시점에서 개인 브랜치 관리자는 병합을 수행하여 (1)에서 (4)로 변경되는 모든 변경 사항을 (3)에 적용합니다. 결과는 버전 (5)이며 SQLite 3.6.16 및 편집입니다.</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">선행 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">리프 페이로드 비율. 32 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">왼쪽 피연산자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">출력 값을 왼쪽으로 맞 춥니 다. 기본값은 오른쪽 정렬입니다. 너비가 0이거나 대체되는 값의 길이보다 작 으면 패딩이없고 &quot;-&quot;플래그가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">세션 모듈의 레거시 (3.22.0 이전) 버전은 sqlite_stat1 테이블의 변경 사항을 캡처 할 수 없습니다. sqlite3changeset_apply () 함수의 레거시 버전은 변경 세트 또는 패치 세트의 일부인 sqlite_stat1 테이블의 수정 사항을 자동으로 무시합니다.</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">레몬에는 자체 소스 저장소가 없습니다. 레몬은 SQLite 소스 트리에 몇 개의 파일로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">레몬은 LALR (1) 파서를 생성합니다. 이 작업은 친숙한 도구 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt; 과 비슷하지만 레몬은 다음과 같은 중요한 개선 사항을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">레몬에는 &quot;대체&quot;토큰이라는 개념이 있습니다. SQL 언어에는 많은 키워드가 포함되어 있으며 이러한 키워드는 식별자 이름과 충돌 할 가능성이 있습니다. 레몬은 일부 키워드를 지정하는 기능이 식별자로 &quot;대체&quot;할 수있게했습니다. 구문 오류 인 컨텍스트에서 키워드가 입력 토큰 스트림에 표시되면 구문 오류가 발생하기 전에 토큰이 자동으로 폴백으로 변환됩니다. 이 기능을 사용하면 구문 분석기가 식별자로 사용되는 예약어를 매우 용서할 수 있습니다. 이는 SQL 언어에서 자주 발생하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">레몬은 구문 오류나 다른 중단 된 구문 분석 후에 메모리 나 기타 리소스를 회수하는 데 사용할 수있는 비 터미널 소멸자 개념을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">레몬은 또한 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 확장 에서 쿼리 패턴 표현식에 대한 구문 분석을 생성하는 데 사용됩니다 . 이 경우 입력 문법 파일은 &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">레몬은 SQLite에서 두 곳에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">레몬은 문법 파일 규칙의 조건부 컴파일을 지원하므로 컴파일 타임 옵션에 따라 다른 파서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">레몬은 1987 년부터 1992 년까지 듀크 대학교 대학원에 재학중인 동안 D. Richard Hipp (또한 SQLite의 창시자)가 저술 한 원본입니다. 레몬의 최초 제작 날짜는 잃어 버렸지 만 아마도 1990 년경 쯤되었을 것입니다. LALR (1) 파서 &quot;Lime&quot;이라는 LL (1) 파서 생성기 도구가 있었지만 Lime의 소스 코드가 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">길이 지정자</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">관리가 적다는 것은 프로그래머가 소프트웨어 작업에 더 많은 시간을 소비하고 (이 경우 SQLite) 버전 제어 시스템을 사용하는 데 소요되는 시간을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">적은 메모리 사용</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">K를 M + ((PM) % (U-4))로 둡니다.</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">X를 ((U-12) * 64 / 255) -23으로 둡니다. 페이로드 크기 P가 X보다 작거나 같은 경우 전체 페이로드가 b- 트리 페이지에 저장됩니다. M을 ((U-12) * 32 / 255) -23으로하고 K를 M + ((PM) % (U-4))로하십시오. P가 X보다 크면 K가 X보다 작거나 같으면 인덱스 b- 트리 페이지에 저장된 바이트 수는 K입니다. 인덱스 페이지에 저장된 바이트 수는 M보다 작지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">X를 U-35라고하자. 페이로드 크기 P가 X보다 작거나 같은 경우 전체 페이로드가 b- 트리 리프 페이지에 저장됩니다. M을 ((U-12) * 32 / 255) -23으로하고 K를 M + ((PM) % (U-4))로하십시오. P가 X보다 크면 K가 X보다 작거나 같은 경우 테이블 b- 트리 리프 페이지에 저장된 바이트 수는 K이고, 그렇지 않으면 M입니다. 리프 페이지에 저장된 바이트 수는 M보다 작지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">X를 부분 인덱스의 WHERE 절에있는 표현식으로, W가 인덱스 된 테이블을 사용하는 쿼리의 WHERE 절이라고하자. 그런 다음 W&amp;rArr;X 인 경우 쿼리에서 부분 인덱스를 사용할 수 있습니다. 여기서 &amp;rArr; 연산자 (일반적으로 &quot;implies&quot;라고 함)는 &quot;X 또는 not W&quot;에 해당하는 논리 연산자입니다. 따라서 특정 쿼리에서 부분 인덱스를 사용할 수 있는지 여부를 결정하면 1 차 논리의 정리 증명이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">X를 X의 모든 j에 대해 aPgno [j % 8192]! = 0이되도록 연속 정수 {h, h + 1, h + 2, ..., h + N}의 가장 큰 집합으로 둡니다. aPgno [h % 8192] == 0 인 경우 X 세트가 비어 있습니다. X 세트는 값 h % 8192로 시작하여 h % 8192를 X에 추가하고 첫 번째 aPgno [h % 8192] 항목이 0이 될 때까지 h를 증가시켜 쉽게 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">데이터베이스 페이지 크기 (저널 헤더의 오프셋 24에있는 정수 값)를 N으로 설정하십시오. 그러면 페이지 레코드의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">데이터 유형 &quot;u8&quot;, &quot;u16&quot;및 &quot;u32&quot;는 각각 길이 8, 16 및 32 비트의 부호없는 정수를 의미합니다. 그런 다음 shm 파일의 첫 32768 바이트 단위는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">alice 노드의 수를 M으로, bob 노드의 수를 N으로하십시오. 두 가지 시나리오를 고려하십시오. 첫 번째 시나리오에서 M과 N은 둘 다 2이지만 각 노드에는 수천 개의 모서리가 있습니다. 이 경우 옵션 1이 선호됩니다. 옵션 1을 사용하면 내부 루프는 한 쌍의 노드 사이에 에지가 있는지 확인하고 발견되면 결과를 출력합니다. 그러나 각각 2 개의 alice 및 bob 노드 만 있기 때문에 내부 루프는 4 번만 실행하면되며 쿼리가 매우 빠릅니다. 옵션 2는 여기에서 훨씬 오래 걸립니다. 옵션 2의 외부 루프는 두 번만 실행되지만 각 앨리스 노드를 떠나는 많은 수의 에지가 있기 때문에 중간 루프는 수천 번 반복되어야합니다. 훨씬 느려질 것입니다. 따라서 첫 번째 시나리오에서는 옵션 1을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">저널 헤더에서 오프셋 8의 페이지 카운트 값을 M으로 설정하십시오. M이 0보다 크면 M 페이지 레코드 이후 저널 파일은 섹터 크기의 다음 배수에 0으로 채워지고 다른 저널 헤더가 삽입 될 수 있습니다. 동일한 저널 내의 모든 저널 헤더는 동일한 데이터베이스 페이지 크기 및 섹터 크기를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">합병 소스 코드를 사용한다고 가정 해 봅시다. 다음과 같이 프로젝트에 기준을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">ZIP 아카이브를 사용하여 파일을 저장하는 대신 OpenDocument는 다음과 같은 단일 테이블 스키마와 함께 매우 간단한 SQLite 데이터베이스를 사용했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">다음 표기법을 사용합시다 (Robson의 표기법과 유사하지만 동일하지 않음).</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">진짜로합시다 Git이 최적의 사용자 경험을 제공하지 않는다고 진지하게 이의를 제기하는 사람은 거의 없습니다. 많은 기본 구현이 사용자 인터페이스를 통해 보여줍니다. 인터페이스가 너무 나빠서 &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;가짜 git man 페이지&lt;/a&gt; 를 생성하는 패러디 사이트도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">여기서 무슨 일이 일어나고 있는지 좀 더 자세히 살펴 봅시다. 첫 번째 SELECT는 명령어 5에서 10까지의 루프에 의해 구현됩니다. 명령어 5는 커서를 되 감아 루프를 초기화합니다. 명령어 6은 &quot;examp&quot;에서 &quot;two&quot;열의 값을 추출하고 명령어 7은이를 행으로 변환합니다. 명령어 8은 빈 문자열을 스택에 넣습니다. 마지막으로 명령 9는 행을 임시 테이블에 기록합니다. 그러나 PutStrKey opcode는 스택의 상단을 레코드 데이터로 사용하고 스택의 다음은 키로 사용합니다. INSERT 문의 경우 MakeRecord opcode에 의해 생성 된 행은 레코드 데이터이고 레코드 키는 NewRecno opcode에 의해 작성된 정수입니다. 그러나 여기서 역할이 바뀌고 MakeRecord에 의해 작성된 행은 레코드 키이고 레코드 데이터는 단지 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">C로 작성된 라이브러리는 큰 런타임 종속성이 없습니다. 최소 구성에서 SQLite는 표준 C 라이브러리의 다음 루틴 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">C ++ 또는 Java로 작성된 라이브러리는 일반적으로 동일한 언어로 작성된 응용 프로그램에서만 사용할 수 있습니다. C ++로 작성된 라이브러리를 호출하기 위해 Haskell 또는 Java로 작성된 응용 프로그램을 얻는 것은 어렵습니다. 반면에 C로 작성된 라이브러리는 모든 프로그래밍 언어에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">라이브러리 크기 최적화.</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">--file과 마찬가지로 파일 FILE을 아카이브로 사용하지만 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS를&lt;/a&gt; 사용하여 파일을 열어 파일이 이미 존재하는 경우 아카이브가 FILE의 끝에 추가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">컨텐츠가없는 테이블과 마찬가지로 외부 컨텐츠 테이블은 REPLACE 충돌 처리를 지원하지 않습니다. REPLACE 충돌 처리를 지정하는 모든 작업은 ABORT를 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">다른 가상 테이블 유형과 마찬가지로 새 FTS 테이블은 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문을 사용하여 작성됩니다. USING 키워드 뒤에 나오는 모듈 이름은 &quot;fts3&quot;또는 &quot;fts4&quot;입니다. 가상 테이블 모듈 인수는 비워 둘 수 있으며,이 경우 &quot;content&quot;라는 단일 사용자 정의 열이있는 FTS 테이블이 작성됩니다. 또는 모듈 인수에 쉼표로 구분 된 열 이름 목록이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">sqlite3rbu_step ()과 같이 진공 작업이 완료되면 sqlite3rbu_close ()는 SQLITE_DONE을 반환합니다. 진공이 완료되지 않았지만 오류가 발생하지 않은 경우 SQLITE_OK가 리턴됩니다. 또는 오류가 발생한 경우 SQLite 오류 코드가 리턴됩니다. sqlite3rbu_step ()에 대한 이전 호출의 일부로 오류가 발생한 경우 sqlite3rbu_close ()는 동일한 오류 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">&quot;.dump&quot;명령과 마찬가지로 &quot;.recover&quot;는 데이터베이스 파일의 전체 내용을 텍스트로 변환하려고 시도합니다. 차이점은 일반적인 SQL 데이터베이스 인터페이스를 사용하여 데이터를 읽는 대신 &quot;.recover&quot;는 가능한 한 많은 데이터베이스 페이지에서 직접 추출한 데이터를 기반으로 데이터베이스를 다시 어셈블하려고 시도한다는 것입니다. 데이터베이스가 손상된 경우 &quot;.recover&quot;는 일반적으로 데이터베이스의 손상되지 않은 모든 부분에서 데이터를 복구 할 수있는 반면 첫 번째 손상 징후가 발생하면 &quot;.dump&quot;는 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">한계 설정</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check가&lt;/a&gt; 생성 하는 출력량을 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">재귀 강하 파서에서 과도한 스택 사용을 피하기 위해 JSON 객체 및 배열의 ​​재귀 깊이를 제한하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64 ()&lt;/a&gt; 인터페이스를 사용하여 할당 할 최대 메모리 양을 제한합니다 . 이는 서비스 거부 공격을 방지하는 데 도움이됩니다. 애플리케이션에 실제로 필요한 힙 공간을 확인하려면 일반적인 입력에 대해이를 실행 한 다음 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스로 최대 순간 메모리 사용량을 측정합니다 . 하드 힙 제한을 관찰 된 최대 순간 메모리 사용량과 약간의 여유로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">한계와 경고</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument 프레젠테이션 형식의 제한</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite의 한계</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">&quot;#&quot;으로 시작하고 SQL 문 중간에없는 행은 주석으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">일반적인 워크로드를 나타내는 약 30,000 개의 SQL 문을 실행하는 테스트 프로그램에 SQLite를 링크하십시오.</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Linus Torvalds는 다른 단어를 사용하여 2006-06-27의 Git 메일 링리스트에서 똑같은 말을했습니다.</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">상수 목록 :</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">기능 목록 :</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">객체 목록 :</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMA 목록</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite 상수 목록</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite 함수 목록</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite 객체 목록</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">가상 테이블 목록</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">처리되는대로 각 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">아카이브 내용을 나열하십시오. 인수를 지정하지 않으면 모든 파일이 나열됩니다. 그렇지 않으면 인수로 지정된 것만 있습니다. 현재 --verbose 옵션은이 명령의 동작을 변경하지 않습니다. 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">아카이브에 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">IN의 오른쪽에있는 목록 값은 구체화되어야하는 하위 쿼리로 처리됩니다. 다시 말해, 이전의 진술은 마치 마치</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">다음은 소리 같은 항목을 추가하는 것이 합리적 일 수있는 경우입니다. 특정 항목은 응용 프로그램 및 대상 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">성스러운 독서를 기꺼이 들으십시오.</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">리터럴 값 (상수)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="translated">리터럴 문자열에는 바이트 순서 표시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">리터럴 값</target>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC 권장 저장 형식</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">확장로드</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">세션으로 테이블 간 차이로드</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">차이점을 계산하기 전에 공유 라이브러리 또는 DLL 파일 LIBRARY를 SQLite에로드하십시오. 스키마에 필요한 응용 프로그램 정의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 를 추가하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">로드 가능한 확장 기능</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">로드 가능한 확장은 C 코드입니다. 대부분의 유닉스 계열 운영 체제에서 컴파일하려면 일반적인 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">로컬 삭제</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">로컬 삽입</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">로컬 업데이트</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">현지 시간 수정 자</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">잠금 이름</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">잠금 오프셋</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="translated">다른 커서가 btree를 쓸 수 없도록 커서 P1이 가리키는 btree를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">잠금 및 동시성</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">잠금 및 동시성 제어는 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;호출기 모듈에&lt;/a&gt; 의해 처리됩니다 . 호출기 모듈은 SQLite &quot;ACID&quot;(원자, 일관성, 격리 및 내구성)를 만드는 역할을합니다. 호출기 모듈을 사용하면 변경 사항이 한 번에 모두 발생하는지, 모든 변경 사항이 발생하거나 전혀 수행되지 않음, 두 개 이상의 프로세스가 동시에 호환되지 않는 방식으로 데이터베이스에 액세스하려고 시도하지 않고 변경 사항이 작성된 경우 명시 적으로 삭제 될 때까지 지속됩니다. 또한 호출기는 디스크 파일의 일부 내용에 대한 메모리 캐시를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">긴 옵션</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">장기 지원</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">길고 짧은 스타일 옵션이 혼합되어있을 수 있습니다. 예를 들어 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">더 긴 대답 : 테이블의 열을 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 로 선언하면 테이블의 해당 열에 NULL을 삽입 할 때마다 NULL은 자동으로 해당 열의 가장 큰 값보다 큰 정수로 변환됩니다 테이블의 다른 모든 행 또는 테이블이 비어있는 경우 1 또는 기존의 가장 큰 정수 키 9223372036854775807을 사용중인 경우 사용하지 않는 키 값이 임의로 선택됩니다. 예를 들어, 다음과 같은 테이블이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">새 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 Lookaside 버퍼 할당 .</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">Lookaside 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">많은 버그 수정.</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">많은 작은 버그 수정.</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">순결을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">금식을 사랑합니다.</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">적을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">후배들을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">데이터베이스 파일의 저수준 제어</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">저수준 시스템 오류 코드</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">가장 낮은 우선 순위 (가장 낮은 그룹화).</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M은 항상 ((U-12) * 32 / 255) -23입니다.</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">마스크 비트 0x02가 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac은 유닉스와 비슷하지만 일반적인 공유 라이브러리 규칙을 따르지 않습니다. Mac에서 공유 라이브러리를 컴파일하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">API 함수 &lt;b&gt;const&lt;/b&gt; 에서 선택된 매개 변수를 만들었습니다 . 이전 버전과 완전히 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop 퍼저&lt;/a&gt; 를 SQLite &lt;a href=&quot;testing&quot;&gt;테스트 전략&lt;/a&gt; 의 표준으로 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">CACHE_SIZE pragma를 지속적으로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">매직 넘버. 0x377f0682 또는 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">100 % MC / DC를 유지하려면 많은 시간과 노력이 필요합니다. 전체 적용 범위 테스트를 유지하는 데 필요한 노력은 일반적인 응용 프로그램에는 비용 효과적이지 않을 수 있습니다. 그러나 전체 범위 테스트는 SQLite와 같이 &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;광범위하게 배포 된&lt;/a&gt; 인프라 라이브러리, 특히 본질적으로 과거 실수를 &quot;기억&quot;하는 데이터베이스 라이브러리에 적합 하다고 생각합니다 .</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">SQLite의 개인 브랜치 유지</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">확인 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used ()&lt;/a&gt; 받는 반응 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB의&lt;/a&gt; 컴파일시 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">WinCE는이 기능을 지원하지 않기 때문에 AreFileApisANSI ()를 WinCE에서 매크로가 아닌 매크로로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">명령 행 셸에서 CSV (쉼표로 분리 된 값) 출력을 허용 된 실습에 더 가깝게 정렬</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">LIMIT가 복합 SELECT 문에서 작동하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">레지스터 P1..P1 + P3을 레지스터 P2..P2 + P3에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">정렬 할 때 숫자와 텍스트 값을 구분하십시오. 텍스트 값은 memcmp ()에 따라 정렬됩니다. 숫자 값은 숫자 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">레지스터 P1의 얕은 복사본을 레지스터 P2에 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">새 페이지를 할당하기 위해 모든 노력을 기울이십시오. 새 페이지를 할당 할 수없는 경우에만 NULL을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">해가지기 전에 적과 화해하십시오.</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">DISTINCT 연산자가 내림차순 인덱스를 사용하여 구현 된 경우에도 ORDER BY가 행을 오름차순으로 정렬해야합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">쉘 의 &lt;b&gt;.dump&lt;/b&gt; 명령 출력에서 해당 테이블 뒤에 VIEW가 작성되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">모든 개별 데이터베이스 파일에 독점 잠금 및 유효한 저널이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">모든 롤백 저널 데이터가 실제로 디스크 표면에 기록되었고 (운영 체제 또는 디스크 제어기 캐시에만 보관되지 않음) 전원 장애가 발생해도 전원이 복원 된 후에도 데이터가 그대로 유지되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">INSERT의 VALUES 절에있는 함수 표현식이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">데이터베이스 파일 이름이 8 + 3 파일 이름 형식을 따르고 빈 이름이나 확장자가 없는지 확인하십시오. 즉, 데이터베이스 파일 이름은 기본 이름에 1-8 자, 확장자에 1-3 자 사이 여야합니다. 공백 확장은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">예약 된 잠금에서 연결이 차단 될 때 잠금이 해제 된 후에도 계속 연결될 수 있는지 확인하십시오. (티켓 # 3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">단일 명령문 내 여러 트리거 의 &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; 값이 서로 간섭하지 않도록하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">버퍼 크기가 1보다 작 으면 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 인터페이스가 버퍼를 0으로 종료하지 않는지 확인하십시오 . Ticket # 2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">MIN () 및 MAX () 최적화가 서브 쿼리 내에서 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt; 의 ORDER BY LIMIT 최적화 가 INTEGER PRIMARY KEY의 IN 연산자와 작동하는지 확인하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c에&lt;/a&gt; 대한 수정</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">64 비트 시스템에서 TCL 언어 인터페이스가 64 비트 정수에서 올바르게 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">malloc ()이 실패하는 경우 메모리 내 백엔드 응답이 제대로 작동하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">쿼리 최적화 프로그램이 복합 SELECT 문의 모든 용어에 대한 종속성을 확인해야합니다. 티켓 # 2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">각 SQL 명령 끝에 세미콜론을 입력하십시오! sqlite3 프로그램은 SQL 명령이 완료 될 때 알 수있는 세미콜론을 찾습니다. 세미콜론을 생략하면 sqlite3은 계속 프롬프트를 표시하고 현재 SQL 명령에 추가 할 텍스트를 더 입력 할 때까지 기다립니다. 이 기능을 사용하면 여러 줄에 걸쳐있는 SQL 명령을 입력 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">해당 스크립트를 실행 가능하게 만들고 $ PATH에 넣으십시오. 그런 다음 다음과 같이 kvtest 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">&quot;AS&quot;키워드를 다시 선택 사항으로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; 옵션으로 컴파일 할 때 &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블&lt;/a&gt; 을 표준 빌드의 일부로 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">프로그래머가 대체 할 수있는 GLOB 및 LIKE 연산자를 작동 시키십시오. 예를 들어, LIKE 연산자를 대소 문자를 구분하도록 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">LIQUE 절이 서브 쿼리에서 작동하도록하십시오. (ORDER BY는 여전히 작동하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">라이브러리를 스레드로부터 안전하게 만듭니다. (코드가 있으며 작동하는 것처럼 보이지만 스트레스를받지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">컴파일이 Windows 용인지 유닉스 용인지를 감지하는 데 os.h 헤더 파일을보다 강력하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">일부 시스템 호출을 피하여 성능을 향상 시키 려면 Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서 OVERLAPPED를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">적절한 경우 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 에서 단일 패스 UPDATE 및 DELETE 쿼리 계획을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">메이크 파일 업데이트</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefile 업데이트 및 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A. Rottmann에서 Makefile 업데이트</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">다른 종류의 테이블 스키마 변경</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="translated">SQLite가 UTF-16 바이트 순서 표시로 변환하는 잘못된 UTF-8은 FTS3 테이블에 삽입 된 SQL 문자열 리터럴 값의 시작 부분에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">잘못된 데이터베이스 테스트</target>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">명령 행에서 SQLite 아카이브 관리</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">매니페스트 입력 및 BLOB 지원</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">매니페스트 타이핑 및 BLOB 지원</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">CROSS JOIN을 사용한 쿼리 계획 수동 제어</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">SQLITE_STAT 테이블을 사용한 쿼리 계획 수동 제어</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">많은 SQLITE_OMIT_ 매크로는 컴파일 타임에 기능을 생략하고 라이브러리 풋 프린트를 줄이기 위해 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">많은 SQLite 함수는 성공 또는 실패를 나타 내기 위해 여기에 표시된 세트에서 정수 결과 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">많은 작은 쿼리가 SQLite에서 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">많은 응용 프로그램 은 종료시 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 호출을 사용하여 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 끊습니다 . 또는, 예를 들어, 그것으로 SQLite는 사용하는 응용 프로그램 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식을&lt;/a&gt; 열 수있는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 파일 / 열기 메뉴 조치에 대한 응답으로 다음 해당 파괴 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 파일 / 닫기 메뉴에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">많은 애플리케이션이 SQLite를 엔터프라이즈 RDBMS의 관련 컨텐츠 캐시로 사용합니다. 이제 대부분의 쿼리가 로컬 캐시에 대해 발생하고 네트워크 왕복을 피하기 때문에 대기 시간이 줄어 듭니다. 또한 네트워크 및 중앙 데이터베이스 서버의로드를 줄입니다. 대부분의 경우 네트워크 중단시 클라이언트 측 응용 프로그램이 계속 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100 % 분기 테스트 적용 범위&lt;/a&gt; 를 지원하는 많은 코드 단순화 및 모호한 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">많은 문서 업데이트</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">완전하고 작동 가능한로드 가능한 확장의 많은 예는 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; 서브 디렉토리 의 SQLite 소스 트리에서 볼 수 있습니다 . 해당 디렉토리의 각 파일은 별도의 확장자입니다. 문서는 파일에 대한 헤더 주석으로 제공됩니다. 다음은 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; 서브 디렉토리 의 몇몇 확장에 대한 간단한 참고 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">구성 스크립트에 대한 많은 개선 및 정리</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">쉘에 대한 많은 개선 및 개선.</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">테스트 스위트가 많이 개선되었습니다. 테스트 범위가 98 %를 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">많은 미세 최적화는 이전 릴리스에 비해 동일한 수의 CPU주기에 대해 20.3 % 더 많은 작업을 수행합니다. &lt;a href=&quot;#version_3_8_0&quot;&gt;버전 3.8.0&lt;/a&gt; 이후 누적 성능 향상 은 61 %입니다. ( gcc 4.8.1 및 -Os가있는 Ubuntu 13.10 x64 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; 워크로드에서 &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; 를 사용하여 측정되었습니다 . 성능이 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">많은 미세 최적화로 인해 이전 릴리스보다 빠른 라이브러리가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">많은 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">많은 성가신 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C 언어 인터페이스&lt;/a&gt; 의 많은 루틴은 성공 또는 실패를 나타내는 숫자 결과 코드를 리턴하며 실패시 실패 원인을 알려줍니다. 이 문서는 각 숫자 결과 코드의 의미를 설명하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">커널 공간과 사용자 공간간에 내용을 복사해야하기 때문에 많은 작업, 특히 I / O 집중 작업이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">많은 프로그램이 &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen ()&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread ()&lt;/a&gt; 및 &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite ()&lt;/a&gt; 를 사용하여 집에서 자른 형식으로 데이터 파일을 만들고 관리합니다. SQLite는 특히 이들을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">많은 독자들이 역사적 개발 활동을 더 잘 보여줄 수있는 다양한 타사 GUI를 Git에 추천했습니다. 어쩌면 그들 중 일부는 네이티브 Git 및 / 또는 GitHub보다 잘 작동하지만 Git이 동기화를 통해 역사적인 분기 이름을 유지하지 못한다는 사실 때문에 모두 방해받을 수 있습니다. 다른 도구가 더 나은 경우에도 원하는 정보를 얻기 위해 타사 도구를 사용해야한다는 사실은 핵심 시스템에 대해 잘 설명하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">많은 작은 성능 최적화.</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">많은 버그 수정 및 호환성 향상.</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">많은 사소한 버그 수정 및 설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">마스터 저널 포인터</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">마스터 저널</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">마스터 저널</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">query1과 query2가 모두 일치하면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">query1 또는 query2가 일치하면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">query1이 일치하고 query2가 일치하지 않으면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Matchinfo B 플래그</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">Matchinfo x 플래그</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Matchinfo y 플래그</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">뷰 및 서브 쿼리의 구체화</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">수학 연산자 (+,-, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; 및 |)는 두 피연산자를 숫자 인 것처럼 해석합니다. STRING 또는 BLOB 피연산자는 자동으로 REAL 또는 INTEGER 값으로 변환됩니다. STRING 또는 BLOB가 실수처럼 보이거나 (소수점 또는 지수가있는 경우) 값이 64 비트 부호있는 정수로 표시 될 수있는 범위를 벗어나면 REAL로 변환됩니다. 그렇지 않으면 피연산자가 INTEGER로 변환됩니다. 수학 피연산자의 묵시적 타입 변환은 약간 다릅니다 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 숫자에&lt;/a&gt; 실수처럼 보이지만 더 소수 부분 대신 그들이 때처럼 INTEGER로 변환되는 REAL로 유지되지 않는 것을 해당 문자열 및 BLOB 값의 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;숫자에 CAST&lt;/a&gt;. STRING 또는 BLOB에서 REAL 또는 INTEGER 로의 변환은 손실되어 되돌릴 수없는 경우에도 수행됩니다. 일부 수학 연산자 (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; 및 |)는 INTEGER 피연산자가 필요합니다. 이러한 연산자의 경우 REAL 피연산자는 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST에서 INTEGER&lt;/a&gt; 와 같은 방식으로 INTEGER로 변환됩니다 . &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; 및 | 연산자는 항상 INTEGER (또는 NULL) 결과를 반환하지만 % 연산자는 피연산자의 유형에 따라 INTEGER 또는 REAL (또는 NULL)을 반환합니다. 수학 연산자의 NULL 피연산자는 NULL 결과를 생성합니다. 숫자로 보이지 않고 NULL이 아닌 수학 연산자의 피연산자는 0 또는 0.0으로 변환됩니다. 0으로 나누면 NULL이됩니다.</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">최대 임베디드 페이로드 비율. 64 여야합니다.</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">최대 rowid</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">최대 xShmLock 색인</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">Maxopen 매개 변수</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">선을 악하지 말고</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">자신을 용서하고 다른 사람을 용서해 주길 바랍니다</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">당신이주는 것보다 더 많이 가져 가지 않고 자유롭게 공유하길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">다음 명령을 사용하여 데이터베이스 및 개별 파일에서 Blob을 읽는 성능을 측정하십시오.</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">--update 옵션을 추가하여 쓰기 성능을 측정하십시오. 이로 인해 블롭이 정확히 동일한 크기의 다른 임의 블롭으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">gcc 5.4.0 및 -Os가있는 x64의 Ubuntu 16.04에서 cachegrind를 사용하여 측정했습니다.</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">위의 측정은 &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;2017-10-08의&lt;/a&gt; SQLite 버전 5594a121bf132a98 을 사용하여 수행 되었습니다.</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">SQLite에서 CPU 사용량 측정 및 감소</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">메모리 할당 루틴</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">메모리 할당 서브 시스템</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">메모리 할당 자 통계</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">메모리 슬롯</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) 시작 시간 옵션과 &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; 컴파일 시간 옵션 의 조합을 사용하여 메모리 계정을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) 시작 시간 옵션과 &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; 컴파일 시간 옵션 의 조합을 사용하여 메모리 계정을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0으로 컴파일되지 않으면 메모리 할당 통계는 기본적으로 사용됩니다.이 경우 기본적으로 메모리 할당 통계는 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0으로 컴파일되지 않으면 메모리 할당 통계는 기본적으로 사용됩니다.이 경우 기본적으로 메모리 할당 통계는 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">메모리 할당, 대소 문자가없는 문자열 비교 루틴, 이식 가능한 텍스트-숫자 변환 루틴 및 기타 유틸리티는 &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c에&lt;/a&gt; 있습니다. 파서가 사용하는 심볼 테이블은 &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt; 에있는 해시 테이블에 의해 유지됩니다 . &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c의&lt;/a&gt; 소스 파일은 유니 코드 변환 서브 루틴이 포함되어 있습니다. SQLite는 &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; 자체에 &lt;a href=&quot;printf&quot;&gt;printf ()&lt;/a&gt; (일부 확장자 포함)를 자체 구현 하고 random.c 에 자체 의사 난수 생성기 (PRNG)를 &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;가지고&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">메모리 통계</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 에 의해 리턴 된 정보를 보유하는 메모리 는 malloc ()에서 확보됩니다. 그러나 호출 함수는이 정보를 직접 해제하지 않아야합니다. 대신, 테이블이 더 이상 필요하지 않으면 전체 테이블을 &lt;b&gt;sqlite_free_table에&lt;/b&gt; 전달하십시오 . 결과 세트가 비어 있으면 리턴되는 NULL 포인터로 &lt;b&gt;sqlite_free_table&lt;/b&gt; 을 호출하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">메모리 매핑 된 I / O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 및 memsys6은 2007 년경에 소개 된 실험용 메모리 할당 자였으며 이후 새로운 가치가 추가되지 않은 것이 분명해진 후 2008 년경 소스 트리에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">개발 변경 사항을 기본 트렁크로 병합합니다. BTree 파일 구조를 사용하기위한 향후 작업에는 별도의 CVS 소스 트리가 사용됩니다. 이 CVS 트리는 SQLite의 GDBM 버전 만 계속 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch는 JSON 객체의 요소를 추가, 수정 또는 삭제할 수 있으므로 JSON 객체의 경우 json_patch () 루틴은 &lt;a href=&quot;json1#jset&quot;&gt;json_set ()&lt;/a&gt; 및 &lt;a href=&quot;json1#jrm&quot;&gt;json_remove ()&lt;/a&gt; 의 일반화 된 대체입니다 . 그러나 MergePatch는 JSON 배열 객체를 원자로 취급합니다. MergePatch는 Array에 추가하거나 Array의 개별 요소를 수정할 수 없습니다. 전체 어레이를 단일 장치로 삽입, 교체 또는 삭제할 수 있습니다. 따라서 json_patch ()는 배열, 특히 많은 하위 구조가있는 배열을 포함하는 JSON을 처리 할 때 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 확장을 트렁크에 병합했습니다 .</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">메타 데이터는이 함수에 5 번째 매개 변수로 전달 된 메모리 위치에 쓰면 반환됩니다. 이러한 인수는 NULL 일 수 있으며,이 경우 해당 메타 데이터 요소가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">방법 (2)는 (1)과 (3) 사이의 중간 점을 제공합니다. 이 방법을 사용하면 '1s *'와 같은 쿼리는 리터럴 토큰 &quot;1st&quot;를 포함하지만 &quot;first&quot;는 포함하지 않은 문서와 일치합니다 (토큰 izer가 접두사에 동의어를 제공 할 수 없다고 가정). 그러나 '1st'와 같은 접두사가 아닌 쿼리는 &quot;1st&quot;및 &quot;first&quot;와 일치합니다. FTS 인덱스에 추가 항목이 추가되지 않으므로이 방법에는 추가 디스크 공간이 필요하지 않습니다. 반면, 각 동의어에 FTS 인덱스의 별도 쿼리가 필요하므로 MATCH 쿼리를 실행하려면 더 많은 CPU주기가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">수백만 및 수백만 개의 테스트 사례</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">최소 임베디드 페이로드 비율. 32 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">최소 rowid</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">웹 사이트의 사소한 수정.</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">더 다양한 컴파일러를 지원하도록 사소한 구문 변경.</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">약간 더 빠르게 실행되도록 다른 코드로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">기타 &lt;a href=&quot;cpu#microopt&quot;&gt;미세 최적화&lt;/a&gt; 는 CPU 사용량을 약 2.1 % 줄입니다.</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">기타 코드 크기 최적화 및 버그 수정</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">기타 문서 향상.</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">기타 마이크로 최적화는 일반적인 워크로드에서 CPU 사용량을 7 % 이상 줄입니다. 이 릴리스에서 대부분의 최적화는 프론트 엔드 ( &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; )에있었습니다.</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">기타 미세 최적화를 통해 이전 릴리스에 비해 동일한 수의 CPU주기에 대해 22.3 % 더 많은 작업이 발생합니다. SQLite는 이제 &lt;a href=&quot;#version_3_8_0&quot;&gt;버전 3.8.0&lt;/a&gt; 보다 두 배 빠르며 &lt;a href=&quot;#version_3_3_9&quot;&gt;버전 3.3.9&lt;/a&gt; 보다 세 배 빠릅니다 . ( gcc 4.8.2 및 -Os가있는 Ubuntu 14.04 x64 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; 워크로드에서 &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; 를 사용하여 측정되었습니다 . 성능이 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">기타 최적화로 인해 &lt;a href=&quot;cpu&quot;&gt;사용&lt;/a&gt; 된 CPU주기 가 2 % 감소 합니다.</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">기타 성능 향상</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">&quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;와 같은 기타 문제 단어</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="translated">형식이 잘못된 레코드</target>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">콜백 누락</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="translated">누락되거나 과잉 색인 항목</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">누락 된 페이지</target>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">최신 파일 시스템은 디스크 액세스가 순차적 일 때 더 빠르게 작동합니다. 따라서 데이터베이스 파일의 컨텐츠가 순차 페이지에있는 경우 SQLite가 더 빠르게 실행됩니다. 데이터베이스에서 페이지의 일부가 순차적인지 확인하여 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 시기를 결정하는 데 유용한 측정 값을 얻으려면 다음과 같이 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">광범위한 임베디드 시스템을 지원 하기 위해 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 인터페이스를 수정했습니다 . 자세한 내용은 &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; 을 참조하십시오 . *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">파서 테이블이 4 배 더 작도록 &lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">버퍼 크기 계산에서 &quot;+4&quot;매직 번호를 제거하도록 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; 를 수정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">명시 적으로 요청 된 경우 내장 SQLITE_MASTER 테이블의 스키마를 인쇄 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘 프로그램을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">새로운 인터페이스 루틴을 사용 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘 프로그램을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">&quot;ls&quot;가 파일 이름을 인쇄하는 방식과 유사하게 여러 열로 테이블 목록을 인쇄하기 위해 새로운 sqlite_get_table () API를 사용 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">&quot;.schema&quot;명령의 출력에서 ​​각 CREATE 문의 끝에 세미콜론을 인쇄 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">실제 데이터가없는 디스크 페이지 (사용 가능한 페이지)가 저널링되지 않고 변경 될 때 메모리에서 디스크로 다시 쓰지 않도록 B-Tree 및 Pager 모듈을 수정했습니다. 페이지에 실제 데이터가 포함되어 있지 않기 때문에 데이터베이스 무결성에 영향을 미치지 않지만 큰 INSERT 작업은 약 2.5 배 빠르며 큰 DELETE는 약 5 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">OS 충돌 또는 전원 장애 후 발생할 수있는 손상에 대한 내성이 향상되도록 저널 파일 형식을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 를 사용하도록 TCL 인터페이스를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">테스트 스크립트를 수정하여 시스템로드 및 프로세서 속도에 의존하는 테스트를 식별하고 사용자에게 해당 (희귀 한) 테스트 중 하나가 실패했다고해서 반드시 라이브러리가 오작동하는 것은 아닙니다. 코드가 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">데이터베이스 페이지의 내용 수정</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">데이터베이스 페이지 수정, 추가 또는 잘라 내기</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">보다 적극적인 &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">한쪽 또는 다른 쪽이 항상 거짓 일 때 AND 연산자의보다 적극적인 최적화.</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">더 복잡한 쿼리는 임시 테이블을 피하기 위해 쿼리 병합을 사용하거나 사용하지 않을 수 있습니다. 쿼리를 병합 할 수 있는지 여부는 하위 쿼리 또는 외부 쿼리에 집계 함수, ORDER BY 또는 GROUP BY 절, LIMIT 절 등이 포함되는지 여부와 같은 요소에 따라 달라집니다. 쿼리를 병합하거나 병합 할 수없는시기에 대한 규칙은 매우 복잡하며이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">더 작은 데이터베이스 파일을 생성하는 부울 값의보다 효율적인 인코딩</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">특히 애플리케이션이 수백 또는 수천 개의 사용자 정의 함수를 정의하는 경우 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수를&lt;/a&gt; 보다 효율적으로 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">특히 응용 프로그램에서 수백 또는 수천 개의 사용자 지정 함수를 정의하는 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수를&lt;/a&gt; 보다 효율적으로 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">Windows에서 sqliteFileExists ()를보다 효율적으로 구현합니다. (조엘 루시 제작)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">메모리 부족 오류를보다 강력하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">더 제안 ...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">단일 쿼리에 둘 이상의 NEAR 연산자가 나타날 수 있습니다. 이 경우 NEAR 연산자로 구분 된 각 용어 또는 구 쌍은 문서에서 서로 지정된 거리 내에 있어야합니다. 위 예제 블록에서와 동일한 테이블 및 데이터 사용 :</target>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">대부분의 R * Tree 쿼리는 깊이 우선 검색을 사용합니다. 이는 rScore를 iLevel과 동일하게 설정하여 수행됩니다. 깊이 우선 검색은 우선 순위 대기열의 요소 수를 최소화하여 메모리 요구 사항을 줄이고 처리 속도를 높이기 때문에 일반적으로 선호됩니다. 그러나 일부 응용 프로그램에서는 너비 우선 검색을 선호 할 수 있는데, 이는 rScore를 mxLevel-iLevel로 설정하여 수행 할 수 있습니다. rScore에 대해보다 복잡한 수식을 만들어 응용 프로그램은 하위 트리가 검색되고 리프 R * Tree 항목이 반환되는 순서를 세부적으로 제어 할 수 있습니다. 예를 들어, 수백만 개의 R * Tree 항목이있는 응용 프로그램에서 가장 큰 또는 가장 중요한 항목이 먼저 반환되도록 응용 프로그램에서 가장 중요한 정보를 신속하게 표시 할 수 있도록 rScore를 정렬 할 수 있습니다.더 작고 중요하지 않은 세부 사항을 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진 (우리가 아는 한 SQLite 이외의 모든 SQL 데이터베이스 엔진)은 고정적이고 엄격한 타이핑을 사용합니다. 정적 타이핑을 사용하면 값의 데이터 유형이 컨테이너 (값이 저장되는 특정 열)에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 클라이언트 / 서버 기반입니다. 서버리스 서버 중에서 SQLite는이 작성자에게 알려진 유일한 응용 프로그램으로 여러 응용 프로그램이 동시에 동일한 데이터베이스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 클라이언트 / 서버 기반입니다. 서버리스 인 SQLite는이 작성자가 알고있는 유일한 응용 프로그램으로 여러 응용 프로그램이 동일한 데이터베이스에 동시에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 별도의 서버 프로세스로 구현됩니다. 데이터베이스에 액세스하려는 프로그램은 일종의 프로세스 간 통신 (일반적으로 TCP / IP)을 사용하여 서버와 통신하여 서버에 요청을 보내고 결과를 다시받습니다. SQLite는 이런 식으로 작동하지 않습니다. SQLite를 사용하면 데이터베이스에 액세스하려는 프로세스가 디스크의 데이터베이스 파일에서 직접 읽고 씁니다. 중개 서버 프로세스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 이미 다양한 시스템 테이블로 구문 분석 된 스키마를 저장합니다. 이러한 데이터베이스 엔진에서 ALTER TABLE은 해당 시스템 테이블을 수정하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 정적 입력을 사용합니다. 데이터 유형은 테이블의 각 열과 연관되며 해당 특정 데이터 유형의 값만 해당 열에 저장 될 수 있습니다. SQLite는 매니페스트 입력을 사용하여 이러한 제한을 완화합니다. 매니페스트 타이핑에서 데이터 유형은 값이 저장된 열이 아니라 값 자체의 속성입니다. 따라서 SQLite를 사용하면 사용자는 해당 열의 선언 된 유형에 관계없이 모든 데이터 유형의 값을 열에 저장할 수 있습니다. (이 규칙에는 몇 가지 예외가 있습니다. INTEGER PRIMARY KEY 열은 정수만 저장할 수 있습니다. SQLite는 가능한 경우 열의 선언 된 데이터 유형으로 값을 강제하려고 시도합니다.)</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">대부분의 응용 프로그램 형식은 다음 세 가지 범주 중 하나에 맞습니다.</target>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">대부분의 응용 프로그램은 이전 섹션에서 설명한 세션 모듈 기능 만 사용합니다. 그러나 변경 세트 및 패치 세트 Blob의 사용 및 조작을 위해 다음과 같은 추가 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">대부분의 응용 프로그램은 기본 구성에서 특별한 컴파일 타임 구성없이 SQLite와 잘 작동합니다. 대부분의 개발자는이 문서를 완전히 무시 하고 특별한 지식없이 특별한 조치를 취하지 않고 간단히 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 으로부터 SQLite를 구축 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">대부분의 빌드는 시스템 메모리 할당 루틴도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">대부분의 내장 윈도우 함수는 프레임 스펙을 무시합니다. 예외는 first_value (), last_value () 및 nth_value ()입니다. 내장 창 함수 호출의 일부로 FILTER 절을 지정하는 것은 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">대부분의 메모리 통계는 전역 적이므로 통계 추적은 뮤텍스로 직렬화되어야합니다. 통계는 기본적으로 켜져 있지만 비활성화 할 수있는 옵션이 있습니다. SQLite는 메모리 통계를 사용하지 않도록 설정하여 각 메모리 할당 및 할당 해제시 뮤텍스를 입력하거나 남기지 않습니다. 뮤텍스 운영이 비싼 시스템에서는 절감 효과가 눈에 can니다. 메모리 통계를 비활성화하려면 시작시 다음 인터페이스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">대부분의 객체 참조는 특정 유형의 객체로만 해석 될 수 있습니다 (예 : DROP TABLE 문의 일부인 참조는 색인, 트리거 또는 뷰가 아닌 테이블 객체로만 해석 될 수 있음). 그러나 일부 컨텍스트 (예 : &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; )에서 객체 참조는 여러 유형의 객체로 해석 될 수 있습니다. 명명 된 개체에 대한 데이터베이스 스키마를 검색 할 때 참조 컨텍스트에서 사용할 수없는 유형의 개체는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLite 소스 트리에있는 대부분의 코드는 순전히 &lt;a href=&quot;testing&quot;&gt;테스트 및 검증에&lt;/a&gt; 전념 합니다 . 안정성은 SQLite에 중요합니다. 테스트 인프라의 작업 중에는 SQLite가 동적으로 할당 된 메모리를 잘못 사용하지 않도록하고 SQLite가 메모리를 누출하지 않으며 SQLite가 동적 메모리 할당 실패에 올바르게 응답하는지 확인하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">대부분의 경우 sqlite3은 입력 행을 읽고 SQLite 라이브러리에 전달하여 실행합니다. 그러나 점 ( &quot;.&quot;)으로 시작하는 입력 라인은 sqlite3 프로그램 자체에 의해 인터셉트되고 해석됩니다. 이러한 &quot;점 명령&quot;은 일반적으로 쿼리의 출력 형식을 변경하거나 사전 패키지 된 특정 쿼리 문을 실행하는 데 사용됩니다. 원래는 몇 개의 점 명령이 있었지만 수년 동안 많은 새로운 기능이 누적되어 오늘날 60 개가 넘습니다.</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">대부분의 경우 SQLite의 쿼리 플래너는 잘 작동합니다. 그러나 쿼리 플래너가 작업하려면 인덱스가 필요합니다. 이 지수는 일반적으로 프로그래머가 추가해야합니다. 드물게 쿼리 플래너 AI가 최적의 알고리즘을 선택하지는 않습니다. 이 경우 프로그래머는 쿼리 플래너가 더 나은 작업을 수행 할 수 있도록 추가 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진은 대부분의 테이블에서 각 행에 대해 일정한 양의 디스크 공간을 할당했습니다. 길이가 매우 다양한 BLOB 및 CLOB 처리를위한 특수 트릭을 수행합니다. 그러나 대부분의 테이블에서 열을 VARCHAR (100)로 선언하면 데이터베이스 엔진은 해당 열에 실제로 저장하는 정보의 양에 관계없이 100 바이트의 디스크 공간을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진은 이보다 훨씬 큽니다. IBM은 최근 출시 된 CloudScape 데이터베이스 엔진이 압축 된 후에도 SQLite보다 훨씬 큰 2MiB jar 파일 인 &quot;단독&quot;임을 자랑합니다! Firebird는 클라이언트 측 라이브러리가 350KiB에 불과하다는 것을 자랑합니다. 그것은 SQLite만큼 크며 데이터베이스 엔진도 포함하지 않습니다. Oracle의 Berkeley DB 라이브러리는 450KiB이며 SQL 지원을 생략하여 프로그래머에게 간단한 키 / 값 쌍만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진에서는 한 플랫폼에서 다른 플랫폼으로 이동할 때 그리고 종종 최신 버전의 소프트웨어로 업그레이드 할 때 데이터베이스를 덤프하고 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">대부분의 프로그래머는 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation을&lt;/a&gt; 사용하여 SQLite를 응용 프로그램으로 컴파일합니다 . &lt;a href=&quot;amalgamation&quot;&gt;합병은&lt;/a&gt; C 코드이지만 &quot;소스 코드&quot;가 아닙니다. &lt;a href=&quot;amalgamation&quot;&gt;합병은&lt;/a&gt; 스크립트에 의해 소스 코드에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLite의 대부분의 테이블은 고유 정수 키 ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ) 와 내용이 포함 된 0 개 이상의 행 으로 구성됩니다. ( &lt;a href=&quot;withoutrowid&quot;&gt;without ROWID&lt;/a&gt; 테이블 은 예외입니다 .) 행은 rowid가 증가하는 순서대로 논리적으로 저장됩니다. 예를 들어,이 기사에서는 &quot;FruitsForSale&quot;이라는 테이블을 사용하여 다양한 과일을 재배 한 상태 및 시장의 단가와 관련시킵니다. 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">일반적인 SQLite 데이터베이스 스키마의 대부분의 테이블은 rowid 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">swarmvtab 사용자는 대부분 위에서 설명한 기능 만 사용합니다. 이 섹션에서는보다 난해한 사용 사례를 위해 설계된 기능에 대해 설명합니다. 이러한 기능에는 모두 CREATE VIRTUAL TABLE 명령의 일부로 SQL 문 다음에 추가 선택적 매개 변수를 지정하는 것이 포함됩니다. 선택적 매개 변수는 이름 다음에 &quot;=&quot;문자와 선택적으로 인용 된 값을 사용하여 지정됩니다. 공백은 이름 &quot;=&quot;문자와 값을 구분할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">BLOB 핸들을 새 행으로 이동</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">레지스터 P1..P1 + P3-1의 P3 값을 레지스터 P2..P2 + P3-1로 옮깁니다. 레지스터 P1..P1 + P3-1은 NULL을 유지합니다. 레지스터 범위 P1..P1 + P3-1 및 P2..P2 + P3-1이 겹치는 것은 오류입니다. P3이 1보다 작은 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">커서 P1을 널 행으로 이동하십시오. 커서가 널 행에있는 동안 발생하는 모든 &lt;a href=&quot;opcode#Column&quot;&gt;컬럼&lt;/a&gt; 조작은 항상 NULL을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">웹 사이트 및 문서 파일을 소스 트리에서 &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;별도의 CM 시스템으로 이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">CVS 저장소를 www.sqlite.org로 이동</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">SQLite 3.4.2에서 3.5.0으로 이동</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">SQLite 3.5.9에서 3.6.0으로 이동</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">한 데이터베이스에서 다른 데이터베이스로 저널 파일 이동</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/intro&quot;&gt;C 언어 인터페이스&lt;/a&gt; 의 대부분은 소스 파일 &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c에&lt;/a&gt; 있지만 일부 루틴은 파일 범위가있는 데이터 구조에 액세스 할 수있는 다른 파일에 흩어져 있습니다. &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 루틴에서 구현 &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt; . &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 루틴에서 발견된다 &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; 인터페이스에 &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt; . &lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 에 의해 구현된다 &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">다중 파일 트랜잭션</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">다중 문자 삽입, 삭제 및 대체는 비용 테이블에 열거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">여러 열 인덱스</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">다중 열 인덱스는 쿼리의 WHERE 절에있는 제약 조건 용어가 AND로 연결된 경우에만 작동합니다. 따라서 Idx3 및 Idx4는 오렌지와 캘리포니아에서 재배 된 품목을 검색 할 때 도움이되지만 오렌지색이었던 모든 품목을 원할 경우 인덱스가 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">여러 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">여러 VFS를 동시에 등록 할 수 있습니다. 각 VFS에는 고유 한 이름이 있습니다. 동일한 프로세스 내에서 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 다른 VFS를 동시에 사용할 수 있습니다. 따라서 단일 데이터베이스 연결에 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령을 사용하여 여러 데이터베이스 파일이 열려 있으면 연결된 각 데이터베이스가 다른 VFS를 사용하고있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">FTS 테이블에 레코드를 삽입하는 비용을 줄이기 위해 단일 b- 트리 대신 여러 b- 트리 구조가 사용됩니다. 이미 많은 데이터가 포함 된 FTS 테이블에 새 레코드가 삽입되면 새 레코드의 많은 용어가 이미 많은 수의 기존 레코드에있을 수 있습니다. 단일 b- 트리가 사용 된 경우 데이터베이스에서 큰 문서 목록 구조를로드하고 새 문서 및 용어 오프셋 목록을 포함하도록 수정 한 다음 데이터베이스에 다시 기록해야합니다. 여러 b- 트리 테이블을 사용하면 나중에 기존 b- 트리 (또는 b- 트리)와 병합 할 수있는 새 b- 트리를 만들어이를 피할 수 있습니다. b- 트리 구조의 병합은 백그라운드 작업으로 수행되거나 특정 수의 개별 b- 트리 구조가 누적되면 수행 될 수 있습니다. 물론이야,이 체계는 (FTS 코드가 하나 이상의 b- 트리에서 개별 용어를 찾아 결과를 병합해야 할 수도 있기 때문에) 쿼리를 더 비싸게 만들지 만 실제로는이 오버 헤드가 무시할 수있는 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">버전 3.15.0에서 도입 된 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 논리 에 대한 여러 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">다수의 주석가들은 포인터 유형에 동적 문자열을 사용하고 SQLite가 유형 문자열의 소유권을 갖도록하고 사용이 끝났을 때 자동으로 유형 문자열을 해제하려고합니다. 이 디자인은 다음과 같은 이유로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">이 비동기 IO 구현을 사용하는 단일 프로세스 내에서 다중 연결은 단일 데이터베이스 파일에 동시에 액세스 할 수 있습니다. 사용자 관점에서 모든 연결이 단일 프로세스 내에있는 경우 비동기 백엔드를 사용하는 &quot;정상&quot;SQLite와 SQLite에서 제공하는 동시성에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">여러 연결이 동시에 읽기 잠금을 유지할 수 있습니다. 많은 스레드가 겹치는 읽기 잠금을 획득하는 경우 하나 이상의 스레드가 항상 읽기 잠금을 보유하는 경우 일 수 있습니다. 그런 다음 쓰기 잠금을 기다리는 테이블은 영원히 기다립니다. 이 시나리오를 &quot;작가 기아&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE를&lt;/a&gt; 사용하여 동일한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 여러 데이터베이스</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">여러 프로세스가 동일한 응용 프로그램 파일에 첨부 할 수 있으며 서로 방해하지 않고 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">여러 프로세스가 동시에 동일한 데이터베이스를 열 수 있습니다. 여러 프로세스가 동시에 SELECT를 수행 할 수 있습니다. 그러나 한 번에 하나의 프로세스 만 데이터베이스를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">여러 개의 작은 정렬은 단일의 큰 정렬보다 CPU주기를 더 적게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 값에 레지스터 P2의 값을 곱하고 결과를 레지스터 P3에 저장합니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">null에 0을 곱하면 null이됩니다.</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">돌연변이 테스트 스크립트</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">각 테스트는 빠른 워크 스테이션에서 최대 5 분이 소요될 수 있으며 각 분기 명령에 대해 두 개의 테스트와 20,000 개 이상의 분기 명령이 있으므로 돌연변이 테스트가 느려질 수 있습니다. 신속한 작업을 위해 노력합니다. 예를 들어 TH3는 첫 번째 오류를 발견하자마자 빠져 나가는 방식으로 컴파일되며 많은 돌연변이가 쉽게 감지되면 몇 초 안에 많은주기가 발생합니다. 그럼에도 불구하고 mutation-test.tcl 스크립트에는 명령 줄 옵션이 포함되어있어 테스트 된 코드 라인의 범위를 제한하여 최근에 변경된 코드 블록에서만 돌연변이 테스트를 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">뮤텍스 핸들</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">뮤텍스 메소드 객체</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">뮤텍스 유형</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">뮤텍스 검증 루틴</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">뮤텍스는 저렴하지만 무료가 아니므로 뮤텍스가 완전히 비활성화되면 성능이 향상됩니다. 결과 라이브러리 풋 프린트도 약간 줄어 듭니다. 컴파일 타임에 뮤텍스를 비활성화하는 것이 적합한 응용 프로그램에 권장되는 최적화 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">뮤텍스는 &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()을&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">뮤텍스는 &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()을&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">WHERE 절 표현식 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 이 작동하지 않습니다. column1의 값이 &quot;column1&quot;인 행뿐만 아니라 테이블의 모든 행이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">내 쿼리가 예상 한 열 이름을 반환하지 않습니다. 이것이 버그입니까?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="translated">MySQL은 UPDATE FROM 아이디어를 지원하지만 FROM 절을 사용하지 않고 지원합니다. 대신 완전한 조인 사양이 UPDATE 및 SET 키워드 사이에 제공됩니다. 동등한 MySQL 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL 버전 3.23.41은 UNION을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12 및 짝수</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13과 홀수</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1 (비용 : 5.52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2 (비용 : 5.52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1 (비용 : 11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">고유 문자 (70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB :이 확장은 더 이상 사용되지 않습니다. 대체품으로는 [WAL 모드]가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">NEAR 개의 검색어</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">NEAR 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">NEW 및 OLD 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">새로운 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN 일</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN 시간</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN 분</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN 개월</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN 년</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNN.NNNN 초</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">존재하지 않는 연산자</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">NOT IN 연산자</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">NOT NULL 제약</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL 제약 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="translated">NUL 문자 (ASCII 코드 0x00 및 유니 코드 \ u0000)는 SQLite의 문자열 중간에 나타날 수 있습니다. 이로 인해 예기치 않은 동작이 발생할 수 있습니다. 자세한 내용은 &quot; &lt;a href=&quot;nulinstr&quot;&gt;문자열의 NUL 문자&lt;/a&gt; &quot;문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLite의 NULL 처리</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">다른 데이터베이스 엔진과 SQLite의 NULL 처리</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL 값 (직렬 유형 0)이 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL 값은 이제 빈 문자열이 아닌 NULL 포인터로 콜백에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">마지막 NULL</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULL이 먼저 정렬</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">호스트 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">데이터베이스 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">임시 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">기본 데이터 정렬 시퀀스의 이름</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">WINDOW 절을 사용하여 명명 된 window-defn 절을 SELECT 문에 추가 한 다음 창 함수 호출 내에서 이름으로 참조 할 수도 있습니다. 예를 들어 다음 SELECT 문에는 &quot;win1&quot;및 &quot;win2&quot;라는 두 개의 명명 된 window-defs 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">이름 변경</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">거의 모든 시스템에는 C로 작성된 라이브러리를 호출 할 수있는 기능이 있습니다. 이것은 다른 구현 언어에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">&quot;.width&quot;명령의 음수는 오른쪽 정렬을 유발합니다</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 및 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO를&lt;/a&gt; 사용하는 중첩 트랜잭션</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">하나님의 자비를 절대 절망하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">그럼에도 불구하고 응용 프로그램 개발자는 메모리 할당 하위 시스템의 상태를 모니터링하고 메모리 사용량이 Robson 제한에 도달하거나이를 초과하면 경보를 발생시키는 것이 좋습니다. 이러한 방식으로 응용 프로그램은 오류 발생 전에 운영자에게 풍부한 경고를 제공합니다. SQLite 의 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 인터페이스는이 작업의 모니터링 부분을 완료하는 데 필요한 모든 메커니즘을 응용 프로그램에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">그럼에도 불구하고 버그가 발생합니다. 신뢰할 수없는 SQL 입력 또는 데이터베이스 파일을 SQLite로 보내는 응용 프로그램을 작성하는 경우 공격 영역을 줄이고 감지되지 않은 버그로 인한 제로 데이 악용을 방지하기 위해 수행 할 수있는 추가 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">그럼에도 불구하고, 메모리 할당 크기 계산에서 정수 오버플로는 SQLite가 처리하고자하는 관심사입니다. 문제를 방지하기 위해 모든 SQLite 내부 메모리 할당은 부호있는 64 비트 정수 크기 매개 변수를 사용하는 씬 래퍼 함수를 ​​사용하여 발생합니다. 모든 크기 계산이 64 비트 부호있는 정수를 사용하여 수행되도록 SQLite 소스 코드를 감사합니다. SQLite는 한 번에 약 2GB 이상의 메모리 할당을 거부합니다. (일반적으로 SQLite는 한 번에 약 8KB 이상의 메모리를 할당하는 경우가 거의 없으므로 2GB 할당 제한이 부담이되지 않습니다.) 따라서 64 비트 크기 매개 변수는 오버플로를 감지하기위한 많은 여유 공간을 제공합니다. 모든 크기 계산이 64 비트 부호있는 정수로 수행되는지 확인하는 동일한 감사도 계산 중에 64 비트 정수를 오버플로 할 수 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">그럼에도 불구하고 100 % 완벽한 소프트웨어는 없습니다. SQLite (현재 수정)에는 데이터베이스 손상을 일으킬 수있는 몇 가지 역사적 버그가있었습니다. 그리고 아직 밝혀지지 않은 것들이 더있을 수 있습니다. 광범위한 테스트와 SQLite의 광범위한 사용으로 인해 데이터베이스 손상을 초래하는 버그는 매우 모호한 경향이 있습니다. 응용 프로그램에서 SQLite 버그가 발생할 가능성은 적습니다. 이를 설명하기 위해 2009-04-01에서 2013-04-15까지 4 년 동안 SQLite에서 발견 된 모든 데이터베이스 손상 버그에 대해 설명합니다. 이 계정은 독자들에게 SQLite의 버그 종류에 대한 직관적 인 이해를 제공하여 테스트 절차를 거쳐 릴리스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">새로운 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt; 컴파일 타임 옵션 추가</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">새로운 변화</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">새로운 파일 형식</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">내장 된 날짜 / 시간 기능에 대한 새로운 HH : MM : SS 수정 자.</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">새로운 VFS는 sqlite3_vfs_register ()에 등록됩니다. makeDflt 플래그가 설정되면 각각의 새로운 VFS는 기본 VFS가됩니다. 동일한 VFS를 부상없이 여러 번 등록 할 수 있습니다. 기존 VFS를 기본 VFS로 만들려면 makeDflt 플래그가 설정된 상태로 다시 VFS를 등록하십시오. 이름이 같은 두 개의 다른 VFS가 등록되면 동작이 정의되지 않습니다. VFS가 NULL 또는 빈 문자열 인 이름으로 등록 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">새로운 응용 프로그램을해야 항상 호출 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()을&lt;/a&gt; . 이전 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 는 이전 버전과의 호환성을 위해 유지됩니다. 그러나 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 는 훨씬 더 나은 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 다음에서 리턴 코드를 확인해야합니다.&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 다음에서 리턴 코드를 확인해야합니다.&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt;확인하여 호출이 작동했는지 확인해야합니다. 그만큼&lt;a href=&quot;#sqlite3_db_config&quot;&gt; sqlite3_db_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 에서 리턴 코드를 확인해야합니다. 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;../rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. 그만큼&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;../rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">SQLite가 만든 새 데이터베이스 파일은 기본적으로 형식 4를 사용합니다. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그&lt;/a&gt; 형식의 버전 번호는 설정에 의해 1 대신에 4 기본값으로 만들 수 있습니다 형식 (1)을 사용하여 새 데이터베이스 파일을 만들 SQLite는을 야기 할 수 있습니다&lt;a href=&quot;compile#default_file_format&quot;&gt; SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; 컴파일시 = 1.</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">향후 버전의 SQLite에는 새로운 오류 코드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">새로운 확장 :</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">일반적인 사용을 위해 25 ~ 35 % 더 작은 새로운 파일 형식.</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">이후 버전의 SQLite에는 새로운 플래그가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">응용 프로그램 정의 SQL 함수를 호출 한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들 을 리턴하는 새로운 인터페이스 &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">새로운 인터페이스 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하면 연결 및 런타임마다 크기 및 길이 제한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">새로운 인터페이스 : sqlite3_bind_parameter_index ()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c 애드온 모듈에 새로운 인터페이스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">항상 &quot;sqlite_&quot;로 시작하는 새로운 내부 스키마 객체 이름은 향후 릴리스에서 SQLite 파일 형식에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">새로운 메모리 할당자는 SQLite 소스 트리의 일부이거나 sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 포함되지 않아도됩니다. . 개별 응용 프로그램은 시작시 SQLite에 자체 메모리 할당자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">보조 메모리 사용을 구성하기위한 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 새로운 옵션 : --pagecache, --lookaside 및 --scratch</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">새로운 쿼리 최적화 :</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">새로운 런타임 제한 범주는 다음 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">새로운 상태 매개 변수가 때때로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">테스트 스위트에 새로운 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">SQLite의 향후 향상을 위해 새로운 텍스트 토큰이 통계 열의 끝에 추가 될 수 있습니다. 호환성을 위해 통계 열의 끝에서 인식 할 수없는 토큰은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">다음 릴리스에서는 새로운 추적 상수가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">향후 SQLite 릴리스에 새 동사가 추가 될 수 있습니다. 기존 동사가 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 단종 또는 지원되지 않는 동사가 불려 갔을 경우 인터페이스 0이 아닌 에러 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLite의 향후 릴리스에 새로운 동사가 추가 될 수 있습니다. 기존 동사가 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 단종 또는 지원되지 않는 동사가 불려 갔을 경우 인터페이스 0이 아닌 에러 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">새로운 zip 아카이브는 zipfile () 집계 함수를 사용하여 메모리 내에 완전히 구성 될 수 있습니다. 집계 함수가 방문한 각 행은 Zip 아카이브에 항목을 추가합니다. 반환 된 값은 전체 아카이브 이미지를 포함하는 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">그러나 최신 디스크 드라이브는 4096 바이트 섹터를 사용하기 시작했습니다. SQLite 개발 팀 은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16) 부터 xSectorSize 변경을 실험하여 폭발 반경으로 4096 바이트를보고했습니다. 이는 많은 데이터베이스에서 쓰기 오버 헤드를 증가시키는 효과가있었습니다. 기호가있는 데이터베이스의 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA의 PAGE_SIZE&lt;/a&gt; 그것은 단지 한 페이지 즉 백업 한 이전 반면 데이터베이스의 단일 페이지에 대한 변경을 1,024 (매우 일반적인 선택)의 지금 롤백 저널에 백업 세 가지 다른 인접 페이지에 SQLite는 필요 바뀌고 있었다. 에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; , 각 거래는 거래 당 기록되는 추가 바이트의 수천의 결과로, 오히려 다음 512 바이트 경계보다는 WAL 파일에 다음 4096 바이트 경계 밖으로 패딩했다.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">다음으로, 다음과 같은 명령을 사용하여 모든 블로 브를 디렉토리의 개별 파일로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">그런 다음 결과 kvtest-android 실행 파일을 Android 장치로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">다음으로 오렌지뿐만 아니라 캘리포니아에서 자란 오렌지의 가격을 찾고 싶다고 가정 해보십시오. 적절한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">아니요 (주 1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">동일한 데이터베이스 연결에서 작업간에 격리가 없음</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">작성 및 디버그 할 애플리케이션 파일 I / O 코드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">변경 없음</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">현재 또는 충돌하는 행 정보가 제공되지 않습니다. 제공된 sqlite3_changeset_iter 핸들에서 호출 할 수있는 유일한 함수는 sqlite3changeset_fk_conflicts ()입니다.</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="translated">너비 또는 정밀도가 SQLITE_PRINTF_PRECISION_LIMIT를 초과하면 오류가 발생하지 않습니다. 대신 큰 너비 또는 정밀도가 자동으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">알 수없는 pragma가 발행되면 오류 메시지가 생성되지 않습니다. 알 수없는 pragma는 단순히 무시됩니다. 이것은 pragma 문에 오타가 있으면 라이브러리는 사용자에게 사실을 알리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">잠금 스타일이 없습니다. 위의 사항 중 어느 것도 지원할 수없는 경우이 잠금 스타일이 사용됩니다. 데이터베이스 잠금 메커니즘이 사용되지 않습니다. 이 시스템을 사용하면 여러 클라이언트가 단일 데이터베이스에 액세스하는 것이 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">데이터베이스에서 잠금이 유지되지 않습니다. 데이터베이스를 읽거나 쓸 수 없습니다. 내부적으로 캐시 된 데이터는 모두 의심스러운 것으로 간주되며 사용하기 전에 데이터베이스 파일에 대한 검증 대상이됩니다. 다른 프로세스는 자체 잠금 상태가 허용하는대로 데이터베이스를 읽거나 쓸 수 있습니다. 이것이 기본 상태입니다.</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">더 이상 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">누구도 규칙을 따르거나 규칙을 알고 있거나 규칙이 좋은 생각이라고 생각할 필요가 없습니다. SQLite의 창립자는 규칙을 따르는 사람은 누구나 더 행복하고 생산적인 삶을 살 것으로 생각하지만 개인은 원하는 경우 그 조언에 자유롭게 이의를 제기하거나 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">다른 프로세스는 데이터베이스를 변경할 수 없으므로 트랜잭션 시작시 변경 카운터를 확인하고 사용자 공간 캐시를 지울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">RBU 업데이트가 적용되는 동안 대상 데이터베이스에서 다른 쓰기가 발생할 수 없습니다. 이를 방지하기 위해 대상 데이터베이스에 읽기 잠금이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">트랜잭션을 제외하고는 읽거나 쓰지 않습니다. 데이터베이스에 액세스하는 모든 명령 (기본적으로 일부 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문을 제외한 모든 SQL 명령 )은 트랜잭션이 아직 유효하지 않은 경우 자동으로 트랜잭션을 시작합니다. 마지막 SQL 문이 완료되면 자동으로 시작된 트랜잭션이 커미트됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">union-vtab의 테이블에 의해 설정된 rowid 범위를 벗어난 항목이 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">SQLite 데이터베이스에서 정보를 삭제하면 사용되지 않은 디스크 공간이 내부 &quot;사용 가능 목록&quot;에 추가되고 다음에 데이터를 삽입 할 때 재사용됩니다. 디스크 공간이 손실되지 않습니다. 그러나 운영 체제로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">비 ASCII 범위 문자 (즉, 127보다 큰 유니 코드 코드 포인트) 또는</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Vista 이외의 Windows 플랫폼은 하나의 DST 규칙 세트 만 지원합니다. Vista는 두 가지만 지원합니다. 따라서 이러한 플랫폼에서 히스토리 DST 계산은 올바르지 않습니다. 예를 들어 미국에서는 2007 년에 DST 규칙이 변경되었습니다. Vista 이외의 Windows 플랫폼은 이전 2007 년에도 새로운 2007 DST 규칙을 적용합니다. Vista는 규칙이 변경되었을 때 1986 년으로 돌아가서 결과를 올바르게 얻는 것이 다소 나아졌습니다.</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">비 결정적 함수는 인수가 항상 같더라도 호출마다 다른 응답을 제공 할 수 있습니다. 다음은 비 결정적 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">비 스트리밍 동등</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">변경 세트 (또는 패치 세트)를 입력으로 허용하는 비 스트리밍 기능을 사용하려면 전체 변경 세트를 메모리의 단일 버퍼에 저장해야합니다. 마찬가지로, 변경 세트 또는 패치 세트를 반환하는 것은 sqlite3_malloc ()을 사용하여 할당 된 하나의 큰 버퍼에 대한 포인터를 반환함으로써 그렇게합니다. 일반적으로 이것은 편리합니다. 그러나 메모리가 적은 환경에서 실행되는 응용 프로그램이 매우 큰 변경 세트를 처리해야하는 경우 필요한 대량의 연속 메모리 할당이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">SQLite가 존재 한 첫 10 년 동안 안전한 프로그래밍 언어는 존재하지 않았습니다. SQLite는 Go 또는 Rust로 코딩 될 수 있지만 그렇게하면 수정 된 것보다 훨씬 많은 버그가 발생할 수 있으며 코드 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">xBegin ()에 대한 호출과 xCommit () 또는 xRollback () 사이를 제외하고 xSavepoint (), xRelease () 또는 xRollbackTo () 메소드는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">일반 함수는 xFunc 만 지정하고 xStep 및 xFinal은 NULL로 설정합니다. 집계 함수는 xStep 및 xFinal을 지정하고 xFunc를 NULL로 설정합니다. 별도의 sqlite3_create_aggregate () API가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="translated">정상적인 의미</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">일반적으로 FTS5는 기본 FTS5 테이블에 삽입 된 토큰에 각 열 값의 크기를 별도의 테이블에 저장하는 특수 백업 테이블을 데이터베이스 내에 유지합니다. 이 백업 테이블은 &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API 함수에서 사용되며 내장 된 &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 순위 함수 &lt;/a&gt;에서 사용되며 다른 순위 함수에도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">일반적으로 NULL SQL 결과는 &lt;a href=&quot;#nullvalue&quot;&gt;널값&lt;/a&gt; 설정을 사용하여 배열에 저장됩니다 . 그러나 &lt;b&gt;-withoutnulls&lt;/b&gt; 옵션을 사용하면 NULL SQL 값으로 인해 해당 배열 요소가 대신 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">일반적으로 SQLite는 섹터의 일부를 업데이트하는 동안 정전이 발생하면 복구 후 전체 장치 섹터의 내용이 의심되는 것으로 가정합니다. 파일 내의 섹터의 어느 부분 에나 쓴 후, 수정 된 섹터 내용은 시스템 내의 어딘가에 휘발성 버퍼 (메인 메모리, 디스크 캐시 등)에 저장되어 있다고 가정합니다. SQLite는 업데이트 된 데이터가 성공적으로 완료 될 때까지 영구 스토리지 미디어에 도달했다고 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">일반적으로 토큰 또는 토큰 접 두부 쿼리는 MATCH 연산자의 왼쪽으로 지정된 FTS 테이블 열과 일치합니다. 또는 FTS 테이블과 이름이 같은 특수 열이 지정된 경우 모든 열에 대해 지정됩니다. 기본 용어 쿼리 전에 column-name 다음에 &quot;:&quot;문자를 지정하여이를 대체 할 수 있습니다. &quot;:&quot;과 쿼리 할 용어 사이에 공백이있을 수 있지만 column-name과 &quot;:&quot;문자 사이에는 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">일반적으로 SQL 인덱스는 테이블의 열을 참조합니다. 그러나 테이블 열과 관련된 표현식에서 인덱스를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">일반적으로 화석은 개인과 공용 지점 사이를 전환 할 때 체크 아웃의 모든 파일을 수정합니다. 그러나이 시점에서 파일은 두 분기에서 동일하므로 수정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">일반적으로 전체 텍스트 쿼리는 대소 문자를 구분하지 않습니다. 그러나 이는 쿼리중인 FTS 테이블에서 사용 하는 특정 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 에 따라 다릅니다 . 자세한 내용 은 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">일반적으로 FTS 모듈은 테이블의 모든 열에있는 모든 항의 역 인덱스를 유지합니다. 이 옵션은 항목을 색인에 추가하지 않아야하는 열 이름을 지정하는 데 사용됩니다. 인덱스에서 여러 열을 생략하도록 지정하기 위해 여러 개의 &quot;인덱싱되지 않은&quot;옵션을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">일반적으로 데이터베이스 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 데이터베이스가 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum을&lt;/a&gt; 지원하는지 여부 는 데이터베이스 파일이 실제로 작성되기 전에 구성되어야합니다. 그러나 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 모드 가 아닌 경우 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 / 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragma를 사용하여 데이터베이스를 즉시 VACUUMing 하여 기존 데이터베이스 의 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 / 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 속성을 변경할 수 있습니다 . 에 때 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 모드 만 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum의&lt;/a&gt; 지원 속성은 진공을 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">일반적으로 SQLite는 데이터베이스 파일에 쓸 때 쓰기 작업이 완료 될 때까지 기다렸다가 호출 응용 프로그램에 제어권을 반환합니다. 파일 시스템에 쓰는 것은 일반적으로 CPU 바운드 작업에 비해 매우 느리기 때문에 성능 병목 현상이 발생할 수 있습니다. 비동기 I / O 백엔드는 SQLite가 백그라운드에서 실행되는 별도의 스레드를 사용하여 모든 쓰기 요청을 수행하도록하는 확장입니다. 이렇게해도 전체 시스템 리소스 (CPU, 디스크 대역폭 등)가 줄어들지는 않지만 데이터베이스에 쓸 때에도 SQLite가 호출자에게 제어권을 신속하게 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">일반적으로 행이 다양한 전체 텍스트 인덱스 항목 및 기타 데이터뿐만 아니라 FTS5 테이블에 삽입 될 때 행의 사본은 FTS5 모듈이 관리하는 개인 테이블에 저장됩니다. 사용자 또는 보조 기능 구현이 FTS5 테이블에서 컬럼 값을 요청하면이 개인 테이블에서 컬럼 값을 읽습니다. &quot;content&quot;옵션을 사용하면 FTS 전체 텍스트 인덱스 항목 만 저장하는 FTS5 테이블을 만들 수 있습니다. 열 값 자체는 일반적으로 연관된 전체 텍스트 인덱스 항목보다 훨씬 크기 때문에 상당한 데이터베이스 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">모든 응용 프로그램이 이러한 조건을 충족하는 것은 아닙니다. 다행히도 NGQP는 이러한 조건이 없더라도 여전히 좋은 쿼리 계획을 찾습니다. 그러나 성능 회귀가 발생할 수있는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">모든 테스트 사례를 이러한 방식으로 처리 할 수있는 것은 아닙니다. 일부 테스트 사례는 디스크 액세스 수, 정렬 작업, 전체 스캔 단계 또는 쿼리 중에 발생하는 기타 처리 단계를 계산하여 최적화가 실제로 계산량을 줄이고 있는지 확인합니다. 최적화가 비활성화되면 해당 테스트 사례가 실패한 것으로 나타납니다. 그러나 대부분의 테스트 사례는 단순히 정답을 얻었는지 확인하고 최적화가 오작동을 일으키지 않음을 나타 내기 위해 모든 경우를 최적화 유무에 관계없이 성공적으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">위의 예 에는 새 테이블의 다양한 측면을 구성하기 위해 CREATE VIRTUAL TABLE 문의 일부로 FTS5에 제공 할 수있는 &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;다양한 옵션&lt;/a&gt; 도 있습니다. FTS5 테이블이 문서 및 쿼리에서 용어를 추출하는 방식을 수정하거나 디스크에 추가 인덱스를 생성하여 접두사 쿼리 속도를 높이거나 다른 곳에 저장된 콘텐츠에 대한 인덱스 역할을하는 FTS5 테이블을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건을&lt;/a&gt; 추가 할 때 CHECK 제약 조건은 기존 테이블 행에 대해 테스트되지 않습니다. 이로 인해 CHECK 제약 조건을 위반하는 데이터가 포함 된 테이블이 생성 될 수 있습니다. 이후 버전의 SQLite는 CHECK 제약 조건이 추가 될 때 유효성을 검사하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">&quot;단일 증가&quot;는 ROWID가 항상 정확히 1 씩 증가한다는 것을 의미하지는 않습니다. 하나는 일반적인 증분입니다. 그러나 고유 제한 조건으로 인해 삽입에 실패하면 실패한 삽입 시도의 ROWID가 후속 삽입에서 재사용되지 않아 ROWID 순서에 공백이 생길 수 있습니다. AUTOINCREMENT는 자동으로 선택된 ROWID가 증가하지만 순차적 인 것은 아님을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 응용 프로그램이 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의 하면 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;../appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 애플리케이션이 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의하는 경우 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">참고 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수는&lt;/a&gt; 기본적으로 비 결정적으로 간주되고,하지 않는 한 CREATE INDEX 문에 사용되지 않을 수 있습니다 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 함수가 등록 될 때 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 애플리케이션이 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의하는 경우 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">참고 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수는&lt;/a&gt; 기본적으로 비 결정적으로 간주되고,하지 않는 한 CREATE INDEX 문에 사용되지 않을 수 있습니다 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 함수가 등록 될 때 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 응용 프로그램이 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의 하면 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Idx3에는 원본 &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt; 과 동일한 정보가 모두 포함되어 있습니다 . 따라서 Idx3이 있다면 더 이상 Idx1이 필요하지 않습니다. &quot;복숭아 가격&quot;쿼리는 Idx3의 &quot;상태&quot;열을 무시하여 Idx3을 사용하여 만족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">MinGW는 32 비트 DLL 만 생성합니다. 64 비트 DLL을 생성하는 데 사용할 수있는 별도의 MinGW64 프로젝트가 있습니다. 아마도 명령 줄 구문은 비슷합니다. 또한 최신 버전의 MSVC는 WinXP 및 이전 버전의 Windows에서는 작동하지 않는 DLL을 생성합니다. 따라서 생성 된 DLL의 최대 호환성을 위해 MinGW가 권장됩니다. 가장 좋은 방법은 MinGW를 사용하여 32 비트 DLL을 생성하고 MSVC를 사용하여 64 비트 DLL을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNORE는 &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 반환 된 &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNORE는 &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 반환 된 &lt;a href=&quot;c_fail&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">SQLite를 사용하면 IN 또는 NOT IN 연산자의 오른쪽에있는 괄호로 묶인 스칼라 값 목록이 빈 목록이 될 수 있지만 대부분의 다른 SQL 데이터베이스 데이터베이스 엔진 및 SQL92 표준에는 목록에 하나 이상의 요소가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">SQLite는 적절한 확장자 접미사 (Windows의 경우 &quot;.dll&quot;, Mac의 경우 &quot;.dylib&quot;, 대부분의 다른 유닉스의 경우 &quot;.so&quot;)를 자동으로 확장자 파일 이름에 추가합니다. 일반적으로 확장자의 전체 경로 이름을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLite에는 압도적 인 대다수의 응용 프로그램에 완벽하게 적합한 여러 &lt;a href=&quot;../malloc#altalloc&quot;&gt;내장 메모리 할당자가 포함&lt;/a&gt; 되어 있으며이 객체는 특수한 메모리 할당 요구 사항을 가진 소수의 응용 프로그램에만 유용합니다. 이 객체는 또한 SQLite가 이러한 조건에서 정상적으로 복구되는지 확인하기 위해 메모리 부족 메모리 조건을 시뮬레이트하는 대체 메모리 할당자를 지정하기 위해 SQLite를 테스트하는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLite에는 압도적 인 대다수의 응용 프로그램에 완벽하게 적합한 여러 &lt;a href=&quot;malloc#altalloc&quot;&gt;내장 메모리 할당자가 포함&lt;/a&gt; 되어 있으며이 객체는 특수한 메모리 할당 요구 사항을 가진 소수의 응용 프로그램에만 유용합니다. 이 객체는 또한 SQLite가 이러한 조건에서 정상적으로 복구되는지 확인하기 위해 메모리 부족 메모리 조건을 시뮬레이트하는 대체 메모리 할당자를 지정하기 위해 SQLite를 테스트하는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">SQLite는 WITHOUT ROWID 가상 테이블에 대해 PRIMARY KEY를 시행하지 않습니다. 적용은 기본 가상 테이블 구현의 책임입니다. 그러나 SQLite는 PRIMARY KEY 제약 조건이 유효하다고 가정합니다. 식별 된 열은 실제로 UNIQUE이며 NOT NULL이 아니며 가상 테이블에 대해 쿼리를 최적화하기 위해 해당 가정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">SQLite는 운영 체제 및 하드웨어가 동기화 요청의 상태에 대해 알려주는 것을 믿어야합니다. SQLite가 거짓말 중이거나 쓰기가 잘못되었음을 감지하는 방법은 없습니다. 그러나 &lt;a href=&quot;wal&quot;&gt;WAL 모드의&lt;/a&gt; SQLite 는 기본 롤백 저널 모드보다 비 순차적 쓰기를 용서합니다. WAL 모드에서 실패한 동기화 작업으로 인해 데이터베이스가 손상 될 수있는 유일한 시간은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업 중입니다. COMMIT 중 동기화 실패로 인해 내구성이 손실 될 수 있지만 데이터베이스 파일은 손상되지 않습니다. 따라서 동기화 조작 실패로 인한 데이터베이스 손상에 대한 한 가지 방어선은 WAL 모드에서 SQLite를 사용하고 가능한 한 자주 체크 포인트를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">SQLite는 정렬 된 데이터 구조 인 b- 트리를 사용하므로 SELECT 문의 WHERE 절에 동등 또는 부등식에 대한 테스트가 포함 된 경우 인덱스를 사용할 수 있습니다. 다음과 같은 쿼리는 사용 가능한 경우 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">선언 된 유형의 &quot;FLOATING POINT&quot;는 &quot;POINT&quot;의 끝에있는 &quot;INT&quot;로 인해 RETE 선호도가 아닌 INTEGER 선호도를 제공합니다. 선언 된 &quot;STRING&quot;유형은 TEXT가 아니라 NUMERIC의 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">다각형을 뒤집는 변형은 꼭지점 순서가 뒤바뀔 수 있습니다. 다시 말해, 변환으로 꼭지점이 시계 반대 방향이 아닌 시계 방향으로 순환 할 수 있습니다. 변환 후 &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw ()&lt;/a&gt; 함수를 통해 결과를 보내서이를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">내부 트랜잭션은 커밋 (RELEASE 명령 사용) 할 수 있지만 나중에 외부 트랜잭션에서 ROLLBACK에 의해 작업이 취소됩니다. 정전 또는 프로그램 충돌 또는 OS 충돌로 인해 가장 바깥 쪽 트랜잭션이 롤백되어 해당 외부 트랜잭션 내에서 발생한 모든 변경 사항을 취소하고 RELEASE 명령에 의해 &quot;커밋 된&quot;변경 내용도 취소됩니다. 가장 바깥 쪽 트랜잭션이 커밋 될 때까지 실제로 콘텐츠는 디스크에서 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">여러 원격 변경 집합의 충돌 해결은 행 단위가 아니라 필드 단위로 결합됩니다. 이는 다중 원격 UPDATE 조작의 경우 단일 로컬 변경의 일부 필드는 REPLACE에 대해 리베이스되고 다른 필드는 OMIT에 대해 리베이스 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be와 UTF-16le 간의 변환은 항상 제자리에서 수행되며 이전 포인터가 가리키는 버퍼의 내용이 수정 되었음에도 불구하고 이전 포인터를 무효화하지 않습니다. 다른 종류의 변환은 가능할 때 수행되지만 언젠가는 불가능하며 이러한 경우 이전 포인터가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">zip 아카이브에서 레코드를 삭제해도 아카이브 내에서 사용 된 공간을 회수하지는 않습니다. 아카이브 &quot;중앙 디렉토리 구조&quot;에서 항목을 제거하기 만하면 항목에 액세스 할 수 없습니다. 이 비 효율성을 해결하는 한 가지 방법은 편집 된 아카이브의 내용을 기반으로 새 zip 아카이브를 만드는 것입니다. 예를 들어 가상 테이블 temp.zzz를 통해 액세스 한 아카이브를 편집 한 후 :</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">운영 체제마다 공유 라이브러리에 다른 파일 이름 접미사를 사용합니다. Windows는 &quot;.dll&quot;을 사용하고 Mac은 &quot;.dylib&quot;를 사용하며 mac 이외의 대부분의 유닉스는 &quot;.so&quot;를 사용합니다. 코드를 이식 가능하게 만들려면 공유 라이브러리 파일 이름에서 접미사를 생략하면 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스에 의해 적절한 접미사가 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">shm 파일의 각 32768 바이트 단위에는 고유 한 aHash 및 aPgno 배열이 있습니다. 단일 장치의 aHash 배열은 동일한 장치에서 aPgno 항목을 찾는 데만 도움이됩니다. 전체 FindFrame (P, M) 함수는 최신 단위로 시작하여 해답을 찾을 때까지 가장 오래된 단위로 거꾸로 해시 조회를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">FTS3을 활성화하면 FTS4도 사용할 수 있습니다. 별도의 SQLITE_ENABLE_FTS4 컴파일 타임 옵션이 없습니다. SQLite 빌드는 FTS3과 FTS4를 모두 지원하거나 둘 다 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">위에서 상세하게 설명한 몇 가지 대소 문자 차이를 제외하고 WITHOUT ROWID 테이블과 rowid 테이블은 동일하게 작동합니다. 그들은 동일한 SQL 문이 주어지면 동일한 대답을 생성합니다. 따라서 WITHOUT ROWID 테이블 사용이 도움이 될지 여부를 테스트하기 위해 개발주기 후반에 애플리케이션에서 실험을 실행하는 것은 간단합니다. 좋은 전략은 제품 개발이 끝날 때까지 ROWID없이 걱정하지 말고, 정수가 아닌 PRIMARY KEY가있는 테이블에 ROWID없이 ROWID를 추가하여 성능을 향상 시키거나 손상시키는 지 확인하고 ROWID 만 유지하는 것입니다. 도움이되는 경우.</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">geopoly는 왼쪽 아래에 원점이있는 전통적인 오른손 데카르트 좌표계를 사용하는 반면 SVG는 왼쪽 위에 원점이있는 왼손 좌표계를 사용합니다. geopoly_svg () 루틴은 좌표계 변환을 시도하지 않으므로 표시된 이미지가 미러 이미지로 표시되고 회전됩니다. 이것이 바람직하지 않은 경우, geopoly_xform () 루틴을 사용하여 다각형을 geopoly_svg ()로 전달하기 전에 출력을 직교에서 SVG 좌표로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">비 결정적 함수에 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 태그가 지정 되고 해당 함수가 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; 에서 사용되면 함수가 다른 응답을 리턴하기 시작하면 연관된 인덱스가 손상 될 수 있습니다. . SQL 함수가 거의 결정 론적이며 (즉, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같이 거의 변경되지 않는 경우 ) 손상된 인덱스에서 사용되는 경우 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 를 실행하여 손상을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">비 결정적 함수에 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 태그가 지정 되고 해당 함수가 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; 에서 사용되는 경우 함수가 다른 응답을 반환하기 시작하면 관련 인덱스가 손상 될 수 있습니다. . SQL 함수가 거의 결정적 (즉, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같이 거의 변경되지 않는 경우 )이고 손상된 인덱스에서 사용되는 경우 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 를 실행하여 손상을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">동적 뮤텍스 매개 변수 중 하나 (SQLITE_MUTEX_FAST 또는 SQLITE_MUTEX_RECURSIVE)가 사용 된 경우 sqlite3_mutex_alloc ()은 모든 호출에서 다른 뮤텍스를 반환합니다. 정적 뮤텍스 유형의 경우 동일한 유형 번호를 가진 모든 호출에서 동일한 뮤텍스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">WHERE 절에 &quot;langid = N&quot;용어를 포함시키지 않으면 검색은 언어 0 (위의 예에서는 영어)에 대해 수행됩니다. 모든 spellfix1 검색은 단일 언어 ID에 대한 것입니다. 한 번에 모든 언어를 검색 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">대부분의 경우 SQLite는 쿼리의 FROM 절에있는 각 테이블에 대해 단일 인덱스 만 사용합니다. 여기에 설명 된 두 번째 OR 절 최적화는 해당 규칙의 예외입니다. OR 절을 사용하면 OR 절의 각 하위 용어에 대해 서로 다른 색인이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">특수한 &quot;: memory :&quot;이름을 적용하고 순수한 인 메모리 데이터베이스를 만들려면 파일 이름에 추가 텍스트가 없어야합니다. 따라서 &quot;./:memory :&quot;와 같이 경로 이름을 앞에 붙여 디스크 기반 데이터베이스를 파일에 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">위의 다이어그램에서 개인 편집 내용을 단일 커밋으로 표시했습니다. 이것은 명확하게 표현하기위한 것입니다. 수십 또는 수백 개의 개별적인 작은 변화를 수행하고 각각 개별적으로 커밋하는 것을 막을 수있는 것은 없습니다. 실제로, 많은 작은 변경을하는 것이 선호되는 작업 방법입니다. 단일 커밋에서 모든 변경을 수행하는 유일한 이유는 다이어그램을 더 쉽게 그릴 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">이 디자인에서 토크 나이 저는 파서를 호출합니다. YACC와 BISON에 익숙한 사람들은 파서가 토크 나이저라고하는 다른 방식으로 일하는 것에 익숙 할 것입니다. 하지만 토크 나이저가 파서를 호출하면 스레드에 안전하고 빠르게 실행될 수 있기 때문에 파서가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">삽입 함수 ( &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; )는 인수의 순서를 반대로합니다. 따라서 &quot;like (A, B)&quot;는 &quot;B like A&quot;와 같습니다. &quot;B like A&quot;형식의 경우 B 용어는 함수의 첫 번째 인수로 간주됩니다. 그러나 &quot;like (A, B)&quot;의 경우 A 용어가 첫 번째 인수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">&quot;.import&quot;명령을 실행하기 전에 &quot;mode&quot;를 &quot;csv&quot;로 설정해야합니다. 이것은 명령 행 쉘이 입력 파일 텍스트를 다른 형식으로 해석하지 못하게하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">인덱스 검색을 효율적으로하기 위해 R * Tree 인덱스의 모든 좌표를 제한 할 필요는 없습니다. 예를 들어 35 번째 병렬과 겹치는 모든 객체를 쿼리하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">$ bigstring 값을 인용 할 필요는 없습니다. 자동으로 발생합니다. $ bigstring이 큰 문자열 또는 이진 객체 인 경우이 기술은 쓰기가 쉬울뿐만 아니라 $ bigstring의 내용을 복사하지 않기 때문에 훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">두 개 이상의 스레드가 SQLite 라이브러리를 사용하여 동일한 SQLite 데이터베이스 파일에 액세스하는 것이 안전합니다. SQLite 용 유닉스 드라이버는 POSIX 권고 잠금 문제를 알고 해결합니다. 스레드가 SQLite 라이브러리를 무시하고 데이터베이스 파일을 직접 읽으려고 할 때만이 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">데이터베이스 파일 이름의 확장자는 매우 중요합니다. 확장명이 없으면 SQLite는 파일의 기본 이름을 추가하여 보조 파일 이름을 만듭니다. 따라서 &quot; &lt;code&gt;db01&lt;/code&gt; &quot; 이라는 데이터베이스 에는 &quot; &lt;code&gt;db01-journal&lt;/code&gt; &quot; 이라는 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 파일 이 있습니다 . 이 파일 이름은 3 자로 단축되는 확장자가 없으므로 그대로 사용되며 8 + 3 명명 규칙을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 이전에 xCreate 메소드를 호출하기 전에 NULL을 확인하지 않았습니다. 따라서 &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;시연&lt;/a&gt; 전용 가상 테이블이 SQLite 버전 3.8.11.1 (2015-07-29) 이하 로 등록되어 있고 해당 가상 테이블 모듈에 대해 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 명령이 시도되면 NULL 포인터로 점프하여 결과적으로 충돌.</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">gcov와 함께 SQLite를 실행하는 것은 SQLite의 테스트가 아니라 테스트 스위트의 테스트입니다. -fprofile-args 및 -ftest-coverage 옵션으로 인해 컴파일러가 다른 코드를 생성하므로 gcov 실행은 SQLite를 테스트하지 않습니다. gcov 실행은 테스트 스위트가 100 % 분기 테스트 범위를 제공하는지 확인합니다. gcov 실행은 테스트 테스트-메타 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 상수는 또한 전위로부터 반환 값으로서 사용된다 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 콜백 것을 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT는&lt;/a&gt; 또한 인 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">있습니다 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 와 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes는 ()&lt;/a&gt; 인터페이스는 트리거 해고 대신에 포함되지 않습니다,하지만 &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes 프라그가&lt;/a&gt; INSTEAD 트리거 발사 카운트 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 상수는 또한 전위로부터 반환 값으로서 사용된다 &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 콜백 것을 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT는&lt;/a&gt; 또한 인 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">DO UPDATE 절은 INSERT 중에 제한 조건 오류가 발생한 단일 행에서만 작동합니다. 조치를 해당 한 행으로 제한하는 WHERE 절을 포함 할 필요는 없습니다. DO UPDATE 끝에서 WHERE 절의 유일한 사용은 원래 값 및 / 또는 새 값에 따라 DO UPDATE를 no-op로 선택적으로 변경하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">SQLITE_TEXT 상수는 SQLite 버전 2에서도 완전히 다른 의미로 사용되었습니다. SQLite 버전 2와 SQLite 버전 3 모두에 연결되는 소프트웨어는 SQLITE_TEXT가 아닌 SQLITE3_TEXT를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">SQLite 파서는 가능하면 색인을 사용하기위한 코드를 항상 생성하지는 않습니다. 다음 쿼리는 현재 인덱스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">복합 쿼리에 대한 UNION ALL 연산자는 자체적으로 일시적인 인덱스를 사용하지 않습니다 (물론 UNION ALL의 오른쪽 및 왼쪽 하위 쿼리는 구성 방식에 따라 일시적인 인덱스를 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">권한 부 여자 콜백은 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 그 변형 동안에 만 호출됩니다 . &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 명령문 평가 중에 권한 부여는 수행되지 않습니다 . 이전 단락에서 언급 한대로 sqlite3_step ()은 sqlite3_prepare_v2 ()를 호출하여 스키마 변경 후 명령문을 다시 준비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">권한 부 여자 콜백은 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 그 변형 동안에 만 호출됩니다 . &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 명령문 평가 중에 권한 부여는 수행되지 않습니다 . 이전 단락에서 언급 한대로 sqlite3_step ()은 sqlite3_prepare_v2 ()를 호출하여 스키마 변경 후 명령문을 다시 준비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">SQLite에서 사용하는 문자 인코딩 메커니즘은 런타임시 변경할 수 없습니다. 이것은 컴파일 타임 옵션입니다. &lt;b&gt;sqlite_encoding&lt;/b&gt; 문자열은 라이브러리가 컴파일 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">동기 설정이 FULL 인 경우 롤백 저널의 체크섬이 필요하지 않습니다. 동기가 NORMAL로 낮아질 때 체크섬에만 의존합니다. 그럼에도 불구하고 체크섬은 결코 아프지 않으므로 동기 설정에 관계없이 롤백 저널에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">명령 행 쉘 프로그램은 이미 설정의 일부로 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스를 호출하여 확장로드를 사용 가능하게 하므로 위의 명령은 특별한 스위치, 설정 또는 기타 복잡성없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">소멸자 함수 D는 유형 문자열 T가 아닌 포인터 값 P에 대한 것입니다. 유형 문자열 T는 수명이 무한한 정적 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">정수 키는 삽입 직전에 테이블에 있던 가장 큰 키보다 하나 큰 것입니다. 새 키는 현재 테이블에있는 모든 키에서 고유하지만 이전에 테이블에서 삭제 된 키와 겹칠 수 있습니다. 테이블 수명 동안 고유 한 키를 작성하려면 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 키워드를 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 선언에 추가하십시오 . 그런 다음 선택한 키는 해당 테이블에 존재했던 가장 큰 키보다 하나 더 많습니다. 가장 큰 가능한 키가 해당 테이블에 이미 존재하면 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 는 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 코드 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 journal_mode 는 MEMORY 또는 OFF이며 다른 값으로 변경할 수 없습니다. &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 journal_mode를 MEMORY 또는 OFF 이외의 설정 으로 변경하려는 시도 는 무시됩니다. 또한 트랜잭션이 활성화되어있는 동안 journal_mode를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">위의 루틴 목록은 실제가 아니라 개념적입니다. 이러한 루틴 중 다수는 여러 버전으로 제공됩니다. 예를 들어, 위 목록 에는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 같은 약간 다른 방식으로 동일한 작업을 수행하는 세 개의 별도 루틴이있는 경우 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 이라는 단일 루틴 이 표시됩니다 . 실제로 그러한 루틴이 존재하지 않는 경우 에는 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column ()을&lt;/a&gt; 언급 합니다. 목록에 표시된 &quot;sqlite3_column ()&quot;은 다양한 데이터 유형의 열 데이터를 추가하는 전체 루틴 제품군의 플레이스 홀더입니다.</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">OOM 오버레이를 사용하는 경우에도 메모리 누수 감지 로직이 계속 작동합니다. 이것은 메모리 할당 오류가 발생하더라도 SQLite가 메모리를 누출하지 않는지 확인합니다. OOM 오버레이는 메모리 할당 오용 여부를 확인하는 인스트루먼트 된 메모리 할당자를 포함하여 모든 기본 메모리 할당 기와 함께 작동 할 수 있습니다. 이러한 방식으로 OOM 오류가 다른 종류의 메모리 사용 오류를 유발하지 않는지 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLite가 이해하는 키워드 수는 컴파일 타임 옵션에 따라 달라질 수 있습니다. 예를 들어, SQLite가 &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; 옵션으로 컴파일 된 경우 &quot;VACUUM&quot;은 키워드가 아닙니다 . 또한 SQLite의 향후 릴리스에 새로운 키워드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLite가 이해하는 키워드 수는 컴파일 타임 옵션에 따라 달라질 수 있습니다. 예를 들어, SQLite가 &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; 옵션으로 컴파일 된 경우 &quot;VACUUM&quot;은 키워드가 아닙니다 . 또한 SQLite의 향후 릴리스에 새로운 키워드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">열 선호도를 결정하기위한 규칙의 순서가 중요합니다. 선언 된 유형이 &quot;CHARINT&quot;인 열은 규칙 1과 2 모두와 일치하지만 첫 번째 규칙이 우선하므로 열 선호도는 INTEGER입니다.</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">기본 결과 코드는 항상 확장 결과 코드의 일부입니다. 전체 32 비트 확장 결과 코드가 제공되면 응용 프로그램은 확장 결과 코드의 최하위 8 비트 만 추출하여 항상 해당 기본 결과 코드를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">이 SELECT 쿼리에 대한 프로그램에는 INSERT 예제에 사용 된 트랜잭션 및 커밋 명령이 포함되어 있지 않습니다. SELECT는 데이터베이스를 변경하지 않는 읽기 작업이므로 트랜잭션이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">readfile (X) 및 writefile (X, Y) 함수는 확장 함수이며 핵심 SQLite 라이브러리에 내장되어 있지 않습니다. 이러한 루틴은 &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite 소스 코드 저장소&lt;/a&gt; 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt; 소스 파일에서 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">BLOB 이외의 값을 BLOB로 캐스트 한 결과와 BLOB 값을 BLOB 이외의 값으로 캐스트 한 결과는 데이터베이스 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 이 UTF-8, UTF-16be 또는 UTF-16le 인지에 따라 다를 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_apply_v2 () API는 아직 &lt;b&gt;실험 단계&lt;/b&gt; 이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_start_v2 () API는 아직 &lt;b&gt;실험 단계&lt;/b&gt; 이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">단항 * + * 연산자는 표현식에서 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 를 제거 하며 경우에 따라 표현식의 의미가 미묘하게 변경 될 수 있습니다. 위의 예에서 * x * 열에 &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT 선호도&lt;/a&gt; 가 있으면 비교 &quot;x = 5&quot;가 텍스트로 수행됩니다. 그러나 * + * 연산자는 선호도를 제거합니다. 따라서 &quot;+ x = 5&quot;비교는 * x * 열의 텍스트를 숫자 값 5와 비교하며 항상 false입니다.</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">실제로 허용되지 않는 구문 다이어그램에는 경로가 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">equals 연산자와 equals 연산자에는 두 가지 변형이 있습니다. 같음</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">이것은 단지 생각 실험 일뿐입니다. OpenDocument를 변경할 것을 권장하지 않습니다. 이 기사는 현재 OpenDocument 디자인에 대한 비판도 아닙니다. 이 에세이의 요점은 미래의 파일 형식 디자인을 개선하는 방법을 제안하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">이 문제점은 잠금을 획득하려고 시도 할 때 I / O 오류가 발생한 경우에만 발생합니다. 다른 스레드 또는 프로세스가 이미 충돌 잠금을 보유하고 있기 때문에 잠금이 단순히 부여되지 않으면 손상이 발생하지 않습니다. 공유 메모리에서 파일 잠금을 가져 오는 중에 I / O 오류로 실패 할 운영 체제를 인식하지 못했습니다. 따라서 이것은 실제 문제가 아닌 이론적 인 문제입니다. 말할 필요도없이,이 문제는 결코 야생에서 관찰 된 적이 없습니다. I / O 오류를 시뮬레이트하는 테스트 하네스에서 SQLite의 스트레스 테스트를 수행하는 중에 문제점이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 일치시 0을 리턴하고 문자열이 일치하지 않으면 &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 와 같이 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 일치시 0을 리턴하고 문자열이 일치하지 않으면 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 와 같이 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">연관된 테이블이 삭제되면 트리거가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">SQLite가 SQLITE_THREADSAFE = 0으로 컴파일 될 때 SQLite 스레드 안전을위한 코드는 빌드에서 생략됩니다. 이 경우 시작 시간이나 런타임에 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 설정이 켜져있는 경우 생성 된 열과 내림차순 인덱스가있는 테이블을 처리하려고 할 때 모호한 오류와 함께 &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 실패합니다. SQLite 버전 3.3.0 및 이전 버전은 생성 된 열 또는 하향 인덱스를 지원하지 않기 때문에 버그로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 설정이 켜져있는 경우 생성 된 열과 내림차순 인덱스가있는 테이블을 처리하려고 할 때 모호한 오류와 함께 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 실패합니다. SQLite 버전 3.3.0 및 이전 버전은 생성 된 열 또는 하향 인덱스를 지원하지 않기 때문에 버그로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">LIKE 또는 GLOB 연산자의 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 를 사용하여 준비된 경우 명령문은 자동으로 재분석되고 각 실행 의 첫 번째 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 재 컴파일 됩니다. 이전 실행 이후 오른쪽 매개 변수에 대한 바인딩이 변경되었습니다. 이 재분석 및 재 컴파일은 기본적으로 스키마 변경 후에 발생하는 동일한 조치입니다. 쿼리 플래너가 LIKE 또는 GLOB 연산자의 오른쪽에 바인드 된 새 값을 검사하고 위에서 설명한 최적화를 사용할지 여부를 판별 할 수 있도록 재 컴파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">유형 변환이 발생하면 sqlite3_column_blob (), sqlite3_column_text () 및 / 또는 sqlite3_column_text16 ()에 대한 이전 호출에서 반환 된 포인터가 무효화 될 수 있습니다. 다음과 같은 경우 유형 변환 및 포인터 무효화가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; NORMAL으로 설정된 체크 포인트 (윈도우 나 UNIX FlushFileBuffers (ON으로 fsync ()))가 I / O 또는 장벽 동기화 작업을 실행하는 경우에만 동작한다. 따라서 응용 프로그램이 별도의 스레드 또는 프로세스에서 검사 점을 실행하는 경우 데이터베이스 쿼리 및 업데이트를 수행하는 기본 스레드 또는 프로세스는 동기화 작업에서 절대 차단되지 않습니다. 이렇게하면 사용중인 디스크 드라이브에서 실행중인 응용 프로그램에서 &quot;래치 업&quot;을 방지 할 수 있습니다. 이 구성의 단점은 트랜잭션이 더 이상 지속되지 않으며 정전 또는 하드 리셋 후에 롤백 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">ANALYZE를 사용하면 비용 추정치가 현실에 더 잘 맞고 알고리즘 -1이 NN과 N3에 의해 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">xBestIndex 의 idxNum 및 idxStr 출력은 xFilter에 대한 입력이 필요하므로 xBestIndex는 항상 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 전에 호출 됩니다. 그러나 성공적인 xBestIndex에 따라 xFilter가 호출된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">&quot;임시&quot;에 주목하십시오. 가상 테이블 이름 앞의 한정자 ( &quot;stat&quot;) 이 규정자는 가상 테이블을 임시로 만듭니다. 현재 데이터베이스 연결 기간 동안 만 존재합니다. 이것이 권장되는 접근법입니다.</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">특히 마지막 글 머리 기호에 유의하십시오. sqlite3_set_auxdata () 인터페이스가 반환되기 전에 sqlite3_set_auxdata (C, N, P, X)의 소멸자 X가 즉시 호출 될 수 있습니다. 따라서 sqlite3_set_auxdata ()는 함수 구현의 끝 부분에서 호출되어야하며 sqlite3_set_auxdata ()가 호출 된 후 함수 구현은 P를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">의 사용에주의 &lt;a href=&quot;lang_corefunc#quote&quot;&gt;따옴표 () SQL 기능&lt;/a&gt; 이 트리거에 있습니다. quote () 함수는 인수를 SQL 문에 포함하기에 적합한 형식으로 변환합니다. 숫자 값은 변경되지 않습니다. 작은 따옴표는 문자열 앞뒤에 추가되고 내부 작은 따옴표는 이스케이프됩니다. BLOB 값은 SQL 표준 16 진 BLOB 표기법을 사용하여 렌더링됩니다. quote () 함수를 사용하면 실행 취소 및 재실행에 사용 된 SQL 문이 항상 SQL 삽입으로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">&quot;estimatedRows&quot;, &quot;idxFlags&quot;및 colUsed 필드의 경고에 유의하십시오. 이 필드에는 각각 SQLite 버전 3.8.2, 3.9.0 및 3.10.0이 추가되었습니다. 이러한 필드를 읽거나 쓰는 확장은 먼저 사용중인 SQLite 라이브러리의 버전이 적절한 버전 이상인지 확인해야합니다. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; 에서 반환 된 값 을 상수 3008002, 3009000 및 / 또는 3010000과 비교할 수 있습니다. 이전 버전의 SQLite에 의해 작성된 sqlite3_index_info 구조에서 이러한 필드에 액세스하려는 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">참고 : &quot; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &quot; 로 표시된 기능 은 &lt;a href=&quot;capi3ref&quot;&gt;실험용&lt;/a&gt; 이며 이름이 &lt;s&gt;잘린&lt;/s&gt; 기능 은 &lt;a href=&quot;capi3ref&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">참고 : &quot; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &quot; 로 표시된 기능 은 &lt;a href=&quot;experimental&quot;&gt;실험용&lt;/a&gt; 이며 이름이 &lt;s&gt;잘린&lt;/s&gt; 기능 은 &lt;a href=&quot;experimental&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">참고 :이 기사의 섹션 2.0 및 3.0은 &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; 및 &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt; 에 대한 의견에 따라 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">참고 :이 방법은 MacOS X 10.7 및 iOS 버전 5.0에서 비활성화되어 있으며 항상 SQLITE_MISUSE를 반환합니다. 이러한 시스템에서 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 통해 데이터베이스 당 연결을 공유 캐시 모드로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">참고 :이 방법은 MacOS X 10.7 및 iOS 버전 5.0에서 비활성화되어 있으며 항상 SQLITE_MISUSE를 반환합니다. 이러한 시스템에서 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 통해 데이터베이스 당 연결을 공유 캐시 모드로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">상의주의 사항 &lt;a href=&quot;optoverview&quot;&gt;쿼리 최적화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">LIKE 연산자가 어떻게 구현되는지 확인하십시오. SQLite에서는 사용자 정의 함수이므로 함수 정의 주소는 P3에 지정되어 있습니다. 피연산자 P1은 스택에서 가져 오는 함수 인수의 수입니다. 이 경우 LIKE () 함수는 2 개의 인수를 갖습니다. 인수는 스택에서 역순으로 (오른쪽에서 왼쪽으로) 제거되므로 일치하는 패턴이 맨 위 스택 요소이고 다음 요소는 비교할 데이터입니다. 반환 값이 스택으로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">위의 쿼리 작동 방식에 주목하십시오. R * Tree 색인은 외부 루프에서 실행되어 경도 -81 ..- 79.6 및 위도 35.0..36.2의 경계 상자 내에 포함 된 항목을 찾습니다. 발견 된 각 오브젝트 ID에 대해 SQLite는 demo_data 테이블에서 해당 항목을 찾습니다. 그런 다음 demo_data 테이블의 경계 필드를 contains_in () 함수에 대한 매개 변수로 사용하고 해당 함수가 true를 반환하면 demo_data 테이블의 objname 필드가 쿼리 결과의 다음 행으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">다른 모든 날짜 및 시간 함수는 strftime ()으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">SQLite 테이블을 사용하여 내용을 더 작은 조각으로 나누면 구현에 유연성이 제공됩니다. 응용 프로그램은 시작할 때 모든 내용을 메모리로 읽도록 선택할 수 있습니다. 또는 몇 페이지를 메모리로 읽어서 나머지는 디스크에 보관할 수 있습니다. 또는 한 번에 한 페이지 만 메모리로 읽을 수 있습니다. 또한 응용 프로그램의 버전에 따라 파일 형식을 변경하지 않고도 다른 방법을 선택할 수 있습니다. 모든 컨텐츠가 ZIP 아카이브에서 하나의 큰 XML 파일에있는 경우 이러한 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">&quot;더미&quot;레코드의 &quot;호스트&quot;값이 NULL이므로 result [] 배열에 해당 슬롯의 NULL 포인터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">함수에 대한 매개 변수는 이제 SQLite 버전 2.X에서와 같이 문자열에 대한 포인터 대신 sqlite3_value 구조에 대한 포인터입니다. 이러한 &quot;값&quot;에서 유용한 정보를 추출하는 데 다음 루틴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">공유 잠금은 디스크 자체가 아닌 운영 체제 디스크 캐시에 있습니다. 파일 잠금은 실제로 운영 체제 커널 내의 플래그 일뿐입니다. (자세한 내용은 특정 OS 계층 인터페이스에 따라 다릅니다.) 따라서 운영 체제 충돌 또는 전원 손실이 발생하면 잠금이 즉시 사라집니다. 일반적으로 잠금을 작성한 프로세스가 종료되면 잠금이 사라지는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">fts3tokenize 가상 테이블의 결과 세트에있는 토큰은 토크 나이저 규칙에 따라 변환되었습니다. 이 예에서는 &quot;porter&quot;토크 나이저를 사용 했으므로 &quot;This&quot;토큰은 &quot;thi&quot;로 변환되었습니다. 토큰의 원본 텍스트가 필요한 경우 &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; 함수 와 함께 &quot;start&quot;및 &quot;end&quot;열을 사용하여 검색 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">ListRead와 Next 명령어의 유사성을 주목하십시오. 두 작업 모두이 규칙에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">평균 읽기 성능과 평균 쓰기 성능 간에는 상충 관계가 있습니다. 읽기 성능을 최대화하기 위해 WAL을 가능한 한 작게 유지하고 따라서 모든 COMMIT만큼 자주 체크 포인트를 자주 실행하려고합니다. 쓰기 성능을 최대화하기 위해 가능한 한 많은 쓰기에 대해 각 검사 점의 비용을 상각하려고합니다. 즉, 검사 점을 자주 실행하지 않고 각 검사 점 전에 WAL을 최대한 크게 늘리기를 원합니다. 따라서 검사 점을 실행하는 빈도는 응용 프로그램의 상대적 읽기 및 쓰기 성능 요구 사항에 따라 응용 프로그램마다 다를 수 있습니다. 기본 전략은 WAL이 1000 페이지에 도달하면 검사 점을 실행하는 것이며이 전략은 워크 스테이션의 테스트 응용 프로그램에서 잘 작동하는 것 같습니다.그러나 다른 전략은 다른 플랫폼이나 다른 워크로드에서 더 잘 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">이제 MSVC ++ 6에서 다시 컴파일</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">이제 fdatasync () 함수가없는 Solaris 및 OpenBSD 및 기타 Unix 변형에서 컴파일</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">이제 키가 180cm 이상인 조직의 모든 사람의 이름을 찾기위한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">이제 M과 N이 모두 3500 인 경우를 고려하십시오. Alice 노드는 풍부합니다. 그러나 이러한 각 노드가 하나 또는 두 개의 모서리로만 연결되어 있다고 가정하십시오. 이 경우 옵션 2가 선호됩니다. 옵션 2를 사용하면 외부 루프는 여전히 3500 번 실행되어야하지만 중간 루프는 각 외부 루프에 대해 한두 번만 실행되며 내부 루프는 각 중간 루프에 대해 한 번만 실행됩니다. 따라서 내부 루프의 총 반복 횟수는 약 7000입니다. 반면에 옵션 1은 외부 루프와 중간 루프를 각각 3500 번 실행해야하므로 중간 루프의 1200 만 반복이 발생합니다. 따라서 두 번째 시나리오에서 옵션 2는 옵션 1보다 거의 2000 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">이제이 연습의 요점 인 SQLite에 대한 개인 사용자 정의 수정을 할 차례입니다. &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;명령을 사용하여 개인 브랜치 (아직없는 경우)로 전환 한 다음 텍스트 편집기에서 소스 파일을 불러오고 원하는대로 변경하십시오. 변경을 완료하면 다음 명령을 사용하여 해당 변경을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">이제이 인덱스가 어떻게 사용되는지 봅시다. 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">이제 사용자에게 전화 번호가 하나만 있으면 user.phone 필드에 일반 텍스트가 있고 전화 번호가 여러 개인 경우 JSON 배열이 있다고 가정하십시오. 같은 질문이 있습니다 : &quot;어떤 사용자가 704 지역 코드에 전화 번호를 가지고 있습니까?&quot; 그러나 json_each () 함수는 첫 번째 인수로 올바른 형식의 JSON이 필요하므로 전화 번호가 두 개 이상인 사용자에 대해서만 json_each () 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">공개 및 개인 분기가 다르므로 &quot; &lt;code&gt;fossil update trunk&lt;/code&gt; &quot;및 &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;명령을 실행하면 분기간에 전환 할 때 화석이 체크 아웃에서 파일을 실제로 변경한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">널 (NULL) 표시기는 열 값이 널임을 나타내는 선택적 문자열입니다. 기본값은 빈 문자열입니다. 열 분리 자 및 널 (NULL) 표시기는 선택적 위치 인수입니다. 널 (NULL) 표시기가 지정된 경우 열 분리 자 인수를 지정하고 널 (NULL) 표시기 인수 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">이전 체크 포인트에 의해 데이터베이스에 이미 백필 된 WAL 프레임 수</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">백업을 시도했지만 성공적으로 백업하지 못한 WAL 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">페이로드의 바이트 수</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="translated">현재 페이지 또는 btree의 셀 수</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WAL 파일에서 유효하고 커밋 된 프레임 수</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">숫자 및 텍스트 유형은 DISTINCT 키워드에서도 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">숫자 값 (직렬 유형 1-9)은 NULL 이후와 숫자 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">숫자 값은 다음 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">수많은 버그 수정 및 설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">수많은 코드 최적화, 특히 코드 풋 프린트를 더 작게 만들도록 설계된 최적화.</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">수많은 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">수많은 다른 성능 향상</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice 및 기타 사람들이 사용하는 Open Document 프레젠테이션 형식</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice 및 기타 사람들이 사용하는 공개 문서 형식</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">FROM 절이없는 쿼리에서는 OFFSET 절이 무시되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET은 정답을 제공합니다. 그러나 OFFSET에는 오프셋 값에 비례하는 시간이 필요합니다. &quot;LIMIT x OFFSET y&quot;에서 실제로 발생하는 일은 SQLite가 쿼리를 &quot;LIMIT x + y&quot;로 계산하고 첫 번째 y 값을 애플리케이션으로 리턴하지 않고 버리는 것입니다. 따라서 창이 긴 목록의 맨 아래로 스크롤되고 y 값이 점점 커짐에 따라 연속 오프셋 계산에 점점 더 많은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">OLD 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">ON CONFLICT 절</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM 테스트는 OOM 오류를 시뮬레이션하여 수행됩니다. SQLite는 애플리케이션이 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC를&lt;/a&gt; 사용하여 대체 malloc () 구현을 대체 할 수 있도록합니다.,...) 상호 작용. TCL 및 TH3 테스트 하네스는 둘 다 특정 수의 할당 후에 실패하도록 조작 할 수있는 수정 된 malloc () 버전을 삽입 할 수 있습니다. 이러한 계측 된 malloc은 한 번만 실패한 다음 다시 작업을 시작하거나 첫 번째 실패 후에도 계속 실패하도록 설정할 수 있습니다. OOM 테스트는 루프에서 수행됩니다. 루프의 첫 번째 반복에서 계측 된 malloc은 첫 번째 할당에서 실패하도록 조작됩니다. 그런 다음 일부 SQLite 작업이 수행되고 SQLite가 OOM 오류를 올바르게 처리했는지 확인합니다. 그런 다음 계측 된 malloc의 실패 시간 카운터가 1 씩 증가하고 테스트가 반복됩니다. 루프는 시뮬레이션 된 OOM 오류가 발생하지 않고 전체 작업이 완료 될 때까지 계속됩니다. 이와 같은 테스트는 두 번 실행됩니다.계측 된 malloc이 한 번만 실패로 설정되고 계측 된 malloc이 첫 번째 실패 후에 지속적으로 실패한 상태로 다시 한 번.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BY 및 GROUP BY는 이제 경계 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">쿼리에 동일한 GROUP BY가 있으면 ORDER BY가 무시됩니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;B75A9CA6B0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY는 하위 선택에서 작동합니다</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">OS 인터페이스</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OS 인터페이스 파일 가상 메소드 오브젝트</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OS 인터페이스 객체</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OS 인터페이스 열린 파일 핸들</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="translated">OSS Fuzz는 더 이상 SQLite에서 역사적인 버그를 찾지 않습니다. 그러나 여전히 실행 중이며 때때로 새로운 개발 체크인에서 문제를 발견합니다. 예 : &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">비록 그들이 (하나님이 금지 한) 그들이 &quot;그들의 말을하라.</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">객체 지향 디자인</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">객체 지향은 프로그래밍 언어가 아닌 디자인 패턴입니다. 어셈블리 언어를 포함하여 원하는 언어로 객체 지향 프로그래밍을 수행 할 수 있습니다. 일부 언어 (예 : C ++ 또는 Java)는 객체 지향을 더 쉽게 만듭니다. 그러나 C와 같은 언어로 여전히 객체 지향 프로그래밍을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">객체 지향 만이 유효한 디자인 패턴은 아닙니다. 많은 프로그래머들이 객체에 대해서만 순수하게 생각하도록 배웠습니다. 그리고 공정하게 말하면, 물체는 종종 문제를 분해하는 좋은 방법입니다. 그러나 객체가 유일한 방법은 아니며 항상 문제를 분해하는 가장 좋은 방법은 아닙니다. 때로는 좋은 오래된 절차 코드가 작성하기 쉽고 유지 관리 및 이해하기 쉽고 객체 지향 코드보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">트리거의 버그 수정 ( &lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt; )이 모호 합니다.</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">사용되지 않는 문서</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">변경 그룹에서 복합 변경 집합 가져 오기</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">집계 함수 컨텍스트 확보</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">변경 세트 반복자에서 충돌하는 행 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">Changeset Iterator에서 현재 작업 가져 오기</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">테이블의 기본 키 정의 얻기</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">URI 매개 변수 값 얻기</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">데이터베이스 파일에서 PENDING 잠금과 EXCLUSIVE 잠금을 확보하십시오. 다른 프로세스에 여전히 SHARED 잠금이있는 경우 기록기는 해당 SHARED 잠금이 지워질 때까지 기다려야 독점 잠금을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">변경 그룹의 현재 내용을 나타내는 변경 세트 (또는 패치 세트)를 포함하는 버퍼를 얻습니다. 변경 그룹에 대한 입력이 변경 세트 인 경우 출력은 변경 세트입니다. 또는 입력이 패치 세트 인 경우 출력도 패치 세트입니다.</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 첨부 된 테이블에 대한 변경 사항이 포함 된 변경 사항 세트를 확보하십시오. 성공하면 SQLITE_OK를 리턴하기 전에 변경 세트를 포함하는 버퍼를 가리키고 * pnChangeset을 변경 세트의 크기를 바이트 단위로 가리 키도록 * ppChangeset을 설정하십시오. 오류가 발생하면 * ppChangeset 및 * pnChangeset을 모두 0으로 설정하고 SQLite 오류 코드를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">특정 테이블에 대한 잠금을 확보하십시오. 이 명령어는 공유 캐시 기능이 활성화 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">데이터베이스 파일에 대한 독점 잠금을 확보하고 위의 1-3 단계 알고리즘을 사용하여 모든 메모리 변경 사항이 데이터베이스 파일에 기록되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">Changeset Iterator에서 새 값을 얻습니다. *</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">구하십시오. * Changeset Iterator에서 값</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">화석에서 최신 SQLite 코드를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">SQL 값 얻기</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">획득</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">뮤텍스를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">때때로 심각한 문제가 발견되고 정기적 인 유지 보수 릴리스에 대해 작은 &quot;패치&quot;릴리스를 작성해야합니다. 패치는 이전 릴리스에서 변경된 코드 줄 수가 매우 작다는 점에서 유지 보수 릴리스와 다릅니다. 유지 보수 릴리스에 버그가 없는지 확인하여 패치 릴리스를 피하기 위해 모든 노력을 기울입니다.</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">물론 ANALYZE는 데이터베이스에 많은 양의 컨텐츠가있는 경우에만 효과적으로 작동합니다. 많은 양의 데이터를 축적 할 것으로 예상되는 새 데이터베이스를 작성할 때 &quot;ANALYZE sqlite_master&quot;명령을 실행하여 SQLITE_STAT1 테이블을 작성한 후 SQLITE_STAT1 테이블 (일반 INSERT 문을 사용하여)을 사용자의 일반적인 데이터베이스를 설명하는 컨텐츠로 미리 채울 수 있습니다. 응용 프로그램-랩에서 잘 구성된 템플릿 데이터베이스에서 ANALYZE를 실행 한 후 추출한 콘텐츠 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">물론 ANALYZE는 처음에 데이터베이스에 많은 양의 콘텐츠가있는 경우에만 효과적으로 작동합니다. 많은 데이터를 축적 할 것으로 예상되는 새 데이터베이스를 만들 때 &quot;ANALYZE sqlite_schema&quot;명령을 실행하여 SQLITE_STAT1 테이블을 만든 다음 일반 INSERT 문을 사용하여 SQLITE_STAT1 테이블을 일반 데이터베이스를 설명하는 콘텐츠로 미리 채울 수 있습니다. 응용 프로그램-랩에서 잘 채워진 템플릿 데이터베이스에서 ANALYZE를 실행 한 후 추출한 콘텐츠 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">물론 위에 열거 된 4 단계 중 하나를 시도하는 동안 오류가 발생할 수 있습니다. 이런 일이 발생하면</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">물론 일반적인 SQLite 테이블은 정수 기본 키에 대해 효율적으로 쿼리를 수행하므로 이전은 중요하지 않습니다. R * Tree를 사용하는 실제 이유는 좌표 범위에 대해 불평등 쿼리를 효율적으로 수행 할 수 있기 때문입니다. 노스 캐롤라이나 주 샬럿 부근에 포함 된 지수의 모든 요소를 ​​찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">물론, 시스템 복구 후에 존재할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">물론 일반적으로 필요한 모든 변경 사항을 원자 적으로 적용하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">물론 WAL 파일에 추가 된 모든 트랜잭션을 원래 데이터베이스로 다시 전송하려고합니다. WAL 파일 트랜잭션을 데이터베이스로 다시 이동하는 것을 &quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">물론 rowid로 쿼리 출력을 정렬하는 것은 거의 유용하지 않습니다. 일반적으로 다른 열로 출력을 정렬하려고합니다.</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">물론 예제에 표시된 &quot;t1bc&quot;및 &quot;t2&quot;대신 원하는 인덱스 및 임 포스터 테이블 이름을 대체하십시오. &quot;.imposter&quot;명령은 &quot;t1bc&quot;인덱스의 스키마를 읽고 해당 정보를 사용하여 임 포스터 테이블에 대해 호환 가능한 CREATE TABLE 문을 구성한 다음 임시 임 포스터 테이블을 자동으로 작성하는 데 필요한 모든 호출을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">물론 위의 두 쿼리는 완전히 동일하지 않습니다. 예를 들어 LIKE 쿼리는 &quot;linuxophobe&quot;또는 &quot;EnterpriseLinux&quot;와 같은 용어가 포함 된 행과 일치하지만 (Enron 전자 메일 데이터 세트에는 실제로 그러한 용어가 포함되지 않음) FTS3 테이블의 MATCH 쿼리는 해당 용어 만 선택합니다. &quot;linux&quot;를 개별 토큰으로 포함하는 행. 두 검색은 대소 문자를 구분하지 않습니다. FTS3 테이블은 일반 테이블의 경우 1453MB에 비해 디스크에서 약 2006MB를 사용합니다. 위의 SELECT 쿼리를 수행하는 데 사용 된 것과 동일한 하드웨어 구성을 사용하여 FTS3 테이블을 채우는 데 31 분이 채 걸리지 않았습니다 (일반 테이블의 경우 25 분).</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="translated">물론 사용자는 정상적인 사용시 강력하고 악의적 인 공격에 강한 코드를 선호합니다. SQLite 개발자는이를 제공하는 데 전념하고 있습니다. 이 섹션의 목적은 두 가지를 동시에 수행하는 것이 어렵다는 점을 지적하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">물론, 마일리지는 하드웨어, 파일 시스템 및 운영 체제에 따라 다를 수 있습니다. 특정 설계를 수행하기 전에 대상 하드웨어에서이 수치를 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">이러한 변경 중 1a 및 2a-2c 만 공식적인 의미에서 비 호환성입니다. 그러나 이전에 SQLite 소스를 사용자 지정하여 수정 한 사용자 (예 : 임베디드 하드웨어에 대한 사용자 지정 OS 계층 추가)는 이러한 변경이 더 큰 영향을 줄 수 있습니다. 한편, 이러한 변경의 중요한 목표는 다른 운영 체제에서 사용하기 위해 SQLite를 훨씬 쉽게 사용자 정의 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">이전 버전의 SQLite는 읽기 전용 인 WAL 모드 데이터베이스를 읽을 수 없습니다. 즉, WAL 모드 데이터베이스를 읽으려면 쓰기 액세스가 필요했습니다. 이 제약은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;버전 3.22.0&lt;/a&gt; (2018-01-22) 부터 완화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">이전 버전의 파이어 버드는 SELECT DISTINCT 및 UNION에서 모든 NULL을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">MSVC 사용자가 쉽게 빌드 할 수 있도록 makefile에서 &quot;awk&quot;를 모두 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">생략 된 매개 변수는 기본값을 사용합니다. STEP의 기본값은 1입니다. END의 기본값은 9223372036854775807입니다. START의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">안드로이드에는 인터넷의 복잡한 구석에서 다운로드 한 신뢰할 수없는 앱에 의해 전달되는 임의의 SQL을 맹목적으로 실행하는 많은 서비스가 있다고 들었습니다. 안드로이드 서비스는 검증되지 않은 소스에서 SQL을 실행하는 것에 대해 더욱 조심해야합니다. 이 저자는 그와 반대되는 구체적인 사례는 없지만, 존재한다는 소문을 들었습니다. 모든 Android 서비스가 더 조심스럽고 실행중인 모든 SQL을 제대로 검사하더라도 안전한지 확인하기 위해 모두 감사하는 것은 어려울 것입니다. 따라서 보안을 염두에 둔 사람들은 임의의 SQL 텍스트를 전달하여 악용 할 수 없도록주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">Linux 및 기타 유닉스 시스템에서는 다음과 같이 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">Win32에서는 존재하지 않는 파일을 삭제하려고 할 때 오류를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">Windows 시스템에서 폴더는 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">MSVC가있는 Windows의 경우 Makefile.msc와 함께 nmake를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">Windows에서 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">(A)에 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 의 WAL 먼저의 xSync 방법하여 영구 저장소에 플러시 &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS를&lt;/a&gt; . 그런 다음 WAL의 유효한 내용이 데이터베이스 파일로 전송됩니다. 마지막으로 데이터베이스는 다른 xSync 메서드 호출을 사용하여 영구 저장소로 플러시됩니다. xSync 작업은 쓰기 장벽 역할을합니다. xSync가 시작된 후 쓰기가 시작되기 전에 xSync가 시작되기 전에 시작된 모든 쓰기가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">인덱스를 사용하는 DISTINCT 쿼리에서 적절한 인덱스를 사용할 수있는 경우 행을 단계별로 실행하지 않고 인덱스를 사용하여 다음 고유 항목으로 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">기존의 회전 디스크에서 섹터는 읽기와 쓰기 모두 양방향의 최소 전송 단위입니다. 그러나 플래시 메모리에서 읽기의 최소 크기는 일반적으로 최소 쓰기보다 훨씬 작습니다. SQLite는 최소 쓰기 양에만 관심이 있으므로이 기사에서는 &quot;섹터&quot;라고 할 때 대용량 저장소에 한 번에 쓸 수있는 최소 데이터 양을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">온 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWID를 또는 INTEGER PRIMARY KEY 열이 명시 적으로 값을 지정하지 않은 경우, 다음은 일반적으로 한 번 더 현재 사용에서 가장 큰 ROWID보다, 사용되지 않는 정수 자동으로 채워집니다. AUTOINCREMENT 키워드 사용 여부에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">제한 조건 점검 순서가 재 배열 될 때 UPSERT에서, 제한 조건 점검 전에 삽입 된 컨텐츠에 대한 선호도 변환이 발생하는지 확인하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">undo :: undo 또는 undo :: redo를 호출 할 때마다 undo / redo 모듈은 모든 최상위 네임 스페이스에서 status_refresh 및 reload_all 메소드를 자동으로 호출합니다. 이러한 메소드는 데이터베이스의 실행 취소 / 다시 실행 변경에 따라 표시를 재구성하거나 프로그램 상태를 업데이트하도록 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">동기 파일 시스템이있는 임베디드 시스템에서 TRUNCATE는 PERSIST보다 동작이 느립니다. 커밋 작업은 동일한 속도입니다. 그러나 후속 트랜잭션은 파일 끝에 추가하는 것보다 기존 내용을 덮어 쓰는 것이 더 빠르기 때문에 TRUNCATE 이후에 더 느립니다. 새 저널 파일 항목은 항상 TRUNCATE 뒤에 추가되지만 일반적으로 PERSIST로 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">대부분의 시스템에서 malloc () 시스템 호출은 8 바이트 경계에 정렬 된 버퍼를 리턴합니다. 그러나 일부 시스템 (예 : windows)에서 malloc ()은 4 바이트 정렬 포인터를 반환합니다. 이 컴파일 타임 옵션은 malloc ()에서 4 바이트 정렬 포인터를 리턴하는 시스템에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">최신 버전의 SQLite에서는 다음 조건 중 하나 이상이 충족되는 한 읽기 전용 미디어의 WAL 모드 데이터베이스 또는 쓰기 권한이없는 WAL 모드 데이터베이스를 계속 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">시작시 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램에 간단한 배너 메시지가 표시되고 SQL을 입력하라는 메시지가 표시됩니다. 세미콜론으로 끝나는 SQL 문을 입력하고 &quot;Enter&quot;를 누르면 SQL이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">시작시 응용 프로그램은 먼저 표시 할 버전을 결정합니다. versionId는 자연스럽게 시간이 증가하고 일반적으로 최신 버전을보고 싶어하므로 적절한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">성공하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴되고 새 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 이 * ppBlob에 저장됩니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴되고 오류 코드가 SQLITE_MISUSE가 아닌 경우 * ppBlob은 NULL로 설정됩니다. 즉, API를 잘못 사용하지 않으면 이 함수가 반환 된 후 * ppBlob에서 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 를 호출하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">성공하면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴되고 새 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 이 * ppBlob에 저장됩니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴되고 오류 코드가 SQLITE_MISUSE가 아닌 경우 * ppBlob은 NULL로 설정됩니다. 즉, API를 잘못 사용하지 않으면 이 함수가 반환 된 후 * ppBlob에서 &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 를 호출하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">성공하면 &lt;b&gt;sqlite_compile&lt;/b&gt; 은 SQLITE_OK를 반환합니다. 그렇지 않으면 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_blob_read ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_blob_read ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">성공하면 sqlite3_blob_write ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다. SQLITE_MISUSE가 리턴되지 않으면이 함수는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 를 통해 액세스 가능한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오류 코드 및 메시지를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">성공하면 sqlite3_blob_write ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다. SQLITE_MISUSE가 리턴되지 않으면이 함수는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 를 통해 액세스 가능한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오류 코드 및 메시지를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_prepare () 루틴 제품군은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다 . 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_prepare () 루틴 제품군은 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다 . 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">Mac에서이 pragma를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">반면에 서버를 사용하는 데이터베이스 엔진은 클라이언트 응용 프로그램의 버그로부터 더 나은 보호 기능을 제공 할 수 있습니다. 클라이언트의 스트레이 포인터는 서버의 메모리를 손상시킬 수 없습니다. 또한 서버는 단일 영구 프로세스이므로보다 정밀하게 데이터베이스 액세스를 제어 할 수 있으므로보다 세밀한 잠금 및 동시성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">반면에 서버를 사용하는 데이터베이스 엔진은 클라이언트 응용 프로그램의 버그로부터 더 나은 보호 기능을 제공 할 수 있습니다. 클라이언트의 스트레이 포인터는 서버의 메모리를 손상시킬 수 없습니다. 또한 서버는 단일 영구 프로세스이기 때문에 데이터베이스 액세스를보다 정밀하게 제어 할 수 있으므로 세밀한 잠금과 동시성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">반면에 RBU Vacuum은 일반 SQLite VACUUM보다 많은 CPU를 사용합니다. 한 번의 테스트에서 최대 5 배나 많은 양입니다. 이러한 이유로 RBU 진공은 종종 동일한 조건에서 SQLite VACUUM보다 상당히 느립니다.</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">반면에 테이블을 삭제하는 것은 일반적인 작업이 아니므로 SQLite가 조금 더 오래 걸리더라도 큰 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">반면에 하위 쿼리의 결과를 여러 번 스캔해야하는 경우 (예를 들어, 조인에서 하나의 테이블 일 뿐이므로) 임시 쿼리를 사용하여 하위 쿼리의 전체 결과를 기억하는 것이 좋습니다. 하위 쿼리를 두 번 이상 계산하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">반면, 각 판독기는 WAL 파일의 내용을 확인해야하고 WAL 파일을 확인하는 데 필요한 시간이 WAL 파일의 크기에 비례하기 때문에 WAL 파일의 크기가 커지면 읽기 성능이 저하됩니다. wal-index는 WAL 파일의 내용을 훨씬 빠르게 찾을 수 있도록 도와 주지만 WAL 파일 크기가 커지면 성능이 저하됩니다. 따라서 좋은 읽기 성능을 유지하려면 정기적으로 검사 점을 실행하여 WAL 파일 크기를 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">스택 디스플레이에서 대부분의 항목은 해당 스택 항목의 데이터 유형을 알려주는 접두사와 함께 표시됩니다. 정수는 &quot; &lt;code&gt;i:&lt;/code&gt; &quot;로 시작합니다 . 부동 소수점 값은 &quot; &lt;code&gt;r:&lt;/code&gt; &quot;로 시작합니다 . &quot;r&quot;은 &quot;실수&quot;를 나타냅니다. 문자열은 &quot; &lt;code&gt;s:&lt;/code&gt; &quot;, &quot; &lt;code&gt;t:&lt;/code&gt; &quot;, &quot; &lt;code&gt;e:&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;z:&lt;/code&gt; &quot;로 시작합니다. 문자열 접두사 간의 차이점은 메모리 할당 방법에 따라 발생합니다. z : 문자열은 &lt;b&gt;malloc ()&lt;/b&gt; 에서 얻은 메모리에 저장됩니다 . t : 문자열은 정적으로 할당됩니다. e : 문자열은 일시적입니다. 다른 모든 문자열에는 s : 접두사가 있습니다. 이것은 관찰자, 당신에게 아무런 영향을 미치지 않습니다z : 문자열을 전달해야하므로 VDBE에 매우 중요합니다.&lt;b&gt;&lt;/b&gt;메모리 누수를 피하기 위해 튀어 나오면 &lt;b&gt;free ()&lt;/b&gt; . 문자열 값의 처음 10 자만 표시되고 이진 값 (예 : MakeRecord 명령의 결과)은 문자열로 처리됩니다. VDBE 스택에 저장할 수있는 유일한 다른 데이터 형식은 NULL이며 접두사없이 단순히 &quot; &lt;code&gt;NULL&lt;/code&gt; &quot; 로 표시 됩니다 . 정수가 정수와 문자열로 스택에 배치 된 경우 접두어는 &quot; &lt;code&gt;si:&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">유닉스 시스템 (또는 cygwin 또는 mingw + msys를 사용하는 Windows)에서 명령은 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">유닉스에서 데이터베이스 파일에 대한 심볼릭 링크가 열리면 해당 저널 파일은 심볼릭 링크 이름이 아닌 실제 파일 이름을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">유닉스 계열 시스템에서 디렉토리는 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Windows에서만 모든 &quot; &lt;code&gt;\&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;/&lt;/code&gt; &quot; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Windows에서만 파일 이름이 드라이브 문자로 시작하는 경우 단일 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자 앞에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">한 번</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">VFS가 등록되면 절대 수정해서는 안됩니다. 동작 변경이 필요한 경우 새 VFS를 등록해야합니다. 응용 프로그램은 아마도 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 를 사용 하여 이전 VFS를 찾고, 이전 VFS를 새로운 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 로 복사 하고, 새로운 VFS를 원하는대로 수정하고, 기존 VFS를 등록 취소 한 다음, 새로운 VFS를 등록 할 수 있습니다. 장소. 기존 데이터베이스 연결은 등록을 해제 한 후에도 이전 VFS를 계속 사용하지만 새 데이터베이스 연결은 새 VFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">연결이 테이블 잠금을 확보하면 현재 트랜잭션 (읽기 또는 쓰기)이 완료 될 때까지 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">프로세스가 독점 잠금을 확보하면 데이터베이스 파일에 쓸 수 있습니다. 그런 다음 롤백 저널에서 페이지의 원래 컨텐츠를 읽고 해당 컨텐츠를 데이터베이스 파일의 원래 위치로 다시 씁니다. 롤백 저널의 헤더는 중단 된 트랜잭션이 시작되기 전에 데이터베이스 파일의 원래 크기를 기록합니다. SQLite는이 정보를 사용하여 불완전한 트랜잭션으로 인해 데이터베이스가 커지는 경우 데이터베이스 파일을 원래 크기로 다시 자릅니다. 이 단계의 끝에서 데이터베이스는 크기가 같아야하며 중단 된 트랜잭션이 시작되기 전과 동일한 정보를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">테이블이 세션 개체에 연결되면 세션 개체는 테이블에 삽입 된 모든 새 행의 기본 키 값을 기록합니다. 또한 삭제되거나 업데이트 된 행의 원래 기본 키 및 기타 열 값을 기록합니다. 각각의 고유 한 기본 키 값에 대해 데이터는 한 번만 기록됩니다. 세션의 수명 동안 해당 기본 키가있는 행이 처음으로 삽입, 업데이트 또는 삭제 된 경우.</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">트랜잭션이 열리면 데이터베이스 연결에서 데이터를 읽는 것은 간단한 작업입니다. 데이터베이스 파일에서 열린 파일 핸들의 xRead () 메소드를 사용하여 필요한 데이터베이스 파일 페이지를 한 번에 하나씩 읽습니다. SQLite는 부분 페이지를 읽지 않으며 항상 필요한 각 페이지마다 xRead ()에 대한 단일 호출을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">가상 테이블이 작성되면 위에서 언급 한 특정 가상 테이블 구현에 의해 부과되는 예외를 제외하고 다른 테이블과 같이 사용할 수 있습니다. 가상 테이블은 일반적인 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 구문을 사용하여 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">다시 한 번, 실제 구현은이 구조를 서브 클래 싱하여 추가 개인 필드를 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">다시 한 번, SQL 문은 동일한 바이트 코드를 생성하므로 정확히 동일한 방식으로 동일한 작업을 수행합니다. 그러나 두 번째 형식은 쿼리 매개 변수를 WHERE 절 전체에 분산시키지 않고 단일 행 값으로 그룹화하여 사람이 쉽게 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">모든 롤백 저널 파일이 디스크로 플러시되면 데이터베이스 파일 업데이트를 시작하는 것이 안전합니다. 변경 사항을 작성하기 전에 모든 데이터베이스 파일에 대한 독점 잠금을 얻어야합니다. 모든 변경 사항을 기록한 후에는 정전 또는 운영 체제 충돌시 변경 사항이 유지되도록 변경 사항을 디스크로 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">SQLite 데이터베이스가 열리면 데이터베이스의 메소드를 사용하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">데이터베이스에 대한 인코딩이 설정되면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">배타적 잠금이 유지되면 데이터베이스 파일에서 다른 프로세스를 읽고 있지 않으므로 변경 내용을 데이터베이스 파일에 쓰는 것이 안전합니다. 일반적으로 이러한 변경 사항은 운영 체제 디스크 캐시까지만 적용되며 대용량 저장 장치를 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">변환이 수행되고 값이 NULL이 아닌 경우 값이 비교됩니다. 두 값이 모두 얼룩이면 memcmp ()를 사용하여 비교 결과를 결정합니다. 두 값이 모두 텍스트 인 경우 P4에 지정된 적절한 조합 기능을 사용하여 비교합니다. P4를 지정하지 않으면 memcmp ()를 사용하여 텍스트 문자열을 비교합니다. 두 값이 모두 숫자이면 숫자 비교가 사용됩니다. 두 값의 유형이 다른 경우 숫자는 문자열보다 작은 것으로 간주되고 문자열은 얼룩보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">모든 준비가 완료되면 &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;명령을 실행하여 변경 사항을 체크인하십시오. 위의 다이어그램에서 원 (4)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">각 슬라이드를 개별적으로 저장한다는 개념에 익숙해지면 프레젠테이션 버전 관리를 지원하는 작은 단계입니다. 다음 스키마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">채워지면 FTS5 테이블의 내용에 대해 전체 텍스트 쿼리를 실행하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">제거중인 더티 페이지를 쓸 수 있으면 데이터베이스 파일에 간단히 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">FROM 절의 입력 데이터가 WHERE 절 표현식 (있는 경우)에 의해 필터링되면 단순 SELECT에 대한 결과 행 세트가 계산됩니다. 정확히 수행되는 방법은 단순 SELECT가 집계 쿼리인지 집계되지 않은 쿼리인지, GROUP BY 절이 지정되었는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">프로젝트 저장소가 작성되면 모든 프로젝트 소스 코드를 유지하려는 디렉토리로 이동하고 다음을 입력하여 프로젝트의 열린 체크 아웃을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">spellfix1 확장이로드되면 spellfix1 가상 테이블의 인스턴스가 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">테스트 프로그램이 생성되면 테스트를 수행하기 위해 인수없이 실행됩니다. 오류 진단뿐만 아니라 진행 정보도 표준 출력에 나타납니다. (표준 출력 채널이없는 내장형 장치에 대해 컴파일 타임 옵션을 사용하여 대체 출력 배열을 만들 수 있습니다.) 오류가 없으면 프로그램은 0을 반환하고 문제가 발견되면 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">가상 테이블이 생성되면 다음과 같이 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">특정 버전을 찾으면 해당 버전의 하이퍼 링크를 클릭하여 &quot;체크인 정보 페이지&quot;를 확인하십시오. 그런 다음 &quot;Tarball&quot;링크 또는 &quot;ZIP archive&quot;링크를 클릭하여 전체 소스 트리를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">이 쿼리에 대한 한 가지 접근 방식은 WHERE 절의 fruit = 'Orange'용어를 사용하여 오렌지를 처리하는 모든 행을 찾은 다음 캘리포니아 이외의 주에서 온 행을 거부하여 해당 행을 필터링하는 것입니다. 이 프로세스는 위의 &lt;a href=&quot;#fig7&quot;&gt;그림 7에&lt;/a&gt; 표시되어 있습니다. 이것은 대부분의 경우 완벽하게 합리적인 접근 방식입니다. 예, 데이터베이스 엔진은 나중에 거부 된 Florida 주황색 행에 대해 추가 이진 검색을 수행해야했기 때문에 많은 응용 프로그램에서 충분히 효율적이기는하지만 원하는만큼 효율적이지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">모듈 이름 뒤에 쉼표로 구분 된 인수를 모듈에 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">&quot;.eqp on&quot;명령을 사용하여 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 를 자동 EXPLAIN QUERY PLAN 모드로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">또한 트랜잭션 타임 라인에서 저장 점을 &quot;표시&quot;로 생각할 수 있습니다. 이 뷰에서 SAVEPOINT 명령은 새 마크를 만들고 ROLLBACK TO 명령은 타임 라인을 명명 된 마크 바로 다음 지점으로 되 감고 RELEASE 명령은 실제로 데이터베이스를 변경하지 않고 타임 라인에서 마크를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">다음과 같은 pragma를 사용하여 WAL 모드를 명시 적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">조합 대신 교차 연산자를 사용하여 WHERE 절에 AND로 연결된 용어가있는 쿼리에서 여러 인덱스를 사용하기 위해 OR-by-UNION 기술을 어떻게 활용할 수 있는지 알 수 있습니다. 많은 SQL 데이터베이스 엔진이 그렇게 할 것입니다. 그러나 단일 인덱스 만 사용하면 성능이 약간 향상되므로 SQLite는 현재이 기술을 구현하지 않습니다. 그러나 향후 버전 SQLite는 AND-by-INTERSECT를 지원하도록 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">가상 테이블에서 트리거를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">가상 테이블에서 추가 인덱스를 만들 수 없습니다. (가상 테이블에는 인덱스가있을 수 있지만 가상 테이블 구현에 내장되어야합니다. 인덱스는 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 사용하여 별도로 추가 할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">일반 도구를 사용하여 OpenDocument 프레젠테이션의 내용을 쉽게 보거나 변경 또는 추출 할 수 없습니다. OpenDocument 문서를 보거나 편집하는 유일한 방법은 OpenDocument를 읽거나 쓰도록 특별히 설계된 응용 프로그램을 사용하여 문서를 여는 것입니다 (읽기 : LibreOffice 또는 그 사촌 중 하나). 상황이 더 나빠질 수 있습니다. &quot;zip&quot;아카이버 도구 만 사용하여 프리젠 테이션에서 개별 이미지를 추출하고 볼 수 있습니다. 그러나 슬라이드에서 텍스트를 추출하는 것은 합리적이지 않습니다. 모든 컨텐츠는 단일 &quot;context.xml&quot;파일에 저장됩니다. 이 파일은 XML이므로 텍스트 파일입니다. 그러나 일반 텍스트 편집기로 관리 할 수있는 텍스트 파일이 아닙니다. 위의 예제 프레젠테이션에서 content.xml 파일은 정확히 두 줄로 구성됩니다. 파일의 첫 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">가상 테이블에 대해 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; 명령을 실행할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next와 ListRead의 한 가지 차이점은 &quot;사물&quot;에 대한 아이디어입니다. 다음 명령어의 &quot;사물&quot;은 데이터베이스 파일의 레코드입니다. ListRead의 &quot;사물&quot;은 목록의 정수 키입니다. 또 다른 차이점은 다음 &quot;사물&quot;이없는 경우 점프하거나 넘어 지는지 여부입니다. 이 경우 다음이 넘어 가서 ListRead가 점프합니다. 나중에 동일한 원리로 작동하는 다른 루핑 명령어 (NextIdx 및 SortNext)가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">이것의 한 예는 2013-08-30 경에 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; 의 표준 저장소에서 발생했습니다 . 이 경우, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 이전에 파일 설명자 2 (표준 오류)가 잘못 닫혔으며 ( &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt; 에 의해 의심 됨) 리포지토리 데이터베이스 파일에 사용 된 파일 설명자가 2였습니다. 나중에 응용 프로그램 버그로 인해 assert ( ) 문은 write (2, ...)를 호출하여 오류 메시지를 표시합니다. 그러나 파일 설명자 2가 이제 데이터베이스 파일에 연결되었으므로 오류 메시지가 데이터베이스의 일부를 덮어 썼습니다. 이러한 종류의 문제를 방지하기 위해 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;버전 3.8.1&lt;/a&gt; (2013-10-17) 이상은 데이터베이스 파일에 낮은 번호의 파일 설명자를 사용하지 않습니다. ( &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 참조 추가 정보가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLite의 typelessness에 대한 한 가지 예외는 유형이 INTEGER PRIMARY KEY 인 열입니다. &quot;INT&quot;가 아닌 &quot;INTEGER&quot;를 사용해야합니다. INT PRIMARY KEY 유형의 열은 다른 방식과 마찬가지로 유형이 없습니다. INTEGER PRIMARY KEY 열은 32 비트 부호있는 정수를 포함해야합니다. 정수가 아닌 데이터를 삽입하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="translated">특히 주목할만한 한 명의 퍼징 연구원은 현재 &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich의 &lt;/a&gt;&lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt; 입니다 (이 단락은 2019-12-21에 작성 됨) . 대부분의 퍼 저는 어설 션 오류, 충돌, 정의되지 않은 동작 (UB) 또는 기타 쉽게 감지되는 이상 항목 만 찾습니다. 반면에 Dr. Rigger의 퍼 저는 SQLite가 오답을 계산하는 경우를 찾을 수 있습니다. Rigger는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;이러한 사례를 많이&lt;/a&gt; 발견 했습니다.. 이러한 발견의 대부분은 유형 변환 및 선호도 변환과 관련된 상당히 모호한 코너 케이스이며 많은 발견이 릴리스되지 않은 기능에 대한 것입니다. 그럼에도 불구하고 그의 발견은 실제 버그이기 때문에 여전히 중요하며 SQLite 개발자는 근본적인 문제를 식별하고 수정할 수 있다는 것에 감사합니다. Rigger의 작업은 현재 게시되지 않았습니다. 출시되면 Zalewski의 AFL 발명 및 프로필 안내 퍼징만큼 영향력이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">위의 한 가지 의미는 단일 세션 내에서 변경이 이루어진 후 (예 : 행을 삽입 한 후 다시 삭제하는 경우) 세션 모듈이 변경을 전혀보고하지 않는다는 것입니다. 또는 동일한 세션 내에서 행이 여러 번 업데이트되는 경우 모든 업데이트는 변경 집합 또는 패치 세트 Blob 내에서 단일 업데이트로 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">오늘날 멀티 기가 바이트 데스크톱 시대에 전체 문서를 메모리로 읽는 것이 좋다고 주장 할 수 있습니다. 그러나 괜찮습니다. 하나의 경우, 사용 된 메모리 양이 디스크의 (압축 된) 파일 크기를 훨씬 초과합니다. 따라서 50MB 프레젠테이션에는 200MB 이상의 RAM이 필요할 수 있습니다. 한 번에 하나의 문서 만 편집해도 문제가되지 않습니다. 그러나 대화를 할 때이 저자는 일반적으로 동시에 10 개 또는 15 개의 서로 다른 프레젠테이션을 갖습니다 (과거의 프레젠테이션에서 슬라이드 복사 / 붙여 넣기를 용이하게하기 위해). 따라서 기가 바이트의 메모리가 필요합니다. 열린 웹 브라우저 또는 두 개 이상의 다른 데스크탑 앱에 추가하면 갑자기 디스크가 빙글 빙글 돌리고 머신이 스와핑됩니다. 그리고 우분투로 개조 된 저렴한 크롬 북 작업을 할 때 하나의 문서 만 있으면 문제가됩니다. 적은 메모리를 사용하는 것이 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">하나는 다른 제공 할 수 있습니다 &lt;a href=&quot;compile&quot;&gt;컴파일 시간 옵션&lt;/a&gt; 과 같은 &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; 전체 텍스트 검색, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; 는 R * 트리 검색 엔진 연장, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1을&lt;/a&gt; 포함하는 &lt;a href=&quot;json1&quot;&gt;JSON SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB을&lt;/a&gt; 에 대한 &lt;a href=&quot;dbstat&quot;&gt;가상 테이블 dbstat와&lt;/a&gt; . &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 리스팅 에서 추가 주석을 보려면 &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS를&lt;/a&gt; 추가하십시오 .선택권. 유닉스 시스템에서, 호스트 시스템이 usleep () 시스템 호출을 지원하면 -DHAVE_USLEEP = 1을 추가하십시오. 명령 행 편집 지원을 받으려면 -DHAVE_READLINE 및 -lreadline 및 -lncurses 라이브러리를 추가하십시오. 컴파일러 최적화 스위치를 지정할 수도 있습니다. SQLite 웹 사이트에서 다운로드 할 수있는 사전 컴파일 된 CLI는 &quot;-Os&quot;를 사용합니다. 여기에는 수많은 변형이 있습니다. 모든 기능을 갖춘 쉘을 컴파일하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">내용을 작은 조각으로 나누는 것의 단점은 압축이 짧은 텍스트에서는 잘 작동하지 않아 문서 크기가 커질 수 있다는 것입니다. 그러나 대부분의 문서 공간이 이미지를 저장하는 데 사용되므로 텍스트 내용의 압축 효율이 약간 떨어지지 만 사용자 환경을 개선하기 위해 적은 비용이 듭니다.</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10 진수 10 진수 ASCII 문자 중 하나 또는</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52 개의 대문자 및 소문자 ASCII 문자 중 하나 또는</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLite의 &lt;a href=&quot;different&quot;&gt;특징&lt;/a&gt; 중 하나는 데이터베이스가 단일 디스크 파일로 구성되어 있다는 것입니다. 데이터베이스 이동 또는 백업은 단일 파일을 복사하는 것만 큼 간단하기 때문에 SQLite 사용을 단순화합니다. 또한 SQLite를 &lt;a href=&quot;whentouse#appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용하기에 적합하게 만듭니다 . 그러나 완전한 데이터베이스가 단일 디스크 파일로 유지되는 동안 SQLite는 데이터베이스 처리 과정에서 많은 임시 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">ALL 또는 DISTINCT 키워드 중 하나가 간단한 SELECT 문에서 SELECT 키워드 뒤에 올 수 있습니다. 단순 SELECT가 SELECT ALL이면 전체 결과 행 세트가 SELECT에 의해 리턴됩니다. ALL 또는 DISTINCT가 없으면 ALL이 지정된 것처럼 동작합니다. 단순 SELECT가 SELECT DISTINCT이면 중복 행이 리턴되기 전에 결과 행 세트에서 제거됩니다. 중복 행을 감지하기 위해 두 개의 NULL 값이 동일한 것으로 간주됩니다. &lt;a href=&quot;datatype3#colrules&quot;&gt;일반적인 규칙은&lt;/a&gt; 텍스트 값을 비교하는 정렬 순서를 선택 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">프로젝트의 일부로 코드 생성기 도구를 호스팅 할 때의 장점 중 하나는 전체 프로젝트의 특정 요구에 맞게 도구를 최적화 할 수 있다는 것입니다. 레몬은이 효과로부터 이익을 얻었습니다. 수년에 걸쳐 레몬 파서 생성기는 SQLite에 새로운 기능과 향상된 성능을 제공하도록 확장 및 향상되었습니다. SQLite에서 사용하도록 특별히 설계된 레몬의 몇 가지 향상된 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFS 인터페이스의 흥미로운 기능 중 하나는 SQLite가 여러 VFS를 동시에 지원할 수 있다는 것입니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 사용하여 연결을 처음 열 때 사용할 단일 VFS를 선택해야합니다 . 그러나 프로세스에 여러 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 포함 된 경우 각각 다른 VFS를 선택할 수 있습니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 VFS를 런타임에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossil이 제공하는 많은 보고서 중 하나는 단일 지점에 대한 변경 일정으로 해당 지점의 모든 병합을 보여줍니다. 이러한 보고서의 일반적인 예는 &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; 를 참조 하십시오 . 이러한 보고서를 생성하는 데 일반적으로 몇 밀리 초가 걸립니다. 그러나 NGQP로 업그레이드 한 후이 보고서가 리포지토리 트렁크에서 10 초에 근접한 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLite가 시스템 충돌 및 전원 장애에 걸쳐 트랜잭션을 원자 적으로 유지하기 위해 수행하는 작업 중 하나는 데이터베이스를 변경하기 전에 모든 변경 사항을 롤백 저널 파일에 기록하는 것입니다. TCL 테스트 하네스에는 올바르게 작동하는지 확인하는 데 도움 이되는 대체 &lt;a href=&quot;vfs&quot;&gt;OS 백엔드&lt;/a&gt; 구현이 포함되어 있습니다 . &quot;journal-test VFS&quot;는 데이터베이스 파일과 롤백 저널 사이의 모든 디스크 I / O 트래픽을 모니터하여 롤백 저널에 처음 기록되고 동기화되지 않은 데이터베이스 파일에 아무것도 기록되지 않았는지 확인합니다. 불일치가 발견되면 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">ANALYZE가 마지막으로 실행 된 이후로 테이블의 하나 이상의 인덱스가 현재 분석되지 &lt;em&gt;않았거나&lt;/em&gt; 테이블 의 행 수가 25 배 이상 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">하나 이상의 트랜잭션이 디스크에 작성되었으므로 현재 wal 파일에 연결되어 있어야합니다. 즉, wal 파일을 처음 연 직후에는 wal 파일이없는 wal 모드 데이터베이스에서 스냅 샷을 작성할 수 없습니다. 먼저 하나 이상의 트랜잭션을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">한 가지 해결책은 데이터베이스 스키마에 SQL 외래 키 제약 조건을 추가하여</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 SQLite를 변경하여 최상의 경로를 철저히 검색하는 것입니다. 그러나 철저한 검색에는 K에 비례하는 시간이 필요합니다! (여기서 K는 조인의 테이블 수) 10- 조인 조인을 넘어 서면 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 를 실행하는 시간 이 매우 커집니다.</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">전체 테이블 스캔을 피하는 한 가지 기술은 rowid (또는 동등한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ) 별로 검색하는 것 입니다. 복숭아의 가격을 조회하기 위해 rowid가 4 인 항목을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Git과 Fossil의 한 사용자가 &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;HN으로 작성합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">SQLite에서 사용되는 한 가지 검증 기술은 전체 테스트 스위트를 두 번 실행하는 것입니다. 한 번 최적화를 설정 한 상태에서 한 번, 최적화를 해제 한 상태로 두 번째로 실행하면 두 번 모두 동일한 출력을 얻을 수 있습니다. 이는 최적화에 오류가 발생하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">매우 간단한 방법 중 하나는 각 결과 문서에서 사용자 검색어의 인스턴스 수를 계산하는 것입니다. 용어가 많이 포함 된 문서는 각 용어가 적은 수의 문서보다 관련성이 높은 것으로 간주됩니다. FTS 응용 프로그램에서 각 결과의 항 인스턴스 수는 &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋&lt;/a&gt; 함수 의 반환 값에있는 정수 수를 계산하여 확인할 수 있습니다 . 다음 예는 사용자가 입력 한 쿼리에 대해 10 개의 가장 관련성이 높은 결과를 얻는 데 사용할 수있는 쿼리를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법은 sqlite3_step () 호출에 의해 반환 된 확장 오류 코드를 확인하는 것입니다. 블로킹 연결이 있으면 확장 오류 코드가 SQLITE_LOCKED_SHAREDCACHE로 설정됩니다. 그렇지 않으면 특수한 &quot;DROP TABLE / INDEX&quot;경우 확장 오류 코드는 SQLITE_LOCKED입니다.</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">FindFrame (P, M)을 계산하는 한 가지 방법은 M 번째 항목부터 시작하여 뒤로 시작하여 aPgno [J] == P 인 J를 반환하는 aPgno 배열을 스캔하는 것입니다. 이러한 알고리즘은 작동하며 페이지 번호가 P 인 최신 프레임을 전체 WAL 파일을 검색하는 것보다 빠릅니다. 그러나 aHash 구조를 사용하면 훨씬 빠르게 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">임 포스터 테이블을 작성하는 한 가지 방법은 sqlite_master 테이블을 직접 편집하여 테이블을 설명하는 새 행을 삽입하는 것입니다. 예를 들어, 스키마가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">임 포스터 테이블을 만드는 한 가지 방법은 sqlite_schema 테이블을 직접 편집하여 테이블을 설명하는 새 행을 삽입하는 것입니다. 예를 들어 스키마가 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">쉘 스크립트에서 sqlite3를 사용하는 한 가지 방법은 &quot;echo&quot;또는 &quot;cat&quot;을 사용하여 파일에서 일련의 명령을 생성 한 다음 생성 된 명령 파일에서 입력을 재지 정하는 동안 sqlite3을 호출하는 것입니다. 이것은 잘 작동하며 많은 상황에서 적합합니다. 그러나 편의상 sqlite3을 사용하면 데이터베이스 이름 다음에 두 번째 인수로 명령 행에 단일 SQL 명령을 입력 할 수 있습니다. sqlite3 프로그램이 두 개의 인수로 시작되면 두 번째 인수는 처리를 위해 SQLite 라이브러리로 전달되고 쿼리 결과는 표준 출력에 목록 모드로 인쇄되고 프로그램이 종료됩니다. 이 메커니즘은 &quot;awk&quot;와 같은 프로그램과 함께 sqlite3를 쉽게 사용할 수 있도록 설계되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">다음과 같은 간단한 쿼리를 사용하여 R * Tree 인덱스를 사용하지 않고도 동일한 대답을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">원스텝 쿼리 실행 인터페이스</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">온라인 백업 API</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">온라인 백업 API.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">온라인 백업 개체</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">여기서는 CPU주기 수만 측정됩니다. CPU 사이클 수는 에너지 소비를위한 좋은 프록시이지만 실제 타이밍과는 상관이 없습니다. I / O를 수행하는 데 소요 된 시간은 CPU주기 수에 반영되지 않으며 많은 SQLite 사용 시나리오에서 I / O 시간이 우세합니다.</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">한 번에 하나의 권한 부여 자만 데이터베이스 연결에 배치 할 수 있습니다. sqlite3_set_authorizer에 대한 각 호출은 이전 호출을 대체합니다. NULL 콜백을 설치하여 권한 부여기를 비활성화하십시오. 인증 기는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 당 한 번에 하나의 진행률 처리기 만 정의 할 수 있습니다 . 새로운 진행 처리기를 설정하면 이전 처리기가 취소됩니다. 매개 변수 X를 NULL로 설정하면 진행률 처리기가 비활성화됩니다. N을 1보다 작은 값으로 설정하면 진행률 처리기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 당 한 번에 하나의 진행률 처리기 만 정의 할 수 있습니다 . 새로운 진행 처리기를 설정하면 이전 처리기가 취소됩니다. 매개 변수 X를 NULL로 설정하면 진행률 처리기가 비활성화됩니다. N을 1보다 작은 값으로 설정하면 진행률 처리기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 문으로 직접 작성된 변경 사항 만 고려됩니다. &lt;a href=&quot;../lang_createtrigger&quot;&gt;트리거&lt;/a&gt; , &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;외래 키 조치&lt;/a&gt; 또는 &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; 제한 조건 분석으로 인한 보조 변경 사항 은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 문으로 직접 작성된 변경 사항 만 고려됩니다. &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; , &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 조치&lt;/a&gt; 또는 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 제한 조건 분석으로 인한 보조 변경 사항 은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">인덱스의 열 a와 b 만 사용할 수 있습니다. c 열이 제한되지 않고 인덱스에서 사용할 수있는 열 집합에 간격이 없어 d 열을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">인덱스의 열 a, b 및 c 만 사용할 수 있습니다. d 열은 c의 오른쪽에서 발생하고 c는 부등식으로 만 제한되므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">둘 이상의 연결된 데이터베이스가 모두 수정되고 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되어 있지 않고 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; 가 OFF, MEMORY 또는 WAL로 설정되어 있지 않은 경우 에만 &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;마스터 저널&lt;/a&gt; 파일을 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">크기가 임계 값을 초과 할 경우 에만 &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 파일을 작성하십시오 . 그렇지 않으면 저널이 메모리에 유지되고 I / O가 발생하지 않습니다. 임계 값은 사용 컴파일시에 구성 될 수 &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 사용 또는 시동시에이 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">둘 이상의 연결된 데이터베이스가 모두 수정되고 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되지 않았으며 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; 가 OFF, MEMORY 또는 WAL로 설정 되지 않은 경우에만 마스터 저널 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">WHERE 절이 true로 평가되는 테이블의 행만 인덱스에 포함됩니다. WHERE 절 표현식이 테이블의 일부 행에 대해 NULL 또는 false로 평가되면 해당 행이 색인에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">langid가 일치하는 단어의 용어 만 검색합니다. 따라서 동일한 테이블에 여러 언어의 항목이 포함될 수 있으며 요청 된 언어 만 사용됩니다. 기본 langid는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">&quot;ll&quot;길이 수정 자만 SQLite에 차이를 만듭니다. 그리고 C 언어 인터페이스를 사용할 때만 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">ALTER TABLE 명령의 RENAME TABLE, ADD COLUMN 및 RENAME COLUMN 변형 만 지원됩니다. DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT 등과 같은 다른 종류의 ALTER TABLE 연산은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">AND 연산자의 암시 적 버전 만 지원됩니다. 표준 쿼리 구문 쿼리의 일부로 문자열 &quot;AND&quot;를 지정하면 &quot;and&quot;라는 용어가 포함 된 문서 집합에 대한 용어 쿼리로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">섹션 1.0에 설명 된 세 가지 핵심 루틴 만 SQLite를 사용해야합니다. 그러나 유용한 인터페이스를 제공하는 다른 많은 기능이 있습니다. 이러한 확장 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">COLLATE가 올 바르면 ORDER BY 또는 GROUP BY를 최적화하기 위해 인덱스 온 표현식 만 사용하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">오피 코드 이름</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">오피 코드 정의</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">증분 I / O를위한 BLOB 열기</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">쿼리 할 테이블로 커서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">커서 P2와 동일한 임시 테이블을 가리키는 새 커서 P1을여십시오. P2 커서는 이전 &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode에 의해 열려 있어야합니다 . 임시 커서 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">새 커서 P1을 임시 테이블로여십시오. 기본 데이터베이스가 읽기 전용 인 경우에도 커서는 항상 읽기 / 쓰기로 열립니다. 임시 테이블은 커서를 닫으면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">단일 데이터 행이 포함 된 가짜 테이블을 가리키는 새 커서를 엽니 다. 그 1 행의 내용은 메모리 레지스터 P2의 내용이다. 즉, 커서 P1은 레지스터 P2에 포함 된 MEM_Blob 내용의 별칭이됩니다.</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">데이터베이스 파일에서 루트 페이지가 P2 인 데이터베이스 테이블에 대한 읽기 전용 커서를여십시오. 데이터베이스 파일은 P3에 의해 결정됩니다. P3 == 0은 기본 데이터베이스를 의미하고 P3 == 1은 임시 테이블에 사용 된 데이터베이스를 의미하고 P3&amp;gt; 1은 해당하는 연결된 데이터베이스를 의미합니다. 새 커서에 P1의 식별자를 제공하십시오. P1 값은 연속적 일 필요는 없지만 모든 P1 값은 작은 정수 여야합니다. P1이 음수 인 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">루트 페이지가 P2이거나 OPFLAG_P2ISREG 비트가 P5에 설정된 경우 루트 페이지가 레지스터 P2에 보유 된 테이블 또는 인덱스에서 이름이 P1 인 읽기 / 쓰기 커서를 엽니 다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">sqlite3rbu_open (T, A, S) 함수를 사용하여 RBU 핸들을여십시오.</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">&quot;/home/fred/data.db&quot;파일을여십시오. posix 권고 잠금 대신 도트 파일을 사용하는 특수 VFS &quot;unix-dotfile&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">읽기 전용 액세스를 위해 현재 디렉토리에서 &quot;data.db&quot;파일을여십시오. 공유 캐시 모드가 기본적으로 사용되는지 여부에 관계없이 개인 캐시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">데이터베이스 파일 &quot;/home/fred/data.db&quot;를여십시오.</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">데이터베이스 파일을 열고 SHARED 잠금을 확보하십시오. SHARED 잠금을 확보 할 수 없으면 즉시 실패하고 SQLITE_BUSY를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">현재 디렉토리에서 &quot;data.db&quot;파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">쿼리중인 두 테이블 각각에 하나씩 두 개의 커서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">P1 값에 따라 매개 변수 P4로 명명 된 저장 점을 열거 나 해제하거나 롤백하십시오. 새 저장 점을 열려면 P1 == 0 (SAVEPOINT_BEGIN)을 설정하십시오. 기존 저장 점을 해제 (커밋)하려면 P1 == 1 (SAVEPOINT_RELEASE)을 설정하십시오. 기존 저장 점을 롤백하려면 P1 == 2 (SAVEPOINT_ROLLBACK)를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">오픈 클로즈 콜백</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">새로운 데이터베이스 연결 열기</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">새로운 연결 열기</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">읽기 전용 트랜잭션 열기</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">새 데이터베이스 연결을 여는 것은 두 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">읽기 전용 트랜잭션을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">읽기-쓰기 트랜잭션을 여는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">명세서 거래를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">피연산자 P1은 0x7fffffff이고 P2는 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">최적화 : &lt;a href=&quot;expridx&quot;&gt;expressions에 인덱스가&lt;/a&gt; 있는 테이블 에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 를 수행 할 때 업데이트 되는 테이블 의 컬럼을 참조하지 않는 경우 표현식 인덱스를 업데이트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">sqlite_mprintf () 루틴에 대한 최적화.</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">디스크에서 데이터베이스 내용을 불필요하게 읽지 않도록 &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#length&quot;&gt;length ()&lt;/a&gt; SQL 함수를 최적화하십시오 .</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">옵티마이 저는 정수 기본 키를 기준으로 정렬하는 ORDER BY 절을 만족시키기 위해 인덱스를 더 잘 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">최적화 개선 : LIKE 연산자의 RHS에 대한 바인딩이 변경되거나 &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 에서 범위 제한이 변경 될 때 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 자동으로 다시 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">옵션 1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">옵션 2 :</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">선택적 LIMIT 및 ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">선택적 LIMIT 및 ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">데이터베이스 연결이 공통 캐시를 공유 할 때 선택적 COMM UNCOMMITTED 격리 (기본 격리 수준 인 SERIALIZABLE 대신) 및 테이블 수준 잠금.</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="translated">선택적으로 &lt;a href=&quot;gencol&quot;&gt;생성 된 열&lt;/a&gt; 제약 조건입니다.</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">선택적으로 테이블의 기본 키입니다. 단일 열과 복합 (다중 열) 기본 키가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt; 명령으로 이해되는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">또는 다음과 동일한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">또는 MSVC가있는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">또는 최적화</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
