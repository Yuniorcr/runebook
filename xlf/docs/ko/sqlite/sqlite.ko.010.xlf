<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="33c558ed5ce36b119e16ee3e9d824eb5021f92cb" translate="yes" xml:space="preserve">
          <source>In the previous sections, we have seen how moving from a key/value store implemented as a ZIP archive to a simple SQLite database with just three tables can add significant capabilities to an application file format. We could continue to enhance the schema with new tables, with indexes added for performance, with triggers and views for programming convenience, and constraints to enforce consistency of content even in the face of programming errors. Further enhancement ideas include:</source>
          <target state="translated">이전 섹션에서 ZIP 아카이브로 구현 된 키 / 값 저장소에서 단 3 개의 테이블이있는 간단한 SQLite 데이터베이스로 이동하면 애플리케이션 파일 형식에 상당한 기능을 추가 할 수있는 방법을 살펴 보았습니다. 성능 향상을 위해 추가 된 인덱스, 프로그래밍 편의를위한 트리거 및 뷰, 프로그래밍 오류가 발생하더라도 콘텐츠의 일관성을 유지하기위한 제약 조건을 갖춘 새로운 테이블을 사용하여 스키마를 계속 향상시킬 수 있습니다. 추가 개선 아이디어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6567a872214501806e02589f934b8c11a8b0e4f5" translate="yes" xml:space="preserve">
          <source>In the previous, the &quot;type NOT IN ('object','array')&quot; term of the WHERE clause suppresses containers and only lets through leaf elements. The same effect could be achieved this way:</source>
          <target state="translated">이전에는 WHERE 절의 &quot;NOT IN ( 'object', 'array')&quot;용어는 컨테이너를 억제하고 리프 요소 만 통과시킵니다. 이 방법으로 동일한 효과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd63ff23c59a1e0a739d0a06a35ed29c44ad2c6" translate="yes" xml:space="preserve">
          <source>In the query above, if both t1 and t2 have approximately N rows, then without any indices the query will require O(N*N) time. On the other hand, creating an index on table t2 requires O(NlogN) time and then use that index to evaluate the query requires an additional O(NlogN) time. In the absence of &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; information, SQLite guesses that N is one million and hence it believes that constructing the automatic index will be the cheaper approach.</source>
          <target state="translated">위의 쿼리에서 t1과 t2에 모두 대략 N 개의 행이 있으면 인덱스가 없으면 쿼리에 O (N * N) 시간이 필요합니다. 반면, 테이블 t2에 인덱스를 만들려면 O (NlogN) 시간이 필요하며 해당 인덱스를 사용하여 쿼리를 평가하려면 추가 O (NlogN) 시간이 필요합니다. &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 정보 가 없으면 SQLite는 N이 백만이라고 추측하므로 자동 인덱스를 구성하는 것이 더 저렴한 방법이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="d42fa24dde8794f21d6a489ff49ead792c8bc812" translate="yes" xml:space="preserve">
          <source>In the query above, one would presumably bind the binary BLOB description of the precise boundary of the 12th district to the &quot;:boundary&quot; parameter.</source>
          <target state="translated">위의 쿼리에서 12 번째 구역의 정확한 경계에 대한 이진 BLOB 설명을 &quot;: boundary&quot;매개 변수에 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbfd2d21d7bf5385c8b5fed28f3d0558f663390" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;PARTITION BY c&quot; clause breaks the result set up into three partitions. The first partition has three rows with c=='one'. The second partition has two rows with c=='three' and the third partition has two rows with c=='two'.</source>
          <target state="translated">위의 쿼리에서 &quot;PARTITION BY c&quot;절은 결과 집합을 세 개의 파티션으로 나눕니다. 첫 번째 파티션에는 c == 'one'인 세 개의 행이 있습니다. 두 번째 파티션에는 c == 'three'인 두 개의 행이 있고 세 번째 파티션에는 c == 'two'인 두 개의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff23670a4dd151a2afe2511d238ffe5c9f59a6d2" translate="yes" xml:space="preserve">
          <source>In the query above, the &quot;a&quot; column is part of the GROUP BY clause and so each row of the output contains one of the distinct values for &quot;a&quot;. The &quot;c&quot; column is contained within the &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum()&lt;/a&gt; aggregate function and so that output column is the sum of all &quot;c&quot; values in rows that have the same value for &quot;a&quot;. But what is the result of the bare column &quot;b&quot;? The answer is that the &quot;b&quot; result will be the value for &quot;b&quot; in one of the input rows that form the aggregate. The problem is that you usually do not know which input row is used to compute &quot;b&quot;, and so in many cases the value for &quot;b&quot; is undefined.</source>
          <target state="translated">위의 쿼리에서 &quot;a&quot;열은 GROUP BY 절의 일부이므로 출력의 각 행에는 &quot;a&quot;에 대한 고유 값 중 하나가 포함됩니다. &quot;c&quot;열은 &lt;a href=&quot;lang_aggfunc#sumunc&quot;&gt;sum ()&lt;/a&gt; 집계 함수 내에 포함 되므로 출력 열은 &quot;a&quot;에 대해 동일한 값을 갖는 행의 모든 ​​&quot;c&quot;값의 합계입니다. 그러나 맨 열 &quot;b&quot;의 결과는 무엇입니까? 대답은 &quot;b&quot;결과가 집계를 형성하는 입력 행 중 하나에서 &quot;b&quot;의 값이된다는 것입니다. 문제는 일반적으로 &quot;b&quot;를 계산하는 데 어떤 입력 행이 사용되는지 알지 못하기 때문에 많은 경우 &quot;b&quot;의 값이 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd7c1539a48900d085cdab5fe3ab086624874b10" translate="yes" xml:space="preserve">
          <source>In the query above, the subquery &quot;SELECT b FROM ex2&quot; is evaluated and its results are stored in a temporary table (actually a temporary index) that allows one to determine whether or not a value ex2.b exists using a simple binary search. Once this table is constructed, the outer query is run and for each prospective result row a check is made to see if ex1.a is contained within the temporary table. The row is output only if the check is true.</source>
          <target state="translated">위 쿼리에서 하위 쿼리 &quot;SELECT b FROM ex2&quot;가 평가되고 결과는 간단한 이진 검색을 사용하여 ex2.b 값이 존재하는지 여부를 확인할 수있는 임시 테이블 (실제로 임시 인덱스)에 저장됩니다. 이 테이블이 구성되면 외부 쿼리가 실행되고 각 예상 결과 행에 대해 ex1.a가 임시 테이블에 포함되어 있는지 확인합니다. 점검이 참인 경우에만 행이 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="e4290c818e5599eff7616300b06206a049026a55" translate="yes" xml:space="preserve">
          <source>In the query above, the values for the first_name and last_name columns will correspond to the row that satisfied the max(salary) condition.</source>
          <target state="translated">위의 쿼리에서 first_name 및 last_name 열의 값은 max (salary) 조건을 만족 한 행에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="812c0304c15e5adbac36486ee814e9ec1db44d78" translate="yes" xml:space="preserve">
          <source>In the revised query, the subquery implemented by a co-routine computes the five most recent values for &quot;a&quot;. Those five values are passed from the co-routine up into the outer query where the &quot;expensive_function()&quot; is invoked on only the specific rows that the application cares about.</source>
          <target state="translated">수정 된 쿼리에서 공동 루틴으로 구현 된 하위 쿼리는 &quot;a&quot;에 대한 가장 최근 5 개의 값을 계산합니다. 이 5 개의 값은 응용 프로그램이 관심을 갖는 특정 행에서만 &quot;expensive_function ()&quot;이 호출되는 공동 쿼리에서 외부 쿼리로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5464a60c31d2aba9c62ea2f61ec84b78e0768c87" translate="yes" xml:space="preserve">
          <source>In the second example, the expression in the DO UPDATE clause is of the form &quot;excluded.phonenumber&quot;. The &quot;excluded.&quot; prefix causes the &quot;phonenumber&quot; to refer to the value for phonenumber that would have been inserted had there been no conflict. Hence, the effect of the upsert is to insert a phonenumber of Alice if none exists, or to overwrite any prior phonenumber for Alice with the new one.</source>
          <target state="translated">두 번째 예에서 DO UPDATE 절의 표현식은 &quot;excluded.phonenumber&quot;형식입니다. &quot;제외됨&quot; prefix는 &quot;phonenumber&quot;가 충돌이없는 경우 삽입 된 phonenumber의 값을 참조하게합니다. 따라서 upsert의 효과는 Alice의 전화 번호가 없으면 Alice의 전화 번호를 삽입하거나 Alice의 이전 전화 번호를 새 전화 번호로 덮어 쓰는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d5709c51541d0085c2cbbc496ec178e66f3f72e" translate="yes" xml:space="preserve">
          <source>In the sequence on the left, the second insert will fail. In this case, the strings '0' and '0.0' are treated as numbers since they are being inserted into a numeric column but 0==0.0 which violates the uniqueness constraint. However, the second insert in the right-hand sequence works. In this case, the constants 0 and 0.0 are treated a strings which means that they are distinct.</source>
          <target state="translated">왼쪽 순서대로 두 번째 인서트가 실패합니다. 이 경우 문자열 '0'및 '0.0'은 숫자 열에 삽입되기 때문에 숫자로 취급되지만 0 == 0.0은 고유성 제약 조건을 위반합니다. 그러나 오른쪽 순서의 두 번째 인서트가 작동합니다. 이 경우 상수 0과 0.0은 문자열로 처리되므로 고유합니다.</target>
        </trans-unit>
        <trans-unit id="a547afdf67cd8d948e7c4160e0e5b6f6d4b49400" translate="yes" xml:space="preserve">
          <source>In the shell, &lt;b&gt;sqlite_interrupt()&lt;/b&gt; is invoked when the user presses Control-C</source>
          <target state="translated">쉘에서 &lt;b&gt;sqlite_interrupt ()&lt;/b&gt; 는 사용자가 Control-C를 누를 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8d983faa26111b1d1fcd83dfccc76792d6f87417" translate="yes" xml:space="preserve">
          <source>In the spellfix1 algorithm, cFrom is the text as the user entered it and cTo is the correctly spelled text as it exists in the database. The goal of the editdist3 algorithm is to determine how close the user-entered text is to the dictionary text.</source>
          <target state="translated">spellfix1 알고리즘에서 cFrom은 사용자가 입력 한 텍스트이고 cTo는 데이터베이스에있는 올바른 철자 텍스트입니다. editdist3 알고리즘의 목표는 사용자가 입력 한 텍스트가 사전 텍스트에 얼마나 가까운 지 확인하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f33fd6db9521ba57d781c7a6cc1cb461b4a1e385" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, now print the version number on initial startup.</source>
          <target state="translated">sqlite 쉘에서 이제 초기 시작시 버전 번호를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="567ed9c7de12cfc6ba8542459479acb37712e779" translate="yes" xml:space="preserve">
          <source>In the sqlite shell, print the &quot;Database opened READ ONLY&quot; message to stderr instead of stdout.</source>
          <target state="translated">sqlite 쉘에서 stdout 대신 &quot;데이터베이스 열림 읽기 전용&quot;메시지를 stderr에 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="04b0bd3687019af0690c1810844c9c6e7505bacb" translate="yes" xml:space="preserve">
          <source>In the statement above, the FTS3 cursor pointer generated by the MATCH operator is send into the carray() table-valued function instead of its intended recipient snippet(). The carray() function treats the pointer as a pointer to an array of integers and returns each integer one by one, thus leaking the content of the FTS3 cursor object. Since the FTS3 cursor object contains pointers to other objects, the statement above would be a pointer leak.</source>
          <target state="translated">위의 명령문에서 MATCH 연산자로 생성 된 FTS3 커서 포인터는 의도 된 수신자 snippet () 대신 carray () 테이블 반환 함수로 전송됩니다. carray () 함수는 포인터를 정수 배열에 대한 포인터로 취급하고 각 정수를 하나씩 반환하여 FTS3 커서 객체의 내용을 누출시킵니다. FTS3 커서 객체에는 다른 객체에 대한 포인터가 포함되어 있으므로 위의 설명은 포인터 누출입니다.</target>
        </trans-unit>
        <trans-unit id="e5c24d1846d01f843a98c707910ed22a0e9486cc" translate="yes" xml:space="preserve">
          <source>In the templates above, NNN represents an integer literal, and VVV represents an alphanumeric identifier. The values of these parameters (also called &quot;host parameter names&quot; or &quot;SQL parameters&quot;) can be set using the sqlite3_bind_*() routines defined here.</source>
          <target state="translated">위의 템플릿에서 NNN은 정수 리터럴을 나타내고 VVV는 영숫자 식별자를 나타냅니다. 이 매개 변수의 값 ( &quot;호스트 매개 변수 이름&quot;또는 &quot;SQL 매개 변수&quot;라고도 함)은 여기에 정의 된 sqlite3_bind _ * () 루틴을 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dee8f982211055f9a9e8d1a438d7f794e0810555" translate="yes" xml:space="preserve">
          <source>In the underlying &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt;, each rowid is stored as a &lt;a href=&quot;fileformat2#varint&quot;&gt;variable-length integer&lt;/a&gt;. That means that small non-negative rowid values take up less disk space than large or negative rowid values.</source>
          <target state="translated">기본 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 에서 각 rowid는 &lt;a href=&quot;fileformat2#varint&quot;&gt;가변 길이 정수&lt;/a&gt; 로 저장됩니다 . 이는 음이 아닌 작은 rowid 값이 큰 또는 음의 rowid 값보다 적은 디스크 공간을 차지함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="147d02b1e1e949a788ff444f3cb5e754276ba6d2" translate="yes" xml:space="preserve">
          <source>In this case the aConstraint[].op value is the same as the value returned by &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction()&lt;/a&gt; for FUNCTION.</source>
          <target state="translated">이 경우 aConstraint []. op 값은 FUNCTION에 대해 &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction ()&lt;/a&gt; 에서 반환 한 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b6bf8cbfac9c457904e9c2859da73ee4a95d3f0d" translate="yes" xml:space="preserve">
          <source>In this case using the temporary b-tree can be avoided by creating an index on t2(c), as follows:</source>
          <target state="translated">이 경우 다음과 같이 t2 (c)에 색인을 작성하여 임시 b- 트리 사용을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a530fdc0efceb4d3e07dfc220358b90fa2145a02" translate="yes" xml:space="preserve">
          <source>In this case, SQLite still does a single binary search to find the first entry of the index where fruit='Orange'. Then it extracts the rowid from the index and uses that rowid to lookup the original table entry via binary search and output the price from the original table. But instead of quitting, the database engine then advances to the next row of index to repeat the process for next fruit='Orange' entry. Advancing to the next row of an index (or table) is much less costly than doing a binary search since the next row is often located on the same database page as the current row. In fact, the cost of advancing to the next row is so cheap in comparison to a binary search that we usually ignore it. So our estimate for the total cost of this query is 3 binary searches. If the number of rows of output is K and the number of rows in the table is N, then in general the cost of doing the query is proportional to (K+1)*logN.</source>
          <target state="translated">이 경우 SQLite는 여전히 단일 이진 검색을 수행하여 fruit = 'Orange'인 인덱스의 첫 번째 항목을 찾습니다. 그런 다음 인덱스에서 rowid를 추출하고 해당 rowid를 사용하여 이진 검색을 통해 원래 테이블 항목을 조회하고 원래 테이블의 가격을 출력합니다. 그러나 데이터베이스 엔진은 종료하는 대신 다음 열 행으로 진행하여 다음 fruit = 'Orange'항목에 대한 프로세스를 반복합니다. 다음 행이 현재 행과 동일한 데이터베이스 페이지에 있기 때문에 이진 검색을 수행하는 것보다 인덱스 (또는 테이블)의 다음 행으로 진행하는 것이 훨씬 저렴합니다. 실제로 다음 행으로 이동하는 비용은 이진 검색에 비해 너무 저렴하여 일반적으로 무시합니다. 따라서이 쿼리의 총 비용에 대한 추정치는 3 개의 이진 검색입니다.출력 행 수가 K이고 테이블의 행 수가 N 인 경우 일반적으로 쿼리 수행 비용은 (K + 1) * logN에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="419a046b4e9791c3dfbe6ecdc597fd0e975a6969" translate="yes" xml:space="preserve">
          <source>In this chart, an SQL statement (&quot;SELECT v FROM kv WHERE k=?1&quot;) is prepared once. Then for each blob, the blob key value is bound to the ?1 parameter and the statement is evaluated to extract the blob content.</source>
          <target state="translated">이 차트에서 SQL 문 ( &quot;SELECT v FROM kv WHERE k =? 1&quot;)이 한 번 준비됩니다. 그런 다음 각 Blob에 대해 Blob 키 값이? 1 매개 변수에 바인드되고 명령문이 평가되어 Blob 컨텐츠를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="67f262080695617f0fd577e77df041ccaf828f11" translate="yes" xml:space="preserve">
          <source>In this example, the content of the docs.body field for the entry where docs.name is &quot;report-15&quot; will be sent to the editor. After the editor returns, the result will be written back into the docs.body field.</source>
          <target state="translated">이 예에서 docs.name이 &quot;report-15&quot;인 항목에 대한 docs.body 필드의 내용이 편집기로 전송됩니다. 편집기가 리턴 된 후 결과는 docs.body 필드에 다시 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="3455933a8fde6f3fc95c8e0f500aee581e4e0da2" translate="yes" xml:space="preserve">
          <source>In this example, the demo_data.boundary field is intended to hold some kind of binary representation of the precise boundaries of the object. The R*Tree index only holds an axis-aligned rectangular boundary for the object. The R*Tree boundary is just an approximation of the true object boundary. So what typically happens is that the R*Tree index is used to narrow a search down to a list of candidate objects and then more detailed and expensive computations are done on each candidate to find if the candidate truly meets the search criteria.</source>
          <target state="translated">이 예에서 demo_data.boundary 필드는 객체의 정확한 경계에 대한 일종의 이진 표현을 유지하기위한 것입니다. R * Tree 인덱스는 객체에 대해 축으로 정렬 된 사각형 경계 만 유지합니다. R * Tree 경계는 실제 객체 경계의 근사치입니다. 따라서 일반적으로 R * Tree 색인을 사용하여 후보 개체 목록으로 검색 범위를 좁히고 각 후보에 대해보다 상세하고 값 비싼 계산을 수행하여 후보가 검색 기준을 실제로 충족하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0eba84e3861d469d7f133f2d07dd6079cc3e76b6" translate="yes" xml:space="preserve">
          <source>In this example, the rowids are not consecutive but they are ordered. SQLite usually creates rowids beginning with one and increasing by one with each added row. But if rows are deleted, gaps can appear in the sequence. And the application can control the rowid assigned if desired, so that rows are not necessarily inserted at the bottom. But regardless of what happens, the rowids are always unique and in strictly ascending order.</source>
          <target state="translated">이 예에서 rowid는 연속적이지 않지만 순서가 있습니다. SQLite는 일반적으로 1부터 시작하여 추가 된 각 행마다 하나씩 증가하는 rowid를 만듭니다. 그러나 행이 삭제되면 시퀀스에 공백이 나타날 수 있습니다. 또한 응용 프로그램은 원하는 경우 지정된 행 ID를 제어하여 행이 맨 아래에 반드시 삽입되는 것은 아닙니다. 그러나 어떤 일이 발생하든 rowid는 항상 고유하며 오름차순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="5350836f804099dba5657839c67d9e6572dea27d" translate="yes" xml:space="preserve">
          <source>In this example, the t2 table is used in a subquery to translate values of the t1.b column. If each table contains N rows, SQLite expects that the subquery will run N times, and hence it will believe it is faster to construct an automatic, transient index on t2 first and then use that index to satisfy the N instances of the subquery.</source>
          <target state="translated">이 예에서 t2 테이블은 하위 쿼리에서 t1.b 열의 값을 변환하는 데 사용됩니다. 각 테이블에 N 개의 행이 포함 된 경우 SQLite는 하위 쿼리가 N 번 실행될 것으로 예상하므로 먼저 t2에 자동 임시 인덱스를 생성 한 다음 해당 인덱스를 사용하여 하위 쿼리의 N 인스턴스를 충족시키는 것이 더 빠르다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="c42a9794244d33827402d87bbb30dbcaf8693beb" translate="yes" xml:space="preserve">
          <source>In this last example, the phonebook2 entry is only updated if the validDate for the newly inserted value is newer than the entry already in the table. If the table already contains an entry with the same name and a current validDate, then the WHERE clause causes the DO UPDATE to become a no-op.</source>
          <target state="translated">이 마지막 예에서 phonebook2 항목은 새로 삽입 된 값의 validDate가 이미 테이블에있는 항목보다 최신 인 경우에만 업데이트됩니다. 테이블에 이름이 같고 현재 validDate 인 항목이 이미 있으면 WHERE 절로 인해 DO UPDATE가 no-op가됩니다.</target>
        </trans-unit>
        <trans-unit id="25dff0fca0922d5e6626c7a322eba86698c2596d" translate="yes" xml:space="preserve">
          <source>In this latter table, there is only a single B-Tree which uses the &quot;word&quot; column as its key and the &quot;cnt&quot; column as its data. (Technicality: the low-level implementation actually stores both &quot;word&quot; and &quot;cnt&quot; in the &quot;key&quot; area of the B-Tree. But unless you are looking at the low-level byte encoding of the database file, that fact is unimportant.) Because there is only a single B-Tree, the text of the &quot;word&quot; column is only stored once in the database. Furthermore, querying the &quot;cnt&quot; value for a specific &quot;word&quot; only involves a single binary search into the main B-Tree, since the &quot;cnt&quot; value can be retrieved directly from the record found by that first search and without the need to do a second binary search on the rowid.</source>
          <target state="translated">후자의 표에는 &quot;word&quot;열을 키로 사용하고 &quot;cnt&quot;열을 데이터로 사용하는 단일 B-Tree 만 있습니다. (기술 : 저수준 구현은 실제로 B-Tree의 &quot;키&quot;영역에 &quot;word&quot;와 &quot;cnt&quot;를 모두 저장하지만 데이터베이스 파일의 저수준 바이트 인코딩을보고 있지 않으면 중요하지 않습니다.) 하나의 B-Tree 만 있기 때문에 &quot;word&quot;열의 텍스트는 데이터베이스에 한 번만 저장됩니다. 또한, 특정 &quot;단어&quot;에 대해 &quot;cnt&quot;값을 쿼리 할 때는 기본 B-Tree에 대한 단일 이진 검색 만 포함됩니다. &quot;cnt&quot;값은 첫 번째 검색에서 찾은 레코드에서 직접 검색 할 필요가 없기 때문입니다. rowid에서 두 번째 이진 검색을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="27f1607d8d73cecfa7aadf0af1217d0ee5b1b3de" translate="yes" xml:space="preserve">
          <source>In this query, the &quot;xaxis&quot; and &quot;yaxis&quot; CTEs define the grid of points for which the Mandelbrot Set will be approximated. Each row in the &quot;m(iter,cx,cy,x,y)&quot; CTE means that after &quot;iter&quot; iterations, the Mandelbrot iteration starting at cx,cy has reached point x,y. The number of iterations in this example is limited to 28 (which severely limits the resolution of the computation, but is sufficient for low-resolution ASCII-art output). The &quot;m2(iter,cx,cy)&quot; CTE holds the maximum number of iterations reached when starting at point cx,cy. Finally, each row in the &quot;a(t)&quot; CTE holds a string which is a single line of the output ASCII-art. The SELECT statement at the end just queries the &quot;a&quot; CTE to retrieve all lines of ASCII-art, one by one.</source>
          <target state="translated">이 쿼리에서 &quot;xaxis&quot;및 &quot;yaxis&quot;CTE는 Mandelbrot 세트가 근사 될 점의 그리드를 정의합니다. &quot;m (iter, cx, cy, x, y)&quot;CTE의 각 행은 &quot;iter&quot;반복 후에 cx, cy에서 시작하는 Mandelbrot 반복이 x, y 지점에 도달했음을 의미합니다. 이 예제의 반복 횟수는 28로 제한됩니다 (이는 계산 해상도를 심각하게 제한하지만 저해상도 ASCII 아트 출력에는 충분합니다). &quot;m2 (iter, cx, cy)&quot;CTE는 cx, cy 지점에서 시작할 때 도달 한 최대 반복 횟수를 보유합니다. 마지막으로, &quot;a (t)&quot;CTE의 각 행에는 출력 ASCII 아트의 한 줄인 문자열이 있습니다. 마지막에있는 SELECT 문은 &quot;a&quot;CTE를 쿼리하여 ASCII 아트의 모든 행을 하나씩 검색합니다.</target>
        </trans-unit>
        <trans-unit id="e3c6ef43db25cfa53ed4da6f4cdaac9eb93f9ff7" translate="yes" xml:space="preserve">
          <source>In this schema, instead of each slide having a page number that determines its order within the presentation, each slide has a unique integer identifier that is unrelated to where it occurs in sequence. The order of slides in the presentation is determined by a list of slideIds, stored as a text string in the MANIFEST column of the VERSION table. Since multiple entries are allowed in the VERSION table, that means that multiple presentations can be stored in the same document.</source>
          <target state="translated">이 스키마에서는 프레젠테이션 내에서 순서를 결정하는 페이지 번호가있는 각 슬라이드 대신 각 슬라이드가 순서대로 발생하는 위치와 관련이없는 고유 한 정수 식별자를 갖습니다. 프레젠테이션의 슬라이드 순서는 VERSION 테이블의 MANIFEST 열에 텍스트 문자열로 저장된 slideId 목록으로 결정됩니다. VERSION 테이블에는 여러 항목이 허용되므로 여러 프레젠테이션을 동일한 문서에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0941893928b48e6ed8f71fafe5691ea7ff76077a" translate="yes" xml:space="preserve">
          <source>In this system, each entry in the song table is required to map to an entry in the album table with the same combination of artist and album.</source>
          <target state="translated">이 시스템에서 곡 테이블의 각 항목은 아티스트와 앨범의 동일한 조합으로 앨범 테이블의 항목에 매핑되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e2304a60e4555367ae83803d8a81dcbbc6bac3fc" translate="yes" xml:space="preserve">
          <source>In this way the new pointer-passing interface seems to solve all of the security problems associated with passing pointer values from one extension to another in SQLite.</source>
          <target state="translated">이런 식으로 새로운 포인터 전달 인터페이스는 SQLite에서 한 확장에서 다른 확장으로 포인터 값을 전달하는 것과 관련된 모든 보안 문제를 해결하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="5b4cc2bd1f16fd79626e9a2d355ec8140a8334dd" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occur at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">네 번째 인수가있는 루틴에서 값은 매개 변수의 바이트 수입니다. 명확하게 : 값은 &lt;u&gt;바이트&lt;/u&gt; 수입니다.&lt;u&gt;&lt;/u&gt;문자 수가 아닌 값으로. sqlite3_bind_text () 또는 sqlite3_bind_text16 ()에 대한 네 번째 매개 변수가 음수이면 문자열의 길이는 첫 번째 0 종결 자까지의 바이트 수입니다. sqlite3_bind_blob ()의 네 번째 매개 변수가 음수이면 동작이 정의되지 않습니다. 음수가 아닌 네 번째 매개 변수가 sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_text64 ()에 제공되는 경우 해당 매개 변수는 문자열이 NUL로 종료되었다고 가정 할 때 NUL 종료자가 발생할 바이트 오프셋이어야합니다. NUL 문자가 네 번째 매개 변수 값보다 작은 바이트 오프셋에서 발생하면 결과 문자열 값에 NUL이 포함됩니다. NUL이 포함 된 문자열과 관련된 표현식의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5c0b6c1ce652bbe2a9ce301182f0e17dcf5f222" translate="yes" xml:space="preserve">
          <source>In those routines that have a fourth argument, its value is the number of bytes in the parameter. To be clear: the value is the number of &lt;u&gt;bytes&lt;/u&gt; in the value, not the number of characters. If the fourth parameter to sqlite3_bind_text() or sqlite3_bind_text16() is negative, then the length of the string is the number of bytes up to the first zero terminator. If the fourth parameter to sqlite3_bind_blob() is negative, then the behavior is undefined. If a non-negative fourth parameter is provided to sqlite3_bind_text() or sqlite3_bind_text16() or sqlite3_bind_text64() then that parameter must be the byte offset where the NUL terminator would occur assuming the string were NUL terminated. If any NUL characters occurs at byte offsets less than the value of the fourth parameter then the resulting string value will contain embedded NULs. The result of expressions involving strings with embedded NULs is undefined.</source>
          <target state="translated">네 번째 인수가있는 루틴에서 해당 값은 매개 변수의 바이트 수입니다. 명확하게 말하면 값은 &lt;u&gt;바이트&lt;/u&gt; 수입니다.&lt;u&gt;&lt;/u&gt;문자 수가 아니라 값에 있습니다. sqlite3_bind_text () 또는 sqlite3_bind_text16 ()의 네 번째 매개 변수가 음수이면 문자열의 길이는 첫 번째 0 종결 자까지의 바이트 수입니다. sqlite3_bind_blob ()에 대한 네 번째 매개 변수가 음수이면 동작이 정의되지 않습니다. 음수가 아닌 네 번째 매개 변수가 sqlite3_bind_text () 또는 sqlite3_bind_text16 () 또는 sqlite3_bind_text64 ()에 제공되면 해당 매개 변수는 문자열이 NUL로 종료되었다고 가정 할 때 NUL 종료자가 발생하는 바이트 오프셋이어야합니다. 네 번째 매개 변수의 값보다 작은 바이트 오프셋에서 NUL 문자가 발생하면 결과 문자열 값에 포함 된 NUL이 포함됩니다. NUL이 포함 된 문자열을 포함하는 표현식의 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5828032be03f722c81b6852fba96bca0f86ff7f" translate="yes" xml:space="preserve">
          <source>In truncate journal mode, the transaction is committed by truncating the journal file to zero length rather than deleting the journal file (as in DELETE mode) or by zeroing the header (as in PERSIST mode). TRUNCATE mode shares the advantage of PERSIST mode that the directory that contains the journal file and database does not need to be updated. Hence truncating a file is often faster than deleting it. TRUNCATE has the additional advantage that it is not followed by a system call (ex: fsync()) to synchronize the change to disk. It might be safer if it did. But on many modern filesystems, a truncate is an atomic and synchronous operation and so we think that TRUNCATE will usually be safe in the face of power failures. If you are uncertain about whether or not TRUNCATE will be synchronous and atomic on your filesystem and it is important to you that your database survive a power loss or operating system crash that occurs during the truncation operation, then you might consider using a different journaling mode.</source>
          <target state="translated">저널 모드 자르기에서는 저널 파일을 삭제하지 않고 (삭제 모드에서와 같이) 저널 파일을 길이가 0으로 자르거나 (PERSIST 모드에서와 같이) 헤더를 0 화하여 트랜잭션을 커미트합니다. TRUNCATE 모드는 저널 파일 및 데이터베이스를 포함하는 디렉토리를 업데이트 할 필요가 없다는 PERSIST 모드의 장점을 공유합니다. 따라서 파일을 자르는 것이 파일을 삭제하는 것보다 빠릅니다. TRUNCATE는 변경 사항을 디스크에 동기화하기 위해 시스템 호출 (예 : fsync ())이 뒤 따르지 않는다는 추가 이점이 있습니다. 그렇게하면 더 안전 할 수 있습니다. 그러나 많은 현대 파일 시스템에서 잘림은 원자적이고 동기적인 작업이므로 TRUNCATE는 정전시 일반적으로 안전하다고 생각합니다.TRUNCATE가 파일 시스템에서 동 기적이며 원자 적인지 여부에 대해 확실하지 않은 경우 데이터베이스가 절단 작업 중에 발생하는 전원 손실 또는 운영 체제 충돌에서 살아남는 것이 중요한 경우 다른 저널링 모드를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0ad1bfd687f56543c8ea5ff79723971d89b554aa" translate="yes" xml:space="preserve">
          <source>In version 3.5.9 the query above would return a single column named &quot;t1.a&quot;. In version 3.6.0 the column name is just &quot;a&quot;.</source>
          <target state="translated">버전 3.5.9에서 위의 쿼리는 &quot;t1.a&quot;라는 단일 열을 반환합니다. 버전 3.6.0에서 열 이름은 &quot;a&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b38dc06ca0b3ec94d37d385f6a25506410f69b7f" translate="yes" xml:space="preserve">
          <source>In very old versions of SQLite (before version 3.7.11 - 2012-03-20) the ROLLBACK will fail with an error code &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; if there are any pending queries. In more recent versions of SQLite, the ROLLBACK will proceed and pending statements will often be aborted, causing them to return an &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; or &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; error. In SQLite version 3.8.8 (2015-01-16) and later, a pending read will continue functioning after the ROLLBACK as long as the ROLLBACK does not modify the database schema.</source>
          <target state="translated">이전 버전의 SQLite (버전 3.7.11-2012-03-20 이전)에서 보류중인 쿼리가 있으면 오류 코드 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 와 함께 ROLLBACK이 실패 합니다. 최신 버전의 SQLite에서 ROLLBACK이 진행되고 보류중인 문이 종종 중단되어 &lt;a href=&quot;rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 또는 &lt;a href=&quot;rescode#abort_rollback&quot;&gt;SQLITE_ABORT_ROLLBACK&lt;/a&gt; 오류가 반환 됩니다. SQLite 버전 3.8.8 (2015-01-16) 이상에서 ROLLBACK이 데이터베이스 스키마를 수정하지 않는 한 보류중인 읽기는 ROLLBACK 후에 계속 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b499aec31026161ef5b7e71ea3cf99793674a2a9" translate="yes" xml:space="preserve">
          <source>In words, we have a database table named &quot;examp&quot; that has two columns of data named &quot;one&quot; and &quot;two&quot;. Now suppose we want to insert a single record into this table. Like this:</source>
          <target state="translated">즉, &quot;one&quot;과 &quot;two&quot;라는 두 개의 데이터 열이있는 &quot;examp&quot;라는 데이터베이스 테이블이 있습니다. 이제이 테이블에 단일 레코드를 삽입하려고한다고 가정하십시오. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="538f80f611dd84d930a92b9f7317e8773bd20fa3" translate="yes" xml:space="preserve">
          <source>In-Memory Databases</source>
          <target state="translated">인 메모리 데이터베이스</target>
        </trans-unit>
        <trans-unit id="d29dcc989f8aeac43865c646816b27c0bf5d86c1" translate="yes" xml:space="preserve">
          <source>In-memory Databases And Shared Cache</source>
          <target state="translated">인 메모리 데이터베이스 및 공유 캐시</target>
        </trans-unit>
        <trans-unit id="f87e1ebcfb907fda4b66420b21bcba1a298d5d80" translate="yes" xml:space="preserve">
          <source>In-memory databases are allowed to use &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; if they are opened using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. If the unadorned &quot;:memory:&quot; name is used to specify the in-memory database, then that database always has a private cache and is this only visible to the database connection that originally opened it. However, the same in-memory database can be opened by two or more database connections as follows:</source>
          <target state="translated">인 메모리 데이터베이스는 &lt;a href=&quot;uri&quot;&gt;URI filename을&lt;/a&gt; 사용하여 열 경우 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 를 사용할 수 있습니다 . 메모리에없는 데이터베이스를 지정하기 위해 unadorned &quot;: memory :&quot;이름을 사용하는 경우 해당 데이터베이스에는 항상 개인 캐시가 있으며 원래 데이터베이스를 연 데이터베이스 연결에서만 볼 수 있습니다. 그러나 다음과 같이 두 개 이상의 데이터베이스 연결로 동일한 인 메모리 데이터베이스를 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e5ba204b0641a7420c326e6c9ccf4a171f01a91" translate="yes" xml:space="preserve">
          <source>Include a digit somewhere in every identifier name.</source>
          <target state="translated">모든 식별자 이름 어딘가에 숫자를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="609cf98670fbb073608f2b25b70dd7c1c13a30bc" translate="yes" xml:space="preserve">
          <source>Include a static string in the library that responds to the RCS &quot;ident&quot; command and which contains the library version number.</source>
          <target state="translated">RCS &quot;ident&quot;명령에 응답하고 라이브러리 버전 번호를 포함하는 정적 문자열을 라이브러리에 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="c0417d1d2b8071cc5718dd6c321dee3ddd0e2b30" translate="yes" xml:space="preserve">
          <source>Incompatible changes are covered first since they are the most important to maintainers and programmers.</source>
          <target state="translated">호환되지 않는 변경 사항은 유지 보수 자와 프로그래머에게 가장 중요하므로 먼저 다룹니다.</target>
        </trans-unit>
        <trans-unit id="bc118ee16ef865aed415e5f3a8d6022aa76b72dd" translate="yes" xml:space="preserve">
          <source>Inconsistent result set column names between CREATE TABLE AS and a simple SELECT. Ticket &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</source>
          <target state="translated">CREATE TABLE AS와 간단한 SELECT 사이에 결과 집합 열 이름이 일치하지 않습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/3b4450072511e621&quot;&gt;3b4450072511e621&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7579773ac4d764f11e434b97ff14dade4554c12" translate="yes" xml:space="preserve">
          <source>Incorporate makefile patches form A. Rottmann to use LIBTOOL</source>
          <target state="translated">A. Rottmann이 LIBTOOL을 사용하도록 makefile 패치를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="78318ed3e6ca4f2006eecd671fb4e1b78bbf85cb" translate="yes" xml:space="preserve">
          <source>Incorrect</source>
          <target state="translated">Incorrect</target>
        </trans-unit>
        <trans-unit id="f074a009d21038c67513df8d49c6353ecce4802a" translate="yes" xml:space="preserve">
          <source>Incorrect assert() statement removed. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt;.</source>
          <target state="translated">잘못된 assert () 문이 제거되었습니다. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/823779d31eb09cda&quot;&gt;823779d31eb09cda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86f64d7d599af33f2e2d357b68bfbc2590e32e39" translate="yes" xml:space="preserve">
          <source>Incorrect column datatype reported. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;a8a0d2996a&lt;/a&gt;</source>
          <target state="translated">잘못된 열 데이터 유형이보고되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/a8a0d2996a&quot;&gt;A8A0D2996A&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5010ff6ebfa98793b55410eccec7fb293111ca61" translate="yes" xml:space="preserve">
          <source>Incorrect query results on a join with a ORDER BY DESC. Ticket &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt;.</source>
          <target state="translated">ORDER BY DESC와의 결합에서 올바르지 않은 조회 결과. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/123c9ba32130a6c9&quot;&gt;123c9ba32130a6c9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d72bf52d94d169fcce6582014fa4914c962c4cbe" translate="yes" xml:space="preserve">
          <source>Incorrect query results when the skip-ahead-distinct optimization is used. Ticket &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt;.</source>
          <target state="translated">미리 건너 뛰기 최적화가 사용될 때 잘못된 쿼리 결과. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/ef9318757b152e3a&quot;&gt;ef9318757b152e3a&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b88b306633c693ef74330d871a60d1a4c0698aa" translate="yes" xml:space="preserve">
          <source>Incorrect result on the less-than operator in &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;f484b65f3d62305&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 에서보다 작음 연산자에 대한 결과가 잘못되었습니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f484b65f3d62305&quot;&gt;F484B65F3D62305&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353e2ea7a72adf3f039c8f1d29d7d6a2765ce415" translate="yes" xml:space="preserve">
          <source>IncrVacuum</source>
          <target state="translated">IncrVacuum</target>
        </trans-unit>
        <trans-unit id="bfb28e75251bc4d83a52b5697560b9c1115b80bf" translate="yes" xml:space="preserve">
          <source>Increase the &lt;a href=&quot;limits#max_variable_number&quot;&gt;default upper bound&lt;/a&gt; on the number of &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; from 999 to 32766.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 수의 &lt;a href=&quot;limits#max_variable_number&quot;&gt;기본 상한&lt;/a&gt; 을 999에서 32766 으로 늘 립니다.</target>
        </trans-unit>
        <trans-unit id="21ef0be270a54a1cdd6fa173d6d67cc79394e640" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; allocation size from 100 to 128 bytes.</source>
          <target state="translated">기본 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자&lt;/a&gt; 할당 크기를 100에서 128 바이트로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="40e4fa7cf5d195215158819dc861b48ed9ae1b97" translate="yes" xml:space="preserve">
          <source>Increase the default &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; size from 512,125 to 1200,100 as this provides better performance while only adding 56KB of extra memory per connection. Memory-sensitive applications can restore the old default at compile-time, start-time, or run-time.</source>
          <target state="translated">연결 당 56KB의 추가 메모리 만 추가하는 동시에 더 나은 성능을 제공 하므로 기본 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside&lt;/a&gt; 크기를 512,125에서 1200,100으로 늘리십시오 . 메모리에 민감한 응용 프로그램은 컴파일 타임, 시작 시간 또는 런타임에 이전 기본값을 복원 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1c35718b4f025f2f5dcc35d709e6b06c180f12" translate="yes" xml:space="preserve">
          <source>Increase the default size of a lookahead cache line from 100 to 128 bytes.</source>
          <target state="translated">lookahead 캐시 라인의 기본 크기를 100 바이트에서 128 바이트로 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="7da2a83b3ac0a9788385c812ce2d8ccd3f55fd86" translate="yes" xml:space="preserve">
          <source>Increase the default value of &lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; to 50 and make sure that it is honored in every place that a schema change might force a statement retry.</source>
          <target state="translated">&lt;a href=&quot;compile#max_schema_retry&quot;&gt;SQLITE_MAX_SCHEMA_RETRY&lt;/a&gt; 의 기본값 을 50 으로 늘리고 모든 위치에서 스키마 변경으로 인해 명령문이 재 시도되도록 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8609e4a99103452adeaaadda83f7438f10dd550a" translate="yes" xml:space="preserve">
          <source>Increase the maximum &quot;scope&quot; value for the &lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; extension from 6 to 30.</source>
          <target state="translated">&lt;a href=&quot;spellfix1&quot;&gt;spellfix1&lt;/a&gt; 확장자 의 최대 &quot;scope&quot;값을 6에서 30으로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="c2f2fd643cba996348fe945409caf6a8045d3c9f" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of a database pages from 32KiB to 64KiB.</source>
          <target state="translated">데이터베이스 페이지의 최대 크기를 32KiB에서 64KiB로 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="c023946d393ce520944a7e8848356e945bf33b16" translate="yes" xml:space="preserve">
          <source>Increase the maximum size of database files to 281 TB.</source>
          <target state="translated">데이터베이스 파일의 최대 크기를 281TB로 늘립니다.</target>
        </trans-unit>
        <trans-unit id="45c470cb2d5edd4a76a24043774f958df34166de" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 30 to 62 (though the default value remains at 10).</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; 의 최대 값을 30에서 62로 늘리십시오 (기본값은 10 으로 유지됨 ).</target>
        </trans-unit>
        <trans-unit id="bb8cf068d7b2280526a2d202959cea91dd49770d" translate="yes" xml:space="preserve">
          <source>Increase the maximum value of &lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; from 62 to 125.</source>
          <target state="translated">&lt;a href=&quot;limits#max_attached&quot;&gt;SQLITE_MAX_ATTACHED&lt;/a&gt; 의 최대 값을 62에서 125로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="69df92b5969bbc35734aa6107d3290339d53b888" translate="yes" xml:space="preserve">
          <source>Increase the timeout in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; before issuing an &lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; error from 1 second to 10 seconds.</source>
          <target state="translated">&lt;a href=&quot;rescode#protocol&quot;&gt;SQLITE_PROTOCOL&lt;/a&gt; 오류를 발행하기 전에 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 제한 시간 을 1 초에서 10 초로 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="9f009e1e744f83083af0b2cc7e6b2078c78f112f" translate="yes" xml:space="preserve">
          <source>Increased robustness against malicious SQL that is run against a maliciously corrupted database.</source>
          <target state="translated">악의적으로 손상된 데이터베이스에 대해 실행되는 악성 SQL에 대한 견고성이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b178246a9f68a2d5235ede0c3d198671a18c66b" translate="yes" xml:space="preserve">
          <source>Increased the version number on the &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; to 3 and added new methods xSetSysCall, xGetSysCall, and xNextSysCall used for doing full-coverage testing.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;VFS 오브젝트&lt;/a&gt; 의 버전 번호 를 3으로 늘리고 전체 범위 테스트를 수행하는 데 사용되는 새로운 메소드 xSetSysCall, xGetSysCall 및 xNextSysCall을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5b01748d80c9a44e0b5e68cd44f76d6fdcd5fbdb" translate="yes" xml:space="preserve">
          <source>Increment a &quot;constraint counter&quot; by P2 (P2 may be negative or positive). If P1 is non-zero, the database constraint counter is incremented (deferred foreign key constraints). Otherwise, if P1 is zero, the statement counter is incremented (immediate foreign key constraints).</source>
          <target state="translated">P2에 의해 &quot;제한 카운터&quot;를 증가시킵니다 (P2는 음수 또는 양수일 수 있음). P1이 0이 아닌 경우 데이터베이스 제한 조건 카운터가 증가합니다 (지연된 외래 키 제한 조건). 그렇지 않으면 P1이 0이면 명령문 카운터가 증가합니다 (즉각 외래 키 제한 조건).</target>
        </trans-unit>
        <trans-unit id="9728ef186d1aa3193e57c71ddbd9cc22dfa95396" translate="yes" xml:space="preserve">
          <source>Increment the schema version number using &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version=X&lt;/a&gt; where X is one more than the old schema version number found in step 2 above.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version = X를&lt;/a&gt; 사용하여 스키마 버전 번호를 늘리십시오. 여기서 X는 위의 2 단계에서 찾은 이전 스키마 버전 번호보다 하나 더 많습니다.</target>
        </trans-unit>
        <trans-unit id="8144fd658d7904e59a32604de5f5f1ca74f2f2ee" translate="yes" xml:space="preserve">
          <source>Increment the value of P1 so that &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes will jump the first time they are evaluated for this run.</source>
          <target state="translated">한 &lt;a href=&quot;opcode#Once&quot;&gt;번&lt;/a&gt; opcode가이 실행에 대해 처음 평가 될 때 점프 하도록 P1의 값을 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="99958674e5ab051f627364f0e7aec7700da2c443" translate="yes" xml:space="preserve">
          <source>Incremental And Continuous Updates</source>
          <target state="translated">증분 및 지속적인 업데이트</target>
        </trans-unit>
        <trans-unit id="c978bfe7fe02498da062fb7e2f5271fe832940ed" translate="yes" xml:space="preserve">
          <source>Index B-Tree Interior Cell (header 0x02):</source>
          <target state="translated">인덱스 B- 트리 내부 셀 (헤더 0x02) :</target>
        </trans-unit>
        <trans-unit id="4e71969581a513a52c19a67df3b923e84e3cb4d7" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Cell (header 0x0a):</source>
          <target state="translated">인덱스 B- 트리 리프 셀 (헤더 0x0a) :</target>
        </trans-unit>
        <trans-unit id="6834f50285e5eaa6aab20cfc4003ad141369bccf" translate="yes" xml:space="preserve">
          <source>Index B-Tree Leaf Or Interior Cell:</source>
          <target state="translated">색인 B 나무 잎 또는 내부 세포 :</target>
        </trans-unit>
        <trans-unit id="d05474cb52cfb6c27f6a9c375d177e07d462e5e6" translate="yes" xml:space="preserve">
          <source>Index Interior (0x02)</source>
          <target state="translated">인덱스 인테리어 (0x02)</target>
        </trans-unit>
        <trans-unit id="f35ac0d24fd01ec25554f05ecc89c727c71a1e04" translate="yes" xml:space="preserve">
          <source>Index Leaf (0x0a)</source>
          <target state="translated">인덱스 리프 (0x0a)</target>
        </trans-unit>
        <trans-unit id="96c319248a56deb59ef179cae4ae3f7a3c92eca2" translate="yes" xml:space="preserve">
          <source>Index Of A Parameter With A Given Name</source>
          <target state="translated">주어진 이름을 가진 매개 변수의 색인</target>
        </trans-unit>
        <trans-unit id="239b13bdf631a9f83fa9a8a3d5c3895198fcc15a" translate="yes" xml:space="preserve">
          <source>Indexes On Expressions</source>
          <target state="translated">식에 대한 색인</target>
        </trans-unit>
        <trans-unit id="f48dd71980245b4a0803daa066444bcb1b77f26c" translate="yes" xml:space="preserve">
          <source>Indexes are removed with the &lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;lang_dropindex&quot;&gt;DROP INDEX&lt;/a&gt; 명령으로 인덱스를 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="535c9c6ad77a4b24ea3df3e8a1b9f2c196027e6c" translate="yes" xml:space="preserve">
          <source>Indexes can use &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; and &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE&lt;/a&gt;</source>
          <target state="translated">인덱스는 &lt;a href=&quot;lang_createindex#descidx&quot;&gt;DESC&lt;/a&gt; 및 &lt;a href=&quot;lang_createindex#collidx&quot;&gt;COLLATE를&lt;/a&gt; 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5826c397297007e146b25d7bb80a3a9d200a4f00" translate="yes" xml:space="preserve">
          <source>Indices are not required for child key columns but they are almost always beneficial. Returning to the example in &lt;a href=&quot;#fk_basics&quot;&gt;section 1&lt;/a&gt;, each time an application deletes a row from the</source>
          <target state="translated">하위 키 열에는 인덱스가 필요하지 않지만 거의 항상 유리합니다. &lt;a href=&quot;#fk_basics&quot;&gt;섹션 1&lt;/a&gt; 의 예제로 돌아가서 애플리케이션이 애플리케이션에서 행을 삭제할 때마다</target>
        </trans-unit>
        <trans-unit id="952faf72c9a83e116cef336ce73f046eb32c95b9" translate="yes" xml:space="preserve">
          <source>Indices with names of the form &quot;sqlite_autoindex_TABLE_N&quot; that are used to implement &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; and &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraints on ordinary tables.</source>
          <target state="translated">일반 테이블에서 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 제약 조건 을 구현하는 데 사용되는 &quot;sqlite_autoindex_TABLE_N&quot;형식의 이름을 가진 인덱스</target>
        </trans-unit>
        <trans-unit id="853f712d884520adb0232cc6445c159a48a0d960" translate="yes" xml:space="preserve">
          <source>Individual database connections created using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; can choose to participate or not participate in shared cache mode by using the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; or &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags the third parameter. The use of either of these flags overrides the global shared cache mode setting established by &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt;. No more than one of the flags should be used; if both SQLITE_OPEN_SHAREDCACHE and SQLITE_OPEN_PRIVATECACHE flags are used in the third argument to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; then the behavior is undefined.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 사용하여 작성된 개별 데이터베이스 연결 은 세 번째 매개 변수 인 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; 플래그를 사용하여 공유 캐시 모드에 참여하거나 참여하지 않도록 선택할 수 있습니다 . 이 플래그 중 하나를 사용하면 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()에&lt;/a&gt; 의해 설정된 글로벌 공유 캐시 모드 설정을 대체합니다 . 하나 이상의 플래그를 사용해야합니다. SQLITE_OPEN_SHAREDCACHE 및 SQLITE_OPEN_PRIVATECACHE 플래그가 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 의 세 번째 인수에 사용 되면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e34e9639a7829e3d1eeead355b99441da28ac59a" translate="yes" xml:space="preserve">
          <source>Individual fields of the shm header, except for the salt values copied from the WAL header, are unsigned integers in the native byte-order of the host machine. The salt values are exact copies from the WAL header and are in whatever byte order is used by the WAL file. The size of integers may be 8, 16, 32, or 64 bits. A detailed breakout of the individual fields of the shm header follows:</source>
          <target state="translated">WAL 헤더에서 복사 된 솔트 값을 제외한 shm 헤더의 개별 필드는 호스트 시스템의 기본 바이트 순서에서 부호없는 정수입니다. 솔트 값은 WAL 헤더의 정확한 사본이며 WAL 파일에서 사용하는 바이트 순서에 관계없이 있습니다. 정수의 크기는 8, 16, 32 또는 64 비트 일 수 있습니다. shm 헤더의 개별 필드에 대한 자세한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afaa9b90ffb384cf537b3db99f57a1ca2ab340a0" translate="yes" xml:space="preserve">
          <source>Individual subterms might be a single comparison expression like *a=5* or *x&amp;gt;y* or they can be LIKE or BETWEEN expressions, or a subterm can be a parenthesized list of AND-connected sub-subterms. Each subterm is analyzed as if it were itself the entire WHERE clause in order to see if the subterm is indexable by itself. If &lt;u&gt;every&lt;/u&gt; subterm of an OR clause is separately indexable then the OR clause might be coded such that a separate index is used to evaluate each term of the OR clause. One way to think about how SQLite uses separate indices for each OR clause term is to imagine that the WHERE clause where rewritten as follows:</source>
          <target state="translated">개별 하위 용어는 * a = 5 * 또는 * x&amp;gt; y *와 같은 단일 비교식이거나 LIKE 또는 BETWEEN식이거나 하위 연결은 괄호로 묶인 AND 연결 하위 하위 목록 일 수 있습니다. 각 하위 용어는 자체적으로 전체 WHERE 절인 것처럼 분석되어 하위 용어 자체가 색인 가능한지 여부를 확인합니다. 경우 &lt;u&gt;모든&lt;/u&gt; 는 OR 절 subterm 별도로 색인입니다 후 OR 절은 별도의 인덱스는 OR 절의 각 용어를 평가하는 데 사용되도록 코딩 될 수 있습니다. SQLite가 각 OR 절 용어에 대해 별도의 인덱스를 사용하는 방법에 대해 생각하는 한 가지 방법은 WHERE 절이 다음과 같이 다시 작성되었다고 상상하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a9fd17dd36196733342a48e4a93f680869a4f7c" translate="yes" xml:space="preserve">
          <source>Individual virtual table implementations might impose additional constraints. For example, some virtual implementations might provide read-only tables. Or some virtual table implementations might allow &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; but not &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Or some virtual table implementations might limit the kinds of UPDATEs that can be made.</source>
          <target state="translated">개별 가상 테이블 구현은 추가 제한 조건을 부과 할 수 있습니다. 예를 들어, 일부 가상 구현은 읽기 전용 테이블을 제공 할 수 있습니다. 또는 일부 가상 테이블 구현에서는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE를&lt;/a&gt; 허용 하지만 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 는 허용 하지 않을 수 있습니다 . 또는 일부 가상 테이블 구현으로 인해 UPDATE 유형이 제한 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7ab8cb519f7ae8e1280427c18f93285db556ab6" translate="yes" xml:space="preserve">
          <source>Infinite loop on an UPDATE that uses an OR operator in the WHERE clause. Problem introduced with 3.17.0 and reported on the mailing list about one year later. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt;.</source>
          <target state="translated">WHERE 절에서 OR 연산자를 사용하는 UPDATE의 무한 루프. 3.17.0에서 소개 된 문제로 약 1 년 후 메일 링리스트에보고되었습니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/47b2581aa9bfecec&quot;&gt;47b2581aa9bfecec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9779307227ff608723d6f1acc622b0fbd0d99060" translate="yes" xml:space="preserve">
          <source>Information about the ORDER BY clause is stored in aOrderBy[]. Each term of aOrderBy records a column of the ORDER BY clause.</source>
          <target state="translated">ORDER BY 절에 대한 정보는 aOrderBy []에 저장됩니다. aOrderBy의 각 용어는 ORDER BY 절의 열을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="8900519c8c00e46885e8acc9f5e07ba3fa96d336" translate="yes" xml:space="preserve">
          <source>Informix</source>
          <target state="translated">Informix</target>
        </trans-unit>
        <trans-unit id="19682bdb9185a5fa9d763d414d0443d3a0bc2456" translate="yes" xml:space="preserve">
          <source>Init</source>
          <target state="translated">Init</target>
        </trans-unit>
        <trans-unit id="c807a586d6078a7e14adef4ebb7912d0c6f4aa53" translate="yes" xml:space="preserve">
          <source>InitCoroutine</source>
          <target state="translated">InitCoroutine</target>
        </trans-unit>
        <trans-unit id="9ceecfe65e61c428178f61207aad8930969e6176" translate="yes" xml:space="preserve">
          <source>Initial Public Release of Alpha code</source>
          <target state="translated">알파 코드의 최초 공개</target>
        </trans-unit>
        <trans-unit id="22e34d8b442d40192baed65a8aa102e6e94f33a1" translate="yes" xml:space="preserve">
          <source>Initial release of version 2.0. The idea of renaming the library to &quot;SQLus&quot; was abandoned in favor of keeping the &quot;SQLite&quot; name and bumping the major version number.</source>
          <target state="translated">버전 2.0의 초기 릴리스. 라이브러리를 &quot;SQLus&quot;로 이름을 바꾸려는 아이디어는 &quot;SQLite&quot;이름을 유지하고 주요 버전 번호를 부딪히기 위해 포기되었습니다.</target>
        </trans-unit>
        <trans-unit id="8f5bfa371a731c186afb7ca1237eb5d4d7f1e077" translate="yes" xml:space="preserve">
          <source>Initial size of the database in pages</source>
          <target state="translated">페이지의 데이터베이스 초기 크기</target>
        </trans-unit>
        <trans-unit id="7bf3e06594405eb1afbafdd083622d687011597a" translate="yes" xml:space="preserve">
          <source>Initialize The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 초기화</target>
        </trans-unit>
        <trans-unit id="d191407d44cf9ade286348bd4b44b9f7f3e25feb" translate="yes" xml:space="preserve">
          <source>Initialize index X to be N-200 (where N is the size of a database page in bytes.</source>
          <target state="translated">색인 X를 N-200으로 초기화하십시오 (여기서 N은 데이터베이스 페이지의 크기 (바이트)).</target>
        </trans-unit>
        <trans-unit id="8e6cd4e5b42b5a543357e6d81e6f378b25c829f6" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;b&gt;azColumnName[]&lt;/b&gt; array for the callback.</source>
          <target state="translated">콜백에 대한 &lt;b&gt;azColumnName []&lt;/b&gt; 배열을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f7aab6a3275a65fb3b4985527f188c8b61dc3b5" translate="yes" xml:space="preserve">
          <source>Initialize the checksum to the checksum nonce value found in the journal header at offset 12.</source>
          <target state="translated">오프셋 12에서 저널 헤더에있는 체크섬 nonce 값으로 체크섬을 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="404f059fc8a52705cd25b69b3e9ff09c1be18ec9" translate="yes" xml:space="preserve">
          <source>Inner joins can be freely reordered. However a left outer join is neither commutative nor associative and hence will not be reordered. Inner joins to the left and right of the outer join might be reordered if the optimizer thinks that is advantageous but the outer joins are always evaluated in the order in which they occur.</source>
          <target state="translated">내부 조인은 자유롭게 재정렬 할 수 있습니다. 그러나 왼쪽 외부 조인은 정식이나 연관성이 없으므로 재정렬되지 않습니다. 옵티마이 저가 유리하다고 생각하지만 외부 조인이 항상 발생 순서대로 평가되면 외부 조인의 왼쪽과 오른쪽에있는 내부 조인이 재정렬 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95802daab3a23990338179f72248350c1434cf39" translate="yes" xml:space="preserve">
          <source>Insert</source>
          <target state="translated">Insert</target>
        </trans-unit>
        <trans-unit id="6173fc45fc7b2219f9b313a58dd34b30a31fc6dc" translate="yes" xml:space="preserve">
          <source>Insert that single row into the recursive table</source>
          <target state="translated">해당 단일 행을 재귀 테이블에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="e9c69a8b8aca121e6ec4067a03fd7e5c40db2b72" translate="yes" xml:space="preserve">
          <source>Insert the integer value held by register P2 into a RowSet object held in register P1.</source>
          <target state="translated">레지스터 P2가 보유한 정수 값을 레지스터 P1에 보유 된 RowSet 오브젝트에 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="85a8fe292b0b6ab92cb375e9d651b4f869ca615a" translate="yes" xml:space="preserve">
          <source>Inserting Records Into The Database</source>
          <target state="translated">데이터베이스에 레코드 삽입</target>
        </trans-unit>
        <trans-unit id="d9102185aa139480514433588d7c7980df39e939" translate="yes" xml:space="preserve">
          <source>Instead of a separate OFFSET clause, the LIMIT clause may specify two scalar expressions separated by a comma. In this case, the first expression is used as the OFFSET expression and the second as the LIMIT expression. This is counter-intuitive, as when using the OFFSET clause the second of the two expressions is the OFFSET and the first the LIMIT. This reversal of the offset and limit is intentional - it maximizes compatibility with other SQL database systems. However, to avoid confusion, programmers are strongly encouraged to use the form of the LIMIT clause that uses the &quot;OFFSET&quot; keyword and avoid using a LIMIT clause with a comma-separated offset.</source>
          <target state="translated">LIMIT 절은 별도의 OFFSET 절 대신 쉼표로 구분 된 두 개의 스칼라 식을 지정할 수 있습니다. 이 경우 첫 번째 표현식은 OFFSET 표현식으로 사용되고 두 번째 표현식은 LIMIT 표현식으로 사용됩니다. 이는 OFFSET 절을 사용할 때 두 표현식 중 두 번째 표현식이 OFFSET이고 첫 번째가 LIMIT이므로 직관적이지 않습니다. 이러한 오프셋 및 제한의 반전은 의도적입니다. 다른 SQL 데이터베이스 시스템과의 호환성을 최대화합니다. 그러나 혼동을 피하기 위해 프로그래머는 &quot;OFFSET&quot;키워드를 사용하는 LIMIT 절 형식을 사용하고 쉼표로 구분 된 오프셋으로 LIMIT 절을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d84a58129471e483da1b069622f8ee436752fbf7" translate="yes" xml:space="preserve">
          <source>Instead of deleting records where the &quot;two&quot; column is less than 50, this statement just puts the &quot;one&quot; column in parentheses The VDBE program to implement this statement follows:</source>
          <target state="translated">&quot;두&quot;열이 50보다 작은 레코드를 삭제하는 대신이 명령문은 &quot;하나&quot;열을 괄호 안에 넣습니다.이 명령문을 구현하는 VDBE 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="123ee948ecafb3b169cf486ec20a13fbb0b9103f" translate="yes" xml:space="preserve">
          <source>Instead of providing full Unicode case support by default, SQLite provides the ability to link against external Unicode comparison and conversion routines. The application can overload the built-in &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; collating sequence (using &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt;) and the built-in &lt;a href=&quot;lang_corefunc#like&quot;&gt;like()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper()&lt;/a&gt;, and &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower()&lt;/a&gt; functions (using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt;). The SQLite source code includes an &quot;ICU&quot; extension that does these overloads. Or, developers can write their own overloads based on their own Unicode-aware comparison routines already contained within their project.</source>
          <target state="translated">SQLite는 기본적으로 완전한 유니 코드 대 / 소문자 지원을 제공하는 대신 외부 유니 코드 비교 및 ​​변환 루틴에 대한 링크 기능을 제공합니다. 애플리케이션은 내장 &lt;a href=&quot;datatype3#collation&quot;&gt;NOCASE&lt;/a&gt; 조합 시퀀스 ( &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation () 사용&lt;/a&gt; ) 및 내장 &lt;a href=&quot;lang_corefunc#like&quot;&gt;like ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#upper&quot;&gt;upper ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#lower&quot;&gt;lower ()&lt;/a&gt; 함수 ( &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 사용 )를 오버로드 할 수 있습니다 . SQLite 소스 코드에는 이러한 과부하를 수행하는 &quot;ICU&quot;확장자가 포함되어 있습니다. 또는 개발자는 프로젝트에 이미 포함 된 고유 한 유니 코드 인식 비교 루틴을 기반으로 자체 과부하를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e02d371a11cece5f4e01254e6fedf80303033a58" translate="yes" xml:space="preserve">
          <source>Instead of using a single data structure on disk to store the full-text index, FTS5 uses a series of b-trees. Each time a new transaction is committed, a new b-tree containing the contents of the committed transaction is written into the database file. When the full-text index is queried, each b-tree must be queried individually and the results merged before being returned to the user.</source>
          <target state="translated">전체 텍스트 인덱스를 저장하기 위해 디스크에서 단일 데이터 구조를 사용하는 대신 FTS5는 일련의 b- 트리를 사용합니다. 새 트랜잭션이 커밋 될 때마다 커밋 된 트랜잭션의 내용을 포함하는 새 b- 트리가 데이터베이스 파일에 기록됩니다. 전체 텍스트 인덱스를 쿼리 할 때 각 b- 트리를 개별적으로 쿼리하고 결과를 병합하여 사용자에게 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="17249ad26f29e1aabdd8d073e961780b07d76064" translate="yes" xml:space="preserve">
          <source>Instead of using bm25() with no trailing arguments, the specific auxiliary function mapped to the rank column may be configured either on a per-query basis, or by setting a different persistent default for the FTS table.</source>
          <target state="translated">후행 인수없이 bm25 ()를 사용하는 대신 순위 열에 매핑 된 특정 보조 함수는 쿼리별로 구성하거나 FTS 테이블에 대해 다른 영구 기본값을 설정하여 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96fd53b0d03f5a031e6bd07854c303b890ed6f3" translate="yes" xml:space="preserve">
          <source>Instead of writing separately to the full-text index and the content table, some users may wish to use database triggers to keep the full-text index up to date with respect to the set of documents stored in the content table. For example, using the tables from earlier examples:</source>
          <target state="translated">전체 텍스트 인덱스와 컨텐트 테이블에 별도로 쓰는 대신 일부 사용자는 데이터베이스 트리거를 사용하여 컨텐트 테이블에 저장된 문서 집합과 관련하여 전체 텍스트 인덱스를 최신 상태로 유지할 수 있습니다. 예를 들어, 이전 예제의 테이블을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2dfaa927aed3a85d724ea909cde490986f208ecf" translate="yes" xml:space="preserve">
          <source>Instruction 1 is of particular importance in this example. Normally, the Column instruction extracts the value of a column from a larger record in the data of an SQLite file entry. Instruction 1 sets a flag on the transient table so that Column will instead treat the key of the SQLite file entry as if it were data and extract column information from the key.</source>
          <target state="translated">이 예에서는 명령 1이 특히 중요합니다. 일반적으로 Column 명령어는 SQLite 파일 항목의 데이터에서 더 큰 레코드에서 열 값을 추출합니다. 명령 1은 임시 테이블에 플래그를 설정하여 Column이 대신 SQLite 파일 항목의 키를 데이터 인 것처럼 취급하고 키에서 열 정보를 추출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="5a41b63030179eee6fe726824158f303ff0039a4" translate="yes" xml:space="preserve">
          <source>Instructions 0 though 4 are as in the INSERT example. They start transactions for the main and temporary databases, verify the database schema for the main database, and open a read cursor on the table &quot;examp&quot;. Notice that the cursor is opened for reading, not writing. At this stage of the program we are only going to be scanning the table, not changing it. We will reopen the same table for writing later, at instruction 15.</source>
          <target state="translated">명령어 0 ~ 4는 INSERT 예와 같습니다. 기본 및 임시 데이터베이스에 대한 트랜잭션을 시작하고 기본 데이터베이스에 대한 데이터베이스 스키마를 확인한 후 &quot;examp&quot;테이블에서 읽기 커서를 엽니 다. 커서는 쓰기가 아니라 읽기 위해 열립니다. 프로그램의이 단계에서는 테이블을 변경하지 않고 스캔 만 할 것입니다. 우리는 명령 15에서 나중에 쓰기 위해 동일한 테이블을 다시 열 것입니다.</target>
        </trans-unit>
        <trans-unit id="b00a667a760d339b93dad1b03b5b7f4819103702" translate="yes" xml:space="preserve">
          <source>Instructions 11 through 18 implement a loop over all index records with the key that was fetched by instruction 8. All of the index records with this key will be contiguous in the index table, so we walk through them and fetch the corresponding table key from the index. This table key is then used to move the cursor to that row in the table. The rest of the loop is the same as the loop for the non-indexed SELECT query.</source>
          <target state="translated">명령어 11부터 18까지는 명령어 8에서 가져온 키를 사용하여 모든 인덱스 레코드에 대해 루프를 구현합니다.이 키가있는 모든 인덱스 레코드는 인덱스 테이블에서 연속적이므로 해당 테이블을 통해 해당 테이블 키를 가져옵니다. 인덱스. 그런 다음이 테이블 키는 커서를 테이블의 해당 행으로 이동하는 데 사용됩니다. 루프의 나머지 부분은 인덱싱되지 않은 SELECT 쿼리의 루프와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="93ad75caff49702ce2412b358044c514b17d458d" translate="yes" xml:space="preserve">
          <source>Instructions 18 through 23 implement a loop over every row of the table being indexed. For each table row, we first extract the integer key for that row using Recno in instruction 19, then get the value of the &quot;two&quot; column using Column in instruction 20. The &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; instruction at 21 converts data from the &quot;two&quot; column (which is on the top of the stack) into a valid index key. For an index on a single column, this is basically a no-op. But if the P1 operand to MakeIdxKey had been greater than one multiple entries would have been popped from the stack and converted into a single index key. The &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt; instruction at 22 is what actually creates the index entry. IdxPut pops two elements from the stack. The top of the stack is used as a key to fetch an entry from the index table. Then the integer which was second on stack is added to the set of integers for that index and the new record is written back to the database file. Note that the same index entry can store multiple integers if there are two or more table entries with the same value for the two column.</source>
          <target state="translated">인스트럭션 18 내지 23은 인덱스되는 테이블의 모든 행에 루프를 구현한다. 각 테이블 행에 대해 먼저 명령 19의 Recno를 사용하여 해당 행의 정수 키를 추출한 다음 명령 20의 열을 사용하여 &quot;2&quot;열의 값을 가져옵니다. 21 의 &lt;a href=&quot;opcode#MakeIdxKey&quot;&gt;MakeIdxKey&lt;/a&gt; 명령은 &quot;2&quot;열의 데이터를 변환합니다 ( 유효한 인덱스 키로) 단일 열의 인덱스의 경우 기본적으로 no-op입니다. 그러나 MakeIdxKey에 대한 P1 피연산자가 하나보다 크면 여러 항목이 스택에서 팝되어 단일 인덱스 키로 변환되었을 것입니다. &lt;a href=&quot;opcode#IdxPut&quot;&gt;IdxPut&lt;/a&gt;22의 지시는 실제로 색인 항목을 작성하는 것입니다. IdxPut은 스택에서 두 요소를 팝합니다. 스택의 맨 위는 인덱스 테이블에서 항목을 가져 오기위한 키로 사용됩니다. 그런 다음 스택의 두 번째 정수는 해당 인덱스의 정수 세트에 추가되고 새 레코드는 데이터베이스 파일에 다시 기록됩니다. 두 열에 대해 동일한 값을 가진 두 개 이상의 테이블 항목이있는 경우 동일한 인덱스 항목이 여러 정수를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d073fd93c649c9cf841978f9cb4f52abf67079a9" translate="yes" xml:space="preserve">
          <source>Instructions 19 through 25 construct a new database record that will be used to replace the existing record. This is the same kind of code that we saw in the description of INSERT and will not be described further. After instruction 25 executes, the stack looks like this:</source>
          <target state="translated">명령어 19 ~ 25는 기존 레코드를 대체하는 데 사용할 새 데이터베이스 레코드를 구성합니다. 이것은 우리가 INSERT의 설명에서 보았던 것과 같은 종류의 코드이며 더 이상 설명하지 않을 것입니다. 명령어 25가 실행 된 후 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="560e44647be24d5aca941bd1314e718abb8f4a57" translate="yes" xml:space="preserve">
          <source>Instructions 2 and 3 open a read cursor on the database table that is to be queried. This works the same as the OpenWrite instruction in the INSERT example except that the cursor is opened for reading this time instead of for writing. Instruction 4 verifies the database schema as in the INSERT example.</source>
          <target state="translated">명령어 2와 3은 쿼리 할 데이터베이스 테이블에서 읽기 커서를 엽니 다. 이것은 커서가 쓰기 대신이 시간 읽기 위해 열린다는 점을 제외하고 INSERT 예제의 OpenWrite 명령어와 동일하게 작동합니다. 명령어 4는 INSERT 예제에서와 같이 데이터베이스 스키마를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="fca2a6be701ffa87d686ce081ffdb761ec90891d" translate="yes" xml:space="preserve">
          <source>Instructions for compiling for Android are &lt;a href=&quot;#compile-android&quot;&gt;shown below&lt;/a&gt;.</source>
          <target state="translated">Android 컴파일 지침은 &lt;a href=&quot;#compile-android&quot;&gt;다음과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="180fcbe698d0f2c44101a06215c472930bbd0a01" translate="yes" xml:space="preserve">
          <source>Int64</source>
          <target state="translated">Int64</target>
        </trans-unit>
        <trans-unit id="8245fcad9e0056a0d272c8564c605d1f5607526e" translate="yes" xml:space="preserve">
          <source>IntCopy</source>
          <target state="translated">IntCopy</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="d591fd91d02ea91f2fb6bfc98baa68985aa1c55d" translate="yes" xml:space="preserve">
          <source>Integer arithmetic operations that would have resulted in overflow are now performed using floating-point instead.</source>
          <target state="translated">오버플로를 초래 한 정수 산술 연산은 이제 부동 소수점을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a45ac87a27eab6aa76ce2b5c611f2a64d3669419" translate="yes" xml:space="preserve">
          <source>Integer values stored as part of segment b-tree nodes are encoded using the FTS varint format. This encoding is similar, but &lt;b&gt;not identical&lt;/b&gt;, to the &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite varint format&lt;/a&gt;.</source>
          <target state="translated">세그먼트 b- 트리 노드의 일부로 저장된 정수 값은 FTS varint 형식을 사용하여 인코딩됩니다. 이 인코딩은 유사한되지만 &lt;b&gt;동일하지 않은&lt;/b&gt; 사람, &lt;a href=&quot;fileformat#varint_format&quot;&gt;SQLite는 varint 포맷&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60896296e2cc4f360fd103b1acf3b75080d48243" translate="yes" xml:space="preserve">
          <source>Integrity of the freelist</source>
          <target state="translated">자유 목록의 무결성</target>
        </trans-unit>
        <trans-unit id="e5d27de0bdb200a7cf8d08a229aa8daa78f0e8ef" translate="yes" xml:space="preserve">
          <source>IntegrityCk</source>
          <target state="translated">IntegrityCk</target>
        </trans-unit>
        <trans-unit id="825d7872ab454dde0951d75f4e8c3836556b73f2" translate="yes" xml:space="preserve">
          <source>Intended Use Of This Memory Slot</source>
          <target state="translated">이 메모리 슬롯의 의도 된 사용</target>
        </trans-unit>
        <trans-unit id="bad6e55f508278bbd1f2de2f51b2cfa41d861db7" translate="yes" xml:space="preserve">
          <source>Interbase</source>
          <target state="translated">Interbase</target>
        </trans-unit>
        <trans-unit id="7b4db7ef1fa23cfb5e115a2a2c89d46a6a2ebc4a" translate="yes" xml:space="preserve">
          <source>Interface</source>
          <target state="translated">Interface</target>
        </trans-unit>
        <trans-unit id="5fe5b201b27c997051ff6e5d94d0bbfdf6211714" translate="yes" xml:space="preserve">
          <source>Interior pages of table b-trees have no payload and so there is never any payload to spill.</source>
          <target state="translated">테이블 b- 트리의 내부 페이지에는 페이로드가 없으므로 엎질러 질 페이로드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc9225a1693f44637be7aea70d7fcc2c5840704d" translate="yes" xml:space="preserve">
          <source>Internal</source>
          <target state="translated">Internal</target>
        </trans-unit>
        <trans-unit id="2e2e38ed2987465eebf4fce7929c514aa147e99c" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs</source>
          <target state="translated">내부 대 외부 BLOB</target>
        </trans-unit>
        <trans-unit id="8f5ed2d53487fd119b9560f28f441dc6f596f2d9" translate="yes" xml:space="preserve">
          <source>Internal Versus External BLOBs in SQLite</source>
          <target state="translated">SQLite의 내부 대 외부 BLOB</target>
        </trans-unit>
        <trans-unit id="e76edc7c42bb9553424aeb43d13659b70db42f10" translate="yes" xml:space="preserve">
          <source>Internal schema objects used by SQLite may include the following:</source>
          <target state="translated">SQLite가 사용하는 내부 스키마 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f7a3c018025e7b8852ebedd2735d4dc85161ed87" translate="yes" xml:space="preserve">
          <source>Internal table</source>
          <target state="translated">내부 테이블</target>
        </trans-unit>
        <trans-unit id="43a9dae252aed092af4315626ccea64ecf3ea367" translate="yes" xml:space="preserve">
          <source>Internally, Geopoly stores polygons in a binary format - an SQL BLOB. Details of the binary format are given below. All of the Geopoly interfaces are able to accept polygons in either the GeoJSON format or in the binary format.</source>
          <target state="translated">내부적으로 Geopoly는 다각형을 이진 형식 (SQL BLOB)으로 저장합니다. 이진 형식의 세부 사항은 다음과 같습니다. 모든 Geopoly 인터페이스는 GeoJSON 형식 또는 이진 형식의 다각형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e37c3aeef00d8b7d2ca4c1560bedb3798f4927" translate="yes" xml:space="preserve">
          <source>Internationalization of the TRIM() function. Ticket #2323</source>
          <target state="translated">TRIM () 함수의 국제화 티켓 # 2323</target>
        </trans-unit>
        <trans-unit id="888710a95af8568e1d72613950e6141b6fd4f17f" translate="yes" xml:space="preserve">
          <source>Interpret the byte at offset X into the page as an 8-bit unsigned integer and add the value of that integer to the checksum.</source>
          <target state="translated">오프셋 X의 바이트를 페이지의 8 비트 부호없는 정수로 해석하고 해당 정수 값을 체크섬에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0a6e9fc795cd5f992a07708fafc38d37296f0f2e" translate="yes" xml:space="preserve">
          <source>Interpret the content of register P1 as an integer. Store the ones-complement of the P1 value into register P2. If P1 holds a NULL then store a NULL in P2.</source>
          <target state="translated">레지스터 P1의 내용을 정수로 해석하십시오. P1 값의 보수를 레지스터 P2에 저장하십시오. P1에 NULL이 있으면 P2에 NULL을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="5e8db10d44914bca3da452a09d9353f35541c4d5" translate="yes" xml:space="preserve">
          <source>Interpret the data that cursor P1 points to as a structure built using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction. (See the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode for additional information about the format of the data.) Extract the P2-th column from this record. If there are less that (P2+1) values in the record, extract a NULL.</source>
          <target state="translated">커서 P1이 가리키는 데이터를 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령을 사용하여 작성된 구조로 해석하십시오 . 데이터 형식에 대한 추가 정보 는 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; opcode를 참조하십시오 .이 레코드에서 P2 번째 열을 추출하십시오. 레코드에 그보다 적은 (P2 + 1) 값이 있으면 NULL을 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="2f79feeee233aec484084c713d84bf8b19e18fec" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store that boolean (a 0 or 1) in register P2. Or if the value in register P1 is NULL, then the P3 is stored in register P2. Invert the answer if P4 is 1.</source>
          <target state="translated">레지스터 P1의 값을 부울 값으로 해석하십시오. 해당 부울 (0 또는 1)을 레지스터 P2에 저장하십시오. 또는 레지스터 P1의 값이 NULL이면 P3이 레지스터 P2에 저장됩니다. P4가 1이면 답을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="11ded0e7491f472be93758e1becf6a72788c6084" translate="yes" xml:space="preserve">
          <source>Interpret the value in register P1 as a boolean value. Store the boolean complement in register P2. If the value in register P1 is NULL, then a NULL is stored in P2.</source>
          <target state="translated">레지스터 P1의 값을 부울 값으로 해석하십시오. 부울 보수를 레지스터 P2에 저장하십시오. 레지스터 P1의 값이 NULL이면 NULL이 P2에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="15470fd033e12b800743519c6e594f7da0f4f0f0" translate="yes" xml:space="preserve">
          <source>Interpretation</source>
          <target state="translated">Interpretation</target>
        </trans-unit>
        <trans-unit id="1215cbe2c98ef14d7aa50ec46f17432a95774205" translate="yes" xml:space="preserve">
          <source>Interrupt A Long-Running Query</source>
          <target state="translated">장기 실행 쿼리 중단</target>
        </trans-unit>
        <trans-unit id="5c1dd154209c449e02a41fa43190c4baa16c350d" translate="yes" xml:space="preserve">
          <source>Introduce extended error codes and add error codes for various kinds of I/O errors.</source>
          <target state="translated">확장 오류 코드를 소개하고 다양한 종류의 I / O 오류에 대한 오류 코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="99fc2e9eb55cb6b8a4a8e79d3fb3b2c33516ae12" translate="yes" xml:space="preserve">
          <source>Introspect the disk content of an SQLite database file (the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;)</source>
          <target state="translated">SQLite 데이터베이스 파일 ( &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블&lt;/a&gt; ) 의 디스크 내용을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="eca078956e48bad9ba22213be258664ddfba5fe3" translate="yes" xml:space="preserve">
          <source>Intuitively, we humans understand that algorithm-1 is best. Each check-in is likely to have few children (one child is the most common case) and each child can be tested for the $trunk tag in logarithmic time. Indeed, algorithm-1 is the faster choice in practice. But the NGQP has no intuition. The NGQP must use hard math, and algorithm-2 is slightly better mathematically. This is because, in the absence of other information, the NGQP must assume that the indexes PLINK_I1 and TAGXREF_I1 are of equal quality and are equally selective. Algorithm-2 uses one field of the TAGXREF_I1 index and both fields of the PLINK_I1 index whereas algorithm-1 only uses the first field of each index. Since algorithm-2 uses more index material, the NGQP is correct to judge it to be the better algorithm. The scores are close and algorithm-2 just barely squeaks ahead of algorithm-1. But algorithm-2 really is the correct choice here.</source>
          <target state="translated">직관적으로, 우리 인간은 알고리즘 -1이 가장 좋다는 것을 이해합니다. 각 체크인에는 자녀가 거의 없을 것이며 (한 자녀가 가장 흔한 경우) 각 자녀는 로그 시간에 $ trunk 태그를 테스트 할 수 있습니다. 실제로 알고리즘 1이 실제로 가장 빠른 선택입니다. 그러나 NGQP는 직관이 없습니다. NGQP는 하드 수학을 사용해야하며 알고리즘 -2는 수학적으로 약간 더 좋습니다. 다른 정보가 없으면 NGQP는 인덱스 PLINK_I1 및 TAGXREF_I1의 품질이 동일하고 선택적으로 동일하다고 가정해야하기 때문입니다. 알고리즘 -2는 TAGXREF_I1 인덱스의 한 필드와 PLINK_I1 인덱스의 두 필드를 사용하지만 algorithm-1은 각 인덱스의 첫 번째 필드 만 사용합니다. 알고리즘 -2는 더 많은 색인 자료를 사용하므로 NGQP는이를 더 나은 알고리즘으로 판단합니다.점수는 가깝고 알고리즘 2는 알고리즘 1보다 거의 삐걱 거리지 않습니다. 그러나 알고리즘 -2가 실제로 올바른 선택입니다.</target>
        </trans-unit>
        <trans-unit id="b761791d82a982a68e59a508cac1ee842272cd79" translate="yes" xml:space="preserve">
          <source>Invert A Changeset</source>
          <target state="translated">변경 세트 반전</target>
        </trans-unit>
        <trans-unit id="e32caad6eec08f7fecc6a1b58616c917f68be530" translate="yes" xml:space="preserve">
          <source>Invert the changeset before applying it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">적용하기 전에 변경 세트를 뒤집습니다. 이는 sqlite3changeset_invert ()를 사용하여 변경 세트를 적용하기 전에 반전시키는 것과 같습니다. 패치 세트로이 플래그를 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="78ac8e24cc6e1af906f6d84df224cae4a5dbdc9c" translate="yes" xml:space="preserve">
          <source>Invert the changeset while iterating through it. This is equivalent to inverting a changeset using sqlite3changeset_invert() before applying it. It is an error to specify this flag with a patchset.</source>
          <target state="translated">반복하면서 체인지 셋을 뒤집습니다. 이는 sqlite3changeset_invert ()를 사용하여 변경 세트를 적용하기 전에 반전시키는 것과 같습니다. 패치 세트로이 플래그를 지정하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="7bcd843ccbf3ca2b0a46090c9286f7cf70d294d4" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened.</source>
          <target state="translated">각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 열리 자마자 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; , 0,0)를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="ebc598ee05cff833de713e00e614680a147ad7e5" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt;,0,0) on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; as soon as it is opened. This prevents application-defined functions from being used in places where an attacker might be able to surreptiously invoke them by modifying a database schema:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f705eccb3bd6ee22f3941d7379adda7f2017d82" translate="yes" xml:space="preserve">
          <source>Invoke &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; on the database connection handle associated with the supplied statement handle to register for an unlock-notify callback. If the call to unlock_notify() returns SQLITE_LOCKED, then return this value to the caller.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 호출제공된 명령문 핸들과 연관된 데이터베이스 연결 핸들에서 를 하여 잠금 해제 알림 콜백에 등록하십시오. unlock_notify () 호출이 SQLITE_LOCKED를 리턴하면이 값을 호출자에게 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="7c709a0509002cbc5917883c970a9481452275c1" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to a FuncDef object that defines the function) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">레지스터 P2 및 후속 장치에서 가져온 P5 인수를 사용하여 사용자 함수 (P4는 함수를 정의하는 FuncDef 객체에 대한 포인터)를 호출합니다. 기능의 결과는 레지스터 P3에 저장됩니다. 레지스터 P3은 기능 입력 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="d5afe87b60965605a9297c781c01328e7ab18fc9" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with P5 arguments taken from register P2 and successors. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">레지스터 P2 및 후속 장치에서 가져온 P5 인수를 사용하여 사용자 함수 (P4는 실행할 함수에 대한 포인터를 포함하는 sqlite3_context 객체에 대한 포인터)를 호출합니다. 기능의 결과는 레지스터 P3에 저장됩니다. 레지스터 P3은 기능 입력 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="bf8b8c1d4d822ee5f5035e452152155ef6c1caa7" translate="yes" xml:space="preserve">
          <source>Invoke a user function (P4 is a pointer to an sqlite3_context object that contains a pointer to the function to be run) with arguments taken from register P2 and successors. The number of arguments is in the sqlite3_context object that P4 points to. The result of the function is stored in register P3. Register P3 must not be one of the function inputs.</source>
          <target state="translated">레지스터 P2 및 후속 작업에서 가져온 인수를 사용하여 사용자 함수 (P4는 실행할 함수에 대한 포인터를 포함하는 sqlite3_context 개체에 대한 포인터)를 호출합니다. 인수의 수는 P4가 가리키는 sqlite3_context 객체에 있습니다. 함수의 결과는 레지스터 P3에 저장됩니다. 레지스터 P3는 함수 입력 중 하나가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="ec3125db909dbad56a3a25ad8b3535b576369321" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command once with the parameter set to -N, then</source>
          <target state="translated">매개 변수를 -N으로 설정하고 'merge'명령을 한 번 호출 한 다음</target>
        </trans-unit>
        <trans-unit id="7dd177608c23145959faf29e93b347c2a9c95d8f" translate="yes" xml:space="preserve">
          <source>Invoke the 'merge' command zero or more times with the parameter set to N.</source>
          <target state="translated">매개 변수를 N으로 설정하여 'merge'명령을 0 번 이상 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="66ccce8dbed894fb937993244705085ff4d8803a" translate="yes" xml:space="preserve">
          <source>Invoke the callback function for the current row of the result.</source>
          <target state="translated">결과의 현재 행에 대한 콜백 함수를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="125398c8d0ddcbf991b86f4ee6d99da4c12cf932" translate="yes" xml:space="preserve">
          <source>Invoke the sqlite3rbu_step(X) function one or more times on the sqlite3rbu object pointer X. Each call to sqlite3rbu_step() performs a single b-tree operation, so thousands of calls may be required to apply a complete update. The sqlite3rbu_step() interface will return SQLITE_DONE when the update has been completely applied.</source>
          <target state="translated">sqlite3rbu 객체 포인터 X에서 sqlite3rbu_step (X) 함수를 한 번 이상 호출하십시오. sqlite3rbu_step ()에 대한 각 호출은 단일 b- 트리 작업을 수행하므로 완전한 업데이트를 적용하려면 수천 번의 호출이 필요할 수 있습니다. 업데이트가 완전히 적용되면 sqlite3rbu_step () 인터페이스는 SQLITE_DONE을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="09ac0f478fa9c31ebe084063003a8993cc83456c" translate="yes" xml:space="preserve">
          <source>Invoke the xValue() function and store the result in register P3.</source>
          <target state="translated">xValue () 함수를 호출하고 결과를 레지스터 P3에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="ec2b47e7de90dfad0a6211ad1cb07982eafe0cde" translate="yes" xml:space="preserve">
          <source>Invoking sqlite3_finalize() on a NULL pointer is a harmless no-op.</source>
          <target state="translated">NULL 포인터에서 sqlite3_finalize ()를 호출하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="bd8202d31b1a7640473e2e12fd946892b1ec4008" translate="yes" xml:space="preserve">
          <source>Invoking this pragma with an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; C interface with a &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;3rd parameter&lt;/a&gt; corresponding to the argument:</source>
          <target state="translated">인수로이 pragma를 호출하는 것은 인수에 해당 하는 &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;세 번째 매개 변수로 &lt;/a&gt;&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; C 인터페이스 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5f0e3d2a93c21482714b0b7a93ae0ad2d3dfb1f3" translate="yes" xml:space="preserve">
          <source>Invoking this pragma without an argument is equivalent to calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface.</source>
          <target state="translated">인수없이이 pragma를 호출하는 것은 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C 인터페이스 를 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8cedb7aa520fd9ec8eb114043f05f6f9d17e93dd" translate="yes" xml:space="preserve">
          <source>Is SQLite threadsafe?</source>
          <target state="translated">SQLite는 안전합니까?</target>
        </trans-unit>
        <trans-unit id="d993744fe6f739c6aa4d5f6de34d342868d7e529" translate="yes" xml:space="preserve">
          <source>Is replaced by:</source>
          <target state="translated">다음으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="accaed01010f56d422eef5c33bfb4384f7eeeed3" translate="yes" xml:space="preserve">
          <source>IsNull</source>
          <target state="translated">IsNull</target>
        </trans-unit>
        <trans-unit id="a0830278e8f462114ebf33a9e4e362b34c86b01d" translate="yes" xml:space="preserve">
          <source>IsTrue</source>
          <target state="translated">IsTrue</target>
        </trans-unit>
        <trans-unit id="3dea5e42ca2754f9e6823ecfc4f51c71cf05676a" translate="yes" xml:space="preserve">
          <source>Isolation And Concurrency</source>
          <target state="translated">격리와 동시성</target>
        </trans-unit>
        <trans-unit id="6a3e64b57124b4061c4f707d69ad242f0d0e0ef1" translate="yes" xml:space="preserve">
          <source>Isolation Between Database Connections</source>
          <target state="translated">데이터베이스 연결 간 격리</target>
        </trans-unit>
        <trans-unit id="e3488e8cb34f4c736ddb072c649ba2a6c79489e5" translate="yes" xml:space="preserve">
          <source>Isolation In SQLite</source>
          <target state="translated">SQLite에서 격리</target>
        </trans-unit>
        <trans-unit id="2dfabf57c5175b858eac45130bf0b51df7502b3e" translate="yes" xml:space="preserve">
          <source>Issue an &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX&lt;/a&gt; warning on the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; whenever the query planner uses an automatic index.</source>
          <target state="translated">문제 &lt;a href=&quot;rescode#warning_autoindex&quot;&gt;SQLITE_WARNING_AUTOINDEX의&lt;/a&gt; 온 경고 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG를&lt;/a&gt; 쿼리 플래너가 자동으로 인덱스를 사용 할 때마다.</target>
        </trans-unit>
        <trans-unit id="ffb450eea3632a82507d6bc65c2b7d60604799db" translate="yes" xml:space="preserve">
          <source>Issue an SQLITE_WARNING message on the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴&lt;/a&gt; 을 사용 하는 경우 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에서 SQLITE_WARNING 메시지를 발행하십시오 .</target>
        </trans-unit>
        <trans-unit id="887bf7a7997457d1a84b4ef3887a47fd35509c6e" translate="yes" xml:space="preserve">
          <source>Issue an error rather instead of an assertion-fault or null-pointer dereference when the sqlite_master table is corrupted so that the sqlite_sequence table root page is really a btree-index page. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</source>
          <target state="translated">sqlite_master 테이블이 손상되어 sqlite_sequence 테이블 루트 페이지가 실제로 btree-index 페이지가되도록 어설 션 오류 또는 널 포인터 역 참조 대신 오류를 발행하십시오. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/525deb7a67fbd647&quot;&gt;525deb7a67fbd647&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="265877cc565c8d7a6873f0a63d90a0fdd348de2c" translate="yes" xml:space="preserve">
          <source>It an error if database zFrom does not exist or does not contain the required compatible table.</source>
          <target state="translated">데이터베이스 zFrom이 존재하지 않거나 필수 호환 테이블이 포함되어 있지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0e154e176231a0aafc6a2d79aba315f0be81a2c2" translate="yes" xml:space="preserve">
          <source>It cannot be used to copy data to or from in-memory databases.</source>
          <target state="translated">인 메모리 데이터베이스와 데이터를 복사하는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6fd3c51616175d12c8323af133471dff22943ef2" translate="yes" xml:space="preserve">
          <source>It could handle a special case of SQLITE_LOCKED that can occur when dropping a table or index.</source>
          <target state="translated">테이블이나 인덱스를 삭제할 때 발생할 수있는 SQLITE_LOCKED의 특수한 경우를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="186b030c86f45f0c84d4dba2b997ab209083ef94" translate="yes" xml:space="preserve">
          <source>It could manage thread priorities.</source>
          <target state="translated">스레드 우선 순위를 관리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="46b90c15208f2a0e159c21cdb03813412db842c6" translate="yes" xml:space="preserve">
          <source>It exists, and</source>
          <target state="translated">존재하고</target>
        </trans-unit>
        <trans-unit id="40ecc5a776918cb0ff3984e5d8619d213f6f930d" translate="yes" xml:space="preserve">
          <source>It is a good idea to establish a convention for determining the RBU vacuum state database name based on the target database name. The example code below uses &quot;&amp;lt;target&amp;gt;-vacuum&quot;, where &amp;lt;target&amp;gt; is the name of the database being vacuumed.</source>
          <target state="translated">대상 데이터베이스 이름을 기반으로 RBU 진공 상태 데이터베이스 이름을 결정하기위한 규칙을 설정하는 것이 좋습니다. 아래의 예제 코드는 &quot;&amp;lt;target&amp;gt; -vacuum&quot;을 사용합니다. 여기서 &amp;lt;target&amp;gt;은 정리할 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bc2605e225f0c06786d4d6602b4aa9c521bcd8db" translate="yes" xml:space="preserve">
          <source>It is acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine before &lt;b&gt;sqlite_step&lt;/b&gt; has returned SQLITE_DONE. Doing so has the effect of interrupting the operation in progress. Partially completed changes will be rolled back and the database will be restored to its original state (unless an alternative recovery algorithm is selected using an ON CONFLICT clause in the SQL being executed.) The effect is the same as if a callback function of &lt;b&gt;sqlite_exec&lt;/b&gt; had returned non-zero.</source>
          <target state="translated">&lt;b&gt;sqlite_step&lt;/b&gt; 이 SQLITE_DONE을 리턴 하기 전에 가상 머신에서 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출 할 수 있습니다. 그렇게하면 진행중인 작업이 중단됩니다. 실행중인 SQL에서 ON CONFLICT 절을 사용하여 대체 복구 알고리즘을 선택하지 않는 한 부분적으로 완료된 변경 사항이 롤백되고 데이터베이스가 원래 상태로 복원됩니다. &lt;b&gt;sqlite_exec&lt;/b&gt; 의 콜백 함수 가 0이 아닌 값을 반환했습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="9b1cdd52a287f4e7becc07615494854f9dea1062" translate="yes" xml:space="preserve">
          <source>It is also acceptable to call &lt;b&gt;sqlite_finalize&lt;/b&gt; on a virtual machine that has never been passed to &lt;b&gt;sqlite_step&lt;/b&gt; even once.</source>
          <target state="translated">&lt;b&gt;sqlite_step에&lt;/b&gt; 한 번도 전달되지 않은 가상 머신에서 &lt;b&gt;sqlite_finalize&lt;/b&gt; 를 호출하는 것도 가능합니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8524404ce2a2650e2fd11b49dcd571c2f2744c61" translate="yes" xml:space="preserve">
          <source>It is also possible to create custom tokenizers for FTS5. The API for doing so is &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">FTS5 용 맞춤형 토크 나이저를 생성 할 수도 있습니다. 이를위한 API &lt;a href=&quot;fts5#custom_tokenizers&quot;&gt;는 여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af4ea7504b8858e61227bf5cbac3c869a2ebb0cf" translate="yes" xml:space="preserve">
          <source>It is also possible to customize the set of codepoints that unicode61 treats as separator characters. The &quot;separators=&quot; option may be used to specify one or more extra characters that should be treated as separator characters, and the &quot;tokenchars=&quot; option may be used to specify one or more extra characters that should be treated as part of tokens instead of as separator characters. For example:</source>
          <target state="translated">유니 코드 61이 구분 문자로 취급하는 코드 포인트 세트를 사용자 정의 할 수도 있습니다. &quot;separators =&quot;옵션은 분리 문자로 취급되어야하는 하나 이상의 추가 문자를 지정하는 데 사용될 수 있으며 &quot;tokenchars =&quot;옵션은 대신 토큰의 일부로 처리되어야하는 하나 이상의 추가 문자를 지정하는 데 사용될 수 있습니다. 구분 문자로. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5f2716f625be713954d4be305f323e2da4e7532" translate="yes" xml:space="preserve">
          <source>It is also possible to express this kind of simultaneous read and write on an R-Tree within a single query, for example if an UPDATE statement tries to change the value of one row of the R-Tree based on a complicated query from another row of the same R-Tree, perhaps something like this:</source>
          <target state="translated">예를 들어, UPDATE 문이 다른 행의 복잡한 쿼리를 기반으로 R- 트리의 한 행 값을 변경하려고하는 경우와 같이 단일 쿼리 내에서 R- 트리에서 이러한 종류의 동시 읽기 및 쓰기를 표현할 수도 있습니다. 동일한 R- 트리의 아마도 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="756b3fcc2f7b6b94c8632586f6c6ecc720cec025" translate="yes" xml:space="preserve">
          <source>It is an error to add types, constraints or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; declarations to a CREATE VIRTUAL TABLE statement used to create an FTS5 table. Once created, an FTS5 table may be populated using &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements like any other table. Like any other table with no PRIMARY KEY declaration, an FTS5 table has an implicit INTEGER PRIMARY KEY field named rowid.</source>
          <target state="translated">FTS5 테이블을 작성하는 데 사용 된 CREATE VIRTUAL TABLE 문 에 유형, 제한 조건 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; 선언 을 추가하는 것은 오류 입니다. FTS5 테이블을 만든 후에는 다른 테이블과 마찬가지로 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문을 사용하여 채울 수 있습니다 . PRIMARY KEY 선언이없는 다른 테이블과 마찬가지로 FTS5 테이블에는 rowid라는 암시 적 INTEGER PRIMARY KEY 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="444eee32669789fe15a56475160491d70e6d7f57" translate="yes" xml:space="preserve">
          <source>It is an error to attempt to set the sz or rawdata field to any value other than NULL.</source>
          <target state="translated">sz 또는 rawdata 필드를 NULL 이외의 다른 값으로 설정하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="24bfd3e9a865c193cff416ba8b58e38e3815e72c" translate="yes" xml:space="preserve">
          <source>It is an error to set the columnsize option to any value other than 0 or 1.</source>
          <target state="translated">columnsize 옵션을 0 또는 1 이외의 값으로 설정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b8e09fbd7b220da38b0f56a632afa06ded1cc2" translate="yes" xml:space="preserve">
          <source>It is an error to specify the FTS5_TOKEN_COLOCATED flag the first time xToken() is called. Multiple synonyms may be specified for a single token by making multiple calls to xToken(FTS5_TOKEN_COLOCATED) in sequence. There is no limit to the number of synonyms that may be provided for a single token.</source>
          <target state="translated">xToken ()을 처음 호출 할 때 FTS5_TOKEN_COLOCATED 플래그를 지정하면 오류가 발생합니다. xToken (FTS5_TOKEN_COLOCATED)을 여러 번 호출하여 단일 토큰에 대해 여러 동의어를 지정할 수 있습니다. 단일 토큰에 제공 될 수있는 동의어의 수에는 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8a103b729e696566ddb48fa0100f23ca6a9cb4a" translate="yes" xml:space="preserve">
          <source>It is assumed that the cursor is used only for appending and so if the cursor is valid, then the cursor must already be pointing at the end of the btree and so no changes are made to the cursor.</source>
          <target state="translated">커서는 추가 용도로만 사용되므로 커서가 유효하면 커서가 이미 btree의 끝을 가리키고 있어야하므로 커서가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="28727e9350bc13e9dd557e61676acaf81b800e9f" translate="yes" xml:space="preserve">
          <source>It is assumed that writing a series of sequential blocks of data to a file in order is faster than writing the same blocks in an arbitrary order.</source>
          <target state="translated">일련의 순차적 데이터 블록을 파일에 순서대로 쓰는 것이 동일한 블록을 임의의 순서로 쓰는 것보다 빠르다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b7995ee897a4d7d38d5bc734c7b7a1490089b50f" translate="yes" xml:space="preserve">
          <source>It is common for an application to invoke sqlite3_create_function() multiple times for the same SQL function. For example, if an SQL function can take either 2 or 3 arguments, then sqlite3_create_function() would be invoked once for the 2-argument version and a second time for the 3-argument version. The underlying implementation (the callbacks) can be different for both variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90995e42fb1f9b39bc19b92ec7c0b1c1c734e41d" translate="yes" xml:space="preserve">
          <source>It is created using a call to sqlite3changegroup_new().</source>
          <target state="translated">sqlite3changegroup_new ()에 대한 호출을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="4e7aaf577a2ee286bdd21a85c82980a7edeb975b" translate="yes" xml:space="preserve">
          <source>It is difficult to update individual entries in a ZIP archive. It is especially difficult to update individual entries in a ZIP archive in a way that does not destroy the entire document if the computer loses power and/or crashes in the middle of the update. It is not impossible to do this, but it is sufficiently difficult that nobody actually does it. Instead, whenever the user selects &quot;File/Save&quot;, the entire ZIP archive is rewritten. Hence, &quot;File/Save&quot; takes longer than it ought, especially on older hardware. Newer machines are faster, but it is still bothersome that changing a single character in a 50 megabyte presentation causes one to burn through 50 megabytes of the finite write life on the SSD.</source>
          <target state="translated">ZIP 아카이브에서 개별 항목을 업데이트하는 것은 어렵습니다. 업데이트 도중 컴퓨터 전원이 꺼 지거나 충돌하는 경우 전체 문서를 손상시키지 않는 방식으로 ZIP 아카이브의 개별 항목을 업데이트하는 것이 특히 어렵습니다. 이 작업을 수행하는 것은 불가능하지 않지만 실제로는 아무도 그렇게하기가 충분히 어렵습니다. 대신 사용자가 &quot;파일 / 저장&quot;을 선택할 때마다 전체 ZIP 아카이브가 다시 작성됩니다. 따라서 &quot;파일 / 저장&quot;은 특히 오래된 하드웨어의 경우보다 오래 걸립니다. 최신 머신은 더 빠르지 만, 50MB 프레젠테이션에서 단일 문자를 변경하면 SSD에서 50MB의 유한 쓰기 수명이 발생하는 것이 여전히 귀찮습니다.</target>
        </trans-unit>
        <trans-unit id="5567ffe2a8c6dd00685158eaaf03eb7345f63a44" translate="yes" xml:space="preserve">
          <source>It is illegal for P1 and P3 to be the same register. Sometimes, if P3 is the same register as P2, the implementation is able to avoid a memcpy().</source>
          <target state="translated">P1과 P3이 동일한 레지스터 인 것은 불법입니다. P3가 P2와 동일한 레지스터 인 경우 구현시 memcpy ()를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08adbd91885a13f3de038527a6e47107fedd5af" translate="yes" xml:space="preserve">
          <source>It is important that all connections to the same database file use the same locking protocol. If one application is using POSIX advisory locks and another application is using dot-file locking, then the two applications will not see each other's locks and will not be able to coordinate database access, possibly leading to database corruption.</source>
          <target state="translated">동일한 데이터베이스 파일에 대한 모든 연결은 동일한 잠금 프로토콜을 사용해야합니다. 한 응용 프로그램이 POSIX 권고 잠금을 사용하고 다른 응용 프로그램이 도트 파일 잠금을 사용하는 경우 두 응용 프로그램은 서로의 잠금을 볼 수 없으며 데이터베이스 액세스를 조정할 수 없으므로 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c1111b9c3326c8dd11b23932594b685a7b1d3f7" translate="yes" xml:space="preserve">
          <source>It is important to note that changing versions of SQLite might cause changes in query plans. The same version of SQLite will always pick the same query plan, but if you relink your application to use a different version of SQLite, then query plans might change. In rare cases, an SQLite version change might lead to a performance regression. This is one reason you should consider statically linking your applications against SQLite rather than use a system-wide SQLite shared library which might change without your knowledge or control.</source>
          <target state="translated">SQLite 버전을 변경하면 쿼리 계획이 변경 될 수 있습니다. 동일한 버전의 SQLite는 항상 동일한 쿼리 계획을 선택하지만 다른 버전의 SQLite를 사용하도록 응용 프로그램을 다시 연결하면 쿼리 계획이 변경 될 수 있습니다. 드문 경우이지만 SQLite 버전 변경으로 인해 성능이 저하 될 수 있습니다. 이 때문에 지식이나 제어없이 변경 될 수있는 시스템 전체 SQLite 공유 라이브러리를 사용하는 대신 SQLite에 대해 애플리케이션을 정적으로 링크하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fb1bf740043ac6cffabf7ccc0393c49b8d377d2" translate="yes" xml:space="preserve">
          <source>It is important to realize that neither &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; nor &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; do anything that cannot be accomplished using the core routines. In fact, these wrappers are implemented purely in terms of the core routines.</source>
          <target state="translated">어느 것을 깨닫는 것이 중요하다 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 도 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()가&lt;/a&gt; 핵심 루틴을 사용하여 수행 할 수없는 아무것도. 실제로 이러한 래퍼는 핵심 루틴 측면에서 순전히 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="e6f1d24d369dd36a94bbbfa574744f4d470ce689" translate="yes" xml:space="preserve">
          <source>It is important to store all pages of a sector in the rollback journal in order to prevent database corruption following a power loss while writing the sector. Suppose that pages 1, 2, 3, and 4 are all stored in sector 1 and that page 2 is modified. In order to write the changes to page 2, the underlying hardware must also rewrite the content of pages 1, 3, and 4 since the hardware must write the complete sector. If this write operation is interrupted by a power outage, one or more of the pages 1, 3, or 4 might be left with incorrect data. Hence, to avoid lasting corruption to the database, the original content of all of those pages must be contained in the rollback journal.</source>
          <target state="translated">섹터를 쓰는 동안 전원 손실로 인한 데이터베이스 손상을 방지하려면 섹터의 모든 페이지를 롤백 저널에 저장하는 것이 중요합니다. 페이지 1, 2, 3 및 4가 모두 섹터 1에 저장되고 페이지 2가 수정되었다고 가정하십시오. 변경 사항을 2 페이지에 쓰려면 하드웨어가 전체 섹터를 작성해야하므로 기본 하드웨어도 1, 3, 4 페이지의 내용을 다시 작성해야합니다. 정전으로 인해이 쓰기 작업이 중단되면 1, 3 또는 4 페이지 중 하나 이상에 잘못된 데이터가 남아있을 수 있습니다. 따라서 데이터베이스의 지속적인 손상을 피하기 위해 모든 해당 페이지의 원본 내용을 롤백 저널에 포함시켜야합니다.</target>
        </trans-unit>
        <trans-unit id="128a48935084af31c9e8080ab5a8fbf025139866" translate="yes" xml:space="preserve">
          <source>It is important to understand these two different definitions for &quot;serverless&quot;. When a database claims to be &quot;serverless&quot;, be sure to discern whether they mean &quot;classic serverless&quot; or &quot;neo-serverless&quot;.</source>
          <target state="translated">&quot;서버리스&quot;에 대한이 두 가지 정의를 이해하는 것이 중요합니다. 데이터베이스가 &quot;서버리스&quot;라고 주장 할 때는 데이터베이스가 &quot;클래식 서버리스&quot;인지 &quot;네오 서버리스&quot;인지를 식별해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa9dd62d3bfcaf75e4033204e51b41d31455c6e9" translate="yes" xml:space="preserve">
          <source>It is important to verify that the gcov test run and the second real test run both give the same output. Any differences in output indicate either the use of undefined or indeterminate behavior in the SQLite code (and hence a bug), or a bug in the compiler. Note that SQLite has, over the previous decade, encountered bugs in each of GCC, Clang, and MSVC. Compiler bugs, while rare, do happen, which is why it is so important to test the code in an as-delivered configuration.</source>
          <target state="translated">gcov 테스트 실행과 두 번째 실제 테스트 실행이 모두 동일한 출력을 제공하는지 확인하는 것이 중요합니다. 출력의 차이는 SQLite 코드에서 정의되지 않거나 결정되지 않은 동작 (또는 버그)을 사용하거나 컴파일러의 버그를 나타냅니다. 지난 10 년 동안 SQLite는 각 GCC, Clang 및 MSVC에서 버그를 발견했습니다. 컴파일러 버그는 드물지만 발생하므로 제공된 구성으로 코드를 테스트하는 것이 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="d1cea258b6006ec069fad2e48bb8e0ae1aa954d2" translate="yes" xml:space="preserve">
          <source>It is impossible to test every possible combination of compile-time options for SQLite. But the following set of compile-time options is one configuration that is always fully tested.</source>
          <target state="translated">SQLite에 대해 가능한 모든 컴파일 시간 옵션 조합을 테스트하는 것은 불가능합니다. 그러나 다음 컴파일 타임 옵션 세트는 항상 완전히 테스트 된 구성입니다.</target>
        </trans-unit>
        <trans-unit id="15edf0a6c6c69dc4fe559f59d8b017e98f300472" translate="yes" xml:space="preserve">
          <source>It is impractical to do crash testing using real power failures, of course, and so crash testing is done in simulation. An alternative &lt;a href=&quot;c3ref/vfs&quot;&gt;Virtual File System&lt;/a&gt; is inserted that allows the test harness to simulate the state of the database file following a crash.</source>
          <target state="translated">물론 실제 정전을 사용하여 충돌 테스트를 수행하는 것은 비현실적이므로 충돌 테스트는 시뮬레이션에서 수행됩니다. 테스트 하네스가 충돌 후 데이터베이스 파일의 상태를 시뮬레이션 할 수 있는 대체 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="e1d5ef237a2a6e6403153de4b153927de75448b8" translate="yes" xml:space="preserve">
          <source>It is not an error if the named table does not exist in the database. Nor is it an error if the named table does not have a PRIMARY KEY. However, no changes will be recorded in either of these scenarios.</source>
          <target state="translated">명명 된 테이블이 데이터베이스에없는 경우 오류가 아닙니다. 명명 된 테이블에 PRIMARY KEY가 없으면 오류도 아닙니다. 그러나 이러한 시나리오 중 하나에서 변경 내용이 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d49fdf0ef1b4c639114a4ac63de04efc40c67c48" translate="yes" xml:space="preserve">
          <source>It is not an error to create a table that has the same name as an existing &lt;a href=&quot;lang_createtrigger&quot;&gt;trigger&lt;/a&gt;.</source>
          <target state="translated">기존 &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; 와 이름이 같은 테이블을 작성하는 것은 오류가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="8aaf6c77de556f14a491171c58f28d211cfbc9d4" translate="yes" xml:space="preserve">
          <source>It is not commonly useful to evaluate the &lt;em&gt;exact&lt;/em&gt; same SQL statement more than once. More often, one wants to evaluate similar statements. For example, you might want to evaluate an INSERT statement multiple times with different values. Or you might want to evaluate the same query multiple times using a different key in the WHERE clause. To accommodate this, SQLite allows SQL statements to contain &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; which are &quot;bound&quot; to values prior to being evaluated. These values can later be changed and the same &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; can be evaluated a second time using the new values.</source>
          <target state="translated">평가하는 것이 일반적으로 유용하지 않다 &lt;em&gt;정확한&lt;/em&gt; 번 이상 같은 SQL 문을. 더 자주, 비슷한 진술을 평가하려고합니다. 예를 들어, 다른 값으로 INSERT 문을 여러 번 평가할 수 있습니다. 또는 WHERE 절에서 다른 키를 사용하여 동일한 쿼리를 여러 번 평가할 수 있습니다. 이를 수용하기 위해 SQLite는 SQL 문 이 평가되기 전에 값에 &quot;바운드&quot;된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 를 포함 할 수 있도록합니다 . 이 값은 나중에 변경 될 수 있으며 새로운 값을 사용하여 동일한 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 두 번째로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de5c77745aab508a14fca7f3c047cc5a41b83c4" translate="yes" xml:space="preserve">
          <source>It is not impossible to find the descendents of a check-in in Git. It is merely difficult. For example, there is a &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow page&lt;/a&gt; showing the command sequence for finding the descendents of a check-in in unix:</source>
          <target state="translated">Git에서 체크인의 자손을 찾는 것은 불가능하지 않습니다. 단지 어렵다. 예를 들어, 유닉스에서 체크인의 하위 항목을 찾기위한 명령 순서를 보여주는 &lt;a href=&quot;https://stackoverflow.com/questions/27960605/find-all-the-direct-descendants-of-a-given-commit#27962018&quot;&gt;stackoverflow 페이지&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="968af02ea707c660eea2edbc719717453c1c09b4" translate="yes" xml:space="preserve">
          <source>It is not necessary for every column of an index to appear in a WHERE clause term in order for that index to be used. But there cannot be gaps in the columns of the index that are used. Thus for the example index above, if there is no WHERE clause term that constraints column c, then terms that constrain columns a and b can be used with the index but not terms that constraint columns d through z. Similarly, index columns will not normally be used (for indexing purposes) if they are to the right of a column that is constrained only by inequalities. (See the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; below for the exception.)</source>
          <target state="translated">해당 인덱스를 사용하기 위해 인덱스의 모든 열이 WHERE 절 용어에 나타날 필요는 없습니다. 그러나 사용되는 인덱스 열에는 차이가있을 수 없습니다. 따라서 위의 인덱스 예에서 c 열을 제한하는 WHERE 절 용어가없는 경우 a 열과 b 열을 제한하는 항을 인덱스와 함께 사용할 수 있지만 d-z 열을 제한하는 항은 사용할 수 없습니다. 마찬가지로, 인덱스 열이 부등식으로 만 제한되는 열의 오른쪽에있는 경우 인덱싱 목적으로 일반적으로 사용되지 않습니다. ( 예외는 아래 의 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화를&lt;/a&gt; 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="91c4a366eb8b7036569a617f444657bfe2829b75" translate="yes" xml:space="preserve">
          <source>It is not necessary to delete a session object after extracting a changeset or patchset from it. It can be left attached to the database handle and will continue monitoring for changes on the configured tables as before. However, if &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt; or &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset()&lt;/a&gt; is called a second time on a session object, the changeset or patchset will contain &lt;em&gt;all&lt;/em&gt; changes that have taken place on the connection since the session was created. In other words, a session object is not reset or zeroed by a call to sqlite3session_changeset() or sqlite3session_patchset().</source>
          <target state="translated">세션 세트 또는 패치 세트를 추출한 후 세션 오브젝트를 삭제할 필요는 없습니다. 데이터베이스 핸들에 연결된 채로 둘 수 있으며 이전과 같이 구성된 테이블의 변경 사항을 계속 모니터링합니다. 그러나 세션 객체에서 &lt;a href=&quot;session/sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; 또는 &lt;a href=&quot;session/sqlite3session_patchset&quot;&gt;sqlite3session_patchset ()을&lt;/a&gt; 두 번 호출하면 변경 세트 또는 패치 세트에는 세션이 작성된 이후 연결에서 발생한 &lt;em&gt;모든&lt;/em&gt; 변경 사항 이 포함됩니다 . 즉, sqlite3session_changeset () 또는 sqlite3session_patchset ()에 대한 호출로 세션 객체가 재설정되거나 제로화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="670d42dfe457729d9823abd17b04a227c0f7995a" translate="yes" xml:space="preserve">
          <source>It is not necessary to increment the change counter in the database header for transactions after the first transaction. This will often save a write of page one to both the rollback journal and the main database file.</source>
          <target state="translated">첫 번째 트랜잭션 이후 트랜잭션의 데이터베이스 헤더에서 변경 카운터를 증가시킬 필요는 없습니다. 이것은 종종 페이지 1의 쓰기를 롤백 저널과 기본 데이터베이스 파일 모두에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="2403c6f4220d7ab7621d951d5ca316ce8bb167ec" translate="yes" xml:space="preserve">
          <source>It is not necessary to retrieve data in the format specify by sqlite3_column_type(). If a different format is requested, the data is converted automatically.</source>
          <target state="translated">sqlite3_column_type ()에 의해 지정된 형식으로 데이터를 검색 할 필요는 없습니다. 다른 형식이 요청되면 데이터가 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="900bad887efaa153c1a2b75294545475e3b1d504" translate="yes" xml:space="preserve">
          <source>It is not possible for a single FTS query to return rows with different languageid values. The results of adding WHERE clauses that use other operators (e.g. lid!=5, or lid&amp;lt;=5) are undefined.</source>
          <target state="translated">단일 FTS 쿼리가 다른 languageid 값을 가진 행을 반환 할 수 없습니다. 다른 연산자를 사용하는 WHERE 절을 추가 한 결과 (예 : lid! = 5 또는 lid &amp;lt;= 5)는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0859fe8615c2125c6e219976b0af5affb3b3243b" translate="yes" xml:space="preserve">
          <source>It is not possible to &lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;ALTER TABLE ADD COLUMN&lt;/a&gt; a STORED column. One can add a VIRTUAL column, however.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d7041428ac37cb2fe5a20d78347fe7eb6acfbe1" translate="yes" xml:space="preserve">
          <source>It is not possible to UPDATE or DELETE a row stored in a contentless FTS4 table. Attempting to do so is an error.</source>
          <target state="translated">내용이없는 FTS4 테이블에 저장된 행을 업데이트하거나 삭제하는 것은 불가능합니다. 시도하는 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="9e4665d3e6caf2e43eb0161671eab0b61b62c13a" translate="yes" xml:space="preserve">
          <source>It is not possible to change the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; after entering WAL mode, either on an empty database or by using &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or by restoring from a backup using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;. You must be in a rollback journal mode to change the page size.</source>
          <target state="translated">비어있는 데이터베이스 나 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 사용 하거나 &lt;a href=&quot;backup&quot;&gt;백업 API를&lt;/a&gt; 사용하여 백업 에서 복원 하여 WAL 모드를 시작한 후에 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 를 변경할 수 없습니다 . 페이지 크기를 변경하려면 롤백 저널 모드에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="deaab8f44371f477a4e7e55d31601e0d0d6a03fb" translate="yes" xml:space="preserve">
          <source>It is not possible to enable or disable foreign key constraints in the middle of a &lt;a href=&quot;lang_transaction&quot;&gt;multi-statement transaction&lt;/a&gt; (when SQLite is not in &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;autocommit mode&lt;/a&gt;). Attempting to do so does not return an error; it simply has no effect.</source>
          <target state="translated">&lt;a href=&quot;lang_transaction&quot;&gt;다중 문 트랜잭션 중에&lt;/a&gt; SQLite가 &lt;a href=&quot;c3ref/get_autocommit&quot;&gt;자동 커밋 모드&lt;/a&gt; 가 아닌 경우 외래 키 제약 조건을 활성화하거나 비활성화 할 수 없습니다 . 그렇게하려고해도 오류가 반환되지 않습니다. 단순히 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="59d7023d400b2c4a42c25e47c1d1dae5bdb83625" translate="yes" xml:space="preserve">
          <source>It is not possible to use the &quot;ALTER TABLE ... ADD COLUMN&quot; syntax to add a column that includes a REFERENCES clause, unless the default value of the new column is NULL. Attempting to do so returns an error.</source>
          <target state="translated">새 열의 기본값이 NULL이 아닌 경우 &quot;ALTER TABLE ... ADD COLUMN&quot;구문을 사용하여 REFERENCES 절을 포함하는 열을 추가 할 수 없습니다. 이렇게하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="912f58b54e2d4f955145072d5727d208f46d87cf" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">한 번에 둘 이상의 스레드에서이 변수를 읽거나 수정하는 것은 안전하지 않습니다. &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 별도의 스레드에서 동시에 사용되는 경우이 변수를 읽거나 수정하는 것은 안전하지 않습니다 . 이 변수는 프로세스 초기화의 일부로 한 번 설정되고 SQLite 인터페이스 루틴이 호출되기 전에 설정되며 그 이후에는이 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="903cea61d0db784ec27805bae69d5dea09532edb" translate="yes" xml:space="preserve">
          <source>It is not safe to read or modify this variable in more than one thread at a time. It is not safe to read or modify this variable if a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; is being used at the same time in a separate thread. It is intended that this variable be set once as part of process initialization and before any SQLite interface routines have been called and that this variable remain unchanged thereafter.</source>
          <target state="translated">한 번에 둘 이상의 스레드에서이 변수를 읽거나 수정하는 것은 안전하지 않습니다. &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 별도의 스레드에서 동시에 사용되는 경우이 변수를 읽거나 수정하는 것은 안전하지 않습니다 . 이 변수는 프로세스 초기화의 일부로 한 번 설정되고 SQLite 인터페이스 루틴이 호출되기 전에 설정되며 그 이후에는이 변수가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="159cf71be6e4a6830ae2567917f78113abca0955" translate="yes" xml:space="preserve">
          <source>It is ok to make multiple entries for the same word as long as each entry has a different soundslike value. Note that if no soundslike value is specified, the soundslike defaults to the word itself.</source>
          <target state="translated">각 항목마다 다른 소리 같은 값이있는 한 동일한 단어에 대해 여러 항목을 입력해도됩니다. soundslike 값을 지정하지 않으면 soundslike의 기본값은 단어 자체입니다.</target>
        </trans-unit>
        <trans-unit id="42b6da3d325a27b4a54e5028535caa1fb0d83d7a" translate="yes" xml:space="preserve">
          <source>It is particularly important to use an entry point name that is based on the extension filename, rather than the generic &quot;sqlite3_extension_init&quot; entry point name, if you will be statically linking two or more extensions. If you use the generic name, there will be multiple definitions of the same symbol and the link will fail.</source>
          <target state="translated">둘 이상의 확장을 정적으로 연결하는 경우 일반 &quot;sqlite3_extension_init&quot;진입 점 이름 대신 확장명 파일 이름을 기반으로하는 진입 점 이름을 사용하는 것이 특히 중요합니다. 일반 이름을 사용하면 동일한 기호에 대한 여러 정의가 있으며 링크가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="1f5372992ab68655b726354d1de85f6b9510df2c" translate="yes" xml:space="preserve">
          <source>It is permitted to register multiple implementations of the same functions with the same name but with either differing numbers of arguments or differing preferred text encodings. SQLite will use the implementation that most closely matches the way in which the SQL function is used. A function implementation with a non-negative nArg parameter is a better match than a function implementation with a negative nArg. A function where the preferred text encoding matches the database encoding is a better match than a function where the encoding is different. A function where the encoding difference is between UTF16le and UTF16be is a closer match than a function where the encoding difference is between UTF8 and UTF16.</source>
          <target state="translated">동일한 이름을 갖지만 다른 수의 인수 또는 다른 선호하는 텍스트 인코딩으로 동일한 함수의 여러 구현을 등록 할 수 있습니다. SQLite는 SQL 함수가 사용되는 방식과 가장 일치하는 구현을 사용합니다. 음수가 아닌 nArg 매개 변수를 사용한 함수 구현은 음수가 nArg 인 함수 구현보다 더 적합합니다. 기본 텍스트 인코딩이 데이터베이스 인코딩과 일치하는 기능은 인코딩이 다른 기능보다 더 적합합니다. 인코딩 차이가 UTF16le과 UTF16be 사이에있는 함수는 인코딩 차이가 UTF8과 UTF16 사이에있는 함수와 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="d335c80330cdb9262d358bd293d73594c1829762" translate="yes" xml:space="preserve">
          <source>It is possible for the library compile-time C preprocessor symbol &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; to override this pragma setting. The following table summarizes the interaction of the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; preprocessor macro and the temp_store pragma:</source>
          <target state="translated">라이브러리 컴파일 타임 C 전 처리기 기호 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 가이 pragma 설정을 대체 할 수 있습니다. 다음 표는 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 전 처리기 매크로와 temp_store pragma 의 상호 작용을 요약 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="882d45108ae3506a475e868a2ed67d0f5c2e5629" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">Prover에 대한 향후 향상을 통해 특정 내장 함수에 대한 NULL 입력이 항상 NULL 응답을 초래한다는 것을 인식 할 수 있습니다. 그러나 모든 내장 함수에 해당 속성이있는 것은 아니며 (예 : &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ) 물론 증명자는 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수에&lt;/a&gt; 대해 추론 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="105eb1a524704db6ebed7c523dd9971899853505" translate="yes" xml:space="preserve">
          <source>It is possible that future enhancements to the prover might enable it to recognize that NULL inputs to certain built-in functions always result in a NULL answer. But not all built-in functions have that property (for example &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt;) and, of course, the prover will never be able to reason about &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;.</source>
          <target state="translated">미래의 검증 자 향상으로 인해 특정 내장 함수에 대한 NULL 입력으로 인해 항상 NULL 응답이 발생 함을 인식 할 수 있습니다. 그러나 모든 내장 함수가 해당 특성을 갖는 것은 아니며 (예 : &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; ) 물론 입증자는 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수에&lt;/a&gt; 대해 추론 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2be5eee10a74ce784db26ece955361d8533b48cb" translate="yes" xml:space="preserve">
          <source>It is possible to build a special &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; that will work with a predetermined set of SQLITE_OMIT_... options. Instructions for doing so can be found with the &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_... documentation&lt;/a&gt;.</source>
          <target state="translated">미리 결정된 SQLITE_OMIT _... 옵션 세트와 함께 작동 하는 특수 &lt;a href=&quot;amalgamation&quot;&gt;병합&lt;/a&gt; 이 가능합니다 . 이를위한 지시 사항은 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _... 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="321373a36254200d34f2e6be79e9dd835a4c4ba3" translate="yes" xml:space="preserve">
          <source>It is possible to create multiple session objects attached to a single database handle.</source>
          <target state="translated">단일 데이터베이스 핸들에 첨부 된 여러 세션 오브젝트를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bed5d040f0bed9644c8d2600cb5ecf6e91531170" translate="yes" xml:space="preserve">
          <source>It is possible to extend custom or pile-of-files formats too, of course, but doing is often much harder. If indices are added, then all application code that changes the corresponding tables must be located and modified to keep those indices up-to-date. If columns are added, then all application code that accesses the corresponding table must be located and modified to take into account the new columns.</source>
          <target state="translated">물론 사용자 정의 또는 파일 더미 형식을 확장 할 수도 있지만 작업이 훨씬 더 어렵습니다. 인덱스가 추가되면 해당 테이블을 변경하는 모든 애플리케이션 코드를 찾아서 수정하여 해당 인덱스를 최신 상태로 유지해야합니다. 열이 추가되면 해당 테이블에 액세스하는 모든 응용 프로그램 코드를 찾아 수정하여 새 열을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6a04c27b0773734dfa33829ac44458f0f513a43" translate="yes" xml:space="preserve">
          <source>It is possible to have an aggregate function with the same name as a simple function, as long as the number of arguments for the two forms of the function are different. For example, the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; function with a single argument is an aggregate and the &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max()&lt;/a&gt; function with two or more arguments is a simple function. Aggregate functions can usually also be used as window functions.</source>
          <target state="translated">함수의 두 형식에 대한 인수 수가 다른 경우 간단한 함수와 이름이 같은 집계 함수를 가질 수 있습니다. 예를 들어, 단일 인수를 가진 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; 함수는 집계이고 두 개 이상의 인수를 가진 &lt;a href=&quot;lang_corefunc#maxoreunc&quot;&gt;max ()&lt;/a&gt; 함수는 간단한 함수입니다. 집계 함수는 일반적으로 창 함수로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79fc85e42448050747bff9c78bdebc62767b73c0" translate="yes" xml:space="preserve">
          <source>It is possible to make SQLite treat NULLs as distinct for the purposes of the SELECT DISTINCT and UNION. To do so, one should change the value of the NULL_ALWAYS_DISTINCT #define in the &lt;code&gt;sqliteInt.h&lt;/code&gt; source file and recompile.</source>
          <target state="translated">SQLite가 SELECT DISTINCT 및 UNION의 목적으로 NULL을 고유하게 처리하도록 할 수 있습니다. 그렇게하려면 &lt;code&gt;sqliteInt.h&lt;/code&gt; 소스 파일 에서 NULL_ALWAYS_DISTINCT #define 값을 변경 하고 다시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8babc1f36de58a996ade599caa2a6556653b1a" translate="yes" xml:space="preserve">
          <source>It is possible to tell whether or not the 'merge' command found any b-trees to merge together by checking the value returned by the &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; API before and after the command is executed. If the difference between the two values is 2 or greater, then work was performed. If the difference is less than 2, then the 'merge' command was a no-op. In this case there is no reason to execute the same 'merge' command again, at least until after the FTS table is next updated.</source>
          <target state="translated">명령 실행 전후에 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; API가 리턴 한 값을 확인하여 'merge'명령이 병합 할 b-tree를 찾았는지 여부를 알 수 있습니다 . 두 값의 차이가 2 이상이면 작업이 수행 된 것입니다. 차이가 2보다 작 으면 '병합'명령이 작동하지 않습니다. 이 경우 최소한 FTS 테이블이 다음에 업데이트 될 때까지 동일한 '병합'명령을 다시 실행할 이유가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e63e80c9bba9974f9e6774ae97788b65cf7107ad" translate="yes" xml:space="preserve">
          <source>It is possible to write into the &quot;t2&quot; table, thus changing the content of the index. But doing so will get the &quot;t1bc&quot; index out of synchronization with its parent table &quot;t1&quot;. An out-of-sync index can result in incorrect query results.</source>
          <target state="translated">&quot;t2&quot;테이블에 쓸 수 있으므로 인덱스의 내용을 변경할 수 있습니다. 그러나 이렇게하면 &quot;t1bc&quot;인덱스가 상위 테이블 &quot;t1&quot;과 동기화되지 않습니다. 동기화되지 않은 인덱스는 잘못된 쿼리 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0822da1b538a191177f07ef1dc3b36f0cff1be87" translate="yes" xml:space="preserve">
          <source>It is recommended that applications respond to the errors listed above by explicitly issuing a ROLLBACK command. If the transaction has already been rolled back automatically by the error response, then the ROLLBACK command will fail with an error, but no harm is caused by this.</source>
          <target state="translated">응용 프로그램은 ROLLBACK 명령을 명시 적으로 실행하여 위에 나열된 오류에 응답하는 것이 좋습니다. 오류 응답으로 트랜잭션이 이미 자동으로 롤백 된 경우 ROLLBACK 명령이 오류와 함께 실패하지만 이로 인한 피해는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7b7eb3618faa363b4bb6cb76587e213a07280f4c" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">현재 데이터베이스 작업을 실행중인 스레드와 다른 스레드에서이 루틴을 호출하는 것이 안전합니다. 그러나 sqlite3_interrupt ()가 리턴되기 전에 닫히거나 닫힐 수 있는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 연결로이 루틴을 호출하는 것은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0d70d917087b8b111a765ae7a55cfbd2640b316e" translate="yes" xml:space="preserve">
          <source>It is safe to call this routine from a thread different from the thread that is currently running the database operation. But it is not safe to call this routine with a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that is closed or might close before sqlite3_interrupt() returns.</source>
          <target state="translated">현재 데이터베이스 작업을 실행중인 스레드와 다른 스레드에서이 루틴을 호출하는 것이 안전합니다. 그러나 sqlite3_interrupt ()가 리턴되기 전에 닫히거나 닫힐 수 있는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스&lt;/a&gt; 연결로이 루틴을 호출하는 것은 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9e98c95444e8fd3d643f309806f8f5b2d312406" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the application's conflict resolution strategy.</source>
          <target state="translated">xConflict 콜백 내에서 콜백과 관련된 테이블에 쓰는 SQL 문을 포함하여 SQL 문을 실행하는 것이 안전합니다. 이것은 응용 프로그램의 충돌 해결 전략을 추가로 사용자 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7155cc55f906067b466a3957abc2b2fa5ca703ab" translate="yes" xml:space="preserve">
          <source>It is safe to execute SQL statements, including those that write to the table that the callback related to, from within the xConflict callback. This can be used to further customize the applications conflict resolution strategy.</source>
          <target state="translated">xConflict 콜백 내에서 콜백과 관련된 테이블에 쓰는 명령문을 포함하여 SQL 문을 실행하는 것이 안전합니다. 이는 응용 프로그램 충돌 해결 전략을 추가로 사용자 정의하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33153f14bd397b5e62d91fe18b2589aae1781966" translate="yes" xml:space="preserve">
          <source>It is sometimes convenient for SQLite extensions to communicate non-SQL values between subcomponents or between the extension and the application. Some examples:</source>
          <target state="translated">SQLite 확장이 하위 구성 요소 간 또는 확장과 응용 프로그램간에 비 SQL 값을 통신하는 것이 편리한 경우가 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="4e37312abd7d96cc7759f842b46f93a1a662f8a0" translate="yes" xml:space="preserve">
          <source>It is still the responsibility of the user to ensure that the contents of an external content FTS5 table are kept up to date with the content table. One way to do this is with triggers. For example:</source>
          <target state="translated">외부 컨텐츠 FTS5 테이블의 컨텐츠가 컨텐츠 테이블을 통해 최신 상태로 유지되도록하는 것은 여전히 ​​사용자의 책임입니다. 이를 수행하는 한 가지 방법은 트리거를 사용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9c7272134156136dee6648bc42ced66fabf0b75c" translate="yes" xml:space="preserve">
          <source>It is the nature of the Guttman R-Tree algorithm that any write might radically restructure the tree, and in the process change the scan order of the nodes. For this reason, it is not generally possible to modify the R-Tree in the middle of a query of the R-Tree. Attempts to do so will fail with a &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;database table is locked&quot; error.</source>
          <target state="translated">모든 쓰기가 트리를 근본적으로 재구성하고 프로세스에서 노드의 스캔 순서를 변경하는 것은 Guttman R-Tree 알고리즘의 특성입니다. 이러한 이유로 일반적으로 R-Tree 쿼리 도중에 R-Tree를 수정할 수 없습니다. 이렇게하면 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; &quot;데이터베이스 테이블이 잠겼습니다&quot;오류 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5653d5d90f75b604cccae96a448a1866fdfa38fe" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually call sqlite3_free() on the *ppOut pointer to free the buffer allocation following a successful call to this function.</source>
          <target state="translated">이 함수를 성공적으로 호출 한 후 버퍼 할당을 해제하려면 * ppOut 포인터에서 sqlite3_free ()를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea70438336584a95d4e17716f1df0d6b713aeb3b" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">호출자를 &lt;a href=&quot;#sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize ()&lt;/a&gt; 에 전달하여 반복자를 파괴하는 것은 호출자의 책임입니다 . 변경 세트 (pChangeset)를 포함하는 버퍼는 반복자가 소멸 될 때까지 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0493c91af19ce8153b8e56f3f8a534dd5019c91" translate="yes" xml:space="preserve">
          <source>It is the responsibility of the caller to eventually destroy the iterator by passing it to &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt;. The buffer containing the changeset (pChangeset) must remain valid until after the iterator is destroyed.</source>
          <target state="translated">호출자를 &lt;a href=&quot;sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize ()&lt;/a&gt; 에 전달하여 반복자를 파괴하는 것은 호출자의 책임입니다 . 변경 세트 (pChangeset)를 포함하는 버퍼는 반복자가 소멸 될 때까지 유효해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d23d845a723659b2b2994a8ad4c9862067cda40" translate="yes" xml:space="preserve">
          <source>It is true that applications sometimes import complete binary SQLite database files from untrusted sources, and such imports could present a possible attack vector. However, those code paths in SQLite are limited and are extremely well tested. And pre-validation routines are available to applications that want to read untrusted databases that can help detect possible attacks prior to use.</source>
          <target state="translated">응용 프로그램이 때때로 신뢰할 수없는 소스에서 완전한 이진 SQLite 데이터베이스 파일을 가져 오는 경우가 많으며 이러한 가져 오기로 인해 가능한 공격 경로가 발생할 수 있습니다. 그러나 SQLite의 코드 경로는 제한되어 있으며 테스트가 매우 잘되었습니다. 또한 사전 검증 루틴을 사용하여 신뢰할 수있는 데이터베이스를 읽고 사용하기 전에 가능한 공격을 탐지 할 수있는 응용 프로그램을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6122ba39afe0e09e2d2af761ca27152501399d2" translate="yes" xml:space="preserve">
          <source>It is usually an error to attempt to create a new table in a database that already contains a table, index or view of the same name. However, if the &quot;IF NOT EXISTS&quot; clause is specified as part of the CREATE TABLE statement and a table or view of the same name already exists, the CREATE TABLE command simply has no effect (and no error message is returned). An error is still returned if the table cannot be created because of an existing index, even if the &quot;IF NOT EXISTS&quot; clause is specified.</source>
          <target state="translated">동일한 이름의 테이블, 인덱스 또는 뷰가 이미 포함 된 데이터베이스에 새 테이블을 만들려고하면 일반적으로 오류가 발생합니다. 그러나 &quot;IF NOT EXISTS&quot;절이 CREATE TABLE 문의 일부로 지정되고 동일한 이름의 테이블 또는 뷰가 이미 존재하면 CREATE TABLE 명령은 아무런 영향을 미치지 않습니다 (오류 메시지가 리턴되지 않음). &quot;IF NOT EXISTS&quot;절이 지정된 경우에도 기존 색인으로 인해 테이블을 작성할 수없는 경우 오류가 계속 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="6955fa966a557f5231f3a39e108f89afbdbb1b83" translate="yes" xml:space="preserve">
          <source>It may not be used on a database that contains &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;식에 대한 인덱스&lt;/a&gt; 가 포함 된 데이터베이스에서는 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="16a2200cb76f9664274f3ef9da8045211e14cc43" translate="yes" xml:space="preserve">
          <source>It might be that there are conflicts in the merge. Conflicts occur when the same line of code was changed in different ways between circles (1) and (4) versus circles (2) and (3). The merge command will announce any conflicts and will include both versions of the conflicting lines in the output. You will need to bring up the files that contain conflicts and manually resolve the conflicts.</source>
          <target state="translated">병합에 충돌이있을 수 있습니다. 동일한 코드 줄이 원 (1)과 (4) 대 원 (2)와 (3) 사이에서 다른 방식으로 변경되면 충돌이 발생합니다. merge 명령은 충돌을 알리고 출력에 충돌하는 두 버전의 라인을 모두 포함합니다. 충돌이 포함 된 파일을 불러 와서 수동으로 충돌을 해결해야합니다.</target>
        </trans-unit>
        <trans-unit id="129a00b2ad750693913d2844d8acb7e806afdd09" translate="yes" xml:space="preserve">
          <source>It must not be possible to make the LIKE or GLOB operator true by having a numeric value (instead of a string or blob) on the left-hand side. This means that either:</source>
          <target state="translated">왼쪽에 숫자 값 (문자열 또는 블로 브 대신)을 사용하여 LIKE 또는 GLOB 연산자를 true로 만들 수 없어야합니다. 이것은 다음 중 하나를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="48d86628c63409da486bd0d69fb891667a6d8475" translate="yes" xml:space="preserve">
          <source>It never hurts to run the VACUUM, even if you don't need it. If the database is in WAL mode, you should shutdown and reopen all database connections before continuing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e56780a95b18eed6f05e0be25053224b3c52ac99" translate="yes" xml:space="preserve">
          <source>It was necessary to move to version 3.0 to implement these features because each requires incompatible changes to the database file format. Other incompatible changes, such as a cleanup of the API, were introduced at the same time under the theory that it is best to get your incompatible changes out of the way all at once.</source>
          <target state="translated">데이터베이스 파일 형식에 호환되지 않는 변경이 필요하기 때문에 이러한 기능을 구현하려면 버전 3.0으로 이동해야했습니다. API 정리와 같은 다른 호환되지 않는 변경 사항은 호환되지 않는 변경 사항을 한 번에 모두 없애는 것이 가장 좋다는 이론하에 동시에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="8d41777ca525f229dab6b56dd5c34598aff8efa5" translate="yes" xml:space="preserve">
          <source>It works with unicode (UTF8) text.</source>
          <target state="translated">유니 코드 (UTF8) 텍스트와 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="829d920a492c6126eef1531c8e8c0e1ab7033bd1" translate="yes" xml:space="preserve">
          <source>Its master journal exists or the master journal name is an empty string, and</source>
          <target state="translated">마스터 저널이 존재하거나 마스터 저널 이름이 빈 문자열이고</target>
        </trans-unit>
        <trans-unit id="a9d92a1b4a228c7e648d8125ef5d3c71b3cd4ff7" translate="yes" xml:space="preserve">
          <source>Its size is greater than 512 bytes, and</source>
          <target state="translated">크기가 512 바이트보다 크고</target>
        </trans-unit>
        <trans-unit id="0239a4728421bae8f8eeba1f3844a6c5e5e3d81b" translate="yes" xml:space="preserve">
          <source>Its super-journal exists or the super-journal name is an empty string, and</source>
          <target state="translated">수퍼 저널이 있거나 수퍼 저널 이름이 빈 문자열 인 경우</target>
        </trans-unit>
        <trans-unit id="73bd910d330560ea1012376a486871434fb0c82d" translate="yes" xml:space="preserve">
          <source>J. M. Robson. &quot;Bounds for Some Functions Concerning Dynamic Storage Allocation&quot;.</source>
          <target state="translated">JM 롭슨 &quot;동적 스토리지 할당에 관한 일부 기능의 경계&quot;.</target>
        </trans-unit>
        <trans-unit id="9a3f6528f2606d1ed81f1e9f85b624a26b98cbbe" translate="yes" xml:space="preserve">
          <source>JOIN</source>
          <target state="translated">JOIN</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="935b885e280c10afb46d2bf45f85bbea09bc94ce" translate="yes" xml:space="preserve">
          <source>JSON support</source>
          <target state="translated">JSON 지원</target>
        </trans-unit>
        <trans-unit id="69a65023a22e8f6d2ee1c6c6ee36c64ccb6d5c6d" translate="yes" xml:space="preserve">
          <source>Join order</source>
          <target state="translated">주문 가입</target>
        </trans-unit>
        <trans-unit id="63acacbd536ebc7829ae48a83492249201168016" translate="yes" xml:space="preserve">
          <source>Join reordering is automatic and usually works well enough that programmers do not have to think about it, especially if &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been used to gather statistics about the available indices. But occasionally some hints from the programmer are needed. Consider, for example, the following schema:</source>
          <target state="translated">조인 재정렬은 자동이며 일반적으로 프로그래머가 그것에 대해 생각할 필요가 없을 정도로 잘 작동합니다. 특히 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 사용하여 사용 가능한 인덱스에 대한 통계를 수집하는 경우. 그러나 때때로 프로그래머의 힌트가 필요합니다. 예를 들어 다음 스키마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="36cb6826dbbbacc9f0915d9e44ccb82925b04c72" translate="yes" xml:space="preserve">
          <source>Joins</source>
          <target state="translated">Joins</target>
        </trans-unit>
        <trans-unit id="742ad08bca9c2e1be08d58aae42e6201c809dcf9" translate="yes" xml:space="preserve">
          <source>Journal File Format</source>
          <target state="translated">저널 파일 형식</target>
        </trans-unit>
        <trans-unit id="debc03f25ef5600d2ed4edf18b01b3412bb71c87" translate="yes" xml:space="preserve">
          <source>Journal Header Format</source>
          <target state="translated">저널 헤더 형식</target>
        </trans-unit>
        <trans-unit id="ccdedfc7a4a23f259c6823eed7a5e93d7a6e430f" translate="yes" xml:space="preserve">
          <source>Journal Record Format</source>
          <target state="translated">저널 레코드 형식</target>
        </trans-unit>
        <trans-unit id="683ff0cc3706704c295b1d1835a7e2e4c3a2a6b7" translate="yes" xml:space="preserve">
          <source>Journal of the Association for Computing Machinery</source>
          <target state="translated">전산 기계 학회지</target>
        </trans-unit>
        <trans-unit id="769726f4101068333430cd9eee0a56b7dfd75235" translate="yes" xml:space="preserve">
          <source>JournalMode</source>
          <target state="translated">JournalMode</target>
        </trans-unit>
        <trans-unit id="c0e70f1bd285ac28ec38cf9261dd9cf6df3840dd" translate="yes" xml:space="preserve">
          <source>Journalling a Database Page</source>
          <target state="translated">데이터베이스 페이지 저널링</target>
        </trans-unit>
        <trans-unit id="b576bd921c8bd5cb6e5720fc3c6797d3e02e8d08" translate="yes" xml:space="preserve">
          <source>Journalling a page</source>
          <target state="translated">페이지 저널링</target>
        </trans-unit>
        <trans-unit id="84e304128c1076094ba7ee02aeb09745e71eaf53" translate="yes" xml:space="preserve">
          <source>Julian day number</source>
          <target state="translated">줄리안 일수</target>
        </trans-unit>
        <trans-unit id="1eba140fdd9c6860a1730c408e3064aa417ca2a3" translate="yes" xml:space="preserve">
          <source>Jump</source>
          <target state="translated">Jump</target>
        </trans-unit>
        <trans-unit id="5d84018241481efa31572e7a64ddf20102d5a735" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is False. The value is considered false if it has a numeric value of zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">레지스터 P1의 값이 False이면 P2로 이동합니다. 숫자 값이 0이면 값이 false로 간주됩니다. P1의 값이 NULL이면 P3이 0이 아닌 경우에만 점프를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c02affea77793c1c3281caf3fff7c025052fcd28" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is NULL.</source>
          <target state="translated">레지스터 P1의 값이 NULL이면 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9d04284895be3aad627f0d99db148ecf0772d61d" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is not NULL.</source>
          <target state="translated">레지스터 P1의 값이 NULL이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="38d677f93cf11ed33026afa36fe1f252297e13d5" translate="yes" xml:space="preserve">
          <source>Jump to P2 if the value in register P1 is true. The value is considered true if it is numeric and non-zero. If the value in P1 is NULL then take the jump if and only if P3 is non-zero.</source>
          <target state="translated">레지스터 P1의 값이 참이면 P2로 이동합니다. 숫자이고 0이 아닌 경우 값은 true로 간주됩니다. P1의 값이 NULL이면 P3이 0이 아닌 경우에만 점프를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="04a8d1cd1316034cf886277bf2c8dd963c76b71c" translate="yes" xml:space="preserve">
          <source>Jump to the instruction at address P1, P2, or P3 depending on whether in the most recent &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; instruction the P1 vector was less than equal to, or greater than the P2 vector, respectively.</source>
          <target state="translated">가장 최근의 &lt;a href=&quot;opcode#Compare&quot;&gt;비교&lt;/a&gt; 명령어에서 P1 벡터가 P2 벡터보다 작거나 같은지 여부에 따라 주소 P1, P2 또는 P3의 명령어로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="029dc808e2fcf8db0d9a3400f04a64bf760921ba" translate="yes" xml:space="preserve">
          <source>Jump to the next instruction after the address in register P1. After the jump, register P1 becomes undefined.</source>
          <target state="translated">레지스터 P1의 주소 다음에 나오는 다음 명령으로 이동하십시오. 점프 후 레지스터 P1은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be91c2cd21e07ee8ceb31ed436dfe5c08c9a83b6" translate="yes" xml:space="preserve">
          <source>Just as there is the &quot;zip&quot; program to manage ZIP Archives, and the &quot;tar&quot; program to manage Tarballs, the &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;&quot;sqlar&quot; program&lt;/a&gt; exists to manage SQL Archives. The &quot;sqlar&quot; program is able to create a new SQLite Archive, list the content of an existing archive, add or remove files from the archive, and/or extract files from the archive. A separate &quot;sqlarfs&quot; program is able to mount the SQLite Archive as a &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt;.</source>
          <target state="translated">ZIP 아카이브를 관리하는 &quot;zip&quot;프로그램과 &lt;a href=&quot;https://sqlite.org/sqlar&quot;&gt;Tarball&lt;/a&gt; 을 관리하는 &quot;tar&quot;프로그램이있는 것처럼 &quot;sqlar&quot;프로그램 은 SQL 아카이브를 관리하기 위해 존재합니다. &quot;sqlar&quot;프로그램은 새 SQLite Archive를 작성하고 기존 아카이브의 컨텐츠를 나열하며 아카이브에서 파일을 추가 또는 제거하거나 아카이브에서 파일을 추출 할 수 있습니다. 별도의 &quot;sqlarfs&quot;프로그램은 SQLite Archive를 &lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;Fuse Filesystem&lt;/a&gt; 으로 마운트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd65c1b4b3e66e765523873bd29cf5d6d6838189" translate="yes" xml:space="preserve">
          <source>KEY</source>
          <target state="translated">KEY</target>
        </trans-unit>
        <trans-unit id="d27c8f02c4abf5f11c1eced4acd8b35520a9fe80" translate="yes" xml:space="preserve">
          <source>Keep constant guard over the actions of your life.</source>
          <target state="translated">당신의 삶의 행동을 끊임없이 경계하십시오.</target>
        </trans-unit>
        <trans-unit id="194e669a908d39900cf589c5a981d721d7c9618b" translate="yes" xml:space="preserve">
          <source>Keep death daily before your eyes.</source>
          <target state="translated">눈 앞에 매일 죽음을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="c25db8dd7484e7f7bee803cd3895b18495da35bc" translate="yes" xml:space="preserve">
          <source>Keep the full precision of integers (if possible) when casting to NUMERIC. Ticket #2364</source>
          <target state="translated">NUMERIC으로 캐스트 할 때 정수의 정밀도를 유지하십시오 (가능한 경우). 티켓 # 2364</target>
        </trans-unit>
        <trans-unit id="4989895ac52269498fe4414b7697f7a4c22ad5aa" translate="yes" xml:space="preserve">
          <source>Key points:</source>
          <target state="translated">키 포인트:</target>
        </trans-unit>
        <trans-unit id="08fa4eb3aedd30338134d345421fea84986b3d4a" translate="yes" xml:space="preserve">
          <source>Key take-aways from this essay:</source>
          <target state="translated">이 글의 주요 내용 :</target>
        </trans-unit>
        <trans-unit id="8b3a8bbf2ec2d401e862eec6bf418d40320b88cb" translate="yes" xml:space="preserve">
          <source>Key/value store for the raw database file content. The key is the page number and the value is binary page content.</source>
          <target state="translated">원시 데이터베이스 파일 컨텐츠의 키 / 값 저장소 키는 페이지 번호이고 값은 이진 페이지 내용입니다.</target>
        </trans-unit>
        <trans-unit id="7b687d48e96f480574af88076704d469738ac8fd" translate="yes" xml:space="preserve">
          <source>Keyword arguments can optionally appear in quotes. (Example: &lt;code&gt;'yes' [FALSE]&lt;/code&gt;.) Some pragmas takes a string literal as their argument. When pragma takes a keyword argument, it will usually also take a numeric equivalent as well. For example, &quot;0&quot; and &quot;no&quot; mean the same thing, as does &quot;1&quot; and &quot;yes&quot;. When querying the value of a setting, many pragmas return the number rather than the keyword.</source>
          <target state="translated">키워드 인수는 선택적으로 따옴표로 표시 할 수 있습니다. (예 : &lt;code&gt;'yes' [FALSE]&lt;/code&gt; .) 일부 pragma는 문자열 리터럴을 인수로 사용합니다. pragma는 키워드 인수를 사용할 때 일반적으로 동등한 숫자도 사용합니다. 예를 들어, &quot;0&quot;과 &quot;no&quot;는 &quot;1&quot;과 &quot;yes&quot;와 같은 의미입니다. 설정 값을 쿼리 할 때 많은 pragma가 키워드 대신 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71d7d3fe2fa70220d2397ae5ef29dbf8ffba7a8b" translate="yes" xml:space="preserve">
          <source>Know for certain that God sees you everywhere.</source>
          <target state="translated">하나님 께서 당신을 모든 곳에서 보신다는 것을 확실히하십시오.</target>
        </trans-unit>
        <trans-unit id="7e70d2e585c390da7abcf2a3249245e0e36e0092" translate="yes" xml:space="preserve">
          <source>LAST</source>
          <target state="translated">LAST</target>
        </trans-unit>
        <trans-unit id="969e2cc476ff76be41815b17d8fb9c685f97e243" translate="yes" xml:space="preserve">
          <source>LEFT</source>
          <target state="translated">LEFT</target>
        </trans-unit>
        <trans-unit id="fa443d7d6200af63823dccc305e61eed839b45c2" translate="yes" xml:space="preserve">
          <source>LEFT JOIN</source>
          <target state="translated">왼쪽 가입</target>
        </trans-unit>
        <trans-unit id="06214bf7efebdbadf0fc2e8285b451472a810158" translate="yes" xml:space="preserve">
          <source>LEFT JOIN elimination often comes up when LEFT JOINs are used inside of views, and then the view is used in such as way that none of the columns of the right-hand table of the LEFT JOIN are referenced.</source>
          <target state="translated">LEFT JOIN이 뷰 내부에서 사용될 때 LEFT JOIN 제거가 종종 발생하고 LEFT JOIN의 오른쪽 테이블 열이 참조되지 않는 방식으로 뷰가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="228baedd626cec5fb29f832c085ce530c565f626" translate="yes" xml:space="preserve">
          <source>LEFT JOIN strength reduction optimization</source>
          <target state="translated">LEFT JOIN 강도 감소 최적화</target>
        </trans-unit>
        <trans-unit id="e43376033cc5d4106eb2e868e3b049e3915b255f" translate="yes" xml:space="preserve">
          <source>LEFT OUTER JOIN is implemented, but not RIGHT OUTER JOIN or FULL OUTER JOIN.</source>
          <target state="translated">LEFT OUTER JOIN이 구현되었지만 RIGHT OUTER JOIN 또는 FULL OUTER JOIN이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5ddf6f04739d8bc3a11b487863b27a7bcaa6fc24" translate="yes" xml:space="preserve">
          <source>LIKE</source>
          <target state="translated">LIKE</target>
        </trans-unit>
        <trans-unit id="92323e665381f4f6e8310e0e8d0ab85b11facf9e" translate="yes" xml:space="preserve">
          <source>LIKE optimization</source>
          <target state="translated">같은 최적화</target>
        </trans-unit>
        <trans-unit id="c385d79f275c108bd6a32af099948cfc74a92c05" translate="yes" xml:space="preserve">
          <source>LIKE optimization now works for columns with COLLATE NOCASE</source>
          <target state="translated">LIKE 최적화는 이제 COLLATE NOCASE가있는 열에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9c590af5665cfc2916823206547377e482547e1d" translate="yes" xml:space="preserve">
          <source>LIMIT</source>
          <target state="translated">LIMIT</target>
        </trans-unit>
        <trans-unit id="40c4547fe7d52f08474372a32d5cd65ef3e61db8" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now shows no rows. Use LIMIT -1 to see all rows.</source>
          <target state="translated">LIMIT 0은 이제 행을 보여주지 않습니다. 모든 행을 보려면 LIMIT -1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e120f1515582fd60e3aa87caeded6a95706ff6a5" translate="yes" xml:space="preserve">
          <source>LIMIT 0 now works on subqueries</source>
          <target state="translated">LIMIT 0은 이제 서브 쿼리에서 작동합니다</target>
        </trans-unit>
        <trans-unit id="2726a4b3c5be6bc17db3c5aa67da0f6e30ea159f" translate="yes" xml:space="preserve">
          <source>LIMIT_ATTACH</source>
          <target state="translated">LIMIT_ATTACH</target>
        </trans-unit>
        <trans-unit id="e8bf21b0d0f3b850c955bb94b5141253b1ae7e2a" translate="yes" xml:space="preserve">
          <source>LIMIT_COLUMN</source>
          <target state="translated">LIMIT_COLUMN</target>
        </trans-unit>
        <trans-unit id="7b09e7eae5f068cca9e40a4e561d97d66518a255" translate="yes" xml:space="preserve">
          <source>LIMIT_COMPOUND_SELECT</source>
          <target state="translated">LIMIT_COMPOUND_SELECT</target>
        </trans-unit>
        <trans-unit id="b1c8f4255d541a1d18f761d25857086f40b1bf20" translate="yes" xml:space="preserve">
          <source>LIMIT_EXPR_DEPTH</source>
          <target state="translated">LIMIT_EXPR_DEPTH</target>
        </trans-unit>
        <trans-unit id="2a0de541f4fa62311ff3575519dfacbb5ae6b11e" translate="yes" xml:space="preserve">
          <source>LIMIT_FUNCTION_ARG</source>
          <target state="translated">LIMIT_FUNCTION_ARG</target>
        </trans-unit>
        <trans-unit id="1a3a784fe44fc702cae042a37cb3ba3e0f6fa7ac" translate="yes" xml:space="preserve">
          <source>LIMIT_LENGTH</source>
          <target state="translated">LIMIT_LENGTH</target>
        </trans-unit>
        <trans-unit id="72fc2492f41deaa54c2dac4538490fafaa14d0d6" translate="yes" xml:space="preserve">
          <source>LIMIT_LIKE_PATTERN_LENGTH</source>
          <target state="translated">LIMIT_LIKE_PATTERN_LENGTH</target>
        </trans-unit>
        <trans-unit id="5e8999dc05d8b9aa066f6d09239a0ae740e36f64" translate="yes" xml:space="preserve">
          <source>LIMIT_SQL_LENGTH</source>
          <target state="translated">LIMIT_SQL_LENGTH</target>
        </trans-unit>
        <trans-unit id="db5d695bfcc2c3ebffa6c7ffcd096c20b8eed97c" translate="yes" xml:space="preserve">
          <source>LIMIT_TRIGGER_DEPTH</source>
          <target state="translated">LIMIT_TRIGGER_DEPTH</target>
        </trans-unit>
        <trans-unit id="16d75adbe3aa654b347523eb12544c39563f5b43" translate="yes" xml:space="preserve">
          <source>LIMIT_VARIABLE_NUMBER</source>
          <target state="translated">LIMIT_VARIABLE_NUMBER</target>
        </trans-unit>
        <trans-unit id="a604921b15950316535a24537e634352270c370e" translate="yes" xml:space="preserve">
          <source>LIMIT_VDBE_OP</source>
          <target state="translated">LIMIT_VDBE_OP</target>
        </trans-unit>
        <trans-unit id="89b86ab0e66f527166d98df92ddbcf5416ed58f6" translate="yes" xml:space="preserve">
          <source>Language</source>
          <target state="translated">Language</target>
        </trans-unit>
        <trans-unit id="7428d00a0b1c6a4c3041c21ce5ceb9dbaa4b015a" translate="yes" xml:space="preserve">
          <source>Large WAL files</source>
          <target state="translated">큰 WAL 파일</target>
        </trans-unit>
        <trans-unit id="d1c69a859a9638b242f2dabf8acf1c0b1450ce6b" translate="yes" xml:space="preserve">
          <source>Last</source>
          <target state="translated">Last</target>
        </trans-unit>
        <trans-unit id="07235ffa8a70d2e51e9570c942d05e5b5851a313" translate="yes" xml:space="preserve">
          <source>Last Insert Rowid</source>
          <target state="translated">마지막 삽입 Rowid</target>
        </trans-unit>
        <trans-unit id="7f81d5c9ec25b5fa1a2640b99a8421ac6c71b017" translate="yes" xml:space="preserve">
          <source>Later, SQLite version 3.6.16 is released, as shown by circle (4) in the diagram. At the point, the private branch maintainer does a merge which takes all of the changes going from (1) to (4) and applies those changes to (3). The result is version (5), which is SQLite 3.6.16 plus edits.</source>
          <target state="translated">나중에 다이어그램에서 원 (4)로 표시된 것처럼 SQLite 버전 3.6.16이 릴리스됩니다. 이 시점에서 개인 브랜치 관리자는 병합을 수행하여 (1)에서 (4)로 변경되는 모든 변경 사항을 (3)에 적용합니다. 결과는 버전 (5)이며 SQLite 3.6.16 및 편집입니다.</target>
        </trans-unit>
        <trans-unit id="e07edacb2555a09c495279c3384f36a675435d8d" translate="yes" xml:space="preserve">
          <source>Le</source>
          <target state="translated">Le</target>
        </trans-unit>
        <trans-unit id="fa3757f35a67a972328ec50d59fdef6fec4d197a" translate="yes" xml:space="preserve">
          <source>Leading spaces are removed.</source>
          <target state="translated">선행 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="e52b8a48a53a875ca174a915ae5c47d6e94c2665" translate="yes" xml:space="preserve">
          <source>Leading zeros are handled properly, in the sense that they do not mess of the maginitude comparison of embedded strings of digits. &quot;x00123y&quot; is equal to &quot;x123y&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dae495d04abf17bb3895a89b30ae8efcca9f3f1" translate="yes" xml:space="preserve">
          <source>Leaf payload fraction. Must be 32.</source>
          <target state="translated">리프 페이로드 비율. 32 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e2626d2b1592bacc07397cf31582efd1c5b2420a" translate="yes" xml:space="preserve">
          <source>Left operand</source>
          <target state="translated">왼쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="203223a5600f328f50c6338dfe2e4c11e8803475" translate="yes" xml:space="preserve">
          <source>Left operand found</source>
          <target state="translated">왼쪽 피연산자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="865d1c5dcc029d18d1621430419ee2f04f5f424f" translate="yes" xml:space="preserve">
          <source>Left-justify the value in the output. The default is to right-justify. If the width is zero or is otherwise less than the length of the value being substituted, then there is no padding and the &quot;-&quot; flag is a no-op.</source>
          <target state="translated">출력 값을 왼쪽으로 맞 춥니 다. 기본값은 오른쪽 정렬입니다. 너비가 0이거나 대체되는 값의 길이보다 작 으면 패딩이없고 &quot;-&quot;플래그가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1877e2f919fe86f5371e6a3e7d9d6b6080bf4d57" translate="yes" xml:space="preserve">
          <source>Legacy (older than 3.22.0) versions of the sessions module cannot capture changes made to the sqlite_stat1 table. Legacy versions of the sqlite3changeset_apply() function silently ignore any modifications to the sqlite_stat1 table that are part of a changeset or patchset.</source>
          <target state="translated">세션 모듈의 레거시 (3.22.0 이전) 버전은 sqlite_stat1 테이블의 변경 사항을 캡처 할 수 없습니다. sqlite3changeset_apply () 함수의 레거시 버전은 변경 세트 또는 패치 세트의 일부인 sqlite_stat1 테이블의 수정 사항을 자동으로 무시합니다.</target>
        </trans-unit>
        <trans-unit id="48078fcdb6dc318fa741d70a2ecdb6ae1437e609" translate="yes" xml:space="preserve">
          <source>Lemon does not have its own source repository. Rather, Lemon consists of a few files in the SQLite source tree:</source>
          <target state="translated">레몬에는 자체 소스 저장소가 없습니다. 레몬은 SQLite 소스 트리에 몇 개의 파일로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0578b2a25d2e804bfd4deee5634450a8293393" translate="yes" xml:space="preserve">
          <source>Lemon generates an LALR(1) parser. It's operation is similar to the more familiar tools &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt;, but Lemon adds important improvements, including:</source>
          <target state="translated">레몬은 LALR (1) 파서를 생성합니다. 이 작업은 친숙한 도구 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Yacc&quot;&gt;Yacc&lt;/a&gt; 및 &lt;a href=&quot;https://en.wikipedia.org/wiki/GNU_bison&quot;&gt;Bison&lt;/a&gt; 과 비슷하지만 레몬은 다음과 같은 중요한 개선 사항을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ae32ad1b62e795e4b0f91393920f4a7aff7c555a" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a &quot;fallback&quot; tokens. The SQL language contains a large number of keywords and these keywords have the potential to collide with identifier names. Lemon has the ability to designate some keywords has being able to &quot;fallback&quot; to an identifier. If the keyword appears in the input token stream in a context that would otherwise be a syntax error, the token is automatically transformed into its fallback before the syntax error is raised. This feature allows the parser to be very forgiving of reserved words used as identifiers, which is a problem that comes up frequently in the SQL language.</source>
          <target state="translated">레몬에는 &quot;대체&quot;토큰이라는 개념이 있습니다. SQL 언어에는 많은 키워드가 포함되어 있으며 이러한 키워드는 식별자 이름과 충돌 할 가능성이 있습니다. 레몬은 일부 키워드를 지정하는 기능이 식별자로 &quot;대체&quot;할 수있게했습니다. 구문 오류 인 컨텍스트에서 키워드가 입력 토큰 스트림에 표시되면 구문 오류가 발생하기 전에 토큰이 자동으로 폴백으로 변환됩니다. 이 기능을 사용하면 구문 분석기가 식별자로 사용되는 예약어를 매우 용서할 수 있습니다. 이는 SQL 언어에서 자주 발생하는 문제입니다.</target>
        </trans-unit>
        <trans-unit id="2f9dc02cb8bf5b03f6591dbb44f0a7a4b90f82f4" translate="yes" xml:space="preserve">
          <source>Lemon has the concept of a non-terminal destructor that can be used to reclaim memory or other resources following a syntax error or other aborted parse.</source>
          <target state="translated">레몬은 구문 오류나 다른 중단 된 구문 분석 후에 메모리 나 기타 리소스를 회수하는 데 사용할 수있는 비 터미널 소멸자 개념을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="cee927c3e2d6e42d43d5738f627f3200d5121eac" translate="yes" xml:space="preserve">
          <source>Lemon is also used to generate parse for the query pattern expressions in the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. In this case, the input grammar file is &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt;.</source>
          <target state="translated">레몬은 또한 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 확장 에서 쿼리 패턴 표현식에 대한 구문 분석을 생성하는 데 사용됩니다 . 이 경우 입력 문법 파일은 &lt;a href=&quot;https://sqlite.org/src/file/ext/fts5/fts5parse.y&quot;&gt;fts5parse.y&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="611d0deb28e86cca8303457d918752428288861c" translate="yes" xml:space="preserve">
          <source>Lemon is used in two places in SQLite.</source>
          <target state="translated">레몬은 SQLite에서 두 곳에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0045a01f71c39a54c68dbc362b5b7275372032f5" translate="yes" xml:space="preserve">
          <source>Lemon supports conditional compilation of grammar file rules, so that a different parser can be generated depending on compile-time options.</source>
          <target state="translated">레몬은 문법 파일 규칙의 조건부 컴파일을 지원하므로 컴파일 타임 옵션에 따라 다른 파서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c89f378ce33982d309c573eb1ff14dd3f01e8a" translate="yes" xml:space="preserve">
          <source>Lemon was original written by D. Richard Hipp (also the creator of SQLite) while he was in graduate school at Duke University between 1987 and 1992. The original creation date of Lemon has been lost, but was probably sometime around 1990. Lemon generates an LALR(1) parser. There was companion LL(1) parser generator tool named &quot;Lime&quot;, but the source code for Lime has been lost.</source>
          <target state="translated">레몬은 1987 년부터 1992 년까지 듀크 대학교 대학원에 재학중인 동안 D. Richard Hipp (또한 SQLite의 창시자)가 저술 한 원본입니다. 레몬의 최초 제작 날짜는 잃어 버렸지 만 아마도 1990 년경 쯤되었을 것입니다. LALR (1) 파서 &quot;Lime&quot;이라는 LL (1) 파서 생성기 도구가 있었지만 Lime의 소스 코드가 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="aa1fa89453ad95c8f115feb4d323d1e9b329630d" translate="yes" xml:space="preserve">
          <source>Length Specifier</source>
          <target state="translated">길이 지정자</target>
        </trans-unit>
        <trans-unit id="c999fb0a278ca9591b2cd0c03ceaa3328da57984" translate="yes" xml:space="preserve">
          <source>Less administration means that programmers spend more time working on the software (SQLite in this case) and less time fussing with the version control system.</source>
          <target state="translated">관리가 적다는 것은 프로그래머가 소프트웨어 작업에 더 많은 시간을 소비하고 (이 경우 SQLite) 버전 제어 시스템을 사용하는 데 소요되는 시간을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="cbcb5b1fa488787750d49ab79f8ec375ce5124b9" translate="yes" xml:space="preserve">
          <source>Less memory used</source>
          <target state="translated">적은 메모리 사용</target>
        </trans-unit>
        <trans-unit id="bc720094b72d521a9bad35bfe37f02c776160039" translate="yes" xml:space="preserve">
          <source>Let K be M+((P-M)%(U-4)).</source>
          <target state="translated">K를 M + ((PM) % (U-4))로 둡니다.</target>
        </trans-unit>
        <trans-unit id="ec5fd8c108643b71cf1bdd72351ff3e987fc1a5d" translate="yes" xml:space="preserve">
          <source>Let X be ((U-12)*64/255)-23. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the index b-tree page is K if K is less than or equal to X or M otherwise. The number of bytes stored on the index page is never less than M.</source>
          <target state="translated">X를 ((U-12) * 64 / 255) -23으로 둡니다. 페이로드 크기 P가 X보다 작거나 같은 경우 전체 페이로드가 b- 트리 페이지에 저장됩니다. M을 ((U-12) * 32 / 255) -23으로하고 K를 M + ((PM) % (U-4))로하십시오. P가 X보다 크면 K가 X보다 작거나 같으면 인덱스 b- 트리 페이지에 저장된 바이트 수는 K입니다. 인덱스 페이지에 저장된 바이트 수는 M보다 작지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3814595cf4d53307c33619bbcfd8505bff49fec5" translate="yes" xml:space="preserve">
          <source>Let X be U-35. If the payload size P is less than or equal to X then the entire payload is stored on the b-tree leaf page. Let M be ((U-12)*32/255)-23 and let K be M+((P-M)%(U-4)). If P is greater than X then the number of bytes stored on the table b-tree leaf page is K if K is less or equal to X or M otherwise. The number of bytes stored on the leaf page is never less than M.</source>
          <target state="translated">X를 U-35라고하자. 페이로드 크기 P가 X보다 작거나 같은 경우 전체 페이로드가 b- 트리 리프 페이지에 저장됩니다. M을 ((U-12) * 32 / 255) -23으로하고 K를 M + ((PM) % (U-4))로하십시오. P가 X보다 크면 K가 X보다 작거나 같은 경우 테이블 b- 트리 리프 페이지에 저장된 바이트 수는 K이고, 그렇지 않으면 M입니다. 리프 페이지에 저장된 바이트 수는 M보다 작지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04ab6da7aca9e95067f1ce62f19a937e96ff6418" translate="yes" xml:space="preserve">
          <source>Let X be the expression in the WHERE clause of a partial index, and let W be the WHERE clause of a query that uses the table that is indexed. Then, the query is permitted to use the partial index if W&amp;rArr;X, where the &amp;rArr; operator (usually pronounced &quot;implies&quot;) is the logic operator equivalent to &quot;X or not W&quot;. Hence, determining whether or not a partial index is usable in a particular query reduces to proving a theorem in first-order logic.</source>
          <target state="translated">X를 부분 인덱스의 WHERE 절에있는 표현식으로, W가 인덱스 된 테이블을 사용하는 쿼리의 WHERE 절이라고하자. 그런 다음 W&amp;rArr;X 인 경우 쿼리에서 부분 인덱스를 사용할 수 있습니다. 여기서 &amp;rArr; 연산자 (일반적으로 &quot;implies&quot;라고 함)는 &quot;X 또는 not W&quot;에 해당하는 논리 연산자입니다. 따라서 특정 쿼리에서 부분 인덱스를 사용할 수 있는지 여부를 결정하면 1 차 논리의 정리 증명이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8e79f3f73bca370e5a0d09f6e67e4908583572b1" translate="yes" xml:space="preserve">
          <source>Let X be the largest set of consecutive integers {h, h+1, h+2, ..., h+N} such that for every j in X, aPgno[j%8192]!=0. The X set will be empty if aPgno[h%8192]==0. The X set is easily computed by starting with the value h%8192, and adding h%8192 to X and incrementing h until encountering the first aPgno[h%8192] entry that is zero.</source>
          <target state="translated">X를 X의 모든 j에 대해 aPgno [j % 8192]! = 0이되도록 연속 정수 {h, h + 1, h + 2, ..., h + N}의 가장 큰 집합으로 둡니다. aPgno [h % 8192] == 0 인 경우 X 세트가 비어 있습니다. X 세트는 값 h % 8192로 시작하여 h % 8192를 X에 추가하고 첫 번째 aPgno [h % 8192] 항목이 0이 될 때까지 h를 증가시켜 쉽게 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="37bafb8ebd6ac523c9fab977240fbaca2d2a4205" translate="yes" xml:space="preserve">
          <source>Let the database page size (the value of the integer at offset 24 in the journal header) be N. Then the format of a page record is as follows:</source>
          <target state="translated">데이터베이스 페이지 크기 (저널 헤더의 오프셋 24에있는 정수 값)를 N으로 설정하십시오. 그러면 페이지 레코드의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5da01c6ea976760415bf0eb965f5e685ea3c15ec" translate="yes" xml:space="preserve">
          <source>Let the datatypes &quot;u8&quot;, &quot;u16&quot;, and &quot;u32&quot; mean unsigned integers of length 8, 16, and 32 bits, respectively. Then, the first 32768-byte unit of the shm file is organized as follows:</source>
          <target state="translated">데이터 유형 &quot;u8&quot;, &quot;u16&quot;및 &quot;u32&quot;는 각각 길이 8, 16 및 32 비트의 부호없는 정수를 의미합니다. 그런 다음 shm 파일의 첫 32768 바이트 단위는 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="bd114f90a251306f5f9680610cc3593a57d82e5b" translate="yes" xml:space="preserve">
          <source>Let the number of alice nodes be M and the number of bob nodes be N. Consider two scenarios. In the first scenario, M and N are both 2 but there are thousands of edges on each node. In this case, option 1 is preferred. With option 1, the inner loop checks for the existence of an edge between a pair of nodes and outputs the result if found. But because there are only 2 alice and bob nodes each, the inner loop only has to run 4 times and the query is very quick. Option 2 would take much longer here. The outer loop of option 2 only executes twice, but because there are a large number of edges leaving each alice node, the middle loop has to iterate many thousands of times. It will be much slower. So in the first scenario, we prefer to use option 1.</source>
          <target state="translated">alice 노드의 수를 M으로, bob 노드의 수를 N으로하십시오. 두 가지 시나리오를 고려하십시오. 첫 번째 시나리오에서 M과 N은 둘 다 2이지만 각 노드에는 수천 개의 모서리가 있습니다. 이 경우 옵션 1이 선호됩니다. 옵션 1을 사용하면 내부 루프는 한 쌍의 노드 사이에 에지가 있는지 확인하고 발견되면 결과를 출력합니다. 그러나 각각 2 개의 alice 및 bob 노드 만 있기 때문에 내부 루프는 4 번만 실행하면되며 쿼리가 매우 빠릅니다. 옵션 2는 여기에서 훨씬 오래 걸립니다. 옵션 2의 외부 루프는 두 번만 실행되지만 각 앨리스 노드를 떠나는 많은 수의 에지가 있기 때문에 중간 루프는 수천 번 반복되어야합니다. 훨씬 느려질 것입니다. 따라서 첫 번째 시나리오에서는 옵션 1을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="74b220b56c9d6c3f209f91061a8b3234a645c429" translate="yes" xml:space="preserve">
          <source>Let the page count value at offset 8 in the journal header be M. If M is greater than zero then after M page records the journal file may be zero padded out to the next multiple of the sector size and another journal header may be inserted. All journal headers within the same journal must contain the same database page size and sector size.</source>
          <target state="translated">저널 헤더에서 오프셋 8의 페이지 카운트 값을 M으로 설정하십시오. M이 0보다 크면 M 페이지 레코드 이후 저널 파일은 섹터 크기의 다음 배수에 0으로 채워지고 다른 저널 헤더가 삽입 될 수 있습니다. 동일한 저널 내의 모든 저널 헤더는 동일한 데이터베이스 페이지 크기 및 섹터 크기를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f44e417ae6158672e12bddd6f44e6cd28bdb55bb" translate="yes" xml:space="preserve">
          <source>Let us assume that you are using the amalgamation source code. Add the baseline to your project as follows:</source>
          <target state="translated">합병 소스 코드를 사용한다고 가정 해 봅시다. 다음과 같이 프로젝트에 기준을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ae7bd817eacac0a262f119102109a97036180841" translate="yes" xml:space="preserve">
          <source>Let us suppose that instead of using a ZIP archive to store its files, OpenDocument used a very simple SQLite database with the following single-table schema:</source>
          <target state="translated">ZIP 아카이브를 사용하여 파일을 저장하는 대신 OpenDocument는 다음과 같은 단일 테이블 스키마와 함께 매우 간단한 SQLite 데이터베이스를 사용했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ecc5e1e5e0ad7c0dd2b547a397bdb11d90ca6d36" translate="yes" xml:space="preserve">
          <source>Let us use the following notation (similar but not identical to Robson's notation):</source>
          <target state="translated">다음 표기법을 사용합시다 (Robson의 표기법과 유사하지만 동일하지 않음).</target>
        </trans-unit>
        <trans-unit id="2d2261f9e0cbec9edf95c4d47c5f5eb0cbcca2f7" translate="yes" xml:space="preserve">
          <source>Let's be real. Few people seriously dispute that Git provides a suboptimal user experience. A lot of the underlying implementation shows through into the user interface. The interface is so bad that there is even a parody site that generates &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;fake git man pages&lt;/a&gt;.</source>
          <target state="translated">진짜로합시다 Git이 최적의 사용자 경험을 제공하지 않는다고 진지하게 이의를 제기하는 사람은 거의 없습니다. 많은 기본 구현이 사용자 인터페이스를 통해 보여줍니다. 인터페이스가 너무 나빠서 &lt;a href=&quot;https://git-man-page-generator.lokaltog.net/&quot;&gt;가짜 git man 페이지&lt;/a&gt; 를 생성하는 패러디 사이트도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f0987eb98b35f60885158c865b4e995d0d04bc9" translate="yes" xml:space="preserve">
          <source>Let's look more closely at what is happening here. The first SELECT is implemented by the loop at instructions 5 through 10. Instruction 5 initializes the loop by rewinding its cursor. Instruction 6 extracts the value of the &quot;two&quot; column from &quot;examp&quot; and instruction 7 converts this into a row. Instruction 8 pushes an empty string onto the stack. Finally, instruction 9 writes the row into the temporary table. But remember, the PutStrKey opcode uses the top of the stack as the record data and the next on stack as the key. For an INSERT statement, the row generated by the MakeRecord opcode is the record data and the record key is an integer created by the NewRecno opcode. But here the roles are reversed and the row created by MakeRecord is the record key and the record data is just an empty string.</source>
          <target state="translated">여기서 무슨 일이 일어나고 있는지 좀 더 자세히 살펴 봅시다. 첫 번째 SELECT는 명령어 5에서 10까지의 루프에 의해 구현됩니다. 명령어 5는 커서를 되 감아 루프를 초기화합니다. 명령어 6은 &quot;examp&quot;에서 &quot;two&quot;열의 값을 추출하고 명령어 7은이를 행으로 변환합니다. 명령어 8은 빈 문자열을 스택에 넣습니다. 마지막으로 명령 9는 행을 임시 테이블에 기록합니다. 그러나 PutStrKey opcode는 스택의 상단을 레코드 데이터로 사용하고 스택의 다음은 키로 사용합니다. INSERT 문의 경우 MakeRecord opcode에 의해 생성 된 행은 레코드 데이터이고 레코드 키는 NewRecno opcode에 의해 작성된 정수입니다. 그러나 여기서 역할이 바뀌고 MakeRecord에 의해 작성된 행은 레코드 키이고 레코드 데이터는 단지 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="8ce47b13d09374c0748516f88f9567e0ba880c6e" translate="yes" xml:space="preserve">
          <source>Libraries written in C do not have a huge run-time dependency. In its minimum configuration, SQLite requires only the following routines from the standard C library:</source>
          <target state="translated">C로 작성된 라이브러리는 큰 런타임 종속성이 없습니다. 최소 구성에서 SQLite는 표준 C 라이브러리의 다음 루틴 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="16b9101f24846717dcb86cc74d99a08aad5ead61" translate="yes" xml:space="preserve">
          <source>Libraries written in C++ or Java can generally only be used by applications written in the same language. It is difficult to get an application written in Haskell or Java to invoke a library written in C++. On the other hand, libraries written in C are callable from any programming language.</source>
          <target state="translated">C ++ 또는 Java로 작성된 라이브러리는 일반적으로 동일한 언어로 작성된 응용 프로그램에서만 사용할 수 있습니다. C ++로 작성된 라이브러리를 호출하기 위해 Haskell 또는 Java로 작성된 응용 프로그램을 얻는 것은 어렵습니다. 반면에 C로 작성된 라이브러리는 모든 프로그래밍 언어에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f218c8346bfddbca30ecf6b104e83b9f15b5e98" translate="yes" xml:space="preserve">
          <source>Library size optimizations.</source>
          <target state="translated">라이브러리 크기 최적화.</target>
        </trans-unit>
        <trans-unit id="3769a60d2f565f40c7f7836558211471f7d8a029" translate="yes" xml:space="preserve">
          <source>Like --file, use file FILE as the archive, but open the file using the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS&lt;/a&gt; so that the archive will be appended to the end of FILE if FILE already exists.</source>
          <target state="translated">--file과 마찬가지로 파일 FILE을 아카이브로 사용하지만 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/appendvfs.c&quot;&gt;apndvfs VFS를&lt;/a&gt; 사용하여 파일을 열어 파일이 이미 존재하는 경우 아카이브가 FILE의 끝에 추가되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="0b095c3da7d05183eec1d9c68eafa22989981539" translate="yes" xml:space="preserve">
          <source>Like contentless tables, external content tables do not support REPLACE conflict handling. Any operations that specify REPLACE conflict handling are handled using ABORT.</source>
          <target state="translated">컨텐츠가없는 테이블과 마찬가지로 외부 컨텐츠 테이블은 REPLACE 충돌 처리를 지원하지 않습니다. REPLACE 충돌 처리를 지정하는 모든 작업은 ABORT를 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="231d089dd7b27b9cd1c3006b16a6dc21b83bfb7e" translate="yes" xml:space="preserve">
          <source>Like other virtual table types, new FTS tables are created using a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. The module name, which follows the USING keyword, is either &quot;fts3&quot; or &quot;fts4&quot;. The virtual table module arguments may be left empty, in which case an FTS table with a single user-defined column named &quot;content&quot; is created. Alternatively, the module arguments may be passed a list of comma separated column names.</source>
          <target state="translated">다른 가상 테이블 유형과 마찬가지로 새 FTS 테이블은 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문을 사용하여 작성됩니다. USING 키워드 뒤에 나오는 모듈 이름은 &quot;fts3&quot;또는 &quot;fts4&quot;입니다. 가상 테이블 모듈 인수는 비워 둘 수 있으며,이 경우 &quot;content&quot;라는 단일 사용자 정의 열이있는 FTS 테이블이 작성됩니다. 또는 모듈 인수에 쉼표로 구분 된 열 이름 목록이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd7d7c85c83f29484f2e117602dc4bec07bd365d" translate="yes" xml:space="preserve">
          <source>Like sqlite3rbu_step(), if the vacuum operation has finished, sqlite3rbu_close() returns SQLITE_DONE. If the vacuum has not finished but no error has occurred, SQLITE_OK is returned. Or, if an error has occurred, an SQLite error code is returned. If an error occurred as part of a prior call to sqlite3rbu_step(), sqlite3rbu_close() returns the same error code.</source>
          <target state="translated">sqlite3rbu_step ()과 같이 진공 작업이 완료되면 sqlite3rbu_close ()는 SQLITE_DONE을 반환합니다. 진공이 완료되지 않았지만 오류가 발생하지 않은 경우 SQLITE_OK가 리턴됩니다. 또는 오류가 발생한 경우 SQLite 오류 코드가 리턴됩니다. sqlite3rbu_step ()에 대한 이전 호출의 일부로 오류가 발생한 경우 sqlite3rbu_close ()는 동일한 오류 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="7e8a69dbe9cf8dfea5767671aa0118b3491fc369" translate="yes" xml:space="preserve">
          <source>Like the &quot;.dump&quot; command, &quot;.recover&quot; attempts to convert the entire contents of a database file to text. The difference is that instead of reading data using the normal SQL database interface, &quot;.recover&quot; attempts to reassemble the database based on data extracted directly from as many database pages as possible. If the database is corrupt, &quot;.recover&quot; is usually able to recover data from all uncorrupted parts of the database, whereas &quot;.dump&quot; stops when the first sign of corruption is encountered.</source>
          <target state="translated">&quot;.dump&quot;명령과 마찬가지로 &quot;.recover&quot;는 데이터베이스 파일의 전체 내용을 텍스트로 변환하려고 시도합니다. 차이점은 일반적인 SQL 데이터베이스 인터페이스를 사용하여 데이터를 읽는 대신 &quot;.recover&quot;는 가능한 한 많은 데이터베이스 페이지에서 직접 추출한 데이터를 기반으로 데이터베이스를 다시 어셈블하려고 시도한다는 것입니다. 데이터베이스가 손상된 경우 &quot;.recover&quot;는 일반적으로 데이터베이스의 손상되지 않은 모든 부분에서 데이터를 복구 할 수있는 반면 첫 번째 손상 징후가 발생하면 &quot;.dump&quot;는 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="86f2b5c75e6099a6cf032f5fc9564b20f9285845" translate="yes" xml:space="preserve">
          <source>Limit Setting</source>
          <target state="translated">한계 설정</target>
        </trans-unit>
        <trans-unit id="dc00d8255b192a092dc29a4b67bc17a891ccaa1d" translate="yes" xml:space="preserve">
          <source>Limit the amount of output that &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; generates.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check가&lt;/a&gt; 생성 하는 출력량을 제한하십시오 .</target>
        </trans-unit>
        <trans-unit id="3bc4a74f4bc8f6fbe5d7600c2ffc0ce32f2df522" translate="yes" xml:space="preserve">
          <source>Limit the depth of recursion for JSON objects and arrays in order to avoid excess stack usage in the recursive descent parser. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052&lt;/a&gt;.</source>
          <target state="translated">재귀 강하 파서에서 과도한 스택 사용을 피하기 위해 JSON 객체 및 배열의 ​​재귀 깊이를 제한하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/981329adeef51011052&quot;&gt;981329adeef51011052에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="5c73db06777439f7e7a4e0b4ef090767959f015d" translate="yes" xml:space="preserve">
          <source>Limit the maximum amount of memory that SQLite will allocate using the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface. This helps prevent denial-of-service attacks. To find out how much heap space an application actually needs, run the it against typical inputs and then measure the maximum instantaneous memory usage with the &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater()&lt;/a&gt; interface. Set the hard heap limit to the maximum observed instantaneous memory usage plus some margin.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64 ()&lt;/a&gt; 인터페이스를 사용하여 할당 할 최대 메모리 양을 제한합니다 . 이는 서비스 거부 공격을 방지하는 데 도움이됩니다. 애플리케이션에 실제로 필요한 힙 공간을 확인하려면 일반적인 입력에 대해이를 실행 한 다음 &lt;a href=&quot;c3ref/memory_highwater&quot;&gt;sqlite3_memory_highwater ()&lt;/a&gt; 인터페이스로 최대 순간 메모리 사용량을 측정합니다 . 하드 힙 제한을 관찰 된 최대 순간 메모리 사용량과 약간의 여유로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="cd047048aa9c975f33600c7ec5b79b0145824c1c" translate="yes" xml:space="preserve">
          <source>Limitations And Caveats</source>
          <target state="translated">한계와 경고</target>
        </trans-unit>
        <trans-unit id="140fa43a5b0009e4451c320039ee7a35af9ef59d" translate="yes" xml:space="preserve">
          <source>Limitations Of The OpenDocument Presentation Format</source>
          <target state="translated">OpenDocument 프레젠테이션 형식의 제한</target>
        </trans-unit>
        <trans-unit id="61a0ae3b849d95fb8185df69b96d0ec676fb0688" translate="yes" xml:space="preserve">
          <source>Limits</source>
          <target state="translated">Limits</target>
        </trans-unit>
        <trans-unit id="da74bbdf0c5ba1732a1bcf36654960401f556496" translate="yes" xml:space="preserve">
          <source>Limits In SQLite</source>
          <target state="translated">SQLite의 한계</target>
        </trans-unit>
        <trans-unit id="2b535e43758af2a0faba7d7491e8ccc0937261f7" translate="yes" xml:space="preserve">
          <source>Lines that begin with &quot;#&quot; and that are not in the middle of an SQL statement are interpreted as comments.</source>
          <target state="translated">&quot;#&quot;으로 시작하고 SQL 문 중간에없는 행은 주석으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="56c40b8da457fccee36d2dd25cabffcd286e7be5" translate="yes" xml:space="preserve">
          <source>Link SQLite against a test program that runs approximately 30,000 SQL statements representing a typical workload.</source>
          <target state="translated">일반적인 워크로드를 나타내는 약 30,000 개의 SQL 문을 실행하는 테스트 프로그램에 SQLite를 링크하십시오.</target>
        </trans-unit>
        <trans-unit id="aa106ea45c187562ead66ff45b2537ad9d39d113" translate="yes" xml:space="preserve">
          <source>Linus Torvalds used different words to say much the same thing on the Git mailing list on 2006-06-27:</source>
          <target state="translated">Linus Torvalds는 다른 단어를 사용하여 2006-06-27의 Git 메일 링리스트에서 똑같은 말을했습니다.</target>
        </trans-unit>
        <trans-unit id="518aa8e09ec633a2ee7ca4061837886754889a59" translate="yes" xml:space="preserve">
          <source>List Of Constants:</source>
          <target state="translated">상수 목록 :</target>
        </trans-unit>
        <trans-unit id="c88854d7fb661e5a305fcbc6e6989b1500fbf8a5" translate="yes" xml:space="preserve">
          <source>List Of Functions:</source>
          <target state="translated">기능 목록 :</target>
        </trans-unit>
        <trans-unit id="02564776632cdeb522e81ac2cc1d466134257360" translate="yes" xml:space="preserve">
          <source>List Of Objects:</source>
          <target state="translated">객체 목록 :</target>
        </trans-unit>
        <trans-unit id="5976b759c2bbe27a2c436cf0d06c399c38f9db0a" translate="yes" xml:space="preserve">
          <source>List Of PRAGMAs</source>
          <target state="translated">PRAGMA 목록</target>
        </trans-unit>
        <trans-unit id="198f4f9677551df3e26744118c9e2c5bcd812876" translate="yes" xml:space="preserve">
          <source>List Of SQLite Constants</source>
          <target state="translated">SQLite 상수 목록</target>
        </trans-unit>
        <trans-unit id="b6b508ee374f53a81be169f4d47397a7a1f331e0" translate="yes" xml:space="preserve">
          <source>List Of SQLite Functions</source>
          <target state="translated">SQLite 함수 목록</target>
        </trans-unit>
        <trans-unit id="52d4b531b52e9862c4189d27482ae4e958f97760" translate="yes" xml:space="preserve">
          <source>List Of SQLite Objects</source>
          <target state="translated">SQLite 객체 목록</target>
        </trans-unit>
        <trans-unit id="68749615daec6b7db7287fc101bfd1803474c677" translate="yes" xml:space="preserve">
          <source>List Of Virtual Tables</source>
          <target state="translated">가상 테이블 목록</target>
        </trans-unit>
        <trans-unit id="9d1c029d1a64007ca37f5bf394575d02eef0574f" translate="yes" xml:space="preserve">
          <source>List each file as it is processed.</source>
          <target state="translated">처리되는대로 각 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="a5d1705cc809076e6266257a5ff3fa27b21bc1d4" translate="yes" xml:space="preserve">
          <source>List the contents of the archive. If no arguments are specified, then all files are listed. Otherwise, only those specified as arguments are. Currently, the --verbose option does not change the behaviour of this command. That may change in the future.</source>
          <target state="translated">아카이브 내용을 나열하십시오. 인수를 지정하지 않으면 모든 파일이 나열됩니다. 그렇지 않으면 인수로 지정된 것만 있습니다. 현재 --verbose 옵션은이 명령의 동작을 변경하지 않습니다. 앞으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27424535e9c380832791dbc03c67071412b07455" translate="yes" xml:space="preserve">
          <source>List the files in the archive.</source>
          <target state="translated">아카이브에 파일을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="615e9625e4457bad91a4957735c233d58d384ed8" translate="yes" xml:space="preserve">
          <source>List values on the right-hand side of IN are treated as a subquery that must be materialized. In other words, the previous statement acts as if it were:</source>
          <target state="translated">IN의 오른쪽에있는 목록 값은 구체화되어야하는 하위 쿼리로 처리됩니다. 다시 말해, 이전의 진술은 마치 마치</target>
        </trans-unit>
        <trans-unit id="f653dec85c31b3ff9b77fe72b2384cf749288d85" translate="yes" xml:space="preserve">
          <source>Listed below are some cases where it might make sense to add additional soundslike entries. The specific entries will depend on the application and the target language.</source>
          <target state="translated">다음은 소리 같은 항목을 추가하는 것이 합리적 일 수있는 경우입니다. 특정 항목은 응용 프로그램 및 대상 언어에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9a2828a10d993798b426c35ab47fdbeb8b46927a" translate="yes" xml:space="preserve">
          <source>Listen willingly to holy reading.</source>
          <target state="translated">성스러운 독서를 기꺼이 들으십시오.</target>
        </trans-unit>
        <trans-unit id="3805c697baba47d8b6fac8ff193aac1d5aae53c5" translate="yes" xml:space="preserve">
          <source>Literal Values (Constants)</source>
          <target state="translated">리터럴 값 (상수)</target>
        </trans-unit>
        <trans-unit id="3c11cc0f06e28252855afe306ffae2efa4d23a55" translate="yes" xml:space="preserve">
          <source>Literal strings contain no byte-order-marks.</source>
          <target state="translated">리터럴 문자열에는 바이트 순서 표시가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a95fd3f55e521532b15bff8dba2b3aa3f6401a1a" translate="yes" xml:space="preserve">
          <source>Literal value</source>
          <target state="translated">리터럴 값</target>
        </trans-unit>
        <trans-unit id="402377f4fa54f586c7bcf70486179fb514f52098" translate="yes" xml:space="preserve">
          <source>Literal values: numeric or string constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc57b0cbf2f7891171194ad1bf1b86f68a201597" translate="yes" xml:space="preserve">
          <source>LoC Recommended Storage Format</source>
          <target state="translated">LoC 권장 저장 형식</target>
        </trans-unit>
        <trans-unit id="c1fd24450afa2a8ca3ccb54f712f70e15f33b7ed" translate="yes" xml:space="preserve">
          <source>Load An Extension</source>
          <target state="translated">확장로드</target>
        </trans-unit>
        <trans-unit id="f9c032c8f6af23d9ff803554a14cbcd6e3037cb8" translate="yes" xml:space="preserve">
          <source>Load The Difference Between Tables Into A Session</source>
          <target state="translated">세션으로 테이블 간 차이로드</target>
        </trans-unit>
        <trans-unit id="9c794e6d2b53e1c944bf6d4f24a6f0f6be485378" translate="yes" xml:space="preserve">
          <source>Load the shared library or DLL file LIBRARY into SQLite prior to computing the differences. This can be used to add application-defined &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt; that are required by the schema.</source>
          <target state="translated">차이점을 계산하기 전에 공유 라이브러리 또는 DLL 파일 LIBRARY를 SQLite에로드하십시오. 스키마에 필요한 응용 프로그램 정의 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 를 추가하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1f26dca858775a9ffdc6b130413dfda84cf7cc4a" translate="yes" xml:space="preserve">
          <source>LoadAnalysis</source>
          <target state="translated">LoadAnalysis</target>
        </trans-unit>
        <trans-unit id="494260ec047bea19460fac6ca8324736557ff1c6" translate="yes" xml:space="preserve">
          <source>Loadable Extension Thunk</source>
          <target state="translated">로드 가능한 확장 기능</target>
        </trans-unit>
        <trans-unit id="a8855a7ba639af1775ee3c99ff39ec45827a09ba" translate="yes" xml:space="preserve">
          <source>Loadable extensions are C-code. To compile them on most unix-like operating systems, the usual command is something like this:</source>
          <target state="translated">로드 가능한 확장은 C 코드입니다. 대부분의 유닉스 계열 운영 체제에서 컴파일하려면 일반적인 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="16baeb9dc5c7b831d9570f59926debb8cb175348" translate="yes" xml:space="preserve">
          <source>Local DELETE</source>
          <target state="translated">로컬 삭제</target>
        </trans-unit>
        <trans-unit id="ad4c5e9ed0fc895a0d42b932b2926861699fe92c" translate="yes" xml:space="preserve">
          <source>Local INSERT</source>
          <target state="translated">로컬 삽입</target>
        </trans-unit>
        <trans-unit id="3e12d4ac47a72a1f8aa6fb2cd56dc176cf45a02b" translate="yes" xml:space="preserve">
          <source>Local UPDATE</source>
          <target state="translated">로컬 업데이트</target>
        </trans-unit>
        <trans-unit id="e88556ba53a549a6a9fbf15298a71732177e868b" translate="yes" xml:space="preserve">
          <source>Localtime modifier</source>
          <target state="translated">현지 시간 수정 자</target>
        </trans-unit>
        <trans-unit id="249beb765376acea4283a10da9faa975024e8fe9" translate="yes" xml:space="preserve">
          <source>Lock Name</source>
          <target state="translated">잠금 이름</target>
        </trans-unit>
        <trans-unit id="d4795eaa0bbabf21615f9f3e359ab0c2e3631ccd" translate="yes" xml:space="preserve">
          <source>Lock offset</source>
          <target state="translated">잠금 오프셋</target>
        </trans-unit>
        <trans-unit id="eb6bc036bb67cd66abad9bfabc9e6cb6a5eaef00" translate="yes" xml:space="preserve">
          <source>Lock the btree to which cursor P1 is pointing so that the btree cannot be written by an other cursor.</source>
          <target state="translated">다른 커서가 btree를 쓸 수 없도록 커서 P1이 가리키는 btree를 잠급니다.</target>
        </trans-unit>
        <trans-unit id="de20f3d1eb2301b2722958c2ff4a7d6bd4e9d117" translate="yes" xml:space="preserve">
          <source>Locking and Concurrency</source>
          <target state="translated">잠금 및 동시성</target>
        </trans-unit>
        <trans-unit id="668186cf26fd89e59f391d180f6666c5c03f0bfa" translate="yes" xml:space="preserve">
          <source>Locking and concurrency control are handled by the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt; pager module&lt;/a&gt;. The pager module is responsible for making SQLite &quot;ACID&quot; (Atomic, Consistent, Isolated, and Durable). The pager module makes sure changes happen all at once, that either all changes occur or none of them do, that two or more processes do not try to access the database in incompatible ways at the same time, and that once changes have been written they persist until explicitly deleted. The pager also provides a memory cache of some of the contents of the disk file.</source>
          <target state="translated">잠금 및 동시성 제어는 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=src/pager.c&quot;&gt;호출기 모듈에&lt;/a&gt; 의해 처리됩니다 . 호출기 모듈은 SQLite &quot;ACID&quot;(원자, 일관성, 격리 및 내구성)를 만드는 역할을합니다. 호출기 모듈을 사용하면 변경 사항이 한 번에 모두 발생하는지, 모든 변경 사항이 발생하거나 전혀 수행되지 않음, 두 개 이상의 프로세스가 동시에 호환되지 않는 방식으로 데이터베이스에 액세스하려고 시도하지 않고 변경 사항이 작성된 경우 명시 적으로 삭제 될 때까지 지속됩니다. 또한 호출기는 디스크 파일의 일부 내용에 대한 메모리 캐시를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="57d0597b0f360ba173ecb2d2a1f767cb5748ea2e" translate="yes" xml:space="preserve">
          <source>Long Option</source>
          <target state="translated">긴 옵션</target>
        </trans-unit>
        <trans-unit id="76889c4037fcda94eba3afe630f0b45c824942de" translate="yes" xml:space="preserve">
          <source>Long Term Support</source>
          <target state="translated">장기 지원</target>
        </trans-unit>
        <trans-unit id="fce206f4d564c7fbca45ff9aebf22500127c7c61" translate="yes" xml:space="preserve">
          <source>Long and short style options may be mixed. For example, the following are equivalent:</source>
          <target state="translated">길고 짧은 스타일 옵션이 혼합되어있을 수 있습니다. 예를 들어 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1a01077cb8c85bad9873673a9051f4ee19688494" translate="yes" xml:space="preserve">
          <source>Longer answer: If you declare a column of a table to be &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;, then whenever you insert a NULL into that column of the table, the NULL is automatically converted into an integer which is one greater than the largest value of that column over all other rows in the table, or 1 if the table is empty. Or, if the largest existing integer key 9223372036854775807 is in use then an unused key value is chosen at random. For example, suppose you have a table like this:</source>
          <target state="translated">더 긴 대답 : 테이블의 열을 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 로 선언하면 테이블의 해당 열에 NULL을 삽입 할 때마다 NULL은 자동으로 해당 열의 가장 큰 값보다 큰 정수로 변환됩니다 테이블의 다른 모든 행 또는 테이블이 비어있는 경우 1 또는 기존의 가장 큰 정수 키 9223372036854775807을 사용중인 경우 사용하지 않는 키 값이 임의로 선택됩니다. 예를 들어, 다음과 같은 테이블이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="6e9f2602cf3d1fd809e1312f33acfde2f150141f" translate="yes" xml:space="preserve">
          <source>Lookaside buffer allocations for new &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt;.</source>
          <target state="translated">새 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결에&lt;/a&gt; 대한 Lookaside 버퍼 할당 .</target>
        </trans-unit>
        <trans-unit id="04bd7a984d3646ac5eb9c18de550a3f1e203e5b1" translate="yes" xml:space="preserve">
          <source>Lookaside memory allocator</source>
          <target state="translated">Lookaside 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="fde137681e3baa6ad1143b905327accc0fb28e76" translate="yes" xml:space="preserve">
          <source>Lots of bug fixes.</source>
          <target state="translated">많은 버그 수정.</target>
        </trans-unit>
        <trans-unit id="990ee2bc3df995ba8afb44c45e674fd9a503ec05" translate="yes" xml:space="preserve">
          <source>Lots of little bug fixes.</source>
          <target state="translated">많은 작은 버그 수정.</target>
        </trans-unit>
        <trans-unit id="43de40a3e36d80f18de0a9c09a14efee88ae8d7f" translate="yes" xml:space="preserve">
          <source>Love chastity.</source>
          <target state="translated">순결을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="0bbc37af1e456bff56591e973337f95cdf967a70" translate="yes" xml:space="preserve">
          <source>Love fasting.</source>
          <target state="translated">금식을 사랑합니다.</target>
        </trans-unit>
        <trans-unit id="b7fcabbc1c2979a6343998251fb3b60ca2fcf13c" translate="yes" xml:space="preserve">
          <source>Love your enemies.</source>
          <target state="translated">적을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="868ab24a96d3a2771240294f216c1eb308fe2112" translate="yes" xml:space="preserve">
          <source>Love your juniors.</source>
          <target state="translated">후배들을 사랑하십시오.</target>
        </trans-unit>
        <trans-unit id="dcbca8259d75e252eae0048dd86f40340f8d0cd8" translate="yes" xml:space="preserve">
          <source>Low-Level Control Of Database Files</source>
          <target state="translated">데이터베이스 파일의 저수준 제어</target>
        </trans-unit>
        <trans-unit id="c47d12b1a2b47bc6fe16c9cb80aba1cd8b334072" translate="yes" xml:space="preserve">
          <source>Low-dependency</source>
          <target state="translated">Low-dependency</target>
        </trans-unit>
        <trans-unit id="9b49cf9a88d0eb7571f152a707297d6594a2f0d2" translate="yes" xml:space="preserve">
          <source>Low-level system error code</source>
          <target state="translated">저수준 시스템 오류 코드</target>
        </trans-unit>
        <trans-unit id="0be209fef2b5ea9e4e344d9742cbe9598db19564" translate="yes" xml:space="preserve">
          <source>Lowest precedence (loosest grouping).</source>
          <target state="translated">가장 낮은 우선 순위 (가장 낮은 그룹화).</target>
        </trans-unit>
        <trans-unit id="f41a055096fba2f5ebbddc8916d81727739dbdb3" translate="yes" xml:space="preserve">
          <source>Lt</source>
          <target state="translated">Lt</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="1e549c8c539e5dd3fb33fffd4ca9bec2df1c3d6b" translate="yes" xml:space="preserve">
          <source>M &amp;amp;times 2&lt;sup&gt;&lt;small&gt;E&lt;/small&gt;&lt;/sup&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4b52e49796d63ce942c6b8bfaa86fb7c20383ea" translate="yes" xml:space="preserve">
          <source>M is always ((U-12)*32/255)-23.</source>
          <target state="translated">M은 항상 ((U-12) * 32 / 255) -23입니다.</target>
        </trans-unit>
        <trans-unit id="1758fbe17031a1050ba647fef2f5a93784bd0bf5" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd2551d496e24af3eb24927ec50373a744a672" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;+M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="835c3f9feac04a1fedeecdc386e908df7274d7ab" translate="yes" xml:space="preserve">
          <source>M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">M&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="7e3ce80c0f5019f27debc96398dd7ba53b449b32" translate="yes" xml:space="preserve">
          <source>MASK</source>
          <target state="translated">MASK</target>
        </trans-unit>
        <trans-unit id="4110e0d1b0232ec2802f84b8b4f2d0c2fb3fbbb7" translate="yes" xml:space="preserve">
          <source>MASK bit 0x02 is set.</source>
          <target state="translated">마스크 비트 0x02가 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="ce71241b2af9817fe6f961964423ded83b2b2446" translate="yes" xml:space="preserve">
          <source>MATCH</source>
          <target state="translated">MATCH</target>
        </trans-unit>
        <trans-unit id="fb533649ca2f9e73b11b6bb948adb363f958ac9f" translate="yes" xml:space="preserve">
          <source>MEDIUMINT</source>
          <target state="translated">MEDIUMINT</target>
        </trans-unit>
        <trans-unit id="7c2c1a9b5cbb8b738dc37806d8007da0a4dabc51" translate="yes" xml:space="preserve">
          <source>MS-SQL</source>
          <target state="translated">MS-SQL</target>
        </trans-unit>
        <trans-unit id="e6557f13d224519bee5609849fa3b7fe2b045817" translate="yes" xml:space="preserve">
          <source>Macs are unix-like, but they do not follow the usual shared library conventions. To compile a shared library on a Mac, use a command like this:</source>
          <target state="translated">Mac은 유닉스와 비슷하지만 일반적인 공유 라이브러리 규칙을 따르지 않습니다. Mac에서 공유 라이브러리를 컴파일하려면 다음과 같은 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a1e5337bd6f525fef1a4495aefda7354ea999138" translate="yes" xml:space="preserve">
          <source>Made selected parameters in API functions &lt;b&gt;const&lt;/b&gt;. This should be fully backwards compatible.</source>
          <target state="translated">API 함수 &lt;b&gt;const&lt;/b&gt; 에서 선택된 매개 변수를 만들었습니다 . 이전 버전과 완전히 호환되어야합니다.</target>
        </trans-unit>
        <trans-unit id="debb142b11cd7000f7ccf5be052a02bcc1c7f9ef" translate="yes" xml:space="preserve">
          <source>Made the &lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop fuzzer&lt;/a&gt; a standard part of SQLite's &lt;a href=&quot;testing&quot;&gt;testing strategy&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#aflfuzz&quot;&gt;American Fuzzy Lop 퍼저&lt;/a&gt; 를 SQLite &lt;a href=&quot;testing&quot;&gt;테스트 전략&lt;/a&gt; 의 표준으로 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="aadd04e928883126f21deaf37b5282558e747d50" translate="yes" xml:space="preserve">
          <source>Made the CACHE_SIZE pragma persistent</source>
          <target state="translated">CACHE_SIZE pragma를 지속적으로 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="2d544f28a897acf54e3872442614c2de63e16acf" translate="yes" xml:space="preserve">
          <source>Magic number. 0x377f0682 or 0x377f0683</source>
          <target state="translated">매직 넘버. 0x377f0682 또는 0x377f0683</target>
        </trans-unit>
        <trans-unit id="a249757e280e4c1ed4596ef256151f0633cc5c86" translate="yes" xml:space="preserve">
          <source>Maintaining 100% MC/DC is laborious and time-consuming. The level of effort needed to maintain full-coverage testing is probably not cost effective for a typical application. However, we think that full-coverage testing is justified for a &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;very widely deployed&lt;/a&gt; infrastructure library like SQLite, and especially for a database library which by its very nature &quot;remembers&quot; past mistakes.</source>
          <target state="translated">100 % MC / DC를 유지하려면 많은 시간과 노력이 필요합니다. 전체 적용 범위 테스트를 유지하는 데 필요한 노력은 일반적인 응용 프로그램에는 비용 효과적이지 않을 수 있습니다. 그러나 전체 범위 테스트는 SQLite와 같이 &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;광범위하게 배포 된&lt;/a&gt; 인프라 라이브러리, 특히 본질적으로 과거 실수를 &quot;기억&quot;하는 데이터베이스 라이브러리에 적합 하다고 생각합니다 .</target>
        </trans-unit>
        <trans-unit id="0690809fdfc162c136b84c90c7f6551b5a7d6bb1" translate="yes" xml:space="preserve">
          <source>Maintaining Private Branches Of SQLite</source>
          <target state="translated">SQLite의 개인 브랜치 유지</target>
        </trans-unit>
        <trans-unit id="74db8285437f292d07f23511a8853dab08df8f69" translate="yes" xml:space="preserve">
          <source>Make &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; responsive to the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">확인 &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used ()&lt;/a&gt; 받는 반응 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB의&lt;/a&gt; 컴파일시 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="f178a74cc1dcf57fcc7b73994685f97569f4844f" translate="yes" xml:space="preserve">
          <source>Make AreFileApisANSI() a no-op macro in WinCE since WinCE does not support this function.</source>
          <target state="translated">WinCE는이 기능을 지원하지 않기 때문에 AreFileApisANSI ()를 WinCE에서 매크로가 아닌 매크로로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="07dc88b6cef4d75e2f7c3880e8647593525aa07e" translate="yes" xml:space="preserve">
          <source>Make CSV (comma separate value) output from the command-line shell more closely aligned to accepted practice</source>
          <target state="translated">명령 행 셸에서 CSV (쉼표로 분리 된 값) 출력을 허용 된 실습에 더 가깝게 정렬</target>
        </trans-unit>
        <trans-unit id="7ebdddec87e9007589d5ada3e116c78e26d2e69a" translate="yes" xml:space="preserve">
          <source>Make LIMIT work on a compound SELECT statement.</source>
          <target state="translated">LIMIT가 복합 SELECT 문에서 작동하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="67a20c818425dd125a3dee8478ee3f7563c8b234" translate="yes" xml:space="preserve">
          <source>Make a copy of registers P1..P1+P3 into registers P2..P2+P3.</source>
          <target state="translated">레지스터 P1..P1 + P3을 레지스터 P2..P2 + P3에 복사합니다.</target>
        </trans-unit>
        <trans-unit id="8d0b0f116d9ed8fdf1c047e6cff51269d6d08bd0" translate="yes" xml:space="preserve">
          <source>Make a distinction between numeric and text values when sorting. Text values sort according to memcmp(). Numeric values sort in numeric order.</source>
          <target state="translated">정렬 할 때 숫자와 텍스트 값을 구분하십시오. 텍스트 값은 memcmp ()에 따라 정렬됩니다. 숫자 값은 숫자 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="9f53feddfd33da18e3bb3466ea22bc837873fc9d" translate="yes" xml:space="preserve">
          <source>Make a shallow copy of register P1 into register P2.</source>
          <target state="translated">레지스터 P1의 얕은 복사본을 레지스터 P2에 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c4914cad6e6db40e49d46939d936ae678cbe7888" translate="yes" xml:space="preserve">
          <source>Make every effort to allocate a new page. Only return NULL if allocating a new page is effectively impossible.</source>
          <target state="translated">새 페이지를 할당하기 위해 모든 노력을 기울이십시오. 새 페이지를 할당 할 수없는 경우에만 NULL을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="94089eca234684dc20cbdb2f8434b3d3fb23b40c" translate="yes" xml:space="preserve">
          <source>Make peace with your adversary before the sun sets.</source>
          <target state="translated">해가지기 전에 적과 화해하십시오.</target>
        </trans-unit>
        <trans-unit id="b31d5954ede96c4a01bf917d9892337c3c9f6de7" translate="yes" xml:space="preserve">
          <source>Make sure ORDER BY puts rows in ascending order even if the DISTINCT operator is implemented using a descending index. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e&lt;/a&gt;.</source>
          <target state="translated">DISTINCT 연산자가 내림차순 인덱스를 사용하여 구현 된 경우에도 ORDER BY가 행을 오름차순으로 정렬해야합니다. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/c5ea805691bfc4204b1cb9e&quot;&gt;c5ea805691bfc4204b1cb9e에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="fd7437d47e0ca64701851f46718248492d235445" translate="yes" xml:space="preserve">
          <source>Make sure VIEWs are created after their corresponding TABLEs in the output of the &lt;b&gt;.dump&lt;/b&gt; command in the shell.</source>
          <target state="translated">쉘 의 &lt;b&gt;.dump&lt;/b&gt; 명령 출력에서 해당 테이블 뒤에 VIEW가 작성되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8fc01ec14bc51db67a6c7f295254a0473ee78c4" translate="yes" xml:space="preserve">
          <source>Make sure all individual database files have an EXCLUSIVE lock and a valid journal.</source>
          <target state="translated">모든 개별 데이터베이스 파일에 독점 잠금 및 유효한 저널이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="39ceab29d21e2433cf3cad2d290185c2cdda1b07" translate="yes" xml:space="preserve">
          <source>Make sure all rollback journal data has actually been written to the surface of the disk (and is not just being held in the operating system's or disk controllers cache) so that if a power failure occurs the data will still be there after power is restored.</source>
          <target state="translated">모든 롤백 저널 데이터가 실제로 디스크 표면에 기록되었고 (운영 체제 또는 디스크 제어기 캐시에만 보관되지 않음) 전원 장애가 발생해도 전원이 복원 된 후에도 데이터가 그대로 유지되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="faaff6cbdbf4873f3d095a4a0e2d87974475615a" translate="yes" xml:space="preserve">
          <source>Make sure functions expressions in the VALUES clause of an INSERT are correct.</source>
          <target state="translated">INSERT의 VALUES 절에있는 함수 표현식이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b3c87542457fbfa0848fd99500f7827664d328fc" translate="yes" xml:space="preserve">
          <source>Make sure that database filenames follow the 8+3 filename format and that they do not have an empty name or extension. In other words, the database filename must contain between 1 and 8 characters in the base name and between 1 and 3 characters in the extension. Blank extensions are not allowed.</source>
          <target state="translated">데이터베이스 파일 이름이 8 + 3 파일 이름 형식을 따르고 빈 이름이나 확장자가 없는지 확인하십시오. 즉, 데이터베이스 파일 이름은 기본 이름에 1-8 자, 확장자에 1-3 자 사이 여야합니다. 공백 확장은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="559ee78af19e40cf8fa346787df1709761be2f3c" translate="yes" xml:space="preserve">
          <source>Make sure that when a connection blocks on a RESERVED lock that it is able to continue after the lock is released. (Ticket #3093)</source>
          <target state="translated">예약 된 잠금에서 연결이 차단 될 때 잠금이 해제 된 후에도 계속 연결될 수 있는지 확인하십시오. (티켓 # 3093)</target>
        </trans-unit>
        <trans-unit id="6c2032f0b0a487670b92ae7b1f7c2a4d3713ca71" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata()&lt;/a&gt; values from multiple triggers within a single statement do not interfere with one another. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt;.</source>
          <target state="translated">단일 명령문 내 여러 트리거 의 &lt;a href=&quot;c3ref/get_auxdata&quot;&gt;sqlite3_set_auxdata ()&lt;/a&gt; 값이 서로 간섭하지 않도록하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/dc9b1c91&quot;&gt;dc9b1c91&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6638940c401bf7e1c92493be7672af3af206b2b" translate="yes" xml:space="preserve">
          <source>Make sure the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; interface does not zero-terminate the buffer if the buffer size is less than 1. Ticket #2341</source>
          <target state="translated">버퍼 크기가 1보다 작 으면 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 인터페이스가 버퍼를 0으로 종료하지 않는지 확인하십시오 . Ticket # 2341</target>
        </trans-unit>
        <trans-unit id="3bc85b9279a5981ff83181cec093f69c7042f9c4" translate="yes" xml:space="preserve">
          <source>Make sure the MIN() and MAX() optimizations work within subqueries.</source>
          <target state="translated">MIN () 및 MAX () 최적화가 서브 쿼리 내에서 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="58ff8f836097af00b92625ae2c5e983cf4412032" translate="yes" xml:space="preserve">
          <source>Make sure the ORDER BY LIMIT optimization (from check-in &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt;) works with IN operators on INTEGER PRIMARY KEYs. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c&lt;/a&gt;</source>
          <target state="translated">체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/559733b09e9630fa&quot;&gt;559733b09e&lt;/a&gt; 의 ORDER BY LIMIT 최적화 가 INTEGER PRIMARY KEY의 IN 연산자와 작동하는지 확인하십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/96c1454cbfd9509&quot;&gt;96c1454c에&lt;/a&gt; 대한 수정</target>
        </trans-unit>
        <trans-unit id="3ea00b4a5adf172672ba7e54a20e155f2d4f11b3" translate="yes" xml:space="preserve">
          <source>Make sure the TCL language interface works correctly with 64-bit integers on 64-bit machines.</source>
          <target state="translated">64 비트 시스템에서 TCL 언어 인터페이스가 64 비트 정수에서 올바르게 작동하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2c7d7b5412a65ed5d6ce615755d9929fa6d57cca" translate="yes" xml:space="preserve">
          <source>Make sure the in-memory backend response sanely if malloc() fails.</source>
          <target state="translated">malloc ()이 실패하는 경우 메모리 내 백엔드 응답이 제대로 작동하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="eae9ed5b156bcdd54a8967008569fef435a53021" translate="yes" xml:space="preserve">
          <source>Make sure the query optimizer checks dependencies on all terms of a compound SELECT statement. Ticket #2640.</source>
          <target state="translated">쿼리 최적화 프로그램이 복합 SELECT 문의 모든 용어에 대한 종속성을 확인해야합니다. 티켓 # 2640.</target>
        </trans-unit>
        <trans-unit id="30c0cf0484d7a5f504b6b728788d263a9e41fc0c" translate="yes" xml:space="preserve">
          <source>Make sure you type a semicolon at the end of each SQL command! The sqlite3 program looks for a semicolon to know when your SQL command is complete. If you omit the semicolon, sqlite3 will give you a continuation prompt and wait for you to enter more text to be added to the current SQL command. This feature allows you to enter SQL commands that span multiple lines. For example:</source>
          <target state="translated">각 SQL 명령 끝에 세미콜론을 입력하십시오! sqlite3 프로그램은 SQL 명령이 완료 될 때 알 수있는 세미콜론을 찾습니다. 세미콜론을 생략하면 sqlite3은 계속 프롬프트를 표시하고 현재 SQL 명령에 추가 할 텍스트를 더 입력 할 때까지 기다립니다. 이 기능을 사용하면 여러 줄에 걸쳐있는 SQL 명령을 입력 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f78a73d59843cf77efe52a3fb9a1c8bc577fb63" translate="yes" xml:space="preserve">
          <source>Make that script executable and put it on your $PATH. Then compile the kvtest program as follows:</source>
          <target state="translated">해당 스크립트를 실행 가능하게 만들고 $ PATH에 넣으십시오. 그런 다음 다음과 같이 kvtest 프로그램을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="55a8e3fef2599367be1f179f0eeae6e3f90c5562" translate="yes" xml:space="preserve">
          <source>Make the &quot;AS&quot; keyword optional again.</source>
          <target state="translated">&quot;AS&quot;키워드를 다시 선택 사항으로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="e8d3c7849aaf72378ce97fad0ef58bb50dfa844b" translate="yes" xml:space="preserve">
          <source>Make the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt; part of standard builds when compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; 옵션으로 컴파일 할 때 &lt;a href=&quot;dbstat&quot;&gt;dbstat 가상 테이블&lt;/a&gt; 을 표준 빌드의 일부로 만드십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf1a1fb81ef7a54777705fadfc53565c39e040a" translate="yes" xml:space="preserve">
          <source>Make the GLOB and LIKE operators functions that can be overridden by a programmer. This allows, for example, the LIKE operator to be changed to be case sensitive.</source>
          <target state="translated">프로그래머가 대체 할 수있는 GLOB 및 LIKE 연산자를 작동 시키십시오. 예를 들어, LIKE 연산자를 대소 문자를 구분하도록 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06d1ed76522acc5f77d35b87ff9bcb7713142c7d" translate="yes" xml:space="preserve">
          <source>Make the LIMIT clause work on subqueries. (ORDER BY still does not work, though.)</source>
          <target state="translated">LIQUE 절이 서브 쿼리에서 작동하도록하십시오. (ORDER BY는 여전히 작동하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="e949e24407b3c3e74908e043648105301add53c5" translate="yes" xml:space="preserve">
          <source>Make the library thread-safe. (The code is there and appears to work but has not been stressed.)</source>
          <target state="translated">라이브러리를 스레드로부터 안전하게 만듭니다. (코드가 있으며 작동하는 것처럼 보이지만 스트레스를받지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="aa1b502d7a3d8467cdd71e12de59017bd7bf7832" translate="yes" xml:space="preserve">
          <source>Make the os.h header file more robust in detecting when the compile is for Windows and when it is for Unix.</source>
          <target state="translated">컴파일이 Windows 용인지 유닉스 용인지를 감지하는 데 os.h 헤더 파일을보다 강력하게 만드십시오.</target>
        </trans-unit>
        <trans-unit id="5b70367d16489f70b60357dd49e971c66ecb7a25" translate="yes" xml:space="preserve">
          <source>Make use of OVERLAPPED in the windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to avoid some system calls and thereby obtain a performance improvement.</source>
          <target state="translated">일부 시스템 호출을 피하여 성능을 향상 시키 려면 Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서 OVERLAPPED를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb3c80011eafc56757b5115bd6da6df2d3cc0bcf" translate="yes" xml:space="preserve">
          <source>Make use of the one-pass UPDATE and DELETE query plans in the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; where appropriate.</source>
          <target state="translated">적절한 경우 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 에서 단일 패스 UPDATE 및 DELETE 쿼리 계획을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c7ffc0af1b5a78c06ebbd279554c53e269060be" translate="yes" xml:space="preserve">
          <source>MakeRecord</source>
          <target state="translated">MakeRecord</target>
        </trans-unit>
        <trans-unit id="decb5fb2e05d5246774c7c119193e5dd3eeab585" translate="yes" xml:space="preserve">
          <source>Makefile updates</source>
          <target state="translated">메이크 파일 업데이트</target>
        </trans-unit>
        <trans-unit id="3e75c9edc23a32990a13f91bc222c1cd2fb310c7" translate="yes" xml:space="preserve">
          <source>Makefile updates and miscellaneous bug fixes.</source>
          <target state="translated">Makefile 업데이트 및 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="bdecdca82af325fcab74535c838b3bad719fc7de" translate="yes" xml:space="preserve">
          <source>Makefile updates from A. Rottmann</source>
          <target state="translated">A. Rottmann에서 Makefile 업데이트</target>
        </trans-unit>
        <trans-unit id="1a74e86adcd0000bd7de1be192d074c821dd68c1" translate="yes" xml:space="preserve">
          <source>Making Other Kinds Of Table Schema Changes</source>
          <target state="translated">다른 종류의 테이블 스키마 변경</target>
        </trans-unit>
        <trans-unit id="e6fe063cab95ff9f5d6ec0129688c23c296059b5" translate="yes" xml:space="preserve">
          <source>Malformed UTF-8 that SQLite converts to a UTF-16 byte-order-mark is embedded at the beginning of an SQL string literal value inserted into an FTS3 table.</source>
          <target state="translated">SQLite가 UTF-16 바이트 순서 표시로 변환하는 잘못된 UTF-8은 FTS3 테이블에 삽입 된 SQL 문자열 리터럴 값의 시작 부분에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e30f6661f23230d01a3d07773b601db8982cabdd" translate="yes" xml:space="preserve">
          <source>Malformed database tests</source>
          <target state="translated">잘못된 데이터베이스 테스트</target>
        </trans-unit>
        <trans-unit id="aa578a91aad5dc4dab2da9a4bac602790d836ae2" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement (an ALTER TABLE that tries to rename a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; into one of its own &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;) causes an infinite loop and denial of service. &lt;a href=&quot;https://sqlite.org/src/info/eca0ba2cf4c0fdf7&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3505da2486b779eca8455a74c0a2213782342dc" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/1bc783da63d58b05&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b3de4ef5153133c67b1a8788b48babe0af12634" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/862974312edf00e9&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f05b51d00c5136f9765e2a5529ff25dd76521560" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference and in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/a80f84b511231204&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3223f276a85bbea2e40f22c66ab04105f353da0b" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a NULL pointer dereference in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension and denial-of-service. This is only possible when the optional &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; extension is deployed, which is not the case in default builds. &lt;a href=&quot;https://www.sqlite.org/src/info/cc0fb00a128fd077&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be787da663e373d3f7997d1441cd2ca035e3495f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read access to a NULL pointer and denial of service. &lt;a href=&quot;https://www.sqlite.org/src/info/7a5279a25c57adf1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7808ef1d93533f98b34a6af3e305d6a4a79902" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read of a NULL pointer in the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension, resulting in denial of service. &lt;a href=&quot;https://sqlite.org/src/info/a4dd148928ea65bd&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5500a4c4534dd4662f8932a169f8e6f4053c24" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service &lt;a href=&quot;https://www.sqlite.org/src/info/4374860b29383380&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a51de55d02f39c503f43bf8dbb67b4a981750f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read using an uninitialized pointer and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/af4556bb5c285c08&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f420ed40458097230e18bc609dc3d6070a139e7" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free memory error. &lt;a href=&quot;https://sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c7315e30c332568a87d33624f52296d256dba71" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a read-only use-after-free, possibly resulting in a incorrect output from the &lt;a href=&quot;fts3#snippet&quot;&gt;snippet()&lt;/a&gt; SQL function of the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; extension. There is no known way to exfiltrate data or crash the application using this bug. &lt;a href=&quot;https://sqlite.org/src/info/0d69f76f0865f962&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="605174f0d56c0319ea8c88e54fd141ec899039f3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes a uninitialized pointer reference and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/e2bddcd4c55ba3cb&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a3d15a3efb587f7e5d31ca19ff99f19bff90311" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an read past the end of a heap buffer. &lt;a href=&quot;https://sqlite.org/src/info/8f157e8010b22af0&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3460af9ab9b12af9da67324f2da63f63e80a6848" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/info/cba2a2a44cdf138a&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b341edff7ed671940a8d972691c324a8c7d62137" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes an uninitialized pointer read and denial-of-service. &lt;a href=&quot;https://www.sqlite.org/src/timeline?r=better-error-handling-1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be80211b17a199f937f0a9b644dfd18f1e2cecb3" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement causes read-only use-after-free of memory allocation if SQLite is compile with -DSQLITE_DEBUG. Does not affect release builds. &lt;a href=&quot;https://www.sqlite.org/src/info/4722bdab08cb1&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90aacfe82b6d869ef75232c639a3bc16d905426f" translate="yes" xml:space="preserve">
          <source>Malicious SQL statement involving the printf() SQL function results in an integer overflow which can overwrite the stack with over 2 billion bytes of 0x30 or 0x20 (ASCII '0' or ' '). Even though this is a stack overwrite, there is no known way to redirect control or otherwise escalate the level of harm. This is a denial-of-service attack only. &lt;a href=&quot;https://www.sqlite.org/src/info/23439ea582241138&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6314779095d53af544ef97df23a24554ee88bdd" translate="yes" xml:space="preserve">
          <source>Managing SQLite Archives from the command-line</source>
          <target state="translated">명령 행에서 SQLite 아카이브 관리</target>
        </trans-unit>
        <trans-unit id="3fbc66cdb2efde39d2ec8d74f242ca151b4515bd" translate="yes" xml:space="preserve">
          <source>Manifest Typing and BLOB Support</source>
          <target state="translated">매니페스트 입력 및 BLOB 지원</target>
        </trans-unit>
        <trans-unit id="bb55c1a865472533208270e05409a59df50af4d8" translate="yes" xml:space="preserve">
          <source>Manifest typing and BLOB support.</source>
          <target state="translated">매니페스트 타이핑 및 BLOB 지원</target>
        </trans-unit>
        <trans-unit id="1cc470a30ade4f894dfdc6d3819af02869f9a0ff" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using CROSS JOIN</source>
          <target state="translated">CROSS JOIN을 사용한 쿼리 계획 수동 제어</target>
        </trans-unit>
        <trans-unit id="cd08ce62fe23d2df3bf17c27439fcc586ae7eb2c" translate="yes" xml:space="preserve">
          <source>Manual Control Of Query Plans Using SQLITE_STAT Tables</source>
          <target state="translated">SQLITE_STAT 테이블을 사용한 쿼리 계획 수동 제어</target>
        </trans-unit>
        <trans-unit id="6ce25f14125bd349207477d6be9b5bb56a241bb2" translate="yes" xml:space="preserve">
          <source>Many SQLITE_OMIT_ macros inserts to omit features at compile-time and reduce the library footprint.</source>
          <target state="translated">많은 SQLITE_OMIT_ 매크로는 컴파일 타임에 기능을 생략하고 라이브러리 풋 프린트를 줄이기 위해 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="58bc21cac299bf4ec03f599485fd07e14baffb8d" translate="yes" xml:space="preserve">
          <source>Many SQLite functions return an integer result code from the set shown here in order to indicate success or failure.</source>
          <target state="translated">많은 SQLite 함수는 성공 또는 실패를 나타 내기 위해 여기에 표시된 세트에서 정수 결과 코드를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="29bbffe8721f3a2848d887e1fb7a366159ccdc97" translate="yes" xml:space="preserve">
          <source>Many Small Queries Are Efficient In SQLite</source>
          <target state="translated">많은 작은 쿼리가 SQLite에서 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="b88b7072aba4a1d9cfba91839cebc05836eb0907" translate="yes" xml:space="preserve">
          <source>Many applications destroy their &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; using calls to &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; at shutdown. Or, for example, an application that uses SQLite as its &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; might open &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; in response to a File/Open menu action and then destroy the corresponding &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in response to the File/Close menu.</source>
          <target state="translated">많은 응용 프로그램 은 종료시 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 호출을 사용하여 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 끊습니다 . 또는, 예를 들어, 그것으로 SQLite는 사용하는 응용 프로그램 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식을&lt;/a&gt; 열 수있는 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결을&lt;/a&gt; 파일 / 열기 메뉴 조치에 대한 응답으로 다음 해당 파괴 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 파일 / 닫기 메뉴에 응답합니다.</target>
        </trans-unit>
        <trans-unit id="e4e81b55d5c98ead21919f5ad70f41ad3433a3b2" translate="yes" xml:space="preserve">
          <source>Many applications use SQLite as a cache of relevant content from an enterprise RDBMS. This reduces latency, since most queries now occur against the local cache and avoid a network round-trip. It also reduces the load on the network and on the central database server. And in many cases, it means that the client-side application can continue operating during network outages.</source>
          <target state="translated">많은 애플리케이션이 SQLite를 엔터프라이즈 RDBMS의 관련 컨텐츠 캐시로 사용합니다. 이제 대부분의 쿼리가 로컬 캐시에 대해 발생하고 네트워크 왕복을 피하기 때문에 대기 시간이 줄어 듭니다. 또한 네트워크 및 중앙 데이터베이스 서버의로드를 줄입니다. 대부분의 경우 네트워크 중단시 클라이언트 측 응용 프로그램이 계속 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a456e7268dde3087ce48e51e3014a05bf0f0916" translate="yes" xml:space="preserve">
          <source>Many code simplifications and obscure bug fixes in support of providing &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100 % 분기 테스트 적용 범위&lt;/a&gt; 를 지원하는 많은 코드 단순화 및 모호한 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="a1bfd103f34c0767adc1c7bc9d7d6d545e23cabf" translate="yes" xml:space="preserve">
          <source>Many documentation updates</source>
          <target state="translated">많은 문서 업데이트</target>
        </trans-unit>
        <trans-unit id="3c83fd215f6013569c8872261f46c5842b6f52ba" translate="yes" xml:space="preserve">
          <source>Many examples of complete and working loadable extensions can be seen in the SQLite source tree in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory. Each file in that directory is a separate extension. Documentation is provided by a header comment on the file. Here are brief notes on a few of the extensions in the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext/misc&lt;/a&gt; subdirectory:</source>
          <target state="translated">완전하고 작동 가능한로드 가능한 확장의 많은 예는 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; 서브 디렉토리 의 SQLite 소스 트리에서 볼 수 있습니다 . 해당 디렉토리의 각 파일은 별도의 확장자입니다. 문서는 파일에 대한 헤더 주석으로 제공됩니다. 다음은 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc&quot;&gt;ext / misc&lt;/a&gt; 서브 디렉토리 의 몇몇 확장에 대한 간단한 참고 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="c27368aaf7a63c4c54dd85e130e6a371a0b652db" translate="yes" xml:space="preserve">
          <source>Many improvements and cleanups to the configure script</source>
          <target state="translated">구성 스크립트에 대한 많은 개선 및 정리</target>
        </trans-unit>
        <trans-unit id="478a301b607ffcc6373478ce0ad5e01e286e6440" translate="yes" xml:space="preserve">
          <source>Many improvements and enhancements to the shell.</source>
          <target state="translated">쉘에 대한 많은 개선 및 개선.</target>
        </trans-unit>
        <trans-unit id="86f119ce378fd6fb5c391277ea97047cef855bbe" translate="yes" xml:space="preserve">
          <source>Many improvements to the test suite. Test coverage now exceeded 98%</source>
          <target state="translated">테스트 스위트가 많이 개선되었습니다. 테스트 범위가 98 %를 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="ec9cc9f8a731e2c88a6a0e04dca8da72cc53d489" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations result in 20.3% more work for the same number of CPU cycles relative to the previous release. The cumulative performance increase since &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; is 61%. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 13.10 x64 with gcc 4.8.1 and -Os. Your performance may vary.)</source>
          <target state="translated">많은 미세 최적화는 이전 릴리스에 비해 동일한 수의 CPU주기에 대해 20.3 % 더 많은 작업을 수행합니다. &lt;a href=&quot;#version_3_8_0&quot;&gt;버전 3.8.0&lt;/a&gt; 이후 누적 성능 향상 은 61 %입니다. ( gcc 4.8.1 및 -Os가있는 Ubuntu 13.10 x64 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; 워크로드에서 &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; 를 사용하여 측정되었습니다 . 성능이 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="1070ccc184f5ee6e5132e8f78957c23f5d18aeb1" translate="yes" xml:space="preserve">
          <source>Many micro-optimizations, resulting in a library that is faster than the previous release.</source>
          <target state="translated">많은 미세 최적화로 인해 이전 릴리스보다 빠른 라이브러리가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ef73d713f7e1172e113f066199b34719f6daec88" translate="yes" xml:space="preserve">
          <source>Many minor bug fixes</source>
          <target state="translated">많은 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="d82e20d7c9c34c867cdbaaabca856ec1debc82ea" translate="yes" xml:space="preserve">
          <source>Many nuisance bugs fixed.</source>
          <target state="translated">많은 성가신 버그가 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="a8c23cdfb8fba87694bb2dbb013754a5354d8db3" translate="yes" xml:space="preserve">
          <source>Many of the parameters passed to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces are common across the entire family.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58cc54792f79ad7e4a6c20e286dbf7226ea88ce5" translate="yes" xml:space="preserve">
          <source>Many of the routines in the SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; return numeric result codes indicating either success or failure, and in the event of a failure, providing some idea of the cause of the failure. This document strives to explain what each of those numeric result codes means.</source>
          <target state="translated">SQLite &lt;a href=&quot;c3ref/intro&quot;&gt;C 언어 인터페이스&lt;/a&gt; 의 많은 루틴은 성공 또는 실패를 나타내는 숫자 결과 코드를 리턴하며 실패시 실패 원인을 알려줍니다. 이 문서는 각 숫자 결과 코드의 의미를 설명하기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="684a0cdf6fba65d365077c8562625db95e85aea3" translate="yes" xml:space="preserve">
          <source>Many operations, especially I/O intensive operations, can be faster since content does need to be copied between kernel space and user space.</source>
          <target state="translated">커널 공간과 사용자 공간간에 내용을 복사해야하기 때문에 많은 작업, 특히 I / O 집중 작업이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e75f87ad413b2b989beb9904a93bbc6902b68acd" translate="yes" xml:space="preserve">
          <source>Many programs use &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;, &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread()&lt;/a&gt;, and &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite()&lt;/a&gt; to create and manage files of data in home-grown formats. SQLite works particularly well as a replacement for these</source>
          <target state="translated">많은 프로그램이 &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen ()&lt;/a&gt; , &lt;a href=&quot;http://man.he.net/man3/fread&quot;&gt;fread ()&lt;/a&gt; 및 &lt;a href=&quot;http://man.he.net/man3/fwrite&quot;&gt;fwrite ()&lt;/a&gt; 를 사용하여 집에서 자른 형식으로 데이터 파일을 만들고 관리합니다. SQLite는 특히 이들을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="58c8d3506d92b491bec9b8982cb696fb925723f6" translate="yes" xml:space="preserve">
          <source>Many readers have recommended various third-party GUIs for Git that might do a better job of showing historical development activity. Maybe some of them do work better than native Git and/or GitHub, though they will all be hampered by the fact that Git does not preserve historical branch names across syncs. And even if those other tools are better, the fact that it is necessary to go to a third-party tool to get the information desired does not speak well of the core system.</source>
          <target state="translated">많은 독자들이 역사적 개발 활동을 더 잘 보여줄 수있는 다양한 타사 GUI를 Git에 추천했습니다. 어쩌면 그들 중 일부는 네이티브 Git 및 / 또는 GitHub보다 잘 작동하지만 Git이 동기화를 통해 역사적인 분기 이름을 유지하지 못한다는 사실 때문에 모두 방해받을 수 있습니다. 다른 도구가 더 나은 경우에도 원하는 정보를 얻기 위해 타사 도구를 사용해야한다는 사실은 핵심 시스템에 대해 잘 설명하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="57a3139bc8f04dd188f9b7807c96ec2f953e86dc" translate="yes" xml:space="preserve">
          <source>Many small performance optimizations.</source>
          <target state="translated">많은 작은 성능 최적화.</target>
        </trans-unit>
        <trans-unit id="575ebc9be57deafee12eee1cb275aca14943f68c" translate="yes" xml:space="preserve">
          <source>Many, many bug fixes and compatibility enhancements.</source>
          <target state="translated">많은 버그 수정 및 호환성 향상.</target>
        </trans-unit>
        <trans-unit id="305801fe337dfa5f8bad0f9f9e15662ddae791a8" translate="yes" xml:space="preserve">
          <source>Many, many minor bug fixes and documentation updates.</source>
          <target state="translated">많은 사소한 버그 수정 및 설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="35ddb236d4c17515cfe7146a42b5a461cee3e50c" translate="yes" xml:space="preserve">
          <source>Master Journal Pointer</source>
          <target state="translated">마스터 저널 포인터</target>
        </trans-unit>
        <trans-unit id="9abc1c7f8fc32d4d49746263693941601091cb5d" translate="yes" xml:space="preserve">
          <source>Master journal</source>
          <target state="translated">마스터 저널</target>
        </trans-unit>
        <trans-unit id="cb9cc1ceef6f81a9f36806b03b083dc9a2408c5e" translate="yes" xml:space="preserve">
          <source>Master journals</source>
          <target state="translated">마스터 저널</target>
        </trans-unit>
        <trans-unit id="7b5111bfd1045a8ecdd3554c1e9631c35ec01ef6" translate="yes" xml:space="preserve">
          <source>Matches if both query1 and query2 match.</source>
          <target state="translated">query1과 query2가 모두 일치하면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="1abd40ea027c30a30c262947ec1298a0d519b4e6" translate="yes" xml:space="preserve">
          <source>Matches if either query1 or query2 match.</source>
          <target state="translated">query1 또는 query2가 일치하면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="51cd172796c27ae8bf6aa95066f1e3c65189a939" translate="yes" xml:space="preserve">
          <source>Matches if query1 matches and query2 does not match.</source>
          <target state="translated">query1이 일치하고 query2가 일치하지 않으면 일치합니다.</target>
        </trans-unit>
        <trans-unit id="bd5c38104019f7a3a298ccf7253423afa28167b4" translate="yes" xml:space="preserve">
          <source>Matchinfo b flag</source>
          <target state="translated">Matchinfo B 플래그</target>
        </trans-unit>
        <trans-unit id="c836afd188ddb1668f2e9e6d198ffaad1a60d7a2" translate="yes" xml:space="preserve">
          <source>Matchinfo x flag</source>
          <target state="translated">Matchinfo x 플래그</target>
        </trans-unit>
        <trans-unit id="1cd52c33bad6e28fab493f91164add2569119727" translate="yes" xml:space="preserve">
          <source>Matchinfo y flag</source>
          <target state="translated">Matchinfo y 플래그</target>
        </trans-unit>
        <trans-unit id="eba78e6ccaca884931e9772ee282f8ff7b915236" translate="yes" xml:space="preserve">
          <source>Materializations of views and subqueries</source>
          <target state="translated">뷰 및 서브 쿼리의 구체화</target>
        </trans-unit>
        <trans-unit id="b44a1f3f0332ddaecfe37d45239aca1621b1d815" translate="yes" xml:space="preserve">
          <source>Mathematical operators (+, -, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) interpret both operands as if they were numbers. STRING or BLOB operands automatically convert into REAL or INTEGER values. If the STRING or BLOB looks like a real number (if it has a decimal point or an exponent) or if the value is outside the range that can be represented as a 64-bit signed integer, then it converts to REAL. Otherwise the operand converts to INTEGER. The implied type conversion of mathematical operands is slightly different from &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt; in that string and BLOB values that look like real numbers but have no fractional part are kept as REAL instead of being converted into INTEGER as they would be for &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to NUMERIC&lt;/a&gt;. The conversion from STRING or BLOB into REAL or INTEGER is performed even if it is lossy and irreversible. Some mathematical operators (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and |) expect INTEGER operands. For those operators, REAL operands are converted into INTEGER in the same way as a &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST to INTEGER&lt;/a&gt;. The &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp;, and | operators always return an INTEGER (or NULL) result, but the % operator returns either INTEGER or REAL (or NULL) depending on the type of its operands. A NULL operand on a mathematical operator yields a NULL result. An operand on a mathematical operator that does not look in any way numeric and is not NULL is converted to 0 or 0.0. Division by zero gives a result of NULL.</source>
          <target state="translated">수학 연산자 (+,-, *, /, %, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; 및 |)는 두 피연산자를 숫자 인 것처럼 해석합니다. STRING 또는 BLOB 피연산자는 자동으로 REAL 또는 INTEGER 값으로 변환됩니다. STRING 또는 BLOB가 실수처럼 보이거나 (소수점 또는 지수가있는 경우) 값이 64 비트 부호있는 정수로 표시 될 수있는 범위를 벗어나면 REAL로 변환됩니다. 그렇지 않으면 피연산자가 INTEGER로 변환됩니다. 수학 피연산자의 묵시적 타입 변환은 약간 다릅니다 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 숫자에&lt;/a&gt; 실수처럼 보이지만 더 소수 부분 대신 그들이 때처럼 INTEGER로 변환되는 REAL로 유지되지 않는 것을 해당 문자열 및 BLOB 값의 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;숫자에 CAST&lt;/a&gt;. STRING 또는 BLOB에서 REAL 또는 INTEGER 로의 변환은 손실되어 되돌릴 수없는 경우에도 수행됩니다. 일부 수학 연산자 (%, &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; 및 |)는 INTEGER 피연산자가 필요합니다. 이러한 연산자의 경우 REAL 피연산자는 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST에서 INTEGER&lt;/a&gt; 와 같은 방식으로 INTEGER로 변환됩니다 . &amp;lt;&amp;lt;, &amp;gt;&amp;gt;, &amp;amp; 및 | 연산자는 항상 INTEGER (또는 NULL) 결과를 반환하지만 % 연산자는 피연산자의 유형에 따라 INTEGER 또는 REAL (또는 NULL)을 반환합니다. 수학 연산자의 NULL 피연산자는 NULL 결과를 생성합니다. 숫자로 보이지 않고 NULL이 아닌 수학 연산자의 피연산자는 0 또는 0.0으로 변환됩니다. 0으로 나누면 NULL이됩니다.</target>
        </trans-unit>
        <trans-unit id="1d9b8da2be0b14b678f29575b8bd5d6d1b4664b6" translate="yes" xml:space="preserve">
          <source>MaxPgcnt</source>
          <target state="translated">MaxPgcnt</target>
        </trans-unit>
        <trans-unit id="6cf7147e1932d9bf8b6d38604abfcfd205a85da8" translate="yes" xml:space="preserve">
          <source>Maximum embedded payload fraction. Must be 64.</source>
          <target state="translated">최대 임베디드 페이로드 비율. 64 여야합니다.</target>
        </trans-unit>
        <trans-unit id="24d9373f317266755bd6dbb0fc6450a4905171c2" translate="yes" xml:space="preserve">
          <source>Maximum rowid</source>
          <target state="translated">최대 rowid</target>
        </trans-unit>
        <trans-unit id="5bc432c657fe4144bd45d936698c166acecd18fa" translate="yes" xml:space="preserve">
          <source>Maximum xShmLock index</source>
          <target state="translated">최대 xShmLock 색인</target>
        </trans-unit>
        <trans-unit id="77e5adb0194b8d8026832696c1f2c7818741ee2e" translate="yes" xml:space="preserve">
          <source>Maxopen parameter</source>
          <target state="translated">Maxopen 매개 변수</target>
        </trans-unit>
        <trans-unit id="0cccb688a9f1ffa766c4517a7aa3af7c04fd578c" translate="yes" xml:space="preserve">
          <source>May you do good and not evil</source>
          <target state="translated">선을 악하지 말고</target>
        </trans-unit>
        <trans-unit id="8b1b4d5262b0d017f35623d6ebe39d0b87517497" translate="yes" xml:space="preserve">
          <source>May you find forgiveness for yourself and forgive others</source>
          <target state="translated">자신을 용서하고 다른 사람을 용서해 주길 바랍니다</target>
        </trans-unit>
        <trans-unit id="580b0f5d2afa3fc028fd1cbe9832972ae188e8d2" translate="yes" xml:space="preserve">
          <source>May you share freely, never taking more than you give.</source>
          <target state="translated">당신이주는 것보다 더 많이 가져 가지 않고 자유롭게 공유하길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="19cd7d185cfd95a703e62d43597e9ae28e0646e5" translate="yes" xml:space="preserve">
          <source>Meaning</source>
          <target state="translated">Meaning</target>
        </trans-unit>
        <trans-unit id="4916cdca74bd290a34e18174e1358515f2ca12e0" translate="yes" xml:space="preserve">
          <source>Measure the performance for reading blobs from the database and from individual files using these commands:</source>
          <target state="translated">다음 명령을 사용하여 데이터베이스 및 개별 파일에서 Blob을 읽는 성능을 측정하십시오.</target>
        </trans-unit>
        <trans-unit id="32d3f574c379f02e466ab9d634b2afa7cedf3a39" translate="yes" xml:space="preserve">
          <source>Measure write performance by adding the --update option. This causes the blobs are overwritten in place with another random blob of exactly the same size.</source>
          <target state="translated">--update 옵션을 추가하여 쓰기 성능을 측정하십시오. 이로 인해 블롭이 정확히 동일한 크기의 다른 임의 블롭으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f8ae177706bfa8cf72569452745c1f4cb10ab6" translate="yes" xml:space="preserve">
          <source>Measured using cachegrind on Ubuntu 16.04 on x64 with gcc 5.4.0 and -Os.</source>
          <target state="translated">gcc 5.4.0 및 -Os가있는 x64의 Ubuntu 16.04에서 cachegrind를 사용하여 측정했습니다.</target>
        </trans-unit>
        <trans-unit id="b32c8e35e5b4b276295d8f91c2b0f1620f45e186" translate="yes" xml:space="preserve">
          <source>Measurements above were conducted using SQLite version &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;5594a121bf132a98&lt;/a&gt; from 2017-10-08.</source>
          <target state="translated">위의 측정은 &lt;a href=&quot;https://sqlite.org/src/timeline?c=5594a121bf132a98&quot;&gt;2017-10-08의&lt;/a&gt; SQLite 버전 5594a121bf132a98 을 사용하여 수행 되었습니다.</target>
        </trans-unit>
        <trans-unit id="201062f4cfcc7a2c58dc61b839eac4c989004f31" translate="yes" xml:space="preserve">
          <source>Measuring and Reducing CPU Usage in SQLite</source>
          <target state="translated">SQLite에서 CPU 사용량 측정 및 감소</target>
        </trans-unit>
        <trans-unit id="d815eeb251818f42b639c19483653cb9e9676a23" translate="yes" xml:space="preserve">
          <source>MemMax</source>
          <target state="translated">MemMax</target>
        </trans-unit>
        <trans-unit id="57b0394c856fac60e784f92bcfff68951cf81266" translate="yes" xml:space="preserve">
          <source>Memory Allocation Routines</source>
          <target state="translated">메모리 할당 루틴</target>
        </trans-unit>
        <trans-unit id="3a30329db6460c4ed15bebe4d427af9052e6678f" translate="yes" xml:space="preserve">
          <source>Memory Allocation Subsystem</source>
          <target state="translated">메모리 할당 서브 시스템</target>
        </trans-unit>
        <trans-unit id="f5bd12480983914d8406751d31133ba86381302d" translate="yes" xml:space="preserve">
          <source>Memory Allocator Statistics</source>
          <target state="translated">메모리 할당 자 통계</target>
        </trans-unit>
        <trans-unit id="8ee60155b22e766b4de73dc4f683f3ac25fa009b" translate="yes" xml:space="preserve">
          <source>Memory Slot</source>
          <target state="translated">메모리 슬롯</target>
        </trans-unit>
        <trans-unit id="ea9be83a8f265809341121ab4ff9c58d527a1bdd" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) 시작 시간 옵션과 &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; 컴파일 시간 옵션 의 조합을 사용하여 메모리 계정을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="83484b2c23e2c43deda0dd88234486f9158814f3" translate="yes" xml:space="preserve">
          <source>Memory accounting is disabled using a combination of the &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt;,...) start-time option and the &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; , ...) 시작 시간 옵션과 &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; 컴파일 시간 옵션 의 조합을 사용하여 메모리 계정을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c90d2f9e1fbdf5d88900e51c0817d79397425f44" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;../compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0으로 컴파일되지 않으면 메모리 할당 통계는 기본적으로 사용됩니다.이 경우 기본적으로 메모리 할당 통계는 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36fecd267945c46262e4527e9008734a419499a2" translate="yes" xml:space="preserve">
          <source>Memory allocation statistics are enabled by default unless SQLite is compiled with &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt;=0 in which case memory allocation statistics are disabled by default.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#default_memstatus&quot;&gt;SQLITE_DEFAULT_MEMSTATUS&lt;/a&gt; = 0으로 컴파일되지 않으면 메모리 할당 통계는 기본적으로 사용됩니다.이 경우 기본적으로 메모리 할당 통계는 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30cf1b800d03b60f9a295eac5e3ee911eb40a567" translate="yes" xml:space="preserve">
          <source>Memory allocation, caseless string comparison routines, portable text-to-number conversion routines, and other utilities are located in &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c&lt;/a&gt;. Symbol tables used by the parser are maintained by hash tables found in &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c&lt;/a&gt; source file contains Unicode conversion subroutines. SQLite has its own private implementation of &lt;a href=&quot;printf&quot;&gt;printf()&lt;/a&gt; (with some extensions) in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; and its own pseudo-random number generator (PRNG) in &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;random.c&lt;/a&gt;.</source>
          <target state="translated">메모리 할당, 대소 문자가없는 문자열 비교 루틴, 이식 가능한 텍스트-숫자 변환 루틴 및 기타 유틸리티는 &lt;a href=&quot;https://sqlite.org/src/file/src/util.c&quot;&gt;util.c에&lt;/a&gt; 있습니다. 파서가 사용하는 심볼 테이블은 &lt;a href=&quot;https://sqlite.org/src/file/src/hash.c&quot;&gt;hash.c&lt;/a&gt; 에있는 해시 테이블에 의해 유지됩니다 . &lt;a href=&quot;https://sqlite.org/src/file/src/utf.c&quot;&gt;utf.c의&lt;/a&gt; 소스 파일은 유니 코드 변환 서브 루틴이 포함되어 있습니다. SQLite는 &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; 자체에 &lt;a href=&quot;printf&quot;&gt;printf ()&lt;/a&gt; (일부 확장자 포함)를 자체 구현 하고 random.c 에 자체 의사 난수 생성기 (PRNG)를 &lt;a href=&quot;https://sqlite.org/src/file/src/random.c&quot;&gt;가지고&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="8351f935d7e0b92d4dbd88ff6014fc3cfebc6b06" translate="yes" xml:space="preserve">
          <source>Memory statistics</source>
          <target state="translated">메모리 통계</target>
        </trans-unit>
        <trans-unit id="0b3951c84915f2636f64c4da056f2bbaa63121ac" translate="yes" xml:space="preserve">
          <source>Memory to hold the information returned by &lt;b&gt;sqlite_get_table&lt;/b&gt; is obtained from malloc(). But the calling function should not try to free this information directly. Instead, pass the complete table to &lt;b&gt;sqlite_free_table&lt;/b&gt; when the table is no longer needed. It is safe to call &lt;b&gt;sqlite_free_table&lt;/b&gt; with a NULL pointer such as would be returned if the result set is empty.</source>
          <target state="translated">&lt;b&gt;sqlite_get_table&lt;/b&gt; 에 의해 리턴 된 정보를 보유하는 메모리 는 malloc ()에서 확보됩니다. 그러나 호출 함수는이 정보를 직접 해제하지 않아야합니다. 대신, 테이블이 더 이상 필요하지 않으면 전체 테이블을 &lt;b&gt;sqlite_free_table에&lt;/b&gt; 전달하십시오 . 결과 세트가 비어 있으면 리턴되는 NULL 포인터로 &lt;b&gt;sqlite_free_table&lt;/b&gt; 을 호출하는 것이 안전합니다 .</target>
        </trans-unit>
        <trans-unit id="0ebf6aa26b7b4fd9c6127be506bafbc4c2292df8" translate="yes" xml:space="preserve">
          <source>Memory-Mapped I/O</source>
          <target state="translated">메모리 매핑 된 I / O</target>
        </trans-unit>
        <trans-unit id="7640161f9a59fd693f768ecd9272e3177311b46c" translate="yes" xml:space="preserve">
          <source>Memsys4 and memsys6 were experimental memory allocators introduced in around 2007 and subsequently removed from the source tree in around 2008, after it became clear that they added no new value.</source>
          <target state="translated">Memsys4 및 memsys6은 2007 년경에 소개 된 실험용 메모리 할당 자였으며 이후 새로운 가치가 추가되지 않은 것이 분명해진 후 2008 년경 소스 트리에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="53e5e9eaf00f6f480e84b07b830bf50ed69b3504" translate="yes" xml:space="preserve">
          <source>Merge development changes into the main trunk. Future work toward using a BTree file structure will use a separate CVS source tree. This CVS tree will continue to support the GDBM version of SQLite only.</source>
          <target state="translated">개발 변경 사항을 기본 트렁크로 병합합니다. BTree 파일 구조를 사용하기위한 향후 작업에는 별도의 CVS 소스 트리가 사용됩니다. 이 CVS 트리는 SQLite의 GDBM 버전 만 계속 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1c69f87311ee49961b7db4c6959bf9e564173753" translate="yes" xml:space="preserve">
          <source>MergePatch can add, modify, or delete elements of a JSON Object, and so for JSON Objects, the json_patch() routine is a generalized replacement for &lt;a href=&quot;json1#jset&quot;&gt;json_set()&lt;/a&gt; and &lt;a href=&quot;json1#jrm&quot;&gt;json_remove()&lt;/a&gt;. However, MergePatch treats JSON Array objects as atomic. MergePatch cannot append to an Array nor modify individual elements of an Array. It can only insert, replace, or delete the whole Array as a single unit. Hence, json_patch() is not as useful when dealing with JSON that includes Arrays, especially Arrays with lots of substructure.</source>
          <target state="translated">MergePatch는 JSON 객체의 요소를 추가, 수정 또는 삭제할 수 있으므로 JSON 객체의 경우 json_patch () 루틴은 &lt;a href=&quot;json1#jset&quot;&gt;json_set ()&lt;/a&gt; 및 &lt;a href=&quot;json1#jrm&quot;&gt;json_remove ()&lt;/a&gt; 의 일반화 된 대체입니다 . 그러나 MergePatch는 JSON 배열 객체를 원자로 취급합니다. MergePatch는 Array에 추가하거나 Array의 개별 요소를 수정할 수 없습니다. 전체 어레이를 단일 장치로 삽입, 교체 또는 삭제할 수 있습니다. 따라서 json_patch ()는 배열, 특히 많은 하위 구조가있는 배열을 포함하는 JSON을 처리 할 때 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b34856a8252222662370c82e139676a40460db4d" translate="yes" xml:space="preserve">
          <source>Merged the &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; extension into trunk.</source>
          <target state="translated">&lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 확장을 트렁크에 병합했습니다 .</target>
        </trans-unit>
        <trans-unit id="dbaecd82c952801d0bb82c4bd7a41de66b9fda44" translate="yes" xml:space="preserve">
          <source>Metadata is returned by writing to the memory locations passed as the 5th and subsequent parameters to this function. Any of these arguments may be NULL, in which case the corresponding element of metadata is omitted.</source>
          <target state="translated">메타 데이터는이 함수에 5 번째 매개 변수로 전달 된 메모리 위치에 쓰면 반환됩니다. 이러한 인수는 NULL 일 수 있으며,이 경우 해당 메타 데이터 요소가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="4d3732872bb2a9906cc1153aeb2590dd048c19aa" translate="yes" xml:space="preserve">
          <source>Method (2) offers a midpoint between (1) and (3). Using this method, a query such as '1s*' will match documents that contain the literal token &quot;1st&quot;, but not &quot;first&quot; (assuming the tokenizer is not able to provide synonyms for prefixes). However, a non-prefix query like '1st' will match against &quot;1st&quot; and &quot;first&quot;. This method does not require extra disk space, as no extra entries are added to the FTS index. On the other hand, it may require more CPU cycles to run MATCH queries, as separate queries of the FTS index are required for each synonym.</source>
          <target state="translated">방법 (2)는 (1)과 (3) 사이의 중간 점을 제공합니다. 이 방법을 사용하면 '1s *'와 같은 쿼리는 리터럴 토큰 &quot;1st&quot;를 포함하지만 &quot;first&quot;는 포함하지 않은 문서와 일치합니다 (토큰 izer가 접두사에 동의어를 제공 할 수 없다고 가정). 그러나 '1st'와 같은 접두사가 아닌 쿼리는 &quot;1st&quot;및 &quot;first&quot;와 일치합니다. FTS 인덱스에 추가 항목이 추가되지 않으므로이 방법에는 추가 디스크 공간이 필요하지 않습니다. 반면, 각 동의어에 FTS 인덱스의 별도 쿼리가 필요하므로 MATCH 쿼리를 실행하려면 더 많은 CPU주기가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1df213a45649b1f66258f5768182bafcd559f0b9" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b9983b06e527d46d817373bc15d13089f4d3e12" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;#sqlite3_snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="547fb3fd92f4ba766d2b81080903dd2fa70ddd7a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;#sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ba8e151eaa184a6fb4bcf2ae01f52e3682b9b04" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05bb53e8fd80fd00914dd4034f12bb335994738a" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp()&lt;/a&gt;, &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;snapshot_cmp&quot;&gt;sqlite3_snapshot_cmp ()&lt;/a&gt; , &lt;a href=&quot;snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; , &lt;a href=&quot;snapshot_recover&quot;&gt;sqlite3_snapshot_recover ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80b86f6f0bb9183c80c83fe634331b034c5a3b6c" translate="yes" xml:space="preserve">
          <source>Methods: &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add()&lt;/a&gt;, &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output()&lt;/a&gt;</source>
          <target state="translated">메소드 : &lt;a href=&quot;sqlite3changegroup_add&quot;&gt;sqlite3changegroup_add ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changegroup_output&quot;&gt;sqlite3changegroup_output ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91126b8550d89c2cabd56ad5c8ea6415436ef4e7" translate="yes" xml:space="preserve">
          <source>Millions and millions of test cases</source>
          <target state="translated">수백만 및 수백만 개의 테스트 사례</target>
        </trans-unit>
        <trans-unit id="8cb901663cd153748076b7a4eed655ac9c9ceb63" translate="yes" xml:space="preserve">
          <source>Minimum embedded payload fraction. Must be 32.</source>
          <target state="translated">최소 임베디드 페이로드 비율. 32 여야합니다.</target>
        </trans-unit>
        <trans-unit id="9f5a0ef3646738848b65efb74e98db2b2c5a359b" translate="yes" xml:space="preserve">
          <source>Minimum rowid</source>
          <target state="translated">최소 rowid</target>
        </trans-unit>
        <trans-unit id="62a01943e842ea4e97ec6b470d86e59a45ec37a1" translate="yes" xml:space="preserve">
          <source>Minor revisions to the website.</source>
          <target state="translated">웹 사이트의 사소한 수정.</target>
        </trans-unit>
        <trans-unit id="e2f772b3f3e4226648620e3b2d22fc9e06b7af3b" translate="yes" xml:space="preserve">
          <source>Minor syntactic changes to support a wider variety of compilers.</source>
          <target state="translated">더 다양한 컴파일러를 지원하도록 사소한 구문 변경.</target>
        </trans-unit>
        <trans-unit id="a207d914072a9004f7af9edb9092f93397750bdb" translate="yes" xml:space="preserve">
          <source>Minor tweaks to other code to make it run a little faster.</source>
          <target state="translated">약간 더 빠르게 실행되도록 다른 코드로 조정합니다.</target>
        </trans-unit>
        <trans-unit id="5f2cbd107037ed23248e5058a7a64cd6bae05468" translate="yes" xml:space="preserve">
          <source>Miscellaneous</source>
          <target state="translated">Miscellaneous</target>
        </trans-unit>
        <trans-unit id="b80fca6a605a77935ff5f5e3122df5de2dfd1555" translate="yes" xml:space="preserve">
          <source>Miscellaneous &lt;a href=&quot;cpu#microopt&quot;&gt;microoptimizations&lt;/a&gt; reduce CPU usage by about 2.1%.</source>
          <target state="translated">기타 &lt;a href=&quot;cpu#microopt&quot;&gt;미세 최적화&lt;/a&gt; 는 CPU 사용량을 약 2.1 % 줄입니다.</target>
        </trans-unit>
        <trans-unit id="28c8a44394b5bc456bad4c873373e406d652fe87" translate="yes" xml:space="preserve">
          <source>Miscellaneous code size optimizations and bug fixes</source>
          <target state="translated">기타 코드 크기 최적화 및 버그 수정</target>
        </trans-unit>
        <trans-unit id="bbb81db24ef06a2153135306601290fda608c2da" translate="yes" xml:space="preserve">
          <source>Miscellaneous documentation enhancements.</source>
          <target state="translated">기타 문서 향상.</target>
        </trans-unit>
        <trans-unit id="98990a8e0a243a1fdf56c721a0da9558936ac95e" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations reduce CPU usage by more than 7% on common workloads. Most optimization in this release has been on the front-end (&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;).</source>
          <target state="translated">기타 마이크로 최적화는 일반적인 워크로드에서 CPU 사용량을 7 % 이상 줄입니다. 이 릴리스에서 대부분의 최적화는 프론트 엔드 ( &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; )에있었습니다.</target>
        </trans-unit>
        <trans-unit id="fbdfeb6f538d5f7f87b9990239ba0793588dd6eb" translate="yes" xml:space="preserve">
          <source>Miscellaneous micro-optimizations result in 22.3% more work for the same number of CPU cycles relative to the previous release. SQLite now runs twice as fast as &lt;a href=&quot;#version_3_8_0&quot;&gt;version 3.8.0&lt;/a&gt; and three times as fast as &lt;a href=&quot;#version_3_3_9&quot;&gt;version 3.3.9&lt;/a&gt;. (Measured using &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; on the &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; workload on Ubuntu 14.04 x64 with gcc 4.8.2 and -Os. Your performance may vary.)</source>
          <target state="translated">기타 미세 최적화를 통해 이전 릴리스에 비해 동일한 수의 CPU주기에 대해 22.3 % 더 많은 작업이 발생합니다. SQLite는 이제 &lt;a href=&quot;#version_3_8_0&quot;&gt;버전 3.8.0&lt;/a&gt; 보다 두 배 빠르며 &lt;a href=&quot;#version_3_3_9&quot;&gt;버전 3.3.9&lt;/a&gt; 보다 세 배 빠릅니다 . ( gcc 4.8.2 및 -Os가있는 Ubuntu 14.04 x64 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact/83f6b3318f7ee&quot;&gt;speedtest1.c&lt;/a&gt; 워크로드에서 &lt;a href=&quot;http://valgrind.org/docs/manual/cg-manual.html&quot;&gt;cachegrind&lt;/a&gt; 를 사용하여 측정되었습니다 . 성능이 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="fc459de1c05b709bda425ad3c5816738720eebc5" translate="yes" xml:space="preserve">
          <source>Miscellaneous minor bug fixes</source>
          <target state="translated">기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="44d1c5c9aa54a9db91e7e7fe347ac18190d724ed" translate="yes" xml:space="preserve">
          <source>Miscellaneous optimizations result in a 2% reduction in &lt;a href=&quot;cpu&quot;&gt;CPU cycles used&lt;/a&gt;.</source>
          <target state="translated">기타 최적화로 인해 &lt;a href=&quot;cpu&quot;&gt;사용&lt;/a&gt; 된 CPU주기 가 2 % 감소 합니다.</target>
        </trans-unit>
        <trans-unit id="f1774acabb62d5801f41470f6cd189b2c0aaaf3c" translate="yes" xml:space="preserve">
          <source>Miscellaneous performance enhancements</source>
          <target state="translated">기타 성능 향상</target>
        </trans-unit>
        <trans-unit id="276e26893215e7c8d37e726040961fa631182ebb" translate="yes" xml:space="preserve">
          <source>Miscellaneous problem words such as &quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;.</source>
          <target state="translated">&quot;debt&quot;, &quot;tsetse&quot;, &quot;Nguyen&quot;, &quot;Van Nuyes&quot;와 같은 기타 문제 단어</target>
        </trans-unit>
        <trans-unit id="4f0711bb69728ffde416a549e0f91f702e273516" translate="yes" xml:space="preserve">
          <source>Misformatted records</source>
          <target state="translated">형식이 잘못된 레코드</target>
        </trans-unit>
        <trans-unit id="0c46987b5699d45998eb4a1f03a81d222b78e342" translate="yes" xml:space="preserve">
          <source>Missing callback</source>
          <target state="translated">콜백 누락</target>
        </trans-unit>
        <trans-unit id="55fd1e5df760c82f67c5509ea619f439d18e5b37" translate="yes" xml:space="preserve">
          <source>Missing or surplus index entries</source>
          <target state="translated">누락되거나 과잉 색인 항목</target>
        </trans-unit>
        <trans-unit id="96732b61a8d377ada7b914c38aba1cf0d28297dd" translate="yes" xml:space="preserve">
          <source>Missing pages</source>
          <target state="translated">누락 된 페이지</target>
        </trans-unit>
        <trans-unit id="a1570b7a7267e412717981829df93815ef1f5214" translate="yes" xml:space="preserve">
          <source>Modern filesystems operate faster when disk accesses are sequential. Hence, SQLite will run faster if the content of the database file is on sequential pages. To find out what fraction of the pages in a database are sequential (and thus obtain a measurement that might be useful in determining when to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;), run a query like the following:</source>
          <target state="translated">최신 파일 시스템은 디스크 액세스가 순차적 일 때 더 빠르게 작동합니다. 따라서 데이터베이스 파일의 컨텐츠가 순차 페이지에있는 경우 SQLite가 더 빠르게 실행됩니다. 데이터베이스에서 페이지의 일부가 순차적인지 확인하여 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 시기를 결정하는 데 유용한 측정 값을 얻으려면 다음과 같이 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="213d5e141cc4f1fbdb215e4e1d09c9f135e23841" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; interface to support a wider range of embedded systems. See &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; for additional information. *** Potentially incompatible change ***</source>
          <target state="translated">광범위한 임베디드 시스템을 지원 하기 위해 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 인터페이스를 수정했습니다 . 자세한 내용은 &lt;a href=&quot;35to36&quot;&gt;35to36.html&lt;/a&gt; 을 참조하십시오 . *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="846a3f594ccb25f4d8b90bf39076621c7a3da386" translate="yes" xml:space="preserve">
          <source>Modifications to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; so that the parser tables are 4 times smaller.</source>
          <target state="translated">파서 테이블이 4 배 더 작도록 &lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="a373b9c05e3506597302158ddcc81e7b79ce6310" translate="yes" xml:space="preserve">
          <source>Modified &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; to remove the &quot;+4&quot; magic number in the buffer size computation.</source>
          <target state="translated">버퍼 크기 계산에서 &quot;+4&quot;매직 번호를 제거하도록 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigscratch&quot;&gt;SQLITE_CONFIG_SCRATCH&lt;/a&gt; 를 수정 했습니다 .</target>
        </trans-unit>
        <trans-unit id="7ae047108ffb132cb41d3775cac528b7c36bd9c6" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to print the schema for the built-in SQLITE_MASTER table, if explicitly requested.</source>
          <target state="translated">명시 적으로 요청 된 경우 내장 SQLITE_MASTER 테이블의 스키마를 인쇄 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘 프로그램을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="64b762eca0515a688c77ad3f10cd0b574a4463f3" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell program to use the new interface routines.</source>
          <target state="translated">새로운 인터페이스 루틴을 사용 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘 프로그램을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="9bea3abf3349ced7a2bd684045cab38caa6bf680" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to make use of the new sqlite_get_table() API in order to print a list of tables in multiple columns, similar to the way &quot;ls&quot; prints filenames.</source>
          <target state="translated">&quot;ls&quot;가 파일 이름을 인쇄하는 방식과 유사하게 여러 열로 테이블 목록을 인쇄하기 위해 새로운 sqlite_get_table () API를 사용 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="d9d09adf1be852d2030f454ddcb0fb1bbde85e4b" translate="yes" xml:space="preserve">
          <source>Modified the &lt;b&gt;sqlite&lt;/b&gt; shell to print a semicolon at the end of each CREATE statement in the output of the &quot;.schema&quot; command.</source>
          <target state="translated">&quot;.schema&quot;명령의 출력에서 ​​각 CREATE 문의 끝에 세미콜론을 인쇄 하도록 &lt;b&gt;sqlite&lt;/b&gt; 쉘을 수정했습니다 .</target>
        </trans-unit>
        <trans-unit id="cecf75f0a6c4e051f8158a879b4378a1d3e737c4" translate="yes" xml:space="preserve">
          <source>Modified the B-Tree and Pager modules so that disk pages that do not contain real data (free pages) are not journaled and are not written from memory back to the disk when they change. This does not impact database integrity, since the pages contain no real data, but it does make large INSERT operations about 2.5 times faster and large DELETEs about 5 times faster.</source>
          <target state="translated">실제 데이터가없는 디스크 페이지 (사용 가능한 페이지)가 저널링되지 않고 변경 될 때 메모리에서 디스크로 다시 쓰지 않도록 B-Tree 및 Pager 모듈을 수정했습니다. 페이지에 실제 데이터가 포함되어 있지 않기 때문에 데이터베이스 무결성에 영향을 미치지 않지만 큰 INSERT 작업은 약 2.5 배 빠르며 큰 DELETE는 약 5 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="2c4d4de8cb2205ec2b07c88e0fe421ab99dc0aaa" translate="yes" xml:space="preserve">
          <source>Modified the journal file format to make it more resistant to corruption that can occur after an OS crash or power failure.</source>
          <target state="translated">OS 충돌 또는 전원 장애 후 발생할 수있는 손상에 대한 내성이 향상되도록 저널 파일 형식을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="3a7ea294bf33134dce4b142b8b7182de29b978b2" translate="yes" xml:space="preserve">
          <source>Modifiers</source>
          <target state="translated">Modifiers</target>
        </trans-unit>
        <trans-unit id="2d258a9a354e69d26a5737aed0d98ba4a12d4ab3" translate="yes" xml:space="preserve">
          <source>Modify the TCL interface to use &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 를 사용하도록 TCL 인터페이스를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c186ff83bfc4ba49c92b1876d399ba40e64a0cc" translate="yes" xml:space="preserve">
          <source>Modify the test scripts to identify tests that depend on system load and processor speed and to warn the user that a failure of one of those (rare) tests does not necessarily mean the library is malfunctioning. No changes to code.</source>
          <target state="translated">테스트 스크립트를 수정하여 시스템로드 및 프로세서 속도에 의존하는 테스트를 식별하고 사용자에게 해당 (희귀 한) 테스트 중 하나가 실패했다고해서 반드시 라이브러리가 오작동하는 것은 아닙니다. 코드가 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ef40b73dad75552add2180adc162c800be16bf41" translate="yes" xml:space="preserve">
          <source>Modifying the contents of a database page.</source>
          <target state="translated">데이터베이스 페이지의 내용 수정</target>
        </trans-unit>
        <trans-unit id="56d9419099fd345280bf9a9122ad284109000f7d" translate="yes" xml:space="preserve">
          <source>Modifying, Adding or Truncating a Database Page</source>
          <target state="translated">데이터베이스 페이지 수정, 추가 또는 잘라 내기</target>
        </trans-unit>
        <trans-unit id="d9ae0b87be39aed320fa35b9e4b820b36d71a71f" translate="yes" xml:space="preserve">
          <source>More aggressive &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</source>
          <target state="translated">보다 적극적인 &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="150e84142afe50eae5e55924e9aafb441ae8328b" translate="yes" xml:space="preserve">
          <source>More aggressive optimization of the AND operator when one side or the other is always false.</source>
          <target state="translated">한쪽 또는 다른 쪽이 항상 거짓 일 때 AND 연산자의보다 적극적인 최적화.</target>
        </trans-unit>
        <trans-unit id="4dccd541fa7b33732e530432dc181f83dcc6ba6e" translate="yes" xml:space="preserve">
          <source>More complex queries may or may not be able to employ query flattening to avoid the temporary table. Whether or not the query can be flattened depends on such factors as whether or not the subquery or outer query contain aggregate functions, ORDER BY or GROUP BY clauses, LIMIT clauses, and so forth. The rules for when a query can and cannot be flattened are very complex and are beyond the scope of this document.</source>
          <target state="translated">더 복잡한 쿼리는 임시 테이블을 피하기 위해 쿼리 병합을 사용하거나 사용하지 않을 수 있습니다. 쿼리를 병합 할 수 있는지 여부는 하위 쿼리 또는 외부 쿼리에 집계 함수, ORDER BY 또는 GROUP BY 절, LIMIT 절 등이 포함되는지 여부와 같은 요소에 따라 달라집니다. 쿼리를 병합하거나 병합 할 수없는시기에 대한 규칙은 매우 복잡하며이 문서의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="0e965ef66116c7e835a08b23bc0aea20069b16ec" translate="yes" xml:space="preserve">
          <source>More efficient encoding of boolean values resulting in smaller database files</source>
          <target state="translated">더 작은 데이터베이스 파일을 생성하는 부울 값의보다 효율적인 인코딩</target>
        </trans-unit>
        <trans-unit id="bc15bc11932b9e3bb7aa3bd3cd6dd3273dc66921" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">특히 애플리케이션이 수백 또는 수천 개의 사용자 정의 함수를 정의하는 경우 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수를&lt;/a&gt; 보다 효율적으로 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="8a3c60573ba6ac75355060c30752d85d7e4a4ea7" translate="yes" xml:space="preserve">
          <source>More efficient handling of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, especially in cases where the application defines hundreds or thousands of custom functions.</source>
          <target state="translated">특히 응용 프로그램에서 수백 또는 수천 개의 사용자 지정 함수를 정의하는 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수를&lt;/a&gt; 보다 효율적으로 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="bbf641e990dbd768fc579b21dbc73f3e38164565" translate="yes" xml:space="preserve">
          <source>More efficient implementation of sqliteFileExists() under Windows. (by Joel Luscy)</source>
          <target state="translated">Windows에서 sqliteFileExists ()를보다 효율적으로 구현합니다. (조엘 루시 제작)</target>
        </trans-unit>
        <trans-unit id="da802536bedcdb71b26438d22c88c54625f47a34" translate="yes" xml:space="preserve">
          <source>More robust handling of out-of-memory errors.</source>
          <target state="translated">메모리 부족 오류를보다 강력하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="f0bbe298877a69ce96299f0684d775b43d33f438" translate="yes" xml:space="preserve">
          <source>More suggestions...</source>
          <target state="translated">더 제안 ...</target>
        </trans-unit>
        <trans-unit id="40a15bddc2f46eb54c50912ec8296652a2a161bf" translate="yes" xml:space="preserve">
          <source>More than one NEAR operator may appear in a single query. In this case each pair of terms or phrases separated by a NEAR operator must appear within the specified proximity of each other in the document. Using the same table and data as in the block of examples above:</source>
          <target state="translated">단일 쿼리에 둘 이상의 NEAR 연산자가 나타날 수 있습니다. 이 경우 NEAR 연산자로 구분 된 각 용어 또는 구 쌍은 문서에서 서로 지정된 거리 내에 있어야합니다. 위 예제 블록에서와 동일한 테이블 및 데이터 사용 :</target>
        </trans-unit>
        <trans-unit id="759136a5c089af122dabc1e0771753f48776ccec" translate="yes" xml:space="preserve">
          <source>Most CVEs written about SQLite assume that the attacker is able to run arbitrary SQL scripts in SQLite. In most applications, this means that there must first be an SQL Injection vulnerability that allows the attacker to inject the malicious SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8eaec9acde05ea65cc7e78b52370752d8ff824b" translate="yes" xml:space="preserve">
          <source>Most R*Tree queries use a depth-first search. This is accomplished by setting the rScore equal to iLevel. A depth-first search is usually preferred since it minimizes the number of elements in the priority queue, which reduces memory requirements and speeds processing. However, some application may prefer a breadth-first search, which can be accomplished by setting rScore to mxLevel-iLevel. By creating more complex formulas for rScore, applications can exercise detailed control over the order in which subtree are searched and leaf R*Tree entries are returned. For example, in an application with many millions of R*Tree entries, the rScore might be arranged so that the largest or most significant entries are returned first, allowing the application to display the most important information quickly, and filling in smaller and less important details as they become available.</source>
          <target state="translated">대부분의 R * Tree 쿼리는 깊이 우선 검색을 사용합니다. 이는 rScore를 iLevel과 동일하게 설정하여 수행됩니다. 깊이 우선 검색은 우선 순위 대기열의 요소 수를 최소화하여 메모리 요구 사항을 줄이고 처리 속도를 높이기 때문에 일반적으로 선호됩니다. 그러나 일부 응용 프로그램에서는 너비 우선 검색을 선호 할 수 있는데, 이는 rScore를 mxLevel-iLevel로 설정하여 수행 할 수 있습니다. rScore에 대해보다 복잡한 수식을 만들어 응용 프로그램은 하위 트리가 검색되고 리프 R * Tree 항목이 반환되는 순서를 세부적으로 제어 할 수 있습니다. 예를 들어, 수백만 개의 R * Tree 항목이있는 응용 프로그램에서 가장 큰 또는 가장 중요한 항목이 먼저 반환되도록 응용 프로그램에서 가장 중요한 정보를 신속하게 표시 할 수 있도록 rScore를 정렬 할 수 있습니다.더 작고 중요하지 않은 세부 사항을 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="0b7d92086a8e46f293a7dca57cb6a5c138416054" translate="yes" xml:space="preserve">
          <source>Most SQL database engines (every SQL database engine other than SQLite, as far as we know) uses static, rigid typing. With static typing, the datatype of a value is determined by its container - the particular column in which the value is stored.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진 (우리가 아는 한 SQLite 이외의 모든 SQL 데이터베이스 엔진)은 고정적이고 엄격한 타이핑을 사용합니다. 정적 타이핑을 사용하면 값의 데이터 유형이 컨테이너 (값이 저장되는 특정 열)에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="0b21de15eb7e27a08d9b4ec057ceb748bbaa22cd" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one known to this author that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 클라이언트 / 서버 기반입니다. 서버리스 서버 중에서 SQLite는이 작성자에게 알려진 유일한 응용 프로그램으로 여러 응용 프로그램이 동시에 동일한 데이터베이스에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27297778565294594247653539b897aca8f2a9fb" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are client/server based. Of those that are serverless, SQLite is the only one that this author knows of that allows multiple applications to access the same database at the same time.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 클라이언트 / 서버 기반입니다. 서버리스 인 SQLite는이 작성자가 알고있는 유일한 응용 프로그램으로 여러 응용 프로그램이 동일한 데이터베이스에 동시에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="260ad8dfcdd6cee164826174f5ff18a6d6796783" translate="yes" xml:space="preserve">
          <source>Most SQL database engines are implemented as a separate server process. Programs that want to access the database communicate with the server using some kind of interprocess communication (typically TCP/IP) to send requests to the server and to receive back results. SQLite does not work this way. With SQLite, the process that wants to access the database reads and writes directly from the database files on disk. There is no intermediary server process.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 별도의 서버 프로세스로 구현됩니다. 데이터베이스에 액세스하려는 프로그램은 일종의 프로세스 간 통신 (일반적으로 TCP / IP)을 사용하여 서버와 통신하여 서버에 요청을 보내고 결과를 다시받습니다. SQLite는 이런 식으로 작동하지 않습니다. SQLite를 사용하면 데이터베이스에 액세스하려는 프로세스가 디스크의 데이터베이스 파일에서 직접 읽고 씁니다. 중개 서버 프로세스가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e11debe28c45aae3eb5d59593787d087cef00a39" translate="yes" xml:space="preserve">
          <source>Most SQL database engines store the schema already parsed into various system tables. On those database engines, ALTER TABLE merely has to make modifications to the corresponding system tables.</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 이미 다양한 시스템 테이블로 구문 분석 된 스키마를 저장합니다. 이러한 데이터베이스 엔진에서 ALTER TABLE은 해당 시스템 테이블을 수정하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c8146f85b00a04238b33c2841ef39833177b149b" translate="yes" xml:space="preserve">
          <source>Most SQL database engines use static typing. A datatype is associated with each column in a table and only values of that particular datatype are allowed to be stored in that column. SQLite relaxes this restriction by using manifest typing. In manifest typing, the datatype is a property of the value itself, not of the column in which the value is stored. SQLite thus allows the user to store any value of any datatype into any column regardless of the declared type of that column. (There are some exceptions to this rule: An INTEGER PRIMARY KEY column may only store integers. And SQLite attempts to coerce values into the declared datatype of the column when it can.)</source>
          <target state="translated">대부분의 SQL 데이터베이스 엔진은 정적 입력을 사용합니다. 데이터 유형은 테이블의 각 열과 연관되며 해당 특정 데이터 유형의 값만 해당 열에 저장 될 수 있습니다. SQLite는 매니페스트 입력을 사용하여 이러한 제한을 완화합니다. 매니페스트 타이핑에서 데이터 유형은 값이 저장된 열이 아니라 값 자체의 속성입니다. 따라서 SQLite를 사용하면 사용자는 해당 열의 선언 된 유형에 관계없이 모든 데이터 유형의 값을 열에 저장할 수 있습니다. (이 규칙에는 몇 가지 예외가 있습니다. INTEGER PRIMARY KEY 열은 정수만 저장할 수 있습니다. SQLite는 가능한 경우 열의 선언 된 데이터 유형으로 값을 강제하려고 시도합니다.)</target>
        </trans-unit>
        <trans-unit id="725952f518d7037ff04756bd99d602eae557b1ce" translate="yes" xml:space="preserve">
          <source>Most application formats fit into one of these three categories:</source>
          <target state="translated">대부분의 응용 프로그램 형식은 다음 세 가지 범주 중 하나에 맞습니다.</target>
        </trans-unit>
        <trans-unit id="d19cf0ebd0035eff768792dfdb24fc34ef35cd23" translate="yes" xml:space="preserve">
          <source>Most applications can use SQLite without having to worry about bugs in obscure SQL inputs. If the application controls the SQL, and the application is not deliberately trying to break SQLite, then everything should just work. It is not necessary to have the latest patched version of SQLite. Any older version should work just fine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce502bced488a9855f9633bf314ed3f557c5599e" translate="yes" xml:space="preserve">
          <source>Most applications will only use the session module functionality described in the previous section. However, the following additional functionality is available for the use and manipulation of changeset and patchset blobs:</source>
          <target state="translated">대부분의 응용 프로그램은 이전 섹션에서 설명한 세션 모듈 기능 만 사용합니다. 그러나 변경 세트 및 패치 세트 Blob의 사용 및 조작을 위해 다음과 같은 추가 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd513c058fc14329a86bc7561ce2383e9150f5ca" translate="yes" xml:space="preserve">
          <source>Most applications work great with SQLite in its default configuration and with no special compile-time configuration. Most developers should be able to completely ignore this document and simply build SQLite from &lt;a href=&quot;amalgamation&quot;&gt;the amalgamation&lt;/a&gt; without any special knowledge and without taking any special actions.</source>
          <target state="translated">대부분의 응용 프로그램은 기본 구성에서 특별한 컴파일 타임 구성없이 SQLite와 잘 작동합니다. 대부분의 개발자는이 문서를 완전히 무시 하고 특별한 지식없이 특별한 조치를 취하지 않고 간단히 &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 으로부터 SQLite를 구축 할 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="635fff5a9d997771ed833778dcd946f9fa076040" translate="yes" xml:space="preserve">
          <source>Most builds also use the system memory allocation routines:</source>
          <target state="translated">대부분의 빌드는 시스템 메모리 할당 루틴도 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c757f57c7c0fc6a3a16a4ba481be29df77f7ba0d" translate="yes" xml:space="preserve">
          <source>Most built-in window functions ignore the frame-spec, the exceptions being first_value(), last_value() and nth_value(). It is a syntax error to specify a FILTER clause as part of a built-in window function invocation.</source>
          <target state="translated">대부분의 내장 윈도우 함수는 프레임 스펙을 무시합니다. 예외는 first_value (), last_value () 및 nth_value ()입니다. 내장 창 함수 호출의 일부로 FILTER 절을 지정하는 것은 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="91aff38100948ec7606e7b9be6940203c42b637c" translate="yes" xml:space="preserve">
          <source>Most memory statistics are global, and therefore the tracking of statistics must be serialized with a mutex. Statistics are turned on by default, but an option exists to disable them. By disabling memory statistics, SQLite avoids entering and leaving a mutex on each memory allocation and deallocation. That savings can be noticeable on systems where mutex operations are expensive. To disable memory statistics, the following interface is used at start-time:</source>
          <target state="translated">대부분의 메모리 통계는 전역 적이므로 통계 추적은 뮤텍스로 직렬화되어야합니다. 통계는 기본적으로 켜져 있지만 비활성화 할 수있는 옵션이 있습니다. SQLite는 메모리 통계를 사용하지 않도록 설정하여 각 메모리 할당 및 할당 해제시 뮤텍스를 입력하거나 남기지 않습니다. 뮤텍스 운영이 비싼 시스템에서는 절감 효과가 눈에 can니다. 메모리 통계를 비활성화하려면 시작시 다음 인터페이스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ddc29325f5f8b33e852a6ad2b01d9c1a5b27979" translate="yes" xml:space="preserve">
          <source>Most object references may only resolve to a specific type of object (for example a reference that is part of a DROP TABLE statement may only resolve to a table object, not an index, trigger or view). However in some contexts (e.g. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;) an object reference may be resolve to more than one type of object. When searching database schemas for a named object, objects of types that cannot be used in the context of the reference are always ignored.</source>
          <target state="translated">대부분의 객체 참조는 특정 유형의 객체로만 해석 될 수 있습니다 (예 : DROP TABLE 문의 일부인 참조는 색인, 트리거 또는 뷰가 아닌 테이블 객체로만 해석 될 수 있음). 그러나 일부 컨텍스트 (예 : &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; )에서 객체 참조는 여러 유형의 객체로 해석 될 수 있습니다. 명명 된 개체에 대한 데이터베이스 스키마를 검색 할 때 참조 컨텍스트에서 사용할 수없는 유형의 개체는 항상 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="1f85923bce6297c36b3c44bb82e688cbd09f35ee" translate="yes" xml:space="preserve">
          <source>Most of the code in the SQLite source tree is devoted purely to &lt;a href=&quot;testing&quot;&gt;testing and verification&lt;/a&gt;. Reliability is important to SQLite. Among the tasks of the test infrastructure is to ensure that SQLite does not misuse dynamically allocated memory, that SQLite does not leak memory, and that SQLite responds correctly to a dynamic memory allocation failure.</source>
          <target state="translated">SQLite 소스 트리에있는 대부분의 코드는 순전히 &lt;a href=&quot;testing&quot;&gt;테스트 및 검증에&lt;/a&gt; 전념 합니다 . 안정성은 SQLite에 중요합니다. 테스트 인프라의 작업 중에는 SQLite가 동적으로 할당 된 메모리를 잘못 사용하지 않도록하고 SQLite가 메모리를 누출하지 않으며 SQLite가 동적 메모리 할당 실패에 올바르게 응답하는지 확인하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ea1351b2e34fd10311e1e13ffcc8b793141d24f" translate="yes" xml:space="preserve">
          <source>Most of the time, sqlite3 just reads lines of input and passes them on to the SQLite library for execution. But input lines that begin with a dot (&quot;.&quot;) are intercepted and interpreted by the sqlite3 program itself. These &quot;dot commands&quot; are typically used to change the output format of queries, or to execute certain prepackaged query statements. There were originally just a few dot commands, but over the years many new features have accumulated so that today there over 60.</source>
          <target state="translated">대부분의 경우 sqlite3은 입력 행을 읽고 SQLite 라이브러리에 전달하여 실행합니다. 그러나 점 ( &quot;.&quot;)으로 시작하는 입력 라인은 sqlite3 프로그램 자체에 의해 인터셉트되고 해석됩니다. 이러한 &quot;점 명령&quot;은 일반적으로 쿼리의 출력 형식을 변경하거나 사전 패키지 된 특정 쿼리 문을 실행하는 데 사용됩니다. 원래는 몇 개의 점 명령이 있었지만 수년 동안 많은 새로운 기능이 누적되어 오늘날 60 개가 넘습니다.</target>
        </trans-unit>
        <trans-unit id="8140e633bb506b56ea3ecec29c87f47b39a7e315" translate="yes" xml:space="preserve">
          <source>Most of the time, the query planner in SQLite does a good job. However, the query planner needs indices to work with. These indices must normally be added by programmers. Rarely, the query planner AI will make a suboptimal algorithm choice. In those cases, programmers may want to provide additional hints to help the query planner do a better job.</source>
          <target state="translated">대부분의 경우 SQLite의 쿼리 플래너는 잘 작동합니다. 그러나 쿼리 플래너가 작업하려면 인덱스가 필요합니다. 이 지수는 일반적으로 프로그래머가 추가해야합니다. 드물게 쿼리 플래너 AI가 최적의 알고리즘을 선택하지는 않습니다. 이 경우 프로그래머는 쿼리 플래너가 더 나은 작업을 수행 할 수 있도록 추가 힌트를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d637cb6d91465469dba952401dcd3c4590d5c67" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines allocated a fixed amount of disk space for each row in most tables. They play special tricks for handling BLOBs and CLOBs which can be of wildly varying length. But for most tables, if you declare a column to be a VARCHAR(100) then the database engine will allocate 100 bytes of disk space regardless of how much information you actually store in that column.</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진은 대부분의 테이블에서 각 행에 대해 일정한 양의 디스크 공간을 할당했습니다. 길이가 매우 다양한 BLOB 및 CLOB 처리를위한 특수 트릭을 수행합니다. 그러나 대부분의 테이블에서 열을 VARCHAR (100)로 선언하면 데이터베이스 엔진은 해당 열에 실제로 저장하는 정보의 양에 관계없이 100 바이트의 디스크 공간을 할당합니다.</target>
        </trans-unit>
        <trans-unit id="b52c62ddb6e76f10df4280114ef18bdd833e392c" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines are much larger than this. IBM boasts that its recently released CloudScape database engine is &quot;only&quot; a 2MiB jar file - an order of magnitude larger than SQLite even after it is compressed! Firebird boasts that its client-side library is only 350KiB. That's as big as SQLite and does not even contain the database engine. The Berkeley DB library from Oracle is 450KiB and it omits SQL support, providing the programmer with only simple key/value pairs.</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진은 이보다 훨씬 큽니다. IBM은 최근 출시 된 CloudScape 데이터베이스 엔진이 압축 된 후에도 SQLite보다 훨씬 큰 2MiB jar 파일 인 &quot;단독&quot;임을 자랑합니다! Firebird는 클라이언트 측 라이브러리가 350KiB에 불과하다는 것을 자랑합니다. 그것은 SQLite만큼 크며 데이터베이스 엔진도 포함하지 않습니다. Oracle의 Berkeley DB 라이브러리는 450KiB이며 SQL 지원을 생략하여 프로그래머에게 간단한 키 / 값 쌍만 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5dfe3bda7177abf58f732623f4daabfa91229422" translate="yes" xml:space="preserve">
          <source>Most other SQL database engines require you to dump and restore the database when moving from one platform to another and often when upgrading to a newer version of the software.</source>
          <target state="translated">대부분의 다른 SQL 데이터베이스 엔진에서는 한 플랫폼에서 다른 플랫폼으로 이동할 때 그리고 종종 최신 버전의 소프트웨어로 업그레이드 할 때 데이터베이스를 덤프하고 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="879c0198beea8a0459677487adc544c847a7576f" translate="yes" xml:space="preserve">
          <source>Most programmers compile SQLite into their applications using the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is C-code but it is not &quot;source code&quot;. The &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; is generated from source code by scripts.</source>
          <target state="translated">대부분의 프로그래머는 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation을&lt;/a&gt; 사용하여 SQLite를 응용 프로그램으로 컴파일합니다 . &lt;a href=&quot;amalgamation&quot;&gt;합병은&lt;/a&gt; C 코드이지만 &quot;소스 코드&quot;가 아닙니다. &lt;a href=&quot;amalgamation&quot;&gt;합병은&lt;/a&gt; 스크립트에 의해 소스 코드에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e8416192176e318d00a7b55e02e8a608d8bdbda6" translate="yes" xml:space="preserve">
          <source>Most tables in SQLite consist of zero or more rows with a unique integer key (the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; or &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;) followed by content. (The exception is &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.) The rows are logically stored in order of increasing rowid. As an example, this article uses a table named &quot;FruitsForSale&quot; which relates various fruits to the state where they are grown and their unit price at market. The schema is this:</source>
          <target state="translated">SQLite의 대부분의 테이블은 고유 정수 키 ( &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ) 와 내용이 포함 된 0 개 이상의 행 으로 구성됩니다. ( &lt;a href=&quot;withoutrowid&quot;&gt;without ROWID&lt;/a&gt; 테이블 은 예외입니다 .) 행은 rowid가 증가하는 순서대로 논리적으로 저장됩니다. 예를 들어,이 기사에서는 &quot;FruitsForSale&quot;이라는 테이블을 사용하여 다양한 과일을 재배 한 상태 및 시장의 단가와 관련시킵니다. 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22d0e010589dcfa569bc8ab54799e70d1b27d453" translate="yes" xml:space="preserve">
          <source>Most tables in a typical SQLite database schema are rowid tables.</source>
          <target state="translated">일반적인 SQLite 데이터베이스 스키마의 대부분의 테이블은 rowid 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="ab23b25ac3bb6f94df4203c5e40926f8de962adb" translate="yes" xml:space="preserve">
          <source>Most users of swarmvtab will only use the features described above. This section describes features designed for more esoteric use cases. These features all involve specifying extra optional parameters following the SQL statement as part of the CREATE VIRTUAL TABLE command. An optional parameter is specified using its name, followed by an &quot;=&quot; character, followed by an optionally quoted value. Whitespace may separate the name, &quot;=&quot; character and value. For example:</source>
          <target state="translated">swarmvtab 사용자는 대부분 위에서 설명한 기능 만 사용합니다. 이 섹션에서는보다 난해한 사용 사례를 위해 설계된 기능에 대해 설명합니다. 이러한 기능에는 모두 CREATE VIRTUAL TABLE 명령의 일부로 SQL 문 다음에 추가 선택적 매개 변수를 지정하는 것이 포함됩니다. 선택적 매개 변수는 이름 다음에 &quot;=&quot;문자와 선택적으로 인용 된 값을 사용하여 지정됩니다. 공백은 이름 &quot;=&quot;문자와 값을 구분할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76cdb950721642b6b8596d36d5a39f7705028b99" translate="yes" xml:space="preserve">
          <source>Move</source>
          <target state="translated">Move</target>
        </trans-unit>
        <trans-unit id="7e894652e8d984064189391f996d60397e2a48ec" translate="yes" xml:space="preserve">
          <source>Move a BLOB Handle to a New Row</source>
          <target state="translated">BLOB 핸들을 새 행으로 이동</target>
        </trans-unit>
        <trans-unit id="b0ff33b105569af9f2119de68af4d3ef24773b02" translate="yes" xml:space="preserve">
          <source>Move the P3 values in register P1..P1+P3-1 over into registers P2..P2+P3-1. Registers P1..P1+P3-1 are left holding a NULL. It is an error for register ranges P1..P1+P3-1 and P2..P2+P3-1 to overlap. It is an error for P3 to be less than 1.</source>
          <target state="translated">레지스터 P1..P1 + P3-1의 P3 값을 레지스터 P2..P2 + P3-1로 옮깁니다. 레지스터 P1..P1 + P3-1은 NULL을 유지합니다. 레지스터 범위 P1..P1 + P3-1 및 P2..P2 + P3-1이 겹치는 것은 오류입니다. P3이 1보다 작은 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="43e629ad230f33beeec0dc2dfe68b2611f083ba6" translate="yes" xml:space="preserve">
          <source>Move the cursor P1 to a null row. Any &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; operations that occur while the cursor is on the null row will always write a NULL.</source>
          <target state="translated">커서 P1을 널 행으로 이동하십시오. 커서가 널 행에있는 동안 발생하는 모든 &lt;a href=&quot;opcode#Column&quot;&gt;컬럼&lt;/a&gt; 조작은 항상 NULL을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ff17aceff7878d14b853ed0faf40490493d4491b" translate="yes" xml:space="preserve">
          <source>Move website and documentation files out of the source tree into a &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;separate CM system&lt;/a&gt;.</source>
          <target state="translated">웹 사이트 및 문서 파일을 소스 트리에서 &lt;a href=&quot;http://www.sqlite.org/docsrc/&quot;&gt;별도의 CM 시스템으로 이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42fda9211198a462ad90d286a7b4b2828423cc34" translate="yes" xml:space="preserve">
          <source>Moved the CVS repository to www.sqlite.org</source>
          <target state="translated">CVS 저장소를 www.sqlite.org로 이동</target>
        </trans-unit>
        <trans-unit id="dc586a90c5c94a44d1d972ced97472cbaf4b949e" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.4.2 to 3.5.0</source>
          <target state="translated">SQLite 3.4.2에서 3.5.0으로 이동</target>
        </trans-unit>
        <trans-unit id="d4fefbd0278cf9b39cd3f466ee48861cfc5e39db" translate="yes" xml:space="preserve">
          <source>Moving From SQLite 3.5.9 to 3.6.0</source>
          <target state="translated">SQLite 3.5.9에서 3.6.0으로 이동</target>
        </trans-unit>
        <trans-unit id="f76bc373feee6b1842d340bd7d664f80273b9cc9" translate="yes" xml:space="preserve">
          <source>Moving a journal file from one database to another.</source>
          <target state="translated">한 데이터베이스에서 다른 데이터베이스로 저널 파일 이동</target>
        </trans-unit>
        <trans-unit id="f0efafe4edefbbfdb22e09fc7f8e1939d65fc935" translate="yes" xml:space="preserve">
          <source>Much of the &lt;a href=&quot;c3ref/intro&quot;&gt;C-language Interface&lt;/a&gt; is found in source files &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c&lt;/a&gt; though some routines are scattered about in other files where they can have access to data structures with file scope. The &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table()&lt;/a&gt; routine is implemented in &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; routine is found in &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt;. The &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete()&lt;/a&gt; interface is in &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt;. The &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt; is implemented by &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/intro&quot;&gt;C 언어 인터페이스&lt;/a&gt; 의 대부분은 소스 파일 &lt;a href=&quot;https://sqlite.org/src/file/src/main.c&quot;&gt;main.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/legacy.c&quot;&gt;legacy.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/vdbeapi.c&quot;&gt;vdbeapi.c에&lt;/a&gt; 있지만 일부 루틴은 파일 범위가있는 데이터 구조에 액세스 할 수있는 다른 파일에 흩어져 있습니다. &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table ()&lt;/a&gt; 루틴에서 구현 &lt;a href=&quot;https://sqlite.org/src/file/src/table.c&quot;&gt;table.c&lt;/a&gt; . &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 루틴에서 발견된다 &lt;a href=&quot;https://sqlite.org/src/file/src/printf.c&quot;&gt;printf.c&lt;/a&gt; . &lt;a href=&quot;c3ref/complete&quot;&gt;sqlite3_complete ()&lt;/a&gt; 인터페이스에 &lt;a href=&quot;https://sqlite.org/src/file/src/complete.c&quot;&gt;complete.c&lt;/a&gt; . &lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스&lt;/a&gt; 에 의해 구현된다 &lt;a href=&quot;https://sqlite.org/src/file/src/tclsqlite.c&quot;&gt;tclsqlite.c&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aeaa0f6e5bc7f27528f2732350cce3993158ba7" translate="yes" xml:space="preserve">
          <source>Multi-File Transactions</source>
          <target state="translated">다중 파일 트랜잭션</target>
        </trans-unit>
        <trans-unit id="7bd215d0dc08a639766c0fd92af7ca6bd919b359" translate="yes" xml:space="preserve">
          <source>Multi-character insertions, deletions, and substitutions can be enumerated in the cost table.</source>
          <target state="translated">다중 문자 삽입, 삭제 및 대체는 비용 테이블에 열거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="658e2e2d073be17c3d24649adb63bc8071c4e34c" translate="yes" xml:space="preserve">
          <source>Multi-column indexes</source>
          <target state="translated">여러 열 인덱스</target>
        </trans-unit>
        <trans-unit id="b37d6f5d76bdf33c501015c981f38efa402cfb25" translate="yes" xml:space="preserve">
          <source>Multi-column indices only work if the constraint terms in the WHERE clause of the query are connected by AND. So Idx3 and Idx4 are helpful when the search is for items that are both Oranges and grown in California, but neither index would be that useful if we wanted all items that were either oranges</source>
          <target state="translated">다중 열 인덱스는 쿼리의 WHERE 절에있는 제약 조건 용어가 AND로 연결된 경우에만 작동합니다. 따라서 Idx3 및 Idx4는 오렌지와 캘리포니아에서 재배 된 품목을 검색 할 때 도움이되지만 오렌지색이었던 모든 품목을 원할 경우 인덱스가 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6a2f3477040c5c780afe34563348a368c865f18" translate="yes" xml:space="preserve">
          <source>Multiple Programming Languages</source>
          <target state="translated">여러 프로그래밍 언어</target>
        </trans-unit>
        <trans-unit id="8127845d9b0c204fa8283356e673cf21f966c9a0" translate="yes" xml:space="preserve">
          <source>Multiple VFSes can be registered at the same time. Each VFS has a unique names. Separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; within the same process can be using different VFSes at the same time. For that matter, if a single database connection has multiple database files open using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command, then each attached database might be using a different VFS.</source>
          <target state="translated">여러 VFS를 동시에 등록 할 수 있습니다. 각 VFS에는 고유 한 이름이 있습니다. 동일한 프로세스 내에서 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 다른 VFS를 동시에 사용할 수 있습니다. 따라서 단일 데이터베이스 연결에 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령을 사용하여 여러 데이터베이스 파일이 열려 있으면 연결된 각 데이터베이스가 다른 VFS를 사용하고있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcdea0a58cadff7c782d97a6048e7da5d88f4991" translate="yes" xml:space="preserve">
          <source>Multiple b-tree structures are used instead of a single b-tree to reduce the cost of inserting records into FTS tables. When a new record is inserted into an FTS table that already contains a lot of data, it is likely that many of the terms in the new record are already present in a large number of existing records. If a single b-tree were used, then large doclist structures would have to be loaded from the database, amended to include the new docid and term-offset list, then written back to the database. Using multiple b-tree tables allows this to be avoided by creating a new b-tree which can be merged with the existing b-tree (or b-trees) later on. Merging of b-tree structures can be performed as a background task, or once a certain number of separate b-tree structures have been accumulated. Of course, this scheme makes queries more expensive (as the FTS code may have to look up individual terms in more than one b-tree and merge the results), but it has been found that in practice this overhead is often negligible.</source>
          <target state="translated">FTS 테이블에 레코드를 삽입하는 비용을 줄이기 위해 단일 b- 트리 대신 여러 b- 트리 구조가 사용됩니다. 이미 많은 데이터가 포함 된 FTS 테이블에 새 레코드가 삽입되면 새 레코드의 많은 용어가 이미 많은 수의 기존 레코드에있을 수 있습니다. 단일 b- 트리가 사용 된 경우 데이터베이스에서 큰 문서 목록 구조를로드하고 새 문서 및 용어 오프셋 목록을 포함하도록 수정 한 다음 데이터베이스에 다시 기록해야합니다. 여러 b- 트리 테이블을 사용하면 나중에 기존 b- 트리 (또는 b- 트리)와 병합 할 수있는 새 b- 트리를 만들어이를 피할 수 있습니다. b- 트리 구조의 병합은 백그라운드 작업으로 수행되거나 특정 수의 개별 b- 트리 구조가 누적되면 수행 될 수 있습니다. 물론이야,이 체계는 (FTS 코드가 하나 이상의 b- 트리에서 개별 용어를 찾아 결과를 병합해야 할 수도 있기 때문에) 쿼리를 더 비싸게 만들지 만 실제로는이 오버 헤드가 무시할 수있는 것으로 밝혀졌습니다.</target>
        </trans-unit>
        <trans-unit id="46b7208fbb4e603607fdd8e005b8c2b44c4f2832" translate="yes" xml:space="preserve">
          <source>Multiple bug fixes to the &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; logic that was introduced in version 3.15.0.</source>
          <target state="translated">버전 3.15.0에서 도입 된 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 논리 에 대한 여러 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="5bf9dc54bb3a9335bc64c25972bec9a940f13e21" translate="yes" xml:space="preserve">
          <source>Multiple commentators have expressed a desire to use dynamic strings for the pointer type, and to have SQLite take ownership of the type strings and to automatically free the type string when it has finished using it. That design is rejected for the following reasons:</source>
          <target state="translated">다수의 주석가들은 포인터 유형에 동적 문자열을 사용하고 SQLite가 유형 문자열의 소유권을 갖도록하고 사용이 끝났을 때 자동으로 유형 문자열을 해제하려고합니다. 이 디자인은 다음과 같은 이유로 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5989cfc9447928ba4d05b443c6d4b672ed4ef531" translate="yes" xml:space="preserve">
          <source>Multiple connections from within a single process that use this implementation of asynchronous IO may access a single database file concurrently. From the point of view of the user, if all connections are from within a single process, there is no difference between the concurrency offered by &quot;normal&quot; SQLite and SQLite using the asynchronous backend.</source>
          <target state="translated">이 비동기 IO 구현을 사용하는 단일 프로세스 내에서 다중 연결은 단일 데이터베이스 파일에 동시에 액세스 할 수 있습니다. 사용자 관점에서 모든 연결이 단일 프로세스 내에있는 경우 비동기 백엔드를 사용하는 &quot;정상&quot;SQLite와 SQLite에서 제공하는 동시성에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="de5017f80cc138eb92a9fee1631567420f1d53b1" translate="yes" xml:space="preserve">
          <source>Multiple connections may hold a read-lock simultaneously. If many threads are acquiring overlapping read-locks, it might be the case that at least one thread is always holding a read lock. Then a table waiting for a write-lock will wait forever. This scenario is called &quot;writer starvation.&quot;</source>
          <target state="translated">여러 연결이 동시에 읽기 잠금을 유지할 수 있습니다. 많은 스레드가 겹치는 읽기 잠금을 획득하는 경우 하나 이상의 스레드가 항상 읽기 잠금을 보유하는 경우 일 수 있습니다. 그런 다음 쓰기 잠금을 기다리는 테이블은 영원히 기다립니다. 이 시나리오를 &quot;작가 기아&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="809241f3730c6379db2c7c73b89d2efee62ec7f1" translate="yes" xml:space="preserve">
          <source>Multiple databases on the same &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE를&lt;/a&gt; 사용하여 동일한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 여러 데이터베이스</target>
        </trans-unit>
        <trans-unit id="45a728f83fed6326d4c43841ba1813e1ce7eb6dd" translate="yes" xml:space="preserve">
          <source>Multiple processes can attach to the same application file and can read and write without interfering with each another.</source>
          <target state="translated">여러 프로세스가 동일한 응용 프로그램 파일에 첨부 할 수 있으며 서로 방해하지 않고 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aa7ba24512eed1d018b442b661d99d24d2bbe28" translate="yes" xml:space="preserve">
          <source>Multiple processes can have the same database open at the same time. Multiple processes can be doing a SELECT at the same time. But only one process can be making changes to the database at any moment in time, however.</source>
          <target state="translated">여러 프로세스가 동시에 동일한 데이터베이스를 열 수 있습니다. 여러 프로세스가 동시에 SELECT를 수행 할 수 있습니다. 그러나 한 번에 하나의 프로세스 만 데이터베이스를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="933ed3deea04e9e9fbd7189bd88652e303cb225d" translate="yes" xml:space="preserve">
          <source>Multiple small sorts collectively use fewer CPU cycles than a single large sort.</source>
          <target state="translated">여러 개의 작은 정렬은 단일의 큰 정렬보다 CPU주기를 더 적게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b20a305f06f0be2e3dd77e203ae365353776cf59" translate="yes" xml:space="preserve">
          <source>Multiply</source>
          <target state="translated">Multiply</target>
        </trans-unit>
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 값에 레지스터 P2의 값을 곱하고 결과를 레지스터 P3에 저장합니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">null에 0을 곱하면 null이됩니다.</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">돌연변이 테스트 스크립트</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">각 테스트는 빠른 워크 스테이션에서 최대 5 분이 소요될 수 있으며 각 분기 명령에 대해 두 개의 테스트와 20,000 개 이상의 분기 명령이 있으므로 돌연변이 테스트가 느려질 수 있습니다. 신속한 작업을 위해 노력합니다. 예를 들어 TH3는 첫 번째 오류를 발견하자마자 빠져 나가는 방식으로 컴파일되며 많은 돌연변이가 쉽게 감지되면 몇 초 안에 많은주기가 발생합니다. 그럼에도 불구하고 mutation-test.tcl 스크립트에는 명령 줄 옵션이 포함되어있어 테스트 된 코드 라인의 범위를 제한하여 최근에 변경된 코드 블록에서만 돌연변이 테스트를 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">뮤텍스 핸들</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">뮤텍스 메소드 객체</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">뮤텍스 유형</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">뮤텍스 검증 루틴</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">뮤텍스는 저렴하지만 무료가 아니므로 뮤텍스가 완전히 비활성화되면 성능이 향상됩니다. 결과 라이브러리 풋 프린트도 약간 줄어 듭니다. 컴파일 타임에 뮤텍스를 비활성화하는 것이 적합한 응용 프로그램에 권장되는 최적화 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">뮤텍스는 &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()을&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">뮤텍스는 &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()을&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">WHERE 절 표현식 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 이 작동하지 않습니다. column1의 값이 &quot;column1&quot;인 행뿐만 아니라 테이블의 모든 행이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">내 쿼리가 예상 한 열 이름을 반환하지 않습니다. 이것이 버그입니까?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="424aa797f42c3aefebeedcebb618509b36642239" translate="yes" xml:space="preserve">
          <source>MySQL supports the UPDATE FROM idea, but it does so without using a FROM clause. Instead, the complete join specification is given in between the UPDATE and SET keywords. The equivalent MySQL statement would be like this:</source>
          <target state="translated">MySQL은 UPDATE FROM 아이디어를 지원하지만 FROM 절을 사용하지 않고 지원합니다. 대신 완전한 조인 사양이 UPDATE 및 SET 키워드 사이에 제공됩니다. 동등한 MySQL 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL 버전 3.23.41은 UNION을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12 및 짝수</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13과 홀수</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1 (비용 : 5.52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2 (비용 : 5.52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1 (비용 : 11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">고유 문자 (70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB :이 확장은 더 이상 사용되지 않습니다. 대체품으로는 [WAL 모드]가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">NEAR 개의 검색어</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">NEAR 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">NEW 및 OLD 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">새로운 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN 일</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN 시간</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN 분</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN 개월</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN 년</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNN.NNNN 초</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">존재하지 않는 연산자</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">NOT IN 연산자</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">NOT NULL 제약</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL 제약 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="545dacd66301f165f41f75a11471135695f4dede" translate="yes" xml:space="preserve">
          <source>NUL Characters In Strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4771b572fc1de8c483abeb1a95a1bc516fa56a87" translate="yes" xml:space="preserve">
          <source>NUL characters (ASCII code 0x00 and Unicode \u0000) may appear in the middle of strings in SQLite. This can lead to unexpected behavior. See the &quot;&lt;a href=&quot;nulinstr&quot;&gt;NUL characters in strings&lt;/a&gt;&quot; document for further information.</source>
          <target state="translated">NUL 문자 (ASCII 코드 0x00 및 유니 코드 \ u0000)는 SQLite의 문자열 중간에 나타날 수 있습니다. 이로 인해 예기치 않은 동작이 발생할 수 있습니다. 자세한 내용은 &quot; &lt;a href=&quot;nulinstr&quot;&gt;문자열의 NUL 문자&lt;/a&gt; &quot;문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLite의 NULL 처리</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">다른 데이터베이스 엔진과 SQLite의 NULL 처리</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL 값 (직렬 유형 0)이 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL 값은 이제 빈 문자열이 아닌 NULL 포인터로 콜백에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">마지막 NULL</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULL이 먼저 정렬</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">호스트 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">데이터베이스 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">임시 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">기본 데이터 정렬 시퀀스의 이름</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">WINDOW 절을 사용하여 명명 된 window-defn 절을 SELECT 문에 추가 한 다음 창 함수 호출 내에서 이름으로 참조 할 수도 있습니다. 예를 들어 다음 SELECT 문에는 &quot;win1&quot;및 &quot;win2&quot;라는 두 개의 명명 된 window-defs 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">이름 변경</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">거의 모든 시스템에는 C로 작성된 라이브러리를 호출 할 수있는 기능이 있습니다. 이것은 다른 구현 언어에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">&quot;.width&quot;명령의 음수는 오른쪽 정렬을 유발합니다</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 및 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO를&lt;/a&gt; 사용하는 중첩 트랜잭션</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">하나님의 자비를 절대 절망하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="56cdefb3df5828b1fdbe0c79de688ed68de09460" translate="yes" xml:space="preserve">
          <source>Never tag an application-defined SQL function with &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; unless you really need to and you have checked the implementation closely and are certain that it can do no harm even if it falls under the control of an attacker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">그럼에도 불구하고 응용 프로그램 개발자는 메모리 할당 하위 시스템의 상태를 모니터링하고 메모리 사용량이 Robson 제한에 도달하거나이를 초과하면 경보를 발생시키는 것이 좋습니다. 이러한 방식으로 응용 프로그램은 오류 발생 전에 운영자에게 풍부한 경고를 제공합니다. SQLite 의 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 인터페이스는이 작업의 모니터링 부분을 완료하는 데 필요한 모든 메커니즘을 응용 프로그램에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">그럼에도 불구하고 버그가 발생합니다. 신뢰할 수없는 SQL 입력 또는 데이터베이스 파일을 SQLite로 보내는 응용 프로그램을 작성하는 경우 공격 영역을 줄이고 감지되지 않은 버그로 인한 제로 데이 악용을 방지하기 위해 수행 할 수있는 추가 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">그럼에도 불구하고, 메모리 할당 크기 계산에서 정수 오버플로는 SQLite가 처리하고자하는 관심사입니다. 문제를 방지하기 위해 모든 SQLite 내부 메모리 할당은 부호있는 64 비트 정수 크기 매개 변수를 사용하는 씬 래퍼 함수를 ​​사용하여 발생합니다. 모든 크기 계산이 64 비트 부호있는 정수를 사용하여 수행되도록 SQLite 소스 코드를 감사합니다. SQLite는 한 번에 약 2GB 이상의 메모리 할당을 거부합니다. (일반적으로 SQLite는 한 번에 약 8KB 이상의 메모리를 할당하는 경우가 거의 없으므로 2GB 할당 제한이 부담이되지 않습니다.) 따라서 64 비트 크기 매개 변수는 오버플로를 감지하기위한 많은 여유 공간을 제공합니다. 모든 크기 계산이 64 비트 부호있는 정수로 수행되는지 확인하는 동일한 감사도 계산 중에 64 비트 정수를 오버플로 할 수 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">그럼에도 불구하고 100 % 완벽한 소프트웨어는 없습니다. SQLite (현재 수정)에는 데이터베이스 손상을 일으킬 수있는 몇 가지 역사적 버그가있었습니다. 그리고 아직 밝혀지지 않은 것들이 더있을 수 있습니다. 광범위한 테스트와 SQLite의 광범위한 사용으로 인해 데이터베이스 손상을 초래하는 버그는 매우 모호한 경향이 있습니다. 응용 프로그램에서 SQLite 버그가 발생할 가능성은 적습니다. 이를 설명하기 위해 2009-04-01에서 2013-04-15까지 4 년 동안 SQLite에서 발견 된 모든 데이터베이스 손상 버그에 대해 설명합니다. 이 계정은 독자들에게 SQLite의 버그 종류에 대한 직관적 인 이해를 제공하여 테스트 절차를 거쳐 릴리스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">새로운 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt; 컴파일 타임 옵션 추가</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">새로운 변화</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">새로운 파일 형식</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">내장 된 날짜 / 시간 기능에 대한 새로운 HH : MM : SS 수정 자.</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">새로운 VFS는 sqlite3_vfs_register ()에 등록됩니다. makeDflt 플래그가 설정되면 각각의 새로운 VFS는 기본 VFS가됩니다. 동일한 VFS를 부상없이 여러 번 등록 할 수 있습니다. 기존 VFS를 기본 VFS로 만들려면 makeDflt 플래그가 설정된 상태로 다시 VFS를 등록하십시오. 이름이 같은 두 개의 다른 VFS가 등록되면 동작이 정의되지 않습니다. VFS가 NULL 또는 빈 문자열 인 이름으로 등록 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">새로운 응용 프로그램을해야 항상 호출 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()을&lt;/a&gt; . 이전 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 는 이전 버전과의 호환성을 위해 유지됩니다. 그러나 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 는 훨씬 더 나은 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 다음에서 리턴 코드를 확인해야합니다.&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 다음에서 리턴 코드를 확인해야합니다.&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt;확인하여 호출이 작동했는지 확인해야합니다. 그만큼&lt;a href=&quot;#sqlite3_db_config&quot;&gt; sqlite3_db_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 에서 리턴 코드를 확인해야합니다. 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;../rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. 그만큼&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;../rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">SQLite가 만든 새 데이터베이스 파일은 기본적으로 형식 4를 사용합니다. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그&lt;/a&gt; 형식의 버전 번호는 설정에 의해 1 대신에 4 기본값으로 만들 수 있습니다 형식 (1)을 사용하여 새 데이터베이스 파일을 만들 SQLite는을 야기 할 수 있습니다&lt;a href=&quot;compile#default_file_format&quot;&gt; SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; 컴파일시 = 1.</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">향후 버전의 SQLite에는 새로운 오류 코드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">새로운 확장 :</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">일반적인 사용을 위해 25 ~ 35 % 더 작은 새로운 파일 형식.</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">이후 버전의 SQLite에는 새로운 플래그가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">응용 프로그램 정의 SQL 함수를 호출 한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들 을 리턴하는 새로운 인터페이스 &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">새로운 인터페이스 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하면 연결 및 런타임마다 크기 및 길이 제한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">새로운 인터페이스 : sqlite3_bind_parameter_index ()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c 애드온 모듈에 새로운 인터페이스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">항상 &quot;sqlite_&quot;로 시작하는 새로운 내부 스키마 객체 이름은 향후 릴리스에서 SQLite 파일 형식에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">새로운 메모리 할당자는 SQLite 소스 트리의 일부이거나 sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 포함되지 않아도됩니다. . 개별 응용 프로그램은 시작시 SQLite에 자체 메모리 할당자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">보조 메모리 사용을 구성하기위한 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 새로운 옵션 : --pagecache, --lookaside 및 --scratch</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">새로운 쿼리 최적화 :</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">새로운 런타임 제한 범주는 다음 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">새로운 상태 매개 변수가 때때로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">테스트 스위트에 새로운 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">SQLite의 향후 향상을 위해 새로운 텍스트 토큰이 통계 열의 끝에 추가 될 수 있습니다. 호환성을 위해 통계 열의 끝에서 인식 할 수없는 토큰은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">다음 릴리스에서는 새로운 추적 상수가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">향후 SQLite 릴리스에 새 동사가 추가 될 수 있습니다. 기존 동사가 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 단종 또는 지원되지 않는 동사가 불려 갔을 경우 인터페이스 0이 아닌 에러 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLite의 향후 릴리스에 새로운 동사가 추가 될 수 있습니다. 기존 동사가 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 단종 또는 지원되지 않는 동사가 불려 갔을 경우 인터페이스 0이 아닌 에러 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">새로운 zip 아카이브는 zipfile () 집계 함수를 사용하여 메모리 내에 완전히 구성 될 수 있습니다. 집계 함수가 방문한 각 행은 Zip 아카이브에 항목을 추가합니다. 반환 된 값은 전체 아카이브 이미지를 포함하는 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">그러나 최신 디스크 드라이브는 4096 바이트 섹터를 사용하기 시작했습니다. SQLite 개발 팀 은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16) 부터 xSectorSize 변경을 실험하여 폭발 반경으로 4096 바이트를보고했습니다. 이는 많은 데이터베이스에서 쓰기 오버 헤드를 증가시키는 효과가있었습니다. 기호가있는 데이터베이스의 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA의 PAGE_SIZE&lt;/a&gt; 그것은 단지 한 페이지 즉 백업 한 이전 반면 데이터베이스의 단일 페이지에 대한 변경을 1,024 (매우 일반적인 선택)의 지금 롤백 저널에 백업 세 가지 다른 인접 페이지에 SQLite는 필요 바뀌고 있었다. 에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; , 각 거래는 거래 당 기록되는 추가 바이트의 수천의 결과로, 오히려 다음 512 바이트 경계보다는 WAL 파일에 다음 4096 바이트 경계 밖으로 패딩했다.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">다음으로, 다음과 같은 명령을 사용하여 모든 블로 브를 디렉토리의 개별 파일로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">그런 다음 결과 kvtest-android 실행 파일을 Android 장치로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">다음으로 오렌지뿐만 아니라 캘리포니아에서 자란 오렌지의 가격을 찾고 싶다고 가정 해보십시오. 적절한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">아니요 (주 1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">동일한 데이터베이스 연결에서 작업간에 격리가 없음</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">작성 및 디버그 할 애플리케이션 파일 I / O 코드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">변경 없음</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">현재 또는 충돌하는 행 정보가 제공되지 않습니다. 제공된 sqlite3_changeset_iter 핸들에서 호출 할 수있는 유일한 함수는 sqlite3changeset_fk_conflicts ()입니다.</target>
        </trans-unit>
        <trans-unit id="7c5c383086cc31c41ab2122a84d0a48706ccfc11" translate="yes" xml:space="preserve">
          <source>No error is raised if a width or precision exceeds SQLITE_PRINTF_PRECISION_LIMIT. Instead, the large width or precision is silently truncated.</source>
          <target state="translated">너비 또는 정밀도가 SQLITE_PRINTF_PRECISION_LIMIT를 초과하면 오류가 발생하지 않습니다. 대신 큰 너비 또는 정밀도가 자동으로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">알 수없는 pragma가 발행되면 오류 메시지가 생성되지 않습니다. 알 수없는 pragma는 단순히 무시됩니다. 이것은 pragma 문에 오타가 있으면 라이브러리는 사용자에게 사실을 알리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">잠금 스타일이 없습니다. 위의 사항 중 어느 것도 지원할 수없는 경우이 잠금 스타일이 사용됩니다. 데이터베이스 잠금 메커니즘이 사용되지 않습니다. 이 시스템을 사용하면 여러 클라이언트가 단일 데이터베이스에 액세스하는 것이 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">데이터베이스에서 잠금이 유지되지 않습니다. 데이터베이스를 읽거나 쓸 수 없습니다. 내부적으로 캐시 된 데이터는 모두 의심스러운 것으로 간주되며 사용하기 전에 데이터베이스 파일에 대한 검증 대상이됩니다. 다른 프로세스는 자체 잠금 상태가 허용하는대로 데이터베이스를 읽거나 쓸 수 있습니다. 이것이 기본 상태입니다.</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">더 이상 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">누구도 규칙을 따르거나 규칙을 알고 있거나 규칙이 좋은 생각이라고 생각할 필요가 없습니다. SQLite의 창립자는 규칙을 따르는 사람은 누구나 더 행복하고 생산적인 삶을 살 것으로 생각하지만 개인은 원하는 경우 그 조언에 자유롭게 이의를 제기하거나 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">다른 프로세스는 데이터베이스를 변경할 수 없으므로 트랜잭션 시작시 변경 카운터를 확인하고 사용자 공간 캐시를 지울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">RBU 업데이트가 적용되는 동안 대상 데이터베이스에서 다른 쓰기가 발생할 수 없습니다. 이를 방지하기 위해 대상 데이터베이스에 읽기 잠금이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">트랜잭션을 제외하고는 읽거나 쓰지 않습니다. 데이터베이스에 액세스하는 모든 명령 (기본적으로 일부 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문을 제외한 모든 SQL 명령 )은 트랜잭션이 아직 유효하지 않은 경우 자동으로 트랜잭션을 시작합니다. 마지막 SQL 문이 완료되면 자동으로 시작된 트랜잭션이 커미트됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">union-vtab의 테이블에 의해 설정된 rowid 범위를 벗어난 항목이 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">SQLite 데이터베이스에서 정보를 삭제하면 사용되지 않은 디스크 공간이 내부 &quot;사용 가능 목록&quot;에 추가되고 다음에 데이터를 삽입 할 때 재사용됩니다. 디스크 공간이 손실되지 않습니다. 그러나 운영 체제로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">비 ASCII 범위 문자 (즉, 127보다 큰 유니 코드 코드 포인트) 또는</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Vista 이외의 Windows 플랫폼은 하나의 DST 규칙 세트 만 지원합니다. Vista는 두 가지만 지원합니다. 따라서 이러한 플랫폼에서 히스토리 DST 계산은 올바르지 않습니다. 예를 들어 미국에서는 2007 년에 DST 규칙이 변경되었습니다. Vista 이외의 Windows 플랫폼은 이전 2007 년에도 새로운 2007 DST 규칙을 적용합니다. Vista는 규칙이 변경되었을 때 1986 년으로 돌아가서 결과를 올바르게 얻는 것이 다소 나아졌습니다.</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">비 결정적 함수는 인수가 항상 같더라도 호출마다 다른 응답을 제공 할 수 있습니다. 다음은 비 결정적 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">비 스트리밍 동등</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">변경 세트 (또는 패치 세트)를 입력으로 허용하는 비 스트리밍 기능을 사용하려면 전체 변경 세트를 메모리의 단일 버퍼에 저장해야합니다. 마찬가지로, 변경 세트 또는 패치 세트를 반환하는 것은 sqlite3_malloc ()을 사용하여 할당 된 하나의 큰 버퍼에 대한 포인터를 반환함으로써 그렇게합니다. 일반적으로 이것은 편리합니다. 그러나 메모리가 적은 환경에서 실행되는 응용 프로그램이 매우 큰 변경 세트를 처리해야하는 경우 필요한 대량의 연속 메모리 할당이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">SQLite가 존재 한 첫 10 년 동안 안전한 프로그래밍 언어는 존재하지 않았습니다. SQLite는 Go 또는 Rust로 코딩 될 수 있지만 그렇게하면 수정 된 것보다 훨씬 많은 버그가 발생할 수 있으며 코드 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">xBegin ()에 대한 호출과 xCommit () 또는 xRollback () 사이를 제외하고 xSavepoint (), xRelease () 또는 xRollbackTo () 메소드는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">일반 함수는 xFunc 만 지정하고 xStep 및 xFinal은 NULL로 설정합니다. 집계 함수는 xStep 및 xFinal을 지정하고 xFunc를 NULL로 설정합니다. 별도의 sqlite3_create_aggregate () API가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8feff5d8988d2d3b3f82fe7920cdb81d5ba04e3a" translate="yes" xml:space="preserve">
          <source>Normal meaning</source>
          <target state="translated">정상적인 의미</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">일반적으로 FTS5는 기본 FTS5 테이블에 삽입 된 토큰에 각 열 값의 크기를 별도의 테이블에 저장하는 특수 백업 테이블을 데이터베이스 내에 유지합니다. 이 백업 테이블은 &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API 함수에서 사용되며 내장 된 &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 순위 함수 &lt;/a&gt;에서 사용되며 다른 순위 함수에도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">일반적으로 NULL SQL 결과는 &lt;a href=&quot;#nullvalue&quot;&gt;널값&lt;/a&gt; 설정을 사용하여 배열에 저장됩니다 . 그러나 &lt;b&gt;-withoutnulls&lt;/b&gt; 옵션을 사용하면 NULL SQL 값으로 인해 해당 배열 요소가 대신 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">일반적으로 SQLite는 섹터의 일부를 업데이트하는 동안 정전이 발생하면 복구 후 전체 장치 섹터의 내용이 의심되는 것으로 가정합니다. 파일 내의 섹터의 어느 부분 에나 쓴 후, 수정 된 섹터 내용은 시스템 내의 어딘가에 휘발성 버퍼 (메인 메모리, 디스크 캐시 등)에 저장되어 있다고 가정합니다. SQLite는 업데이트 된 데이터가 성공적으로 완료 될 때까지 영구 스토리지 미디어에 도달했다고 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">일반적으로 토큰 또는 토큰 접 두부 쿼리는 MATCH 연산자의 왼쪽으로 지정된 FTS 테이블 열과 일치합니다. 또는 FTS 테이블과 이름이 같은 특수 열이 지정된 경우 모든 열에 대해 지정됩니다. 기본 용어 쿼리 전에 column-name 다음에 &quot;:&quot;문자를 지정하여이를 대체 할 수 있습니다. &quot;:&quot;과 쿼리 할 용어 사이에 공백이있을 수 있지만 column-name과 &quot;:&quot;문자 사이에는 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">일반적으로 SQL 인덱스는 테이블의 열을 참조합니다. 그러나 테이블 열과 관련된 표현식에서 인덱스를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">일반적으로 화석은 개인과 공용 지점 사이를 전환 할 때 체크 아웃의 모든 파일을 수정합니다. 그러나이 시점에서 파일은 두 분기에서 동일하므로 수정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">일반적으로 전체 텍스트 쿼리는 대소 문자를 구분하지 않습니다. 그러나 이는 쿼리중인 FTS 테이블에서 사용 하는 특정 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 에 따라 다릅니다 . 자세한 내용 은 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">일반적으로 FTS 모듈은 테이블의 모든 열에있는 모든 항의 역 인덱스를 유지합니다. 이 옵션은 항목을 색인에 추가하지 않아야하는 열 이름을 지정하는 데 사용됩니다. 인덱스에서 여러 열을 생략하도록 지정하기 위해 여러 개의 &quot;인덱싱되지 않은&quot;옵션을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">일반적으로 데이터베이스 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 데이터베이스가 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum을&lt;/a&gt; 지원하는지 여부 는 데이터베이스 파일이 실제로 작성되기 전에 구성되어야합니다. 그러나 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 모드 가 아닌 경우 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 / 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragma를 사용하여 데이터베이스를 즉시 VACUUMing 하여 기존 데이터베이스 의 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 / 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 속성을 변경할 수 있습니다 . 에 때 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 모드 만 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum의&lt;/a&gt; 지원 속성은 진공을 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">일반적으로 SQLite는 데이터베이스 파일에 쓸 때 쓰기 작업이 완료 될 때까지 기다렸다가 호출 응용 프로그램에 제어권을 반환합니다. 파일 시스템에 쓰는 것은 일반적으로 CPU 바운드 작업에 비해 매우 느리기 때문에 성능 병목 현상이 발생할 수 있습니다. 비동기 I / O 백엔드는 SQLite가 백그라운드에서 실행되는 별도의 스레드를 사용하여 모든 쓰기 요청을 수행하도록하는 확장입니다. 이렇게해도 전체 시스템 리소스 (CPU, 디스크 대역폭 등)가 줄어들지는 않지만 데이터베이스에 쓸 때에도 SQLite가 호출자에게 제어권을 신속하게 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">일반적으로 행이 다양한 전체 텍스트 인덱스 항목 및 기타 데이터뿐만 아니라 FTS5 테이블에 삽입 될 때 행의 사본은 FTS5 모듈이 관리하는 개인 테이블에 저장됩니다. 사용자 또는 보조 기능 구현이 FTS5 테이블에서 컬럼 값을 요청하면이 개인 테이블에서 컬럼 값을 읽습니다. &quot;content&quot;옵션을 사용하면 FTS 전체 텍스트 인덱스 항목 만 저장하는 FTS5 테이블을 만들 수 있습니다. 열 값 자체는 일반적으로 연관된 전체 텍스트 인덱스 항목보다 훨씬 크기 때문에 상당한 데이터베이스 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">모든 응용 프로그램이 이러한 조건을 충족하는 것은 아닙니다. 다행히도 NGQP는 이러한 조건이 없더라도 여전히 좋은 쿼리 계획을 찾습니다. 그러나 성능 회귀가 발생할 수있는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">모든 테스트 사례를 이러한 방식으로 처리 할 수있는 것은 아닙니다. 일부 테스트 사례는 디스크 액세스 수, 정렬 작업, 전체 스캔 단계 또는 쿼리 중에 발생하는 기타 처리 단계를 계산하여 최적화가 실제로 계산량을 줄이고 있는지 확인합니다. 최적화가 비활성화되면 해당 테스트 사례가 실패한 것으로 나타납니다. 그러나 대부분의 테스트 사례는 단순히 정답을 얻었는지 확인하고 최적화가 오작동을 일으키지 않음을 나타 내기 위해 모든 경우를 최적화 유무에 관계없이 성공적으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d047995ecc6203bb86f7cef3de1f0a2b4fa5dba8" translate="yes" xml:space="preserve">
          <source>Not ever decimal number with fewer than 16 significant digits can be represented exactly as a binary64 number. In fact, most decimal numbers with digits to the right of the decimal point lack an exact binary64 equivalent. For example, if you have a database column that is intended to hold an item price in dollars and cents, the only cents value that can be exactly represented are 0.00, 0.25, 0.50, and 0.75. Any other numbers to the right of the decimal point result in an approximation. If you provide a &quot;price&quot; value of 47.49, that number will be represented in binary64 as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">위의 예 에는 새 테이블의 다양한 측면을 구성하기 위해 CREATE VIRTUAL TABLE 문의 일부로 FTS5에 제공 할 수있는 &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;다양한 옵션&lt;/a&gt; 도 있습니다. FTS5 테이블이 문서 및 쿼리에서 용어를 추출하는 방식을 수정하거나 디스크에 추가 인덱스를 생성하여 접두사 쿼리 속도를 높이거나 다른 곳에 저장된 콘텐츠에 대한 인덱스 역할을하는 FTS5 테이블을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건을&lt;/a&gt; 추가 할 때 CHECK 제약 조건은 기존 테이블 행에 대해 테스트되지 않습니다. 이로 인해 CHECK 제약 조건을 위반하는 데이터가 포함 된 테이블이 생성 될 수 있습니다. 이후 버전의 SQLite는 CHECK 제약 조건이 추가 될 때 유효성을 검사하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">&quot;단일 증가&quot;는 ROWID가 항상 정확히 1 씩 증가한다는 것을 의미하지는 않습니다. 하나는 일반적인 증분입니다. 그러나 고유 제한 조건으로 인해 삽입에 실패하면 실패한 삽입 시도의 ROWID가 후속 삽입에서 재사용되지 않아 ROWID 순서에 공백이 생길 수 있습니다. AUTOINCREMENT는 자동으로 선택된 ROWID가 증가하지만 순차적 인 것은 아님을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 응용 프로그램이 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의 하면 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2de1256b9fbe19c405bb475cc7365f640da5726d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;../appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;../appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 애플리케이션이 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의하는 경우 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2a8f4592d0e17a85103883247d0a4447a3744957" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">참고 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수는&lt;/a&gt; 기본적으로 비 결정적으로 간주되고,하지 않는 한 CREATE INDEX 문에 사용되지 않을 수 있습니다 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 함수가 등록 될 때 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1de4b11ed42096116749429497dc130939876ea1" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 애플리케이션이 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의하는 경우 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">참고 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수는&lt;/a&gt; 기본적으로 비 결정적으로 간주되고,하지 않는 한 CREATE INDEX 문에 사용되지 않을 수 있습니다 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 함수가 등록 될 때 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 응용 프로그램이 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의 하면 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Idx3에는 원본 &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt; 과 동일한 정보가 모두 포함되어 있습니다 . 따라서 Idx3이 있다면 더 이상 Idx1이 필요하지 않습니다. &quot;복숭아 가격&quot;쿼리는 Idx3의 &quot;상태&quot;열을 무시하여 Idx3을 사용하여 만족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">MinGW는 32 비트 DLL 만 생성합니다. 64 비트 DLL을 생성하는 데 사용할 수있는 별도의 MinGW64 프로젝트가 있습니다. 아마도 명령 줄 구문은 비슷합니다. 또한 최신 버전의 MSVC는 WinXP 및 이전 버전의 Windows에서는 작동하지 않는 DLL을 생성합니다. 따라서 생성 된 DLL의 최대 호환성을 위해 MinGW가 권장됩니다. 가장 좋은 방법은 MinGW를 사용하여 32 비트 DLL을 생성하고 MSVC를 사용하여 64 비트 DLL을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNORE는 &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 반환 된 &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNORE는 &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 반환 된 &lt;a href=&quot;c_fail&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="63e763dca84d9237a89baecc3d0c141975e41415" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the number of reserve-bytes to be increased but not decreased. So if a database file already has a reserve-bytes value greater than 8, there is no way to activate checksumming on that database, other than to dump and restore the database file. Note also that other extensions might also make use of the reserve-bytes. Checksumming will be incompatible with those other extensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">SQLite를 사용하면 IN 또는 NOT IN 연산자의 오른쪽에있는 괄호로 묶인 스칼라 값 목록이 빈 목록이 될 수 있지만 대부분의 다른 SQL 데이터베이스 데이터베이스 엔진 및 SQL92 표준에는 목록에 하나 이상의 요소가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">SQLite는 적절한 확장자 접미사 (Windows의 경우 &quot;.dll&quot;, Mac의 경우 &quot;.dylib&quot;, 대부분의 다른 유닉스의 경우 &quot;.so&quot;)를 자동으로 확장자 파일 이름에 추가합니다. 일반적으로 확장자의 전체 경로 이름을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLite에는 압도적 인 대다수의 응용 프로그램에 완벽하게 적합한 여러 &lt;a href=&quot;../malloc#altalloc&quot;&gt;내장 메모리 할당자가 포함&lt;/a&gt; 되어 있으며이 객체는 특수한 메모리 할당 요구 사항을 가진 소수의 응용 프로그램에만 유용합니다. 이 객체는 또한 SQLite가 이러한 조건에서 정상적으로 복구되는지 확인하기 위해 메모리 부족 메모리 조건을 시뮬레이트하는 대체 메모리 할당자를 지정하기 위해 SQLite를 테스트하는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLite에는 압도적 인 대다수의 응용 프로그램에 완벽하게 적합한 여러 &lt;a href=&quot;malloc#altalloc&quot;&gt;내장 메모리 할당자가 포함&lt;/a&gt; 되어 있으며이 객체는 특수한 메모리 할당 요구 사항을 가진 소수의 응용 프로그램에만 유용합니다. 이 객체는 또한 SQLite가 이러한 조건에서 정상적으로 복구되는지 확인하기 위해 메모리 부족 메모리 조건을 시뮬레이트하는 대체 메모리 할당자를 지정하기 위해 SQLite를 테스트하는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">SQLite는 WITHOUT ROWID 가상 테이블에 대해 PRIMARY KEY를 시행하지 않습니다. 적용은 기본 가상 테이블 구현의 책임입니다. 그러나 SQLite는 PRIMARY KEY 제약 조건이 유효하다고 가정합니다. 식별 된 열은 실제로 UNIQUE이며 NOT NULL이 아니며 가상 테이블에 대해 쿼리를 최적화하기 위해 해당 가정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">SQLite는 운영 체제 및 하드웨어가 동기화 요청의 상태에 대해 알려주는 것을 믿어야합니다. SQLite가 거짓말 중이거나 쓰기가 잘못되었음을 감지하는 방법은 없습니다. 그러나 &lt;a href=&quot;wal&quot;&gt;WAL 모드의&lt;/a&gt; SQLite 는 기본 롤백 저널 모드보다 비 순차적 쓰기를 용서합니다. WAL 모드에서 실패한 동기화 작업으로 인해 데이터베이스가 손상 될 수있는 유일한 시간은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업 중입니다. COMMIT 중 동기화 실패로 인해 내구성이 손실 될 수 있지만 데이터베이스 파일은 손상되지 않습니다. 따라서 동기화 조작 실패로 인한 데이터베이스 손상에 대한 한 가지 방어선은 WAL 모드에서 SQLite를 사용하고 가능한 한 자주 체크 포인트를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">SQLite는 정렬 된 데이터 구조 인 b- 트리를 사용하므로 SELECT 문의 WHERE 절에 동등 또는 부등식에 대한 테스트가 포함 된 경우 인덱스를 사용할 수 있습니다. 다음과 같은 쿼리는 사용 가능한 경우 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">선언 된 유형의 &quot;FLOATING POINT&quot;는 &quot;POINT&quot;의 끝에있는 &quot;INT&quot;로 인해 RETE 선호도가 아닌 INTEGER 선호도를 제공합니다. 선언 된 &quot;STRING&quot;유형은 TEXT가 아니라 NUMERIC의 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">다각형을 뒤집는 변형은 꼭지점 순서가 뒤바뀔 수 있습니다. 다시 말해, 변환으로 꼭지점이 시계 반대 방향이 아닌 시계 방향으로 순환 할 수 있습니다. 변환 후 &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw ()&lt;/a&gt; 함수를 통해 결과를 보내서이를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">내부 트랜잭션은 커밋 (RELEASE 명령 사용) 할 수 있지만 나중에 외부 트랜잭션에서 ROLLBACK에 의해 작업이 취소됩니다. 정전 또는 프로그램 충돌 또는 OS 충돌로 인해 가장 바깥 쪽 트랜잭션이 롤백되어 해당 외부 트랜잭션 내에서 발생한 모든 변경 사항을 취소하고 RELEASE 명령에 의해 &quot;커밋 된&quot;변경 내용도 취소됩니다. 가장 바깥 쪽 트랜잭션이 커밋 될 때까지 실제로 콘텐츠는 디스크에서 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">여러 원격 변경 집합의 충돌 해결은 행 단위가 아니라 필드 단위로 결합됩니다. 이는 다중 원격 UPDATE 조작의 경우 단일 로컬 변경의 일부 필드는 REPLACE에 대해 리베이스되고 다른 필드는 OMIT에 대해 리베이스 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be와 UTF-16le 간의 변환은 항상 제자리에서 수행되며 이전 포인터가 가리키는 버퍼의 내용이 수정 되었음에도 불구하고 이전 포인터를 무효화하지 않습니다. 다른 종류의 변환은 가능할 때 수행되지만 언젠가는 불가능하며 이러한 경우 이전 포인터가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">zip 아카이브에서 레코드를 삭제해도 아카이브 내에서 사용 된 공간을 회수하지는 않습니다. 아카이브 &quot;중앙 디렉토리 구조&quot;에서 항목을 제거하기 만하면 항목에 액세스 할 수 없습니다. 이 비 효율성을 해결하는 한 가지 방법은 편집 된 아카이브의 내용을 기반으로 새 zip 아카이브를 만드는 것입니다. 예를 들어 가상 테이블 temp.zzz를 통해 액세스 한 아카이브를 편집 한 후 :</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">운영 체제마다 공유 라이브러리에 다른 파일 이름 접미사를 사용합니다. Windows는 &quot;.dll&quot;을 사용하고 Mac은 &quot;.dylib&quot;를 사용하며 mac 이외의 대부분의 유닉스는 &quot;.so&quot;를 사용합니다. 코드를 이식 가능하게 만들려면 공유 라이브러리 파일 이름에서 접미사를 생략하면 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스에 의해 적절한 접미사가 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">shm 파일의 각 32768 바이트 단위에는 고유 한 aHash 및 aPgno 배열이 있습니다. 단일 장치의 aHash 배열은 동일한 장치에서 aPgno 항목을 찾는 데만 도움이됩니다. 전체 FindFrame (P, M) 함수는 최신 단위로 시작하여 해답을 찾을 때까지 가장 오래된 단위로 거꾸로 해시 조회를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">FTS3을 활성화하면 FTS4도 사용할 수 있습니다. 별도의 SQLITE_ENABLE_FTS4 컴파일 타임 옵션이 없습니다. SQLite 빌드는 FTS3과 FTS4를 모두 지원하거나 둘 다 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">위에서 상세하게 설명한 몇 가지 대소 문자 차이를 제외하고 WITHOUT ROWID 테이블과 rowid 테이블은 동일하게 작동합니다. 그들은 동일한 SQL 문이 주어지면 동일한 대답을 생성합니다. 따라서 WITHOUT ROWID 테이블 사용이 도움이 될지 여부를 테스트하기 위해 개발주기 후반에 애플리케이션에서 실험을 실행하는 것은 간단합니다. 좋은 전략은 제품 개발이 끝날 때까지 ROWID없이 걱정하지 말고, 정수가 아닌 PRIMARY KEY가있는 테이블에 ROWID없이 ROWID를 추가하여 성능을 향상 시키거나 손상시키는 지 확인하고 ROWID 만 유지하는 것입니다. 도움이되는 경우.</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">geopoly는 왼쪽 아래에 원점이있는 전통적인 오른손 데카르트 좌표계를 사용하는 반면 SVG는 왼쪽 위에 원점이있는 왼손 좌표계를 사용합니다. geopoly_svg () 루틴은 좌표계 변환을 시도하지 않으므로 표시된 이미지가 미러 이미지로 표시되고 회전됩니다. 이것이 바람직하지 않은 경우, geopoly_xform () 루틴을 사용하여 다각형을 geopoly_svg ()로 전달하기 전에 출력을 직교에서 SVG 좌표로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">비 결정적 함수에 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 태그가 지정 되고 해당 함수가 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; 에서 사용되면 함수가 다른 응답을 리턴하기 시작하면 연관된 인덱스가 손상 될 수 있습니다. . SQL 함수가 거의 결정 론적이며 (즉, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같이 거의 변경되지 않는 경우 ) 손상된 인덱스에서 사용되는 경우 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 를 실행하여 손상을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c13f9095e78ebed2a9c8d270bb63e3a9b47c70fe" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">비 결정적 함수에 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 태그가 지정 되고 해당 함수가 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; 에서 사용되는 경우 함수가 다른 응답을 반환하기 시작하면 관련 인덱스가 손상 될 수 있습니다. . SQL 함수가 거의 결정적 (즉, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같이 거의 변경되지 않는 경우 )이고 손상된 인덱스에서 사용되는 경우 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 를 실행하여 손상을 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">동적 뮤텍스 매개 변수 중 하나 (SQLITE_MUTEX_FAST 또는 SQLITE_MUTEX_RECURSIVE)가 사용 된 경우 sqlite3_mutex_alloc ()은 모든 호출에서 다른 뮤텍스를 반환합니다. 정적 뮤텍스 유형의 경우 동일한 유형 번호를 가진 모든 호출에서 동일한 뮤텍스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">WHERE 절에 &quot;langid = N&quot;용어를 포함시키지 않으면 검색은 언어 0 (위의 예에서는 영어)에 대해 수행됩니다. 모든 spellfix1 검색은 단일 언어 ID에 대한 것입니다. 한 번에 모든 언어를 검색 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">대부분의 경우 SQLite는 쿼리의 FROM 절에있는 각 테이블에 대해 단일 인덱스 만 사용합니다. 여기에 설명 된 두 번째 OR 절 최적화는 해당 규칙의 예외입니다. OR 절을 사용하면 OR 절의 각 하위 용어에 대해 서로 다른 색인이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">특수한 &quot;: memory :&quot;이름을 적용하고 순수한 인 메모리 데이터베이스를 만들려면 파일 이름에 추가 텍스트가 없어야합니다. 따라서 &quot;./:memory :&quot;와 같이 경로 이름을 앞에 붙여 디스크 기반 데이터베이스를 파일에 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">위의 다이어그램에서 개인 편집 내용을 단일 커밋으로 표시했습니다. 이것은 명확하게 표현하기위한 것입니다. 수십 또는 수백 개의 개별적인 작은 변화를 수행하고 각각 개별적으로 커밋하는 것을 막을 수있는 것은 없습니다. 실제로, 많은 작은 변경을하는 것이 선호되는 작업 방법입니다. 단일 커밋에서 모든 변경을 수행하는 유일한 이유는 다이어그램을 더 쉽게 그릴 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">이 디자인에서 토크 나이 저는 파서를 호출합니다. YACC와 BISON에 익숙한 사람들은 파서가 토크 나이저라고하는 다른 방식으로 일하는 것에 익숙 할 것입니다. 하지만 토크 나이저가 파서를 호출하면 스레드에 안전하고 빠르게 실행될 수 있기 때문에 파서가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">삽입 함수 ( &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; )는 인수의 순서를 반대로합니다. 따라서 &quot;like (A, B)&quot;는 &quot;B like A&quot;와 같습니다. &quot;B like A&quot;형식의 경우 B 용어는 함수의 첫 번째 인수로 간주됩니다. 그러나 &quot;like (A, B)&quot;의 경우 A 용어가 첫 번째 인수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">&quot;.import&quot;명령을 실행하기 전에 &quot;mode&quot;를 &quot;csv&quot;로 설정해야합니다. 이것은 명령 행 쉘이 입력 파일 텍스트를 다른 형식으로 해석하지 못하게하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">인덱스 검색을 효율적으로하기 위해 R * Tree 인덱스의 모든 좌표를 제한 할 필요는 없습니다. 예를 들어 35 번째 병렬과 겹치는 모든 객체를 쿼리하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">$ bigstring 값을 인용 할 필요는 없습니다. 자동으로 발생합니다. $ bigstring이 큰 문자열 또는 이진 객체 인 경우이 기술은 쓰기가 쉬울뿐만 아니라 $ bigstring의 내용을 복사하지 않기 때문에 훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">두 개 이상의 스레드가 SQLite 라이브러리를 사용하여 동일한 SQLite 데이터베이스 파일에 액세스하는 것이 안전합니다. SQLite 용 유닉스 드라이버는 POSIX 권고 잠금 문제를 알고 해결합니다. 스레드가 SQLite 라이브러리를 무시하고 데이터베이스 파일을 직접 읽으려고 할 때만이 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">데이터베이스 파일 이름의 확장자는 매우 중요합니다. 확장명이 없으면 SQLite는 파일의 기본 이름을 추가하여 보조 파일 이름을 만듭니다. 따라서 &quot; &lt;code&gt;db01&lt;/code&gt; &quot; 이라는 데이터베이스 에는 &quot; &lt;code&gt;db01-journal&lt;/code&gt; &quot; 이라는 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 파일 이 있습니다 . 이 파일 이름은 3 자로 단축되는 확장자가 없으므로 그대로 사용되며 8 + 3 명명 규칙을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 이전에 xCreate 메소드를 호출하기 전에 NULL을 확인하지 않았습니다. 따라서 &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;시연&lt;/a&gt; 전용 가상 테이블이 SQLite 버전 3.8.11.1 (2015-07-29) 이하 로 등록되어 있고 해당 가상 테이블 모듈에 대해 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 명령이 시도되면 NULL 포인터로 점프하여 결과적으로 충돌.</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">gcov와 함께 SQLite를 실행하는 것은 SQLite의 테스트가 아니라 테스트 스위트의 테스트입니다. -fprofile-args 및 -ftest-coverage 옵션으로 인해 컴파일러가 다른 코드를 생성하므로 gcov 실행은 SQLite를 테스트하지 않습니다. gcov 실행은 테스트 스위트가 100 % 분기 테스트 범위를 제공하는지 확인합니다. gcov 실행은 테스트 테스트-메타 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 상수는 또한 전위로부터 반환 값으로서 사용된다 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 콜백 것을 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT는&lt;/a&gt; 또한 인 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">있습니다 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 와 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes는 ()&lt;/a&gt; 인터페이스는 트리거 해고 대신에 포함되지 않습니다,하지만 &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes 프라그가&lt;/a&gt; INSTEAD 트리거 발사 카운트 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 상수는 또한 전위로부터 반환 값으로서 사용된다 &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 콜백 것을 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT는&lt;/a&gt; 또한 인 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">DO UPDATE 절은 INSERT 중에 제한 조건 오류가 발생한 단일 행에서만 작동합니다. 조치를 해당 한 행으로 제한하는 WHERE 절을 포함 할 필요는 없습니다. DO UPDATE 끝에서 WHERE 절의 유일한 사용은 원래 값 및 / 또는 새 값에 따라 DO UPDATE를 no-op로 선택적으로 변경하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">SQLITE_TEXT 상수는 SQLite 버전 2에서도 완전히 다른 의미로 사용되었습니다. SQLite 버전 2와 SQLite 버전 3 모두에 연결되는 소프트웨어는 SQLITE_TEXT가 아닌 SQLITE3_TEXT를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">SQLite 파서는 가능하면 색인을 사용하기위한 코드를 항상 생성하지는 않습니다. 다음 쿼리는 현재 인덱스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">복합 쿼리에 대한 UNION ALL 연산자는 자체적으로 일시적인 인덱스를 사용하지 않습니다 (물론 UNION ALL의 오른쪽 및 왼쪽 하위 쿼리는 구성 방식에 따라 일시적인 인덱스를 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">권한 부 여자 콜백은 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 그 변형 동안에 만 호출됩니다 . &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 명령문 평가 중에 권한 부여는 수행되지 않습니다 . 이전 단락에서 언급 한대로 sqlite3_step ()은 sqlite3_prepare_v2 ()를 호출하여 스키마 변경 후 명령문을 다시 준비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">권한 부 여자 콜백은 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 그 변형 동안에 만 호출됩니다 . &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 명령문 평가 중에 권한 부여는 수행되지 않습니다 . 이전 단락에서 언급 한대로 sqlite3_step ()은 sqlite3_prepare_v2 ()를 호출하여 스키마 변경 후 명령문을 다시 준비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">SQLite에서 사용하는 문자 인코딩 메커니즘은 런타임시 변경할 수 없습니다. 이것은 컴파일 타임 옵션입니다. &lt;b&gt;sqlite_encoding&lt;/b&gt; 문자열은 라이브러리가 컴파일 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">동기 설정이 FULL 인 경우 롤백 저널의 체크섬이 필요하지 않습니다. 동기가 NORMAL로 낮아질 때 체크섬에만 의존합니다. 그럼에도 불구하고 체크섬은 결코 아프지 않으므로 동기 설정에 관계없이 롤백 저널에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">명령 행 쉘 프로그램은 이미 설정의 일부로 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스를 호출하여 확장로드를 사용 가능하게 하므로 위의 명령은 특별한 스위치, 설정 또는 기타 복잡성없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">소멸자 함수 D는 유형 문자열 T가 아닌 포인터 값 P에 대한 것입니다. 유형 문자열 T는 수명이 무한한 정적 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">정수 키는 삽입 직전에 테이블에 있던 가장 큰 키보다 하나 큰 것입니다. 새 키는 현재 테이블에있는 모든 키에서 고유하지만 이전에 테이블에서 삭제 된 키와 겹칠 수 있습니다. 테이블 수명 동안 고유 한 키를 작성하려면 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 키워드를 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 선언에 추가하십시오 . 그런 다음 선택한 키는 해당 테이블에 존재했던 가장 큰 키보다 하나 더 많습니다. 가장 큰 가능한 키가 해당 테이블에 이미 존재하면 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 는 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 코드 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 journal_mode 는 MEMORY 또는 OFF이며 다른 값으로 변경할 수 없습니다. &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 journal_mode를 MEMORY 또는 OFF 이외의 설정 으로 변경하려는 시도 는 무시됩니다. 또한 트랜잭션이 활성화되어있는 동안 journal_mode를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">위의 루틴 목록은 실제가 아니라 개념적입니다. 이러한 루틴 중 다수는 여러 버전으로 제공됩니다. 예를 들어, 위 목록 에는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 같은 약간 다른 방식으로 동일한 작업을 수행하는 세 개의 별도 루틴이있는 경우 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 이라는 단일 루틴 이 표시됩니다 . 실제로 그러한 루틴이 존재하지 않는 경우 에는 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column ()을&lt;/a&gt; 언급 합니다. 목록에 표시된 &quot;sqlite3_column ()&quot;은 다양한 데이터 유형의 열 데이터를 추가하는 전체 루틴 제품군의 플레이스 홀더입니다.</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">OOM 오버레이를 사용하는 경우에도 메모리 누수 감지 로직이 계속 작동합니다. 이것은 메모리 할당 오류가 발생하더라도 SQLite가 메모리를 누출하지 않는지 확인합니다. OOM 오버레이는 메모리 할당 오용 여부를 확인하는 인스트루먼트 된 메모리 할당자를 포함하여 모든 기본 메모리 할당 기와 함께 작동 할 수 있습니다. 이러한 방식으로 OOM 오류가 다른 종류의 메모리 사용 오류를 유발하지 않는지 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLite가 이해하는 키워드 수는 컴파일 타임 옵션에 따라 달라질 수 있습니다. 예를 들어, SQLite가 &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; 옵션으로 컴파일 된 경우 &quot;VACUUM&quot;은 키워드가 아닙니다 . 또한 SQLite의 향후 릴리스에 새로운 키워드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLite가 이해하는 키워드 수는 컴파일 타임 옵션에 따라 달라질 수 있습니다. 예를 들어, SQLite가 &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; 옵션으로 컴파일 된 경우 &quot;VACUUM&quot;은 키워드가 아닙니다 . 또한 SQLite의 향후 릴리스에 새로운 키워드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">열 선호도를 결정하기위한 규칙의 순서가 중요합니다. 선언 된 유형이 &quot;CHARINT&quot;인 열은 규칙 1과 2 모두와 일치하지만 첫 번째 규칙이 우선하므로 열 선호도는 INTEGER입니다.</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">기본 결과 코드는 항상 확장 결과 코드의 일부입니다. 전체 32 비트 확장 결과 코드가 제공되면 응용 프로그램은 확장 결과 코드의 최하위 8 비트 만 추출하여 항상 해당 기본 결과 코드를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">이 SELECT 쿼리에 대한 프로그램에는 INSERT 예제에 사용 된 트랜잭션 및 커밋 명령이 포함되어 있지 않습니다. SELECT는 데이터베이스를 변경하지 않는 읽기 작업이므로 트랜잭션이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">readfile (X) 및 writefile (X, Y) 함수는 확장 함수이며 핵심 SQLite 라이브러리에 내장되어 있지 않습니다. 이러한 루틴은 &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite 소스 코드 저장소&lt;/a&gt; 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt; 소스 파일에서 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">BLOB 이외의 값을 BLOB로 캐스트 한 결과와 BLOB 값을 BLOB 이외의 값으로 캐스트 한 결과는 데이터베이스 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 이 UTF-8, UTF-16be 또는 UTF-16le 인지에 따라 다를 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_apply_v2 () API는 아직 &lt;b&gt;실험 단계&lt;/b&gt; 이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_start_v2 () API는 아직 &lt;b&gt;실험 단계&lt;/b&gt; 이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">단항 * + * 연산자는 표현식에서 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 를 제거 하며 경우에 따라 표현식의 의미가 미묘하게 변경 될 수 있습니다. 위의 예에서 * x * 열에 &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT 선호도&lt;/a&gt; 가 있으면 비교 &quot;x = 5&quot;가 텍스트로 수행됩니다. 그러나 * + * 연산자는 선호도를 제거합니다. 따라서 &quot;+ x = 5&quot;비교는 * x * 열의 텍스트를 숫자 값 5와 비교하며 항상 false입니다.</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">실제로 허용되지 않는 구문 다이어그램에는 경로가 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">equals 연산자와 equals 연산자에는 두 가지 변형이 있습니다. 같음</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">이것은 단지 생각 실험 일뿐입니다. OpenDocument를 변경할 것을 권장하지 않습니다. 이 기사는 현재 OpenDocument 디자인에 대한 비판도 아닙니다. 이 에세이의 요점은 미래의 파일 형식 디자인을 개선하는 방법을 제안하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">이 문제점은 잠금을 획득하려고 시도 할 때 I / O 오류가 발생한 경우에만 발생합니다. 다른 스레드 또는 프로세스가 이미 충돌 잠금을 보유하고 있기 때문에 잠금이 단순히 부여되지 않으면 손상이 발생하지 않습니다. 공유 메모리에서 파일 잠금을 가져 오는 중에 I / O 오류로 실패 할 운영 체제를 인식하지 못했습니다. 따라서 이것은 실제 문제가 아닌 이론적 인 문제입니다. 말할 필요도없이,이 문제는 결코 야생에서 관찰 된 적이 없습니다. I / O 오류를 시뮬레이트하는 테스트 하네스에서 SQLite의 스트레스 테스트를 수행하는 중에 문제점이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 일치시 0을 리턴하고 문자열이 일치하지 않으면 &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 와 같이 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 일치시 0을 리턴하고 문자열이 일치하지 않으면 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 와 같이 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">연관된 테이블이 삭제되면 트리거가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">SQLite가 SQLITE_THREADSAFE = 0으로 컴파일 될 때 SQLite 스레드 안전을위한 코드는 빌드에서 생략됩니다. 이 경우 시작 시간이나 런타임에 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="32708b7e6e76296f6dad18be6a6d369658183e8b" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 설정이 켜져있는 경우 생성 된 열과 내림차순 인덱스가있는 테이블을 처리하려고 할 때 모호한 오류와 함께 &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 실패합니다. SQLite 버전 3.3.0 및 이전 버전은 생성 된 열 또는 하향 인덱스를 지원하지 않기 때문에 버그로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3822538f7b251248e21c02ba82556fd2e3a92957" translate="yes" xml:space="preserve">
          <source>Note that when the SQLITE_DBCONFIG_LEGACY_FILE_FORMAT setting is on, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command will fail with an obscure error when attempting to process a table with generated columns and a descending index. This is not considered a bug since SQLite versions 3.3.0 and earlier do not support either generated columns or decending indexes.</source>
          <target state="translated">SQLITE_DBCONFIG_LEGACY_FILE_FORMAT 설정이 켜져있는 경우 생성 된 열과 내림차순 인덱스가있는 테이블을 처리하려고 할 때 모호한 오류와 함께 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 실패합니다. SQLite 버전 3.3.0 및 이전 버전은 생성 된 열 또는 하향 인덱스를 지원하지 않기 때문에 버그로 간주되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">LIKE 또는 GLOB 연산자의 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 를 사용하여 준비된 경우 명령문은 자동으로 재분석되고 각 실행 의 첫 번째 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 재 컴파일 됩니다. 이전 실행 이후 오른쪽 매개 변수에 대한 바인딩이 변경되었습니다. 이 재분석 및 재 컴파일은 기본적으로 스키마 변경 후에 발생하는 동일한 조치입니다. 쿼리 플래너가 LIKE 또는 GLOB 연산자의 오른쪽에 바인드 된 새 값을 검사하고 위에서 설명한 최적화를 사용할지 여부를 판별 할 수 있도록 재 컴파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">유형 변환이 발생하면 sqlite3_column_blob (), sqlite3_column_text () 및 / 또는 sqlite3_column_text16 ()에 대한 이전 호출에서 반환 된 포인터가 무효화 될 수 있습니다. 다음과 같은 경우 유형 변환 및 포인터 무효화가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; NORMAL으로 설정된 체크 포인트 (윈도우 나 UNIX FlushFileBuffers (ON으로 fsync ()))가 I / O 또는 장벽 동기화 작업을 실행하는 경우에만 동작한다. 따라서 응용 프로그램이 별도의 스레드 또는 프로세스에서 검사 점을 실행하는 경우 데이터베이스 쿼리 및 업데이트를 수행하는 기본 스레드 또는 프로세스는 동기화 작업에서 절대 차단되지 않습니다. 이렇게하면 사용중인 디스크 드라이브에서 실행중인 응용 프로그램에서 &quot;래치 업&quot;을 방지 할 수 있습니다. 이 구성의 단점은 트랜잭션이 더 이상 지속되지 않으며 정전 또는 하드 리셋 후에 롤백 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">ANALYZE를 사용하면 비용 추정치가 현실에 더 잘 맞고 알고리즘 -1이 NN과 N3에 의해 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">xBestIndex 의 idxNum 및 idxStr 출력은 xFilter에 대한 입력이 필요하므로 xBestIndex는 항상 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 전에 호출 됩니다. 그러나 성공적인 xBestIndex에 따라 xFilter가 호출된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">&quot;임시&quot;에 주목하십시오. 가상 테이블 이름 앞의 한정자 ( &quot;stat&quot;) 이 규정자는 가상 테이블을 임시로 만듭니다. 현재 데이터베이스 연결 기간 동안 만 존재합니다. 이것이 권장되는 접근법입니다.</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">특히 마지막 글 머리 기호에 유의하십시오. sqlite3_set_auxdata () 인터페이스가 반환되기 전에 sqlite3_set_auxdata (C, N, P, X)의 소멸자 X가 즉시 호출 될 수 있습니다. 따라서 sqlite3_set_auxdata ()는 함수 구현의 끝 부분에서 호출되어야하며 sqlite3_set_auxdata ()가 호출 된 후 함수 구현은 P를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">의 사용에주의 &lt;a href=&quot;lang_corefunc#quote&quot;&gt;따옴표 () SQL 기능&lt;/a&gt; 이 트리거에 있습니다. quote () 함수는 인수를 SQL 문에 포함하기에 적합한 형식으로 변환합니다. 숫자 값은 변경되지 않습니다. 작은 따옴표는 문자열 앞뒤에 추가되고 내부 작은 따옴표는 이스케이프됩니다. BLOB 값은 SQL 표준 16 진 BLOB 표기법을 사용하여 렌더링됩니다. quote () 함수를 사용하면 실행 취소 및 재실행에 사용 된 SQL 문이 항상 SQL 삽입으로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">&quot;estimatedRows&quot;, &quot;idxFlags&quot;및 colUsed 필드의 경고에 유의하십시오. 이 필드에는 각각 SQLite 버전 3.8.2, 3.9.0 및 3.10.0이 추가되었습니다. 이러한 필드를 읽거나 쓰는 확장은 먼저 사용중인 SQLite 라이브러리의 버전이 적절한 버전 이상인지 확인해야합니다. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; 에서 반환 된 값 을 상수 3008002, 3009000 및 / 또는 3010000과 비교할 수 있습니다. 이전 버전의 SQLite에 의해 작성된 sqlite3_index_info 구조에서 이러한 필드에 액세스하려는 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">참고 : &quot; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &quot; 로 표시된 기능 은 &lt;a href=&quot;capi3ref&quot;&gt;실험용&lt;/a&gt; 이며 이름이 &lt;s&gt;잘린&lt;/s&gt; 기능 은 &lt;a href=&quot;capi3ref&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">참고 : &quot; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &quot; 로 표시된 기능 은 &lt;a href=&quot;experimental&quot;&gt;실험용&lt;/a&gt; 이며 이름이 &lt;s&gt;잘린&lt;/s&gt; 기능 은 &lt;a href=&quot;experimental&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">참고 :이 기사의 섹션 2.0 및 3.0은 &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; 및 &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt; 에 대한 의견에 따라 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">참고 :이 방법은 MacOS X 10.7 및 iOS 버전 5.0에서 비활성화되어 있으며 항상 SQLITE_MISUSE를 반환합니다. 이러한 시스템에서 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 통해 데이터베이스 당 연결을 공유 캐시 모드로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">참고 :이 방법은 MacOS X 10.7 및 iOS 버전 5.0에서 비활성화되어 있으며 항상 SQLITE_MISUSE를 반환합니다. 이러한 시스템에서 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 통해 데이터베이스 당 연결을 공유 캐시 모드로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">상의주의 사항 &lt;a href=&quot;optoverview&quot;&gt;쿼리 최적화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">LIKE 연산자가 어떻게 구현되는지 확인하십시오. SQLite에서는 사용자 정의 함수이므로 함수 정의 주소는 P3에 지정되어 있습니다. 피연산자 P1은 스택에서 가져 오는 함수 인수의 수입니다. 이 경우 LIKE () 함수는 2 개의 인수를 갖습니다. 인수는 스택에서 역순으로 (오른쪽에서 왼쪽으로) 제거되므로 일치하는 패턴이 맨 위 스택 요소이고 다음 요소는 비교할 데이터입니다. 반환 값이 스택으로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">위의 쿼리 작동 방식에 주목하십시오. R * Tree 색인은 외부 루프에서 실행되어 경도 -81 ..- 79.6 및 위도 35.0..36.2의 경계 상자 내에 포함 된 항목을 찾습니다. 발견 된 각 오브젝트 ID에 대해 SQLite는 demo_data 테이블에서 해당 항목을 찾습니다. 그런 다음 demo_data 테이블의 경계 필드를 contains_in () 함수에 대한 매개 변수로 사용하고 해당 함수가 true를 반환하면 demo_data 테이블의 objname 필드가 쿼리 결과의 다음 행으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">다른 모든 날짜 및 시간 함수는 strftime ()으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">SQLite 테이블을 사용하여 내용을 더 작은 조각으로 나누면 구현에 유연성이 제공됩니다. 응용 프로그램은 시작할 때 모든 내용을 메모리로 읽도록 선택할 수 있습니다. 또는 몇 페이지를 메모리로 읽어서 나머지는 디스크에 보관할 수 있습니다. 또는 한 번에 한 페이지 만 메모리로 읽을 수 있습니다. 또한 응용 프로그램의 버전에 따라 파일 형식을 변경하지 않고도 다른 방법을 선택할 수 있습니다. 모든 컨텐츠가 ZIP 아카이브에서 하나의 큰 XML 파일에있는 경우 이러한 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">&quot;더미&quot;레코드의 &quot;호스트&quot;값이 NULL이므로 result [] 배열에 해당 슬롯의 NULL 포인터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">함수에 대한 매개 변수는 이제 SQLite 버전 2.X에서와 같이 문자열에 대한 포인터 대신 sqlite3_value 구조에 대한 포인터입니다. 이러한 &quot;값&quot;에서 유용한 정보를 추출하는 데 다음 루틴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">공유 잠금은 디스크 자체가 아닌 운영 체제 디스크 캐시에 있습니다. 파일 잠금은 실제로 운영 체제 커널 내의 플래그 일뿐입니다. (자세한 내용은 특정 OS 계층 인터페이스에 따라 다릅니다.) 따라서 운영 체제 충돌 또는 전원 손실이 발생하면 잠금이 즉시 사라집니다. 일반적으로 잠금을 작성한 프로세스가 종료되면 잠금이 사라지는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">fts3tokenize 가상 테이블의 결과 세트에있는 토큰은 토크 나이저 규칙에 따라 변환되었습니다. 이 예에서는 &quot;porter&quot;토크 나이저를 사용 했으므로 &quot;This&quot;토큰은 &quot;thi&quot;로 변환되었습니다. 토큰의 원본 텍스트가 필요한 경우 &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; 함수 와 함께 &quot;start&quot;및 &quot;end&quot;열을 사용하여 검색 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">ListRead와 Next 명령어의 유사성을 주목하십시오. 두 작업 모두이 규칙에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">평균 읽기 성능과 평균 쓰기 성능 간에는 상충 관계가 있습니다. 읽기 성능을 최대화하기 위해 WAL을 가능한 한 작게 유지하고 따라서 모든 COMMIT만큼 자주 체크 포인트를 자주 실행하려고합니다. 쓰기 성능을 최대화하기 위해 가능한 한 많은 쓰기에 대해 각 검사 점의 비용을 상각하려고합니다. 즉, 검사 점을 자주 실행하지 않고 각 검사 점 전에 WAL을 최대한 크게 늘리기를 원합니다. 따라서 검사 점을 실행하는 빈도는 응용 프로그램의 상대적 읽기 및 쓰기 성능 요구 사항에 따라 응용 프로그램마다 다를 수 있습니다. 기본 전략은 WAL이 1000 페이지에 도달하면 검사 점을 실행하는 것이며이 전략은 워크 스테이션의 테스트 응용 프로그램에서 잘 작동하는 것 같습니다.그러나 다른 전략은 다른 플랫폼이나 다른 워크로드에서 더 잘 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">이제 MSVC ++ 6에서 다시 컴파일</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">이제 fdatasync () 함수가없는 Solaris 및 OpenBSD 및 기타 Unix 변형에서 컴파일</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">이제 키가 180cm 이상인 조직의 모든 사람의 이름을 찾기위한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">이제 M과 N이 모두 3500 인 경우를 고려하십시오. Alice 노드는 풍부합니다. 그러나 이러한 각 노드가 하나 또는 두 개의 모서리로만 연결되어 있다고 가정하십시오. 이 경우 옵션 2가 선호됩니다. 옵션 2를 사용하면 외부 루프는 여전히 3500 번 실행되어야하지만 중간 루프는 각 외부 루프에 대해 한두 번만 실행되며 내부 루프는 각 중간 루프에 대해 한 번만 실행됩니다. 따라서 내부 루프의 총 반복 횟수는 약 7000입니다. 반면에 옵션 1은 외부 루프와 중간 루프를 각각 3500 번 실행해야하므로 중간 루프의 1200 만 반복이 발생합니다. 따라서 두 번째 시나리오에서 옵션 2는 옵션 1보다 거의 2000 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">이제이 연습의 요점 인 SQLite에 대한 개인 사용자 정의 수정을 할 차례입니다. &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;명령을 사용하여 개인 브랜치 (아직없는 경우)로 전환 한 다음 텍스트 편집기에서 소스 파일을 불러오고 원하는대로 변경하십시오. 변경을 완료하면 다음 명령을 사용하여 해당 변경을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">이제이 인덱스가 어떻게 사용되는지 봅시다. 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">이제 사용자에게 전화 번호가 하나만 있으면 user.phone 필드에 일반 텍스트가 있고 전화 번호가 여러 개인 경우 JSON 배열이 있다고 가정하십시오. 같은 질문이 있습니다 : &quot;어떤 사용자가 704 지역 코드에 전화 번호를 가지고 있습니까?&quot; 그러나 json_each () 함수는 첫 번째 인수로 올바른 형식의 JSON이 필요하므로 전화 번호가 두 개 이상인 사용자에 대해서만 json_each () 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">공개 및 개인 분기가 다르므로 &quot; &lt;code&gt;fossil update trunk&lt;/code&gt; &quot;및 &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;명령을 실행하면 분기간에 전환 할 때 화석이 체크 아웃에서 파일을 실제로 변경한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">널 (NULL) 표시기는 열 값이 널임을 나타내는 선택적 문자열입니다. 기본값은 빈 문자열입니다. 열 분리 자 및 널 (NULL) 표시기는 선택적 위치 인수입니다. 널 (NULL) 표시기가 지정된 경우 열 분리 자 인수를 지정하고 널 (NULL) 표시기 인수 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">이전 체크 포인트에 의해 데이터베이스에 이미 백필 된 WAL 프레임 수</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">백업을 시도했지만 성공적으로 백업하지 못한 WAL 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">페이로드의 바이트 수</target>
        </trans-unit>
        <trans-unit id="3bacc7e3374d56ead644519a8de907aa11ddb984" translate="yes" xml:space="preserve">
          <source>Number of cells on the current page or btree</source>
          <target state="translated">현재 페이지 또는 btree의 셀 수</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WAL 파일에서 유효하고 커밋 된 프레임 수</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">숫자 및 텍스트 유형은 DISTINCT 키워드에서도 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">숫자 값 (직렬 유형 1-9)은 NULL 이후와 숫자 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">숫자 값은 다음 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">수많은 버그 수정 및 설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">수많은 코드 최적화, 특히 코드 풋 프린트를 더 작게 만들도록 설계된 최적화.</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">수많은 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">수많은 다른 성능 향상</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice 및 기타 사람들이 사용하는 Open Document 프레젠테이션 형식</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice 및 기타 사람들이 사용하는 공개 문서 형식</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">FROM 절이없는 쿼리에서는 OFFSET 절이 무시되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET은 정답을 제공합니다. 그러나 OFFSET에는 오프셋 값에 비례하는 시간이 필요합니다. &quot;LIMIT x OFFSET y&quot;에서 실제로 발생하는 일은 SQLite가 쿼리를 &quot;LIMIT x + y&quot;로 계산하고 첫 번째 y 값을 애플리케이션으로 리턴하지 않고 버리는 것입니다. 따라서 창이 긴 목록의 맨 아래로 스크롤되고 y 값이 점점 커짐에 따라 연속 오프셋 계산에 점점 더 많은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">OLD 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">ON CONFLICT 절</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM 테스트는 OOM 오류를 시뮬레이션하여 수행됩니다. SQLite는 애플리케이션이 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC를&lt;/a&gt; 사용하여 대체 malloc () 구현을 대체 할 수 있도록합니다.,...) 상호 작용. TCL 및 TH3 테스트 하네스는 둘 다 특정 수의 할당 후에 실패하도록 조작 할 수있는 수정 된 malloc () 버전을 삽입 할 수 있습니다. 이러한 계측 된 malloc은 한 번만 실패한 다음 다시 작업을 시작하거나 첫 번째 실패 후에도 계속 실패하도록 설정할 수 있습니다. OOM 테스트는 루프에서 수행됩니다. 루프의 첫 번째 반복에서 계측 된 malloc은 첫 번째 할당에서 실패하도록 조작됩니다. 그런 다음 일부 SQLite 작업이 수행되고 SQLite가 OOM 오류를 올바르게 처리했는지 확인합니다. 그런 다음 계측 된 malloc의 실패 시간 카운터가 1 씩 증가하고 테스트가 반복됩니다. 루프는 시뮬레이션 된 OOM 오류가 발생하지 않고 전체 작업이 완료 될 때까지 계속됩니다. 이와 같은 테스트는 두 번 실행됩니다.계측 된 malloc이 한 번만 실패로 설정되고 계측 된 malloc이 첫 번째 실패 후에 지속적으로 실패한 상태로 다시 한 번.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BY 및 GROUP BY는 이제 경계 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">쿼리에 동일한 GROUP BY가 있으면 ORDER BY가 무시됩니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;B75A9CA6B0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY는 하위 선택에서 작동합니다</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">OS 인터페이스</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OS 인터페이스 파일 가상 메소드 오브젝트</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OS 인터페이스 객체</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OS 인터페이스 열린 파일 핸들</target>
        </trans-unit>
        <trans-unit id="1bea0dbc1c9e6f1262f42405074e1a4e5f89e1c4" translate="yes" xml:space="preserve">
          <source>OSS Fuzz no longer finds historical bugs in SQLite. But it is still running and does occasionally find issues in new development check-ins. Examples: &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2]&lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt;.</source>
          <target state="translated">OSS Fuzz는 더 이상 SQLite에서 역사적인 버그를 찾지 않습니다. 그러나 여전히 실행 중이며 때때로 새로운 개발 체크인에서 문제를 발견합니다. 예 : &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=c422afb507dc8757&quot;&gt;[1] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=0a2eb949f8a759e5&quot;&gt;[2] &lt;/a&gt;&lt;a href=&quot;https://www.sqlite.org/src/timeline?y=ci&amp;amp;c=62f2235adf796c72&quot;&gt;[3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
