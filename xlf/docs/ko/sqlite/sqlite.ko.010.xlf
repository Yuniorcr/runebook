<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="8e0df4037503e2d7d2784fedb62cdd6ec1bcce1f" translate="yes" xml:space="preserve">
          <source>Multiply the value in register P1 by the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 값에 레지스터 P2의 값을 곱하고 결과를 레지스터 P3에 저장합니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="96a8063d277e69bad9338f2cd2299ce555b10c74" translate="yes" xml:space="preserve">
          <source>Multiplying null by zero gives null</source>
          <target state="translated">null에 0을 곱하면 null이됩니다.</target>
        </trans-unit>
        <trans-unit id="0882d3aaa23d5575a8f63bfdd8452012d19a092f" translate="yes" xml:space="preserve">
          <source>MustBeInt</source>
          <target state="translated">MustBeInt</target>
        </trans-unit>
        <trans-unit id="ad84a5c1e8958f4a9c3429e8188a4603875d0079" translate="yes" xml:space="preserve">
          <source>Mutation test script</source>
          <target state="translated">돌연변이 테스트 스크립트</target>
        </trans-unit>
        <trans-unit id="20e073cd00cadf7d267e8b82f5b78e0e3f9214a2" translate="yes" xml:space="preserve">
          <source>Mutation testing can be slow, since each test can take up to 5 minutes on a fast workstation, and there are two tests for each branch instructions, and over 20,000 branch instructions. Efforts are made to expedite operation. For example, TH3 is compiled in such a way that it exits as soon as it finds the first error, and as many of the mutations are easily detected, many cycles happen in only a few seconds. Nevertheless, the mutation-test.tcl script includes command-line options to limit the range of code lines tested so that mutation testing only needs to be performed on blocks of code that have recently changed.</source>
          <target state="translated">각 테스트는 빠른 워크 스테이션에서 최대 5 분이 소요될 수 있으며 각 분기 명령에 대해 두 개의 테스트와 20,000 개 이상의 분기 명령이 있으므로 돌연변이 테스트가 느려질 수 있습니다. 신속한 작업을 위해 노력합니다. 예를 들어 TH3는 첫 번째 오류를 발견하자마자 빠져 나가는 방식으로 컴파일되며 많은 돌연변이가 쉽게 감지되면 몇 초 안에 많은주기가 발생합니다. 그럼에도 불구하고 mutation-test.tcl 스크립트에는 명령 줄 옵션이 포함되어있어 테스트 된 코드 라인의 범위를 제한하여 최근에 변경된 코드 블록에서만 돌연변이 테스트를 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ee9066f4d731d8a141c6e684743ee9a9527de8b6" translate="yes" xml:space="preserve">
          <source>Mutex Handle</source>
          <target state="translated">뮤텍스 핸들</target>
        </trans-unit>
        <trans-unit id="9f117864c1709baa2c76d7b2cfa8d17c9f1bfe11" translate="yes" xml:space="preserve">
          <source>Mutex Methods Object</source>
          <target state="translated">뮤텍스 메소드 객체</target>
        </trans-unit>
        <trans-unit id="83fb9a7fd1246d148749d832e1630432bf7c41eb" translate="yes" xml:space="preserve">
          <source>Mutex Types</source>
          <target state="translated">뮤텍스 유형</target>
        </trans-unit>
        <trans-unit id="9ca067080a430d66f997055e5f2d644e22736a96" translate="yes" xml:space="preserve">
          <source>Mutex Verification Routines</source>
          <target state="translated">뮤텍스 검증 루틴</target>
        </trans-unit>
        <trans-unit id="82f2c9599c5c14be2ce92b9de958cb57db81b38f" translate="yes" xml:space="preserve">
          <source>Mutexes</source>
          <target state="translated">Mutexes</target>
        </trans-unit>
        <trans-unit id="5b84f7a78e5961ea2a526de843a9daab8f41a20c" translate="yes" xml:space="preserve">
          <source>Mutexes are cheap but they are not free, so performance will be better when mutexes are completely disabled. The resulting library footprint will also be a little smaller. Disabling the mutexes at compile-time is a recommended optimization for applications where it makes sense.</source>
          <target state="translated">뮤텍스는 저렴하지만 무료가 아니므로 뮤텍스가 완전히 비활성화되면 성능이 향상됩니다. 결과 라이브러리 풋 프린트도 약간 줄어 듭니다. 컴파일 타임에 뮤텍스를 비활성화하는 것이 적합한 응용 프로그램에 권장되는 최적화 방법입니다.</target>
        </trans-unit>
        <trans-unit id="b22446695cc6c25d3041d52dab780b6caac7cd1e" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">뮤텍스는 &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()을&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a8bd3143e806972c1aad1cdeede17125b4f66fc3" translate="yes" xml:space="preserve">
          <source>Mutexes are created using &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc()&lt;/a&gt;.</source>
          <target state="translated">뮤텍스는 &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_alloc ()을&lt;/a&gt; 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="90dba5f17bdba09d7b97e3f464ca3b8fa2e57394" translate="yes" xml:space="preserve">
          <source>My WHERE clause expression &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; does not work. It causes every row of the table to be returned, not just the rows where column1 has the value &quot;column1&quot;.</source>
          <target state="translated">WHERE 절 표현식 &lt;code&gt;column1=&quot;column1&quot;&lt;/code&gt; 이 작동하지 않습니다. column1의 값이 &quot;column1&quot;인 행뿐만 아니라 테이블의 모든 행이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="53dbb81c605812b9954b771e4d176a4b96f646d2" translate="yes" xml:space="preserve">
          <source>My query does not return the column name that I expect. Is this a bug?</source>
          <target state="translated">내 쿼리가 예상 한 열 이름을 반환하지 않습니다. 이것이 버그입니까?</target>
        </trans-unit>
        <trans-unit id="deaa0c393a6613972aaccbf1fecfdad67aa21e88" translate="yes" xml:space="preserve">
          <source>MySQL</source>
          <target state="translated">MySQL</target>
        </trans-unit>
        <trans-unit id="e5d56b96c147bc00244a87ca5dec3dbb343c2acd" translate="yes" xml:space="preserve">
          <source>MySQL version 3.23.41 does not support UNION.</source>
          <target state="translated">MySQL 버전 3.23.41은 UNION을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e303d2711b51452d1cb5f1e99368e6acecd1238f" translate="yes" xml:space="preserve">
          <source>MySQL:</source>
          <target state="translated">MySQL:</target>
        </trans-unit>
        <trans-unit id="b51a60734da64be0e618bacbea2865a8a7dcd669" translate="yes" xml:space="preserve">
          <source>N</source>
          <target state="translated">N</target>
        </trans-unit>
        <trans-unit id="8942124b2b322d5ed5aaedb0379f2b4629d337ae" translate="yes" xml:space="preserve">
          <source>N&amp;ge;12 and even</source>
          <target state="translated">N&amp;ge;12 및 짝수</target>
        </trans-unit>
        <trans-unit id="65234a7e6be9327b0d7bbc7e6bf2ce41cdf5a33b" translate="yes" xml:space="preserve">
          <source>N&amp;ge;13 and odd</source>
          <target state="translated">N&amp;ge;13과 홀수</target>
        </trans-unit>
        <trans-unit id="4bbff46d5e4a2066e44932399c1db699e807cf39" translate="yes" xml:space="preserve">
          <source>N+1</source>
          <target state="translated">N+1</target>
        </trans-unit>
        <trans-unit id="bd2f53c8c05f137a14d10bbea3ef6da285114906" translate="yes" xml:space="preserve">
          <source>N+4</source>
          <target state="translated">N+4</target>
        </trans-unit>
        <trans-unit id="08d2e98e6754af941484848930ccbaddfefe13d6" translate="yes" xml:space="preserve">
          <source>N/A</source>
          <target state="translated">N/A</target>
        </trans-unit>
        <trans-unit id="8dd6dc5b4967e63a1a79c5eb2a6c948692613a58" translate="yes" xml:space="preserve">
          <source>N1 (cost: 5.52)</source>
          <target state="translated">N1 (비용 : 5.52)</target>
        </trans-unit>
        <trans-unit id="798d9ffe324145d7424e3df912c7130f87d2bc5a" translate="yes" xml:space="preserve">
          <source>N2 (cost: 5.52)</source>
          <target state="translated">N2 (비용 : 5.52)</target>
        </trans-unit>
        <trans-unit id="15fbf39b576cc8bd369719e2a3d26f97ec889560" translate="yes" xml:space="preserve">
          <source>N2-N1 (cost: 11.04)</source>
          <target state="translated">N2-N1 (비용 : 11.04)</target>
        </trans-unit>
        <trans-unit id="5b4ea6d782abcd0ed1483d887c331af67374531e" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e5c2df06ba96ff92a5b489615f6b10abd3bf147f" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;left&lt;/small&gt;&lt;/sub&gt;&amp;times;N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2c0a1bee57f9f58fc50d516a0bf15f88caa7689c" translate="yes" xml:space="preserve">
          <source>N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</source>
          <target state="translated">N&lt;sub&gt;&lt;small&gt;right&lt;/small&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="a9d371451b6909ac85117130b9153a96499a362c" translate="yes" xml:space="preserve">
          <source>NAME</source>
          <target state="translated">NAME</target>
        </trans-unit>
        <trans-unit id="5b0ac1bba3d09af88af51314ab9e3274563ae94b" translate="yes" xml:space="preserve">
          <source>NATIVE CHARACTER(70)</source>
          <target state="translated">고유 문자 (70)</target>
        </trans-unit>
        <trans-unit id="7b0c42d6ea58612c19c7961351b229254674e033" translate="yes" xml:space="preserve">
          <source>NATURAL</source>
          <target state="translated">NATURAL</target>
        </trans-unit>
        <trans-unit id="ea1a1d896196c614eb971163bd79e6b0f3ccbe73" translate="yes" xml:space="preserve">
          <source>NB: This extension is deprecated. [WAL mode] is recommended as a replacement.</source>
          <target state="translated">NB :이 확장은 더 이상 사용되지 않습니다. 대체품으로는 [WAL 모드]가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9829174ea4702c19a86b2f2d0ae072ffd5bcdee0" translate="yes" xml:space="preserve">
          <source>NCHAR(55)</source>
          <target state="translated">NCHAR(55)</target>
        </trans-unit>
        <trans-unit id="b7fe5d20802ca2aca87db42d4b7dae9f148c0ed7" translate="yes" xml:space="preserve">
          <source>NEAR queries</source>
          <target state="translated">NEAR 개의 검색어</target>
        </trans-unit>
        <trans-unit id="ad140e1560939f826df416c1e0d8f81eaa5dd26a" translate="yes" xml:space="preserve">
          <source>NEAR queries are not available.</source>
          <target state="translated">NEAR 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9bbceb6fd3a09583f532267c802c583270b6ed37" translate="yes" xml:space="preserve">
          <source>NEVER(X)</source>
          <target state="translated">NEVER(X)</target>
        </trans-unit>
        <trans-unit id="97b77dd54bade796fe382680ffda0d54d204b7ea" translate="yes" xml:space="preserve">
          <source>NEW and OLD references are valid</source>
          <target state="translated">NEW 및 OLD 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="a82d81a38474e7a2f1b05be86c3d0ec157924da9" translate="yes" xml:space="preserve">
          <source>NEW references are valid</source>
          <target state="translated">새로운 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="aa7b193ecb5f5e8127c45d86d672c669b4ad311a" translate="yes" xml:space="preserve">
          <source>NNN</source>
          <target state="translated">NNN</target>
        </trans-unit>
        <trans-unit id="cf99bc0053e83f8041fe548005de7972be838e08" translate="yes" xml:space="preserve">
          <source>NNN days</source>
          <target state="translated">NNN 일</target>
        </trans-unit>
        <trans-unit id="33c4ffa6e43390375c0bf9b4e04eedef73776044" translate="yes" xml:space="preserve">
          <source>NNN hours</source>
          <target state="translated">NNN 시간</target>
        </trans-unit>
        <trans-unit id="4dc2b6e588bcda89bc862d480bc0a6894df9769a" translate="yes" xml:space="preserve">
          <source>NNN minutes</source>
          <target state="translated">NNN 분</target>
        </trans-unit>
        <trans-unit id="bf0082b4c02bd0d30ff30874661f393df82750f4" translate="yes" xml:space="preserve">
          <source>NNN months</source>
          <target state="translated">NNN 개월</target>
        </trans-unit>
        <trans-unit id="afb2dbb2fb0e9adb5cd092d7e7b6d3ffb78523de" translate="yes" xml:space="preserve">
          <source>NNN years</source>
          <target state="translated">NNN 년</target>
        </trans-unit>
        <trans-unit id="b58c197b751c5ed1962a3c0390de8c10bb4951b3" translate="yes" xml:space="preserve">
          <source>NNN.NNNN seconds</source>
          <target state="translated">NNN.NNNN 초</target>
        </trans-unit>
        <trans-unit id="a0509b7780628bd9d9abc7eb8a2163477341053a" translate="yes" xml:space="preserve">
          <source>NO</source>
          <target state="translated">NO</target>
        </trans-unit>
        <trans-unit id="05fdd36e7692e52033451b07ec66dff9eb7e55c8" translate="yes" xml:space="preserve">
          <source>NOCASE</source>
          <target state="translated">NOCASE</target>
        </trans-unit>
        <trans-unit id="0654a028e5aea48c8fbb09871b8f397a186c883b" translate="yes" xml:space="preserve">
          <source>NONE</source>
          <target state="translated">NONE</target>
        </trans-unit>
        <trans-unit id="969e7d8dee132181523a501a068fec75bded3005" translate="yes" xml:space="preserve">
          <source>NOT</source>
          <target state="translated">NOT</target>
        </trans-unit>
        <trans-unit id="13e8b0dd0b366e8464e50db4ffa83a38db17f5c0" translate="yes" xml:space="preserve">
          <source>NOT EXISTS operator</source>
          <target state="translated">존재하지 않는 연산자</target>
        </trans-unit>
        <trans-unit id="c251201ede2fa823c20c38c57254fd75c17ce421" translate="yes" xml:space="preserve">
          <source>NOT IN operator</source>
          <target state="translated">NOT IN 연산자</target>
        </trans-unit>
        <trans-unit id="f4a4efddb03a7d76572898f7eabe1ea34a780b2f" translate="yes" xml:space="preserve">
          <source>NOT NULL constraint</source>
          <target state="translated">NOT NULL 제약</target>
        </trans-unit>
        <trans-unit id="6ff7e3eeee65666114a7a3854176937e0d8c1522" translate="yes" xml:space="preserve">
          <source>NOT NULL constraints are honored.</source>
          <target state="translated">NOT NULL 제약 조건이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c462e8fc3e502ae6d5489c34ffa0054b7073578f" translate="yes" xml:space="preserve">
          <source>NOTHING</source>
          <target state="translated">NOTHING</target>
        </trans-unit>
        <trans-unit id="d6a7f5abac5bd9faa0bac9e8bb7907ab9f614941" translate="yes" xml:space="preserve">
          <source>NOTNULL</source>
          <target state="translated">NOTNULL</target>
        </trans-unit>
        <trans-unit id="eef19c54306daa69eda49c0272623bdb5e2b341f" translate="yes" xml:space="preserve">
          <source>NULL</source>
          <target state="translated">NULL</target>
        </trans-unit>
        <trans-unit id="0d475d854a2a7eeffd82e1a01f92ca65e566328f" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite</source>
          <target state="translated">SQLite의 NULL 처리</target>
        </trans-unit>
        <trans-unit id="7fac7bb3c1a767adbbac557d34135fb142c688ca" translate="yes" xml:space="preserve">
          <source>NULL Handling in SQLite Versus Other Database Engines</source>
          <target state="translated">다른 데이터베이스 엔진과 SQLite의 NULL 처리</target>
        </trans-unit>
        <trans-unit id="248ab3abcb099e69f2fef53b64e651576012c852" translate="yes" xml:space="preserve">
          <source>NULL values (serial type 0) sort first.</source>
          <target state="translated">NULL 값 (직렬 유형 0)이 먼저 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="a1efa1e3b6119cae6664d71bdefea57f479d6ebf" translate="yes" xml:space="preserve">
          <source>NULL values are now reported to the callback as a NULL pointer rather than an empty string.</source>
          <target state="translated">NULL 값은 이제 빈 문자열이 아닌 NULL 포인터로 콜백에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="743ef19013396d7d94a24cacbb830235275be9c8" translate="yes" xml:space="preserve">
          <source>NULLS</source>
          <target state="translated">NULLS</target>
        </trans-unit>
        <trans-unit id="fc81819cf87d3384597c4ae67d1976d82323a9b0" translate="yes" xml:space="preserve">
          <source>NULLS LAST</source>
          <target state="translated">마지막 NULL</target>
        </trans-unit>
        <trans-unit id="8280c934b3178b2afed2c01f955aab5fe7295999" translate="yes" xml:space="preserve">
          <source>NULLs sort first</source>
          <target state="translated">NULL이 먼저 정렬</target>
        </trans-unit>
        <trans-unit id="58ad270de77802cc63222e273fa800c4b248cdd7" translate="yes" xml:space="preserve">
          <source>NUMERIC</source>
          <target state="translated">NUMERIC</target>
        </trans-unit>
        <trans-unit id="024959fd2d5e8c9c205a2098591019699ae29143" translate="yes" xml:space="preserve">
          <source>NVARCHAR(100)</source>
          <target state="translated">NVARCHAR(100)</target>
        </trans-unit>
        <trans-unit id="709a23220f2c3d64d1e1d6d18c4d5280f8d82fca" translate="yes" xml:space="preserve">
          <source>Name</source>
          <target state="translated">Name</target>
        </trans-unit>
        <trans-unit id="daa5b774be0bfcbd2e2835e6bd0980fb6e06778a" translate="yes" xml:space="preserve">
          <source>Name Of A Host Parameter</source>
          <target state="translated">호스트 매개 변수 이름</target>
        </trans-unit>
        <trans-unit id="cb9e33f6b09bb7fe5d38a783b74c6905b2f43077" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Database Files</source>
          <target state="translated">데이터베이스 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="7749c218b18b42cbe27f3f870da40b8d3d708ba1" translate="yes" xml:space="preserve">
          <source>Name Of The Folder Holding Temporary Files</source>
          <target state="translated">임시 파일을 보유한 폴더의 이름</target>
        </trans-unit>
        <trans-unit id="fbb9c33e0412f25c0e798fd22a36fd452bd92012" translate="yes" xml:space="preserve">
          <source>Name of default collation sequence</source>
          <target state="translated">기본 데이터 정렬 시퀀스의 이름</target>
        </trans-unit>
        <trans-unit id="4e3a9de996d9196b59f293d51cf53aa5b2a8a36e" translate="yes" xml:space="preserve">
          <source>Named window-defn clauses may also be added to a SELECT statement using a WINDOW clause and then referred to by name within window function invocations. For example, the following SELECT statement contains two named window-defs clauses, &quot;win1&quot; and &quot;win2&quot;:</source>
          <target state="translated">WINDOW 절을 사용하여 명명 된 window-defn 절을 SELECT 문에 추가 한 다음 창 함수 호출 내에서 이름으로 참조 할 수도 있습니다. 예를 들어 다음 SELECT 문에는 &quot;win1&quot;및 &quot;win2&quot;라는 두 개의 명명 된 window-defs 절이 있습니다.</target>
        </trans-unit>
        <trans-unit id="02aead4c6c683a05b1c0ebf7ea825cf0f6d1b06c" translate="yes" xml:space="preserve">
          <source>Naming Changes</source>
          <target state="translated">이름 변경</target>
        </trans-unit>
        <trans-unit id="f736bf35e196e5f8a2152cf612783a7b401c2cad" translate="yes" xml:space="preserve">
          <source>Ne</source>
          <target state="translated">Ne</target>
        </trans-unit>
        <trans-unit id="28477357de69f5526193889fda40ed45cd101a03" translate="yes" xml:space="preserve">
          <source>Nearly all systems have the ability to call libraries written in C. This is not true of other implementation languages.</source>
          <target state="translated">거의 모든 시스템에는 C로 작성된 라이브러리를 호출 할 수있는 기능이 있습니다. 이것은 다른 구현 언어에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a37e5d1459b64bbf0f387b130668f0c8c4924e69" translate="yes" xml:space="preserve">
          <source>Negative numbers in the &quot;.width&quot; command cause right-alignment</source>
          <target state="translated">&quot;.width&quot;명령의 음수는 오른쪽 정렬을 유발합니다</target>
        </trans-unit>
        <trans-unit id="fec37acea6ebcef8454c4fc958c0b8f34d2b8c80" translate="yes" xml:space="preserve">
          <source>Nested transactions using &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;, &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt;, and &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; , &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 및 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK TO를&lt;/a&gt; 사용하는 중첩 트랜잭션</target>
        </trans-unit>
        <trans-unit id="9c791dcaae3666d9984fccf3b99d9aec11d78e88" translate="yes" xml:space="preserve">
          <source>Never despair of God's mercy.</source>
          <target state="translated">하나님의 자비를 절대 절망하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="cb1f0a8ca1cbcde19e25e6a553a1aa4154cf9c78" translate="yes" xml:space="preserve">
          <source>Nevertheless, application developers are admonished to monitor the state of the memory allocation subsystems and raise alarms when memory usage approaches or exceeds Robson limits. In this way, the application will provide operators with abundant warning well in advance of failure. The &lt;a href=&quot;malloc#memstatus&quot;&gt;memory statistics&lt;/a&gt; interfaces of SQLite provide the application with all the mechanism necessary to complete the monitoring portion of this task.</source>
          <target state="translated">그럼에도 불구하고 응용 프로그램 개발자는 메모리 할당 하위 시스템의 상태를 모니터링하고 메모리 사용량이 Robson 제한에 도달하거나이를 초과하면 경보를 발생시키는 것이 좋습니다. 이러한 방식으로 응용 프로그램은 오류 발생 전에 운영자에게 풍부한 경고를 제공합니다. SQLite 의 &lt;a href=&quot;malloc#memstatus&quot;&gt;메모리 통계&lt;/a&gt; 인터페이스는이 작업의 모니터링 부분을 완료하는 데 필요한 모든 메커니즘을 응용 프로그램에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b14d2dd89e46e860f7449a61cc79bde67323500f" translate="yes" xml:space="preserve">
          <source>Nevertheless, bugs happen. If you are writing an application that sends untrusted SQL inputs or database files to SQLite, there are additional steps you can take to help reduce the attack surface and prevent zero-day exploits caused by undetected bugs.</source>
          <target state="translated">그럼에도 불구하고 버그가 발생합니다. 신뢰할 수없는 SQL 입력 또는 데이터베이스 파일을 SQLite로 보내는 응용 프로그램을 작성하는 경우 공격 영역을 줄이고 감지되지 않은 버그로 인한 제로 데이 악용을 방지하기 위해 수행 할 수있는 추가 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe8f48a38c1ee2d5e1ec0b569c50eb0f4be22e0d" translate="yes" xml:space="preserve">
          <source>Nevertheless, integer overflow in the computation of memory allocation sizes is a concern that SQLite would like to deal with. To prevent problems, all SQLite internal memory allocations occur using thin wrapper functions that take a signed 64-bit integer size parameter. The SQLite source code is audited to ensure that all size computations are carried out using 64-bit signed integers as well. SQLite will refuse to allocate more than about 2GB of memory at one go. (In common use, SQLite seldom ever allocates more than about 8KB of memory at a time so a 2GB allocation limit is not a burden.) So the 64-bit size parameter provides lots of headroom for detecting overflows. The same audit that verifies that all size computations are done as 64-bit signed integers also verifies that it is impossible to overflow a 64-bit integer during the computation.</source>
          <target state="translated">그럼에도 불구하고, 메모리 할당 크기 계산에서 정수 오버플로는 SQLite가 처리하고자하는 관심사입니다. 문제를 방지하기 위해 모든 SQLite 내부 메모리 할당은 부호있는 64 비트 정수 크기 매개 변수를 사용하는 씬 래퍼 함수를 ​​사용하여 발생합니다. 모든 크기 계산이 64 비트 부호있는 정수를 사용하여 수행되도록 SQLite 소스 코드를 감사합니다. SQLite는 한 번에 약 2GB 이상의 메모리 할당을 거부합니다. (일반적으로 SQLite는 한 번에 약 8KB 이상의 메모리를 할당하는 경우가 거의 없으므로 2GB 할당 제한이 부담이되지 않습니다.) 따라서 64 비트 크기 매개 변수는 오버플로를 감지하기위한 많은 여유 공간을 제공합니다. 모든 크기 계산이 64 비트 부호있는 정수로 수행되는지 확인하는 동일한 감사도 계산 중에 64 비트 정수를 오버플로 할 수 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e49fc674e296beca34786edd4c2b299863546a78" translate="yes" xml:space="preserve">
          <source>Nevertheless, no software is 100% perfect. There have been a few historical bugs in SQLite (now fixed) that could cause database corruption. And there may be yet a few more that remain undiscovered. Because of the extensive testing and widespread use of SQLite, bugs that result in database corruption tend to be very obscure. The likelihood of an application encountering an SQLite bug is small. To illustrate this, an account is given below of all database-corruption bugs found in SQLite during the four-year period from 2009-04-01 to 2013-04-15. This account should give the reader an intuitive sense of the kinds of bugs in SQLite that manage to slip through testing procedures and make it into a release.</source>
          <target state="translated">그럼에도 불구하고 100 % 완벽한 소프트웨어는 없습니다. SQLite (현재 수정)에는 데이터베이스 손상을 일으킬 수있는 몇 가지 역사적 버그가있었습니다. 그리고 아직 밝혀지지 않은 것들이 더있을 수 있습니다. 광범위한 테스트와 SQLite의 광범위한 사용으로 인해 데이터베이스 손상을 초래하는 버그는 매우 모호한 경향이 있습니다. 응용 프로그램에서 SQLite 버그가 발생할 가능성은 적습니다. 이를 설명하기 위해 2009-04-01에서 2013-04-15까지 4 년 동안 SQLite에서 발견 된 모든 데이터베이스 손상 버그에 대해 설명합니다. 이 계정은 독자들에게 SQLite의 버그 종류에 대한 직관적 인 이해를 제공하여 테스트 절차를 거쳐 릴리스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="0116882452ef2d4b8e1293a906b669874cb29ba7" translate="yes" xml:space="preserve">
          <source>New &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_...&lt;/a&gt; compile-time options added</source>
          <target state="translated">새로운 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT _...&lt;/a&gt; 컴파일 타임 옵션 추가</target>
        </trans-unit>
        <trans-unit id="75836f6f6b6f280ffed2e7c97c8de38d49f8b36b" translate="yes" xml:space="preserve">
          <source>New Change</source>
          <target state="translated">새로운 변화</target>
        </trans-unit>
        <trans-unit id="519eb3711af9fb8ce8d81cf7983b569f9b988fc0" translate="yes" xml:space="preserve">
          <source>New File Format</source>
          <target state="translated">새로운 파일 형식</target>
        </trans-unit>
        <trans-unit id="05a025f4bcdcce620e0b66e603b7b96a2aa62567" translate="yes" xml:space="preserve">
          <source>New HH:MM:SS modifier to the built-in date/time functions.</source>
          <target state="translated">내장 된 날짜 / 시간 기능에 대한 새로운 HH : MM : SS 수정 자.</target>
        </trans-unit>
        <trans-unit id="35afb195f0b01edb4e7140e0f143cfa5913617eb" translate="yes" xml:space="preserve">
          <source>New VFSes are registered with sqlite3_vfs_register(). Each new VFS becomes the default VFS if the makeDflt flag is set. The same VFS can be registered multiple times without injury. To make an existing VFS into the default VFS, register it again with the makeDflt flag set. If two different VFSes with the same name are registered, the behavior is undefined. If a VFS is registered with a name that is NULL or an empty string, then the behavior is undefined.</source>
          <target state="translated">새로운 VFS는 sqlite3_vfs_register ()에 등록됩니다. makeDflt 플래그가 설정되면 각각의 새로운 VFS는 기본 VFS가됩니다. 동일한 VFS를 부상없이 여러 번 등록 할 수 있습니다. 기존 VFS를 기본 VFS로 만들려면 makeDflt 플래그가 설정된 상태로 다시 VFS를 등록하십시오. 이름이 같은 두 개의 다른 VFS가 등록되면 동작이 정의되지 않습니다. VFS가 NULL 또는 빈 문자열 인 이름으로 등록 된 경우 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e6d8977d2335274bf96388fe98628d1d0b7e083" translate="yes" xml:space="preserve">
          <source>New applications should always invoke &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. The older &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; is retained for backwards compatibility. But &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; provides a much better interface.</source>
          <target state="translated">새로운 응용 프로그램을해야 항상 호출 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()을&lt;/a&gt; . 이전 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 는 이전 버전과의 호환성을 위해 유지됩니다. 그러나 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 는 훨씬 더 나은 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="741f30a581517ffe6e7dcd8b6f50643914279724" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 다음에서 리턴 코드를 확인해야합니다.&lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="dfd7ca29d835fc9c4dbb0540c0bcc6f89fdaa393" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 다음에서 리턴 코드를 확인해야합니다.&lt;a href=&quot;#sqlite3_db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt;확인하여 호출이 작동했는지 확인해야합니다. 그만큼&lt;a href=&quot;#sqlite3_db_config&quot;&gt; sqlite3_db_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="290c5a063c07711b910fa8250f0c45e5e6c8d5a9" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;config&quot;&gt;sqlite3_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 에서 리턴 코드를 확인해야합니다. 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;../rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bef0fe1db7b5b12623a7cb6dd11860448e032b3e" translate="yes" xml:space="preserve">
          <source>New configuration options may be added in future releases of SQLite. Existing configuration options might be discontinued. Applications should check the return code from &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface will return a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; if a discontinued or unsupported configuration option is invoked.</source>
          <target state="translated">향후 릴리스의 SQLite에는 새로운 구성 옵션이 추가 될 수 있습니다. 기존 구성 옵션이 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. 그만큼&lt;a href=&quot;db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스 0이 아닌 리턴 &lt;a href=&quot;../rescode&quot;&gt;에러 코드를&lt;/a&gt; 단종 또는 지원되지 않는 구성 옵션이 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b448decebb78010dbfebbde65087fb4a352a7ae8" translate="yes" xml:space="preserve">
          <source>New database files created by SQLite use format 4 by default. The &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format pragma&lt;/a&gt; can be used to cause SQLite to create new database files using format 1. The format version number can be made to default to 1 instead of 4 by setting &lt;a href=&quot;compile#default_file_format&quot;&gt;SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt;=1 at compile-time.</source>
          <target state="translated">SQLite가 만든 새 데이터베이스 파일은 기본적으로 형식 4를 사용합니다. &lt;a href=&quot;pragma#pragma_legacy_file_format&quot;&gt;legacy_file_format 프라그&lt;/a&gt; 형식의 버전 번호는 설정에 의해 1 대신에 4 기본값으로 만들 수 있습니다 형식 (1)을 사용하여 새 데이터베이스 파일을 만들 SQLite는을 야기 할 수 있습니다&lt;a href=&quot;compile#default_file_format&quot;&gt; SQLITE_DEFAULT_FILE_FORMAT&lt;/a&gt; 컴파일시 = 1.</target>
        </trans-unit>
        <trans-unit id="7fae2a2a8fa480fb532533df6e47c596e4029933" translate="yes" xml:space="preserve">
          <source>New error codes may be added in future versions of SQLite.</source>
          <target state="translated">향후 버전의 SQLite에는 새로운 오류 코드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02a2eef012a8248fed2ec4a5f4418e441dee6267" translate="yes" xml:space="preserve">
          <source>New extensions:</source>
          <target state="translated">새로운 확장 :</target>
        </trans-unit>
        <trans-unit id="c375e60e4ec3e7a7421f6f6fc9277a408ea2286e" translate="yes" xml:space="preserve">
          <source>New file format that is 25% to 35% smaller for typical use.</source>
          <target state="translated">일반적인 사용을 위해 25 ~ 35 % 더 작은 새로운 파일 형식.</target>
        </trans-unit>
        <trans-unit id="fd04fa0f053215d42b7f8b539b38e361266bd4c9" translate="yes" xml:space="preserve">
          <source>New flags may be added in future releases of SQLite.</source>
          <target state="translated">이후 버전의 SQLite에는 새로운 플래그가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609f25b82bb11b34abf866257917b5188d15ee70" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle()&lt;/a&gt; that returns the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; handle that has invoked an application-defined SQL function.</source>
          <target state="translated">응용 프로그램 정의 SQL 함수를 호출 한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들 을 리턴하는 새로운 인터페이스 &lt;a href=&quot;c3ref/context_db_handle&quot;&gt;sqlite3_context_db_handle ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="97e454a0ee0ddbdb1207081ac8f340c9145f813d" translate="yes" xml:space="preserve">
          <source>New interface &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; allows size and length limits to be set on a per-connection basis and at run-time.</source>
          <target state="translated">새로운 인터페이스 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하면 연결 및 런타임마다 크기 및 길이 제한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351a6ce815b5dd18ffcf850d512cce2a33e3cd28" translate="yes" xml:space="preserve">
          <source>New interface: sqlite3_bind_parameter_index()</source>
          <target state="translated">새로운 인터페이스 : sqlite3_bind_parameter_index ()</target>
        </trans-unit>
        <trans-unit id="ff421fae0557a39a0bd809f33195e163ee4bb7ae" translate="yes" xml:space="preserve">
          <source>New interfaces added to the test_quota.c add-on module.</source>
          <target state="translated">test_quota.c 애드온 모듈에 새로운 인터페이스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ae3613412d28080958e2d37e217b087b523b9aae" translate="yes" xml:space="preserve">
          <source>New internal schema objects names, always beginning with &quot;sqlite_&quot;, may be added to the SQLite file format in future releases.</source>
          <target state="translated">항상 &quot;sqlite_&quot;로 시작하는 새로운 내부 스키마 객체 이름은 향후 릴리스에서 SQLite 파일 형식에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26bcef71ccfa90b2e0cbb123ce577eb05e69bad7" translate="yes" xml:space="preserve">
          <source>New memory allocators do not have to be part of the SQLite source tree nor included in the sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Individual applications can supply their own memory allocators to SQLite at start-time.</source>
          <target state="translated">새로운 메모리 할당자는 SQLite 소스 트리의 일부이거나 sqlite3.c &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 포함되지 않아도됩니다. . 개별 응용 프로그램은 시작시 SQLite에 자체 메모리 할당자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e4800161f51168ad45c54c49952a916eb4c7f5a" translate="yes" xml:space="preserve">
          <source>New options to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; for configuring auxiliary memory usage: --pagecache, --lookaside, and --scratch.</source>
          <target state="translated">보조 메모리 사용을 구성하기위한 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 새로운 옵션 : --pagecache, --lookaside 및 --scratch</target>
        </trans-unit>
        <trans-unit id="33b435c4ed8f9927e4700fe7e7aeadeae900e749" translate="yes" xml:space="preserve">
          <source>New query optimizations:</source>
          <target state="translated">새로운 쿼리 최적화 :</target>
        </trans-unit>
        <trans-unit id="27a96e272ba4064e97b901622de6fb30f7bc2a07" translate="yes" xml:space="preserve">
          <source>New run-time limit categories may be added in future releases.</source>
          <target state="translated">새로운 런타임 제한 범주는 다음 릴리스에서 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa7ba8a90d79e3949a9a92f1f6dd6361b3924b13" translate="yes" xml:space="preserve">
          <source>New status parameters may be added from time to time.</source>
          <target state="translated">새로운 상태 매개 변수가 때때로 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8001d5465bcc215e617045ec61b342b4c0fbe511" translate="yes" xml:space="preserve">
          <source>New tests added to the test suite.</source>
          <target state="translated">테스트 스위트에 새로운 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="19df796618ecb880621a1ff2386886f64457fe9e" translate="yes" xml:space="preserve">
          <source>New text tokens may be added to the end of the stat column in future enhancements to SQLite. For compatibility, unrecognized tokens at the end of the stat column are silently ignored.</source>
          <target state="translated">SQLite의 향후 향상을 위해 새로운 텍스트 토큰이 통계 열의 끝에 추가 될 수 있습니다. 호환성을 위해 통계 열의 끝에서 인식 할 수없는 토큰은 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d23050a62d4b2ebb32c827e3e8678911cb996090" translate="yes" xml:space="preserve">
          <source>New tracing constants may be added in future releases.</source>
          <target state="translated">다음 릴리스에서는 새로운 추적 상수가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ec81cf9bf3ff78a39346bf7439447032b8bc32c" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">향후 SQLite 릴리스에 새 동사가 추가 될 수 있습니다. 기존 동사가 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 단종 또는 지원되지 않는 동사가 불려 갔을 경우 인터페이스 0이 아닌 에러 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6997236519e17b29acb8e0c21015208012814bff" translate="yes" xml:space="preserve">
          <source>New verbs may be added in future releases of SQLite. Existing verbs might be discontinued. Applications should check the return code from &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; to make sure that the call worked. The &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface will return a non-zero error code if a discontinued or unsupported verb is invoked.</source>
          <target state="translated">SQLite의 향후 릴리스에 새로운 동사가 추가 될 수 있습니다. 기존 동사가 중단 될 수 있습니다. 애플리케이션은 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 의 리턴 코드를 확인하여 호출이 작동했는지 확인해야합니다. &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 단종 또는 지원되지 않는 동사가 불려 갔을 경우 인터페이스 0이 아닌 에러 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b162b6ee72989cc021180a9aa2d3a7a0e2b57826" translate="yes" xml:space="preserve">
          <source>New zip archives may be constructed entirely within memory using the zipfile() aggregate function. Each row visited by the aggregate function adds an entry to the zip archive. The value returned is a blob containing the entire archive image.</source>
          <target state="translated">새로운 zip 아카이브는 zipfile () 집계 함수를 사용하여 메모리 내에 완전히 구성 될 수 있습니다. 집계 함수가 방문한 각 행은 Zip 아카이브에 항목을 추가합니다. 반환 된 값은 전체 아카이브 이미지를 포함하는 얼룩입니다.</target>
        </trans-unit>
        <trans-unit id="e327377c14f6ddd81b93544df605d7203e2995e8" translate="yes" xml:space="preserve">
          <source>NewRowid</source>
          <target state="translated">NewRowid</target>
        </trans-unit>
        <trans-unit id="6975bed1eebd03a852e5aa6a11d0f144cd34ff6e" translate="yes" xml:space="preserve">
          <source>Newer disk drives have begun using 4096 byte sectors however. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the SQLite development team experimented with changes xSectorSize to report 4096 bytes as the blast radius. This had the effect of increasing write overhead on many databases. For a database with a &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA page_size&lt;/a&gt; of 1024 (a very common choice) making a change to a single page in the database now requires SQLite to backup three other adjacent pages to the rollback journal, whereas formerly it only had to backup the one page that was changing. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, each transaction had to be padded out to the next 4096-byte boundary in the WAL file, rather than the next 512-byte boundary, resulting in thousands of extra bytes being written per transaction.</source>
          <target state="translated">그러나 최신 디스크 드라이브는 4096 바이트 섹터를 사용하기 시작했습니다. SQLite 개발 팀 은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16) 부터 xSectorSize 변경을 실험하여 폭발 반경으로 4096 바이트를보고했습니다. 이는 많은 데이터베이스에서 쓰기 오버 헤드를 증가시키는 효과가있었습니다. 기호가있는 데이터베이스의 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;PRAGMA의 PAGE_SIZE&lt;/a&gt; 그것은 단지 한 페이지 즉 백업 한 이전 반면 데이터베이스의 단일 페이지에 대한 변경을 1,024 (매우 일반적인 선택)의 지금 롤백 저널에 백업 세 가지 다른 인접 페이지에 SQLite는 필요 바뀌고 있었다. 에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; , 각 거래는 거래 당 기록되는 추가 바이트의 수천의 결과로, 오히려 다음 512 바이트 경계보다는 WAL 파일에 다음 4096 바이트 경계 밖으로 패딩했다.</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="bc1189b8a3e7e2b908b403ea79a8eb14b14bcd47" translate="yes" xml:space="preserve">
          <source>Next, make copies of all the blobs into individual files in a directory using a command like this:</source>
          <target state="translated">다음으로, 다음과 같은 명령을 사용하여 모든 블로 브를 디렉토리의 개별 파일로 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="73f7cfb7746314674a12b8d200b36135947e050b" translate="yes" xml:space="preserve">
          <source>Next, move the resulting kvtest-android executable to the Android device:</source>
          <target state="translated">그런 다음 결과 kvtest-android 실행 파일을 Android 장치로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="21d2b394790e7b47b83f7c9d1daa6c55ee3c0c16" translate="yes" xml:space="preserve">
          <source>Next, suppose that you want to look up the price of not just any orange, but specifically California-grown oranges. The appropriate query would be as follows:</source>
          <target state="translated">다음으로 오렌지뿐만 아니라 캘리포니아에서 자란 오렌지의 가격을 찾고 싶다고 가정 해보십시오. 적절한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="dad2991d263e4aa51578f91e92e9777428d9762b" translate="yes" xml:space="preserve">
          <source>No (Note 1)</source>
          <target state="translated">아니요 (주 1)</target>
        </trans-unit>
        <trans-unit id="b4f66722cbcf69861e819a02ca8d6803b779fcd3" translate="yes" xml:space="preserve">
          <source>No Isolation Between Operations On The Same Database Connection</source>
          <target state="translated">동일한 데이터베이스 연결에서 작업간에 격리가 없음</target>
        </trans-unit>
        <trans-unit id="8dae863821cb04b5484c9a0e7717d726d350b9bd" translate="yes" xml:space="preserve">
          <source>No application file I/O code to write and debug.</source>
          <target state="translated">작성 및 디버그 할 애플리케이션 파일 I / O 코드가 없습니다.</target>
        </trans-unit>
        <trans-unit id="95ec05297c8cafc96feb998f4af109f4728d5530" translate="yes" xml:space="preserve">
          <source>No change</source>
          <target state="translated">변경 없음</target>
        </trans-unit>
        <trans-unit id="7f2ff41fbbf4963dea6c3e81c6aa743e95c596b5" translate="yes" xml:space="preserve">
          <source>No current or conflicting row information is provided. The only function it is possible to call on the supplied sqlite3_changeset_iter handle is sqlite3changeset_fk_conflicts().</source>
          <target state="translated">현재 또는 충돌하는 행 정보가 제공되지 않습니다. 제공된 sqlite3_changeset_iter 핸들에서 호출 할 수있는 유일한 함수는 sqlite3changeset_fk_conflicts ()입니다.</target>
        </trans-unit>
        <trans-unit id="662adfcee595804e0d0a40f3427892366f101024" translate="yes" xml:space="preserve">
          <source>No error messages are generated if an unknown pragma is issued. Unknown pragmas are simply ignored. This means if there is a typo in a pragma statement the library does not inform the user of the fact.</source>
          <target state="translated">알 수없는 pragma가 발행되면 오류 메시지가 생성되지 않습니다. 알 수없는 pragma는 단순히 무시됩니다. 이것은 pragma 문에 오타가 있으면 라이브러리는 사용자에게 사실을 알리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36386488a9bfa58ff6f23801ec174053b73ed777" translate="yes" xml:space="preserve">
          <source>No locking style. If none of the above can be supported, this locking style is used. No database locking mechanism is used. When this system is used it is not safe for a single database to be accessed by multiple clients.</source>
          <target state="translated">잠금 스타일이 없습니다. 위의 사항 중 어느 것도 지원할 수없는 경우이 잠금 스타일이 사용됩니다. 데이터베이스 잠금 메커니즘이 사용되지 않습니다. 이 시스템을 사용하면 여러 클라이언트가 단일 데이터베이스에 액세스하는 것이 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b15426333f8adb77f306aae95c84b204b379d14" translate="yes" xml:space="preserve">
          <source>No locks are held on the database. The database may be neither read nor written. Any internally cached data is considered suspect and subject to verification against the database file before being used. Other processes can read or write the database as their own locking states permit. This is the default state.</source>
          <target state="translated">데이터베이스에서 잠금이 유지되지 않습니다. 데이터베이스를 읽거나 쓸 수 없습니다. 내부적으로 캐시 된 데이터는 모두 의심스러운 것으로 간주되며 사용하기 전에 데이터베이스 파일에 대한 검증 대상이됩니다. 다른 프로세스는 자체 잠금 상태가 허용하는대로 데이터베이스를 읽거나 쓸 수 있습니다. 이것이 기본 상태입니다.</target>
        </trans-unit>
        <trans-unit id="589cdf57b87436c5bbc074aa5e48b70f3f3363e1" translate="yes" xml:space="preserve">
          <source>No longer in use.</source>
          <target state="translated">더 이상 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7375825a734eee4acde64dd3de9ae4b6f89db26c" translate="yes" xml:space="preserve">
          <source>No longer used.</source>
          <target state="translated">더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1cff8c4990053d03c141cc08cc6f740585898fb6" translate="yes" xml:space="preserve">
          <source>No one is required to follow The Rule, to know The Rule, or even to think that The Rule is a good idea. The Founder of SQLite believes that anyone who follows The Rule will live a happier and more productive life, but individuals are free to dispute or ignore that advice if they wish.</source>
          <target state="translated">누구도 규칙을 따르거나 규칙을 알고 있거나 규칙이 좋은 생각이라고 생각할 필요가 없습니다. SQLite의 창립자는 규칙을 따르는 사람은 누구나 더 행복하고 생산적인 삶을 살 것으로 생각하지만 개인은 원하는 경우 그 조언에 자유롭게 이의를 제기하거나 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4226fa0e8cf6311cf2613fee3e52c99bd81b607" translate="yes" xml:space="preserve">
          <source>No other processes can change the database so there is never a need to check the change counter and clear the user-space cache at the beginning of a transaction.</source>
          <target state="translated">다른 프로세스는 데이터베이스를 변경할 수 없으므로 트랜잭션 시작시 변경 카운터를 확인하고 사용자 공간 캐시를 지울 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b5b494aee4d1b7c43eaf07044f46f3778af61cd" translate="yes" xml:space="preserve">
          <source>No other writes may occur on the target database while the RBU update is being applied. A read-lock is held on the target database to prevent this.</source>
          <target state="translated">RBU 업데이트가 적용되는 동안 대상 데이터베이스에서 다른 쓰기가 발생할 수 없습니다. 이를 방지하기 위해 대상 데이터베이스에 읽기 잠금이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="3943b575617ba52cb8729616c676b13dc34b8e79" translate="yes" xml:space="preserve">
          <source>No reads or writes occur except within a transaction. Any command that accesses the database (basically, any SQL command, except a few &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements) will automatically start a transaction if one is not already in effect. Automatically started transactions are committed when the last SQL statement finishes.</source>
          <target state="translated">트랜잭션을 제외하고는 읽거나 쓰지 않습니다. 데이터베이스에 액세스하는 모든 명령 (기본적으로 일부 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문을 제외한 모든 SQL 명령 )은 트랜잭션이 아직 유효하지 않은 경우 자동으로 트랜잭션을 시작합니다. 마지막 SQL 문이 완료되면 자동으로 시작된 트랜잭션이 커미트됩니다.</target>
        </trans-unit>
        <trans-unit id="2a9bc5ebe3cc4eba5a484c518ae347f8a47ccd50" translate="yes" xml:space="preserve">
          <source>No table in a union-vtab may contain entries that are outside of the rowid bounds established by the</source>
          <target state="translated">union-vtab의 테이블에 의해 설정된 rowid 범위를 벗어난 항목이 포함될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d5b25b567984a7a4091e940273bfff96cd2fed3" translate="yes" xml:space="preserve">
          <source>No. When you delete information from an SQLite database, the unused disk space is added to an internal &quot;free-list&quot; and is reused the next time you insert data. The disk space is not lost. But neither is it returned to the operating system.</source>
          <target state="translated">SQLite 데이터베이스에서 정보를 삭제하면 사용되지 않은 디스크 공간이 내부 &quot;사용 가능 목록&quot;에 추가되고 다음에 데이터를 삽입 할 때 재사용됩니다. 디스크 공간이 손실되지 않습니다. 그러나 운영 체제로 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4e9f5ef9057ec35a6f3d638ab0a7b961dadfa79" translate="yes" xml:space="preserve">
          <source>NoConflict</source>
          <target state="translated">NoConflict</target>
        </trans-unit>
        <trans-unit id="66290ce3e3466df1560e431a1eebe9e205ef9f1e" translate="yes" xml:space="preserve">
          <source>Non-ASCII range characters (i.e. unicode codepoints greater than 127), or</source>
          <target state="translated">비 ASCII 범위 문자 (즉, 127보다 큰 유니 코드 코드 포인트) 또는</target>
        </trans-unit>
        <trans-unit id="1bc1387523b6d25784112f80a2990511e6a57420" translate="yes" xml:space="preserve">
          <source>Non-Vista Windows platforms only support one set of DST rules. Vista only supports two. Therefore, on these platforms, historical DST calculations will be incorrect. For example, in the US, in 2007 the DST rules changed. Non-Vista Windows platforms apply the new 2007 DST rules to all previous years as well. Vista does somewhat better getting results correct back to 1986, when the rules were also changed.</source>
          <target state="translated">Vista 이외의 Windows 플랫폼은 하나의 DST 규칙 세트 만 지원합니다. Vista는 두 가지만 지원합니다. 따라서 이러한 플랫폼에서 히스토리 DST 계산은 올바르지 않습니다. 예를 들어 미국에서는 2007 년에 DST 규칙이 변경되었습니다. Vista 이외의 Windows 플랫폼은 이전 2007 년에도 새로운 2007 DST 규칙을 적용합니다. Vista는 규칙이 변경되었을 때 1986 년으로 돌아가서 결과를 올바르게 얻는 것이 다소 나아졌습니다.</target>
        </trans-unit>
        <trans-unit id="b1b833538f0549b7c8aca0acf47c1aa5ac7f2fac" translate="yes" xml:space="preserve">
          <source>Non-deterministic functions might give different answers on each invocation, even if the arguments are always the same. The following are examples of non-deterministic functions:</source>
          <target state="translated">비 결정적 함수는 인수가 항상 같더라도 호출마다 다른 응답을 제공 할 수 있습니다. 다음은 비 결정적 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="cf3ad9f318d5d17809c32f85aa54a78cb4cda991" translate="yes" xml:space="preserve">
          <source>Non-streaming equivalent</source>
          <target state="translated">비 스트리밍 동등</target>
        </trans-unit>
        <trans-unit id="1d0d5248c3c8dbbb61313817bba98f17697e01b6" translate="yes" xml:space="preserve">
          <source>Non-streaming functions that accept changesets (or patchsets) as input require that the entire changeset be stored in a single buffer in memory. Similarly, those that return a changeset or patchset do so by returning a pointer to a single large buffer allocated using sqlite3_malloc(). Normally this is convenient. However, if an application running in a low-memory environment is required to handle very large changesets, the large contiguous memory allocations required can become onerous.</source>
          <target state="translated">변경 세트 (또는 패치 세트)를 입력으로 허용하는 비 스트리밍 기능을 사용하려면 전체 변경 세트를 메모리의 단일 버퍼에 저장해야합니다. 마찬가지로, 변경 세트 또는 패치 세트를 반환하는 것은 sqlite3_malloc ()을 사용하여 할당 된 하나의 큰 버퍼에 대한 포인터를 반환함으로써 그렇게합니다. 일반적으로 이것은 편리합니다. 그러나 메모리가 적은 환경에서 실행되는 응용 프로그램이 매우 큰 변경 세트를 처리해야하는 경우 필요한 대량의 연속 메모리 할당이 번거로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f7070838a5d668002d389cd9b3fec752e6c30d" translate="yes" xml:space="preserve">
          <source>None of the safe programming languages existed for the first 10 years of SQLite's existence. SQLite could be recoded in Go or Rust, but doing so would probably introduce far more bugs than would be fixed, and it seems also likely to result in slower code.</source>
          <target state="translated">SQLite가 존재 한 첫 10 년 동안 안전한 프로그래밍 언어는 존재하지 않았습니다. SQLite는 Go 또는 Rust로 코딩 될 수 있지만 그렇게하면 수정 된 것보다 훨씬 많은 버그가 발생할 수 있으며 코드 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9f34e057f76ac2b419477d464548015d8ef844" translate="yes" xml:space="preserve">
          <source>None of the xSavepoint(), xRelease(), or xRollbackTo() methods will ever be called except in between calls to xBegin() and either xCommit() or xRollback().</source>
          <target state="translated">xBegin ()에 대한 호출과 xCommit () 또는 xRollback () 사이를 제외하고 xSavepoint (), xRelease () 또는 xRollbackTo () 메소드는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1fe0caa1d6e9f3e9dd7087ae4f2a9ea810cd170" translate="yes" xml:space="preserve">
          <source>Noop</source>
          <target state="translated">Noop</target>
        </trans-unit>
        <trans-unit id="2bbfb9d52741dbc3a4ff03abc70ca82cb8e2f1bc" translate="yes" xml:space="preserve">
          <source>Normal functions specify only xFunc and leave xStep and xFinal set to NULL. Aggregate functions specify xStep and xFinal and leave xFunc set to NULL. There is no separate sqlite3_create_aggregate() API.</source>
          <target state="translated">일반 함수는 xFunc 만 지정하고 xStep 및 xFinal은 NULL로 설정합니다. 집계 함수는 xStep 및 xFinal을 지정하고 xFunc를 NULL로 설정합니다. 별도의 sqlite3_create_aggregate () API가 없습니다.</target>
        </trans-unit>
        <trans-unit id="e304219719d389c0ea46b9c98590f2134fb67330" translate="yes" xml:space="preserve">
          <source>Normally, FTS5 maintains a special backing table within the database that stores the size of each column value in tokens inserted into the main FTS5 table in a separate table. This backing table is used by the &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize&lt;/a&gt;&lt;a&gt; API function, which is in turn used by the built-in &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ranking function&lt;/a&gt; (and is likely to be useful to other ranking functions as well).</source>
          <target state="translated">일반적으로 FTS5는 기본 FTS5 테이블에 삽입 된 토큰에 각 열 값의 크기를 별도의 테이블에 저장하는 특수 백업 테이블을 데이터베이스 내에 유지합니다. 이 백업 테이블은 &lt;a href=&quot;#xColumnSize&quot;&gt;xColumnSize &lt;/a&gt;&lt;a&gt;API 함수에서 사용되며 내장 된 &lt;/a&gt;&lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 순위 함수 &lt;/a&gt;에서 사용되며 다른 순위 함수에도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="866b49d7e3deb743a545b4433375afa6debe3327" translate="yes" xml:space="preserve">
          <source>Normally, NULL SQL results are stored in the array using the &lt;a href=&quot;#nullvalue&quot;&gt;nullvalue&lt;/a&gt; setting. However, if the &lt;b&gt;-withoutnulls&lt;/b&gt; option is used, then NULL SQL values cause the corresponding array element to be unset instead.</source>
          <target state="translated">일반적으로 NULL SQL 결과는 &lt;a href=&quot;#nullvalue&quot;&gt;널값&lt;/a&gt; 설정을 사용하여 배열에 저장됩니다 . 그러나 &lt;b&gt;-withoutnulls&lt;/b&gt; 옵션을 사용하면 NULL SQL 값으로 인해 해당 배열 요소가 대신 설정 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="d1f5712d735a4022fc9c1482cc2c46055815935d" translate="yes" xml:space="preserve">
          <source>Normally, SQLite assumes that if a power failure occurs while updating any portion of a sector then the contents of the entire device sector is suspect following recovery. After writing to any part of a sector within a file, it is assumed that the modified sector contents are held in a volatile buffer somewhere within the system (main memory, disk cache etc.). SQLite does not assume that the updated data has reached the persistent storage media, until after it has successfully</source>
          <target state="translated">일반적으로 SQLite는 섹터의 일부를 업데이트하는 동안 정전이 발생하면 복구 후 전체 장치 섹터의 내용이 의심되는 것으로 가정합니다. 파일 내의 섹터의 어느 부분 에나 쓴 후, 수정 된 섹터 내용은 시스템 내의 어딘가에 휘발성 버퍼 (메인 메모리, 디스크 캐시 등)에 저장되어 있다고 가정합니다. SQLite는 업데이트 된 데이터가 성공적으로 완료 될 때까지 영구 스토리지 미디어에 도달했다고 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5b528fefcff05064efc30021e7a7579eaaad4d2" translate="yes" xml:space="preserve">
          <source>Normally, a token or token prefix query is matched against the FTS table column specified as the left-hand side of the MATCH operator. Or, if the special column with the same name as the FTS table itself is specified, against all columns. This may be overridden by specifying a column-name followed by a &quot;:&quot; character before a basic term query. There may be space between the &quot;:&quot; and the term to query for, but not between the column-name and the &quot;:&quot; character. For example:</source>
          <target state="translated">일반적으로 토큰 또는 토큰 접 두부 쿼리는 MATCH 연산자의 왼쪽으로 지정된 FTS 테이블 열과 일치합니다. 또는 FTS 테이블과 이름이 같은 특수 열이 지정된 경우 모든 열에 대해 지정됩니다. 기본 용어 쿼리 전에 column-name 다음에 &quot;:&quot;문자를 지정하여이를 대체 할 수 있습니다. &quot;:&quot;과 쿼리 할 용어 사이에 공백이있을 수 있지만 column-name과 &quot;:&quot;문자 사이에는 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf4491e66772ed8b491e6908438d7924fa774545" translate="yes" xml:space="preserve">
          <source>Normally, an SQL index references columns of a table. But an index can also be formed on expressions involving table columns.</source>
          <target state="translated">일반적으로 SQL 인덱스는 테이블의 열을 참조합니다. 그러나 테이블 열과 관련된 표현식에서 인덱스를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="39e8cea13d3d48550994e6ce4ac623d3130ee592" translate="yes" xml:space="preserve">
          <source>Normally, fossil will modify all the files in your checkout when switching between the private and the public branches. But at this point, the files are identical in both branches so not modifications need to be made.</source>
          <target state="translated">일반적으로 화석은 개인과 공용 지점 사이를 전환 할 때 체크 아웃의 모든 파일을 수정합니다. 그러나이 시점에서 파일은 두 분기에서 동일하므로 수정하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="d3d92a3c721eaacd534b06f545203c90c257b9b9" translate="yes" xml:space="preserve">
          <source>Normally, full-text queries are case-insensitive. However, this is dependent on the specific &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt; used by the FTS table being queried. Refer to the section on &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizers&lt;/a&gt; for details.</source>
          <target state="translated">일반적으로 전체 텍스트 쿼리는 대소 문자를 구분하지 않습니다. 그러나 이는 쿼리중인 FTS 테이블에서 사용 하는 특정 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 에 따라 다릅니다 . 자세한 내용 은 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="63e53b72fdcc0af9b1c300c26469b45178a485e4" translate="yes" xml:space="preserve">
          <source>Normally, the FTS module maintains an inverted index of all terms in all columns of the table. This option is used to specify the name of a column for which entries should not be added to the index. Multiple &quot;notindexed&quot; options may be used to specify that multiple columns should be omitted from the index. For example:</source>
          <target state="translated">일반적으로 FTS 모듈은 테이블의 모든 열에있는 모든 항의 역 인덱스를 유지합니다. 이 옵션은 항목을 색인에 추가하지 않아야하는 열 이름을 지정하는 데 사용됩니다. 인덱스에서 여러 열을 생략하도록 지정하기 위해 여러 개의 &quot;인덱싱되지 않은&quot;옵션을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebe2262110ee72155bb934332e4fc5587e66a440" translate="yes" xml:space="preserve">
          <source>Normally, the database &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and whether or not the database supports &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; must be configured before the database file is actually created. However, when not in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; properties of an existing database may be changed by using the &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; and/or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragmas and then immediately VACUUMing the database. When in &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; mode, only the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; support property can be changed using VACUUM.</source>
          <target state="translated">일반적으로 데이터베이스 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 데이터베이스가 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum을&lt;/a&gt; 지원하는지 여부 는 데이터베이스 파일이 실제로 작성되기 전에 구성되어야합니다. 그러나 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 모드 가 아닌 경우 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 / 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;pragma auto_vacuum&lt;/a&gt; pragma를 사용하여 데이터베이스를 즉시 VACUUMing 하여 기존 데이터베이스 의 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page_size&lt;/a&gt; 및 / 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 속성을 변경할 수 있습니다 . 에 때 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 모드 만 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum의&lt;/a&gt; 지원 속성은 진공을 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5df62864e283fb4361bad80921bbac8b7ec57013" translate="yes" xml:space="preserve">
          <source>Normally, when SQLite writes to a database file, it waits until the write operation is finished before returning control to the calling application. Since writing to the file-system is usually very slow compared with CPU bound operations, this can be a performance bottleneck. The asynchronous I/O backend is an extension that causes SQLite to perform all write requests using a separate thread running in the background. Although this does not reduce the overall system resources (CPU, disk bandwidth etc.), it does allow SQLite to return control to the caller quickly even when writing to the database.</source>
          <target state="translated">일반적으로 SQLite는 데이터베이스 파일에 쓸 때 쓰기 작업이 완료 될 때까지 기다렸다가 호출 응용 프로그램에 제어권을 반환합니다. 파일 시스템에 쓰는 것은 일반적으로 CPU 바운드 작업에 비해 매우 느리기 때문에 성능 병목 현상이 발생할 수 있습니다. 비동기 I / O 백엔드는 SQLite가 백그라운드에서 실행되는 별도의 스레드를 사용하여 모든 쓰기 요청을 수행하도록하는 확장입니다. 이렇게해도 전체 시스템 리소스 (CPU, 디스크 대역폭 등)가 줄어들지는 않지만 데이터베이스에 쓸 때에도 SQLite가 호출자에게 제어권을 신속하게 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b810f7b8c9c4b12cca67db5205f27d6d0477e848" translate="yes" xml:space="preserve">
          <source>Normally, when a row is inserted into an FTS5 table, as well as the various full-text index entries and other data a copy of the row is stored in a private table managed by the FTS5 module. When column values are requested from the FTS5 table by the user or by an auxiliary function implementation, they are read from this private table. The &quot;content&quot; option may be used to create an FTS5 table that stores only FTS full-text index entries. Because the column values themselves are usually much larger than the associated full-text index entries, this can save significant database space.</source>
          <target state="translated">일반적으로 행이 다양한 전체 텍스트 인덱스 항목 및 기타 데이터뿐만 아니라 FTS5 테이블에 삽입 될 때 행의 사본은 FTS5 모듈이 관리하는 개인 테이블에 저장됩니다. 사용자 또는 보조 기능 구현이 FTS5 테이블에서 컬럼 값을 요청하면이 개인 테이블에서 컬럼 값을 읽습니다. &quot;content&quot;옵션을 사용하면 FTS 전체 텍스트 인덱스 항목 만 저장하는 FTS5 테이블을 만들 수 있습니다. 열 값 자체는 일반적으로 연관된 전체 텍스트 인덱스 항목보다 훨씬 크기 때문에 상당한 데이터베이스 공간을 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1dd39379254ab3f3c73dbffb0d03d628b27d20" translate="yes" xml:space="preserve">
          <source>Not</source>
          <target state="translated">Not</target>
        </trans-unit>
        <trans-unit id="5927a7e485b2adcf5a36cf65c4801a2eed120fcc" translate="yes" xml:space="preserve">
          <source>Not all applications meet these conditions. Fortunately, the NGQP will still usually find good query plans, even without these conditions. However, cases do arise (rarely) where performance regressions can occur.</source>
          <target state="translated">모든 응용 프로그램이 이러한 조건을 충족하는 것은 아닙니다. 다행히도 NGQP는 이러한 조건이 없더라도 여전히 좋은 쿼리 계획을 찾습니다. 그러나 성능 회귀가 발생할 수있는 경우는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="6938024f626f02a7276620a318f6367169f62576" translate="yes" xml:space="preserve">
          <source>Not all test cases can be handled this way. Some test cases check to verify that the optimizations really are reducing the amount of computation by counting the number of disk accesses, sort operations, full-scan steps, or other processing steps that occur during queries. Those test cases will appear to fail when optimizations are disabled. But the majority of test cases simply check that the correct answer was obtained, and all of those cases can be run successfully with and without the optimizations, in order to show that the optimizations do not cause malfunctions.</source>
          <target state="translated">모든 테스트 사례를 이러한 방식으로 처리 할 수있는 것은 아닙니다. 일부 테스트 사례는 디스크 액세스 수, 정렬 작업, 전체 스캔 단계 또는 쿼리 중에 발생하는 기타 처리 단계를 계산하여 최적화가 실제로 계산량을 줄이고 있는지 확인합니다. 최적화가 비활성화되면 해당 테스트 사례가 실패한 것으로 나타납니다. 그러나 대부분의 테스트 사례는 단순히 정답을 얻었는지 확인하고 최적화가 오작동을 일으키지 않음을 나타 내기 위해 모든 경우를 최적화 유무에 관계없이 성공적으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="593dbd15d49368a738585302a9107baf925136df" translate="yes" xml:space="preserve">
          <source>Not shown in the example above is that there are also &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;various options&lt;/a&gt; that may be provided to FTS5 as part of the CREATE VIRTUAL TABLE statement to configure various aspects of the new table. These may be used to modify the way in which the FTS5 table extracts terms from documents and queries, to create extra indexes on disk to speed up prefix queries, or to create an FTS5 table that acts as an index on content stored elsewhere.</source>
          <target state="translated">위의 예 에는 새 테이블의 다양한 측면을 구성하기 위해 CREATE VIRTUAL TABLE 문의 일부로 FTS5에 제공 할 수있는 &lt;a href=&quot;fts5#fts5_table_creation_and_initialization&quot;&gt;다양한 옵션&lt;/a&gt; 도 있습니다. FTS5 테이블이 문서 및 쿼리에서 용어를 추출하는 방식을 수정하거나 디스크에 추가 인덱스를 생성하여 접두사 쿼리 속도를 높이거나 다른 곳에 저장된 콘텐츠에 대한 인덱스 역할을하는 FTS5 테이블을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edbfab21e07e4e0dbe02fb875980c40bdd52ad0f" translate="yes" xml:space="preserve">
          <source>NotExists</source>
          <target state="translated">NotExists</target>
        </trans-unit>
        <trans-unit id="6f05e7cc9203f83829c08dcc46fafe9db426763f" translate="yes" xml:space="preserve">
          <source>NotFound</source>
          <target state="translated">NotFound</target>
        </trans-unit>
        <trans-unit id="85c73c74f4b29a9fb7ba8d0a5bc532eb27f0866a" translate="yes" xml:space="preserve">
          <source>NotNull</source>
          <target state="translated">NotNull</target>
        </trans-unit>
        <trans-unit id="7884a1030f088443b3e65dc8c7d9c833c3f14209" translate="yes" xml:space="preserve">
          <source>Nota bene:</source>
          <target state="translated">참고 :</target>
        </trans-unit>
        <trans-unit id="59ab81d7ff99620547d7c60a07878ec16f88cba0" translate="yes" xml:space="preserve">
          <source>Note also that when adding a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt;, the CHECK constraint is not tested against preexisting rows of the table. This can result in a table that contains data that is in violation of the CHECK constraint. Future versions of SQLite might change to validate CHECK constraints as they are added.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건을&lt;/a&gt; 추가 할 때 CHECK 제약 조건은 기존 테이블 행에 대해 테스트되지 않습니다. 이로 인해 CHECK 제약 조건을 위반하는 데이터가 포함 된 테이블이 생성 될 수 있습니다. 이후 버전의 SQLite는 CHECK 제약 조건이 추가 될 때 유효성을 검사하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63cff68b4cc8b6d1593b377ca2761e4a780c9aef" translate="yes" xml:space="preserve">
          <source>Note that &quot;monotonically increasing&quot; does not imply that the ROWID always increases by exactly one. One is the usual increment. However, if an insert fails due to (for example) a uniqueness constraint, the ROWID of the failed insertion attempt might not be reused on subsequent inserts, resulting in gaps in the ROWID sequence. AUTOINCREMENT guarantees that automatically chosen ROWIDs will be increasing but not that they will be sequential.</source>
          <target state="translated">&quot;단일 증가&quot;는 ROWID가 항상 정확히 1 씩 증가한다는 것을 의미하지는 않습니다. 하나는 일반적인 증분입니다. 그러나 고유 제한 조건으로 인해 삽입에 실패하면 실패한 삽입 시도의 ROWID가 후속 삽입에서 재사용되지 않아 ROWID 순서에 공백이 생길 수 있습니다. AUTOINCREMENT는 자동으로 선택된 ROWID가 증가하지만 순차적 인 것은 아님을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4308667a324be6565f7e88fc7a4b19a7777f66dd" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#sqlite3_create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;#sqlite3_create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 응용 프로그램이 &lt;a href=&quot;#sqlite3_exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의 하면 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="aa33906842475ccf0659a59159f766bfacc10e93" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are by default considered non-deterministic and may not be used in a CREATE INDEX statement unless the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; flag is used when the function is registered.</source>
          <target state="translated">참고 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수는&lt;/a&gt; 기본적으로 비 결정적으로 간주되고,하지 않는 한 CREATE INDEX 문에 사용되지 않을 수 있습니다 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 함수가 등록 될 때 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5f9e6d6d8a3bf2c6d2a7e519940c1c6c58742f80" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;../vtab&quot;&gt;virtual tables&lt;/a&gt; might change the database indirectly as a side effect. For example, if an application defines a function &quot;eval()&quot; that calls &lt;a href=&quot;exec&quot;&gt;sqlite3_exec()&lt;/a&gt;, then the following SQL statement would change the database file through side-effects:</source>
          <target state="translated">참고 &lt;a href=&quot;create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블이&lt;/a&gt; 부작용으로 간접적으로 데이터베이스에 변경 될 수 있습니다. 예를 들어, 응용 프로그램이 &lt;a href=&quot;exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 를 호출하는 &quot;eval ()&quot;함수를 정의 하면 다음 SQL 문은 부작용을 통해 데이터베이스 파일을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="f679875d06130633120a14b47faa759dd16975f1" translate="yes" xml:space="preserve">
          <source>Note that Idx3 contains all the same information as the original &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt;. And so if we have Idx3, we do not really need Idx1 any more. The &quot;price of peaches&quot; query can be satisfied using Idx3 by simply ignoring the &quot;state&quot; column of Idx3:</source>
          <target state="translated">Idx3에는 원본 &lt;a href=&quot;#fig3&quot;&gt;Idx1&lt;/a&gt; 과 동일한 정보가 모두 포함되어 있습니다 . 따라서 Idx3이 있다면 더 이상 Idx1이 필요하지 않습니다. &quot;복숭아 가격&quot;쿼리는 Idx3의 &quot;상태&quot;열을 무시하여 Idx3을 사용하여 만족할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e97b2bc14d77a13e225d171f50b67e2004fff89" translate="yes" xml:space="preserve">
          <source>Note that MinGW generates 32-bit DLLs only. There is a separate MinGW64 project that can be used to generate 64-bit DLLs. Presumably the command-line syntax is similar. Also note that recent versions of MSVC generate DLLs that will not work on WinXP and earlier versions of Windows. So for maximum compatibility of your generated DLL, MinGW is recommended. A good rule-of-thumb is to generate 32-bit DLLs using MinGW and 64-bit DLLs using MSVC.</source>
          <target state="translated">MinGW는 32 비트 DLL 만 생성합니다. 64 비트 DLL을 생성하는 데 사용할 수있는 별도의 MinGW64 프로젝트가 있습니다. 아마도 명령 줄 구문은 비슷합니다. 또한 최신 버전의 MSVC는 WinXP 및 이전 버전의 Windows에서는 작동하지 않는 DLL을 생성합니다. 따라서 생성 된 DLL의 최대 호환성을 위해 MinGW가 권장됩니다. 가장 좋은 방법은 MinGW를 사용하여 32 비트 DLL을 생성하고 MSVC를 사용하여 64 비트 DLL을 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="103d786acd07e894276011f9fe0ff0e5d6f3f4da" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNORE는 &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 반환 된 &lt;a href=&quot;#SQLITE_FAIL&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="82cf9ab6c420a3c604d44b14992c4f512d1f4c35" translate="yes" xml:space="preserve">
          <source>Note that SQLITE_IGNORE is also used as a &lt;a href=&quot;c_fail&quot;&gt;conflict resolution mode&lt;/a&gt; returned from the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; interface.</source>
          <target state="translated">SQLITE_IGNORE는 &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 인터페이스 에서 반환 된 &lt;a href=&quot;c_fail&quot;&gt;충돌 해결 모드&lt;/a&gt; 로 도 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd4aaf9aa187deca337c2af0406d2d0e3c9d07f4" translate="yes" xml:space="preserve">
          <source>Note that SQLite allows the parenthesized list of scalar values on the right-hand side of an IN or NOT IN operator to be an empty list but most other SQL database database engines and the SQL92 standard require the list to contain at least one element.</source>
          <target state="translated">SQLite를 사용하면 IN 또는 NOT IN 연산자의 오른쪽에있는 괄호로 묶인 스칼라 값 목록이 빈 목록이 될 수 있지만 대부분의 다른 SQL 데이터베이스 데이터베이스 엔진 및 SQL92 표준에는 목록에 하나 이상의 요소가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="069a48733ca46d6fc20e074068d69739ed664b2b" translate="yes" xml:space="preserve">
          <source>Note that SQLite automatically adds the appropriate extension suffix (&quot;.dll&quot; on windows, &quot;.dylib&quot; on Mac, &quot;.so&quot; on most other unixes) to the extension filename. It is generally a good idea to specify the full pathname of the extension.</source>
          <target state="translated">SQLite는 적절한 확장자 접미사 (Windows의 경우 &quot;.dll&quot;, Mac의 경우 &quot;.dylib&quot;, 대부분의 다른 유닉스의 경우 &quot;.so&quot;)를 자동으로 확장자 파일 이름에 추가합니다. 일반적으로 확장자의 전체 경로 이름을 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="878abfb73c8f4fd7637bff37205a9854afa6975b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;../malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLite에는 압도적 인 대다수의 응용 프로그램에 완벽하게 적합한 여러 &lt;a href=&quot;../malloc#altalloc&quot;&gt;내장 메모리 할당자가 포함&lt;/a&gt; 되어 있으며이 객체는 특수한 메모리 할당 요구 사항을 가진 소수의 응용 프로그램에만 유용합니다. 이 객체는 또한 SQLite가 이러한 조건에서 정상적으로 복구되는지 확인하기 위해 메모리 부족 메모리 조건을 시뮬레이트하는 대체 메모리 할당자를 지정하기 위해 SQLite를 테스트하는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9932e44739c8fef89cbf2d998599f354bb604b" translate="yes" xml:space="preserve">
          <source>Note that SQLite comes with several &lt;a href=&quot;malloc#altalloc&quot;&gt;built-in memory allocators&lt;/a&gt; that are perfectly adequate for the overwhelming majority of applications and that this object is only useful to a tiny minority of applications with specialized memory allocation requirements. This object is also used during testing of SQLite in order to specify an alternative memory allocator that simulates memory out-of-memory conditions in order to verify that SQLite recovers gracefully from such conditions.</source>
          <target state="translated">SQLite에는 압도적 인 대다수의 응용 프로그램에 완벽하게 적합한 여러 &lt;a href=&quot;malloc#altalloc&quot;&gt;내장 메모리 할당자가 포함&lt;/a&gt; 되어 있으며이 객체는 특수한 메모리 할당 요구 사항을 가진 소수의 응용 프로그램에만 유용합니다. 이 객체는 또한 SQLite가 이러한 조건에서 정상적으로 복구되는지 확인하기 위해 메모리 부족 메모리 조건을 시뮬레이트하는 대체 메모리 할당자를 지정하기 위해 SQLite를 테스트하는 동안 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f1f541cbfa03c47b900f800f3f8afdec05b49044" translate="yes" xml:space="preserve">
          <source>Note that SQLite does not enforce the PRIMARY KEY for a WITHOUT ROWID virtual table. Enforcement is the responsibility of the underlying virtual table implementation. But SQLite does assume that the PRIMARY KEY constraint is valid - that the identified columns really are UNIQUE and NOT NULL - and it uses that assumption to optimize queries against the virtual table.</source>
          <target state="translated">SQLite는 WITHOUT ROWID 가상 테이블에 대해 PRIMARY KEY를 시행하지 않습니다. 적용은 기본 가상 테이블 구현의 책임입니다. 그러나 SQLite는 PRIMARY KEY 제약 조건이 유효하다고 가정합니다. 식별 된 열은 실제로 UNIQUE이며 NOT NULL이 아니며 가상 테이블에 대해 쿼리를 최적화하기 위해 해당 가정을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3bdb4d9a8050dadd7145a64b6065f6da75ef0eb" translate="yes" xml:space="preserve">
          <source>Note that SQLite must believe whatever the operating system and hardware tell it about the status of sync requests. There is no way for SQLite to detect that either is lying and that writes might be occurring out-of-order. However, SQLite in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is far more forgiving of out-of-order writes than in the default rollback journal modes. In WAL mode, the only time that a failed sync operation can cause database corruption is during a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operation. A sync failure during a COMMIT might result in loss of durability but not in a corrupt database file. Hence, one line of defense against database corruption due to failed sync operations is to use SQLite in WAL mode and to checkpoint as infrequently as possible.</source>
          <target state="translated">SQLite는 운영 체제 및 하드웨어가 동기화 요청의 상태에 대해 알려주는 것을 믿어야합니다. SQLite가 거짓말 중이거나 쓰기가 잘못되었음을 감지하는 방법은 없습니다. 그러나 &lt;a href=&quot;wal&quot;&gt;WAL 모드의&lt;/a&gt; SQLite 는 기본 롤백 저널 모드보다 비 순차적 쓰기를 용서합니다. WAL 모드에서 실패한 동기화 작업으로 인해 데이터베이스가 손상 될 수있는 유일한 시간은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업 중입니다. COMMIT 중 동기화 실패로 인해 내구성이 손실 될 수 있지만 데이터베이스 파일은 손상되지 않습니다. 따라서 동기화 조작 실패로 인한 데이터베이스 손상에 대한 한 가지 방어선은 WAL 모드에서 SQLite를 사용하고 가능한 한 자주 체크 포인트를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a2fee544cde41af143fe81786b7190276086b344" translate="yes" xml:space="preserve">
          <source>Note that SQLite uses b-trees, which are a sorted data structure, so indices can be used when the WHERE clause of the SELECT statement contains tests for equality or inequality. Queries like the following can use an index if it is available:</source>
          <target state="translated">SQLite는 정렬 된 데이터 구조 인 b- 트리를 사용하므로 SELECT 문의 WHERE 절에 동등 또는 부등식에 대한 테스트가 포함 된 경우 인덱스를 사용할 수 있습니다. 다음과 같은 쿼리는 사용 가능한 경우 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5081483bfc5c0173b67743dd4507d0595797d951" translate="yes" xml:space="preserve">
          <source>Note that a declared type of &quot;FLOATING POINT&quot; would give INTEGER affinity, not REAL affinity, due to the &quot;INT&quot; at the end of &quot;POINT&quot;. And the declared type of &quot;STRING&quot; has an affinity of NUMERIC, not TEXT.</source>
          <target state="translated">선언 된 유형의 &quot;FLOATING POINT&quot;는 &quot;POINT&quot;의 끝에있는 &quot;INT&quot;로 인해 RETE 선호도가 아닌 INTEGER 선호도를 제공합니다. 선언 된 &quot;STRING&quot;유형은 TEXT가 아니라 NUMERIC의 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6008db09d7c79dcc3b84a140fc5e215929e6ce79" translate="yes" xml:space="preserve">
          <source>Note that a transformation that flips the polygon might cause the order of vertexes to be reversed. In other words, the transformation might cause the vertexes to circulate in clockwise order instead of counter-clockwise. This can be corrected by sending the result through the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function after transformation.</source>
          <target state="translated">다각형을 뒤집는 변형은 꼭지점 순서가 뒤바뀔 수 있습니다. 다시 말해, 변환으로 꼭지점이 시계 반대 방향이 아닌 시계 방향으로 순환 할 수 있습니다. 변환 후 &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw ()&lt;/a&gt; 함수를 통해 결과를 보내서이를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3eb1501d271603c6953bfb8ef829d45c83d17e8d" translate="yes" xml:space="preserve">
          <source>Note that an inner transaction might commit (using the RELEASE command) but then later have its work undone by a ROLLBACK in an outer transaction. A power failure or program crash or OS crash will cause the outer-most transaction to rollback, undoing all changes that have occurred within that outer transaction, even changes that have supposedly been &quot;committed&quot; by the RELEASE command. Content is not actually committed on the disk until the outermost transaction commits.</source>
          <target state="translated">내부 트랜잭션은 커밋 (RELEASE 명령 사용) 할 수 있지만 나중에 외부 트랜잭션에서 ROLLBACK에 의해 작업이 취소됩니다. 정전 또는 프로그램 충돌 또는 OS 충돌로 인해 가장 바깥 쪽 트랜잭션이 롤백되어 해당 외부 트랜잭션 내에서 발생한 모든 변경 사항을 취소하고 RELEASE 명령에 의해 &quot;커밋 된&quot;변경 내용도 취소됩니다. 가장 바깥 쪽 트랜잭션이 커밋 될 때까지 실제로 콘텐츠는 디스크에서 커밋되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7c93fd99fb4687ad2997daf3b6769cc616b7c58e" translate="yes" xml:space="preserve">
          <source>Note that conflict resolutions from multiple remote changesets are combined on a per-field basis, not per-row. This means that in the case of multiple remote UPDATE operations, some fields of a single local change may be rebased for REPLACE while others are rebased for OMIT.</source>
          <target state="translated">여러 원격 변경 집합의 충돌 해결은 행 단위가 아니라 필드 단위로 결합됩니다. 이는 다중 원격 UPDATE 조작의 경우 단일 로컬 변경의 일부 필드는 REPLACE에 대해 리베이스되고 다른 필드는 OMIT에 대해 리베이스 될 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e3af7101a58299023cb05d90e0fc88f9fa63608b" translate="yes" xml:space="preserve">
          <source>Note that conversions between UTF-16be and UTF-16le are always done in place and do not invalidate a prior pointer, though of course the content of the buffer that the prior pointer points to will have been modified. Other kinds of conversion are done in place when it is possible, but sometime it is not possible and in those cases prior pointers are invalidated.</source>
          <target state="translated">UTF-16be와 UTF-16le 간의 변환은 항상 제자리에서 수행되며 이전 포인터가 가리키는 버퍼의 내용이 수정 되었음에도 불구하고 이전 포인터를 무효화하지 않습니다. 다른 종류의 변환은 가능할 때 수행되지만 언젠가는 불가능하며 이러한 경우 이전 포인터가 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="f0c5f85c046ed0d0d783a57a522950f881e39de3" translate="yes" xml:space="preserve">
          <source>Note that deleting records from a zip archive does not reclaim the space used within the archive - it merely removes an entry from the archives &quot;Central Directory Structure&quot;, making the entry inaccessible. One way to work around this inefficiency is to create a new zip archive based on the contents of the edited archive. For example, after editing the archive accessed via virtual table temp.zzz:</source>
          <target state="translated">zip 아카이브에서 레코드를 삭제해도 아카이브 내에서 사용 된 공간을 회수하지는 않습니다. 아카이브 &quot;중앙 디렉토리 구조&quot;에서 항목을 제거하기 만하면 항목에 액세스 할 수 없습니다. 이 비 효율성을 해결하는 한 가지 방법은 편집 된 아카이브의 내용을 기반으로 새 zip 아카이브를 만드는 것입니다. 예를 들어 가상 테이블 temp.zzz를 통해 액세스 한 아카이브를 편집 한 후 :</target>
        </trans-unit>
        <trans-unit id="710cdb120286dd832bd6798397cffbb5dfeed9ef" translate="yes" xml:space="preserve">
          <source>Note that different operating systems use different filename suffixes for their shared libraries. Windows use &quot;.dll&quot;, Mac uses &quot;.dylib&quot;, and most unixes other than mac use &quot;.so&quot;. If you want to make your code portable, you can omit the suffix from the shared library filename and the appropriate suffix will be added automatically by the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; interface.</source>
          <target state="translated">운영 체제마다 공유 라이브러리에 다른 파일 이름 접미사를 사용합니다. Windows는 &quot;.dll&quot;을 사용하고 Mac은 &quot;.dylib&quot;를 사용하며 mac 이외의 대부분의 유닉스는 &quot;.so&quot;를 사용합니다. 코드를 이식 가능하게 만들려면 공유 라이브러리 파일 이름에서 접미사를 생략하면 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 인터페이스에 의해 적절한 접미사가 자동으로 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="c12e1242a0c93cb2f83528b0161fb89fb73eac90" translate="yes" xml:space="preserve">
          <source>Note that each 32768-byte unit of the shm file has its own aHash and aPgno arrays. The aHash array for a single unit is only helpful in finding aPgno entries in that same unit. The overall FindFrame(P,M) function needs to do hash lookups beginning with the latest unit and working backwards to the oldest unit until it finds an answer.</source>
          <target state="translated">shm 파일의 각 32768 바이트 단위에는 고유 한 aHash 및 aPgno 배열이 있습니다. 단일 장치의 aHash 배열은 동일한 장치에서 aPgno 항목을 찾는 데만 도움이됩니다. 전체 FindFrame (P, M) 함수는 최신 단위로 시작하여 해답을 찾을 때까지 가장 오래된 단위로 거꾸로 해시 조회를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="30f49c0b1079064845cadc4000f3f0cbc4ba7f9a" translate="yes" xml:space="preserve">
          <source>Note that enabling FTS3 also makes FTS4 available. There is not a separate SQLITE_ENABLE_FTS4 compile-time option. A build of SQLite either supports both FTS3 and FTS4 or it supports neither.</source>
          <target state="translated">FTS3을 활성화하면 FTS4도 사용할 수 있습니다. 별도의 SQLITE_ENABLE_FTS4 컴파일 타임 옵션이 없습니다. SQLite 빌드는 FTS3과 FTS4를 모두 지원하거나 둘 다 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="665e7a6fdd40011f21f13b4109b67442ccc2792c" translate="yes" xml:space="preserve">
          <source>Note that except for a few corner-case differences detailed above, WITHOUT ROWID tables and rowid tables work the same. They both generate the same answers given the same SQL statements. So it is a simple matter to run experiments on an application, late in the development cycle, to test whether or not the use of WITHOUT ROWID tables will be helpful. A good strategy is to simply not worry about WITHOUT ROWID until near the end of product development, then go back and run tests to see if adding WITHOUT ROWID to tables with non-integer PRIMARY KEYs helps or hurts performance, and retaining the WITHOUT ROWID only in those cases where it helps.</source>
          <target state="translated">위에서 상세하게 설명한 몇 가지 대소 문자 차이를 제외하고 WITHOUT ROWID 테이블과 rowid 테이블은 동일하게 작동합니다. 그들은 동일한 SQL 문이 주어지면 동일한 대답을 생성합니다. 따라서 WITHOUT ROWID 테이블 사용이 도움이 될지 여부를 테스트하기 위해 개발주기 후반에 애플리케이션에서 실험을 실행하는 것은 간단합니다. 좋은 전략은 제품 개발이 끝날 때까지 ROWID없이 걱정하지 말고, 정수가 아닌 PRIMARY KEY가있는 테이블에 ROWID없이 ROWID를 추가하여 성능을 향상 시키거나 손상시키는 지 확인하고 ROWID 만 유지하는 것입니다. 도움이되는 경우.</target>
        </trans-unit>
        <trans-unit id="bde5b3e09fe9bd78baf5c5b8cf655c1d83bf9828" translate="yes" xml:space="preserve">
          <source>Note that geopoly uses a traditional right-handed cartesian coordinate system with the origin at the lower left, whereas SVG uses a left-handed coordinate system with the origin at the upper left. The geopoly_svg() routine makes no attempt to transform the coordinate system, so the displayed images are shown in mirror image and rotated. If that is undesirable, the geopoly_xform() routine can be used to transform the output from cartesian to SVG coordinates prior to passing the polygons into geopoly_svg().</source>
          <target state="translated">geopoly는 왼쪽 아래에 원점이있는 전통적인 오른손 데카르트 좌표계를 사용하는 반면 SVG는 왼쪽 위에 원점이있는 왼손 좌표계를 사용합니다. geopoly_svg () 루틴은 좌표계 변환을 시도하지 않으므로 표시된 이미지가 미러 이미지로 표시되고 회전됩니다. 이것이 바람직하지 않은 경우, geopoly_xform () 루틴을 사용하여 다각형을 geopoly_svg ()로 전달하기 전에 출력을 직교에서 SVG 좌표로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a440c913714baad6d711ca1c482bbb8e3fece7" translate="yes" xml:space="preserve">
          <source>Note that if a non-deterministic function is tagged with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; and if that function ends up being used in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt; or in an &lt;a href=&quot;expridx&quot;&gt;expression index&lt;/a&gt;, then when the function begins to return different answers, the associated index may become corrupt. If an SQL function is nearly deterministic (which is to say, if it only rarely changes, like &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt;) and it is used in an index that becomes corrupt, the corruption can be fixed by running &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt;.</source>
          <target state="translated">비 결정적 함수에 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 태그가 지정 되고 해당 함수가 &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 또는 &lt;a href=&quot;expridx&quot;&gt;표현식 인덱스&lt;/a&gt; 에서 사용되면 함수가 다른 응답을 리턴하기 시작하면 연관된 인덱스가 손상 될 수 있습니다. . SQL 함수가 거의 결정 론적이며 (즉, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 과 같이 거의 변경되지 않는 경우 ) 손상된 인덱스에서 사용되는 경우 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 를 실행하여 손상을 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e7ef1f945a3c3a6083df7d03b59a24fcefb7fd0" translate="yes" xml:space="preserve">
          <source>Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc() returns a different mutex on every call. For the static mutex types, the same mutex is returned on every call that has the same type number.</source>
          <target state="translated">동적 뮤텍스 매개 변수 중 하나 (SQLITE_MUTEX_FAST 또는 SQLITE_MUTEX_RECURSIVE)가 사용 된 경우 sqlite3_mutex_alloc ()은 모든 호출에서 다른 뮤텍스를 반환합니다. 정적 뮤텍스 유형의 경우 동일한 유형 번호를 가진 모든 호출에서 동일한 뮤텍스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1c50891c113debf231642ee8d937768c49d352cf" translate="yes" xml:space="preserve">
          <source>Note that if you do not include the &quot;langid=N&quot; term in the WHERE clause, the search will be against language 0 (English in the example above.) All spellfix1 searches are against a single language id. There is no way to search all languages at once.</source>
          <target state="translated">WHERE 절에 &quot;langid = N&quot;용어를 포함시키지 않으면 검색은 언어 0 (위의 예에서는 영어)에 대해 수행됩니다. 모든 spellfix1 검색은 단일 언어 ID에 대한 것입니다. 한 번에 모든 언어를 검색 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="67f33837baeec763fa57cef78587afa10292c83d" translate="yes" xml:space="preserve">
          <source>Note that in most cases, SQLite will only use a single index for each table in the FROM clause of a query. The second OR-clause optimization described here is the exception to that rule. With an OR-clause, a different index might be used for each subterm in the OR-clause.</source>
          <target state="translated">대부분의 경우 SQLite는 쿼리의 FROM 절에있는 각 테이블에 대해 단일 인덱스 만 사용합니다. 여기에 설명 된 두 번째 OR 절 최적화는 해당 규칙의 예외입니다. OR 절을 사용하면 OR 절의 각 하위 용어에 대해 서로 다른 색인이 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63fa9dab5a3c38f244560b4ee3d5231308f8ad59" translate="yes" xml:space="preserve">
          <source>Note that in order for the special &quot;:memory:&quot; name to apply and to create a pure in-memory database, there must be no additional text in the filename. Thus, a disk-based database can be created in a file by prepending a pathname, like this: &quot;./:memory:&quot;.</source>
          <target state="translated">특수한 &quot;: memory :&quot;이름을 적용하고 순수한 인 메모리 데이터베이스를 만들려면 파일 이름에 추가 텍스트가 없어야합니다. 따라서 &quot;./:memory :&quot;와 같이 경로 이름을 앞에 붙여 디스크 기반 데이터베이스를 파일에 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b52e107709738a3260fec8ebd98ff46511f5c58" translate="yes" xml:space="preserve">
          <source>Note that in the diagram above, we showed the private edits as a single commit. This was for clarity of presentation only. There is nothing to stop you from doing dozens or hundreds of separate tiny changes and committing each separately. In fact, making many small changes is the preferred way to work. The only reason for doing all the changes in a single commit is that it makes the diagram easier to draw.</source>
          <target state="translated">위의 다이어그램에서 개인 편집 내용을 단일 커밋으로 표시했습니다. 이것은 명확하게 표현하기위한 것입니다. 수십 또는 수백 개의 개별적인 작은 변화를 수행하고 각각 개별적으로 커밋하는 것을 막을 수있는 것은 없습니다. 실제로, 많은 작은 변경을하는 것이 선호되는 작업 방법입니다. 단일 커밋에서 모든 변경을 수행하는 유일한 이유는 다이어그램을 더 쉽게 그릴 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="705b7526443ed2af20dbc38ecc0ad5be9f1ce9d9" translate="yes" xml:space="preserve">
          <source>Note that in this design, the tokenizer calls the parser. People who are familiar with YACC and BISON may be accustomed to doing things the other way around &amp;mdash; having the parser call the tokenizer. Having the tokenizer call the parser is better, though, because it can be made threadsafe and it runs faster.</source>
          <target state="translated">이 디자인에서 토크 나이 저는 파서를 호출합니다. YACC와 BISON에 익숙한 사람들은 파서가 토크 나이저라고하는 다른 방식으로 일하는 것에 익숙 할 것입니다. 하지만 토크 나이저가 파서를 호출하면 스레드에 안전하고 빠르게 실행될 수 있기 때문에 파서가 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="819e65339172e5dc379cf7c2c3439c1fadf7ced3" translate="yes" xml:space="preserve">
          <source>Note that infix functions (&lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt;, and &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt;) reverse the order of their arguments. So &quot;like(A,B)&quot; is equivalent to &quot;B like A&quot;. For the form &quot;B like A&quot; the B term is considered the first argument to the function. But for &quot;like(A,B)&quot; the A term is considered the first argument.</source>
          <target state="translated">삽입 함수 ( &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; , &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; )는 인수의 순서를 반대로합니다. 따라서 &quot;like (A, B)&quot;는 &quot;B like A&quot;와 같습니다. &quot;B like A&quot;형식의 경우 B 용어는 함수의 첫 번째 인수로 간주됩니다. 그러나 &quot;like (A, B)&quot;의 경우 A 용어가 첫 번째 인수로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="35589dde916482f10a4613056291243d802b1cc4" translate="yes" xml:space="preserve">
          <source>Note that it is important to set the &quot;mode&quot; to &quot;csv&quot; before running the &quot;.import&quot; command. This is necessary to prevent the command-line shell from trying to interpret the input file text as some other format.</source>
          <target state="translated">&quot;.import&quot;명령을 실행하기 전에 &quot;mode&quot;를 &quot;csv&quot;로 설정해야합니다. 이것은 명령 행 쉘이 입력 파일 텍스트를 다른 형식으로 해석하지 못하게하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aab0f603b95c5838db66d31fe53b5c5afd66afd1" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary for all coordinates in an R*Tree index to be constrained in order for the index search to be efficient. One might, for example, want to query all objects that overlap with the 35th parallel:</source>
          <target state="translated">인덱스 검색을 효율적으로하기 위해 R * Tree 인덱스의 모든 좌표를 제한 할 필요는 없습니다. 예를 들어 35 번째 병렬과 겹치는 모든 객체를 쿼리하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="750004cbbcdb4b09f134058116396d2802e69e0a" translate="yes" xml:space="preserve">
          <source>Note that it is not necessary to quote the $bigstring value. That happens automatically. If $bigstring is a large string or binary object, this technique is not only easier to write, it is also much more efficient since it avoids making a copy of the content of $bigstring.</source>
          <target state="translated">$ bigstring 값을 인용 할 필요는 없습니다. 자동으로 발생합니다. $ bigstring이 큰 문자열 또는 이진 객체 인 경우이 기술은 쓰기가 쉬울뿐만 아니라 $ bigstring의 내용을 복사하지 않기 때문에 훨씬 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="aedf129a94b2c6ea4cf41bd3da4352659cc6bb37" translate="yes" xml:space="preserve">
          <source>Note that it is perfectly safe for two or more threads to access the same SQLite database file using the SQLite library. The unix drivers for SQLite know about the POSIX advisory locking quirks and work around them. This problem only arises when a thread tries to bypass the SQLite library and read the database file directly.</source>
          <target state="translated">두 개 이상의 스레드가 SQLite 라이브러리를 사용하여 동일한 SQLite 데이터베이스 파일에 액세스하는 것이 안전합니다. SQLite 용 유닉스 드라이버는 POSIX 권고 잠금 문제를 알고 해결합니다. 스레드가 SQLite 라이브러리를 무시하고 데이터베이스 파일을 직접 읽으려고 할 때만이 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="af76f7d3a1b3eb149d8a26a0e9299bf38c7c0401" translate="yes" xml:space="preserve">
          <source>Note that it is very important that the database filename have some kind of extension. If there is no extension, then SQLite creates auxiliary filenames by appending to the base name of the file. Thus, a database named &quot;&lt;code&gt;db01&lt;/code&gt;&quot; would have a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; file named &quot;&lt;code&gt;db01-journal&lt;/code&gt;&quot;. And as this filename has no extension to shorten to 3 characters, it will be used as-is, and will violate 8+3 naming rules.</source>
          <target state="translated">데이터베이스 파일 이름의 확장자는 매우 중요합니다. 확장명이 없으면 SQLite는 파일의 기본 이름을 추가하여 보조 파일 이름을 만듭니다. 따라서 &quot; &lt;code&gt;db01&lt;/code&gt; &quot; 이라는 데이터베이스 에는 &quot; &lt;code&gt;db01-journal&lt;/code&gt; &quot; 이라는 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 파일 이 있습니다 . 이 파일 이름은 3 자로 단축되는 확장자가 없으므로 그대로 사용되며 8 + 3 명명 규칙을 위반합니다.</target>
        </trans-unit>
        <trans-unit id="19eeeefb37e5b82a70fbf6a86a847157f005c210" translate="yes" xml:space="preserve">
          <source>Note that prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), SQLite did not check the xCreate method for NULL before invoking it. So if an eponymous-only virtual table is registered with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;version 3.8.11.1&lt;/a&gt; (2015-07-29) or earlier and a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command is attempted against that virtual table module, a jump to a NULL pointer will occur, resulting in a crash.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 이전에 xCreate 메소드를 호출하기 전에 NULL을 확인하지 않았습니다. 따라서 &lt;a href=&quot;https://sqlite.org/releaselog/3_8_11_1.html&quot;&gt;시연&lt;/a&gt; 전용 가상 테이블이 SQLite 버전 3.8.11.1 (2015-07-29) 이하 로 등록되어 있고 해당 가상 테이블 모듈에 대해 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 명령이 시도되면 NULL 포인터로 점프하여 결과적으로 충돌.</target>
        </trans-unit>
        <trans-unit id="7cb63274cd75ba4167c68c8885d57c07e7241aab" translate="yes" xml:space="preserve">
          <source>Note that running SQLite with gcov is not a test of SQLite &amp;mdash; it is a test of the test suite. The gcov run does not test SQLite because the -fprofile-args and -ftest-coverage options cause the compiler to generate different code. The gcov run merely verifies that the test suite provides 100% branch test coverage. The gcov run is a test of the test - a meta-test.</source>
          <target state="translated">gcov와 함께 SQLite를 실행하는 것은 SQLite의 테스트가 아니라 테스트 스위트의 테스트입니다. -fprofile-args 및 -ftest-coverage 옵션으로 인해 컴파일러가 다른 코드를 생성하므로 gcov 실행은 SQLite를 테스트하지 않습니다. gcov 실행은 테스트 스위트가 100 % 분기 테스트 범위를 제공하는지 확인합니다. gcov 실행은 테스트 테스트-메타 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="5a5f0aee350ad05534eee4c24d91d936725afa91" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 상수는 또한 전위로부터 반환 값으로서 사용된다 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 콜백 것을 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT는&lt;/a&gt; 또한 인 &lt;a href=&quot;rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4daa0a4c8ffbaa8c905b7b2b472738ae1e277cf" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces do not count INSTEAD OF trigger firings, but the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; does count INSTEAD OF trigger firing.</source>
          <target state="translated">있습니다 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 와 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes는 ()&lt;/a&gt; 인터페이스는 트리거 해고 대신에 포함되지 않습니다,하지만 &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes 프라그가&lt;/a&gt; INSTEAD 트리거 발사 카운트 않습니다.</target>
        </trans-unit>
        <trans-unit id="f4f048e66a09e44bfda0411919740620eea7756a" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE&lt;/a&gt; constant is also used as a potential return value from the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; callback and that &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; is also a &lt;a href=&quot;../rescode&quot;&gt;result code&lt;/a&gt;.</source>
          <target state="translated">점을 유의 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_IGNORE의&lt;/a&gt; 상수는 또한 전위로부터 반환 값으로서 사용된다 &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 콜백 것을 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT는&lt;/a&gt; 또한 인 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e678676cbad83be2195f0c9cbdf90bfcdfbeb" translate="yes" xml:space="preserve">
          <source>Note that the DO UPDATE clause acts only on the single row that experienced the constraint error during INSERT. It is not necessary to include a WHERE clause that restrictions the action to that one row. The only use for the WHERE clause at the end of the DO UPDATE is to optionally change the DO UPDATE into a no-op depending on the original and/or new values. For example:</source>
          <target state="translated">DO UPDATE 절은 INSERT 중에 제한 조건 오류가 발생한 단일 행에서만 작동합니다. 조치를 해당 한 행으로 제한하는 WHERE 절을 포함 할 필요는 없습니다. DO UPDATE 끝에서 WHERE 절의 유일한 사용은 원래 값 및 / 또는 새 값에 따라 DO UPDATE를 no-op로 선택적으로 변경하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e431af898d8e365308f86b50efb344365dfb157" translate="yes" xml:space="preserve">
          <source>Note that the SQLITE_TEXT constant was also used in SQLite version 2 for a completely different meaning. Software that links against both SQLite version 2 and SQLite version 3 should use SQLITE3_TEXT, not SQLITE_TEXT.</source>
          <target state="translated">SQLITE_TEXT 상수는 SQLite 버전 2에서도 완전히 다른 의미로 사용되었습니다. SQLite 버전 2와 SQLite 버전 3 모두에 연결되는 소프트웨어는 SQLITE_TEXT가 아닌 SQLITE3_TEXT를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="db7397560741b34c84d7c7b13b86a2bbf792ba5b" translate="yes" xml:space="preserve">
          <source>Note that the SQLite parser will not always generate code to use an index, even if it is possible to do so. The following queries will not currently use the index:</source>
          <target state="translated">SQLite 파서는 가능하면 색인을 사용하기위한 코드를 항상 생성하지는 않습니다. 다음 쿼리는 현재 인덱스를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="021cca6e0a1bc313b828c0c99864715910f5cf3d" translate="yes" xml:space="preserve">
          <source>Note that the UNION ALL operator for compound queries does not use transient indices by itself (though of course the right and left subqueries of the UNION ALL might use transient indices depending on how they are composed.)</source>
          <target state="translated">복합 쿼리에 대한 UNION ALL 연산자는 자체적으로 일시적인 인덱스를 사용하지 않습니다 (물론 UNION ALL의 오른쪽 및 왼쪽 하위 쿼리는 구성 방식에 따라 일시적인 인덱스를 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0676f5b60fd19b027ecab9b9999e5b7f746d671c" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">권한 부 여자 콜백은 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 그 변형 동안에 만 호출됩니다 . &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 명령문 평가 중에 권한 부여는 수행되지 않습니다 . 이전 단락에서 언급 한대로 sqlite3_step ()은 sqlite3_prepare_v2 ()를 호출하여 스키마 변경 후 명령문을 다시 준비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f1e28776761e0bfe4431c21ae77ea6373668b8fc" translate="yes" xml:space="preserve">
          <source>Note that the authorizer callback is invoked only during &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or its variants. Authorization is not performed during statement evaluation in &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;, unless as stated in the previous paragraph, sqlite3_step() invokes sqlite3_prepare_v2() to reprepare a statement after a schema change.</source>
          <target state="translated">권한 부 여자 콜백은 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 그 변형 동안에 만 호출됩니다 . &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 에서 명령문 평가 중에 권한 부여는 수행되지 않습니다 . 이전 단락에서 언급 한대로 sqlite3_step ()은 sqlite3_prepare_v2 ()를 호출하여 스키마 변경 후 명령문을 다시 준비하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac6d36a8492877c1ea3743d0c173020c27937cf2" translate="yes" xml:space="preserve">
          <source>Note that the character encoding mechanism used by SQLite cannot be changed at run-time. This is a compile-time option only. The &lt;b&gt;sqlite_encoding&lt;/b&gt; character string just tells you how the library was compiled.</source>
          <target state="translated">SQLite에서 사용하는 문자 인코딩 메커니즘은 런타임시 변경할 수 없습니다. 이것은 컴파일 타임 옵션입니다. &lt;b&gt;sqlite_encoding&lt;/b&gt; 문자열은 라이브러리가 컴파일 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7febee2154ade1b2d3219ad0df6d8ce2b6d91690" translate="yes" xml:space="preserve">
          <source>Note that the checksums in the rollback journal are not necessary if the synchronous setting is FULL. We only depend on the checksums when synchronous is lowered to NORMAL. Nevertheless, the checksums never hurt and so they are included in the rollback journal regardless of the synchronous setting.</source>
          <target state="translated">동기 설정이 FULL 인 경우 롤백 저널의 체크섬이 필요하지 않습니다. 동기가 NORMAL로 낮아질 때 체크섬에만 의존합니다. 그럼에도 불구하고 체크섬은 결코 아프지 않으므로 동기 설정에 관계없이 롤백 저널에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="808239b91162b2ff74019b785a2c4443032a884a" translate="yes" xml:space="preserve">
          <source>Note that the command-line shell program has already enabled extension loading for you (by calling the &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension()&lt;/a&gt; interface as part of its setup) so the command above works without any special switches, setup, or other complications.</source>
          <target state="translated">명령 행 쉘 프로그램은 이미 설정의 일부로 &lt;a href=&quot;c3ref/enable_load_extension&quot;&gt;sqlite3_enable_load_extension ()&lt;/a&gt; 인터페이스를 호출하여 확장로드를 사용 가능하게 하므로 위의 명령은 특별한 스위치, 설정 또는 기타 복잡성없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6e9cc72c28987333ade7d6e3571128f51c3b46dd" translate="yes" xml:space="preserve">
          <source>Note that the destructor function D is for the pointer value P, not for the type string T. The type string T should be a static string with an infinite lifetime.</source>
          <target state="translated">소멸자 함수 D는 유형 문자열 T가 아닌 포인터 값 P에 대한 것입니다. 유형 문자열 T는 수명이 무한한 정적 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4cfa4e46e35f2a19630aea45991cffe3dd621ecd" translate="yes" xml:space="preserve">
          <source>Note that the integer key is one greater than the largest key that was in the table just prior to the insert. The new key will be unique over all keys currently in the table, but it might overlap with keys that have been previously deleted from the table. To create keys that are unique over the lifetime of the table, add the &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; keyword to the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; declaration. Then the key chosen will be one more than the largest key that has ever existed in that table. If the largest possible key has previously existed in that table, then the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; will fail with an &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; error code.</source>
          <target state="translated">정수 키는 삽입 직전에 테이블에 있던 가장 큰 키보다 하나 큰 것입니다. 새 키는 현재 테이블에있는 모든 키에서 고유하지만 이전에 테이블에서 삭제 된 키와 겹칠 수 있습니다. 테이블 수명 동안 고유 한 키를 작성하려면 &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 키워드를 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 선언에 추가하십시오 . 그런 다음 선택한 키는 해당 테이블에 존재했던 가장 큰 키보다 하나 더 많습니다. 가장 큰 가능한 키가 해당 테이블에 이미 존재하면 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 는 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 오류 코드 와 함께 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="228b63ead1b7d1b62a8c83539d4e8ab64da2dc4c" translate="yes" xml:space="preserve">
          <source>Note that the journal_mode for an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; is either MEMORY or OFF and can not be changed to a different value. An attempt to change the journal_mode of an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; to any setting other than MEMORY or OFF is ignored. Note also that the journal_mode cannot be changed while a transaction is active.</source>
          <target state="translated">&lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 journal_mode 는 MEMORY 또는 OFF이며 다른 값으로 변경할 수 없습니다. &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 의 journal_mode를 MEMORY 또는 OFF 이외의 설정 으로 변경하려는 시도 는 무시됩니다. 또한 트랜잭션이 활성화되어있는 동안 journal_mode를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1150442b82dfad6909e59c690e94911009ab738b" translate="yes" xml:space="preserve">
          <source>Note that the list of routines above is conceptual rather than actual. Many of these routines come in multiple versions. For example, the list above shows a single routine named &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; when in fact there are three separate routines that accomplish the same thing in slightly different ways: &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. The list mentions &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column()&lt;/a&gt; when in fact no such routine exists. The &quot;sqlite3_column()&quot; shown in the list is a placeholder for an entire family of routines that extra column data in various datatypes.</source>
          <target state="translated">위의 루틴 목록은 실제가 아니라 개념적입니다. 이러한 루틴 중 다수는 여러 버전으로 제공됩니다. 예를 들어, 위 목록 에는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 같은 약간 다른 방식으로 동일한 작업을 수행하는 세 개의 별도 루틴이있는 경우 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 이라는 단일 루틴 이 표시됩니다 . 실제로 그러한 루틴이 존재하지 않는 경우 에는 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column ()을&lt;/a&gt; 언급 합니다. 목록에 표시된 &quot;sqlite3_column ()&quot;은 다양한 데이터 유형의 열 데이터를 추가하는 전체 루틴 제품군의 플레이스 홀더입니다.</target>
        </trans-unit>
        <trans-unit id="4fdc00a153b8f8752a20bfd3564af15ee4f88900" translate="yes" xml:space="preserve">
          <source>Note that the memory leak detection logic continues to work even when the OOM overlay is being used. This verifies that SQLite does not leak memory even when it encounters memory allocation errors. Note also that the OOM overlay can work with any underlying memory allocator, including the instrumented memory allocator that checks for memory allocation misuse. In this way it is verified that OOM errors do not induce other kinds of memory usage errors.</source>
          <target state="translated">OOM 오버레이를 사용하는 경우에도 메모리 누수 감지 로직이 계속 작동합니다. 이것은 메모리 할당 오류가 발생하더라도 SQLite가 메모리를 누출하지 않는지 확인합니다. OOM 오버레이는 메모리 할당 오용 여부를 확인하는 인스트루먼트 된 메모리 할당자를 포함하여 모든 기본 메모리 할당 기와 함께 작동 할 수 있습니다. 이러한 방식으로 OOM 오류가 다른 종류의 메모리 사용 오류를 유발하지 않는지 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="a2673a9d4ca364b864416763c5f28c9b8fac9ff0" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLite가 이해하는 키워드 수는 컴파일 타임 옵션에 따라 달라질 수 있습니다. 예를 들어, SQLite가 &lt;a href=&quot;../compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; 옵션으로 컴파일 된 경우 &quot;VACUUM&quot;은 키워드가 아닙니다 . 또한 SQLite의 향후 릴리스에 새로운 키워드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d91b980ac2f1529b090c5eabcb20ce64f838c85" translate="yes" xml:space="preserve">
          <source>Note that the number of keywords understood by SQLite can depend on compile-time options. For example, &quot;VACUUM&quot; is not a keyword if SQLite is compiled with the &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; option. Also, new keywords may be added to future releases of SQLite.</source>
          <target state="translated">SQLite가 이해하는 키워드 수는 컴파일 타임 옵션에 따라 달라질 수 있습니다. 예를 들어, SQLite가 &lt;a href=&quot;compile#omit_vacuum&quot;&gt;-DSQLITE_OMIT_VACUUM&lt;/a&gt; 옵션으로 컴파일 된 경우 &quot;VACUUM&quot;은 키워드가 아닙니다 . 또한 SQLite의 향후 릴리스에 새로운 키워드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aca65a78510b061ab1efe777d7b5b2943653a08" translate="yes" xml:space="preserve">
          <source>Note that the order of the rules for determining column affinity is important. A column whose declared type is &quot;CHARINT&quot; will match both rules 1 and 2 but the first rule takes precedence and so the column affinity will be INTEGER.</source>
          <target state="translated">열 선호도를 결정하기위한 규칙의 순서가 중요합니다. 선언 된 유형이 &quot;CHARINT&quot;인 열은 규칙 1과 2 모두와 일치하지만 첫 번째 규칙이 우선하므로 열 선호도는 INTEGER입니다.</target>
        </trans-unit>
        <trans-unit id="1d73e69c69eafce89c99fd09f5dcbc2e6299190a" translate="yes" xml:space="preserve">
          <source>Note that the primary result code is always a part of the extended result code. Given a full 32-bit extended result code, the application can always find the corresponding primary result code merely by extracting the least significant 8 bits of the extended result code.</source>
          <target state="translated">기본 결과 코드는 항상 확장 결과 코드의 일부입니다. 전체 32 비트 확장 결과 코드가 제공되면 응용 프로그램은 확장 결과 코드의 최하위 8 비트 만 추출하여 항상 해당 기본 결과 코드를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="299082c757bfbc2b1a98c9af13620cc48c49d3d4" translate="yes" xml:space="preserve">
          <source>Note that the program for this SELECT query didn't contain the Transaction and Commit instructions used in the INSERT example. Because the SELECT is a read operation that doesn't alter the database, it doesn't require a transaction.</source>
          <target state="translated">이 SELECT 쿼리에 대한 프로그램에는 INSERT 예제에 사용 된 트랜잭션 및 커밋 명령이 포함되어 있지 않습니다. SELECT는 데이터베이스를 변경하지 않는 읽기 작업이므로 트랜잭션이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f586476195ef53b793699f052ad1af05d3a6c8e4" translate="yes" xml:space="preserve">
          <source>Note that the readfile(X) and writefile(X,Y) functions are extension functions and are not built into the core SQLite library. These routines are available as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext/misc/fileio.c&lt;/a&gt; source file in the &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite source code repositories&lt;/a&gt;.</source>
          <target state="translated">readfile (X) 및 writefile (X, Y) 함수는 확장 함수이며 핵심 SQLite 라이브러리에 내장되어 있지 않습니다. 이러한 루틴은 &lt;a href=&quot;https://sqlite.org/download.html#srctree&quot;&gt;SQLite 소스 코드 저장소&lt;/a&gt; 의 &lt;a href=&quot;http://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/fileio.c&quot;&gt;ext / misc / fileio.c&lt;/a&gt; 소스 파일에서 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64553501493418021ca0b221dddc1b5aa622fbc2" translate="yes" xml:space="preserve">
          <source>Note that the result from casting any non-BLOB value into a BLOB and the result from casting any BLOB value into a non-BLOB value may be different depending on whether the database &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; is UTF-8, UTF-16be, or UTF-16le.</source>
          <target state="translated">BLOB 이외의 값을 BLOB로 캐스트 한 결과와 BLOB 값을 BLOB 이외의 값으로 캐스트 한 결과는 데이터베이스 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 이 UTF-8, UTF-16be 또는 UTF-16le 인지에 따라 다를 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="e984670ffac060fe0c3430de1a1c23ffe29028d1" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_apply_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_apply_v2 () API는 아직 &lt;b&gt;실험 단계&lt;/b&gt; 이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a04165c5ad09a6b0ad2414206038c2e65d87aa51" translate="yes" xml:space="preserve">
          <source>Note that the sqlite3changeset_start_v2() API is still &lt;b&gt;experimental&lt;/b&gt; and therefore subject to change.</source>
          <target state="translated">sqlite3changeset_start_v2 () API는 아직 &lt;b&gt;실험 단계&lt;/b&gt; 이므로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c55c88c2dea7079ec802efa3e99479f764ecf7e" translate="yes" xml:space="preserve">
          <source>Note that the unary *+* operator also removes &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt; from an expression, and in some cases this can cause subtle changes in the meaning of an expression. In the example above, if column *x* has &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT affinity&lt;/a&gt; then the comparison &quot;x=5&quot; will be done as text. But the *+* operator removes the affinity. So the comparison &quot;+x=5&quot; will compare the text in column *x* with the numeric value 5 and will always be false.</source>
          <target state="translated">단항 * + * 연산자는 표현식에서 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 를 제거 하며 경우에 따라 표현식의 의미가 미묘하게 변경 될 수 있습니다. 위의 예에서 * x * 열에 &lt;a href=&quot;datatype3#affinity&quot;&gt;TEXT 선호도&lt;/a&gt; 가 있으면 비교 &quot;x = 5&quot;가 텍스트로 수행됩니다. 그러나 * + * 연산자는 선호도를 제거합니다. 따라서 &quot;+ x = 5&quot;비교는 * x * 열의 텍스트를 숫자 값 5와 비교하며 항상 false입니다.</target>
        </trans-unit>
        <trans-unit id="c990d58c5d0bc49b39ec476dafbb19955404bbcd" translate="yes" xml:space="preserve">
          <source>Note that there are paths through the syntax diagrams that are not allowed in practice. Some examples:</source>
          <target state="translated">실제로 허용되지 않는 구문 다이어그램에는 경로가 있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="96acc3ff45ab0c01a0b94c0892486dbb72afce32" translate="yes" xml:space="preserve">
          <source>Note that there are two variations of the equals and not equals operators. Equals can be either</source>
          <target state="translated">equals 연산자와 equals 연산자에는 두 가지 변형이 있습니다. 같음</target>
        </trans-unit>
        <trans-unit id="a67d64fb18ca2294fb42994c6d74eeb61ff03be8" translate="yes" xml:space="preserve">
          <source>Note that this is only a thought experiment. We are not suggesting that OpenDocument be changed. Nor is this article a criticism of the current OpenDocument design. The point of this essay is to suggest ways to improve future file format designs.</source>
          <target state="translated">이것은 단지 생각 실험 일뿐입니다. OpenDocument를 변경할 것을 권장하지 않습니다. 이 기사는 현재 OpenDocument 디자인에 대한 비판도 아닙니다. 이 에세이의 요점은 미래의 파일 형식 디자인을 개선하는 방법을 제안하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="99c1505807d577ab62bcd4edbb24d5f3cd06e9f6" translate="yes" xml:space="preserve">
          <source>Note that this problem only occurs if the attempt to acquire the lock resulted in an I/O error. If the lock is simply not granted (because some other thread or process is already holding a conflicting lock) then no corruption will ever occur. We are not aware of any operating systems that will fail with an I/O error while attempting to get a file lock on shared memory. So this is a theoretical problem rather than a real problem. Needless to say, this problem has never been observed in the wild. The problem was discovered while doing stress testing of SQLite in a test harness that simulates I/O errors.</source>
          <target state="translated">이 문제점은 잠금을 획득하려고 시도 할 때 I / O 오류가 발생한 경우에만 발생합니다. 다른 스레드 또는 프로세스가 이미 충돌 잠금을 보유하고 있기 때문에 잠금이 단순히 부여되지 않으면 손상이 발생하지 않습니다. 공유 메모리에서 파일 잠금을 가져 오는 중에 I / O 오류로 실패 할 운영 체제를 인식하지 못했습니다. 따라서 이것은 실제 문제가 아닌 이론적 인 문제입니다. 말할 필요도없이,이 문제는 결코 야생에서 관찰 된 적이 없습니다. I / O 오류를 시뮬레이트하는 테스트 하네스에서 SQLite의 스트레스 테스트를 수행하는 중에 문제점이 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="ebff595e74a177f5fa63d87902cc62cb3ce02f96" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 일치시 0을 리턴하고 문자열이 일치하지 않으면 &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 와 같이 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="0d629b76283bd20b6edf31050b7b9b764c009820" translate="yes" xml:space="preserve">
          <source>Note that this routine returns zero on a match and non-zero if the strings do not match, the same as &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; and &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">이 루틴은 일치시 0을 리턴하고 문자열이 일치하지 않으면 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 및 &lt;a href=&quot;stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; 와 같이 0이 아닌 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c810fa4c8943f66ac3d34092b7e767d31528340e" translate="yes" xml:space="preserve">
          <source>Note that triggers are automatically dropped when the associated table is dropped.</source>
          <target state="translated">연관된 테이블이 삭제되면 트리거가 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="d606f23ac3535efbf11c3a7516392c25071ecf15" translate="yes" xml:space="preserve">
          <source>Note that when SQLite is compiled with SQLITE_THREADSAFE=0, the code to make SQLite threadsafe is omitted from the build. When this occurs, it is impossible to change the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; at start-time or run-time.</source>
          <target state="translated">SQLite가 SQLITE_THREADSAFE = 0으로 컴파일 될 때 SQLite 스레드 안전을위한 코드는 빌드에서 생략됩니다. 이 경우 시작 시간이나 런타임에 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 변경할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="789391b5c680547fd2d7df978b13d5bea4b6c611" translate="yes" xml:space="preserve">
          <source>Note that when the right-hand side of a LIKE or GLOB operator is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; and the statement is prepared using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; then the statement is automatically reparsed and recompiled on the first &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call of each run if the binding to the right-hand side parameter has changed since the previous run. This reparse and recompile is essentially the same action that occurs following a schema change. The recompile is necessary so that the query planner can examine the new value bound to the right-hand side of the LIKE or GLOB operator and determine whether or not to employ the optimization described above.</source>
          <target state="translated">LIKE 또는 GLOB 연산자의 오른쪽이 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이고 명령문이 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 를 사용하여 준비된 경우 명령문은 자동으로 재분석되고 각 실행 의 첫 번째 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 호출에서 재 컴파일 됩니다. 이전 실행 이후 오른쪽 매개 변수에 대한 바인딩이 변경되었습니다. 이 재분석 및 재 컴파일은 기본적으로 스키마 변경 후에 발생하는 동일한 조치입니다. 쿼리 플래너가 LIKE 또는 GLOB 연산자의 오른쪽에 바인드 된 새 값을 검사하고 위에서 설명한 최적화를 사용할지 여부를 판별 할 수 있도록 재 컴파일이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7aca89c620a18b6fdc63e568bea908a626dcadff" translate="yes" xml:space="preserve">
          <source>Note that when type conversions occur, pointers returned by prior calls to sqlite3_column_blob(), sqlite3_column_text(), and/or sqlite3_column_text16() may be invalidated. Type conversions and pointer invalidations might occur in the following cases:</source>
          <target state="translated">유형 변환이 발생하면 sqlite3_column_blob (), sqlite3_column_text () 및 / 또는 sqlite3_column_text16 ()에 대한 이전 호출에서 반환 된 포인터가 무효화 될 수 있습니다. 다음과 같은 경우 유형 변환 및 포인터 무효화가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1368e4859dec1f8b656ae1f17b0c284cfecc238a" translate="yes" xml:space="preserve">
          <source>Note that with &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to NORMAL, the checkpoint is the only operation to issue an I/O barrier or sync operation (fsync() on unix or FlushFileBuffers() on windows). If an application therefore runs checkpoint in a separate thread or process, the main thread or process that is doing database queries and updates will never block on a sync operation. This helps to prevent &quot;latch-up&quot; in applications running on a busy disk drive. The downside to this configuration is that transactions are no longer durable and might rollback following a power failure or hard reset.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; NORMAL으로 설정된 체크 포인트 (윈도우 나 UNIX FlushFileBuffers (ON으로 fsync ()))가 I / O 또는 장벽 동기화 작업을 실행하는 경우에만 동작한다. 따라서 응용 프로그램이 별도의 스레드 또는 프로세스에서 검사 점을 실행하는 경우 데이터베이스 쿼리 및 업데이트를 수행하는 기본 스레드 또는 프로세스는 동기화 작업에서 절대 차단되지 않습니다. 이렇게하면 사용중인 디스크 드라이브에서 실행중인 응용 프로그램에서 &quot;래치 업&quot;을 방지 할 수 있습니다. 이 구성의 단점은 트랜잭션이 더 이상 지속되지 않으며 정전 또는 하드 리셋 후에 롤백 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8da0c032621fbb18df4dc03aaa124440bc316a57" translate="yes" xml:space="preserve">
          <source>Note that with ANALYZE the cost estimates are better aligned with reality and algorithm-1 is selected by both NN and N3.</source>
          <target state="translated">ANALYZE를 사용하면 비용 추정치가 현실에 더 잘 맞고 알고리즘 -1이 NN과 N3에 의해 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="695e607ef01e6db075031ffa227e23ca60904541" translate="yes" xml:space="preserve">
          <source>Note that xBestIndex will always be called before &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt;, since the idxNum and idxStr outputs from xBestIndex are required inputs to xFilter. However, there is no guarantee that xFilter will be called following a successful xBestIndex.</source>
          <target state="translated">xBestIndex 의 idxNum 및 idxStr 출력은 xFilter에 대한 입력이 필요하므로 xBestIndex는 항상 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 전에 호출 됩니다. 그러나 성공적인 xBestIndex에 따라 xFilter가 호출된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="d227a38478007bafe1c5681fa0c0259f1628a846" translate="yes" xml:space="preserve">
          <source>Note the &quot;temp.&quot; qualifier before the virtual table name (&quot;stat&quot;). This qualifier causes the virtual table to be temporary - to only exist for the duration of the current database connection. This is the recommended approach.</source>
          <target state="translated">&quot;임시&quot;에 주목하십시오. 가상 테이블 이름 앞의 한정자 ( &quot;stat&quot;) 이 규정자는 가상 테이블을 임시로 만듭니다. 현재 데이터베이스 연결 기간 동안 만 존재합니다. 이것이 권장되는 접근법입니다.</target>
        </trans-unit>
        <trans-unit id="984a9d35869a9cec59e40e09a2d60d76afb99304" translate="yes" xml:space="preserve">
          <source>Note the last bullet in particular. The destructor X in sqlite3_set_auxdata(C,N,P,X) might be called immediately, before the sqlite3_set_auxdata() interface even returns. Hence sqlite3_set_auxdata() should be called near the end of the function implementation and the function implementation should not make any use of P after sqlite3_set_auxdata() has been called.</source>
          <target state="translated">특히 마지막 글 머리 기호에 유의하십시오. sqlite3_set_auxdata () 인터페이스가 반환되기 전에 sqlite3_set_auxdata (C, N, P, X)의 소멸자 X가 즉시 호출 될 수 있습니다. 따라서 sqlite3_set_auxdata ()는 함수 구현의 끝 부분에서 호출되어야하며 sqlite3_set_auxdata ()가 호출 된 후 함수 구현은 P를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="be13ad345e0dba5ca596ce6f7266fdf09fc32236" translate="yes" xml:space="preserve">
          <source>Note the use of the &lt;a href=&quot;lang_corefunc#quote&quot;&gt;quote() SQL function&lt;/a&gt; in these triggers. The quote() function converts its argument into a form that is appropriate for inclusion in an SQL statement. Numeric values come through unchanged. Single quotes are added before and after strings and any internal single quotes are escaped. BLOB values are rendered using SQL-standard hexadecimal BLOB notation. The use of the quote() function ensures that the SQL statements used to undo and redo are always safe from SQL injection.</source>
          <target state="translated">의 사용에주의 &lt;a href=&quot;lang_corefunc#quote&quot;&gt;따옴표 () SQL 기능&lt;/a&gt; 이 트리거에 있습니다. quote () 함수는 인수를 SQL 문에 포함하기에 적합한 형식으로 변환합니다. 숫자 값은 변경되지 않습니다. 작은 따옴표는 문자열 앞뒤에 추가되고 내부 작은 따옴표는 이스케이프됩니다. BLOB 값은 SQL 표준 16 진 BLOB 표기법을 사용하여 렌더링됩니다. quote () 함수를 사용하면 실행 취소 및 재실행에 사용 된 SQL 문이 항상 SQL 삽입으로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="044b3a09040052b2232feb80c6848441318257d4" translate="yes" xml:space="preserve">
          <source>Note the warnings on the &quot;estimatedRows&quot;, &quot;idxFlags&quot;, and colUsed fields. These fields were added with SQLite versions 3.8.2, 3.9.0, and 3.10.0, respectively. Any extension that reads or writes these fields must first check that the version of the SQLite library in use is greater than or equal to appropriate version - perhaps comparing the value returned from &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt; against constants 3008002, 3009000, and/or 3010000. The result of attempting to access these fields in an sqlite3_index_info structure created by an older version of SQLite are undefined.</source>
          <target state="translated">&quot;estimatedRows&quot;, &quot;idxFlags&quot;및 colUsed 필드의 경고에 유의하십시오. 이 필드에는 각각 SQLite 버전 3.8.2, 3.9.0 및 3.10.0이 추가되었습니다. 이러한 필드를 읽거나 쓰는 확장은 먼저 사용중인 SQLite 라이브러리의 버전이 적절한 버전 이상인지 확인해야합니다. &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; 에서 반환 된 값 을 상수 3008002, 3009000 및 / 또는 3010000과 비교할 수 있습니다. 이전 버전의 SQLite에 의해 작성된 sqlite3_index_info 구조에서 이러한 필드에 액세스하려는 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49bc1f28a1c9c886ae8bd63cbcbb27c797246229" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;capi3ref&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;capi3ref&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">참고 : &quot; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &quot; 로 표시된 기능 은 &lt;a href=&quot;capi3ref&quot;&gt;실험용&lt;/a&gt; 이며 이름이 &lt;s&gt;잘린&lt;/s&gt; 기능 은 &lt;a href=&quot;capi3ref&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="66ee76f5066068620f09c7e62f4bb8c158c87cf7" translate="yes" xml:space="preserve">
          <source>Note: Functions marked with &quot;&lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt;&quot; are &lt;a href=&quot;experimental&quot;&gt;experimental&lt;/a&gt; and functions whose names are &lt;s&gt;struck through&lt;/s&gt; are &lt;a href=&quot;experimental&quot;&gt;deprecated&lt;/a&gt;.</source>
          <target state="translated">참고 : &quot; &lt;small&gt;&lt;i&gt;(exp)&lt;/i&gt;&lt;/small&gt; &quot; 로 표시된 기능 은 &lt;a href=&quot;experimental&quot;&gt;실험용&lt;/a&gt; 이며 이름이 &lt;s&gt;잘린&lt;/s&gt; 기능 은 &lt;a href=&quot;experimental&quot;&gt;더 이상 사용되지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03b148e28fde4df0887542e9d88b598d5e8f42db" translate="yes" xml:space="preserve">
          <source>Note: Sections 2.0 and 3.0 of this article were added in response to comments on &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; and &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt;.</source>
          <target state="translated">참고 :이 기사의 섹션 2.0 및 3.0은 &lt;a href=&quot;https://news.ycombinator.com/item?id=16585120&quot;&gt;Hacker News&lt;/a&gt; 및 &lt;a href=&quot;https://www.reddit.com/r/programming/comments/84fzoc/why_is_sqlite_coded_in_c/&quot;&gt;Reddit&lt;/a&gt; 에 대한 의견에 따라 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="85e051b1f236f895d99d48916ab5fd667388aec3" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">참고 :이 방법은 MacOS X 10.7 및 iOS 버전 5.0에서 비활성화되어 있으며 항상 SQLITE_MISUSE를 반환합니다. 이러한 시스템에서 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 통해 데이터베이스 당 연결을 공유 캐시 모드로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ddf57deb38e4651cb3981116d2b9ec03a6feb885" translate="yes" xml:space="preserve">
          <source>Note: This method is disabled on MacOS X 10.7 and iOS version 5.0 and will always return SQLITE_MISUSE. On those systems, shared cache mode should be enabled per-database connection via &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; with &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt;.</source>
          <target state="translated">참고 :이 방법은 MacOS X 10.7 및 iOS 버전 5.0에서 비활성화되어 있으며 항상 SQLITE_MISUSE를 반환합니다. 이러한 시스템에서 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 를 사용하여 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 를 통해 데이터베이스 당 연결을 공유 캐시 모드로 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="b7c62ae6be1885d1c5a81f6a7886c67b36419ed4" translate="yes" xml:space="preserve">
          <source>Notes on the &lt;a href=&quot;optoverview&quot;&gt;query optimizer&lt;/a&gt;.</source>
          <target state="translated">상의주의 사항 &lt;a href=&quot;optoverview&quot;&gt;쿼리 최적화&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="bb5c89c5cb4409cab6ee44d716c6d95feaaddc62" translate="yes" xml:space="preserve">
          <source>Notice how the LIKE operator is implemented. It is a user-defined function in SQLite, so the address of its function definition is specified in P3. The operand P1 is the number of function arguments for it to take from the stack. In this case the LIKE() function takes 2 arguments. The arguments are taken off the stack in reverse order (right-to-left), so the pattern to match is the top stack element, and the next element is the data to compare. The return value is pushed onto the stack.</source>
          <target state="translated">LIKE 연산자가 어떻게 구현되는지 확인하십시오. SQLite에서는 사용자 정의 함수이므로 함수 정의 주소는 P3에 지정되어 있습니다. 피연산자 P1은 스택에서 가져 오는 함수 인수의 수입니다. 이 경우 LIKE () 함수는 2 개의 인수를 갖습니다. 인수는 스택에서 역순으로 (오른쪽에서 왼쪽으로) 제거되므로 일치하는 패턴이 맨 위 스택 요소이고 다음 요소는 비교할 데이터입니다. 반환 값이 스택으로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="5255c6a9b36d606aac6af8d3dbbceadb0d1f9b02" translate="yes" xml:space="preserve">
          <source>Notice how the query above works: The R*Tree index runs in the outer loop to find entries that are contained within the bounding box of longitude -81..-79.6 and latitude 35.0..36.2. For each object identifier found, SQLite looks up the corresponding entry in the demo_data table. It then uses the boundary field from the demo_data table as a parameter to the contained_in() function and if that function returns true, the objname field from the demo_data table is returned as the next row of query result.</source>
          <target state="translated">위의 쿼리 작동 방식에 주목하십시오. R * Tree 색인은 외부 루프에서 실행되어 경도 -81 ..- 79.6 및 위도 35.0..36.2의 경계 상자 내에 포함 된 항목을 찾습니다. 발견 된 각 오브젝트 ID에 대해 SQLite는 demo_data 테이블에서 해당 항목을 찾습니다. 그런 다음 demo_data 테이블의 경계 필드를 contains_in () 함수에 대한 매개 변수로 사용하고 해당 함수가 true를 반환하면 demo_data 테이블의 objname 필드가 쿼리 결과의 다음 행으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b7384e004cca4a56bb485375c44be1a10c5774f" translate="yes" xml:space="preserve">
          <source>Notice that all other date and time functions can be expressed in terms of strftime():</source>
          <target state="translated">다른 모든 날짜 및 시간 함수는 strftime ()으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0897fe8cedb04900939c7986a4c19ddb9b29972" translate="yes" xml:space="preserve">
          <source>Notice that dividing up the content into smaller pieces using an SQLite table gives flexibility to the implementation. The application can choose to read all content into memory at startup. Or it can read just a few pages into memory and keep the rest on disk. Or it can read just single page into memory at a time. And different versions of the application can make different choices without having to make any changes to the file format. Such options are not available when all content is in a single big XML file in a ZIP archive.</source>
          <target state="translated">SQLite 테이블을 사용하여 내용을 더 작은 조각으로 나누면 구현에 유연성이 제공됩니다. 응용 프로그램은 시작할 때 모든 내용을 메모리로 읽도록 선택할 수 있습니다. 또는 몇 페이지를 메모리로 읽어서 나머지는 디스크에 보관할 수 있습니다. 또는 한 번에 한 페이지 만 메모리로 읽을 수 있습니다. 또한 응용 프로그램의 버전에 따라 파일 형식을 변경하지 않고도 다른 방법을 선택할 수 있습니다. 모든 컨텐츠가 ZIP 아카이브에서 하나의 큰 XML 파일에있는 경우 이러한 옵션을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b6637336242d861c3d1aedafa06202a9a576add" translate="yes" xml:space="preserve">
          <source>Notice that the &quot;host&quot; value for the &quot;dummy&quot; record is NULL so the result[] array contains a NULL pointer at that slot.</source>
          <target state="translated">&quot;더미&quot;레코드의 &quot;호스트&quot;값이 NULL이므로 result [] 배열에 해당 슬롯의 NULL 포인터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81da02d10ebbcf526492f91d32dd8afa2884d608" translate="yes" xml:space="preserve">
          <source>Notice that the parameters to functions are now pointers to sqlite3_value structures instead of pointers to strings as in SQLite version 2.X. The following routines are used to extract useful information from these &quot;values&quot;:</source>
          <target state="translated">함수에 대한 매개 변수는 이제 SQLite 버전 2.X에서와 같이 문자열에 대한 포인터 대신 sqlite3_value 구조에 대한 포인터입니다. 이러한 &quot;값&quot;에서 유용한 정보를 추출하는 데 다음 루틴이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="45ef496d245754f1f4daa860e31545d9feaf1aea" translate="yes" xml:space="preserve">
          <source>Notice that the shared lock is on the operating system disk cache, not on the disk itself. File locks really are just flags within the operating system kernel, usually. (The details depend on the specific OS layer interface.) Hence, the lock will instantly vanish if the operating system crashes or if there is a power loss. It is usually also the case that the lock will vanish if the process that created the lock exits.</source>
          <target state="translated">공유 잠금은 디스크 자체가 아닌 운영 체제 디스크 캐시에 있습니다. 파일 잠금은 실제로 운영 체제 커널 내의 플래그 일뿐입니다. (자세한 내용은 특정 OS 계층 인터페이스에 따라 다릅니다.) 따라서 운영 체제 충돌 또는 전원 손실이 발생하면 잠금이 즉시 사라집니다. 일반적으로 잠금을 작성한 프로세스가 종료되면 잠금이 사라지는 경우도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8f4b80268c40011630e5371241e6ab982124215" translate="yes" xml:space="preserve">
          <source>Notice that the tokens in the result set from the fts3tokenize virtual table have been transformed according to the rules of the tokenizer. Since this example used the &quot;porter&quot; tokenizer, the &quot;This&quot; token was converted into &quot;thi&quot;. If the original text of the token is desired, it can be retrieved using the &quot;start&quot; and &quot;end&quot; columns with the &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt; function. For example:</source>
          <target state="translated">fts3tokenize 가상 테이블의 결과 세트에있는 토큰은 토크 나이저 규칙에 따라 변환되었습니다. 이 예에서는 &quot;porter&quot;토크 나이저를 사용 했으므로 &quot;This&quot;토큰은 &quot;thi&quot;로 변환되었습니다. 토큰의 원본 텍스트가 필요한 경우 &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; 함수 와 함께 &quot;start&quot;및 &quot;end&quot;열을 사용하여 검색 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af54971d34d4b499061179fcac4a7f0e1fee4c0f" translate="yes" xml:space="preserve">
          <source>Notice the similarity between the ListRead and Next instructions. Both operations work according to this rule:</source>
          <target state="translated">ListRead와 Next 명령어의 유사성을 주목하십시오. 두 작업 모두이 규칙에 따라 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7cec2e96076ffe89a48a9bb0d641ff84dbe2e0a2" translate="yes" xml:space="preserve">
          <source>Notice too that there is a tradeoff between average read performance and average write performance. To maximize the read performance, one wants to keep the WAL as small as possible and hence run checkpoints frequently, perhaps as often as every COMMIT. To maximize write performance, one wants to amortize the cost of each checkpoint over as many writes as possible, meaning that one wants to run checkpoints infrequently and let the WAL grow as large as possible before each checkpoint. The decision of how often to run checkpoints may therefore vary from one application to another depending on the relative read and write performance requirements of the application. The default strategy is to run a checkpoint once the WAL reaches 1000 pages and this strategy seems to work well in test applications on workstations, but other strategies might work better on different platforms or for different workloads.</source>
          <target state="translated">평균 읽기 성능과 평균 쓰기 성능 간에는 상충 관계가 있습니다. 읽기 성능을 최대화하기 위해 WAL을 가능한 한 작게 유지하고 따라서 모든 COMMIT만큼 자주 체크 포인트를 자주 실행하려고합니다. 쓰기 성능을 최대화하기 위해 가능한 한 많은 쓰기에 대해 각 검사 점의 비용을 상각하려고합니다. 즉, 검사 점을 자주 실행하지 않고 각 검사 점 전에 WAL을 최대한 크게 늘리기를 원합니다. 따라서 검사 점을 실행하는 빈도는 응용 프로그램의 상대적 읽기 및 쓰기 성능 요구 사항에 따라 응용 프로그램마다 다를 수 있습니다. 기본 전략은 WAL이 1000 페이지에 도달하면 검사 점을 실행하는 것이며이 전략은 워크 스테이션의 테스트 응용 프로그램에서 잘 작동하는 것 같습니다.그러나 다른 전략은 다른 플랫폼이나 다른 워크로드에서 더 잘 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d969bb722b85b5d0915700d40ff32bef3f77944d" translate="yes" xml:space="preserve">
          <source>Now compiles on MSVC++6 again</source>
          <target state="translated">이제 MSVC ++ 6에서 다시 컴파일</target>
        </trans-unit>
        <trans-unit id="6c31ef81ebda278449acfecbdc59bc58b62b9f81" translate="yes" xml:space="preserve">
          <source>Now compiles on Solaris and OpenBSD and other Unix variants that lack the fdatasync() function</source>
          <target state="translated">이제 fdatasync () 함수가없는 Solaris 및 OpenBSD 및 기타 Unix 변형에서 컴파일</target>
        </trans-unit>
        <trans-unit id="d8eeae1a57da5c7c1fc46f998bfb914d868defe3" translate="yes" xml:space="preserve">
          <source>Now consider a query to find the names of everyone in the organization that is 180cm tall or taller:</source>
          <target state="translated">이제 키가 180cm 이상인 조직의 모든 사람의 이름을 찾기위한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cace99b617f1285adb8e73b73b38a21bf398149e" translate="yes" xml:space="preserve">
          <source>Now consider the case where M and N are both 3500. Alice nodes are abundant. But suppose each of these nodes is connected by only one or two edges. In this case, option 2 is preferred. With option 2, the outer loop still has to run 3500 times, but the middle loop only runs once or twice for each outer loop and the inner loop will only run once for each middle loop, if at all. So the total number of iterations of the inner loop is around 7000. Option 1, on the other hand, has to run both its outer loop and its middle loop 3500 times each, resulting in 12 million iterations of the middle loop. Thus in the second scenario, option 2 is nearly 2000 times faster than option 1.</source>
          <target state="translated">이제 M과 N이 모두 3500 인 경우를 고려하십시오. Alice 노드는 풍부합니다. 그러나 이러한 각 노드가 하나 또는 두 개의 모서리로만 연결되어 있다고 가정하십시오. 이 경우 옵션 2가 선호됩니다. 옵션 2를 사용하면 외부 루프는 여전히 3500 번 실행되어야하지만 중간 루프는 각 외부 루프에 대해 한두 번만 실행되며 내부 루프는 각 중간 루프에 대해 한 번만 실행됩니다. 따라서 내부 루프의 총 반복 횟수는 약 7000입니다. 반면에 옵션 1은 외부 루프와 중간 루프를 각각 3500 번 실행해야하므로 중간 루프의 1200 만 반복이 발생합니다. 따라서 두 번째 시나리오에서 옵션 2는 옵션 1보다 거의 2000 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ddfe6464a41b67622d5429681d09c2e30ec73502" translate="yes" xml:space="preserve">
          <source>Now it is time to make the private, custom modifications to SQLite which are the whole point of this exercise. Switch to the private branch (if you are not already there) using the &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; command, then bring up the source files in your text editor and make whatever changes you want to make. Once you have finished making changes, commit those changes using this command:</source>
          <target state="translated">이제이 연습의 요점 인 SQLite에 대한 개인 사용자 정의 수정을 할 차례입니다. &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;명령을 사용하여 개인 브랜치 (아직없는 경우)로 전환 한 다음 텍스트 편집기에서 소스 파일을 불러오고 원하는대로 변경하십시오. 변경을 완료하면 다음 명령을 사용하여 해당 변경을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="421feb72f2bd97fb759d08871988b6f039784dca" translate="yes" xml:space="preserve">
          <source>Now let's look at how this index will be used. Consider the following query:</source>
          <target state="translated">이제이 인덱스가 어떻게 사용되는지 봅시다. 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="470c0db4772f894a123be1434e95e5d5a6304ade" translate="yes" xml:space="preserve">
          <source>Now suppose the user.phone field contains plain text if the user has only a single phone number and a JSON array if the user has multiple phone numbers. The same question is posed: &quot;Which users have a phone number in the 704 area code?&quot; But now the json_each() function can only be called for those users that have two or more phone numbers since json_each() requires well-formed JSON as its first argument:</source>
          <target state="translated">이제 사용자에게 전화 번호가 하나만 있으면 user.phone 필드에 일반 텍스트가 있고 전화 번호가 여러 개인 경우 JSON 배열이 있다고 가정하십시오. 같은 질문이 있습니다 : &quot;어떤 사용자가 704 지역 코드에 전화 번호를 가지고 있습니까?&quot; 그러나 json_each () 함수는 첫 번째 인수로 올바른 형식의 JSON이 필요하므로 전화 번호가 두 개 이상인 사용자에 대해서만 json_each () 함수를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f22ea5fd82bf1b044f7951c4c771bd645f73f8d1" translate="yes" xml:space="preserve">
          <source>Now that the public and private branches are different, you can run the &quot;&lt;code&gt;fossil update trunk&lt;/code&gt;&quot; and &quot;&lt;code&gt;fossil update private&lt;/code&gt;&quot; commands and see that fossil really does change the files in the checkout as you switch back and forth between branches.</source>
          <target state="translated">공개 및 개인 분기가 다르므로 &quot; &lt;code&gt;fossil update trunk&lt;/code&gt; &quot;및 &quot; &lt;code&gt;fossil update private&lt;/code&gt; &quot;명령을 실행하면 분기간에 전환 할 때 화석이 체크 아웃에서 파일을 실제로 변경한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="109085beaaa80ac89858b283a64f7c75d7e5bb12" translate="yes" xml:space="preserve">
          <source>Null</source>
          <target state="translated">Null</target>
        </trans-unit>
        <trans-unit id="5b7d454836a77f93829b713b5a5d0e3045934959" translate="yes" xml:space="preserve">
          <source>Null-indicator is an optional string that indicates a column value is null. The default is an empty string. Note that column-separator and null-indicator are optional positional arguments; if null-indicator is specified, a column-separator argument must be specified and precede the null-indicator argument.</source>
          <target state="translated">널 (NULL) 표시기는 열 값이 널임을 나타내는 선택적 문자열입니다. 기본값은 빈 문자열입니다. 열 분리 자 및 널 (NULL) 표시기는 선택적 위치 인수입니다. 널 (NULL) 표시기가 지정된 경우 열 분리 자 인수를 지정하고 널 (NULL) 표시기 인수 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="a37aacd80c708abde1a03c3d5afe5b13fd00cfc3" translate="yes" xml:space="preserve">
          <source>NullRow</source>
          <target state="translated">NullRow</target>
        </trans-unit>
        <trans-unit id="eb0f5a21c19313cdefd12cf556538964ec1b60c1" translate="yes" xml:space="preserve">
          <source>Number Of Columns In A Result Set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="29a85c89c3b665d61a62026778cb1a84d89e00ac" translate="yes" xml:space="preserve">
          <source>Number Of SQL Parameters</source>
          <target state="translated">SQL 매개 변수 수</target>
        </trans-unit>
        <trans-unit id="a780fc260fcaca2d5e967db2577edefc7720d5d2" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have already been backfilled into the database by prior checkpoints</source>
          <target state="translated">이전 체크 포인트에 의해 데이터베이스에 이미 백필 된 WAL 프레임 수</target>
        </trans-unit>
        <trans-unit id="2a37475de2d92c9f14f2ea5c38819cea5766eaa7" translate="yes" xml:space="preserve">
          <source>Number of WAL frames that have attempted to be backfilled but which might not have been backfilled successfully.</source>
          <target state="translated">백업을 시도했지만 성공적으로 백업하지 못한 WAL 프레임 수입니다.</target>
        </trans-unit>
        <trans-unit id="3b125f191573ae8fecea26a8fd5c1f85866a1737" translate="yes" xml:space="preserve">
          <source>Number of bytes of payload</source>
          <target state="translated">페이로드의 바이트 수</target>
        </trans-unit>
        <trans-unit id="93e4ee2802912bc9542ff03c865140e0975aff48" translate="yes" xml:space="preserve">
          <source>Number of columns in a result set</source>
          <target state="translated">결과 집합의 열 수</target>
        </trans-unit>
        <trans-unit id="2b00ff36e6009d3918fa275ec909bb841ed966c0" translate="yes" xml:space="preserve">
          <source>Number of valid and committed frames in the WAL file.</source>
          <target state="translated">WAL 파일에서 유효하고 커밋 된 프레임 수</target>
        </trans-unit>
        <trans-unit id="ff84d5af979f34eb1211b7993c06c6a08d3a99e3" translate="yes" xml:space="preserve">
          <source>Number-of-pages</source>
          <target state="translated">Number-of-pages</target>
        </trans-unit>
        <trans-unit id="2f32b7f17e88cd173c751d8cdc7e8c19cbcaed9f" translate="yes" xml:space="preserve">
          <source>Numeric and text types make a difference for the DISTINCT keyword too:</source>
          <target state="translated">숫자 및 텍스트 유형은 DISTINCT 키워드에서도 차이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c37c2e33a0fa0b90c0fc1ac3254fa39cce3fa242" translate="yes" xml:space="preserve">
          <source>Numeric values (serial types 1 through 9) sort after NULLs and in numeric order.</source>
          <target state="translated">숫자 값 (직렬 유형 1-9)은 NULL 이후와 숫자 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="16bebfa71033ff1ade58c6f0e6b14f281dfaba25" translate="yes" xml:space="preserve">
          <source>Numeric values sort next in numerical order</source>
          <target state="translated">숫자 값은 다음 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="0f5fd79254e55ff1fbee2cde5598536b3ec7dea6" translate="yes" xml:space="preserve">
          <source>Numerous bug fixes and documentation updates.</source>
          <target state="translated">수많은 버그 수정 및 설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="dc11c061204c46d3ddd7e450955d3893423efff5" translate="yes" xml:space="preserve">
          <source>Numerous code optimizations, specially optimizations designed to make the code footprint smaller.</source>
          <target state="translated">수많은 코드 최적화, 특히 코드 풋 프린트를 더 작게 만들도록 설계된 최적화.</target>
        </trans-unit>
        <trans-unit id="1608a6f49ab43b4c01022e79721183478aa81607" translate="yes" xml:space="preserve">
          <source>Numerous minor bug fixes</source>
          <target state="translated">수많은 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="59f5ab25bf1e5a211679172dc18a637343443a9e" translate="yes" xml:space="preserve">
          <source>Numerous other performance enhancements</source>
          <target state="translated">수많은 다른 성능 향상</target>
        </trans-unit>
        <trans-unit id="957b6bbcded8f49f8684b4d5e7a64d7f3a67b7a1" translate="yes" xml:space="preserve">
          <source>OCELOT</source>
          <target state="translated">OCELOT</target>
        </trans-unit>
        <trans-unit id="7481b4b2758d96d6c2ef2af6709c88460dc01560" translate="yes" xml:space="preserve">
          <source>ODP - The Open Document presentation format used by OpenOffice and others</source>
          <target state="translated">ODP-OpenOffice 및 기타 사람들이 사용하는 Open Document 프레젠테이션 형식</target>
        </trans-unit>
        <trans-unit id="2a2888f26efa625ef4871988ca874037d8ea156c" translate="yes" xml:space="preserve">
          <source>ODT - The Open Document format used by OpenOffice and others</source>
          <target state="translated">ODT-OpenOffice 및 기타 사람들이 사용하는 공개 문서 형식</target>
        </trans-unit>
        <trans-unit id="0cf81c47abad8b8dc52569f7edcc1b5b2d3511f9" translate="yes" xml:space="preserve">
          <source>OF</source>
          <target state="translated">OF</target>
        </trans-unit>
        <trans-unit id="acd2081fe0965992b6934d49ae30eed38ac749e0" translate="yes" xml:space="preserve">
          <source>OFFSET</source>
          <target state="translated">OFFSET</target>
        </trans-unit>
        <trans-unit id="4f963961751f0891a23f93bba4882f74f0ade805" translate="yes" xml:space="preserve">
          <source>OFFSET clause ignored on queries without a FROM clause. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</source>
          <target state="translated">FROM 절이없는 쿼리에서는 OFFSET 절이 무시되었습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/07d6a0453d&quot;&gt;07d6a0453d&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80f83fb7443c61c317b946841f59c0be3182f095" translate="yes" xml:space="preserve">
          <source>OFFSET gives the correct answer. However, OFFSET requires time proportional to the offset value. What really happens with &quot;LIMIT x OFFSET y&quot; is that SQLite computes the query as &quot;LIMIT x+y&quot; and discards the first y values without returning them to the application. So as the window scrolls down toward the bottom of a long list, and the y value becomes larger and larger, successive offset computations take more and more time.</source>
          <target state="translated">OFFSET은 정답을 제공합니다. 그러나 OFFSET에는 오프셋 값에 비례하는 시간이 필요합니다. &quot;LIMIT x OFFSET y&quot;에서 실제로 발생하는 일은 SQLite가 쿼리를 &quot;LIMIT x + y&quot;로 계산하고 첫 번째 y 값을 애플리케이션으로 리턴하지 않고 버리는 것입니다. 따라서 창이 긴 목록의 맨 아래로 스크롤되고 y 값이 점점 커짐에 따라 연속 오프셋 계산에 점점 더 많은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9c108e42d4ae43fd2c4c857619aacef018184aee" translate="yes" xml:space="preserve">
          <source>OLD references are valid</source>
          <target state="translated">OLD 참조가 유효합니다</target>
        </trans-unit>
        <trans-unit id="387d7a59dbaaef002e0f9ac69ecd4443b9c5cef2" translate="yes" xml:space="preserve">
          <source>ON</source>
          <target state="translated">ON</target>
        </trans-unit>
        <trans-unit id="32bb503cc80e713ad933b48ce9053610aae7664e" translate="yes" xml:space="preserve">
          <source>ON CONFLICT clause</source>
          <target state="translated">ON CONFLICT 절</target>
        </trans-unit>
        <trans-unit id="c13d037157d8eb7ac7ee7af0a3380941dabf2fa2" translate="yes" xml:space="preserve">
          <source>OOM testing is accomplished by simulating OOM errors. SQLite allows an application to substitute an alternative malloc() implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt;,...) interface. The TCL and TH3 test harnesses are both capable of inserting a modified version of malloc() that can be rigged to fail after a certain number of allocations. These instrumented mallocs can be set to fail only once and then start working again, or to continue failing after the first failure. OOM tests are done in a loop. On the first iteration of the loop, the instrumented malloc is rigged to fail on the first allocation. Then some SQLite operation is carried out and checks are done to make sure SQLite handled the OOM error correctly. Then the time-to-failure counter on the instrumented malloc is increased by one and the test is repeated. The loop continues until the entire operation runs to completion without ever encountering a simulated OOM failure. Tests like this are run twice, once with the instrumented malloc set to fail only once, and again with the instrumented malloc set to fail continuously after the first failure.</source>
          <target state="translated">OOM 테스트는 OOM 오류를 시뮬레이션하여 수행됩니다. SQLite는 애플리케이션이 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC를&lt;/a&gt; 사용하여 대체 malloc () 구현을 대체 할 수 있도록합니다.,...) 상호 작용. TCL 및 TH3 테스트 하네스는 둘 다 특정 수의 할당 후에 실패하도록 조작 할 수있는 수정 된 malloc () 버전을 삽입 할 수 있습니다. 이러한 계측 된 malloc은 한 번만 실패한 다음 다시 작업을 시작하거나 첫 번째 실패 후에도 계속 실패하도록 설정할 수 있습니다. OOM 테스트는 루프에서 수행됩니다. 루프의 첫 번째 반복에서 계측 된 malloc은 첫 번째 할당에서 실패하도록 조작됩니다. 그런 다음 일부 SQLite 작업이 수행되고 SQLite가 OOM 오류를 올바르게 처리했는지 확인합니다. 그런 다음 계측 된 malloc의 실패 시간 카운터가 1 씩 증가하고 테스트가 반복됩니다. 루프는 시뮬레이션 된 OOM 오류가 발생하지 않고 전체 작업이 완료 될 때까지 계속됩니다. 이와 같은 테스트는 두 번 실행됩니다.계측 된 malloc이 한 번만 실패로 설정되고 계측 된 malloc이 첫 번째 실패 후에 지속적으로 실패한 상태로 다시 한 번.</target>
        </trans-unit>
        <trans-unit id="f579c523960af1aec824c6fdc57af6d4abd76a1f" translate="yes" xml:space="preserve">
          <source>OR</source>
          <target state="translated">OR</target>
        </trans-unit>
        <trans-unit id="683e61c81d390d130002106c2c28e827414b7056" translate="yes" xml:space="preserve">
          <source>ORDER</source>
          <target state="translated">ORDER</target>
        </trans-unit>
        <trans-unit id="2164bde64d5e67a9aad0e7c0543250365dc40e72" translate="yes" xml:space="preserve">
          <source>ORDER BY</source>
          <target state="translated">주문</target>
        </trans-unit>
        <trans-unit id="e4ec6dd8b3c32fb2c490ae23010139de3ea19166" translate="yes" xml:space="preserve">
          <source>ORDER BY and GROUP BY now use bounded memory</source>
          <target state="translated">ORDER BY 및 GROUP BY는 이제 경계 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9252c387c5a364e0aa75e161fd6ca4b31550d60" translate="yes" xml:space="preserve">
          <source>ORDER BY ignored if the query has an identical GROUP BY. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;b75a9ca6b0&lt;/a&gt;</source>
          <target state="translated">쿼리에 동일한 GROUP BY가 있으면 ORDER BY가 무시됩니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/b75a9ca6b0499&quot;&gt;B75A9CA6B0&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d00407a3fb0d8ad7b8bcf4535e5d986d53520d0" translate="yes" xml:space="preserve">
          <source>ORDER BY works on subselects</source>
          <target state="translated">ORDER BY는 하위 선택에서 작동합니다</target>
        </trans-unit>
        <trans-unit id="fb1eb08d2d3f0a79b8449be8ce9ee77050e088a5" translate="yes" xml:space="preserve">
          <source>OS Interface</source>
          <target state="translated">OS 인터페이스</target>
        </trans-unit>
        <trans-unit id="7ea1a5ba1dffba576fe0a188bb466f1a65ef5c2d" translate="yes" xml:space="preserve">
          <source>OS Interface File Virtual Methods Object</source>
          <target state="translated">OS 인터페이스 파일 가상 메소드 오브젝트</target>
        </trans-unit>
        <trans-unit id="2fdd9f0dd04e20b2da0185c9864ac62e0fd49b33" translate="yes" xml:space="preserve">
          <source>OS Interface Object</source>
          <target state="translated">OS 인터페이스 객체</target>
        </trans-unit>
        <trans-unit id="e502b880ac4721322e02bb29b5215f15ab6c97e9" translate="yes" xml:space="preserve">
          <source>OS Interface Open File Handle</source>
          <target state="translated">OS 인터페이스 열린 파일 핸들</target>
        </trans-unit>
        <trans-unit id="dee9889ad644e6e58468f0ff85f3a57aa76cfbd9" translate="yes" xml:space="preserve">
          <source>OTHERS</source>
          <target state="translated">OTHERS</target>
        </trans-unit>
        <trans-unit id="a032f6607e24aa99492871d19a553d714048e163" translate="yes" xml:space="preserve">
          <source>OUTER</source>
          <target state="translated">OUTER</target>
        </trans-unit>
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">비록 그들이 (하나님이 금지 한) 그들이 &quot;그들의 말을하라.</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">객체 지향 디자인</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">객체 지향은 프로그래밍 언어가 아닌 디자인 패턴입니다. 어셈블리 언어를 포함하여 원하는 언어로 객체 지향 프로그래밍을 수행 할 수 있습니다. 일부 언어 (예 : C ++ 또는 Java)는 객체 지향을 더 쉽게 만듭니다. 그러나 C와 같은 언어로 여전히 객체 지향 프로그래밍을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">객체 지향 만이 유효한 디자인 패턴은 아닙니다. 많은 프로그래머들이 객체에 대해서만 순수하게 생각하도록 배웠습니다. 그리고 공정하게 말하면, 물체는 종종 문제를 분해하는 좋은 방법입니다. 그러나 객체가 유일한 방법은 아니며 항상 문제를 분해하는 가장 좋은 방법은 아닙니다. 때로는 좋은 오래된 절차 코드가 작성하기 쉽고 유지 관리 및 이해하기 쉽고 객체 지향 코드보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">트리거의 버그 수정 ( &lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt; )이 모호 합니다.</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">사용되지 않는 문서</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">변경 그룹에서 복합 변경 집합 가져 오기</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">집계 함수 컨텍스트 확보</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">변경 세트 반복자에서 충돌하는 행 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">Changeset Iterator에서 현재 작업 가져 오기</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">테이블의 기본 키 정의 얻기</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">URI 매개 변수 값 얻기</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">데이터베이스 파일에서 PENDING 잠금과 EXCLUSIVE 잠금을 확보하십시오. 다른 프로세스에 여전히 SHARED 잠금이있는 경우 기록기는 해당 SHARED 잠금이 지워질 때까지 기다려야 독점 잠금을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">변경 그룹의 현재 내용을 나타내는 변경 세트 (또는 패치 세트)를 포함하는 버퍼를 얻습니다. 변경 그룹에 대한 입력이 변경 세트 인 경우 출력은 변경 세트입니다. 또는 입력이 패치 세트 인 경우 출력도 패치 세트입니다.</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 첨부 된 테이블에 대한 변경 사항이 포함 된 변경 사항 세트를 확보하십시오. 성공하면 SQLITE_OK를 리턴하기 전에 변경 세트를 포함하는 버퍼를 가리키고 * pnChangeset을 변경 세트의 크기를 바이트 단위로 가리 키도록 * ppChangeset을 설정하십시오. 오류가 발생하면 * ppChangeset 및 * pnChangeset을 모두 0으로 설정하고 SQLite 오류 코드를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">특정 테이블에 대한 잠금을 확보하십시오. 이 명령어는 공유 캐시 기능이 활성화 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">데이터베이스 파일에 대한 독점 잠금을 확보하고 위의 1-3 단계 알고리즘을 사용하여 모든 메모리 변경 사항이 데이터베이스 파일에 기록되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">Changeset Iterator에서 새 값을 얻습니다. *</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">구하십시오. * Changeset Iterator에서 값</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">화석에서 최신 SQLite 코드를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">SQL 값 얻기</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">획득</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">뮤텍스를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">때때로 심각한 문제가 발견되고 정기적 인 유지 보수 릴리스에 대해 작은 &quot;패치&quot;릴리스를 작성해야합니다. 패치는 이전 릴리스에서 변경된 코드 줄 수가 매우 작다는 점에서 유지 보수 릴리스와 다릅니다. 유지 보수 릴리스에 버그가 없는지 확인하여 패치 릴리스를 피하기 위해 모든 노력을 기울입니다.</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">물론 ANALYZE는 데이터베이스에 많은 양의 컨텐츠가있는 경우에만 효과적으로 작동합니다. 많은 양의 데이터를 축적 할 것으로 예상되는 새 데이터베이스를 작성할 때 &quot;ANALYZE sqlite_master&quot;명령을 실행하여 SQLITE_STAT1 테이블을 작성한 후 SQLITE_STAT1 테이블 (일반 INSERT 문을 사용하여)을 사용자의 일반적인 데이터베이스를 설명하는 컨텐츠로 미리 채울 수 있습니다. 응용 프로그램-랩에서 잘 구성된 템플릿 데이터베이스에서 ANALYZE를 실행 한 후 추출한 콘텐츠 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">물론 위에 열거 된 4 단계 중 하나를 시도하는 동안 오류가 발생할 수 있습니다. 이런 일이 발생하면</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">물론 일반적인 SQLite 테이블은 정수 기본 키에 대해 효율적으로 쿼리를 수행하므로 이전은 중요하지 않습니다. R * Tree를 사용하는 실제 이유는 좌표 범위에 대해 불평등 쿼리를 효율적으로 수행 할 수 있기 때문입니다. 노스 캐롤라이나 주 샬럿 부근에 포함 된 지수의 모든 요소를 ​​찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">물론, 시스템 복구 후에 존재할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">물론 일반적으로 필요한 모든 변경 사항을 원자 적으로 적용하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">물론 WAL 파일에 추가 된 모든 트랜잭션을 원래 데이터베이스로 다시 전송하려고합니다. WAL 파일 트랜잭션을 데이터베이스로 다시 이동하는 것을 &quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">물론 rowid로 쿼리 출력을 정렬하는 것은 거의 유용하지 않습니다. 일반적으로 다른 열로 출력을 정렬하려고합니다.</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">물론 예제에 표시된 &quot;t1bc&quot;및 &quot;t2&quot;대신 원하는 인덱스 및 임 포스터 테이블 이름을 대체하십시오. &quot;.imposter&quot;명령은 &quot;t1bc&quot;인덱스의 스키마를 읽고 해당 정보를 사용하여 임 포스터 테이블에 대해 호환 가능한 CREATE TABLE 문을 구성한 다음 임시 임 포스터 테이블을 자동으로 작성하는 데 필요한 모든 호출을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">물론 위의 두 쿼리는 완전히 동일하지 않습니다. 예를 들어 LIKE 쿼리는 &quot;linuxophobe&quot;또는 &quot;EnterpriseLinux&quot;와 같은 용어가 포함 된 행과 일치하지만 (Enron 전자 메일 데이터 세트에는 실제로 그러한 용어가 포함되지 않음) FTS3 테이블의 MATCH 쿼리는 해당 용어 만 선택합니다. &quot;linux&quot;를 개별 토큰으로 포함하는 행. 두 검색은 대소 문자를 구분하지 않습니다. FTS3 테이블은 일반 테이블의 경우 1453MB에 비해 디스크에서 약 2006MB를 사용합니다. 위의 SELECT 쿼리를 수행하는 데 사용 된 것과 동일한 하드웨어 구성을 사용하여 FTS3 테이블을 채우는 데 31 분이 채 걸리지 않았습니다 (일반 테이블의 경우 25 분).</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">물론, 마일리지는 하드웨어, 파일 시스템 및 운영 체제에 따라 다를 수 있습니다. 특정 설계를 수행하기 전에 대상 하드웨어에서이 수치를 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">이러한 변경 중 1a 및 2a-2c 만 공식적인 의미에서 비 호환성입니다. 그러나 이전에 SQLite 소스를 사용자 지정하여 수정 한 사용자 (예 : 임베디드 하드웨어에 대한 사용자 지정 OS 계층 추가)는 이러한 변경이 더 큰 영향을 줄 수 있습니다. 한편, 이러한 변경의 중요한 목표는 다른 운영 체제에서 사용하기 위해 SQLite를 훨씬 쉽게 사용자 정의 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">이전 버전의 SQLite는 읽기 전용 인 WAL 모드 데이터베이스를 읽을 수 없습니다. 즉, WAL 모드 데이터베이스를 읽으려면 쓰기 액세스가 필요했습니다. 이 제약은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;버전 3.22.0&lt;/a&gt; (2018-01-22) 부터 완화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">이전 버전의 파이어 버드는 SELECT DISTINCT 및 UNION에서 모든 NULL을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">MSVC 사용자가 쉽게 빌드 할 수 있도록 makefile에서 &quot;awk&quot;를 모두 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">생략 된 매개 변수는 기본값을 사용합니다. STEP의 기본값은 1입니다. END의 기본값은 9223372036854775807입니다. START의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">안드로이드에는 인터넷의 복잡한 구석에서 다운로드 한 신뢰할 수없는 앱에 의해 전달되는 임의의 SQL을 맹목적으로 실행하는 많은 서비스가 있다고 들었습니다. 안드로이드 서비스는 검증되지 않은 소스에서 SQL을 실행하는 것에 대해 더욱 조심해야합니다. 이 저자는 그와 반대되는 구체적인 사례는 없지만, 존재한다는 소문을 들었습니다. 모든 Android 서비스가 더 조심스럽고 실행중인 모든 SQL을 제대로 검사하더라도 안전한지 확인하기 위해 모두 감사하는 것은 어려울 것입니다. 따라서 보안을 염두에 둔 사람들은 임의의 SQL 텍스트를 전달하여 악용 할 수 없도록주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">Linux 및 기타 유닉스 시스템에서는 다음과 같이 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">Win32에서는 존재하지 않는 파일을 삭제하려고 할 때 오류를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">Windows 시스템에서 폴더는 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">MSVC가있는 Windows의 경우 Makefile.msc와 함께 nmake를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">Windows에서 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">(A)에 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 의 WAL 먼저의 xSync 방법하여 영구 저장소에 플러시 &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS를&lt;/a&gt; . 그런 다음 WAL의 유효한 내용이 데이터베이스 파일로 전송됩니다. 마지막으로 데이터베이스는 다른 xSync 메서드 호출을 사용하여 영구 저장소로 플러시됩니다. xSync 작업은 쓰기 장벽 역할을합니다. xSync가 시작된 후 쓰기가 시작되기 전에 xSync가 시작되기 전에 시작된 모든 쓰기가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">인덱스를 사용하는 DISTINCT 쿼리에서 적절한 인덱스를 사용할 수있는 경우 행을 단계별로 실행하지 않고 인덱스를 사용하여 다음 고유 항목으로 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">기존의 회전 디스크에서 섹터는 읽기와 쓰기 모두 양방향의 최소 전송 단위입니다. 그러나 플래시 메모리에서 읽기의 최소 크기는 일반적으로 최소 쓰기보다 훨씬 작습니다. SQLite는 최소 쓰기 양에만 관심이 있으므로이 기사에서는 &quot;섹터&quot;라고 할 때 대용량 저장소에 한 번에 쓸 수있는 최소 데이터 양을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">온 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWID를 또는 INTEGER PRIMARY KEY 열이 명시 적으로 값을 지정하지 않은 경우, 다음은 일반적으로 한 번 더 현재 사용에서 가장 큰 ROWID보다, 사용되지 않는 정수 자동으로 채워집니다. AUTOINCREMENT 키워드 사용 여부에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">제한 조건 점검 순서가 재 배열 될 때 UPSERT에서, 제한 조건 점검 전에 삽입 된 컨텐츠에 대한 선호도 변환이 발생하는지 확인하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">undo :: undo 또는 undo :: redo를 호출 할 때마다 undo / redo 모듈은 모든 최상위 네임 스페이스에서 status_refresh 및 reload_all 메소드를 자동으로 호출합니다. 이러한 메소드는 데이터베이스의 실행 취소 / 다시 실행 변경에 따라 표시를 재구성하거나 프로그램 상태를 업데이트하도록 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">동기 파일 시스템이있는 임베디드 시스템에서 TRUNCATE는 PERSIST보다 동작이 느립니다. 커밋 작업은 동일한 속도입니다. 그러나 후속 트랜잭션은 파일 끝에 추가하는 것보다 기존 내용을 덮어 쓰는 것이 더 빠르기 때문에 TRUNCATE 이후에 더 느립니다. 새 저널 파일 항목은 항상 TRUNCATE 뒤에 추가되지만 일반적으로 PERSIST로 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">대부분의 시스템에서 malloc () 시스템 호출은 8 바이트 경계에 정렬 된 버퍼를 리턴합니다. 그러나 일부 시스템 (예 : windows)에서 malloc ()은 4 바이트 정렬 포인터를 반환합니다. 이 컴파일 타임 옵션은 malloc ()에서 4 바이트 정렬 포인터를 리턴하는 시스템에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">최신 버전의 SQLite에서는 다음 조건 중 하나 이상이 충족되는 한 읽기 전용 미디어의 WAL 모드 데이터베이스 또는 쓰기 권한이없는 WAL 모드 데이터베이스를 계속 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">시작시 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램에 간단한 배너 메시지가 표시되고 SQL을 입력하라는 메시지가 표시됩니다. 세미콜론으로 끝나는 SQL 문을 입력하고 &quot;Enter&quot;를 누르면 SQL이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">시작시 응용 프로그램은 먼저 표시 할 버전을 결정합니다. versionId는 자연스럽게 시간이 증가하고 일반적으로 최신 버전을보고 싶어하므로 적절한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">성공하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴되고 새 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 이 * ppBlob에 저장됩니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴되고 오류 코드가 SQLITE_MISUSE가 아닌 경우 * ppBlob은 NULL로 설정됩니다. 즉, API를 잘못 사용하지 않으면 이 함수가 반환 된 후 * ppBlob에서 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 를 호출하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">성공하면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴되고 새 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 이 * ppBlob에 저장됩니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴되고 오류 코드가 SQLITE_MISUSE가 아닌 경우 * ppBlob은 NULL로 설정됩니다. 즉, API를 잘못 사용하지 않으면 이 함수가 반환 된 후 * ppBlob에서 &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 를 호출하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">성공하면 &lt;b&gt;sqlite_compile&lt;/b&gt; 은 SQLITE_OK를 반환합니다. 그렇지 않으면 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_blob_read ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_blob_read ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">성공하면 sqlite3_blob_write ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다. SQLITE_MISUSE가 리턴되지 않으면이 함수는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 를 통해 액세스 가능한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오류 코드 및 메시지를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">성공하면 sqlite3_blob_write ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다. SQLITE_MISUSE가 리턴되지 않으면이 함수는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 를 통해 액세스 가능한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오류 코드 및 메시지를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_prepare () 루틴 제품군은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다 . 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_prepare () 루틴 제품군은 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다 . 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">Mac에서이 pragma를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">반면에 서버를 사용하는 데이터베이스 엔진은 클라이언트 응용 프로그램의 버그로부터 더 나은 보호 기능을 제공 할 수 있습니다. 클라이언트의 스트레이 포인터는 서버의 메모리를 손상시킬 수 없습니다. 또한 서버는 단일 영구 프로세스이므로보다 정밀하게 데이터베이스 액세스를 제어 할 수 있으므로보다 세밀한 잠금 및 동시성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">반면에 서버를 사용하는 데이터베이스 엔진은 클라이언트 응용 프로그램의 버그로부터 더 나은 보호 기능을 제공 할 수 있습니다. 클라이언트의 스트레이 포인터는 서버의 메모리를 손상시킬 수 없습니다. 또한 서버는 단일 영구 프로세스이기 때문에 데이터베이스 액세스를보다 정밀하게 제어 할 수 있으므로 세밀한 잠금과 동시성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">반면에 RBU Vacuum은 일반 SQLite VACUUM보다 많은 CPU를 사용합니다. 한 번의 테스트에서 최대 5 배나 많은 양입니다. 이러한 이유로 RBU 진공은 종종 동일한 조건에서 SQLite VACUUM보다 상당히 느립니다.</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">반면에 테이블을 삭제하는 것은 일반적인 작업이 아니므로 SQLite가 조금 더 오래 걸리더라도 큰 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">반면에 하위 쿼리의 결과를 여러 번 스캔해야하는 경우 (예를 들어, 조인에서 하나의 테이블 일 뿐이므로) 임시 쿼리를 사용하여 하위 쿼리의 전체 결과를 기억하는 것이 좋습니다. 하위 쿼리를 두 번 이상 계산하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">반면, 각 판독기는 WAL 파일의 내용을 확인해야하고 WAL 파일을 확인하는 데 필요한 시간이 WAL 파일의 크기에 비례하기 때문에 WAL 파일의 크기가 커지면 읽기 성능이 저하됩니다. wal-index는 WAL 파일의 내용을 훨씬 빠르게 찾을 수 있도록 도와 주지만 WAL 파일 크기가 커지면 성능이 저하됩니다. 따라서 좋은 읽기 성능을 유지하려면 정기적으로 검사 점을 실행하여 WAL 파일 크기를 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">스택 디스플레이에서 대부분의 항목은 해당 스택 항목의 데이터 유형을 알려주는 접두사와 함께 표시됩니다. 정수는 &quot; &lt;code&gt;i:&lt;/code&gt; &quot;로 시작합니다 . 부동 소수점 값은 &quot; &lt;code&gt;r:&lt;/code&gt; &quot;로 시작합니다 . &quot;r&quot;은 &quot;실수&quot;를 나타냅니다. 문자열은 &quot; &lt;code&gt;s:&lt;/code&gt; &quot;, &quot; &lt;code&gt;t:&lt;/code&gt; &quot;, &quot; &lt;code&gt;e:&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;z:&lt;/code&gt; &quot;로 시작합니다. 문자열 접두사 간의 차이점은 메모리 할당 방법에 따라 발생합니다. z : 문자열은 &lt;b&gt;malloc ()&lt;/b&gt; 에서 얻은 메모리에 저장됩니다 . t : 문자열은 정적으로 할당됩니다. e : 문자열은 일시적입니다. 다른 모든 문자열에는 s : 접두사가 있습니다. 이것은 관찰자, 당신에게 아무런 영향을 미치지 않습니다z : 문자열을 전달해야하므로 VDBE에 매우 중요합니다.&lt;b&gt;&lt;/b&gt;메모리 누수를 피하기 위해 튀어 나오면 &lt;b&gt;free ()&lt;/b&gt; . 문자열 값의 처음 10 자만 표시되고 이진 값 (예 : MakeRecord 명령의 결과)은 문자열로 처리됩니다. VDBE 스택에 저장할 수있는 유일한 다른 데이터 형식은 NULL이며 접두사없이 단순히 &quot; &lt;code&gt;NULL&lt;/code&gt; &quot; 로 표시 됩니다 . 정수가 정수와 문자열로 스택에 배치 된 경우 접두어는 &quot; &lt;code&gt;si:&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">유닉스 시스템 (또는 cygwin 또는 mingw + msys를 사용하는 Windows)에서 명령은 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">유닉스에서 데이터베이스 파일에 대한 심볼릭 링크가 열리면 해당 저널 파일은 심볼릭 링크 이름이 아닌 실제 파일 이름을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">유닉스 계열 시스템에서 디렉토리는 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Windows에서만 모든 &quot; &lt;code&gt;\&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;/&lt;/code&gt; &quot; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Windows에서만 파일 이름이 드라이브 문자로 시작하는 경우 단일 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자 앞에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">한 번</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">VFS가 등록되면 절대 수정해서는 안됩니다. 동작 변경이 필요한 경우 새 VFS를 등록해야합니다. 응용 프로그램은 아마도 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 를 사용 하여 이전 VFS를 찾고, 이전 VFS를 새로운 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 로 복사 하고, 새로운 VFS를 원하는대로 수정하고, 기존 VFS를 등록 취소 한 다음, 새로운 VFS를 등록 할 수 있습니다. 장소. 기존 데이터베이스 연결은 등록을 해제 한 후에도 이전 VFS를 계속 사용하지만 새 데이터베이스 연결은 새 VFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">연결이 테이블 잠금을 확보하면 현재 트랜잭션 (읽기 또는 쓰기)이 완료 될 때까지 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">프로세스가 독점 잠금을 확보하면 데이터베이스 파일에 쓸 수 있습니다. 그런 다음 롤백 저널에서 페이지의 원래 컨텐츠를 읽고 해당 컨텐츠를 데이터베이스 파일의 원래 위치로 다시 씁니다. 롤백 저널의 헤더는 중단 된 트랜잭션이 시작되기 전에 데이터베이스 파일의 원래 크기를 기록합니다. SQLite는이 정보를 사용하여 불완전한 트랜잭션으로 인해 데이터베이스가 커지는 경우 데이터베이스 파일을 원래 크기로 다시 자릅니다. 이 단계의 끝에서 데이터베이스는 크기가 같아야하며 중단 된 트랜잭션이 시작되기 전과 동일한 정보를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">테이블이 세션 개체에 연결되면 세션 개체는 테이블에 삽입 된 모든 새 행의 기본 키 값을 기록합니다. 또한 삭제되거나 업데이트 된 행의 원래 기본 키 및 기타 열 값을 기록합니다. 각각의 고유 한 기본 키 값에 대해 데이터는 한 번만 기록됩니다. 세션의 수명 동안 해당 기본 키가있는 행이 처음으로 삽입, 업데이트 또는 삭제 된 경우.</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">트랜잭션이 열리면 데이터베이스 연결에서 데이터를 읽는 것은 간단한 작업입니다. 데이터베이스 파일에서 열린 파일 핸들의 xRead () 메소드를 사용하여 필요한 데이터베이스 파일 페이지를 한 번에 하나씩 읽습니다. SQLite는 부분 페이지를 읽지 않으며 항상 필요한 각 페이지마다 xRead ()에 대한 단일 호출을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">가상 테이블이 작성되면 위에서 언급 한 특정 가상 테이블 구현에 의해 부과되는 예외를 제외하고 다른 테이블과 같이 사용할 수 있습니다. 가상 테이블은 일반적인 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 구문을 사용하여 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">다시 한 번, 실제 구현은이 구조를 서브 클래 싱하여 추가 개인 필드를 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">다시 한 번, SQL 문은 동일한 바이트 코드를 생성하므로 정확히 동일한 방식으로 동일한 작업을 수행합니다. 그러나 두 번째 형식은 쿼리 매개 변수를 WHERE 절 전체에 분산시키지 않고 단일 행 값으로 그룹화하여 사람이 쉽게 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">모든 롤백 저널 파일이 디스크로 플러시되면 데이터베이스 파일 업데이트를 시작하는 것이 안전합니다. 변경 사항을 작성하기 전에 모든 데이터베이스 파일에 대한 독점 잠금을 얻어야합니다. 모든 변경 사항을 기록한 후에는 정전 또는 운영 체제 충돌시 변경 사항이 유지되도록 변경 사항을 디스크로 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">SQLite 데이터베이스가 열리면 데이터베이스의 메소드를 사용하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">데이터베이스에 대한 인코딩이 설정되면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">배타적 잠금이 유지되면 데이터베이스 파일에서 다른 프로세스를 읽고 있지 않으므로 변경 내용을 데이터베이스 파일에 쓰는 것이 안전합니다. 일반적으로 이러한 변경 사항은 운영 체제 디스크 캐시까지만 적용되며 대용량 저장 장치를 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">변환이 수행되고 값이 NULL이 아닌 경우 값이 비교됩니다. 두 값이 모두 얼룩이면 memcmp ()를 사용하여 비교 결과를 결정합니다. 두 값이 모두 텍스트 인 경우 P4에 지정된 적절한 조합 기능을 사용하여 비교합니다. P4를 지정하지 않으면 memcmp ()를 사용하여 텍스트 문자열을 비교합니다. 두 값이 모두 숫자이면 숫자 비교가 사용됩니다. 두 값의 유형이 다른 경우 숫자는 문자열보다 작은 것으로 간주되고 문자열은 얼룩보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">모든 준비가 완료되면 &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;명령을 실행하여 변경 사항을 체크인하십시오. 위의 다이어그램에서 원 (4)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">각 슬라이드를 개별적으로 저장한다는 개념에 익숙해지면 프레젠테이션 버전 관리를 지원하는 작은 단계입니다. 다음 스키마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">채워지면 FTS5 테이블의 내용에 대해 전체 텍스트 쿼리를 실행하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">제거중인 더티 페이지를 쓸 수 있으면 데이터베이스 파일에 간단히 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">FROM 절의 입력 데이터가 WHERE 절 표현식 (있는 경우)에 의해 필터링되면 단순 SELECT에 대한 결과 행 세트가 계산됩니다. 정확히 수행되는 방법은 단순 SELECT가 집계 쿼리인지 집계되지 않은 쿼리인지, GROUP BY 절이 지정되었는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">프로젝트 저장소가 작성되면 모든 프로젝트 소스 코드를 유지하려는 디렉토리로 이동하고 다음을 입력하여 프로젝트의 열린 체크 아웃을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">spellfix1 확장이로드되면 spellfix1 가상 테이블의 인스턴스가 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">테스트 프로그램이 생성되면 테스트를 수행하기 위해 인수없이 실행됩니다. 오류 진단뿐만 아니라 진행 정보도 표준 출력에 나타납니다. (표준 출력 채널이없는 내장형 장치에 대해 컴파일 타임 옵션을 사용하여 대체 출력 배열을 만들 수 있습니다.) 오류가 없으면 프로그램은 0을 반환하고 문제가 발견되면 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">가상 테이블이 생성되면 다음과 같이 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">특정 버전을 찾으면 해당 버전의 하이퍼 링크를 클릭하여 &quot;체크인 정보 페이지&quot;를 확인하십시오. 그런 다음 &quot;Tarball&quot;링크 또는 &quot;ZIP archive&quot;링크를 클릭하여 전체 소스 트리를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">이 쿼리에 대한 한 가지 접근 방식은 WHERE 절의 fruit = 'Orange'용어를 사용하여 오렌지를 처리하는 모든 행을 찾은 다음 캘리포니아 이외의 주에서 온 행을 거부하여 해당 행을 필터링하는 것입니다. 이 프로세스는 위의 &lt;a href=&quot;#fig7&quot;&gt;그림 7에&lt;/a&gt; 표시되어 있습니다. 이것은 대부분의 경우 완벽하게 합리적인 접근 방식입니다. 예, 데이터베이스 엔진은 나중에 거부 된 Florida 주황색 행에 대해 추가 이진 검색을 수행해야했기 때문에 많은 응용 프로그램에서 충분히 효율적이기는하지만 원하는만큼 효율적이지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">모듈 이름 뒤에 쉼표로 구분 된 인수를 모듈에 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">&quot;.eqp on&quot;명령을 사용하여 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 를 자동 EXPLAIN QUERY PLAN 모드로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">또한 트랜잭션 타임 라인에서 저장 점을 &quot;표시&quot;로 생각할 수 있습니다. 이 뷰에서 SAVEPOINT 명령은 새 마크를 만들고 ROLLBACK TO 명령은 타임 라인을 명명 된 마크 바로 다음 지점으로 되 감고 RELEASE 명령은 실제로 데이터베이스를 변경하지 않고 타임 라인에서 마크를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">다음과 같은 pragma를 사용하여 WAL 모드를 명시 적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">조합 대신 교차 연산자를 사용하여 WHERE 절에 AND로 연결된 용어가있는 쿼리에서 여러 인덱스를 사용하기 위해 OR-by-UNION 기술을 어떻게 활용할 수 있는지 알 수 있습니다. 많은 SQL 데이터베이스 엔진이 그렇게 할 것입니다. 그러나 단일 인덱스 만 사용하면 성능이 약간 향상되므로 SQLite는 현재이 기술을 구현하지 않습니다. 그러나 향후 버전 SQLite는 AND-by-INTERSECT를 지원하도록 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">가상 테이블에서 트리거를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">가상 테이블에서 추가 인덱스를 만들 수 없습니다. (가상 테이블에는 인덱스가있을 수 있지만 가상 테이블 구현에 내장되어야합니다. 인덱스는 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 사용하여 별도로 추가 할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">일반 도구를 사용하여 OpenDocument 프레젠테이션의 내용을 쉽게 보거나 변경 또는 추출 할 수 없습니다. OpenDocument 문서를 보거나 편집하는 유일한 방법은 OpenDocument를 읽거나 쓰도록 특별히 설계된 응용 프로그램을 사용하여 문서를 여는 것입니다 (읽기 : LibreOffice 또는 그 사촌 중 하나). 상황이 더 나빠질 수 있습니다. &quot;zip&quot;아카이버 도구 만 사용하여 프리젠 테이션에서 개별 이미지를 추출하고 볼 수 있습니다. 그러나 슬라이드에서 텍스트를 추출하는 것은 합리적이지 않습니다. 모든 컨텐츠는 단일 &quot;context.xml&quot;파일에 저장됩니다. 이 파일은 XML이므로 텍스트 파일입니다. 그러나 일반 텍스트 편집기로 관리 할 수있는 텍스트 파일이 아닙니다. 위의 예제 프레젠테이션에서 content.xml 파일은 정확히 두 줄로 구성됩니다. 파일의 첫 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">가상 테이블에 대해 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; 명령을 실행할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next와 ListRead의 한 가지 차이점은 &quot;사물&quot;에 대한 아이디어입니다. 다음 명령어의 &quot;사물&quot;은 데이터베이스 파일의 레코드입니다. ListRead의 &quot;사물&quot;은 목록의 정수 키입니다. 또 다른 차이점은 다음 &quot;사물&quot;이없는 경우 점프하거나 넘어 지는지 여부입니다. 이 경우 다음이 넘어 가서 ListRead가 점프합니다. 나중에 동일한 원리로 작동하는 다른 루핑 명령어 (NextIdx 및 SortNext)가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">이것의 한 예는 2013-08-30 경에 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; 의 표준 저장소에서 발생했습니다 . 이 경우, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 이전에 파일 설명자 2 (표준 오류)가 잘못 닫혔으며 ( &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt; 에 의해 의심 됨) 리포지토리 데이터베이스 파일에 사용 된 파일 설명자가 2였습니다. 나중에 응용 프로그램 버그로 인해 assert ( ) 문은 write (2, ...)를 호출하여 오류 메시지를 표시합니다. 그러나 파일 설명자 2가 이제 데이터베이스 파일에 연결되었으므로 오류 메시지가 데이터베이스의 일부를 덮어 썼습니다. 이러한 종류의 문제를 방지하기 위해 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;버전 3.8.1&lt;/a&gt; (2013-10-17) 이상은 데이터베이스 파일에 낮은 번호의 파일 설명자를 사용하지 않습니다. ( &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 참조 추가 정보가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLite의 typelessness에 대한 한 가지 예외는 유형이 INTEGER PRIMARY KEY 인 열입니다. &quot;INT&quot;가 아닌 &quot;INTEGER&quot;를 사용해야합니다. INT PRIMARY KEY 유형의 열은 다른 방식과 마찬가지로 유형이 없습니다. INTEGER PRIMARY KEY 열은 32 비트 부호있는 정수를 포함해야합니다. 정수가 아닌 데이터를 삽입하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">위의 한 가지 의미는 단일 세션 내에서 변경이 이루어진 후 (예 : 행을 삽입 한 후 다시 삭제하는 경우) 세션 모듈이 변경을 전혀보고하지 않는다는 것입니다. 또는 동일한 세션 내에서 행이 여러 번 업데이트되는 경우 모든 업데이트는 변경 집합 또는 패치 세트 Blob 내에서 단일 업데이트로 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">오늘날 멀티 기가 바이트 데스크톱 시대에 전체 문서를 메모리로 읽는 것이 좋다고 주장 할 수 있습니다. 그러나 괜찮습니다. 하나의 경우, 사용 된 메모리 양이 디스크의 (압축 된) 파일 크기를 훨씬 초과합니다. 따라서 50MB 프레젠테이션에는 200MB 이상의 RAM이 필요할 수 있습니다. 한 번에 하나의 문서 만 편집해도 문제가되지 않습니다. 그러나 대화를 할 때이 저자는 일반적으로 동시에 10 개 또는 15 개의 서로 다른 프레젠테이션을 갖습니다 (과거의 프레젠테이션에서 슬라이드 복사 / 붙여 넣기를 용이하게하기 위해). 따라서 기가 바이트의 메모리가 필요합니다. 열린 웹 브라우저 또는 두 개 이상의 다른 데스크탑 앱에 추가하면 갑자기 디스크가 빙글 빙글 돌리고 머신이 스와핑됩니다. 그리고 우분투로 개조 된 저렴한 크롬 북 작업을 할 때 하나의 문서 만 있으면 문제가됩니다. 적은 메모리를 사용하는 것이 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">하나는 다른 제공 할 수 있습니다 &lt;a href=&quot;compile&quot;&gt;컴파일 시간 옵션&lt;/a&gt; 과 같은 &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; 전체 텍스트 검색, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; 는 R * 트리 검색 엔진 연장, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1을&lt;/a&gt; 포함하는 &lt;a href=&quot;json1&quot;&gt;JSON SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB을&lt;/a&gt; 에 대한 &lt;a href=&quot;dbstat&quot;&gt;가상 테이블 dbstat와&lt;/a&gt; . &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 리스팅 에서 추가 주석을 보려면 &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS를&lt;/a&gt; 추가하십시오 .선택권. 유닉스 시스템에서, 호스트 시스템이 usleep () 시스템 호출을 지원하면 -DHAVE_USLEEP = 1을 추가하십시오. 명령 행 편집 지원을 받으려면 -DHAVE_READLINE 및 -lreadline 및 -lncurses 라이브러리를 추가하십시오. 컴파일러 최적화 스위치를 지정할 수도 있습니다. SQLite 웹 사이트에서 다운로드 할 수있는 사전 컴파일 된 CLI는 &quot;-Os&quot;를 사용합니다. 여기에는 수많은 변형이 있습니다. 모든 기능을 갖춘 쉘을 컴파일하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">내용을 작은 조각으로 나누는 것의 단점은 압축이 짧은 텍스트에서는 잘 작동하지 않아 문서 크기가 커질 수 있다는 것입니다. 그러나 대부분의 문서 공간이 이미지를 저장하는 데 사용되므로 텍스트 내용의 압축 효율이 약간 떨어지지 만 사용자 환경을 개선하기 위해 적은 비용이 듭니다.</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10 진수 10 진수 ASCII 문자 중 하나 또는</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52 개의 대문자 및 소문자 ASCII 문자 중 하나 또는</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLite의 &lt;a href=&quot;different&quot;&gt;특징&lt;/a&gt; 중 하나는 데이터베이스가 단일 디스크 파일로 구성되어 있다는 것입니다. 데이터베이스 이동 또는 백업은 단일 파일을 복사하는 것만 큼 간단하기 때문에 SQLite 사용을 단순화합니다. 또한 SQLite를 &lt;a href=&quot;whentouse#appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용하기에 적합하게 만듭니다 . 그러나 완전한 데이터베이스가 단일 디스크 파일로 유지되는 동안 SQLite는 데이터베이스 처리 과정에서 많은 임시 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">ALL 또는 DISTINCT 키워드 중 하나가 간단한 SELECT 문에서 SELECT 키워드 뒤에 올 수 있습니다. 단순 SELECT가 SELECT ALL이면 전체 결과 행 세트가 SELECT에 의해 리턴됩니다. ALL 또는 DISTINCT가 없으면 ALL이 지정된 것처럼 동작합니다. 단순 SELECT가 SELECT DISTINCT이면 중복 행이 리턴되기 전에 결과 행 세트에서 제거됩니다. 중복 행을 감지하기 위해 두 개의 NULL 값이 동일한 것으로 간주됩니다. &lt;a href=&quot;datatype3#colrules&quot;&gt;일반적인 규칙은&lt;/a&gt; 텍스트 값을 비교하는 정렬 순서를 선택 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">프로젝트의 일부로 코드 생성기 도구를 호스팅 할 때의 장점 중 하나는 전체 프로젝트의 특정 요구에 맞게 도구를 최적화 할 수 있다는 것입니다. 레몬은이 효과로부터 이익을 얻었습니다. 수년에 걸쳐 레몬 파서 생성기는 SQLite에 새로운 기능과 향상된 성능을 제공하도록 확장 및 향상되었습니다. SQLite에서 사용하도록 특별히 설계된 레몬의 몇 가지 향상된 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFS 인터페이스의 흥미로운 기능 중 하나는 SQLite가 여러 VFS를 동시에 지원할 수 있다는 것입니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 사용하여 연결을 처음 열 때 사용할 단일 VFS를 선택해야합니다 . 그러나 프로세스에 여러 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 포함 된 경우 각각 다른 VFS를 선택할 수 있습니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 VFS를 런타임에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossil이 제공하는 많은 보고서 중 하나는 단일 지점에 대한 변경 일정으로 해당 지점의 모든 병합을 보여줍니다. 이러한 보고서의 일반적인 예는 &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; 를 참조 하십시오 . 이러한 보고서를 생성하는 데 일반적으로 몇 밀리 초가 걸립니다. 그러나 NGQP로 업그레이드 한 후이 보고서가 리포지토리 트렁크에서 10 초에 근접한 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLite가 시스템 충돌 및 전원 장애에 걸쳐 트랜잭션을 원자 적으로 유지하기 위해 수행하는 작업 중 하나는 데이터베이스를 변경하기 전에 모든 변경 사항을 롤백 저널 파일에 기록하는 것입니다. TCL 테스트 하네스에는 올바르게 작동하는지 확인하는 데 도움 이되는 대체 &lt;a href=&quot;vfs&quot;&gt;OS 백엔드&lt;/a&gt; 구현이 포함되어 있습니다 . &quot;journal-test VFS&quot;는 데이터베이스 파일과 롤백 저널 사이의 모든 디스크 I / O 트래픽을 모니터하여 롤백 저널에 처음 기록되고 동기화되지 않은 데이터베이스 파일에 아무것도 기록되지 않았는지 확인합니다. 불일치가 발견되면 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">ANALYZE가 마지막으로 실행 된 이후로 테이블의 하나 이상의 인덱스가 현재 분석되지 &lt;em&gt;않았거나&lt;/em&gt; 테이블 의 행 수가 25 배 이상 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">하나 이상의 트랜잭션이 디스크에 작성되었으므로 현재 wal 파일에 연결되어 있어야합니다. 즉, wal 파일을 처음 연 직후에는 wal 파일이없는 wal 모드 데이터베이스에서 스냅 샷을 작성할 수 없습니다. 먼저 하나 이상의 트랜잭션을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">한 가지 해결책은 데이터베이스 스키마에 SQL 외래 키 제약 조건을 추가하여</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 SQLite를 변경하여 최상의 경로를 철저히 검색하는 것입니다. 그러나 철저한 검색에는 K에 비례하는 시간이 필요합니다! (여기서 K는 조인의 테이블 수) 10- 조인 조인을 넘어 서면 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 를 실행하는 시간 이 매우 커집니다.</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">전체 테이블 스캔을 피하는 한 가지 기술은 rowid (또는 동등한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ) 별로 검색하는 것 입니다. 복숭아의 가격을 조회하기 위해 rowid가 4 인 항목을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Git과 Fossil의 한 사용자가 &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;HN으로 작성합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">SQLite에서 사용되는 한 가지 검증 기술은 전체 테스트 스위트를 두 번 실행하는 것입니다. 한 번 최적화를 설정 한 상태에서 한 번, 최적화를 해제 한 상태로 두 번째로 실행하면 두 번 모두 동일한 출력을 얻을 수 있습니다. 이는 최적화에 오류가 발생하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">매우 간단한 방법 중 하나는 각 결과 문서에서 사용자 검색어의 인스턴스 수를 계산하는 것입니다. 용어가 많이 포함 된 문서는 각 용어가 적은 수의 문서보다 관련성이 높은 것으로 간주됩니다. FTS 응용 프로그램에서 각 결과의 항 인스턴스 수는 &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋&lt;/a&gt; 함수 의 반환 값에있는 정수 수를 계산하여 확인할 수 있습니다 . 다음 예는 사용자가 입력 한 쿼리에 대해 10 개의 가장 관련성이 높은 결과를 얻는 데 사용할 수있는 쿼리를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법은 sqlite3_step () 호출에 의해 반환 된 확장 오류 코드를 확인하는 것입니다. 블로킹 연결이 있으면 확장 오류 코드가 SQLITE_LOCKED_SHAREDCACHE로 설정됩니다. 그렇지 않으면 특수한 &quot;DROP TABLE / INDEX&quot;경우 확장 오류 코드는 SQLITE_LOCKED입니다.</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">FindFrame (P, M)을 계산하는 한 가지 방법은 M 번째 항목부터 시작하여 뒤로 시작하여 aPgno [J] == P 인 J를 반환하는 aPgno 배열을 스캔하는 것입니다. 이러한 알고리즘은 작동하며 페이지 번호가 P 인 최신 프레임을 전체 WAL 파일을 검색하는 것보다 빠릅니다. 그러나 aHash 구조를 사용하면 훨씬 빠르게 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">임 포스터 테이블을 작성하는 한 가지 방법은 sqlite_master 테이블을 직접 편집하여 테이블을 설명하는 새 행을 삽입하는 것입니다. 예를 들어, 스키마가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">쉘 스크립트에서 sqlite3를 사용하는 한 가지 방법은 &quot;echo&quot;또는 &quot;cat&quot;을 사용하여 파일에서 일련의 명령을 생성 한 다음 생성 된 명령 파일에서 입력을 재지 정하는 동안 sqlite3을 호출하는 것입니다. 이것은 잘 작동하며 많은 상황에서 적합합니다. 그러나 편의상 sqlite3을 사용하면 데이터베이스 이름 다음에 두 번째 인수로 명령 행에 단일 SQL 명령을 입력 할 수 있습니다. sqlite3 프로그램이 두 개의 인수로 시작되면 두 번째 인수는 처리를 위해 SQLite 라이브러리로 전달되고 쿼리 결과는 표준 출력에 목록 모드로 인쇄되고 프로그램이 종료됩니다. 이 메커니즘은 &quot;awk&quot;와 같은 프로그램과 함께 sqlite3를 쉽게 사용할 수 있도록 설계되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">다음과 같은 간단한 쿼리를 사용하여 R * Tree 인덱스를 사용하지 않고도 동일한 대답을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">원스텝 쿼리 실행 인터페이스</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">온라인 백업 API</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">온라인 백업 API.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">온라인 백업 개체</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">여기서는 CPU주기 수만 측정됩니다. CPU 사이클 수는 에너지 소비를위한 좋은 프록시이지만 실제 타이밍과는 상관이 없습니다. I / O를 수행하는 데 소요 된 시간은 CPU주기 수에 반영되지 않으며 많은 SQLite 사용 시나리오에서 I / O 시간이 우세합니다.</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">한 번에 하나의 권한 부여 자만 데이터베이스 연결에 배치 할 수 있습니다. sqlite3_set_authorizer에 대한 각 호출은 이전 호출을 대체합니다. NULL 콜백을 설치하여 권한 부여기를 비활성화하십시오. 인증 기는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 당 한 번에 하나의 진행률 처리기 만 정의 할 수 있습니다 . 새로운 진행 처리기를 설정하면 이전 처리기가 취소됩니다. 매개 변수 X를 NULL로 설정하면 진행률 처리기가 비활성화됩니다. N을 1보다 작은 값으로 설정하면 진행률 처리기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 당 한 번에 하나의 진행률 처리기 만 정의 할 수 있습니다 . 새로운 진행 처리기를 설정하면 이전 처리기가 취소됩니다. 매개 변수 X를 NULL로 설정하면 진행률 처리기가 비활성화됩니다. N을 1보다 작은 값으로 설정하면 진행률 처리기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 문으로 직접 작성된 변경 사항 만 고려됩니다. &lt;a href=&quot;../lang_createtrigger&quot;&gt;트리거&lt;/a&gt; , &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;외래 키 조치&lt;/a&gt; 또는 &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; 제한 조건 분석으로 인한 보조 변경 사항 은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 문으로 직접 작성된 변경 사항 만 고려됩니다. &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; , &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 조치&lt;/a&gt; 또는 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 제한 조건 분석으로 인한 보조 변경 사항 은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">인덱스의 열 a와 b 만 사용할 수 있습니다. c 열이 제한되지 않고 인덱스에서 사용할 수있는 열 집합에 간격이 없어 d 열을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">인덱스의 열 a, b 및 c 만 사용할 수 있습니다. d 열은 c의 오른쪽에서 발생하고 c는 부등식으로 만 제한되므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">둘 이상의 연결된 데이터베이스가 모두 수정되고 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되어 있지 않고 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; 가 OFF, MEMORY 또는 WAL로 설정되어 있지 않은 경우 에만 &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;마스터 저널&lt;/a&gt; 파일을 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">크기가 임계 값을 초과 할 경우 에만 &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 파일을 작성하십시오 . 그렇지 않으면 저널이 메모리에 유지되고 I / O가 발생하지 않습니다. 임계 값은 사용 컴파일시에 구성 될 수 &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 사용 또는 시동시에이 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">WHERE 절이 true로 평가되는 테이블의 행만 인덱스에 포함됩니다. WHERE 절 표현식이 테이블의 일부 행에 대해 NULL 또는 false로 평가되면 해당 행이 색인에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">langid가 일치하는 단어의 용어 만 검색합니다. 따라서 동일한 테이블에 여러 언어의 항목이 포함될 수 있으며 요청 된 언어 만 사용됩니다. 기본 langid는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">&quot;ll&quot;길이 수정 자만 SQLite에 차이를 만듭니다. 그리고 C 언어 인터페이스를 사용할 때만 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">ALTER TABLE 명령의 RENAME TABLE, ADD COLUMN 및 RENAME COLUMN 변형 만 지원됩니다. DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT 등과 같은 다른 종류의 ALTER TABLE 연산은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">AND 연산자의 암시 적 버전 만 지원됩니다. 표준 쿼리 구문 쿼리의 일부로 문자열 &quot;AND&quot;를 지정하면 &quot;and&quot;라는 용어가 포함 된 문서 집합에 대한 용어 쿼리로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">섹션 1.0에 설명 된 세 가지 핵심 루틴 만 SQLite를 사용해야합니다. 그러나 유용한 인터페이스를 제공하는 다른 많은 기능이 있습니다. 이러한 확장 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">COLLATE가 올 바르면 ORDER BY 또는 GROUP BY를 최적화하기 위해 인덱스 온 표현식 만 사용하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">오피 코드 이름</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">오피 코드 정의</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">증분 I / O를위한 BLOB 열기</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">쿼리 할 테이블로 커서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">커서 P2와 동일한 임시 테이블을 가리키는 새 커서 P1을여십시오. P2 커서는 이전 &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode에 의해 열려 있어야합니다 . 임시 커서 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">새 커서 P1을 임시 테이블로여십시오. 기본 데이터베이스가 읽기 전용 인 경우에도 커서는 항상 읽기 / 쓰기로 열립니다. 임시 테이블은 커서를 닫으면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">단일 데이터 행이 포함 된 가짜 테이블을 가리키는 새 커서를 엽니 다. 그 1 행의 내용은 메모리 레지스터 P2의 내용이다. 즉, 커서 P1은 레지스터 P2에 포함 된 MEM_Blob 내용의 별칭이됩니다.</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">데이터베이스 파일에서 루트 페이지가 P2 인 데이터베이스 테이블에 대한 읽기 전용 커서를여십시오. 데이터베이스 파일은 P3에 의해 결정됩니다. P3 == 0은 기본 데이터베이스를 의미하고 P3 == 1은 임시 테이블에 사용 된 데이터베이스를 의미하고 P3&amp;gt; 1은 해당하는 연결된 데이터베이스를 의미합니다. 새 커서에 P1의 식별자를 제공하십시오. P1 값은 연속적 일 필요는 없지만 모든 P1 값은 작은 정수 여야합니다. P1이 음수 인 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">루트 페이지가 P2이거나 OPFLAG_P2ISREG 비트가 P5에 설정된 경우 루트 페이지가 레지스터 P2에 보유 된 테이블 또는 인덱스에서 이름이 P1 인 읽기 / 쓰기 커서를 엽니 다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">sqlite3rbu_open (T, A, S) 함수를 사용하여 RBU 핸들을여십시오.</target>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">&quot;/home/fred/data.db&quot;파일을여십시오. posix 권고 잠금 대신 도트 파일을 사용하는 특수 VFS &quot;unix-dotfile&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">읽기 전용 액세스를 위해 현재 디렉토리에서 &quot;data.db&quot;파일을여십시오. 공유 캐시 모드가 기본적으로 사용되는지 여부에 관계없이 개인 캐시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">데이터베이스 파일 &quot;/home/fred/data.db&quot;를여십시오.</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">데이터베이스 파일을 열고 SHARED 잠금을 확보하십시오. SHARED 잠금을 확보 할 수 없으면 즉시 실패하고 SQLITE_BUSY를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">현재 디렉토리에서 &quot;data.db&quot;파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">쿼리중인 두 테이블 각각에 하나씩 두 개의 커서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">P1 값에 따라 매개 변수 P4로 명명 된 저장 점을 열거 나 해제하거나 롤백하십시오. 새 저장 점을 열려면 P1 == 0 (SAVEPOINT_BEGIN)을 설정하십시오. 기존 저장 점을 해제 (커밋)하려면 P1 == 1 (SAVEPOINT_RELEASE)을 설정하십시오. 기존 저장 점을 롤백하려면 P1 == 2 (SAVEPOINT_ROLLBACK)를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">오픈 클로즈 콜백</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">새로운 데이터베이스 연결 열기</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">새로운 연결 열기</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">읽기 전용 트랜잭션 열기</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">새 데이터베이스 연결을 여는 것은 두 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">읽기 전용 트랜잭션을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">읽기-쓰기 트랜잭션을 여는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">명세서 거래를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">피연산자 P1은 0x7fffffff이고 P2는 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">최적화 : &lt;a href=&quot;expridx&quot;&gt;expressions에 인덱스가&lt;/a&gt; 있는 테이블 에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 를 수행 할 때 업데이트 되는 테이블 의 컬럼을 참조하지 않는 경우 표현식 인덱스를 업데이트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">sqlite_mprintf () 루틴에 대한 최적화.</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">디스크에서 데이터베이스 내용을 불필요하게 읽지 않도록 &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#length&quot;&gt;length ()&lt;/a&gt; SQL 함수를 최적화하십시오 .</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">옵티마이 저는 정수 기본 키를 기준으로 정렬하는 ORDER BY 절을 만족시키기 위해 인덱스를 더 잘 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">최적화 개선 : LIKE 연산자의 RHS에 대한 바인딩이 변경되거나 &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 에서 범위 제한이 변경 될 때 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 자동으로 다시 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">옵션 1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">옵션 2 :</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">선택적 LIMIT 및 ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">선택적 LIMIT 및 ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">데이터베이스 연결이 공통 캐시를 공유 할 때 선택적 COMM UNCOMMITTED 격리 (기본 격리 수준 인 SERIALIZABLE 대신) 및 테이블 수준 잠금.</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">선택적으로 테이블의 기본 키입니다. 단일 열과 복합 (다중 열) 기본 키가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt; 명령으로 이해되는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">또는 다음과 동일한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">또는 MSVC가있는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">또는 최적화</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">또는 아마도 응용 프로그램은 가장 최근의 checkinTime을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">아니면 이거:</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">또는 데이터베이스를 더욱 안전하게 보호하고 SQLite가 데이터베이스에 전원 안전 덮어 쓰기가 없다고 가정하도록하려면</target>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">또는 SQLite 쉘 도구에서 ( &lt;a href=&quot;cli#fileio&quot;&gt;readfile ()&lt;/a&gt; 함수는 파일 시스템에서 파일 내용을 읽고이를 블롭으로 리턴합니다).</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">또는 zTab 인수가 NULL이면 데이터베이스의 모든 테이블에 대한 변경 사항이 기록됩니다. 이 호출 후 추가 테이블이 데이터베이스에 추가되면 ( &quot;CREATE TABLE&quot;문을 실행하여) 새 테이블에 대한 변경 사항도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">또는 큰 따옴표로 묶인 문자열 리터럴이 기본적으로 비활성화되어 있지만 일부 히스토리 데이터베이스 연결에 대해 선택적으로 활성화해야하는 경우, 세 번째 매개 변수가 0에서 1로 변경된 경우를 제외하고는 위에 표시된 것과 동일한 C 코드를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">또는 sqlite3.c가 다른 빌드 시스템을 사용하여 컴파일되는 경우 SQLITE_ENABLE_FTS5 전 처리기 기호를 정의하여 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">또는 REINDEX에 첨부 된 인수가 특정 데이터베이스 테이블을 식별하면 데이터베이스 테이블에 첨부 된 모든 인덱스가 재 빌드됩니다. 특정 데이터베이스 인덱스를 식별하면 해당 인덱스 만 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">또는 테이블이 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless 테이블&lt;/a&gt; 인 경우 다음이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">또는 autoconf 빌드 시스템을 사용하는 경우 --enable-session 옵션을 configure 스크립트에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">또는 여러 프레젠테이션을 동일한 문서에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">또는 다음을 사용하여 동일한 내용을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">또는 규모가 작은 순서대로 하나의 특정 계정 ($ xyz)에 대한 모든 변경 사항을 나열하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">매우 큰 테이블에서 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX의&lt;/a&gt; 성능이 크게 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">일반적인 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">일반적인 SQL 문은 자유 형식이며 여러 줄로 분산 될 수 있으며 어디에서나 공백과 주석을 가질 수 있습니다. 도트 명령이 더 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">일반적인 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">거래 시작 전 페이지의 원본 콘텐츠</target>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">다른 문제</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">다른 SQL 데이터베이스 엔진은 데이터를 큰 파일 모음으로 저장하는 경향이 있습니다. 종종 이러한 파일은 데이터베이스 엔진 자체 만 액세스 할 수있는 표준 위치에 있습니다. 이로 인해 데이터가 더 안전 해지지 만 액세스하기가 더 어려워집니다. 일부 SQL 데이터베이스 엔진은 디스크에 직접 쓰고 파일 시스템을 우회하는 옵션을 제공합니다. 이는 추가 성능을 제공하지만 설치 및 유지 관리가 상당히 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">다른 더 복잡한 확장에 따라 하위 폴더에서 찾을 수 있습니다 &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;내선 /&lt;/a&gt; 내선 / 기타 / 이외.</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">&lt;a href=&quot;compile#threadsafe&quot;&gt;-O&lt;/a&gt; 대신 -O3 사용 또는 -DSQLITE_THREADSAFE = 0 사용 및 / 또는 다른 &lt;a href=&quot;compile#rcmd&quot;&gt;권장 컴파일 시간 옵션&lt;/a&gt; 과 같은 다른 컴파일 시간 옵션 은 SQLite가 직접 파일 시스템 읽기에 비해 훨씬 빠르게 실행하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">다른 데이터베이스 엔진은 일단 실행하면 훌륭하게 실행될 수 있습니다. 그러나 초기 설치 및 구성을 수행하는 것은 종종 위협적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">비용 표의 다른 항목은 특정 문자를 변환합니다. 특정 변환 비용은 기본 비용보다 낮아야합니다. 그렇지 않으면 기본 비용이 우선하며 특정 변환은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">다른 실험용 메모리 할당자는 향후 SQLite 릴리스에 추가 될 수 있습니다. 이들을 memsys7, memsys8 등이라고 부를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">다른 중요한 버그 수정</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">sqlite3_rtree_query_info 구조의 다른 정보 필드는 원하는 경우 xQueryFunc 콜백에서 사용할 수 있습니다. iRowid 필드는 고려중인 요소의 rowid (R * Tree에서 3-11 개의 열 중 첫 번째)입니다. iRowid는 잎에만 유효합니다. eParentWithin 및 rParentScore 값은 현재 행의 포함 서브 트리에서 eWithin 및 rScore 값의 사본입니다. anQueue 필드는 각 레벨에서 우선 순위 큐에있는 현재 요소 수를 알려주는 mxLevel + 1 부호없는 정수의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">다른 종류의 제약 조건이 사용될 수 있지만 작동하지만 다른 제약 조건은 각 행에 대해 개별적으로 검사되며 최적화되지 않습니다 (최소한 초기에는 아님). 모든 제약 조건 검사는 최적화 발생 여부에 관계없이 완전히 자동입니다. 이 글 머리 기호에 언급 된 최적화는 성능 고려 사항 일뿐입니다. 쿼리 최적화 여부에 관계없이 동일한 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">기타 사소한 버그 수정 및 설명서 향상</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">기타 사소한 버그 수정 및 설명서 향상.</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">기타 사소한 버그 수정 및 성능 향상</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">기타 사소한 버그 수정 및 성능 최적화</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">버전 3.3의 첫 번째 안정적인 릴리스를 준비하는 기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">기타 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">기타 사소한 변경 및 개선.</target>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">기타 사소한 문서 및 makefile 변경 및 버그 수정</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; 코드 의 품질을 향상시키기위한 기타 미세 조정 .</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">기타 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">기타 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">루프 언 롤링과 같은 기타 기타 개선 사항.</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">성능 향상 및 메모리 사용량 감소를위한 기타 기타 마이크로 최적화.</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">기타 기타 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">기타 기타 성능 향상</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">친숙한 다른 데이터베이스 엔진은 일단 실행하면 훌륭하게 실행됩니다. 그러나 초기 설치 및 구성은 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">화석과 Git에 관한 다른 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">다른 성능 향상. 약 &lt;a href=&quot;cpu&quot;&gt;6.5 % 적은 CPU주기를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">다른 성능 최적화 :</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">다른 프로그래밍 언어는 때때로 &quot;C만큼 빠르다&quot;고 주장합니다. 그러나 다른 언어는 범용 프로그래밍에서 C보다 빠르다고 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">다른 유사한 트리 표시 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">기타 작은 버그 수정 및 최적화</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">다른 시스템은 때때로 SQLite에서 ALWAYS (X) 또는 NEVER (X)를 사용하는 것과 유사한 방식으로 assert (X)를 사용합니다. 개발자는 &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;X가 항상 참이라고 완전히 믿지 않는다는 암묵적 인정&lt;/a&gt; 으로 assert (X)를 추가 합니다.. 우리는 assert (X)의 사용이 잘못되었고 C에서 assert (X)를 사용할 수있는 의도와 목적을 위반한다고 생각합니다. assert (X)는 실수로부터 보호하기 위해 사용되는 안전망 또는 상단 로프로 간주되어서는 안됩니다. 심층 방어에는 assert (X)도 적합하지 않습니다. 프로그래머가 추론을 할 때 ALWAYS (X) 또는 NEVER (X) 매크로 또는 이와 유사한 것을 사용해야합니다. 틀리다. ALWAYS (X) 또는 NEVER (X)를 따르는 코드는 테스트되지 않았으므로 검사를 통해 쉽게 확인할 수있는 &quot;return&quot;문과 같이 매우 단순해야합니다.</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">그렇지 않으면 표현식에 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">그렇지 않으면 오류가 발생하지 않으면 &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; 는 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">그렇지 않으면 오류가 발생하지 않으면 &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; 는 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">그렇지 않으면, ORDER BY 표현식이 컬럼이거나 컬럼 인 표현식의 별명 인 경우, 컬럼의 기본 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">그렇지 않으면 ORDER BY 표현식이 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 를 사용하여 데이터 정렬 시퀀스에 지정된 표현식의 별명 인 경우 별명 지정된 표현식에 지정된 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">그렇지 않으면 ORDER BY 표현식이 다른 표현식 인 경우 평가되고 리턴 된 값이 출력 행을 정렬하는 데 사용됩니다. SELECT 문이 단순 SELECT 인 경우 ORDER BY는 임의의 표현식을 포함 할 수 있습니다. 그러나 SELECT가 복합 SELECT 인 경우 출력 컬럼의 별명이 아닌 ORDER BY 표현식은 출력 컬럼으로 사용되는 표현식과 정확히 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">그렇지 않으면 선호도가 적용되지 않고 두 피연산자가 그대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">그렇지 않으면 r [P2]는 r [P1]과 r [P3]의 합으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">그렇지 않으면 BINARY 조합 기능이 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">그렇지 않으면 선호도는 NUMERIC입니다.</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">그렇지 않으면이 필드에 삽입 된 값은 일반 파일의 파일 내용 또는 기호 링크의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">그렇지 않으면이 API는 P1이 P2보다 오래된 스냅 샷을 참조하면 음수 값을 리턴하고, 두 핸들이 동일한 데이터베이스 스냅 샷을 참조하면 0, P1이 P2보다 새로운 스냅 샷이면 양수 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">우리의 목표는 오늘날 SQLite에 저장하는 콘텐츠를 손자에게 쉽게 액세스 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">메모리 부족 (OOM) 오류 조건은 SQLITE_NOMEM 오류 코드 및 실패한 할당에 의해 요청 된 메모리 바이트 수를 나타내는 메시지와 함께 오류 로깅 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">메모리 부족 테스트</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">비정상적인 재귀 쿼리 예제</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">출력 변경</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">index_info pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">index_list pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">index_xinfo pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 &quot;.dump&quot;명령에서 무한대를 1e999로 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">작은 정렬이 완료 될 때마다 그리고 테이블 스캔이 완료되기 훨씬 전에 출력 행을 애플리케이션으로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">데이터베이스 t1.db를 업데이트하는 데 사용되는 경우 해당 컨텐츠가 데이터베이스 t2.db의 컨텐츠와 동일하도록 패치하는 RBU 데이터베이스를 작성하는 SQL 스크립트를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">100 개가 넘는 별도의 소스 파일이 &quot;sqlite3.c&quot;라는 하나의 큰 C 코드 파일로 연결되고 &quot;아말감 화&quot;라고합니다. 통합에는 응용 프로그램에 SQLite를 포함시키는 데 필요한 모든 것이 포함됩니다. 합병 파일의 길이는 220,000 줄 이상이고 크기는 7.5MB 이상입니다 (2018-11-24 기준).</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">오버플로 페이지</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">가상 테이블에 대한 함수 과부하</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Zulu 또는 현지 시간을 얻기위한 호출과 같은 다른 운영 체제 인터페이스를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">개요 서류</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">이미 존재하는 경우 덮어 쓰시겠습니까?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">원본 데이터베이스와 관련된 핫 저널도 삭제하지 않고 다른 데이터베이스 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">다른 저널 파일로 저널 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P (비용 : 7.71)</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1은 일반 테이블 또는 가상 테이블 일 수 있습니다. 가상 테이블에 사용할 별도의 OP_VRowid opcode가 있었지만이 opcode는 이제 두 테이블 유형 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1은 서브 프로그램에 대한 인수로 사용되는 값의 배열에서 첫 번째 메모리 셀을 포함하는 메모리 셀의 주소를 포함합니다. P2는 하위 프로그램이 RAISE () 함수를 사용하여 IGNORE 예외를 발생시키는 경우 이동할 주소를 포함합니다. 레지스터 P3에는 런타임시 서브 vdbe에 필요한 메모리를 할당하는 데 사용되는이 (상위) VM의 메모리 셀 주소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1은 함수에 대한 각 인수가 컴파일 타임에 일정하다고 결정되었는지 여부를 나타내는 32 비트 비트 마스크입니다. 첫 번째 인수가 상수이면 P1의 비트 0이 설정됩니다. sqlite3_set_auxdata () API를 사용하여 사용자 함수 인수와 연관된 메타 데이터가 다음에이 opcode를 호출 할 때까지 안전하게 유지 될 수 있는지 여부를 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1은 부울 플래그입니다. true로 설정되고 xUpdate 호출이 성공하면 sqlite3_last_insert_rowid ()에 의해 리턴 된 값이 방금 삽입 된 행의 rowid 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1은 &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen을&lt;/a&gt; 사용하여 열린 커서 입니다. P2는 필터링 된 결과 집합이 비어있는 경우 이동할 주소입니다.</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1은이 VM의 루트 프레임에있는 레지스터입니다 (이 명령이 하위 프로그램 내에서 실행되는 경우 루트 프레임은 현재 프레임과 다릅니다). 레지스터 P1의 값을 현재 값의 최대 값과 레지스터 P2의 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1은 분류기 커서입니다. 시퀀스 카운터가 현재 0이면 P2로 이동합니다. 점프 여부와 관계없이 시퀀스 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1은 분류기 커서입니다. 이 명령어는 레지스터 P3에있는 레코드 Blob의 접두사와 분류기 커서가 현재 가리키는 항목의 접두사를 비교합니다. r [P3]의 첫 번째 P4 필드와 분류기 레코드 만 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1은 열린 인덱스 커서이고 P3은 해당 테이블의 커서입니다. 이 opcode는 P3 테이블 커서를 P1의 현재 행에 해당하는 행으로 지연 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1은 SQL 테이블 btree에서 열린 커서의 인덱스입니다 (정수 키 포함). 레지스터 P3에 정수가 없거나 P1에 rowid P3이있는 레코드가없는 경우 즉시 P2로 이동하십시오. 또는 P2가 0이면 SQLITE_CORRUPT 오류를 발생시킵니다. P1에 rowid P3의 레코드가 포함되어 있으면 커서가 해당 레코드를 가리키고 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1은 SQL 테이블 btree에서 열린 커서의 인덱스입니다 (정수 키 포함). P3은 정수 rowid입니다. P1에 rowid P3의 레코드가 없으면 즉시 P2로 이동하십시오. 또는 P2가 0이면 SQLITE_CORRUPT 오류를 발생시킵니다. P1에 rowid P3의 레코드가 포함되어 있으면 커서가 해당 레코드를 가리키고 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1은 트랜잭션이 시작된 데이터베이스 파일의 색인입니다. 인덱스 0은 기본 데이터베이스 파일이고 인덱스 1은 임시 테이블에 사용되는 파일입니다. 연결된 데이터베이스에는 2 개 이상의 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1은 잠금을 획득 한 데이터베이스의 sqlite3.aDb []에있는 데이터베이스의 색인입니다. P3 == 0이면 판독 잠금을 얻거나 P3 == 1이면 기록 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1은 집계 또는 창 함수의 누산기 인 메모리 위치입니다. 집계에 대한 종료 자 함수를 실행하고 결과를 P1에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1은 sqlite3_exec (), sqlite3_reset () 또는 sqlite3_finalize ()에 의해 반환되는 결과 코드입니다. 정상적인 정지의 경우 SQLITE_OK (0)이어야합니다. 오류의 경우 다른 값이 될 수 있습니다. P1! = 0이면 P2는 현재 트랜잭션을 롤백할지 여부를 결정합니다. P2 == OE_Fail 인 경우 롤백하지 마십시오. P2 == OE_Rollback 인 경우 롤백을 수행하십시오. P2 == OE_Abort 인 경우 VDBE를 실행하는 동안 발생한 모든 변경 사항을 취소하지만 트랜잭션을 롤백하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1은 유효한 b- 트리 커서 여야합니다. P2는 0 또는 1의 부울 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1은 의사 테이블이 아니어야합니다. 여러 행이있는 실제 테이블이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2는 잠글 테이블의 루트 페이지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2는 데이터베이스 P1의 가상 테이블 이름을 보유하는 레지스터입니다. 해당 테이블의 xCreate 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2는 sqlite_offset () 함수에 대한 인수의 열 번호입니다. 이 opcode는 P2 자체를 사용하지 않지만 P2 값은 코드 생성기에서 사용됩니다. 이 opcode의 P1, P2 및 P3 피연산자는 &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; 의 피연산자와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2는 단계 함수가 취하는 인수 수이고 P4는이 함수의 FuncDef에 대한 포인터입니다. 이 opcode에서는 P2 인수를 사용하지 않습니다. 다양한 수의 인수를 취할 수있는 기능을 명확하게하는 것만 있습니다. P4 인수는 단계 함수가 이전에 호출되지 않은 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2는 임시 테이블의 열 수입니다. 커서는 P4 == 0 인 경우 BTree 테이블을 가리키고 P4가 0이 아닌 경우 BTree 인덱스를 가리 킵니다. P4가 NULL이 아닌 경우 인덱스의 키 형식을 정의하는 KeyInfo 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A'&amp;rarr; BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B'&amp;rarr; 텍스트</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C'&amp;rarr; 숫자</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D'&amp;rarr; 정수</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E'&amp;rarr; 실제</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3 = P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3은 의사 테이블에 의해 저장 될 레코드의 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4에는 잠긴 테이블 이름에 대한 포인터가 있습니다. 잠금을 확보 할 수없는 경우에만 오류 메시지를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4는 비교를위한 조합 순서 및 정렬 순서를 정의하는 KeyInfo 구조입니다. 순열은 레지스터에만 적용됩니다. KeyInfo 요소는 순차적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4는 64 비트 부동 소수점 값에 대한 포인터입니다. 이 값을 레지스터 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4는 64 비트 정수 값에 대한 포인터입니다. 이 값을 레지스터 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4는 CollSeq 객체에 대한 포인터입니다. 사용자 함수에 대한 다음 호출 또는 집계가 sqlite3GetFuncCollSeq ()를 호출하면이 조합 순서가 리턴됩니다. 내장 min (), max () 및 nullif () 함수에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. P1은 커서 번호입니다. 이 opcode는 가상 테이블에 대한 커서를 열고 해당 커서를 P1에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. 이 opcode는 해당 xRename 메소드를 호출합니다. 레지스터 P1의 값은 zName 인수로 xRename 메소드에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. 이 opcode는 해당 xUpdate 메소드를 호출합니다. P2 값은 P3에서 시작하여 xUpdate 호출로 전달되는 연속 메모리 셀입니다. 레지스터 (P3 + P2-1)의 값은 xUpdate에 전달 된 argv 배열의 p2 번째 요소에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4는 트리거 프로그램이 포함 된 VM에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4는 P2 자 길이의 문자열입니다. 문자열의 N 번째 문자는 해당 범위의 N 번째 메모리 셀에 사용해야하는 열 선호도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4는 항상 P4_ADVANCE 유형입니다. 함수 포인터는 sqlite3BtreeNext ()를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4는 항상 P4_ADVANCE 유형입니다. 함수 포인터는 sqlite3BtreePrevious ()를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4는 NULL이거나 모듈의 xBestIndex 메소드에 의해 생성 된 문자열입니다. P4 문자열의 해석은 모듈 구현에 맡겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4는 데이터베이스 P1의 가상 테이블 이름입니다. 해당 테이블의 xDestroy 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4는 sqlite3_vtab 구조에 대한 포인터 일 수 있습니다. 그렇다면 해당 테이블에 대한 xBegin 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4는 P2 자 길이의 문자열 일 수 있습니다. 문자열의 N 번째 문자는 인덱스 키의 N 번째 필드에 사용해야하는 열 선호도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4는 P3 테이블의 각 열에 대해 하나의 항목을 포함하는 정수 배열 (P4_INTARRAY 유형) 일 수 있습니다. 배열 항목 a (i)가 0이 아닌 경우 커서 P3에서 열 a (i) -1을 읽는 것은 지연된 탐색을 수행 한 다음 P1에서 열 i를 읽는 것과 같습니다. 이 정보는 P3에 저장되며 P3에 대한 읽기를 P1로 리디렉션하는 데 사용되므로 커서 P3을 찾아서 읽을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4는 P1 바이트 길이의 데이터 Blob을 가리 킵니다. 이 얼룩을 레지스터 P2에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4는 널 종료 UTF-8 문자열을 가리 킵니다. 이 opcode는 처음으로 실행되기 전에 &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode 로 변환됩니다 . 이 변환 중에 문자열 P4의 길이가 계산되어 P1 매개 변수로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5는 P4 문자열을 수정하는 0에서 4 사이의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5는 삽입 또는 업데이트시 제한 조건 실패시 적용 할 오류 조치 (OE_Replace, OE_Fail, OE_Ignore 등)입니다.</target>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Adobe의 휴대용 문서 형식</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">POSIX 잠금 스타일. 이것은 기본 잠금 스타일이며 다른 (Mac OS X 이외) 유닉스에서 사용되는 스타일입니다. fcntl () 시스템 호출을 사용하여 잠금을 확보하고 해제합니다.</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-Microsoft PowerPoint 프레젠테이션</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">PRAGMA 문</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMA application_id</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA auto_vacuum</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">PRAGMA automatic_index</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMA busy_timeout</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">PRAGMA cache_size</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMA checkpoint_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA collation_list</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">PRAGMA 명령 구문</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">PRAGMA compile_options</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">PRAGMA data_store_directory</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">PRAGMA data_version</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">PRAGMA database_list</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA default_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA defer_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">PRAGMA 인코딩</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA foreign_key_list</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA foreign_keys</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA freelist_count</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA full_column_names</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync = ON;</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">PRAGMA 기능</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">PRAGMA function_list</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">PRAGMA 기능</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA ignore_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA incremental_vacuum</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA index_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">PRAGMA index_list</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">PRAGMA integrity_check</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check가 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; 오류를 찾지 못했습니다 . FOREIGN KEY 제약 조건에서 오류를 찾으 려면 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">PRAGMA journal_mode</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">PRAGMA journal_size_limit</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">PRAGMA legacy_file_format</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">PRAGMA locking_mode</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">PRAGMA module_list</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA 최적화</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMA page_count</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">PRAGMA page_size</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA parser_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA 동기식 = FULL;</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">PRAGMA temp_store_directory = ''</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">결과를 반환하고 부작용이없는 PRAGMA는 일반 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에서 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 로 액세스 할 수 있습니다 . 참여하는 각 PRAGMA에 대해 해당 테이블 반환 함수의 이름은 7 자리 &quot;pragma_&quot;로 PRAGMA와 동일합니다. PRAGMA 인수 및 스키마 (있는 경우)는 테이블 반환 함수에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">기본 키 제약</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">페이지 1 및 예상 페이지 크기</target>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">데이터베이스 파일의 1 페이지는 완전한 데이터베이스 스키마를 저장하는 &quot;sqlite_master&quot;(또는 TEMP 데이터베이스의 경우 &quot;sqlite_temp_master&quot;)라는 특수 테이블을 보유하는 테이블 b- 트리의 루트 페이지입니다. sqlite_master 테이블의 구조는 다음 SQL을 사용하여 작성된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">페이지 캐시</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">페이지 캐시 알고리즘</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">페이지 캐시 구성</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">범용 메모리 할당 자로 오버 플로우되는 페이지 캐시 메모리 할당.</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">페이지 번호</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">첫 번째 오버 플로우 페이지의 페이지 번호</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">좌익의 페이지 수</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">첫 번째 프리리스트 트렁크 페이지의 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">페이지 캐시 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">호출기 및 btree 하위 시스템이 제거되었습니다. 이들은 &quot;SQLus&quot;라는 후속 SQL Server 라이브러리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">호출기 서브 시스템이 추가되었지만 아직 사용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">페이지는 최대 페이지 수는 2,147,483,646 (2, 1로 시작하는 번호가 &lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). 최소 크기 SQLite 데이터베이스는 단일 512 바이트 페이지입니다. 최대 크기 데이터베이스는 페이지 당 65536 바이트 또는 140,737,488,224,256 바이트 (약 140 테라 바이트)에서 2147483646 페이지입니다. 일반적으로 SQLite는 자체 내부 크기 제한에 도달하기 전에 기본 파일 시스템 또는 디스크 하드웨어의 최대 파일 크기 제한에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">매개 변수 P4는 테이블 구조를 가리 키거나 NULL 일 수 있습니다. NULL이 아닌 경우 성공적인 삽입 후 update-hook (sqlite3.xUpdateCallback)이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">zDb 매개 변수는 데이터베이스를 포함하는 파일 이름이 아니라 데이터베이스의 기호 이름입니다. 접속 된 데이터베이스의 경우, 이는 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 나타나는 이름입니다 . 기본 데이터베이스 파일의 경우 데이터베이스 이름은 &quot;main&quot;입니다. TEMP 테이블의 경우 데이터베이스 이름은 &quot;temp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">zDb 매개 변수는 데이터베이스를 포함하는 파일 이름이 아니라 데이터베이스의 기호 이름입니다. 접속 된 데이터베이스의 경우, 이는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 나타나는 이름입니다 . 기본 데이터베이스 파일의 경우 데이터베이스 이름은 &quot;main&quot;입니다. TEMP 테이블의 경우 데이터베이스 이름은 &quot;temp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">매개 변수는 이름을 지정하거나 이름을 지정할 수 없습니다. 명명되지 않은 매개 변수는 단일 물음표 ( &quot;?&quot;)입니다. 명명 된 매개 변수는 &quot;?&quot; 바로 뒤에 숫자 (예 : &quot;? 15&quot;또는 &quot;? 123&quot;) 또는 &quot;$&quot;, &quot;:&quot;또는 &quot;@&quot;문자 중 하나 다음에 영숫자 이름 (예 : &quot;$ var1&quot;, &quot;: xyz &quot;,&quot;@bingo &quot;).</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()를&lt;/a&gt; 사용하여 값이 지정되지 않은 매개 변수는 NULL로 처리됩니다. &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 인터페이스는 동등한 숫자 인덱스로 상징적 파라미터 명을 변환하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">부모 키와 자식 키는 동일한 카디널리티를 가져야합니다. SQLite에서 하위 키 열 (이 경우 songartist 및 songalbum)이 NULL이면 상위 테이블의 해당 행에 대한 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">부모 테이블</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">열 이름 주위의 괄호는 무시됩니다. 따라서 X와 YZ가 열 이름 인 경우 (X)와 (YZ)도 열 이름으로 간주되며 해당 열의 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">괄호는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">일반적인 방법으로 연산자 우선 순위를 수정하기 위해 괄호를 사용하여 표현식을 그룹화 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">외래 키를 구문 분석합니다 (구현하지는 않음).</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">파서는 자동 스택 오버플로를 감지하고보고합니다.</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">모호성 파싱</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">부분 인덱스로 인해 UPDATE OR REPLACE에서 어설 션 오류가 발생합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이후 부분 인덱스가 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">인덱스 별 부분 정렬</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED를&lt;/a&gt; 사용하여 뮤텍스 사용을 부분적으로 또는 완전히 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">! =, IS, IS NOT, NOT NULL 및 IS NULL 제한 조건에 대한 &lt;a href=&quot;vtab#xbestindex&quot;&gt;정보&lt;/a&gt; 를 가상 테이블 의 xBestIndex 메소드에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">포인터가 정수 또는 BLOB 인 것처럼 포인터를 전달하는 것은 쉽고 효과적이며 응용 프로그램 구성 요소가 서로 친숙한 환경에서 잘 작동합니다. 그러나 포인터를 정수 및 BLOB로 전달하면 악의적 인 SQL 텍스트가 잘못된 포인터를 생성하여 장난을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">이 기능에 0을 전달하면 세션이 비활성화됩니다. 0보다 큰 값을 전달하면 활성화됩니다. 0보다 작은 값을 전달하는 것은 작동하지 않으며 세션의 현재 상태를 쿼리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">패치 릴리스는 문제에 따라 릴리스 체크리스트가 있거나 없을 수 있습니다. 이것은 프로젝트 리더의 판단입니다.</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Christian Werner의 패치로 ODBC 호환성을 개선하고 round () 함수의 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">테이블 b- 트리 데이터 또는 인덱스 b- 트리 키 중 하나 인 페이로드는 항상 &quot;레코드 형식&quot;입니다. 레코드 형식은 테이블 또는 인덱스의 열에 해당하는 일련의 값을 정의합니다. 레코드 형식은 열 수, 각 열의 데이터 유형 및 각 열의 내용을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">보류중인 명령문은 더 이상 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK을&lt;/a&gt; 차단하지 않습니다 . 대신, ROLLBACK 이후에 다음에 액세스 할 때 보류중인 명령문은 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">사람들은 종종 SQLite가 다른 사람들처럼 &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; 버전 제어 시스템을 사용하지 않는 이유를 궁금해 합니다. 이 기사는 그 질문에 대한 답변을 시도합니다. 또한 &lt;a href=&quot;#getthecode&quot;&gt;섹션 3&lt;/a&gt; 에서이 기사는 Git 사용자에게 SQLite 소스 코드에 쉽게 액세스 할 수있는 방법에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">SQL을 이해하는 사람들은 &lt;a href=&quot;cli&quot;&gt;sqlite3 명령 줄 셸&lt;/a&gt; (또는 다양한 타사 SQLite 액세스 프로그램)을 사용하여 큰 데이터 집합을 분석 할 수 있습니다. 원시 데이터는 CSV 파일에서 가져올 수 있으며, 그 데이터를 슬라이스하고 잘라서 무수한 요약 보고서를 생성 할 수 있습니다. 보다 복잡한 분석은 Tcl 또는 Python (둘 다 SQLite 내장으로 제공됨) 또는 R 또는 다른 언어로 작성된 간단한 스크립트를 사용하여 쉽게 사용할 수있는 어댑터를 사용하여 수행 할 수 있습니다. 웹 사이트 로그 분석, 스포츠 통계 분석, 프로그래밍 메트릭 편집 및 실험 결과 분석이 가능합니다. 많은 생물 정보학 연구자들이 이런 식으로 SQLite를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">P1 데이터베이스에서 증분 진공 절차의 단일 단계를 수행하십시오. 진공이 완료되면 지침 P2로 이동하십시오. 그렇지 않으면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">필요한 외래 키 작업을 수행하고</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">두 번이 아닌 단일 번으로 일부 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">성능 관련 가정</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">성능을 향상시킬 수 있도록 크기가 감소 &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt; , &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; , &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt; , &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE을&lt;/a&gt; , &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt; , &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt; 및 &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt; . 이 모든 옵션을 함께 사용하면 성능이 약 3.5 % 향상되고 크기가 3.0 % 감소합니다.</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">메모리 매핑 된 I / O로 성능이 항상 향상되는 것은 아닙니다. 실제로 메모리 매핑 된 I / O를 사용하여 성능이 저하되는 테스트 사례를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">성능 향상 : 가변 길이 정수를 해석하고 렌더링하는 데 사용되는 내부 루틴을 리엔지니어링하십시오.</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬의&lt;/a&gt; 성능 향상 생성 파서</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">VDBE, 특히 OP_Column opcode에 대한 성능 향상.</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">파서의 성능 향상</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">ORDER BY 및 CREATE INDEX에서 사용하는 분류기의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">일부 경우 COUNT (*)의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">디스크 I / O 감소를 통한 성능 향상 :</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">B-Tree 레이어의 트리 밸런싱 로직 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">성능 향상</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">성능 향상 : 상수 하위 표현식이 루프에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">성능 개선 : 여러 OP_Column opcode를 발행하는 대신 OP_Column의 결과가 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">성능 향상 : OP_IdxDelete opcode는 압축 해제 된 레코드를 사용하므로 삭제 된 각 인덱스 레코드마다 OP_MakeRecord opcode 호출이 하나 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">&quot;count (*)&quot;쿼리의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; , &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check의&lt;/a&gt; 성능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum의&lt;/a&gt; 성능 향상 , 특히 사용 가능한 페이지 수가 사용 가능 목록의 단일 트렁크 페이지에 적합한 것보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">LEMON 생성 파서의 성능 향상</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">파서, 호출기 및 WHERE 절 코드 생성기의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">쿼리 최적화 프로그램의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">성능 향상 라이브러리가 훨씬 빨라졌습니다.</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">성능 측정은 단일 컴파일러 (gcc 5.4.0), 최적화 설정 (-Os) 및 단일 플랫폼 (x64의 Ubuntu 16.04 LTS)에서 수행됩니다. 다른 컴파일러와 프로세서의 성능은 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">단일 SQLite 사용자로부터 특정 사용 사례를 대상으로하는 성능 최적화 Valgrind로 측정 한대로 CPU 작동 수를 12 % 줄였습니다. 실제로 실제 성능 향상은 작업 부하에 따라 달라질 수 있습니다. 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX를&lt;/a&gt; 사용하여 개발주기 후반에도 성능 문제를 해결할 수있어 비용이 많이 드는 재 설계, 재 작성 및 재검사 노력을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">cachegrind를 사용하여 speedtest1을 실행하고 &quot;I refs&quot;출력을 관찰하여 성능을 측정했습니다.</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">SQLite의 일반적인 작업 부하를 모방하려는 &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; 유틸리티 프로그램을 사용하여 성능을 측정했습니다 . 테스트 실행 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">아마도 SQL92에서 다음 명령문을 참조하고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">FROM 절없이 SELECT 문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">순열 제목 색인</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">지속적인로드 가능한 확장</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">구문 및 NEAR 쿼리는 행 내 여러 열에 걸쳐 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">구문 쿼리</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">구문 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">문구 및 NEAR 그룹은 &lt;b&gt;암시 적 AND 연산자&lt;/b&gt; 로 연결될 수도 있습니다 . 간단히하기 위해 위의 BNF 문법에는 표시되지 않습니다. 기본적으로 공백으로 만 분리 된 모든 구문 또는 NEAR 그룹 (지정된 열과 일치하는 것으로 제한되는 것을 포함)은 각 쌍의 구문 또는 NEAR 그룹간에 암시 적 AND 연산자가있는 것처럼 처리됩니다. 암시 적 AND 연산자는 괄호로 묶은 식 뒤에 또는 앞에 삽입되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">구문 및 NEAR 그룹은 &lt;b&gt;부울 연산자를&lt;/b&gt; 사용하여 표현식으로 배열 될 수 있습니다 . 우선 순위가 가장 높은 그룹 (가장 엄격한 그룹)에서 가장 낮은 그룹 (가장 낮은 그룹)까지 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">다양한 루프의 중첩 순서 따기</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">중첩 순서를 선택하는 것이 일반적으로 더 어려운 문제입니다. 조인의 중첩 순서가 설정되면 일반적으로 각 루프에 대한 인덱스 선택이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">데이터베이스 페이지 고정 (읽기)</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Windows에서 바이러스 스캐너로 더 잘 재생</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">포인터가에서 반환 된 사실에 특히주의하십시오 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; 에 대한 후속 호출에 의해 무효화 될 수 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">포인터가에서 반환 된 사실에 특히주의하십시오 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; 에 대한 후속 호출에 의해 무효화 될 수 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">malloc ()이 실패한 경우 발생하는 메모리 누수를 연결하십시오. malloc ()이 작동하는 한 메모리 누수가없는 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">포인터 전달 인터페이스</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">포인터 누출</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">포인터 맵 또는 ptrmap 페이지는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 모드 작업을 보다 효율적으로 수행 할 수 있도록 데이터베이스에 추가 된 페이지 입니다. 데이터베이스의 다른 페이지 유형에는 일반적으로 부모에서 자식으로의 포인터가 있습니다. 예를 들어, 내부 b- 트리 페이지에는 하위 b- 트리 페이지에 대한 포인터가 포함되고 오버플로 체인에는 체인의 이전 링크에서 이후 링크까지의 포인터가 있습니다. ptrmap 페이지에는 하위에서 상위로 반대 방향으로 연결 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">포인터 타입</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">포인터 유형은 정적 문자열이며 다른 함수에서 전달 된 매개 변수가 아닌 SQLite API 호출에 직접 포함 된 문자열 리터럴이어야합니다. 정수 값을 포인터 유형으로 사용하는 것을 고려했지만 정적 문자열은 훨씬 더 큰 이름 공간을 제공하여 관련없는 확장간에 우발적 인 유형 이름 충돌 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; 의해 생성 된 포인터 값 은 순수 SQL로 읽을 수 없습니다. 따라서 SQL이 포인터 값을 유출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">포인터 값은 중간 연산자 나 함수없이 생산자에서 소비자에게 직접 전달되어야합니다. 포인터 값을 변환하면 포인터가 삭제되고 값이 일반 SQL NULL로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()로&lt;/a&gt; 읽은 포인터 값 은 순수 SQL로 생성 할 수 없습니다. 따라서 SQL에서 포인터를 위조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">포인터는 정수 또는 BLOB와 같은 다른 SQL 데이터 유형으로 인코딩하여 교환 해서는 &lt;u&gt;안됩니다&lt;/u&gt; . 대신 보안 포인터 전달을 용이하게하도록 설계된 인터페이스 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">SQLite를 새로운 운영 체제로 포팅</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">btree에 새 항목을 추가하기 위해 btree 끝에 커서 P1을 놓습니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">I / O를 완전히 피할 수 있기를 바랍니다. 가능한 한 오랫동안 TEMP 파일과 연관된 I / O를 연기하십시오.</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">전력 안전 덮어 쓰기</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">프라 그마 목록</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">SQLite가 지원하는 Pragma 문</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">이름이있다하는 pragma &lt;s&gt;을 통해 당했다&lt;/s&gt; 되지 않습니다. 사용하지 마십시오. 역사적 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">그리스도의 사랑 안에서 원수들을 위해기도하십시오.</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">그리스도의 사랑 이상을 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">접두사 인덱스는 두 가지 경우에 &lt;a href=&quot;fts3#termprefix&quot;&gt;접두사 쿼리&lt;/a&gt; 를 최적화하는 데 사용될 수 있습니다 . 쿼리의 접두사가 N 바이트 인 경우 &quot;prefix = N&quot;으로 만든 접두사 인덱스는 최상의 최적화를 제공합니다. 또는 &quot;prefix = N&quot;색인을 사용할 수없는 경우 &quot;prefix = N + 1&quot;색인을 대신 사용할 수 있습니다. &quot;prefix = N + 1&quot;인덱스를 사용하는 것은 &quot;prefix = N&quot;인덱스보다 효율적이지 않지만 접두어 인덱스가없는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">접두사 쿼리</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">FTS3의 접두사 검색이 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">깃발 준비</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">준비된 명세서 객체</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">준비된 명령문 스캔 상태</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">준비된 명령문 스캔 상태 Opcode</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">준비된 진술서 상태</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">값을 지정된 너비로 확장하려면 필요한만큼 숫자 대체에 &quot;0&quot;문자를 추가하십시오. 너비 필드가 생략되면이 플래그는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">&quot; &lt;code&gt;file:&lt;/code&gt; &quot;체계를 앞에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">방금 추출한 단일 행이 재귀 테이블의 유일한 행인 것으로 가정하고 모든 결과를 큐에 추가하여 재귀 선택을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">대규모 트랜잭션에서 저널 파일 오버 플로우를 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">기본 결과 코드 기호 이름은 &quot;SQLITE_XXXXXX&quot;형식이며 여기서 XXXXXX는 대문자 알파벳 순서입니다. 확장 결과 코드 이름은 &quot;SQLITE_XXXXXX_YYYYYYY&quot;형식이며 여기서 XXXXXX 부분은 해당 기본 결과 코드이고 YYYYYYY는 결과 코드를 추가로 분류하는 확장입니다.</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">기본 및 확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">오류가 발생하면 문제가되는 SQL 문을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이전에 SQLite는 최상의 쿼리 계획을 검색 할 때 항상 &quot;가장 가까운 이웃&quot;또는 &quot;NN&quot;휴리스틱을 사용했습니다. NN 휴리스틱은 그래프의 단일 순회를 수행하여 항상 다음 단계로 가장 저렴한 아크를 선택합니다. NN 휴리스틱은 대부분의 경우 놀랍도록 잘 작동합니다. 그리고 NN은 빠르기 때문에 SQLite는 대규모 64 웨이 조인에 대한 좋은 계획을 신속하게 찾을 수 있습니다. 반대로,보다 광범위한 검색을 수행하는 다른 SQL 데이터베이스 엔진은 조인의 테이블 수가 10 또는 15를 초과 할 때 멈춤 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">SQLite 3.20.0 (2017-08-01) 이전에는 모든 날짜 / 시간 함수가 항상 비 결정적인 것으로 간주되었습니다. 인수에 따라 날짜 / 시간 함수가 결정적이고 때로는 결정적이지 않은 기능이 3.20.0 릴리스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">SQLite 3.7.15 (2012-12-12) 이전에는 FROM 절의 하위 쿼리가 외부 쿼리로 병합되거나 외부 쿼리가 시작되기 전에 하위 쿼리가 완료 될 때까지 하위 쿼리가 실행됩니다. 임시 테이블에 저장된 다음 외부 쿼리에 임시 테이블이 사용됩니다. 최신 버전의 SQLite에는 공동 루틴을 사용하여 하위 쿼리를 구현하는 세 번째 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;버전 3.11.0&lt;/a&gt; (2016-02-15) 이전에 fts3_tokenzer ()에 대한 인수는 리터럴 문자열 또는 BLOB 일 수 있습니다. &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수를 바인딩&lt;/a&gt; 할 필요는 없습니다 . 그러나 이로 인해 SQL 삽입시 보안 문제가 발생할 수 있습니다. 따라서 레거시 동작은 이제 기본적으로 비활성화되어 있습니다. 그러나 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0) 를 호출하여 실제로 필요한 응용 프로그램에서 이전 버전과의 호환성을 위해 이전 레거시 동작을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; (2009-08-10) 이전에는 가상 테이블 메커니즘이 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 자체 데이터베이스 스키마 사본을 유지 한다고 가정합니다 . 따라서 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 사용 가능한 데이터베이스에서 가상 테이블 메커니즘을 사용할 수 없습니다 . &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 경우 인터페이스는 오류를 반환 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 활성화됩니다. 이 제한은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; 부터 완화 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11) 이전에는 재귀 트리거가 지원되지 않았습니다. SQLite의 동작은 항상이 pragma가 OFF로 설정된 것처럼 작동했습니다. 재귀 트리거에 대한 지원은 버전 3.6.18에서 추가되었지만 호환성을 위해 기본적으로 기본적으로 해제되어 있습니다. 이후 버전의 SQLite에서는 기본적으로 재귀 트리거가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11) 이전에는 트리거가 재귀 적이 지 않았 으므로이 한계는 의미가 없었습니다. 버전 3.6.18부터 재귀 트리거가 지원되었지만 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; 문을 사용하여 명시 적으로 활성화해야했습니다 . 를 시작으로 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2009-09-11), 재귀 트리거는 기본적으로 활성화되어 있지만, 수동으로 사용하지 않도록 설정할 수 있습니다 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA의 RECURSIVE_TRIGGERS을&lt;/a&gt; . SQLITE_MAX_TRIGGER_DEPTH는 재귀 트리거가 활성화 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">SQLite 버전 3.17.0 이전에는 세션 확장이 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID&lt;/a&gt; 테이블이 아닌 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서만 작동했습니다 . 3.17.0부터 rowid 및 WITHOUT ROWID 테이블이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">SQLite 버전 3.3.14 이전에는 모든 경우에 512 바이트의 섹터 크기가 가정되었습니다. 이것을 변경하는 컴파일 타임 옵션이 있었지만 코드는 더 큰 값으로 테스트되지 않았습니다. 512 바이트 섹터 가정은 최근까지 모든 디스크 드라이브가 512 바이트 섹터를 내부적으로 사용했기 때문에 합리적으로 보였다. 그러나 최근 디스크의 섹터 크기를 4096 바이트로 늘리려는 시도가있었습니다. 또한 플래시 메모리의 섹터 크기는 일반적으로 512 바이트보다 큽니다. 이러한 이유로 3.3.14로 시작하는 SQLite 버전에는 OS 파일 계층에 기본 파일 시스템을 조사하여 실제 섹터 크기를 찾는 방법이 있습니다. 현재 구현 된 (버전 3.5.0)이 방법은 여전히 ​​하드 코딩 된 512 바이트 값을 반환합니다. Unix 또는 Windows에서 실제 섹터 크기를 검색하는 표준 방법이 없기 때문입니다.그러나이 방법은 임베디드 디바이스 제조업체가 자신의 필요에 따라 조정할 수 있습니다. 그리고 향후 Unix 및 Windows에서보다 의미있는 구현을 작성할 가능성을 열어 놓았습니다.</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.7.10 이전의 Windows OS 인터페이스 계층은 SQLite에서 사용하는 UTF-8 인코딩과 특정 Windows 설치에서 사용되는 파일 이름 인코딩간에 파일 이름을 변환 할 때 시스템 malloc () 및 free ()를 직접 호출했습니다. 메모리 할당 오류가 감지되었지만 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 대신 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 또는 SQLITE_IOERR &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;로보고되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.7.10 이전의 Windows OS 인터페이스 계층은 SQLite에서 사용하는 UTF-8 인코딩과 특정 Windows 설치에서 사용되는 파일 이름 인코딩간에 파일 이름을 변환 할 때 시스템 malloc () 및 free ()를 직접 호출했습니다. 메모리 할당 오류가 감지되었지만 &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 대신 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 또는 SQLITE_IOERR &lt;a href=&quot;../rescode#nomem&quot;&gt;로보고되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">SQLite 버전 3.8.2 (2013-12-06) 이전에는 +9223372036854775807.0보다 큰 REAL 값을 정수로 캐스트하면 가장 음의 정수인 -9223372036854775808이 발생했습니다. 이 동작은 동등한 캐스트를 수행 할 때 x86 / x64 하드웨어의 동작을 에뮬레이션하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">SQLite 소스 트리에 체크인 할 때마다 개발자는 일반적으로 약 248.5 천 개의 테스트 사례로 구성된 Tcl 테스트의 하위 집합 ( &quot;매우 빠른&quot;)을 실행합니다. 매우 빠른 테스트에는 이상, 퍼지 및 흡수 테스트 이외의 대부분의 테스트가 포함됩니다. 매우 빠른 테스트의 기본 개념은 대부분의 오류를 포착하기에 충분하지만 몇 시간이 아니라 몇 분만에 실행될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">데이터베이스 파일을 변경하기 전에 SQLite는 먼저 별도의 롤백 저널 파일을 작성하고 롤백 저널에 변경 될 데이터베이스 페이지의 원래 컨텐츠를 씁니다. 롤백 저널의 기본 개념은 데이터베이스를 원래 상태로 복원하는 데 필요한 모든 정보를 포함한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">데이터베이스 파일 자체를 변경하기 전에 데이터베이스 파일에 대한 독점 잠금을 얻어야합니다. 독점 잠금을 얻는 것은 실제로 두 단계 프로세스입니다. 첫 번째 SQLite는 &quot;보류중인&quot;잠금을 얻습니다. 그런 다음 보류중인 잠금을 독점 잠금으로 에스컬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">버전 3.26.0 (2018-12-01) 이전에 이름이 바뀐 테이블에 대한 FOREIGN KEY 참조는 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt; 또는 다른 말로 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 이 적용된 경우에만 편집 되었습니다. 으로 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA의 foreign_keys = OFF는&lt;/a&gt; 외부 키가 (이하 &quot;라고하는 테이블 때, FOREIGN KEY 제약 조건이 변경되지 않을 것이다 &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;부모 테이블&lt;/a&gt; &quot;)로 변경되었습니다. 버전 3.26.0부터는 &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt; 설정을 사용 하지 않는 한 테이블 이름을 바꿀 때 FOREIGN KEY 제약 조건이 항상 변환됩니다 . 다음 표는 차이점을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 함수는 sqlite3_release_memory () 호출과 동일한 스레드에서 모든 데이터베이스 연결에서 메모리를 회수하려고 시도했습니다. 버전 3.5.0부터 sqlite3_release_memory () 함수는 모든 스레드의 모든 데이터베이스 연결에서 메모리를 회수하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 는 단일 스레드 내의 모든 데이터베이스 연결에 대한 힙 메모리 사용량의 상한을 설정했습니다. 각 스레드에는 자체 힙 제한이있을 수 있습니다. 버전 3.5.0부터 전체 프로세스에 대한 단일 힙 한계가 있습니다. 이것은 더 제한적인 것처럼 보이지만 (많은 사용자와 달리 한 가지 제한) 실제로는 대부분의 사용자가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; API는 단일 스레드 내의 모든 연결에 대해 공유 캐시 기능을 사용 및 사용 안함으로 설정했습니다. sqlite3_enable_shared_cache () 루틴이 호출 된 동일한 스레드입니다. 공유 캐시를 사용하는 데이터베이스 연결은 열린 동일한 스레드에서 실행되도록 제한되었습니다. 버전 3.5.0부터 sqlite3_enable_shared_cache ()는 프로세스 내의 모든 스레드에있는 모든 데이터베이스 연결에 적용됩니다. 이제 별도의 스레드에서 실행되는 데이터베이스 연결이 캐시를 공유 할 수 있습니다. 공유 캐시를 사용하는 데이터베이스 연결은 한 스레드에서 다른 스레드로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">프로세스 A는 이제 데이터베이스에 쓰려고합니다. 그러나 프로세스 B가 프로세스 A가 데이터베이스 파일을 읽은 후 데이터베이스 파일을 수정했기 때문에 프로세스 A의 데이터베이스 컨텐츠보기가 더 이상 사용되지 않습니다. 따라서 프로세스 A는 SQLITE_BUSY_SNAPSHOT 오류를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">프로세스 A는 데이터베이스에서 읽기 트랜잭션을 시작하고 하나 이상의 SELECT 문을 수행합니다. 프로세스 A는 트랜잭션을 열린 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">프로세스 B는 데이터베이스를 업데이트하여 프로세스 A가 이전에 읽은 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">group_concat () SQL 함수를 제품화하고 공식적으로 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">PGO (프로필 안내 최적화)는 SQLite에서 도움이되지 않습니다. PGO는 이진이 약 1 % 더 크고 약 0.33 % 더 느립니다.</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">프로파일 링은 대부분의 시스템 및 대부분의 환경에서 SQLite가 디스크 I / O를 수행하는 데 대부분의 시간을 소비한다는 것을 나타냅니다. 디스크 I / O의 양을 줄이기 위해 할 수있는 일은 SQLite의 성능에 큰 긍정적 인 영향을 줄 것입니다. 이 섹션에서는 원자 커밋을 유지하면서 디스크 I / O의 양을 최소로 줄이기 위해 SQLite에서 사용하는 일부 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">프로그래머는 이전 글 머리표에서 설명한 두 가지 예외를 사용하지 않도록주의해야합니다. 우리는 그것들이 존재하기 때문에 오래되고 잘못 구성된 SQL 문이 올바르게 실행되도록 강조합니다. 이후 버전의 SQLite는 위의 예외에서 다루는 잘못된 형식의 문장을 받아들이지 않고 오류를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">프로그래머는 JOIN, INNER JOIN, NATURAL JOIN 또는 &quot;,&quot;조인 대신 CROSS JOIN 연산자를 사용하여 SQLite가 조인에 특정 루프 중첩 순서를 사용하도록 할 수 있습니다. CROSS JOIN은 이론적으로는 정식 적이지만 SQLite는 CROSS JOIN에서 테이블을 다시 정렬하지 않도록 선택합니다. 따라서 CROSS JOIN의 왼쪽 테이블은 항상 오른쪽 테이블을 기준으로 외부 루프에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">로드 가능한 확장 프로그램 프로그래밍</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">프로그램은 첫 번째 opcode로이 opcode의 단일 인스턴스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check에 &lt;/a&gt;&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA 기능&lt;/a&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">커서 P1에 P4의 Expr을 만족시키는 행만 리턴해야한다는 힌트를 제공하십시오. P4 표현식의 TK_REGISTER 용어는 현재 레지스터에 보유 된 값을 나타냅니다. P4 표현식의 TK_COLUMN 용어는 커서 P1이 가리키는 b- 트리의 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">sqlite_master 테이블에 CREATE TABLE AS 문이 포함 된 경우 적절한 오류 메시지를 제공하십시오. 이전에는 어설 션 오류 또는 널 포인터 역 참조가 발생했습니다. GDAL 프로젝트에서 OSSFuzz가 발견 한 문제점. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; 플래그를 제공하고 이를 사용 하여 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장에&lt;/a&gt; 의한 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리&lt;/a&gt; 오용 을 제한 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">제공 &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; SQL 기능을하는 수익률로 컴파일 할 때 기록을 보유 값 X의 시작 부분에 데이터베이스 파일에 바이트 오프셋 &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 대한 SQL 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil 버전 제어 시스템&lt;/a&gt; 에서 단일 체크인으로 모든 파일에 대한 정보를 제공합니다 . 이 가상 테이블은 SQLite 프로젝트의 일부가 아니지만 가상 테이블 사용 방법의 예를 제공하고 SQLite 소스의 버전 제어를 돕는 데 사용되기 때문에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">데이터베이스 파일에서 각 페이지의 목적 및 사용에 대한 정보를 제공합니다. &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; 유틸리티 프로그램 의 구현에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">의사 난수 생성기</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmap 페이지는 데이터베이스 헤더의 오프셋 52에서 0이 아닌 가장 큰 루트 b- 트리 페이지 값을 가진 데이터베이스 파일에 있어야합니다. 가장 큰 루트 b- 트리 페이지 값이 0이면 데이터베이스에 ptrmap 페이지가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">더티 페이지 퍼지</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">다음 &quot;물건&quot;을 스택으로 밀어 넣고 밀어 넣을 다음 &quot;물건&quot;이 있는지 여부에 따라 P2로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">모든 식별자 이름을 큰 따옴표 안에 넣습니다. 이것은 식별자 이름을 이스케이프하는 공식 SQL 방법입니다.</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="translated">식별자 이름을 [...] 안에 넣으십시오. 이것은 표준 SQL은 아니지만 SQL Server가 수행하는 방식이므로 많은 프로그래머가이 기술을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">&quot; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &quot;행 바로 뒤에 매크로 &quot; &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; &quot;을 한 줄에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">하나님 께 희망을 두십시오.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">품질 관리</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">SQLite의 품질 보증은 컴파일러 경고 또는 기타 정적 코드 분석 도구가 아닌 &lt;a href=&quot;testing#coverage&quot;&gt;전체 범위 테스트를&lt;/a&gt; 사용하여 수행됩니다 . 다시 말해, 우리는 SQLite가 단순히 문체 적 제약을 만족시키는 것이 아니라 정답을 얻는다는 것을 확인합니다. 대부분의 SQLite 코드 기반은 순전히 테스트에 전념합니다. SQLite 테스트 스위트는 수만 건의 개별 테스트 사례를 실행하며 이러한 테스트 사례 중 다수는 매개 변수화되어 수십억 개의 SQL 문과 관련된 수억 건의 테스트가 실행되고 모든 릴리스 전에 정확성을 평가합니다. 개발자는 코드 범위 도구를 사용하여 코드를 통한 모든 경로가 테스트되었는지 확인합니다. SQLite에서 버그가 발견 될 때마다 버그를 나타 내기 위해 새로운 테스트 사례가 작성되므로 나중에 버그를 발견 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">품질 관리 문서는 읽을 수없는 전문 용어로 가득 찬 바인더로 확장되는 경향이 있습니다. 이 문서는 간결하고 유용하여 해당 패턴을 깨기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">WHERE 절에 베어 geopoly_overlap () 또는 geopoly_within () 함수가 포함 된 쿼리 (및 DELETE 및 UPDATE 문)는 기본 R * Tree 데이터 구조를 사용하여 행의 서브 세트 만 검사하면되는 빠른 검색을 수행합니다. 탁자. 검사 할 행 수는 물론 $ query_polygon의 크기에 따라 다릅니다. 큰 $ query_polygons는 일반적으로 작은 것보다 더 많은 행을보아야합니다.</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">그래프에 대한 쿼리</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">지오 폴리 테이블의 rowid에 대한 쿼리는 행 수가 많은 테이블의 경우에도 매우 빠릅니다. 그러나 보조 데이터 열은 인덱스가 아니므로 보조 데이터 열에 대한 쿼리에는 전체 테이블 스캔이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">&quot;SELECT max (x), y FROM table&quot;형식의 쿼리는 최대 x 값이 포함 된 동일한 행에서 y 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">인수가 인덱스의 가장 왼쪽 열인 단일 MIN () 또는 MAX () 집계 함수를 포함하는 쿼리는 전체 테이블을 스캔하지 않고 단일 인덱스 조회를 수행하여 충족 될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">하위 쿼리가 포함 된 쿼리는 때때로 하위 쿼리를 개별적으로 평가하고 결과를 임시 테이블에 저장 한 다음 임시 테이블의 내용을 사용하여 외부 쿼리를 평가해야합니다. 이것을 하위 쿼리를 &quot;구체화&quot;한다고합니다. SQLite의 쿼리 최적화 프로그램은 구체화를 피하려고 시도하지만 때로는 쉽게 피할 수 없습니다. 구체화에 의해 작성된 임시 테이블은 각각 ​​별도의 임시 파일에 저장되며 쿼리가 완료되면 자동으로 삭제됩니다. 이러한 임시 테이블의 크기는 물론 하위 쿼리의 구체화에있는 데이터의 양에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">ORDER BY 및 LIMIT를 사용하는 쿼리는 이제 LIMIT 아래에 들어갈 수없는 행을 계산하지 않습니다. 이는 특히 제한이없는 출력 행 수에 비해 LIMIT가 작은 경우 ORDER BY LIMIT 쿼리의 성능을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">SQLite가 이해하는 쿼리 언어</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">쿼리 플래너</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">쿼리 계획</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">쿼리 진행 콜백</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">준비된 명령문에 대한 EXPLAIN 설정 조회</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">플래 튼 쿼리</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">쿼리 병합은 뷰의 각 사용이 하위 쿼리로 변환 될 때 뷰가 사용될 때 중요한 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">현재 행 내에서 구문 일치 iIdx의 세부 사항을 쿼리하십시오. 구문 검색은 0부터 시작하여 번호가 매겨 지므로 iIdx 인수는 0보다 크거나 같아야하며 xInstCount ()가 출력 한 값보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">쿼리 최적화 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">쿼리 최적화 기능 개선 :</target>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">count-changes 플래그를 조회하거나 변경하십시오. 일반적으로 count-changes 플래그가 설정되지 않은 경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문은 데이터를 리턴하지 않습니다. count-changes가 설정되면 이러한 각 명령은 하나의 정수 값 (명령으로 삽입, 수정 또는 삭제 된 행 수)으로 구성된 단일 데이터 행을 리턴합니다. 반환 된 변경 수에는 트리거에 의해 수행 된 삽입, 수정 또는 삭제, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업에&lt;/a&gt; 의해 자동으로 수행 된 변경 또는 &lt;a href=&quot;lang_upsert&quot;&gt;upsert로&lt;/a&gt; 인한 업데이트가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">empty-result-callbacks 플래그를 조회하거나 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">full_column_names 플래그를 조회하거나 변경하십시오. &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; 플래그 와 함께이 플래그는 SQLite가 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 열에 이름을 지정하는 방법을 결정합니다 . 결과 열은 다음 규칙을 순서대로 적용하여 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업을 위한 fullfsync 플래그를 쿼리하거나 변경합니다 . 이 플래그가 설정되면 F_FULLFSYNC를 지원하는 시스템에서 검사 점 작업 중에 F_FULLFSYNC 동기화 방법이 사용됩니다. checkpoint_fullfsync 플래그의 기본값은 해제입니다. Mac OS-X 만 F_FULLFSYNC를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">fullfsync 플래그를 조회하거나 변경하십시오. 이 플래그는 F_FULLFSYNC 동기화 방법이이를 지원하는 시스템에서 사용되는지 여부를 결정합니다. fullfsync 플래그의 기본값은 해제입니다. Mac OS X 만 F_FULLFSYNC를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">단일 데이터베이스에서 메모리 매핑 된 I / O를 위해 설정된 최대 바이트 수를 쿼리하거나 변경하십시오. 첫 번째 형식 (인수없이)은 현재 제한을 쿼리합니다. 두 번째 형식 (숫자 인수 포함)은 지정된 데이터베이스 또는 선택적 데이터베이스 이름이 생략 된 경우 모든 데이터베이스에 대한 한계를 설정합니다. 두 번째 양식에서 데이터베이스 이름이 생략되면, 설정된 한계는 후속 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문에 의해 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 추가되는 모든 데이터베이스의 기본 한계가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b3761ba731b4ca68bda2cd1e8fe9ffa86d5d2f0" translate="yes" xml:space="preserve">
          <source>Query or change the secure-delete setting. When secure_delete is on, SQLite overwrites deleted content with zeros. The default setting for secure_delete is determined by the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option and is normally off. The off setting for secure_delete improves performance by reducing the number of CPU cycles and the amount of disk I/O. Applications that wish to avoid leaving forensic traces after content is deleted or updated should enable the secure_delete pragma prior to performing the delete or update, or else run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; after the delete or update.</source>
          <target state="translated">보안 삭제 설정을 조회하거나 변경하십시오. secure_delete가 설정되면 SQLite는 삭제 된 내용을 0으로 덮어 씁니다. secure_delete의 기본 설정은 &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; 컴파일 타임 옵션에 의해 결정되며 일반적으로 해제되어 있습니다. secure_delete의 꺼짐 설정은 CPU주기 수와 디스크 I / O 양을 줄임으로써 성능을 향상시킵니다. 컨텐츠를 삭제하거나 업데이트 한 후 포렌식 추적을 남기지 않으려는 애플리케이션은 삭제 또는 업데이트를 수행하기 전에 secure_delete pragma를 활성화하거나 삭제 또는 업데이트 후에 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="de56ca3e30c1c074a1fd98f6d3fdce5680f699b3" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;&lt;b&gt;temp_store&lt;/b&gt;&quot; parameter. When temp_store is DEFAULT (0), the compile-time C preprocessor macro &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; is used to determine where temporary tables and indices are stored. When temp_store is MEMORY (2) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are kept in as if they were pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; memory. When temp_store is FILE (1) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are stored in a file. The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma can be used to specify the directory containing temporary files when &lt;b&gt;FILE&lt;/b&gt; is specified. When the temp_store setting is changed, all existing temporary tables, indices, triggers, and views are immediately deleted.</source>
          <target state="translated">&quot; &lt;b&gt;temp_store&lt;/b&gt; &quot;매개 변수 의 설정을 조회하거나 변경하십시오 . temp_store가 DEFAULT (0) 인 경우 컴파일 타임 C 프리 프로세서 매크로 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 를 사용하여 임시 테이블 및 인덱스가 저장되는 위치를 결정합니다. temp_store가 MEMORY (2) 인 경우 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스는 순수한 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 메모리 인 것처럼 유지됩니다 . temp_store가 FILE (1) 인 경우 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스는 파일에 저장됩니다. &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma는 경우 임시 파일을 포함하는 디렉토리를 지정하는 데 사용할 수있는 &lt;b&gt;파일을&lt;/b&gt; 지정합니다. temp_store 설정이 변경되면 기존의 모든 임시 테이블, 인덱스, 트리거 및 뷰가 즉시 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb005d9ab4e0804f12c87dee002073b411d274d" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;synchronous&quot; flag. The first (query) form will return the synchronous setting as an integer. The second form changes the synchronous setting. The meanings of the various synchronous settings are as follows:</source>
          <target state="translated">&quot;동기&quot;플래그 설정을 조회하거나 변경하십시오. 첫 번째 (쿼리) 형식은 동기 설정을 정수로 반환합니다. 두 번째 형식은 동기 설정을 변경합니다. 다양한 동기 설정의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dcfcd54b0505cd09f50244da9bbd756766eef81" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;busy timeout&lt;/a&gt;. This pragma is an alternative to the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; C-language interface which is made available as a pragma for use with language bindings that do not provide direct access to &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;통화 중 시간 초과&lt;/a&gt; 설정을 쿼리하거나 변경합니다 . 이 pragma는 대안입니다 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 에 직접 액세스 제공하지 않는 언어 바인딩과 함께 사용할 수있는 프라 그마로 사용할 수 있습니다 C 언어 인터페이스 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6f0cf05490ce574881ff5675cbd192d91cf992" translate="yes" xml:space="preserve">
          <source>Query or change the short-column-names flag. This flag affects the way SQLite names columns of data returned by &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. See the &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma for full details.</source>
          <target state="translated">short-column-names 플래그를 조회하거나 변경하십시오. 이 플래그는 SQLite가 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에서 반환 한 데이터 열의 이름을 지정하는 방식에 영향을줍니다 . 자세한 내용은 &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c472dc3fc7ff36d8acee51946b1687ac08bd59fe" translate="yes" xml:space="preserve">
          <source>Query or change the suggested maximum number of database disk pages that SQLite will hold in memory at once per open database file. Whether or not this suggestion is honored is at the discretion of the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;Application Defined Page Cache&lt;/a&gt;. The default page cache that is built into SQLite honors the request, however alternative application-defined page cache implementations may choose to interpret the suggested cache size in different ways or to ignore it all together. The default suggested cache size is -2000, which means the cache size is limited to 2048000 bytes of memory. The default suggested cache size can be altered using the &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; compile-time options. The TEMP database has a default suggested cache size of 0 pages.</source>
          <target state="translated">SQLite가 열린 데이터베이스 파일 당 한 번에 메모리에 보유 할 제안 된 최대 데이터베이스 디스크 페이지 수를 조회하거나 변경하십시오. 이 제안이 적용되는지 여부는 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;응용 프로그램 정의 페이지 캐시&lt;/a&gt; 의 재량에 따릅니다 . SQLite에 기본 제공되는 기본 페이지 캐시는 요청을 받아들이지 만 대체 응용 프로그램 정의 페이지 캐시 구현은 제안 된 캐시 크기를 다른 방식으로 해석하거나 함께 무시하도록 선택할 수 있습니다. 기본 제안 된 캐시 크기는 -2000이며, 이는 캐시 크기가 2048000 바이트의 메모리로 제한됨을 의미합니다. 기본 제안 된 캐시 크기는 &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; 컴파일 시간 옵션을 사용하여 변경할 수 있습니다. TEMP 데이터베이스의 기본 제안 된 캐시 크기는 0 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="38317b0c0d1df51bd83790ce312ba13da0c5ed05" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable, which windows operating-system interface backends use to determine where to store database files specified using a relative pathname.</source>
          <target state="translated">Windows 운영 체제 인터페이스 백엔드가 상대 경로 이름을 사용하여 지정된 데이터베이스 파일을 저장할 위치를 결정하는 데 사용 하는 &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 글로벌 변수 의 값을 조회하거나 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="f61590ed5a58a97ecca18f3fbb40bf0ae63fb037" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) limit for the current database connection. This limit sets an upper bound on the number of auxiliary threads that a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is allowed to launch to assist with a query. The default limit is 0 unless it is changed using the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option. When the limit is zero, that means no auxiliary threads will be launched.</source>
          <target state="translated">현재 데이터베이스 연결 에 대한 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; , ...) 한계 값을 쿼리하거나 변경하십시오 . 이 한계는 쿼리를 지원하기 위해 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 실행할 수있는 보조 스레드 수의 상한을 설정 합니다. &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; 컴파일 타임 옵션을 사용하여 변경하지 않는 한 기본 한계는 0 입니다. 한계가 0이면 보조 스레드가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ad35fae3f5b98f4ef0cd9485074046877d96539" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable, which many operating-system interface backends use to determine where to store &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices.</source>
          <target state="translated">많은 운영 체제 인터페이스 백엔드가 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스 를 저장할 위치를 결정하는 데 사용 하는 &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 글로벌 변수 의 값을 쿼리하거나 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5866fac6602f3e40c19df259ea318d2b63caf2bd" translate="yes" xml:space="preserve">
          <source>Query or set the auto-vacuum status in the database.</source>
          <target state="translated">데이터베이스에서 자동 진공 상태를 조회하거나 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cc5d0ecc46bacf93e04d7b7978224221ecdf262" translate="yes" xml:space="preserve">
          <source>Query or set the maximum number of pages in the database file. Both forms of the pragma return the maximum page count. The second form attempts to modify the maximum page count. The maximum page count cannot be reduced below the current database size.</source>
          <target state="translated">데이터베이스 파일의 최대 페이지 수를 쿼리하거나 설정하십시오. pragma의 두 가지 형식 모두 최대 페이지 수를 반환합니다. 두 번째 양식은 최대 페이지 수 수정을 시도합니다. 최대 페이지 수는 현재 데이터베이스 크기 아래로 줄어들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b4e54fcf1e120591a5a6535bff6e2b69b86d7df" translate="yes" xml:space="preserve">
          <source>Query or set the page size of the database. The page size must be a power of two between 512 and 65536 inclusive.</source>
          <target state="translated">데이터베이스의 페이지 크기를 쿼리하거나 설정하십시오. 페이지 크기는 512에서 65536 사이의 2의 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="627a1950bccb0926f06969a3db2d136c3cabdca5" translate="yes" xml:space="preserve">
          <source>Query planner checklist</source>
          <target state="translated">쿼리 플래너 체크리스트</target>
        </trans-unit>
        <trans-unit id="e93c39912e396551e04ed9b46c1ea823e2d8b3bb" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - automatic transient indices are created when doing so reduces the estimated query time.</source>
          <target state="translated">쿼리 플래너 향상-자동 임시 색인이 작성되면 예상 쿼리 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="15e2bd2467aae946e711f6cc5ade007f83eb3c87" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - the ORDER BY becomes a no-op if the query also contains a GROUP BY clause that forces the correct output order.</source>
          <target state="translated">쿼리 플래너 향상-쿼리에 올바른 출력 순서를 강제하는 GROUP BY 절이 포함되어 있으면 ORDER BY가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26786d5880615e168b7819292d8f2bd689ef42b3" translate="yes" xml:space="preserve">
          <source>Query planner enhancement: Use the transitive property of constraints to move constraints into the outer loops of a join whenever possible, thereby reducing the amount of work that needs to occur in inner loops.</source>
          <target state="translated">쿼리 플래너 향상 : 제한 조건의 전이 특성을 사용하여 가능할 때마다 제한 조건을 결합의 외부 루프로 이동하여 내부 루프에서 발생해야하는 작업량을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="736e85cef8966360d93b45933c07771905d6a0b9" translate="yes" xml:space="preserve">
          <source>Query planner enhancements.</source>
          <target state="translated">쿼리 플래너 향상</target>
        </trans-unit>
        <trans-unit id="c7e16cd25b99db12dc36d4eb42e08d056acec1b1" translate="yes" xml:space="preserve">
          <source>Query planner enhancements:</source>
          <target state="translated">쿼리 플래너 향상 :</target>
        </trans-unit>
        <trans-unit id="b2b452d242e61d8f7480bffaae127bf001921fa3" translate="yes" xml:space="preserve">
          <source>Query planner stability guarantee</source>
          <target state="translated">쿼리 플래너 안정성 보장</target>
        </trans-unit>
        <trans-unit id="ca5891ff28346fccc5150a605b02b68689910ebb" translate="yes" xml:space="preserve">
          <source>Query planners are what make SQL database engines so amazingly useful and powerful. (This is true of all SQL database engines, not just SQLite.) The query planner frees the programmer from the chore of selecting a particular query plan, and thereby allows the programmer to focus more mental energy on higher-level application issues and on providing more value to the end user. For simple queries where the choice of query plan is obvious, this is convenient but not hugely important. But as applications and schemas and queries grow more complex, a clever query planner can greatly speed and simplify the work of application development. There is amazing power in being about to tell the database engine what content is desired, and then let the database engine figure out the best way to retrieve that content.</source>
          <target state="translated">쿼리 플래너는 SQL 데이터베이스 엔진을 매우 유용하고 강력하게 만드는 요소입니다. (이는 SQLite뿐만 아니라 모든 SQL 데이터베이스 엔진에도 적용됩니다.) 쿼리 플래너는 프로그래머가 특정 쿼리 계획을 선택해야하는 번거 로움을 없애고 프로그래머가 더 높은 수준의 응용 프로그램 문제 및 제공에 정신적 에너지를 집중할 수 있도록합니다. 최종 사용자에게 더 많은 가치. 쿼리 계획의 선택이 명백한 간단한 쿼리의 경우 편리하지만 크게 중요하지는 않습니다. 그러나 응용 프로그램과 스키마 및 쿼리가 더욱 복잡 해짐에 따라 영리한 쿼리 플래너는 응용 프로그램 개발 작업을 크게 가속화하고 단순화 할 수 있습니다. 데이터베이스 엔진에 원하는 컨텐츠를 알려주고 데이터베이스 엔진이 해당 컨텐츠를 검색하는 가장 좋은 방법을 찾도록하는 놀라운 힘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee854629ae78a2199bdb56da8e286e6006b5d8d" translate="yes" xml:space="preserve">
          <source>Query results are returned as a list of column values. If a query requests 2 columns and there are 3 rows matching the query, then the returned list will contain 6 elements. For example:</source>
          <target state="translated">쿼리 결과는 열 값 목록으로 반환됩니다. 쿼리가 2 개의 열을 요청하고 쿼리와 일치하는 3 개의 행이 있으면 반환 된 목록에 6 개의 요소가 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cb7820ab431080267a59361b01e9af99b0f2f7" translate="yes" xml:space="preserve">
          <source>Query, set, or clear READ UNCOMMITTED isolation. The default isolation level for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except between connections that share a common page and schema cache. Cache sharing is enabled using the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API. Cache sharing is disabled by default.</source>
          <target state="translated">커밋되지 않은 읽기 격리를 쿼리, 설정 또는 지 웁니다. SQLite의 기본 격리 수준은 SERIALIZABLE입니다. 모든 프로세스 또는 스레드는 커밋되지 않은 읽기 격리를 선택할 수 있지만 공통 페이지와 스키마 캐시를 공유하는 연결을 제외하고는 SERIALIZABLE이 계속 사용됩니다. 캐시 공유는 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; API를 사용하여 활성화 됩니다. 캐시 공유는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0366bdd9a4ae5e944fbf6092ddc8900d9aeaaed5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; capability.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱싱&lt;/a&gt; 기능을 쿼리, 설정 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="14ccb18dde2fc34367c93b804727ccf1143765e5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 의 적용을 쿼리, 설정 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="160bfb7a8121ce10fe672d852b6ba0dcf536c5e1" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the recursive trigger capability.</source>
          <target state="translated">재귀 트리거 기능을 쿼리, 설정 또는 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="bf0ed56a136cbe5ffad095931c71813d09f0273f" translate="yes" xml:space="preserve">
          <source>Questions and confusion quickly arose on the &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about the purpose behind these new interfaces, why they were introduced, and what problem they solve. This essay attempts to answer those questions and clear up the confusion.</source>
          <target state="translated">이러한 새로운 인터페이스의 목적, 도입 된 이유 및 해결되는 문제 에 대한 &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;메일 링리스트&lt;/a&gt; 에서 질문과 혼란이 빠르게 일어났습니다 . 이 에세이는 이러한 질문에 답하고 혼란을 해결하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6fb0e0d11a03f78b5ecb2f7f8b42ef10b6e101e0" translate="yes" xml:space="preserve">
          <source>Questions like these (and countless others) can be answered without having to uncompress or extract any content.</source>
          <target state="translated">내용을 압축 해제하거나 추출 할 필요없이 이러한 질문 (및 수많은 다른 질문)에 답변 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09a7d1d2da3256534f8a2a26b3d747dbae8b2a14" translate="yes" xml:space="preserve">
          <source>Quirks, Caveats, and Gotchas In SQLite</source>
          <target state="translated">SQLite의 Quirks, Caveats 및 Gotchas</target>
        </trans-unit>
        <trans-unit id="9432058147a91a2c4afeff95adc17f4930b4c6b9" translate="yes" xml:space="preserve">
          <source>R (cost: 3.56)</source>
          <target state="translated">R (비용 : 3.56)</target>
        </trans-unit>
        <trans-unit id="37abd4d23bc413fb5db77feee86f46ad0b861e2d" translate="yes" xml:space="preserve">
          <source>R*Tree Module</source>
          <target state="translated">R * 트리 모듈</target>
        </trans-unit>
        <trans-unit id="43ea99300f03323c6239855a57c58f91be6c0d63" translate="yes" xml:space="preserve">
          <source>R-N1 (cost: 7.03)</source>
          <target state="translated">R-N1 (비용 : 7.03)</target>
        </trans-unit>
        <trans-unit id="00f923142bbc27eb285a9f64b857d908b86719d8" translate="yes" xml:space="preserve">
          <source>R-N1-C (cost: 13.43)</source>
          <target state="translated">R-N1-C (비용 : 13.43)</target>
        </trans-unit>
        <trans-unit id="f743ed80cd4af3e3dd6aaa0242ee69bf26b480c0" translate="yes" xml:space="preserve">
          <source>R-N1-N2 (cost: 12.55)</source>
          <target state="translated">R-N1-N2 (비용 : 12.55)</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
