<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="08b6cbcabbd6e71be72f53afc70af79412d77457" translate="yes" xml:space="preserve">
          <source>SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;version 3.8.2&lt;/a&gt; (2013-12-06) or later is necessary in order to use a WITHOUT ROWID table. An attempt to open a database that contains one or more WITHOUT ROWID tables using an earlier version of SQLite will result in a &quot;malformed database schema&quot; error.</source>
          <target state="translated">WITHOUT ROWID 테이블을 사용하려면 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_2.html&quot;&gt;버전 3.8.2&lt;/a&gt; (2013-12-06) 이상이 필요합니다. 이전 버전의 SQLite를 사용하여 하나 이상의 WITHOUT ROWID 테이블이 포함 된 데이터베이스를 열려고하면 &quot;잘못된 데이터베이스 스키마&quot;오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3e86e2833db1abf49e8061aaa2cd583e95133d97" translate="yes" xml:space="preserve">
          <source>SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;treats the CROSS JOIN operator specially&lt;/a&gt;. The CROSS JOIN operator is commutative in theory. But SQLite chooses to never reorder tables in a CROSS JOIN. This provides a mechanism by which the programmer can force SQLite to choose a particular loop nesting order.</source>
          <target state="translated">SQLite &lt;a href=&quot;lang_select#crossjoin&quot;&gt;는 CROSS JOIN 연산자를 특별히 취급합니다&lt;/a&gt; . CROSS JOIN 연산자는 이론적으로 정식입니다. 그러나 SQLite는 CROSS JOIN에서 테이블을 다시 정렬하지 않도록 선택합니다. 이것은 프로그래머가 SQLite가 특정 루프 중첩 순서를 선택하도록 할 수있는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0bbb7536ee31c5a80721eae98fa10519f1ad8533" translate="yes" xml:space="preserve">
          <source>SQLite And 8+3 Filenames</source>
          <target state="translated">SQLite 및 8 + 3 파일 이름</target>
        </trans-unit>
        <trans-unit id="e2d4ce9c3b2bbe3c99f8642fe06d326e27f53052" translate="yes" xml:space="preserve">
          <source>SQLite Archive</source>
          <target state="translated">SQLite 아카이브</target>
        </trans-unit>
        <trans-unit id="1c2e4c767e501295b07044a0be089e468b1c54e4" translate="yes" xml:space="preserve">
          <source>SQLite Archive Files</source>
          <target state="translated">SQLite 아카이브 파일</target>
        </trans-unit>
        <trans-unit id="d2b4826d6cd13e751ecf395b030c78611c772164" translate="yes" xml:space="preserve">
          <source>SQLite Archive smaller than ZIP</source>
          <target state="translated">ZIP보다 작은 SQLite 아카이브</target>
        </trans-unit>
        <trans-unit id="51574f80326ace266a8bf5040636cb259e147450" translate="yes" xml:space="preserve">
          <source>SQLite As An Application File Format</source>
          <target state="translated">응용 프로그램 파일 형식으로서의 SQLite</target>
        </trans-unit>
        <trans-unit id="a2eb63f481d4cfa9928a76da8d2a3e4d7f83d8bb" translate="yes" xml:space="preserve">
          <source>SQLite As The Application File Format</source>
          <target state="translated">응용 프로그램 파일 형식으로 SQLite</target>
        </trans-unit>
        <trans-unit id="4a3178c3074df690a5eb7e97c76ac53d45c44383" translate="yes" xml:space="preserve">
          <source>SQLite Assumptions About Powersafe Overwrite</source>
          <target state="translated">Powersafe 덮어 쓰기에 대한 SQLite 가정</target>
        </trans-unit>
        <trans-unit id="049b16eaba216715a3e362ab05145ec23c0b6c0b" translate="yes" xml:space="preserve">
          <source>SQLite Autoincrement</source>
          <target state="translated">SQLite 자동 증가</target>
        </trans-unit>
        <trans-unit id="08111684d7d4e09683b29110ad3d644fa9e33310" translate="yes" xml:space="preserve">
          <source>SQLite Backup API</source>
          <target state="translated">SQLite 백업 API</target>
        </trans-unit>
        <trans-unit id="ad0e7df52748eecbc45730ba392651b98c724763" translate="yes" xml:space="preserve">
          <source>SQLite C/C++ Reference Guide</source>
          <target state="translated">SQLite C / C ++ 참조 안내서</target>
        </trans-unit>
        <trans-unit id="c92de27dd7389ec46eb38a11b845ea569a381c7d" translate="yes" xml:space="preserve">
          <source>SQLite Changes From Version 3.4.2 To 3.5.0</source>
          <target state="translated">SQLite가 버전 3.4.2에서 3.5.0으로 변경됨</target>
        </trans-unit>
        <trans-unit id="25c3be734136db1baee77887da69941fe29aa884" translate="yes" xml:space="preserve">
          <source>SQLite Changes From Version 3.5.9 To 3.6.0</source>
          <target state="translated">버전 3.5.9에서 3.6.0으로의 SQLite 변경</target>
        </trans-unit>
        <trans-unit id="0444fc9f22bced4b2fff02fcfbe554ed7b1e5072" translate="yes" xml:space="preserve">
          <source>SQLite Database Speed Comparison</source>
          <target state="translated">SQLite 데이터베이스 속도 비교</target>
        </trans-unit>
        <trans-unit id="7b8f472af0032f55957a6dc12f85bfe03df14036" translate="yes" xml:space="preserve">
          <source>SQLite Documentation</source>
          <target state="translated">SQLite 설명서</target>
        </trans-unit>
        <trans-unit id="6ff713ff03124b24b867fcfe6378512d75f45ff5" translate="yes" xml:space="preserve">
          <source>SQLite FTS3 and FTS4 Extensions</source>
          <target state="translated">SQLite FTS3 및 FTS4 확장</target>
        </trans-unit>
        <trans-unit id="bb8dd4cb69443f463263e0baaae53f90fbc24c8e" translate="yes" xml:space="preserve">
          <source>SQLite FTS5 Extension</source>
          <target state="translated">SQLite FTS5 확장</target>
        </trans-unit>
        <trans-unit id="2224f0faf91f0a51e1ba8f1cbb3ab37f2f712c36" translate="yes" xml:space="preserve">
          <source>SQLite File Database File Format</source>
          <target state="translated">SQLite 파일 데이터베이스 파일 형식</target>
        </trans-unit>
        <trans-unit id="6eac80f01ebeadc3031650b9aefac516bf6e0bbd" translate="yes" xml:space="preserve">
          <source>SQLite File IO Specification</source>
          <target state="translated">SQLite 파일 IO 사양</target>
        </trans-unit>
        <trans-unit id="77914a1b06d12241c0755a61b1c00302dcab6be7" translate="yes" xml:space="preserve">
          <source>SQLite Foreign Key Support</source>
          <target state="translated">SQLite 외래 키 지원</target>
        </trans-unit>
        <trans-unit id="f65ccb959ceb3f4521413d9bdfa153476f97acaf" translate="yes" xml:space="preserve">
          <source>SQLite Frequently Asked Questions</source>
          <target state="translated">SQLite 자주 묻는 질문</target>
        </trans-unit>
        <trans-unit id="e852f86b5d09751d115407b22c097c26c15c6357" translate="yes" xml:space="preserve">
          <source>SQLite In 5 Minutes Or Less</source>
          <target state="translated">5 분 이내에 SQLite</target>
        </trans-unit>
        <trans-unit id="2fbb8bccf7dd8ebcb5b1089562fd0f1493f23b68" translate="yes" xml:space="preserve">
          <source>SQLite Is A Zero-Configuration Database</source>
          <target state="translated">SQLite는 제로 구성 데이터베이스입니다</target>
        </trans-unit>
        <trans-unit id="166abc8c6f5c5da769b2d025b705df20e04ef92a" translate="yes" xml:space="preserve">
          <source>SQLite Is Serverless</source>
          <target state="translated">SQLite는 서버리스입니다</target>
        </trans-unit>
        <trans-unit id="6b3190a178d6342f9ee76ff056763fdb914c2573" translate="yes" xml:space="preserve">
          <source>SQLite Is Transactional</source>
          <target state="translated">SQLite는 트랜잭션입니다</target>
        </trans-unit>
        <trans-unit id="3ee672eb31b5447a08bacf0b40a3605a0b7bc619" translate="yes" xml:space="preserve">
          <source>SQLite Keywords</source>
          <target state="translated">SQLite 키워드</target>
        </trans-unit>
        <trans-unit id="a0504f17f4504d78de525defd78c85fa4ac14446" translate="yes" xml:space="preserve">
          <source>SQLite Library Footprint</source>
          <target state="translated">SQLite 라이브러리 공간</target>
        </trans-unit>
        <trans-unit id="2b61cfd89697cf1e4c1606af934cf897a3a7e3c3" translate="yes" xml:space="preserve">
          <source>SQLite Runtime Status</source>
          <target state="translated">SQLite 런타임 상태</target>
        </trans-unit>
        <trans-unit id="d2298bad6251daf42a2fd57b3cda73107d61fb64" translate="yes" xml:space="preserve">
          <source>SQLite Session Module C/C++ Interface</source>
          <target state="translated">SQLite 세션 모듈 C / C ++ 인터페이스</target>
        </trans-unit>
        <trans-unit id="299b38a2c54499cac63ea1735d0f8e2caaea9a18" translate="yes" xml:space="preserve">
          <source>SQLite Shared-Cache Mode</source>
          <target state="translated">SQLite 공유 캐시 모드</target>
        </trans-unit>
        <trans-unit id="677c15838e15871697707715489f6e66e916c277" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: aggregate-function-invocation</source>
          <target state="translated">SQLite 구문 : 집계 함수 호출</target>
        </trans-unit>
        <trans-unit id="4691dc8275b1b7dcdfb4a74a779f10a2ef5bbd95" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: alter-table-stmt</source>
          <target state="translated">SQLite 구문 : alter-table-stmt</target>
        </trans-unit>
        <trans-unit id="f5b6c872a84846a12015354c09cd6f7d86efd461" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: analyze-stmt</source>
          <target state="translated">SQLite 구문 : analyze-stmt</target>
        </trans-unit>
        <trans-unit id="684b2229f95587114a6593fd80991f4423d34aa8" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: attach-stmt</source>
          <target state="translated">SQLite 구문 : attach-stmt</target>
        </trans-unit>
        <trans-unit id="f3514b2655ab967d1d4d9c40e5e30807c7435ade" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: begin-stmt</source>
          <target state="translated">SQLite 구문 : begin-stmt</target>
        </trans-unit>
        <trans-unit id="c6cf986e37b92e0f71e4f25c33898b1f0f45dbcd" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: column-constraint</source>
          <target state="translated">SQLite 구문 : 열 제약</target>
        </trans-unit>
        <trans-unit id="eba9dd23d84d7e9bc75755c88603e6ac71390578" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: column-def</source>
          <target state="translated">SQLite 구문 : column-def</target>
        </trans-unit>
        <trans-unit id="ae4bf7f9ac99e8a57e0ac8bbb59715b46801a120" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: column-name-list</source>
          <target state="translated">SQLite 구문 : column-name-list</target>
        </trans-unit>
        <trans-unit id="35991e0b4057b986eeadf0cc45c155dc0f91c65a" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: comment-syntax</source>
          <target state="translated">SQLite 구문 : 주석 구문</target>
        </trans-unit>
        <trans-unit id="f2e0ac0ef89c375d83c5b1384036f5b2516b9307" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: commit-stmt</source>
          <target state="translated">SQLite 구문 : commit-stmt</target>
        </trans-unit>
        <trans-unit id="95d23da3bee6078ef612231be1cfa8f10f805f2e" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: common-table-expression</source>
          <target state="translated">SQLite 구문 : common-table-expression</target>
        </trans-unit>
        <trans-unit id="039c1612ed78696f89317565d7e41d051338a692" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: compound-operator</source>
          <target state="translated">SQLite 구문 : 복합 연산자</target>
        </trans-unit>
        <trans-unit id="728336d6ce396fb5d1623d810ae16f2b0450b6c0" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: compound-select-stmt</source>
          <target state="translated">SQLite 구문 : compound-select-stmt</target>
        </trans-unit>
        <trans-unit id="bb9e3604a676499a26de3609f97318d6f24b71ed" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: conflict-clause</source>
          <target state="translated">SQLite 구문 : conflict-clause</target>
        </trans-unit>
        <trans-unit id="0443bffb822656183f2a577ef7880a0d4bd82031" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: create-index-stmt</source>
          <target state="translated">SQLite 구문 : create-index-stmt</target>
        </trans-unit>
        <trans-unit id="708dc5d9fd291c969b1bd2640875f8d92f5e9f11" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: create-table-stmt</source>
          <target state="translated">SQLite 구문 : create-table-stmt</target>
        </trans-unit>
        <trans-unit id="303fde63f397da7c4f8cbb6017ecd31afaf4ddfb" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: create-trigger-stmt</source>
          <target state="translated">SQLite 구문 : create-trigger-stmt</target>
        </trans-unit>
        <trans-unit id="b8fb6d35aab37ca2af3cdac57b071efd02d6924c" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: create-view-stmt</source>
          <target state="translated">SQLite 구문 : create-view-stmt</target>
        </trans-unit>
        <trans-unit id="b4889bbb657490dfcf4c3f5ba65751a10e51e723" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: create-virtual-table-stmt</source>
          <target state="translated">SQLite 구문 : create-virtual-table-stmt</target>
        </trans-unit>
        <trans-unit id="76067026e43105f05d6bff642ac214381ad9922a" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: cte-table-name</source>
          <target state="translated">SQLite 구문 : cte-table-name</target>
        </trans-unit>
        <trans-unit id="91e0a17a4c4f2bf18fcffb5ebc2e0e3a2cdf8562" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: delete-stmt</source>
          <target state="translated">SQLite 구문 : delete-stmt</target>
        </trans-unit>
        <trans-unit id="9d4d0e69a4f08fa8640faffc0b2d4299f162f2b7" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: delete-stmt-limited</source>
          <target state="translated">SQLite 구문 : delete-stmt-limited</target>
        </trans-unit>
        <trans-unit id="e90497d8998fdb3ccb26a77962c7bbcbf635bde9" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: detach-stmt</source>
          <target state="translated">SQLite 구문 : detach-stmt</target>
        </trans-unit>
        <trans-unit id="91195854864f792e27abec14d3537b15c279bb14" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: drop-index-stmt</source>
          <target state="translated">SQLite 구문 : drop-index-stmt</target>
        </trans-unit>
        <trans-unit id="85347359e1b4766f91b51c95ced69b0f3029b8b0" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: drop-table-stmt</source>
          <target state="translated">SQLite 구문 : drop-table-stmt</target>
        </trans-unit>
        <trans-unit id="621be33c7e22655bf397c677d9a95ce0336e9ff0" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: drop-trigger-stmt</source>
          <target state="translated">SQLite 구문 : 드롭 트리거 트리거</target>
        </trans-unit>
        <trans-unit id="855719862278805238899aaa962a1d7f018de7d9" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: drop-view-stmt</source>
          <target state="translated">SQLite 구문 : drop-view-stmt</target>
        </trans-unit>
        <trans-unit id="067a126b6088641ddc4fdcfa3722e62011bb4f51" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: expr</source>
          <target state="translated">SQLite 구문 : expr</target>
        </trans-unit>
        <trans-unit id="9f140fca538ac6edd7ef2eee0de838e80a2d449e" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: factored-select-stmt</source>
          <target state="translated">SQLite 구문 : factored-select-stmt</target>
        </trans-unit>
        <trans-unit id="27f6b600e670fe7c00dc0b08eb62b4d324c84033" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: filter-clause</source>
          <target state="translated">SQLite 구문 : filter-clause</target>
        </trans-unit>
        <trans-unit id="ba88876d319af8f2577df00c41efe0395f45bff9" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: foreign-key-clause</source>
          <target state="translated">SQLite 구문 : foreign-key-clause</target>
        </trans-unit>
        <trans-unit id="fd9de54f1cc00c8e574ac8953ad69298071208e7" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: frame-spec</source>
          <target state="translated">SQLite 구문 : frame-spec</target>
        </trans-unit>
        <trans-unit id="87d64c023e5e381103487db80f2868b5978714a7" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: indexed-column</source>
          <target state="translated">SQLite 구문 : 인덱스 열</target>
        </trans-unit>
        <trans-unit id="3d4594d2848b2394bbefe5ea8217cc7e3c76f672" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: insert-stmt</source>
          <target state="translated">SQLite 구문 : insert-stmt</target>
        </trans-unit>
        <trans-unit id="8577db36921d583cdcad51a5c03a4f6e97bffb21" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: join-clause</source>
          <target state="translated">SQLite 구문 : join-clause</target>
        </trans-unit>
        <trans-unit id="aba100e55d4db0adbf63a3bb9f3710458e0d827e" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: join-constraint</source>
          <target state="translated">SQLite 구문 : join-constraint</target>
        </trans-unit>
        <trans-unit id="16f1a5cc270acbe167090bf3cbafd62173aed97d" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: join-operator</source>
          <target state="translated">SQLite 구문 : 조인 연산자</target>
        </trans-unit>
        <trans-unit id="d0bc2ede668fa14ed80b38fa0115bfb1ec4cad31" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: literal-value</source>
          <target state="translated">SQLite 구문 : 리터럴 값</target>
        </trans-unit>
        <trans-unit id="d05cc0fdc4cf9429206e8f1323d48eb520a03d21" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: numeric-literal</source>
          <target state="translated">SQLite 구문 : 숫자 리터럴</target>
        </trans-unit>
        <trans-unit id="8bcdc034c5a8d5eea59002db151c0f81acb97578" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: ordering-term</source>
          <target state="translated">SQLite 구문 : 주문 기간</target>
        </trans-unit>
        <trans-unit id="664b6cb7705a6e43244b1416c9701b0b2b507bca" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: over-clause</source>
          <target state="translated">SQLite 구문 : 과절</target>
        </trans-unit>
        <trans-unit id="a238ba2cad4f605801c8b083f2572a2a958876d4" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: pragma-stmt</source>
          <target state="translated">SQLite 구문 : pragma-stmt</target>
        </trans-unit>
        <trans-unit id="81fe0e201877124c81cf3c039fede3b4583bfba3" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: pragma-value</source>
          <target state="translated">SQLite 구문 : pragma-value</target>
        </trans-unit>
        <trans-unit id="280eeaf5a048efcbfa18fbd4f149831662d48acd" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: qualified-table-name</source>
          <target state="translated">SQLite 구문 : 규정 된 테이블 이름</target>
        </trans-unit>
        <trans-unit id="e6ef0134a6bc4d48f79e0039c929d4d37c652dc3" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: raise-function</source>
          <target state="translated">SQLite 구문 : raise-function</target>
        </trans-unit>
        <trans-unit id="3a40e3d3c18f61cfd21291d4b84660edf656ce99" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: recursive-cte</source>
          <target state="translated">SQLite 구문 : 재귀 cte</target>
        </trans-unit>
        <trans-unit id="c1d248b2a2ba6dd3ea14e6a9d4d79ed7f94444cf" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: reindex-stmt</source>
          <target state="translated">SQLite 구문 : reindex-stmt</target>
        </trans-unit>
        <trans-unit id="a13d31221e9d4037f421a6d37ea073fc63b695b8" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: release-stmt</source>
          <target state="translated">SQLite 구문 : release-stmt</target>
        </trans-unit>
        <trans-unit id="f08276238d08e10966ddb10944ae99158c816126" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: result-column</source>
          <target state="translated">SQLite 구문 : 결과 열</target>
        </trans-unit>
        <trans-unit id="69fe7851d9b587098d2b17109c11dc725ff51b70" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: rollback-stmt</source>
          <target state="translated">SQLite 구문 : rollback-stmt</target>
        </trans-unit>
        <trans-unit id="cec796a9d19402e6e453aa86dc4dd4a673b51a97" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: savepoint-stmt</source>
          <target state="translated">SQLite 구문 : savepoint-stmt</target>
        </trans-unit>
        <trans-unit id="985f7fbb23c1934fca9c9349003183d72524c2d3" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: select-core</source>
          <target state="translated">SQLite 구문 : select-core</target>
        </trans-unit>
        <trans-unit id="ce29139f5831e2f5e82346f67a1f683a7627f040" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: select-stmt</source>
          <target state="translated">SQLite 구문 : select-stmt</target>
        </trans-unit>
        <trans-unit id="45300c89b269b19c7948d6c1e6bfc93bae6db7b3" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: signed-number</source>
          <target state="translated">SQLite 구문 : 부호있는 숫자</target>
        </trans-unit>
        <trans-unit id="e2dddad4353873534c5a965851be336502d4f375" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: simple-function-invocation</source>
          <target state="translated">SQLite 구문 : 단순 함수 호출</target>
        </trans-unit>
        <trans-unit id="e95eb7cbc0e5efb7cb3ea0b3ab2d164c6af1ea4b" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: simple-select-stmt</source>
          <target state="translated">SQLite 구문 : simple-select-stmt</target>
        </trans-unit>
        <trans-unit id="4c0ec00be423bb27ec90eee0603c0c511827c050" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: sql-stmt</source>
          <target state="translated">SQLite 구문 : sql-stmt</target>
        </trans-unit>
        <trans-unit id="6c5ec49d95e64968ffbc676a4ac0c92a033fdbfe" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: sql-stmt-list</source>
          <target state="translated">SQLite 구문 : sql-stmt-list</target>
        </trans-unit>
        <trans-unit id="e9188ff0476af5124a331c5defa406d27d25456e" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: table-constraint</source>
          <target state="translated">SQLite 구문 : 테이블 제약</target>
        </trans-unit>
        <trans-unit id="3004d1bb7f3075c9abc745d7922ef925affb2fa1" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: table-or-subquery</source>
          <target state="translated">SQLite 구문 : 테이블 또는 하위 쿼리</target>
        </trans-unit>
        <trans-unit id="560c464a694343364d8c50f76894aebe3f735689" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: type-name</source>
          <target state="translated">SQLite 구문 : type-name</target>
        </trans-unit>
        <trans-unit id="e649ec1aef1d598b439cb497e4a46afc39cbe73f" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: update-stmt</source>
          <target state="translated">SQLite 구문 : update-stmt</target>
        </trans-unit>
        <trans-unit id="06ff24e6ae0f0f3f737fc0fa722249611f0912bc" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: update-stmt-limited</source>
          <target state="translated">SQLite 구문 : update-stmt-limited</target>
        </trans-unit>
        <trans-unit id="544b5efeb28fe81cb603bc870933ca21b5f35890" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: upsert-clause</source>
          <target state="translated">SQLite 구문 : upsert-clause</target>
        </trans-unit>
        <trans-unit id="71070233d1585db4326c0f6451968d1c320c6cb9" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: vacuum-stmt</source>
          <target state="translated">SQLite 구문 : vacuum-stmt</target>
        </trans-unit>
        <trans-unit id="f1d004a43cadf321c4e18f1bbca885f5f177b4a4" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: window-defn</source>
          <target state="translated">SQLite 구문 : window-defn</target>
        </trans-unit>
        <trans-unit id="2a465aee6a993a25486e8c76e81ed49d1553ea4b" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: window-function-invocation</source>
          <target state="translated">SQLite 구문 : 창 함수 호출</target>
        </trans-unit>
        <trans-unit id="3b530b8fa9b84d9671440411981b99fb1eeb4e3f" translate="yes" xml:space="preserve">
          <source>SQLite Syntax: with-clause</source>
          <target state="translated">SQLite 구문 : with-clause</target>
        </trans-unit>
        <trans-unit id="8bfbbc2e777cd02dc1cf2d883ae13c1f62982d58" translate="yes" xml:space="preserve">
          <source>SQLite Test Harness #3 (hereafter &quot;TH3&quot;) is one of &lt;a href=&quot;testing#harnesses&quot;&gt;three test harnesses&lt;/a&gt; used for testing SQLite. TH3 meets the following objectives:</source>
          <target state="translated">SQLite 테스트 하니스 # 3 (이하 &quot;TH3&quot;)은 SQLite 테스트에 사용되는 &lt;a href=&quot;testing#harnesses&quot;&gt;세 가지 테스트 하네스&lt;/a&gt; 중 하나입니다 . TH3는 다음 목표를 충족합니다.</target>
        </trans-unit>
        <trans-unit id="c4c0058559ad2757e2f42dec76caf9ac8c7164ae" translate="yes" xml:space="preserve">
          <source>SQLite Unlock-Notify API</source>
          <target state="translated">SQLite 잠금 해제 알림 API</target>
        </trans-unit>
        <trans-unit id="a028956a99a12bd048e1eeff4723ada12456d471" translate="yes" xml:space="preserve">
          <source>SQLite Version 3 Overview</source>
          <target state="translated">SQLite 버전 3 개요</target>
        </trans-unit>
        <trans-unit id="bd96d83d414ccfb7bc5520b4ea64da03f619d463" translate="yes" xml:space="preserve">
          <source>SQLite Virtual File System</source>
          <target state="translated">SQLite 가상 파일 시스템</target>
        </trans-unit>
        <trans-unit id="6622991f94a6e3a971610a97b129a00df4671455" translate="yes" xml:space="preserve">
          <source>SQLite accepts both of the above. But, in an effort to be compatible with MySQL 3.x (which was one of the most widely used RDBMSes when SQLite was first being designed) SQLite will also interpret a double-quotes string as string literal if it does not match any valid identifier.</source>
          <target state="translated">SQLite는 위의 두 가지를 모두 허용합니다. 그러나 MySQL 3.x (SQLite가 처음 설계 될 때 가장 널리 사용되는 RDBMS 중 하나)와 호환되도록하기 위해 SQLite는 유효한 식별자와 일치하지 않으면 큰 따옴표 문자열을 문자열 리터럴로 해석합니다. .</target>
        </trans-unit>
        <trans-unit id="7969bc0ef72affc99d4e83ba233f43547794f858" translate="yes" xml:space="preserve">
          <source>SQLite accomplishes these goals using the following techniques:</source>
          <target state="translated">SQLite는 다음 기술을 사용하여 이러한 목표를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="93485e58ca6a1adc30eee7bf094d9254f1bee763" translate="yes" xml:space="preserve">
          <source>SQLite adds new keywords from time to time when it takes on new features. So to prevent your code from being broken by future enhancements, you should normally quote any identifier that is an English language word, even if you do not have to.</source>
          <target state="translated">SQLite는 새로운 기능을 수행 할 때마다 새로운 키워드를 추가합니다. 따라서 향후 개선 사항으로 인해 코드가 손상되지 않도록하려면 필요하지 않더라도 일반적으로 영어 단어 인 식별자를 인용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c35a475a7114c76d3815adf2008d8ab3592758e" translate="yes" xml:space="preserve">
          <source>SQLite allocates space to hold all host parameters between 1 and the largest host parameter number used. Hence, an SQL statement that contains a host parameter like ?1000000000 would require gigabytes of storage. This could easily overwhelm the resources of the host machine. To prevent excessive memory allocations, the maximum value of a host parameter number is SQLITE_MAX_VARIABLE_NUMBER, which defaults to 999 for SQLite versions prior to 3.32.0 (2020-05-22) or 32766 for SQLite versions after 3.32.0.</source>
          <target state="translated">SQLite는 1과 사용 된 가장 큰 호스트 매개 변수 번호 사이의 모든 호스트 매개 변수를 보유 할 공간을 할당합니다. 따라서? 1000000000과 같은 호스트 매개 변수가 포함 된 SQL 문에는 기가 바이트의 스토리지가 필요합니다. 이것은 쉽게 호스트 시스템의 리소스를 압도 할 수 있습니다. 과도한 메모리 할당을 방지하기 위해 호스트 매개 변수 번호의 최대 값은 SQLITE_MAX_VARIABLE_NUMBER이며, 3.32.0 (2020-05-22) 이전의 SQLite 버전의 경우 기본값은 999, 3.32.0 이후의 SQLite 버전의 경우 32766입니다.</target>
        </trans-unit>
        <trans-unit id="c1be33c93281691f32c1348190378d0671224738" translate="yes" xml:space="preserve">
          <source>SQLite allocates space to hold all host parameters between 1 and the largest host parameter number used. Hence, an SQL statement that contains a host parameter like ?1000000000 would require gigabytes of storage. This could easily overwhelm the resources of the host machine. To prevent excessive memory allocations, the maximum value of a host parameter number is SQLITE_MAX_VARIABLE_NUMBER, which defaults to 999.</source>
          <target state="translated">SQLite는 1과 사용 된 최대 호스트 매개 변수 번호 사이의 모든 호스트 매개 변수를 보유 할 공간을 할당합니다. 따라서? 1000000000과 같은 호스트 매개 변수를 포함하는 SQL 문에는 기가 바이트의 스토리지가 필요합니다. 이것은 호스트 시스템의 리소스를 쉽게 압도 할 수 있습니다. 과도한 메모리 할당을 방지하기 위해 호스트 매개 변수 번호의 최대 값은 SQLITE_MAX_VARIABLE_NUMBER이며 기본값은 999입니다.</target>
        </trans-unit>
        <trans-unit id="028432208e1a28c564db5004c2abbc25db803bf5" translate="yes" xml:space="preserve">
          <source>SQLite allows &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; to appear in an SQL statement anywhere that a literal value is allowed. The values for these parameters are set using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_...()&lt;/a&gt; family of APIs.</source>
          <target state="translated">SQLite를 사용 하면 리터럴 값이 허용되는 모든 위치에서 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바인딩 된 매개 변수&lt;/a&gt; 를 SQL 문에 표시 할 수 있습니다. 이 매개 변수의 값은 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind _... ()&lt;/a&gt; API 제품군을 사용하여 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="278782a5b168582474220ea63200b84c038c9dc8" translate="yes" xml:space="preserve">
          <source>SQLite allows &lt;a href=&quot;nulls&quot;&gt;NULL values&lt;/a&gt; to be stored in PRIMARY KEY columns. However, the session extension ignores all such rows. No changes affecting rows with one or more NULL values in PRIMARY KEY columns are recorded by the sessions module.</source>
          <target state="translated">SQLite를 사용하면 &lt;a href=&quot;nulls&quot;&gt;NULL 값&lt;/a&gt; 을 PRIMARY KEY 열에 저장할 수 있습니다. 그러나 세션 확장은 이러한 모든 행을 무시합니다. PRIMARY KEY 컬럼에서 하나 이상의 NULL 값을 가진 행에 영향을주는 변경 사항은 세션 모듈에 의해 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="884c046dfb4d83f0b2a502b3f7e63f5f14133cf1" translate="yes" xml:space="preserve">
          <source>SQLite allows NUL characters (ASCII 0x00, Unicode \u0000) in the middle of string values stored in the database. However, the use of NUL within strings can lead to surprising behaviors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ebacbcb8bf95caa1ee114063133ab4b95b55473" translate="yes" xml:space="preserve">
          <source>SQLite allows a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; wherever a string literal, numeric constant, or NULL is allowed. (Parameters may not be used for column or table names.) A &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; takes one of the following forms:</source>
          <target state="translated">SQLite는 문자열 리터럴, 숫자 상수 또는 NULL이 허용되는 경우 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 를 허용합니다. 열 또는 테이블 이름에는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수를&lt;/a&gt; 사용할 수 없습니다. 매개 변수 는 다음 형식 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5fdab0901a13bb73134edf1f5b43792bfd020d0d" translate="yes" xml:space="preserve">
          <source>SQLite allows a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; to talk to two or more database files simultaneously through the use of the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt; command. When multiple database files are modified within a single transaction, all files are updated atomically. In other words, either all of the database files are updated or else none of them are. Achieving an atomic commit across multiple database files is more complex that doing so for a single file. This section describes how SQLite works that bit of magic.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH DATABASE&lt;/a&gt; 명령을 사용하여 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 둘 이상의 데이터베이스 파일과 동시에 통신 할 수 있도록합니다 . 단일 트랜잭션 내에서 여러 데이터베이스 파일이 수정되면 모든 파일이 원자 적으로 업데이트됩니다. 다시 말해, 모든 데이터베이스 파일이 업데이트되거나 다른 파일이 없습니다. 여러 데이터베이스 파일에서 원자 커밋을 달성하는 것은 단일 파일의 경우보다 복잡합니다. 이 섹션에서는 SQLite가 그처럼 마술처럼 작동하는 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cc7a43eb476861ca4de0ab85bc340fdf021129ce" translate="yes" xml:space="preserve">
          <source>SQLite allows database files to have any desired filename extension, so an application can choose a custom filename extension for its own use, if desired. The &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; can be used to set an &quot;Application ID&quot; integer in the database file so that tools like &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;file(1)&lt;/a&gt; can determine that the file is associated with your application and is not just a generic SQL database.</source>
          <target state="translated">SQLite를 사용하면 데이터베이스 파일에 원하는 파일 이름 확장자를 사용할 수 있으므로 응용 프로그램은 원하는 경우 자체 용도로 사용자 정의 파일 이름 확장자를 선택할 수 있습니다. &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;APPLICATION_ID pragma는&lt;/a&gt; 같은 그 도구 있도록 데이터베이스 파일에서 &quot;응용 프로그램 ID&quot;정수 설정하는 데 사용할 수있는 &lt;a href=&quot;http://www.darwinsys.com/file/&quot;&gt;파일 (1)&lt;/a&gt; 파일이 응용 프로그램과 관련된 단지 일반적인 SQL 데이터베이스에없는 것을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dd980880596b1666ea5094593b639d4cc0c7ac5" translate="yes" xml:space="preserve">
          <source>SQLite allows row values to be expressed in two ways:</source>
          <target state="translated">SQLite를 사용하면 행 값을 두 가지 방식으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72c273d6d02f4047a096d5a6faa4aee763a76338" translate="yes" xml:space="preserve">
          <source>SQLite allows you to store BLOB data in any column, even columns that are declared to hold some other type. BLOBs can even be used as PRIMARY KEYs.</source>
          <target state="translated">SQLite를 사용하면 다른 유형을 보유하도록 선언 된 열을 포함하여 모든 열에 BLOB 데이터를 저장할 수 있습니다. BLOB는 기본 키로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a29650667127162de04d158b912a78c7b191fe0" translate="yes" xml:space="preserve">
          <source>SQLite also allows two or more SELECT statements to be joined as peers using operators UNION, UNION ALL, INTERSECT, and EXCEPT. These compound select statements are implemented using transient tables. The implementation is slightly different for each operator, but the basic ideas are the same. For an example we will use the EXCEPT operator.</source>
          <target state="translated">SQLite는 또한 UNION, UNION ALL, INTERSECT 및 EXCEPT 연산자를 사용하여 둘 이상의 SELECT 문을 피어로 조인 할 수 있습니다. 이 복합 선택문은 임시 테이블을 사용하여 구현됩니다. 구현은 각 운영자마다 약간 씩 다르지만 기본 아이디어는 동일합니다. 예를 들어 EXCEPT 연산자를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="637b40631e98becd08eb5f7d6c42ce3df54984ba" translate="yes" xml:space="preserve">
          <source>SQLite also maintains a hard upper bound on the mmap_size. Attempts to increase the mmap_size above this hard upper bound (using &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt;) will automatically cap the mmap_size at the hard upper bound. If the hard upper bound is zero, then memory mapped I/O is impossible. The hard upper bound can be set at compile-time using the &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; macro. If &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; is set to zero, then the code used to implement memory mapped I/O is omitted from the build. The hard upper bound is automatically set to zero on certain platforms (ex: OpenBSD) where memory mapped I/O does not work due to the lack of a unified buffer cache.</source>
          <target state="translated">SQLite는 또한 mmap_size에서 하드 상한을 유지합니다. &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size를&lt;/a&gt; 사용하여이 하드 상한보다 mmap_size를 늘리려 고하면 하드 상한에서 mmap_size를 자동으로 제한합니다. 하드 상한이 0이면 메모리 매핑 된 I / O가 불가능합니다. &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; 매크로를 사용하여 컴파일 타임에 하드 상한을 설정할 수 있습니다 . &lt;a href=&quot;compile#max_mmap_size&quot;&gt;SQLITE_MAX_MMAP_SIZE&lt;/a&gt; 가 0으로 설정 되면 메모리 맵핑 I / O를 구현하는 데 사용되는 코드가 빌드에서 생략됩니다. 통합 버퍼 캐시 부족으로 인해 메모리 매핑 I / O가 작동하지 않는 특정 플랫폼 (예 : OpenBSD)에서는 하드 상한이 자동으로 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b4fd5ebb0d7780ed8ecffd7a393ffca7213601" translate="yes" xml:space="preserve">
          <source>SQLite also supports continuous update. Instead of collecting changes in memory and then writing them to disk only on a File/Save action, changes can be written back to the disk as they occur. This avoids loss of work on a system crash or power failure. An &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt;, managed using triggers, can be kept in the on-disk database, meaning that undo/redo can occur across session boundaries.</source>
          <target state="translated">SQLite는 지속적인 업데이트도 지원합니다. 메모리에서 변경 사항을 수집 한 다음 파일 / 저장 작업에서만 디스크에 기록하는 대신 변경 사항이 발생할 때 디스크에 다시 기록 할 수 있습니다. 이렇게하면 시스템 충돌이나 정전으로 인한 작업 손실을 피할 수 있습니다. 는 &lt;a href=&quot;undoredo&quot;&gt;실행 취소 / 다시 실행 스택 자동화 된&lt;/a&gt; 트리거를 사용하여 관리, 세션 경계에 걸쳐 발생할 수있는 실행 취소 / 재실행을 의미하는 디스크상의 데이터베이스에 보관하실 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329060624f510ae9922f24c62d601f675e2d16ed" translate="yes" xml:space="preserve">
          <source>SQLite also supports custom &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;, but they are implemented by a different mechanism that is not covered in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac820d2c8ac9fabacbf33e56fbf0619b4b852375" translate="yes" xml:space="preserve">
          <source>SQLite always constructs the loops in the same order as the tables appear in the FROM clause of the SELECT statement. The left-most table becomes the outer loop and the right-most table becomes the inner loop. It is possible, in theory, to reorder the loops in some circumstances to speed the evaluation of the join. But SQLite does not attempt this optimization.</source>
          <target state="translated">SQLite는 테이블이 SELECT 문의 FROM 절에 나타나는 순서대로 루프를 항상 구성합니다. 가장 왼쪽 테이블은 외부 루프가되고 가장 오른쪽 테이블은 내부 루프가됩니다. 이론적으로 일부 상황에서 루프를 재정렬하여 조인의 평가 속도를 높일 수 있습니다. 그러나 SQLite는이 최적화를 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6d2ae6a0c05e99e10243796d37bf281d92ff6ce" translate="yes" xml:space="preserve">
          <source>SQLite always converts numbers into double-precision (64-bit) floats for comparison purposes. This means that a long sequence of digits that differ only in insignificant digits will compare equal if they are in a numeric column but will compare unequal if they are in a text column. We have:</source>
          <target state="translated">SQLite는 항상 비교를 위해 숫자를 배정도 (64 비트) 부동 소수점으로 변환합니다. 즉, 중요하지 않은 숫자 만 다른 긴 숫자 시퀀스는 숫자 열에 있으면 같지만 텍스트 열에 있으면 같지 않습니다. 우리는 :</target>
        </trans-unit>
        <trans-unit id="5149f6fd20b777693e945883aade1a453a85108d" translate="yes" xml:space="preserve">
          <source>SQLite assumes that a file deletion is atomic from the point of view of a user process. By this we mean that if SQLite requests that a file be deleted and the power is lost during the delete operation, once power is restored either the file will exist completely with all if its original content unaltered, or else the file will not be seen in the filesystem at all. If after power is restored the file is only partially deleted, if some of its data has been altered or erased, or the file has been truncated but not completely removed, then database corruption will likely result.</source>
          <target state="translated">SQLite는 파일 삭제가 사용자 프로세스의 관점에서 원자 적이라고 가정합니다. 즉, SQLite가 파일 삭제를 요청하고 삭제 작업 중에 전원이 끊어지면 전원이 복구되면 원래 내용이 변경되지 않으면 파일이 완전히 존재하거나 파일이 표시되지 않습니다. 파일 시스템. 전원이 복구 된 후 파일이 부분적으로 만 삭제되거나 일부 데이터가 변경되거나 지워지거나 파일이 잘리지 만 완전히 제거되지 않으면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47cc3cb9abff9d6022223d946bdf388c686ec2a8" translate="yes" xml:space="preserve">
          <source>SQLite assumes that file deletion is an atomic operation from the point of view of a user process. If power fails in the middle of a file deletion, then after power is restored SQLite expects to see either the entire file with all of its original data intact, or it expects not to find the file at all. Transactions may not be atomic on systems that do not work this way.</source>
          <target state="translated">SQLite는 파일 삭제가 사용자 프로세스의 관점에서 원자적인 작업이라고 가정합니다. 파일 삭제 도중 전원이 꺼지면 전원이 복구 된 후 SQLite는 원본 데이터가 그대로있는 전체 파일을 보거나 파일을 전혀 찾지 못할 것으로 예상합니다. 이 방식으로 작동하지 않는 시스템에서는 트랜잭션이 원 자성이 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="adec4e330b65c9b3e58a2c5af4b816aeb357f3e0" translate="yes" xml:space="preserve">
          <source>SQLite assumes that the detection and/or correction of bit errors caused by cosmic rays, thermal noise, quantum fluctuations, device driver bugs, or other mechanisms, is the responsibility of the underlying hardware and operating system. SQLite does not add any redundancy to the database file for the purpose of detecting corruption or I/O errors. SQLite assumes that the data it reads is exactly the same data that it previously wrote.</source>
          <target state="translated">SQLite는 우주선, 열 잡음, 양자 변동, 장치 드라이버 버그 또는 기타 메커니즘으로 인한 비트 오류의 감지 및 / 또는 수정이 기본 하드웨어 및 운영 체제의 책임이라고 가정합니다. SQLite는 손상 또는 I / O 오류를 감지하기 위해 데이터베이스 파일에 중복성을 추가하지 않습니다. SQLite는 읽은 데이터가 이전에 쓴 데이터와 정확히 동일하다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="be735f717b7a7e354acc45a2112bfb053a9d4325" translate="yes" xml:space="preserve">
          <source>SQLite assumes that the operating system will buffer writes and that a write request will return before data has actually been stored in the mass storage device. SQLite further assumes that write operations will be reordered by the operating system. For this reason, SQLite does a &quot;flush&quot; or &quot;fsync&quot; operation at key points. SQLite assumes that the flush or fsync will not return until all pending write operations for the file that is being flushed have completed. We are told that the flush and fsync primitives are broken on some versions of Windows and Linux. This is unfortunate. It opens SQLite up to the possibility of database corruption following a power loss in the middle of a commit. However, there is nothing that SQLite can do to test for or remedy the situation. SQLite assumes that the operating system that it is running on works as advertised. If that is not quite the case, well then hopefully you will not lose power too often.</source>
          <target state="translated">SQLite는 운영 체제가 쓰기를 버퍼링하고 실제로 데이터가 대용량 저장 장치에 저장되기 전에 쓰기 요청이 반환 될 것이라고 가정합니다. 또한 SQLite는 운영 체제가 쓰기 작업을 다시 정렬한다고 가정합니다. 이러한 이유로 SQLite는 주요 지점에서 &quot;flush&quot;또는 &quot;fsync&quot;작업을 수행합니다. SQLite는 플러시중인 파일에 대해 보류중인 모든 쓰기 작업이 완료 될 때까지 플러시 또는 fsync가 반환되지 않는다고 가정합니다. 플러시 및 fsync 프리미티브는 일부 버전의 Windows 및 Linux에서 손상되었다고합니다. 불행한 일입니다. 커밋 도중 전원 손실로 인해 데이터베이스가 손상 될 가능성까지 SQLite를 엽니 다. 그러나 SQLite가 상황을 테스트하거나 해결하기 위해 할 수있는 일은 없습니다.SQLite는 실행중인 운영 체제가 알려진대로 작동한다고 가정합니다. 그렇지 않다면, 당신은 힘을 너무 자주 잃지 않기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="eac5840b276383c5ab7ffbc04386838e9a3a1b34" translate="yes" xml:space="preserve">
          <source>SQLite assumes that when a file grows in length that the new file space originally contains garbage and then later is filled in with the data actually written. In other words, SQLite assumes that the file size is updated before the file content. This is a pessimistic assumption and SQLite has to do some extra work to make sure that it does not cause database corruption if power is lost between the time when the file size is increased and when the new content is written. The xDeviceCharacteristics method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; might indicate that the filesystem will always write the data before updating the file size. (This is the SQLITE_IOCAP_SAFE_APPEND property for those readers who are looking at the code.) When the xDeviceCharacteristics method indicates that files content is written before the file size is increased, SQLite can forego some of its pedantic database protection steps and thereby decrease the amount of disk I/O needed to perform a commit. The current implementation, however, makes no such assumptions for the default VFSes for Windows and Unix.</source>
          <target state="translated">SQLite는 파일의 길이가 길어지면 새 파일 공간에 원래 가비지가 들어 있고 나중에 실제로 작성된 데이터로 채워지는 것으로 가정합니다. 즉, SQLite는 파일 크기가 파일 내용보다 먼저 업데이트된다고 가정합니다. 이것은 비관적 인 가정이며 SQLite는 파일 크기가 증가하는 시간과 새로운 내용이 쓰여질 때 사이에 전력이 손실되는 경우 데이터베이스가 손상되지 않도록 추가 작업을 수행해야합니다. &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xDeviceCharacteristics 메소드파일 크기를 업데이트하기 전에 파일 시스템이 항상 데이터를 쓰도록 지시 할 수 있습니다. (코드를보고있는 독자를위한 SQLITE_IOCAP_SAFE_APPEND 특성입니다.) xDeviceCharacteristics 메소드가 파일 크기가 증가하기 전에 파일 컨텐츠가 기록됨을 표시하면 SQLite는 일부 데이터베이스 보호 단계를 포기하여 그 양을 줄일 수 있습니다. 커밋을 수행하는 데 필요한 디스크 I / O 그러나 현재 구현에서는 Windows 및 Unix의 기본 VFS에 대해서는 그러한 가정이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f72e7e6a8e3533bba6109b9b427868c41f828eab" translate="yes" xml:space="preserve">
          <source>SQLite attempts to use an index to satisfy the ORDER BY clause of a query when possible. When faced with the choice of using an index to satisfy WHERE clause constraints or satisfying an ORDER BY clause, SQLite does the same cost analysis described above and chooses the index that it believes will result in the fastest answer.</source>
          <target state="translated">SQLite는 가능하면 쿼리의 ORDER BY 절을 만족시키기 위해 인덱스를 사용하려고 시도합니다. WHERE 절 제약 조건을 충족시키기 위해 인덱스를 사용하거나 ORDER BY 절을 만족시키는 선택에 직면 할 때 SQLite는 위에서 설명한 것과 동일한 비용 분석을 수행하고 가장 빠른 답변을 얻을 것으로 생각되는 인덱스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c7b4924fe5a0590164a78695840bbbd42f195a38" translate="yes" xml:space="preserve">
          <source>SQLite automatically frees the memory allocated by sqlite3_aggregate_context() when the aggregate query concludes.</source>
          <target state="translated">SQLite는 집계 쿼리가 끝나면 sqlite3_aggregate_context ()에 의해 할당 된 메모리를 자동으로 해제합니다.</target>
        </trans-unit>
        <trans-unit id="1b3055b66526cbbe45b4800a2c0d18f447b730c9" translate="yes" xml:space="preserve">
          <source>SQLite automatically increments the schema-version whenever the schema changes. As each SQL statement runs, the schema version is checked to ensure that the schema has not changed since the SQL statement was &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared&lt;/a&gt;. Subverting this mechanism by using &quot;PRAGMA schema_version&quot; may cause SQL statement to run using an obsolete schema, which can lead to incorrect answers and/or &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;database corruption&lt;/a&gt;.</source>
          <target state="translated">SQLite는 스키마가 변경 될 때마다 스키마 버전을 자동으로 증가시킵니다. 각 SQL 문이 실행될 때 스키마 버전이 점검되어 SQL 문이 &lt;a href=&quot;c3ref/prepare&quot;&gt;준비된&lt;/a&gt; 이후 스키마가 변경되지 않았는지 확인합니다 . &quot;PRAGMA schema_version&quot;을 사용하여이 메커니즘을 무효화하면 더 이상 사용되지 않는 스키마를 사용하여 SQL 문이 실행되어 잘못된 응답 및 / 또는 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;데이터베이스 손상&lt;/a&gt; 이 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3020db6478f19a9532839179a12c2a9ed24e1db4" translate="yes" xml:space="preserve">
          <source>SQLite automatically serializes calls to the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; so it does not need to be threadsafe either. All other methods must be threadsafe in multithreaded applications.</source>
          <target state="translated">SQLite는 xInit 메서드에 대한 호출을 자동으로 직렬화하므로 xInit 메서드는 스레드로부터 안전하지 않아도됩니다. xShutdown 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 에서만 호출 되므로 스레드 세이프 일 필요도 없습니다. 다른 모든 방법은 다중 스레드 응용 프로그램에서 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="adf570ddec15cfa93349d4a743e839e20376d5d4" translate="yes" xml:space="preserve">
          <source>SQLite automatically serializes calls to the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; so it does not need to be threadsafe either. All other methods must be threadsafe in multithreaded applications.</source>
          <target state="translated">SQLite는 xInit 메서드에 대한 호출을 자동으로 직렬화하므로 xInit 메서드는 스레드로부터 안전하지 않아도됩니다. xShutdown 메소드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 에서만 호출 되므로 스레드 세이프 일 필요도 없습니다. 다른 모든 방법은 다중 스레드 응용 프로그램에서 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="b53d5d709f2b8563b5c899f4b327d7464bad702f" translate="yes" xml:space="preserve">
          <source>SQLite can also do large and complex queries efficiently, just like client/server databases. But SQLite can do many smaller queries efficiently too. Application developers can use whichever technique works best for the task at hand.</source>
          <target state="translated">SQLite는 클라이언트 / 서버 데이터베이스와 마찬가지로 크고 복잡한 쿼리를 효율적으로 수행 할 수 있습니다. 그러나 SQLite는 많은 작은 쿼리도 효율적으로 수행 할 수 있습니다. 응용 프로그램 개발자는 현재 작업에 가장 적합한 기술을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e87caa697e0258d2993af3a32d9b7e8cb861e14" translate="yes" xml:space="preserve">
          <source>SQLite can be compiled with or without mutexes. When the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe. When the &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro is 0, the mutexes are omitted. Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.</source>
          <target state="translated">SQLite는 뮤텍스와 함께 또는 뮤텍스없이 컴파일 될 수 있습니다. 때 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; C 처리기 매크로는 1 또는 2이고, 뮤텍스는 활성화 SQLite는 스레드가 인된다. 때 &lt;a href=&quot;../compile#threadsafe&quot;&gt;SQLITE_THREADSAFE의&lt;/a&gt; 매크로는 0, 뮤텍스는 생략한다. 뮤텍스가 없으면 둘 이상의 스레드에서 SQLite를 동시에 사용하는 것이 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="011026d39fd1e83a00c257ae9fee74aa8abebcc5" translate="yes" xml:space="preserve">
          <source>SQLite can be compiled with or without mutexes. When the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; C preprocessor macro is 1 or 2, mutexes are enabled and SQLite is threadsafe. When the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; macro is 0, the mutexes are omitted. Without the mutexes, it is not safe to use SQLite concurrently from more than one thread.</source>
          <target state="translated">SQLite는 뮤텍스와 함께 또는 뮤텍스없이 컴파일 될 수 있습니다. 때 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; C 처리기 매크로는 1 또는 2이고, 뮤텍스는 활성화 SQLite는 스레드가 인된다. 때 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE의&lt;/a&gt; 매크로는 0, 뮤텍스는 생략한다. 뮤텍스가 없으면 둘 이상의 스레드에서 SQLite를 동시에 사용하는 것이 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36cb69ad46f78c1ed8dd15f2baaaa36c57889f6a" translate="yes" xml:space="preserve">
          <source>SQLite can be configured to commit transactions by overwriting the journal header with zeros instead of deleting the journal file by setting the &quot;PERSIST&quot; journaling mode using the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; PRAGMA. For example:</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; PRAGMA를 사용하여 &quot;PERSIST&quot;저널링 모드를 설정하여 저널 파일을 삭제하는 대신 저널 헤더를 0으로 덮어 써서 트랜잭션을 커밋하도록 SQLite를 구성 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80ddece7460eee85c8c3c249243bb3dbfbde484c" translate="yes" xml:space="preserve">
          <source>SQLite can be configured to invoke a callback function containing an error code and a terse error message whenever anomalies occur. This mechanism is very helpful in tracking obscure problems that occur rarely and in the field. Application developers are encouraged to take advantage of the error logging facility of SQLite in their products, as it is very low CPU and memory cost but can be a huge aid for debugging.</source>
          <target state="translated">예외가 발생할 때마다 오류 코드와 간결한 오류 메시지가 포함 된 콜백 함수를 호출하도록 SQLite를 구성 할 수 있습니다. 이 메커니즘은 거의 발생하지 않으며 현장에서 발생하는 모호한 문제를 추적하는 데 매우 유용합니다. 응용 프로그램 개발자는 CPU 및 메모리 비용이 매우 낮지 만 디버깅에 큰 도움이 될 수 있으므로 제품에서 SQLite의 오류 로깅 기능을 활용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="81616a9223e74e96edfa97f31284e6d7c2ededd0" translate="yes" xml:space="preserve">
          <source>SQLite can be configured to make page cache memory allocations from a separate and distinct memory pool of fixed-size slots. This can have two advantages:</source>
          <target state="translated">고정 크기 슬롯의 개별 메모리 풀에서 페이지 캐시 메모리 할당을 수행하도록 SQLite를 구성 할 수 있습니다. 두 가지 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="872ca116186d75a484f48dbcd06ae645c30cfafb" translate="yes" xml:space="preserve">
          <source>SQLite can pull a similar trick for a descending ORDER BY:</source>
          <target state="translated">SQLite는 내림차순 ORDER BY에 대해 비슷한 트릭을 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e65b704c4d79c568a9eb5907bffebebd829ede2d" translate="yes" xml:space="preserve">
          <source>SQLite can use row values in two contexts:</source>
          <target state="translated">SQLite는 두 가지 컨텍스트에서 행 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0233fb6752b9903c64922ece01dc28610983e5af" translate="yes" xml:space="preserve">
          <source>SQLite commands are normally terminated by a semicolon. In the shell you can also use the word &quot;GO&quot; (case-insensitive) or a slash character &quot;/&quot; on a line by itself to end a command. These are used by SQL Server and Oracle, respectively. These won't work in &lt;b&gt;sqlite3_exec()&lt;/b&gt;, because the shell translates these into a semicolon before passing them to that function.</source>
          <target state="translated">SQLite 명령은 일반적으로 세미콜론으로 종료됩니다. 쉘에서 &quot;GO&quot;(대소 문자를 구분하지 않음) 또는 슬래시 문자 &quot;/&quot;만 사용하여 명령을 종료 할 수도 있습니다. 이들은 각각 SQL Server와 Oracle에서 사용됩니다. 쉘은 그것들을 세미콜론으로 변환하기 전에 &lt;b&gt;sqlite3_exec ()&lt;/b&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="c00500c2a2685e49d6f5ca17fcd6441b18a649d0" translate="yes" xml:space="preserve">
          <source>SQLite computes joins using nested loops, one loop for each table in the join. (Additional loops might be inserted for IN and OR operators in the WHERE clause. SQLite considers those too, but for simplicity we will ignore them in this essay.) One or more indexes might be used on each loop to speed the search, or a loop might be a &quot;full table scan&quot; that reads every row in the table. Thus query planning decomposes into two subtasks:</source>
          <target state="translated">SQLite는 조인의 각 테이블에 대해 하나의 루프 인 중첩 루프를 사용하여 조인을 계산합니다. (추가 루프는 WHERE 절에서 IN 및 OR 연산자에 삽입 될 수 있습니다. SQLite도이를 고려하지만 단순성을 위해이 에세이에서는이를 무시합니다.) 각 루프에서 하나 이상의 인덱스를 사용하여 검색 속도를 높이거나 루프는 테이블의 모든 행을 읽는 &quot;전체 테이블 스캔&quot;일 수 있습니다. 따라서 쿼리 계획은 두 가지 하위 작업으로 분해됩니다.</target>
        </trans-unit>
        <trans-unit id="7974ee005c7bea20e8549f294a1e5c666d87f59c" translate="yes" xml:space="preserve">
          <source>SQLite computes the entry point for the extension based on the extension filename. To override this choice, simply add the name of the extension as a second argument to the &quot;.load&quot; command.</source>
          <target state="translated">SQLite는 확장 파일 이름을 기반으로 확장의 진입 점을 계산합니다. 이 선택을 무시하려면 확장명을 &quot;.load&quot;명령의 두 번째 인수로 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="e364fda4b28195b331863df02fe5a0c5e92edd6b" translate="yes" xml:space="preserve">
          <source>SQLite connections can open two kinds of transactions, read and write transactions. This is not done explicitly, a transaction is implicitly a read-transaction until it first writes to a database table, at which point it becomes a write-transaction.</source>
          <target state="translated">SQLite 연결은 읽기 및 쓰기 트랜잭션이라는 두 가지 종류의 트랜잭션을 열 수 있습니다. 트랜잭션은 명시 적으로 수행되지 않으며 트랜잭션은 데이터베이스 테이블에 처음 쓸 때까지 암시 적으로 읽기 트랜잭션이되며,이 시점에서 트랜잭션이 쓰기 트랜잭션이됩니다.</target>
        </trans-unit>
        <trans-unit id="bfb7f60f82c37c439853dbcce0278c6d68d992ca" translate="yes" xml:space="preserve">
          <source>SQLite considers NULL values to be smaller than any other values for sorting purposes. Hence, NULLs naturally appear at the beginning of an ASC order-by and at the end of a DESC order-by. This can be changed using the &quot;ASC NULLS LAST&quot; or &quot;DESC NULLS FIRST&quot; syntax.</source>
          <target state="translated">SQLite는 정렬을 위해 NULL 값이 다른 값보다 작다고 간주합니다. 따라서 널 (NULL)은 자연스럽게 ASC 주문 시작과 DESC 주문 종료시에 나타납니다. &quot;ASC NULLS LAST&quot;또는 &quot;DESC NULLS FIRST&quot;구문을 사용하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3c65750b414698c230a01a96245ecd4d646ee27" translate="yes" xml:space="preserve">
          <source>SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; when inserting new records into a table that already uses the largest possible &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. The PRNG is also used for the build-in random() and randomblob() SQL functions. This interface allows applications to access the same PRNG for other purposes.</source>
          <target state="translated">SQLite에는 이미 가장 큰 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID를&lt;/a&gt; 사용하는 테이블에 새 레코드를 삽입 할 때 임의의 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 선택하는 데 사용되는 고품질 의사 난수 생성기 (PRNG)가 포함되어 있습니다 . PRNG는 내장 random () 및 randomblob () SQL 함수에도 사용됩니다. 이 인터페이스를 통해 응용 프로그램은 다른 목적으로 동일한 PRNG에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb68dd5c1cbc6cb1c97029684bf4911536bda94" translate="yes" xml:space="preserve">
          <source>SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; when inserting new records into a table that already uses the largest possible &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. The PRNG is also used for the built-in random() and randomblob() SQL functions. This interface allows applications to access the same PRNG for other purposes.</source>
          <target state="translated">SQLite에는 가능한 가장 큰 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 이미 사용하는 테이블에 새 레코드를 삽입 할 때 임의의 &lt;a href=&quot;../lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 선택하는 데 사용되는 고품질 PRNG (pseudo-random number generator)가 포함되어 있습니다 . PRNG는 내장 random () 및 randomblob () SQL 함수에도 사용됩니다. 이 인터페이스를 사용하면 응용 프로그램이 다른 용도로 동일한 PRNG에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f509851478b4c800f043c189999c977fd8cd102" translate="yes" xml:space="preserve">
          <source>SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; when inserting new records into a table that already uses the largest possible &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. The PRNG is also used for the build-in random() and randomblob() SQL functions. This interface allows applications to access the same PRNG for other purposes.</source>
          <target state="translated">SQLite에는 이미 가장 큰 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID를&lt;/a&gt; 사용하는 테이블에 새 레코드를 삽입 할 때 임의의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 선택하는 데 사용되는 고품질 의사 난수 생성기 (PRNG)가 포함되어 있습니다 . PRNG는 내장 random () 및 randomblob () SQL 함수에도 사용됩니다. 이 인터페이스를 통해 응용 프로그램은 다른 목적으로 동일한 PRNG에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0307ee063764cc9b4b9c8b2d1ac0ca31dc710f9b" translate="yes" xml:space="preserve">
          <source>SQLite contains a high-quality pseudo-random number generator (PRNG) used to select random &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWIDs&lt;/a&gt; when inserting new records into a table that already uses the largest possible &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. The PRNG is also used for the built-in random() and randomblob() SQL functions. This interface allows applications to access the same PRNG for other purposes.</source>
          <target state="translated">SQLite에는 가능한 가장 큰 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 이미 사용하는 테이블에 새 레코드를 삽입 할 때 임의의 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 를 선택하는 데 사용되는 고품질 PRNG (pseudo-random number generator)가 포함되어 있습니다 . PRNG는 내장 random () 및 randomblob () SQL 함수에도 사용됩니다. 이 인터페이스를 사용하면 응용 프로그램이 다른 용도로 동일한 PRNG에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ee77bcaf1d66acd1a62c0df67a25f317b961f7" translate="yes" xml:space="preserve">
          <source>SQLite contains a pluggable &lt;a href=&quot;malloc&quot;&gt;memory allocation subsystem&lt;/a&gt;. The default implementation uses system malloc() and free(). However, if SQLite is compiled with &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt;, an alternative memory allocation wrapper (&lt;a href=&quot;malloc#memdebug&quot;&gt;memsys2&lt;/a&gt;) is inserted that looks for memory allocation errors at run-time. The memsys2 wrapper checks for memory leaks, of course, but also looks for buffer overruns, uses of uninitialized memory, and attempts to use memory after it has been freed. These same checks are also done by valgrind (and, indeed, Valgrind does them better) but memsys2 has the advantage of being much faster than Valgrind, which means the checks can be done more often and for longer tests.</source>
          <target state="translated">SQLite는 플러그 가능한 &lt;a href=&quot;malloc&quot;&gt;메모리 할당 서브 시스템을&lt;/a&gt; 포함합니다 . 기본 구현은 시스템 malloc () 및 free ()를 사용합니다. 그러나 SQLite가 &lt;a href=&quot;compile#memdebug&quot;&gt;SQLITE_MEMDEBUG&lt;/a&gt; 로 컴파일 된 경우 런타임시 메모리 할당 오류를 찾는 대체 메모리 할당 랩퍼 ( &lt;a href=&quot;malloc#memdebug&quot;&gt;memsys2&lt;/a&gt; )가 삽입됩니다. memsys2 래퍼는 물론 메모리 누수를 검사 할뿐만 아니라 버퍼 오버런, 초기화되지 않은 메모리 사용 및 해제 된 메모리 사용을 찾습니다. valgrind도 이와 동일한 검사를 수행하지만 실제로 Valgrind가 더 나은 성능을 제공하지만 memsys2는 Valgrind보다 훨씬 빠르다는 장점이 있습니다. 즉, 검사를 더 자주 수행하고 더 긴 테스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e70b3aaacfaf470c166676be17bd20f5d45f4693" translate="yes" xml:space="preserve">
          <source>SQLite contains a pluggable mutex subsystem. Depending on compile-time options, the default mutex system contains interfaces &lt;a href=&quot;c3ref/mutex_held&quot;&gt;sqlite3_mutex_held()&lt;/a&gt; and &lt;a href=&quot;c3ref/mutex_held&quot;&gt;sqlite3_mutex_notheld()&lt;/a&gt; that detect whether or not a particular mutex is held by the calling thread. These two interfaces are used extensively within assert() statements in SQLite to verify mutexes are held and released at all the right moments, in order to double-check that SQLite does work correctly in multi-threaded applications.</source>
          <target state="translated">SQLite는 플러그 가능한 뮤텍스 서브 시스템을 포함합니다. 컴파일 타임 옵션에 따라 기본 mutex 시스템에는 &lt;a href=&quot;c3ref/mutex_held&quot;&gt;sqlite3_mutex_held ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/mutex_held&quot;&gt;sqlite3_mutex_notheld ()&lt;/a&gt; 인터페이스가 포함되어 있어 호출 스레드가 특정 뮤텍스를 보유하고 있는지 여부를 감지합니다. 이 두 인터페이스는 SQLite가 assert () 문 내에서 광범위하게 사용되어 멀티 스레드 응용 프로그램에서 SQLite가 올바르게 작동하는지 다시 확인하기 위해 모든 순간에 뮤텍스가 유지되고 해제되는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dabfcc2f753d723e8f1fdffc47c7886d69735236" translate="yes" xml:space="preserve">
          <source>SQLite contains its own implementation of the string formatting routine &quot;printf()&quot;, accessible via the following interfaces:</source>
          <target state="translated">SQLite에는 다음 인터페이스를 통해 액세스 할 수있는 자체 문자열 형식화 루틴 &quot;printf ()&quot;가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93da66184cea55ccf1eb0a76557743722cd0c9e" translate="yes" xml:space="preserve">
          <source>SQLite creates a new rollback journal at the start of the first transaction within an exclusive locking mode session. But at the conclusion of the transaction, it does not delete the rollback journal. The rollback journal might be truncated, or its header might be zeroed (depending on what version of SQLite you are using) but the rollback journal is not deleted. The rollback journal is not deleted until exclusive access mode is exited.</source>
          <target state="translated">SQLite는 독점 잠금 모드 세션 내에서 첫 번째 트랜잭션이 시작될 때 새 롤백 저널을 만듭니다. 그러나 트랜잭션이 끝날 때 롤백 저널은 삭제되지 않습니다. 롤백 저널이 잘 리거나 사용중인 SQLite 버전에 따라 헤더가 0이 될 수 있지만 롤백 저널은 삭제되지 않습니다. 단독 액세스 모드가 종료 될 때까지 롤백 저널이 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ff4a994995e43acece5539fc362ef2f8d57c451" translate="yes" xml:space="preserve">
          <source>SQLite current supports multiple simultaneous read transactions coming from separate database connections, possibly in separate threads or processes, but only one simultaneous write transaction.</source>
          <target state="translated">SQLite current는 별도의 스레드 또는 프로세스에서 별도의 데이터베이스 연결에서 오는 여러 개의 동시 읽기 트랜잭션을 지원하지만 하나의 동시 쓰기 트랜잭션 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="52550351bf043c480663244c5089f3b0a1af2f89" translate="yes" xml:space="preserve">
          <source>SQLite currently uses nine distinct types of temporary files:</source>
          <target state="translated">SQLite는 현재 9 가지 유형의 임시 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="768d0612a89e99cfab38eb300c519c8884a3292a" translate="yes" xml:space="preserve">
          <source>SQLite database content can be viewed using a wide variety third-party tools.</source>
          <target state="translated">SQLite 데이터베이스 컨텐츠는 다양한 타사 도구를 사용하여 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0dbc098faec242c7e0eb6b90f7b812b21e7a30" translate="yes" xml:space="preserve">
          <source>SQLite database files are &lt;a href=&quot;locrsf&quot;&gt;recommended by the US Library of Congress&lt;/a&gt; as a storage format for long-term preservation of digital content.</source>
          <target state="translated">SQLite 데이터베이스 파일은 &lt;a href=&quot;locrsf&quot;&gt;미국 의회 도서관&lt;/a&gt; 에서 디지털 컨텐츠의 장기 보존을위한 스토리지 형식으로 권장됩니다 .</target>
        </trans-unit>
        <trans-unit id="94d38bbabdf14ff89a4cf80dbf6c1e905d82147b" translate="yes" xml:space="preserve">
          <source>SQLite database files are ordinary disk files that can be opened and written by ordinary user processes. A rogue process can open an SQLite database and fill it with corrupt data. Corrupt data might also be introduced into an SQLite database by bugs in the operating system or disk controller; especially bugs triggered by a power failure. There is nothing SQLite can do to defend against these kinds of problems.</source>
          <target state="translated">SQLite 데이터베이스 파일은 일반 사용자 프로세스에서 열고 쓸 수있는 일반 디스크 파일입니다. 불량 프로세스는 SQLite 데이터베이스를 열고 손상된 데이터로 채울 수 있습니다. 운영 체제 또는 디스크 컨트롤러의 버그로 인해 손상된 데이터가 SQLite 데이터베이스에 도입 될 수도 있습니다. 특히 정전으로 인한 버그. 이러한 종류의 문제를 막기 위해 SQLite가 할 수있는 일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b12d3c769cd65d1fff0004d3dbd9ed7d36630a2" translate="yes" xml:space="preserve">
          <source>SQLite database files are ordinary disk files. That means that any process can open the file and overwrite it with garbage. There is nothing that the SQLite library can do to defend against this.</source>
          <target state="translated">SQLite 데이터베이스 파일은 일반 디스크 파일입니다. 이는 모든 프로세스가 파일을 열고 가비지로 덮어 쓸 수 있음을 의미합니다. 이것을 막기 위해 SQLite 라이브러리가 할 수있는 일은 없습니다.</target>
        </trans-unit>
        <trans-unit id="9b4a84c75e811d2fb173fe3d58bd4e6cbe30bdcc" translate="yes" xml:space="preserve">
          <source>SQLite defines certain &lt;a href=&quot;limits&quot;&gt;limits&lt;/a&gt; on its operation, such as the maximum number of columns in a table, the maximum length of an SQL statement, or the maximum value of an integer. The TCL and TH3 test suites both contains numerous tests that push SQLite right to the edge of its defined limits and verify that it performs correctly for all allowed values. Additional tests go beyond the defined limits and verify that SQLite correctly returns errors. The source code contains &lt;a href=&quot;testing#testcase&quot;&gt;testcase macros&lt;/a&gt; to verify that both sides of each boundary have been tested.</source>
          <target state="translated">SQLite는 테이블의 최대 열 수, SQL 문의 최대 길이 또는 정수의 최대 값과 같이 조작에 대한 특정 &lt;a href=&quot;limits&quot;&gt;제한&lt;/a&gt; 을 정의합니다 . TCL 및 TH3 테스트 스위트에는 모두 SQLite를 정의 된 한계의 끝까지 밀어 넣고 허용되는 모든 값에 대해 올바르게 수행되는지 확인하는 수많은 테스트가 포함되어 있습니다. 추가 테스트는 정의 된 한계를 넘어 SQLite가 오류를 올바르게 반환하는지 확인합니다. 소스 코드에는 &lt;a href=&quot;testing#testcase&quot;&gt;테스트 케이스 매크로&lt;/a&gt; 가 포함되어 있어 각 경계의 양쪽이 테스트되었는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="1ebe49ed011549b4b376ada76a7c80346e42783e" translate="yes" xml:space="preserve">
          <source>SQLite defines five constraint conflict resolution algorithms as follows:</source>
          <target state="translated">SQLite는 다음과 같이 다섯 가지 제약 조건 충돌 해결 알고리즘을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e63f24a3abefb779413eb11019f8b7c1a24ed4a7" translate="yes" xml:space="preserve">
          <source>SQLite depends on the underlying filesystem to do locking as the documentation says it will. But some filesystems contain bugs in their locking logic such that the locks do not always behave as advertised. This is especially true of network filesystems and NFS in particular. If SQLite is used on a filesystem where the locking primitives contain bugs, and if two or more threads or processes try to access the same database at the same time, then database corruption might result.</source>
          <target state="translated">SQLite는 문서가 말한대로 잠금을 수행하기 위해 기본 파일 시스템에 의존합니다. 그러나 일부 파일 시스템에는 잠금 논리에 버그가 포함되어있어 잠금이 항상 광고 된대로 동작하지는 않습니다. 이것은 특히 네트워크 파일 시스템과 특히 NFS에 해당됩니다. 잠금 프리미티브에 버그가 포함 된 파일 시스템에서 SQLite를 사용하고 둘 이상의 스레드 또는 프로세스가 동일한 데이터베이스에 동시에 액세스하려고하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84e20ec3709a6092a2fe5e0b3864b26d52798097" translate="yes" xml:space="preserve">
          <source>SQLite determines whether or not the</source>
          <target state="translated">SQLite는 여부를 결정합니다</target>
        </trans-unit>
        <trans-unit id="047a8354791082378f7165112ad6a4371a7d6650" translate="yes" xml:space="preserve">
          <source>SQLite developers fix all bugs in SQLite as soon as they are reported, usually within a few hours. The fixes are immediately available on the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;public SQLite source tree&lt;/a&gt;. If a bug seems like it might cause problems for existing applications, a new patch release for SQLite will be issued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08f1115ba9f2179d3b543581df6ff78cc24d770e" translate="yes" xml:space="preserve">
          <source>SQLite developers follow the NASA principle of &quot;fly what you test and test what you fly&quot;. This principle is violated if this option is enabled for delivery but disabled for testing. But if this option is enabled during testing, not all branches are reachable. Therefore, the use of this compile-time option is discouraged.</source>
          <target state="translated">SQLite 개발자는 NASA의 &quot;무엇을 테스트하고 비행하는지 테스트&quot;라는 원칙을 따릅니다. 이 옵션은 전달이 가능하지만 테스트가 불가능한 경우 위반됩니다. 그러나 테스트 중에이 옵션을 활성화하면 모든 분기에 도달 할 수있는 것은 아닙니다. 따라서이 컴파일 타임 옵션을 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c4f80e4b417989d34a30cd7b51ee661ffc0b6477" translate="yes" xml:space="preserve">
          <source>SQLite does &lt;u&gt;not&lt;/u&gt; have a sophisticated theorem prover with which to determine W&amp;rArr;X. Instead, SQLite uses two simple rules to find the common cases where W&amp;rArr;X is true, and it assumes all the other cases are false. The rules used by SQLite are these:</source>
          <target state="translated">SQLite에는 W&amp;rArr;X를 결정할 수있는 정교한 정리 증명 기능 이 &lt;u&gt;없습니다&lt;/u&gt; . 대신 SQLite는 두 가지 간단한 규칙을 사용하여 W&amp;rArr;X가 true 인 일반적인 경우를 찾고 다른 모든 경우는 false라고 가정합니다. SQLite에서 사용하는 규칙은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="812f97d0b2305c9c697f76ed10e7be3a58d7abf1" translate="yes" xml:space="preserve">
          <source>SQLite does not assume that a &lt;b&gt;create file&lt;/b&gt; operation has actually modified the file-system records within persistent storage until after the file has been successfully</source>
          <target state="translated">SQLite는 &lt;b&gt;파일 작성&lt;/b&gt; 조작이 파일이 성공적으로 완료 될 때까지 지속적 스토리지 내의 파일 시스템 레코드를 실제로 수정 했다고 가정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03f904caa75ae48b8b97c8d68e12829b77d799cd" translate="yes" xml:space="preserve">
          <source>SQLite does not assume that the xFetch() method will work. If a call to xFetch() returns a NULL pointer (indicating that the requested page is not currently mapped into the applications address space) then SQLite silently falls back to using xRead(). An error is only reported if xRead() also fails.</source>
          <target state="translated">SQLite는 xFetch () 메소드가 작동한다고 가정하지 않습니다. xFetch () 호출이 NULL 포인터를 리턴하면 (요청한 페이지가 현재 응용 프로그램 주소 공간에 맵핑되지 않음을 나타냄) SQLite는 xRead ()를 사용하여 자동으로 폴백합니다. xRead ()도 실패한 경우에만 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="8388b88a9237299e6bc5f9efcad34bc3644e42d2" translate="yes" xml:space="preserve">
          <source>SQLite does not compete with client/server databases. SQLite competes with &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen()&lt;/a&gt;.</source>
          <target state="translated">SQLite는 클라이언트 / 서버 데이터베이스와 경쟁하지 않습니다. SQLite는 &lt;a href=&quot;http://man.he.net/man3/fopen&quot;&gt;fopen ()&lt;/a&gt; 과 경쟁합니다 .</target>
        </trans-unit>
        <trans-unit id="d4a676b7a2490751f91ae5727d82720cbc10b6a9" translate="yes" xml:space="preserve">
          <source>SQLite does not corrupt database files without external help. If your application crashes in the middle of an update, your data is safe. The database is safe even if your OS crashes or takes a power loss. The crash-resistance of SQLite has been extensively studied and tested and is attested by years of real-world experience by billions of users.</source>
          <target state="translated">SQLite는 외부 도움없이 데이터베이스 파일을 손상시키지 않습니다. 업데이트 도중에 응용 프로그램이 중단되면 데이터가 안전합니다. OS가 충돌하거나 전원이 꺼지더라도 데이터베이스는 안전합니다. SQLite의 충돌 내성은 광범위한 연구와 테스트를 거쳤으며 수십억 명의 사용자가 수년간의 실제 경험을 통해 입증했습니다.</target>
        </trans-unit>
        <trans-unit id="10f8b576bd8d7de605fdbd1523853def318b0261" translate="yes" xml:space="preserve">
          <source>SQLite does not currently generate this result code. However, &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, or &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, or other extensions might cause this result code to be returned.</source>
          <target state="translated">SQLite는 현재이 결과 코드를 생성하지 않습니다. 그러나 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; , &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 또는 기타 확장으로 인해이 결과 코드가 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32682669e98a22ab436457272a952e96b8984c62" translate="yes" xml:space="preserve">
          <source>SQLite does not currently generate this result code. However, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; or &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, or &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;, or other extensions might cause this result code to be returned.</source>
          <target state="translated">SQLite는 현재이 결과 코드를 생성하지 않습니다. 그러나 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 또는 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 또는 기타 확장으로 인해이 결과 코드가 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="849cd253604893ceb116db699857d9c341985c8d" translate="yes" xml:space="preserve">
          <source>SQLite does not enforce the length of a VARCHAR. You can declare a VARCHAR(10) and SQLite will be happy to store a 500-million character string there. And it will keep all 500-million characters intact. Your content is never truncated. SQLite understands the column type of &quot;VARCHAR(</source>
          <target state="translated">SQLite는 VARCHAR의 길이를 강제하지 않습니다. VARCHAR (10)을 선언하면 SQLite는 5 억 개의 문자열을 저장할 수 있습니다. 그리고 5 억 개의 문자를 그대로 유지합니다. 내용이 잘리지 않습니다. SQLite는 &quot;VARCHAR (</target>
        </trans-unit>
        <trans-unit id="a1926595d7ae5865ee5b67632895b9b864b1dde1" translate="yes" xml:space="preserve">
          <source>SQLite does not enforce this restriction. The output columns from an aggregate query can be arbitrary expressions that include columns not found in GROUP BY clause. This feature has two uses:</source>
          <target state="translated">SQLite는이 제한을 적용하지 않습니다. 집계 쿼리의 출력 열은 GROUP BY 절에없는 열을 포함하는 임의 식일 수 있습니다. 이 기능은 두 가지 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cedfdcc8a476fe016f6e9e5112a567a29b98822a" translate="yes" xml:space="preserve">
          <source>SQLite does not execute CREATE INDEX or DROP TABLE as fast as the other databases. But this is not seen as a problem because those are infrequent operations.</source>
          <target state="translated">SQLite는 다른 데이터베이스만큼 빨리 CREATE INDEX 또는 DROP TABLE을 실행하지 않습니다. 그러나 이것은 드문 작업이므로 문제로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43864158c682c4848f5d2752dd74608390472ba4" translate="yes" xml:space="preserve">
          <source>SQLite does not have a separate Boolean storage class. Instead, Boolean values are stored as integers 0 (false) and 1 (true).</source>
          <target state="translated">SQLite에는 별도의 부울 스토리지 클래스가 없습니다. 대신 부울 값은 정수 0 (거짓) 및 1 (참)로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5bf507b529089c7d7e63ee38c65f8ff819e17f" translate="yes" xml:space="preserve">
          <source>SQLite does not have a storage class set aside for storing dates and/or times. Instead, the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;Date And Time Functions&lt;/a&gt; of SQLite are capable of storing dates and times as TEXT, REAL, or INTEGER values:</source>
          <target state="translated">SQLite에는 날짜 및 / 또는 시간을 저장하기 위해 따로 보관 클래스가 설정되어 있지 않습니다. 대신 SQLite 의 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 함수&lt;/a&gt; 는 날짜 및 시간을 TEXT, REAL 또는 INTEGER 값으로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d38a36f56dfc9a58300bf464f4bc506a55de48ac" translate="yes" xml:space="preserve">
          <source>SQLite does not have any file naming requirements and so the application can use any custom file suffix that it wants to help identify the file as &quot;belonging&quot; to the application. SQLite database files contain a 4-byte &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; in their headers that can be set to an application-defined value and then used to identify the &quot;type&quot; of the document for utility programs such as &lt;a href=&quot;http://linux.die.net/man/1/file&quot;&gt;file(1)&lt;/a&gt;, further enhancing the document metaphor.</source>
          <target state="translated">SQLite에는 파일 이름 지정 요구 사항이 없으므로 응용 프로그램은 파일을 응용 프로그램에 &quot;포함&quot;하는 것으로 식별하려는 사용자 지정 파일 접미사를 사용할 수 있습니다. SQLite 데이터베이스 파일에는 헤더에 4 바이트 &lt;a href=&quot;fileformat2#appid&quot;&gt;애플리케이션 ID&lt;/a&gt; 가 포함 되어 있으며 애플리케이션 정의 값으로 설정 한 다음 &lt;a href=&quot;http://linux.die.net/man/1/file&quot;&gt;file (1)&lt;/a&gt; 과 같은 유틸리티 프로그램에 대한 문서의 &quot;유형&quot;을 식별 하여 문서 메타포를 더욱 향상시킵니다. .</target>
        </trans-unit>
        <trans-unit id="e59c710100ff708b1aef0f21340b69db8c1733b8" translate="yes" xml:space="preserve">
          <source>SQLite does not impose any arbitrary limits on the tables in a join. It also allows a table to be joined with itself.</source>
          <target state="translated">SQLite는 조인의 테이블에 임의의 제한을 부과하지 않습니다. 또한 테이블을 자체와 조인 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19b66e3a5f9904818e920e65d3e2c5788b19b7a" translate="yes" xml:space="preserve">
          <source>SQLite does not impose any naming requirements on database files. SQLite will happily work with a database file that has any filename extension or with no extension at all. When auxiliary files are needed for a &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; or a &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or for one of the other kinds of &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt;, then the name for the auxiliary file is normally constructed by appending a suffix onto the end of the database file name. For example, if the original database is call &quot;&lt;code&gt;app.db&lt;/code&gt;&quot; then the &lt;a href=&quot;lockingv3#rollback&quot;&gt;rollback journal&lt;/a&gt; will be called &quot;&lt;code&gt;app.db-journal&lt;/code&gt;&quot; and the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; will be called &quot;&lt;code&gt;app.db-wal&lt;/code&gt;&quot;. This approach to auxiliary file naming works great on systems that support long filenames. But on systems that impose 8+3 filename constraints, the auxiliary files do not fit the 8+3 format even though the original database file does.</source>
          <target state="translated">SQLite는 데이터베이스 파일에 대한 명명 요구 사항을 부과하지 않습니다. SQLite는 파일 이름 확장자가 있거나 확장자가없는 데이터베이스 파일과 함께 행복하게 작동합니다. 보조 파일이 필요한 경우 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 또는 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 또는 다른 종류의 일을 위해 &lt;a href=&quot;tempfiles&quot;&gt;임시 디스크 파일&lt;/a&gt; , 다음 보조 파일의 이름은 일반적으로 데이터베이스 파일 이름의 끝 부분에 접미사를 추가하여 구성된다. 예를 들어, 원래 데이터베이스가 &quot; &lt;code&gt;app.db&lt;/code&gt; &quot;인 경우 &lt;a href=&quot;lockingv3#rollback&quot;&gt;롤백 저널&lt;/a&gt; 은 &quot; &lt;code&gt;app.db-journal&lt;/code&gt; &quot;이되고 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 는 &quot; &lt;code&gt;app.db-wal&lt;/code&gt; &quot;이됩니다.보조 파일 이름 지정에 대한이 접근 방식은 긴 파일 이름을 지원하는 시스템에서 효과적입니다. 그러나 8 + 3 파일 이름 제한 조건을 적용하는 시스템에서는 보조 데이터베이스 파일이 원래 데이터베이스 파일과 달리 8 + 3 형식에 맞지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a73287a8fe8c79033c83c805463ed8e55719bac8" translate="yes" xml:space="preserve">
          <source>SQLite does not impose this restriction. The output columns from an aggregate query can be arbitrary expressions that include columns not found in GROUP BY clause. This feature has two uses:</source>
          <target state="translated">SQLite는이 제한을 적용하지 않습니다. 집계 조회의 출력 열은 GROUP BY 절에없는 열을 포함하는 임의의 표현식 일 수 있습니다. 이 기능에는 두 가지 용도가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8555210284d36b3e1b8f8883b624896b86a18ab1" translate="yes" xml:space="preserve">
          <source>SQLite does not know about the upper-case/lower-case distinction for all unicode characters. SQL functions like upper() and lower() only work on ASCII characters. There are two reasons for this:</source>
          <target state="translated">SQLite는 모든 유니 코드 문자의 대문자 / 소문자 구별에 대해 알지 못합니다. upper () 및 lower ()와 같은 SQL 함수는 ASCII 문자에서만 작동합니다. 이에 대한 두 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb92b3df474a6ac50c00c18c8f46d84276cd93dd" translate="yes" xml:space="preserve">
          <source>SQLite does not need to be &quot;installed&quot; before it is used. There is no &quot;setup&quot; procedure. There is no server process that needs to be started, stopped, or configured. There is no need for an administrator to create a new database instance or assign access permissions to users. SQLite uses no configuration files. Nothing needs to be done to tell the system that SQLite is running. No actions are required to recover after a system crash or power failure. There is nothing to troubleshoot.</source>
          <target state="translated">SQLite를 사용하기 전에 &quot;설치&quot;할 필요는 없습니다. &quot;설정&quot;절차가 없습니다. 시작, 중지 또는 구성해야 할 서버 프로세스가 없습니다. 관리자가 새 데이터베이스 인스턴스를 작성하거나 사용자에게 액세스 권한을 지정할 필요가 없습니다. SQLite는 구성 파일을 사용하지 않습니다. 시스템에 SQLite가 실행 중임을 알리기 위해 수행 할 작업이 없습니다. 시스템 고장 또는 정전 후 복구 할 조치가 필요하지 않습니다. 해결할 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="884bfc65b22f2d44e73c6eb276c85fdfbd7fe67c" translate="yes" xml:space="preserve">
          <source>SQLite does not support joins containing more than 64 tables. This limit arises from the fact that the SQLite code generator uses bitmaps with one bit per join-table in the query optimizer.</source>
          <target state="translated">SQLite는 64 개가 넘는 테이블을 포함하는 조인을 지원하지 않습니다. 이 한계는 SQLite 코드 생성기가 쿼리 최적화 프로그램에서 결합 테이블 당 1 비트의 비트 맵을 사용한다는 사실에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32cceefcad6471cec76877d28300254ecd207a80" translate="yes" xml:space="preserve">
          <source>SQLite does not use reallocarray(). The reason is that reallocarray() is not useful to SQLite. It turns out that SQLite never does memory allocations that are the simple product of two integers. Instead, SQLite does allocations of the form &quot;X+C&quot; or &quot;N*X+C&quot; or &quot;M*N*X+C&quot; or &quot;N*X+M*Y+C&quot;, and so forth. The reallocarray() interface is not helpful in avoiding integer overflow in those cases.</source>
          <target state="translated">SQLite는 reallocarray ()를 사용하지 않습니다. 그 이유는 reallocarray ()가 SQLite에 유용하지 않기 때문입니다. SQLite는 두 정수의 단순한 곱인 메모리 할당을 수행하지 않는 것으로 나타났습니다. 대신 SQLite는 &quot;X + C&quot;또는 &quot;N * X + C&quot;또는 &quot;M * N * X + C&quot;또는 &quot;N * X + M * Y + C&quot;등의 형식으로 할당합니다. 이러한 경우 reallocarray () 인터페이스는 정수 오버플로를 피하는 데 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e572f2c7a3110182d89abded21495f7d514fd7ce" translate="yes" xml:space="preserve">
          <source>SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system. SQLite uses &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; instead, which is a version control system that was specifically designed and written to support SQLite.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; 버전 제어 시스템을 사용하지 않습니다 . SQLite는 SQLite 를 지원하도록 특별히 설계된 버전 제어 시스템 인 &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil을&lt;/a&gt; 대신 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="f4fb8e959c9cf8676f0661c9123f7b84f2d8bef1" translate="yes" xml:space="preserve">
          <source>SQLite evaluates an SQL function by invoking callback routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ed31deb6ad368a56d7944ce942ebcf9b2c51e9" translate="yes" xml:space="preserve">
          <source>SQLite follows interpretation (1), as does PostgreSQL, MySQL, Oracle, and Firebird. It is true that Informix and Microsoft SQL Server use interpretation (2), however we the SQLite developers hold that interpretation (1) is the most natural reading of the requirement and we also want to maximize compatibility with other SQL database engines, and most other database engines also go with (1), so that is what SQLite does.</source>
          <target state="translated">SQLite는 PostgreSQL, MySQL, Oracle 및 Firebird와 마찬가지로 해석 (1)을 따릅니다. Informix와 Microsoft SQL Server는 해석 (2)을 사용하는 것이 사실이지만, SQLite 개발자는 해석 (1)이 요구 사항을 가장 자연스럽게 읽으며 다른 SQL 데이터베이스 엔진과의 호환성을 극대화하기를 원한다고 주장합니다. 데이터베이스 엔진도 (1)과 함께 사용되므로 SQLite가 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3c073597d6dda07cec7d805350d02b0ccb097124" translate="yes" xml:space="preserve">
          <source>SQLite generates the following VDBE code to handle this query:</source>
          <target state="translated">SQLite는이 쿼리를 처리하기 위해 다음 VDBE 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b4d6b7ddedcd5672d5d5c1d0814e9f17af528341" translate="yes" xml:space="preserve">
          <source>SQLite guarantees that the zFilename parameter to xOpen is either a NULL pointer or string obtained from xFullPathname() with an optional suffix added. If a suffix is added to the zFilename parameter, it will consist of a single &quot;-&quot; character followed by no more than 11 alphanumeric and/or &quot;-&quot; characters. SQLite further guarantees that the string will be valid and unchanged until xClose() is called. Because of the previous sentence, the &lt;a href=&quot;#sqlite3_file&quot; id=&quot;sqlite3vfsxopen&quot;&gt;sqlite3_file&lt;/a&gt; can safely store a pointer to the filename if it needs to remember the filename for some reason. If the zFilename parameter to xOpen is a NULL pointer then xOpen must invent its own temporary name for the file. Whenever the xFilename parameter is NULL it will also be the case that the flags parameter will include &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;.</source>
          <target state="translated">SQLite는 xOpen에 대한 zFilename 매개 변수가 선택적 접미 부가 추가 된 xFullPathname ()에서 얻은 NULL 포인터 또는 문자열임을 보증합니다. 접미어가 zFilename 매개 변수에 추가되면 단일 &quot;-&quot;문자와 11 자 이하의 영숫자 및 / 또는 &quot;-&quot;문자로 구성됩니다. SQLite는 xClose ()가 호출 될 때까지 문자열이 유효하고 변경되지 않도록 보장합니다. 이전 문장 때문에 &lt;a href=&quot;#sqlite3_file&quot; id=&quot;sqlite3vfsxopen&quot;&gt;sqlite3_file&lt;/a&gt; 은 어떤 이유로 파일 이름을 기억 해야하는 경우 파일 이름에 대한 포인터를 안전하게 저장할 수 있습니다. xOpen에 대한 zFilename 매개 변수가 NULL 포인터 인 경우 xOpen은 파일의 자체 임시 이름을 발명해야합니다.xFilename 매개 변수가 NULL 일 때마다 flags 매개 변수에 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_DELETEONCLOSE 가 포함 됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d519343efa0295e444925cd61c058c515076622f" translate="yes" xml:space="preserve">
          <source>SQLite guarantees that the zFilename parameter to xOpen is either a NULL pointer or string obtained from xFullPathname() with an optional suffix added. If a suffix is added to the zFilename parameter, it will consist of a single &quot;-&quot; character followed by no more than 11 alphanumeric and/or &quot;-&quot; characters. SQLite further guarantees that the string will be valid and unchanged until xClose() is called. Because of the previous sentence, the &lt;a href=&quot;file&quot; id=&quot;sqlite3vfsxopen&quot;&gt;sqlite3_file&lt;/a&gt; can safely store a pointer to the filename if it needs to remember the filename for some reason. If the zFilename parameter to xOpen is a NULL pointer then xOpen must invent its own temporary name for the file. Whenever the xFilename parameter is NULL it will also be the case that the flags parameter will include &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE&lt;/a&gt;.</source>
          <target state="translated">SQLite는 xOpen에 대한 zFilename 매개 변수가 선택적 접미 부가 추가 된 xFullPathname ()에서 얻은 NULL 포인터 또는 문자열임을 보증합니다. 접미어가 zFilename 매개 변수에 추가되면 단일 &quot;-&quot;문자와 11 자 이하의 영숫자 및 / 또는 &quot;-&quot;문자로 구성됩니다. SQLite는 xClose ()가 호출 될 때까지 문자열이 유효하고 변경되지 않도록 보장합니다. 이전 문장 때문에 &lt;a href=&quot;file&quot; id=&quot;sqlite3vfsxopen&quot;&gt;sqlite3_file&lt;/a&gt; 은 어떤 이유로 파일 이름을 기억 해야하는 경우 파일 이름에 대한 포인터를 안전하게 저장할 수 있습니다. xOpen에 대한 zFilename 매개 변수가 NULL 포인터 인 경우 xOpen은 파일의 자체 임시 이름을 발명해야합니다.xFilename 매개 변수가 NULL 일 때마다 flags 매개 변수에 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_DELETEONCLOSE 가 포함 됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e30a11544b3b70ee38ad6d69bfc7966ff234f5f0" translate="yes" xml:space="preserve">
          <source>SQLite has a long-range vision. Planning is done with the assumption that SQLite will be used and supported through at least the year 2050. All code is written with the idea that it will one day be read and maintained by people not yet born. The code is carefully commented with an eye toward helping those future developers more easily understand the logic and the rationale behind the code.</source>
          <target state="translated">SQLite는 장거리 비전을 가지고 있습니다. SQLite는 적어도 2050 년까지 사용 및 지원 될 것이라는 가정하에 계획이 이루어집니다. 모든 코드는 아직 태어나지 않은 사람들이 언젠가 읽고 관리 할 것이라는 아이디어로 작성되었습니다. 이 코드는 미래 개발자들이 코드의 논리와 논리를보다 쉽게 ​​이해할 수 있도록주의 깊게 주석을 달았습니다.</target>
        </trans-unit>
        <trans-unit id="aceade92bdc221158a6b3b9dee552d0622a51de1" translate="yes" xml:space="preserve">
          <source>SQLite has always been threadsafe in the sense that it is safe to use different SQLite database connections in different threads at the same time. The constraint was that the same database connection could not be used in two separate threads at once. SQLite version 3.5.0 relaxes this constraint.</source>
          <target state="translated">SQLite는 서로 다른 스레드에서 서로 다른 SQLite 데이터베이스 연결을 동시에 사용하는 것이 안전하다는 의미에서 항상 스레드 안전을 유지했습니다. 제약 조건은 동일한 데이터베이스 연결을 두 개의 개별 스레드에서 한 번에 사용할 수 없다는 것입니다. SQLite 버전 3.5.0은이 제약 조건을 완화합니다.</target>
        </trans-unit>
        <trans-unit id="271f775dd6b6f73fbe141210d32e18aec79eee7a" translate="yes" xml:space="preserve">
          <source>SQLite has been used with great success as the on-disk file format for desktop applications such as version control systems, financial analysis tools, media cataloging and editing suites, CAD packages, record keeping programs, and so forth. The traditional File/Open operation calls sqlite3_open() to attach to the database file. Updates happen automatically as application content is revised so the File/Save menu option becomes superfluous. The File/Save_As menu option can be implemented using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;.</source>
          <target state="translated">SQLite는 버전 제어 시스템, 재무 분석 도구, 미디어 카탈로그 및 편집 제품군, CAD 패키지, 레코드 보관 프로그램 등과 같은 데스크톱 응용 프로그램을위한 온 디스크 파일 형식으로 큰 성공을 거두었습니다. 전통적인 File / Open 작업은 sqlite3_open ()을 호출하여 데이터베이스 파일에 연결합니다. 파일 / 저장 메뉴 옵션이 불필요 해 지므로 응용 프로그램 내용이 수정되면 자동으로 업데이트됩니다. File / Save_As 메뉴 옵션은 &lt;a href=&quot;backup&quot;&gt;백업 API를&lt;/a&gt; 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f55c294c2cf9b8417df5cbe3a3af491dd2f0fa77" translate="yes" xml:space="preserve">
          <source>SQLite has limited &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; support that you can use to add a column to the end of a table or to change the name of a table. If you want to make more complex changes in the structure of a table, you will have to recreate the table. You can save existing data to a temporary table, drop the old table, create the new table, then copy the data back in from the temporary table.</source>
          <target state="translated">SQLite에는 테이블 끝에 열을 추가하거나 테이블 이름을 변경하는 데 사용할 수있는 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 지원 이 제한 되어 있습니다. 테이블 구조를보다 복잡하게 변경하려면 테이블을 다시 작성해야합니다. 기존 데이터를 임시 테이블에 저장하고 이전 테이블을 삭제하고 새 테이블을 만든 다음 데이터를 임시 테이블에서 다시 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b73be04138313333850933822dba80a15ce2e139" translate="yes" xml:space="preserve">
          <source>SQLite has many built-in protections against database corruption. But many of these protections can be disabled by configuration options. If protections are disabled, database corruption may occur.</source>
          <target state="translated">SQLite에는 데이터베이스 손상에 대한 많은 보호 기능이 내장되어 있습니다. 그러나 이러한 보호 기능 중 상당수는 구성 옵션으로 비활성화 할 수 있습니다. 보호가 비활성화되면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb603bba250f35273a32a5611b9cd000e44489f5" translate="yes" xml:space="preserve">
          <source>SQLite has more than 225 APIs. However, most of the APIs are optional and very specialized and can be ignored by beginners. The core API is small, simple, and easy to learn. This article summarizes the core API.</source>
          <target state="translated">SQLite에는 225 개 이상의 API가 있습니다. 그러나 대부분의 API는 선택적이고 매우 전문적이며 초보자는 무시할 수 있습니다. 핵심 API는 작고 간단하며 배우기 쉽습니다. 이 기사는 핵심 API를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="8a4895c12238b138bb6c6286f8230fbb2f5cd9a6" translate="yes" xml:space="preserve">
          <source>SQLite has never made any promises about the names of columns in the result set of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement unless the column contains an AS clause. So this change to column name is technically not an incompatibility. SQLite is merely changing from one undefined behavior to another. Nevertheless, many applications depend on the unspecified column naming behavior of SQLite and so this change is discussed under the incompatible changes subheading.</source>
          <target state="translated">열에 AS 절이 포함되어 있지 않으면 SQLite는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 집합에서 열 이름에 대해 약속 한 적이 없습니다 . 따라서이 열 이름 변경은 기술적으로 호환되지 않습니다. SQLite는 정의되지 않은 동작에서 다른 동작으로 변경 될뿐입니다. 그럼에도 불구하고 많은 응용 프로그램이 SQLite의 지정되지 않은 열 명명 동작에 의존하므로이 변경 사항은 호환되지 않는 변경 하위 제목에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="ca7acd3d88ffa5a3ae27ab37d2b4f9fba4b8da4f" translate="yes" xml:space="preserve">
          <source>SQLite has no DATETIME datatype. Instead, dates and times can be stored in any of these ways:</source>
          <target state="translated">SQLite에는 DATETIME 데이터 유형이 없습니다. 대신 날짜와 시간을 다음 방법 중 하나로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="434827c14efeeadfcb2418a72c6305a40a35bf77" translate="yes" xml:space="preserve">
          <source>SQLite has parsed foreign key constraints for time out of mind, but added the ability to actually enforce those constraints much later, with &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14). By the time foreign key constraint enforcement was added, there were already countless millions of databases in circulation that contained foreign key constraints, some of which were not correct. To avoid breaking those legacy databases, foreign key constraint enforcement is turned off by default in SQLite.</source>
          <target state="translated">SQLite는 시간이 지남에 따라 외래 키 제약 조건을 구문 분석했지만 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; (2009-10-14)로 훨씬 나중에 이러한 제약 조건을 실제로 적용하는 기능을 추가했습니다 . 외래 키 제약 조건 시행이 추가 될 때 이미 외래 키 제약 조건을 포함하는 수많은 데이터베이스가 유통되고 있었는데 그 중 일부는 올바르지 않았습니다. 레거시 데이터베이스가 손상되지 않도록 SQLite에서 외래 키 제약 조건 적용이 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe0e942db3fdd796752686c9b5c13e9ee369eca1" translate="yes" xml:space="preserve">
          <source>SQLite has the ability to load extensions (including new &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;) at run-time. This feature allows the code for extensions to be developed and tested separately from the application and then loaded on an as-needed basis.</source>
          <target state="translated">SQLite는 런타임에 확장 (새 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; , &lt;a href=&quot;datatype3#collation&quot;&gt;조합 시퀀스&lt;/a&gt; , &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;vfs&quot;&gt;VFS 포함&lt;/a&gt; )을로드하는 기능이 있습니다. 이 기능을 사용하면 확장 코드를 응용 프로그램과 별도로 개발하고 테스트 한 다음 필요에 따라로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01e91ba3e2500969e52ba828deace82978255140" translate="yes" xml:space="preserve">
          <source>SQLite has the ability to load extensions (including new &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt;) at run-time. This feature allows the code for extensions to be developed and tested separately from the application and then loaded on an as-needed basis.</source>
          <target state="translated">SQLite는 런타임에 확장 (신규 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; , 데이터 &lt;a href=&quot;datatype3#collation&quot;&gt;정렬 시퀀스&lt;/a&gt; , &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;vfs&quot;&gt;VFS 포함&lt;/a&gt; )을로드 할 수 있습니다. 이 기능을 사용하면 확장 코드를 응용 프로그램과 별도로 개발하고 테스트 한 다음 필요에 따라로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e4d010949f30fdc1e3ec9866eaf0049a35366ab" translate="yes" xml:space="preserve">
          <source>SQLite has the ability to set aside a small number of extra bytes at the end of every page for use by extensions. These extra bytes are used, for example, by the SQLite Encryption Extension to store a nonce and/or cryptographic checksum associated with each page. The &quot;reserved space&quot; size in the 1-byte integer at offset 20 is the number of bytes of space at the end of each page to reserve for extensions. This value is usually 0. The value can be odd.</source>
          <target state="translated">SQLite는 확장 프로그램에서 사용할 수 있도록 모든 페이지 끝에 작은 바이트를 추가로 확보 할 수 있습니다. 이러한 여분의 바이트는 예를 들어 SQLite Encryption Extension에서 각 페이지와 관련된 nonce 및 / 또는 암호화 체크섬을 저장하는 데 사용됩니다. 오프셋 20에서 1 바이트 정수의 &quot;예약 된 공간&quot;크기는 확장을 위해 예약 할 각 페이지 끝의 공간 바이트 수입니다. 이 값은 일반적으로 0입니다. 값은 홀수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9203406a48bcc380153eb0cdda332e02c86e380f" translate="yes" xml:space="preserve">
          <source>SQLite has the important property that transactions appear to be atomic even if the transaction is interrupted by an operating system crash or power failure.</source>
          <target state="translated">SQLite는 운영 체제 충돌 또는 전원 장애로 인해 트랜잭션이 중단 된 경우에도 트랜잭션이 원자적인 것처럼 보이는 중요한 속성을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0a51ac8c3c19e2efc6a52feb047f00515d3213" translate="yes" xml:space="preserve">
          <source>SQLite has to do two binary searches to find the price of peaches using the method show above. But for a table with a large number of rows, this is still much faster than doing a full table scan.</source>
          <target state="translated">SQLite는 위의 방법을 사용하여 복숭아 가격을 찾기 위해 이진 검색을 두 번 수행해야합니다. 그러나 행 수가 많은 테이블의 경우 전체 테이블 스캔을 수행하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="676af2e11cb2905c4dfb00ec08797f3ee68e158c" translate="yes" xml:space="preserve">
          <source>SQLite has traditionally assumed that a sector write is &lt;u&gt;not&lt;/u&gt; atomic. However, SQLite does always assume that a sector write is linear. By &quot;linear&quot; we mean that SQLite assumes that when writing a sector, the hardware begins at one end of the data and writes byte by byte until it gets to the other end. The write might go from beginning to end or from end to beginning. If a power failure occurs in the middle of a sector write it might be that part of the sector was modified and another part was left unchanged. The key assumption by SQLite is that if any part of the sector gets changed, then either the first or the last bytes will be changed. So the hardware will never start writing a sector in the middle and work towards the ends. We do not know if this assumption is always true but it seems reasonable.</source>
          <target state="translated">SQLite는 전통적으로 섹터 쓰기가 원 자성 이 &lt;u&gt;아니라고&lt;/u&gt; 가정했습니다 . 그러나 SQLite는 항상 섹터 쓰기가 선형이라고 가정합니다. &quot;선형&quot;은 SQLite가 섹터를 쓸 때 하드웨어가 데이터의 한쪽 끝에서 시작하여 다른 쪽 끝에 도달 할 때까지 바이트 단위로 쓴다고 가정합니다. 쓰기는 처음부터 끝까지 또는 끝에서 시작까지 진행될 수 있습니다. 섹터 쓰기 도중 정전이 발생하면 섹터의 일부가 수정되고 다른 부분이 변경되지 않은 것일 수 있습니다. SQLite의 주요 가정은 섹터의 일부가 변경되면 첫 번째 또는 마지막 바이트가 변경된다는 것입니다. 따라서 하드웨어는 결코 중간에 섹터를 작성하지 않고 끝을 향해 작동합니다. 우리는이 가정이 항상 사실인지는 알지 못하지만 합리적으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="6e2b79f10afe47ad0c40bb4a3ac913a6b768b679" translate="yes" xml:space="preserve">
          <source>SQLite helps applications avoid writer starvation. After any attempt to obtain a write-lock on a table fails (because one or more other connections are holding read-locks), all attempts to open new transactions on the shared-cache fail until one of the following is true:</source>
          <target state="translated">SQLite는 애플리케이션이 라이터 기아를 피할 수 있도록 도와줍니다. 하나 이상의 다른 연결이 읽기 잠금을 보유하고 있기 때문에 테이블에서 쓰기 잠금을 얻는 데 실패하면 다음 중 하나에 해당 될 때까지 공유 캐시에서 새 트랜잭션을 열려는 모든 시도가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="402f5ca7372d4a9946847b5c208fa5c883a857e1" translate="yes" xml:space="preserve">
          <source>SQLite holds a write transaction open on the destination database file for the duration of the backup operation. The source database is read-locked only while it is being read; it is not locked continuously for the entire backup operation. Thus, the backup may be performed on a live source database without preventing other database connections from reading or writing to the source database while the backup is underway.</source>
          <target state="translated">SQLite는 백업 작업 기간 동안 대상 데이터베이스 파일에서 열린 쓰기 트랜잭션을 보유합니다. 소스 데이터베이스는 읽는 동안에 만 읽기 잠금 상태입니다. 전체 백업 조작에 대해 지속적으로 잠기지 않습니다. 따라서 백업이 진행되는 동안 다른 데이터베이스 연결이 소스 데이터베이스를 읽거나 쓰는 것을 막지 않고 라이브 소스 데이터베이스에서 백업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc11b90ce34488ba86957f5c9e4b6d1abe96e13" translate="yes" xml:space="preserve">
          <source>SQLite holds the &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MAIN&lt;/a&gt; mutex when it invokes the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; so it does not need to be threadsafe either. For all other methods, SQLite holds the &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; mutex as long as the &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; configuration option is turned on (which it is by default) and so the methods are automatically serialized. However, if &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled, then the other methods must be threadsafe or else make their own arrangements for serialization.</source>
          <target state="translated">SQLite는 xInit 메서드를 호출 할 때 &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MAIN&lt;/a&gt; 뮤텍스를 보유 하므로 xInit 메서드는 스레드로부터 안전 할 필요가 없습니다. xShutdown 메서드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 에서만 호출 되므로 스레드로부터 안전 할 필요도 없습니다. 다른 모든 메서드의 경우 SQLite는 &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 구성 옵션이 켜져 있고 (기본적으로) 메서드가 자동으로 직렬화 되는 한 &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; 뮤텍스를 보유합니다 . 그러나 &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 비활성화 된 경우 다른 메서드는 스레드로부터 안전해야하며 그렇지 않으면 직렬화를 위해 자체적으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="912f035cba3f20daf2c59df8d233e473805d19b3" translate="yes" xml:space="preserve">
          <source>SQLite holds the &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MASTER&lt;/a&gt; mutex when it invokes the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; so it does not need to be threadsafe either. For all other methods, SQLite holds the &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; mutex as long as the &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; configuration option is turned on (which it is by default) and so the methods are automatically serialized. However, if &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled, then the other methods must be threadsafe or else make their own arrangements for serialization.</source>
          <target state="translated">SQLite는 xInit 메소드를 호출 할 때 &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MASTER&lt;/a&gt; 뮤텍스를 보유 하므로 xInit 메소드는 스레드로부터 안전하지 않아도됩니다. xShutdown 메소드는 &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 에서만 호출 되므로 스레드 세이프 일 필요도 없습니다. 다른 모든 메소드의 경우, &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 구성 옵션이 켜져 있고 (기본적으로) 메소드가 자동으로 직렬화되는 한 SQLite는 &lt;a href=&quot;#SQLITE_MUTEX_FAST&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; 뮤텍스를 보유합니다 . 그러나 &lt;a href=&quot;#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 사용 불가능한 경우 다른 메소드는 스레드 세이프 이거나 직렬화를 위해 자체적으로 배열해야합니다.</target>
        </trans-unit>
        <trans-unit id="79a19d02c026b02e8c1a0db8ac15db509fcdae53" translate="yes" xml:space="preserve">
          <source>SQLite holds the &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MAIN&lt;/a&gt; mutex when it invokes the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; so it does not need to be threadsafe either. For all other methods, SQLite holds the &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; mutex as long as the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; configuration option is turned on (which it is by default) and so the methods are automatically serialized. However, if &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled, then the other methods must be threadsafe or else make their own arrangements for serialization.</source>
          <target state="translated">SQLite는 xInit 메서드를 호출 할 때 &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MAIN&lt;/a&gt; 뮤텍스를 보유 하므로 xInit 메서드는 스레드로부터 안전 할 필요가 없습니다. xShutdown 메서드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 에서만 호출 되므로 스레드로부터 안전 할 필요도 없습니다. 다른 모든 메서드의 경우 SQLite는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 구성 옵션이 켜져 있고 (기본적으로) 메서드가 자동으로 직렬화 되는 한 &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; 뮤텍스를 보유합니다 . 그러나 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 비활성화 된 경우 다른 메서드는 스레드로부터 안전해야하며 그렇지 않으면 직렬화를 위해 자체적으로 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bd2489c20f80af95976208fb003fab254c1fa75" translate="yes" xml:space="preserve">
          <source>SQLite holds the &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MASTER&lt;/a&gt; mutex when it invokes the xInit method, so the xInit method need not be threadsafe. The xShutdown method is only called from &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; so it does not need to be threadsafe either. For all other methods, SQLite holds the &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; mutex as long as the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; configuration option is turned on (which it is by default) and so the methods are automatically serialized. However, if &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; is disabled, then the other methods must be threadsafe or else make their own arrangements for serialization.</source>
          <target state="translated">SQLite는 xInit 메소드를 호출 할 때 &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MASTER&lt;/a&gt; 뮤텍스를 보유 하므로 xInit 메소드는 스레드로부터 안전하지 않아도됩니다. xShutdown 메소드는 &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 에서만 호출 되므로 스레드 세이프 일 필요도 없습니다. 다른 모든 메소드의 경우, &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 구성 옵션이 켜져 있고 (기본적으로) 메소드가 자동으로 직렬화되는 한 SQLite는 &lt;a href=&quot;c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_MEM&lt;/a&gt; 뮤텍스를 보유합니다 . 그러나 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmemstatus&quot;&gt;SQLITE_CONFIG_MEMSTATUS&lt;/a&gt; 가 사용 불가능한 경우 다른 메소드는 스레드 세이프 이거나 직렬화를 위해 자체적으로 배열해야합니다.</target>
        </trans-unit>
        <trans-unit id="f91f212a3a30086dc5ca1eb656ef7423affc33b3" translate="yes" xml:space="preserve">
          <source>SQLite implements GROUP BY by ordering the output rows in the order suggested by the GROUP BY terms. Each output row is compared to the previous to see if it starts a new &quot;group&quot;. The ordering by GROUP BY terms is done in exactly the same way as the ordering by ORDER BY terms. A preexisting index is used if possible, but if no suitable index is available, a transient index is created.</source>
          <target state="translated">SQLite는 GROUP BY 용어에서 제안한 순서대로 출력 행을 정렬하여 GROUP BY를 구현합니다. 각 출력 행을 이전과 비교하여 새 &quot;그룹&quot;을 시작하는지 확인합니다. GROUP BY 용어 순서는 ORDER BY 용어 순서와 정확히 같은 방식으로 수행됩니다. 가능한 경우 기존 색인이 사용되지만 사용 가능한 적절한 색인이 없으면 임시 색인이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="21ee3a1222ea37592ef106a68bea0de2b898dfe2" translate="yes" xml:space="preserve">
          <source>SQLite implements SQL functions using callbacks to C-language routines. Even the built-in SQL functions are implemented this way. Most of the built-in SQL functions (ex: &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs()&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc#count&quot;&gt;count()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr()&lt;/a&gt;, and so forth) can be found in &lt;a href=&quot;https://sqlite.org/src/file/src/func.c&quot;&gt;func.c&lt;/a&gt; source file. Date and time conversion functions are found in &lt;a href=&quot;https://sqlite.org/src/file/src/date.c&quot;&gt;date.c&lt;/a&gt;. Some functions such as &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; are implemented as bytecode directly by the code generator.</source>
          <target state="translated">SQLite는 C 언어 루틴에 대한 콜백을 사용하여 SQL 함수를 구현합니다. 내장 SQL 함수조차도 이런 식으로 구현됩니다. 내장 SQL 함수 (예 : &lt;a href=&quot;lang_corefunc#abs&quot;&gt;abs ()&lt;/a&gt; , &lt;a href=&quot;lang_aggfunc#count&quot;&gt;count ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#substr&quot;&gt;substr ()&lt;/a&gt; 등)의 대부분은 &lt;a href=&quot;https://sqlite.org/src/file/src/func.c&quot;&gt;func.c&lt;/a&gt; 소스 파일 에서 찾을 수 있습니다 . 날짜 및 시간 변환 기능은 &lt;a href=&quot;https://sqlite.org/src/file/src/date.c&quot;&gt;date.c에&lt;/a&gt; 있습니다. &lt;a href=&quot;lang_corefunc#coalesce&quot;&gt;coalesce ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof &lt;/a&gt;() 와 같은 일부 함수 는 코드 생성기에 의해 직접 바이트 코드로 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="44379bdc54f42e9de25ccca623147353d761d9c1" translate="yes" xml:space="preserve">
          <source>SQLite implements isolation and concurrency control (and atomicity) using transient journal files that appear in the same directory in as the database file. There are two major &quot;journal modes&quot;. The older &quot;rollback mode&quot; corresponds to using the &quot;DELETE&quot;, &quot;PERSIST&quot;, or &quot;TRUNCATE&quot; options to the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;. In rollback mode, changes are written directly into the database file, while simultaneously a separate rollback journal file is constructed that is able to restore the database to its original state if the transaction rolls back. Rollback mode (specifically DELETE mode, meaning that the rollback journal is deleted from disk at the conclusion of each transaction) is the current default behavior.</source>
          <target state="translated">SQLite는 데이터베이스 파일과 동일한 디렉토리에 나타나는 임시 저널 파일을 사용하여 격리 및 동시성 제어 (및 원 자성)를 구현합니다. 두 가지 주요 &quot;저널 모드&quot;가 있습니다. 이전 &quot;롤백 모드&quot;는 &quot;DELETE&quot;, &quot;PERSIST&quot;또는 &quot;TRUNCATE&quot;옵션을 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma에 사용&lt;/a&gt; 하는 것과 같습니다 . 롤백 모드에서는 변경 사항이 데이터베이스 파일에 직접 기록되는 동시에 트랜잭션이 롤백되면 데이터베이스를 원래 상태로 복원 할 수있는 별도의 롤백 저널 파일이 구성됩니다. 롤백 모드 (특히, 트랜잭션 삭제시 롤백 저널이 디스크에서 삭제됨을 의미하는 DELETE 모드)가 현재 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b9d44a427593aad3444fe54a299daaaadaee9c2b" translate="yes" xml:space="preserve">
          <source>SQLite implements most of the common features of SQL. Rather than try to list all the features of SQL that SQLite does support, it is much easier to list those that it does not. Unsupported features of SQL are shown below.</source>
          <target state="translated">SQLite는 SQL의 일반적인 기능 대부분을 구현합니다. SQLite가 지원하는 SQL의 모든 기능을 나열하려고하기보다는 그렇지 않은 기능을 나열하는 것이 훨씬 쉽습니다. 지원되지 않는 SQL 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3786d84dc62565b9805fcc978b2dc22f28e9c31" translate="yes" xml:space="preserve">
          <source>SQLite implements run-time extension loading using the xDlOpen(), xDlError(), xDlSym(), and xDlClose() methods of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. These methods are implemented using the dlopen() library on unix (which explains why SQLite commonly need to be linked against the &quot;-ldl&quot; library on unix systems) and using LoadLibrary() API on Windows. In a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; for unusual systems, these methods can all be omitted, in which case the run-time extension loading mechanism will not work (though you will still be able to statically link the extension code, assuming the entry pointers are uniquely named). SQLite can be compiled with &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; to omit the extension loading code from the build.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xDlOpen (), xDlError (), xDlSym () 및 xDlClose () 메서드를 사용하여 런타임 확장 로딩을 구현 합니다. 이러한 메소드는 유닉스에서 dlopen () 라이브러리를 사용하여 구현되며 (유닉스 시스템에서 &quot;-ldl&quot;라이브러리에 대해 SQLite를 일반적으로 링크해야하는 이유를 설명합니다) Windows에서 LoadLibrary () API를 사용합니다. 비정상적인 시스템에 대한 사용자 정의 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 에서는 이러한 방법을 모두 생략 할 수 있습니다.이 경우 런타임 확장 로딩 메커니즘이 작동하지 않습니다 (항목 포인터의 이름이 고유하다고 가정하면 확장 코드를 정적으로 링크 할 수는 있지만) . SQLite는 &lt;a href=&quot;compile#omit_load_extension&quot;&gt;SQLITE_OMIT_LOAD_EXTENSION&lt;/a&gt; 으로 컴파일 하여 빌드에서 확장로드 코드를 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="325b495e36e305c6da36491d23c9a45ddd677117" translate="yes" xml:space="preserve">
          <source>SQLite implements the ORDER BY clause using a special set of instructions to control an object called a sorter. In the inner-most loop of the query, where there would normally be a Callback instruction, instead a record is constructed that contains both callback parameters and a key. This record is added to the sorter (in a linked list). After the query loop finishes, the list of records is sorted and this list is walked. For each record on the list, the callback is invoked. Finally, the sorter is closed and memory is deallocated.</source>
          <target state="translated">SQLite는 특수 명령 세트를 사용하여 ORDER BY 절을 구현하여 분류기라는 객체를 제어합니다. 일반적으로 콜백 명령어가있는 쿼리의 가장 안쪽 루프에서 콜백 매개 변수와 키가 모두 포함 된 레코드가 구성됩니다. 이 레코드는 분류기에 (연결된 목록으로) 추가됩니다. 쿼리 루프가 완료되면 레코드 목록이 정렬되고이 목록이 진행됩니다. 목록의 각 레코드에 대해 콜백이 호출됩니다. 마지막으로 분류 기가 닫히고 메모리가 할당 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="7bbf56d81f309f0a9cbabc4cabc75bf4752d9e1b" translate="yes" xml:space="preserve">
          <source>SQLite implements the command &quot;&lt;b&gt;DELETE FROM table&lt;/b&gt;&quot; (without a WHERE clause) by dropping the table then recreating it. This is much faster than deleting the elements of the table individually. But it also means that the value returned from &lt;b&gt;sqlite_changes&lt;/b&gt; will be zero regardless of the number of elements that were originally in the table. If an accurate count of the number of elements deleted is necessary, use &quot;&lt;b&gt;DELETE FROM table WHERE 1&lt;/b&gt;&quot; instead.</source>
          <target state="translated">SQLite 는 테이블을 삭제 한 후 다시 작성하여 &quot; &lt;b&gt;DELETE FROM table&lt;/b&gt; &quot; 명령 (WHERE 절없이)을 구현합니다. 이것은 테이블 요소를 개별적으로 삭제하는 것보다 훨씬 빠릅니다. 그러나 &lt;b&gt;sqlite_changes&lt;/b&gt; 에서 반환 된 값 은 원래 테이블에 있던 요소 수에 관계없이 0이됩니다. 삭제 된 요소 수의 정확한 개수가 필요한 경우 대신 &quot; &lt;b&gt;DELETE FROM table WHERE 1&lt;/b&gt; &quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9ab0efccb175242c24a04c63d7820adef1b32339" translate="yes" xml:space="preserve">
          <source>SQLite implements this interface by calling the xSleep() method of the default &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the xSleep() method of the default VFS is not implemented correctly, or not implemented at all, then the behavior of sqlite3_sleep() may deviate from the description in the previous paragraphs.</source>
          <target state="translated">SQLite는 기본 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xSleep () 메서드를 호출하여이 인터페이스를 구현 합니다. 기본 VFS의 xSleep () 메소드가 올바르게 구현되지 않거나 전혀 구현되지 않으면 sqlite3_sleep ()의 동작이 이전 단락의 설명에서 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f2e714978760592edabd2996e80f8001082574" translate="yes" xml:space="preserve">
          <source>SQLite implements this interface by calling the xSleep() method of the default &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object. If the xSleep() method of the default VFS is not implemented correctly, or not implemented at all, then the behavior of sqlite3_sleep() may deviate from the description in the previous paragraphs.</source>
          <target state="translated">SQLite는 기본 &lt;a href=&quot;vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xSleep () 메서드를 호출하여이 인터페이스를 구현 합니다. 기본 VFS의 xSleep () 메소드가 올바르게 구현되지 않거나 전혀 구현되지 않으면 sqlite3_sleep ()의 동작이 이전 단락의 설명에서 벗어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a283eba3413ed38200757b2476e06c81659c4de6" translate="yes" xml:space="preserve">
          <source>SQLite includes interfaces that can be used to extend its functionality. Such routines include:</source>
          <target state="translated">SQLite에는 기능을 확장하는 데 사용할 수있는 인터페이스가 포함되어 있습니다. 이러한 루틴에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4393772680ef025bd2cd5b1596f363dde45e77fe" translate="yes" xml:space="preserve">
          <source>SQLite interfaces can be subdivided into three categories:</source>
          <target state="translated">SQLite 인터페이스는 세 가지 범주로 세분 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="869311cd351a4162301e2c57a02fdd8d674a9eaa" translate="yes" xml:space="preserve">
          <source>SQLite invokes the xCreate() method to construct a new cache instance. SQLite will typically create one cache instance for each open database file, though this is not guaranteed. The first parameter, szPage, is the size in bytes of the pages that must be allocated by the cache. szPage will always a power of two. The second parameter szExtra is a number of bytes of extra storage associated with each page cache entry. The szExtra parameter will a number less than 250. SQLite will use the extra szExtra bytes on each page to store metadata about the underlying database page on disk. The value passed into szExtra depends on the SQLite version, the target platform, and how SQLite was compiled. The third argument to xCreate(), bPurgeable, is true if the cache being created will be used to cache database pages of a file stored on disk, or false if it is used for an in-memory database. The cache implementation does not have to do anything special based with the value of bPurgeable; it is purely advisory. On a cache where bPurgeable is false, SQLite will never invoke xUnpin() except to deliberately delete a page. In other words, calls to xUnpin() on a cache with bPurgeable set to false will always have the &quot;discard&quot; flag set to true. Hence, a cache created with bPurgeable false will never contain any unpinned pages.</source>
          <target state="translated">SQLite는 xCreate () 메소드를 호출하여 새 캐시 인스턴스를 구성합니다. SQLite는 일반적으로 열려있는 각 데이터베이스 파일에 대해 하나의 캐시 인스턴스를 작성하지만 이것이 보장되지는 않습니다. 첫 번째 매개 변수 인 szPage는 캐시에서 할당해야하는 페이지 크기 (바이트)입니다. szPage는 항상 2의 거듭 제곱입니다. 두 번째 매개 변수 szExtra는 각 페이지 캐시 항목과 연관된 추가 스토리지의 바이트 수입니다. szExtra 매개 변수는 250보다 작습니다. SQLite는 기본 데이터베이스 페이지에 대한 메타 데이터를 디스크에 저장하기 위해 각 페이지에서 추가 szExtra 바이트를 사용합니다. szExtra에 전달 된 값은 SQLite 버전, 대상 플랫폼 및 SQLite가 컴파일 된 방법에 따라 다릅니다. xCreate ()에 대한 세 번째 인수 인 bPurgeable은 작성중인 캐시가 디스크에 저장된 파일의 데이터베이스 페이지를 캐시하는 데 사용되는 경우 true입니다.인 메모리 데이터베이스에 사용되는 경우는 false 캐시 구현은 bPurgeable 값에 따라 특별한 작업을 수행 할 필요가 없습니다. 순전히 자문입니다. bPurgeable이 false 인 캐시에서 SQLite는 의도적으로 페이지를 삭제하는 것 외에는 xUnpin ()을 호출하지 않습니다. 즉, bPurgeable이 false로 설정된 캐시에서 xUnpin ()을 호출하면 항상 &quot;discard&quot;플래그가 true로 설정됩니다. 따라서 bPurgeable false로 작성된 캐시에는 고정되지 않은 페이지가 포함되지 않습니다.ignore &quot;플래그를 true로 설정합니다. 따라서 bPurgeable false로 작성된 캐시에는 고정되지 않은 페이지가 포함되지 않습니다.ignore &quot;플래그를 true로 설정합니다. 따라서 bPurgeable false로 작성된 캐시에는 고정되지 않은 페이지가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8d91a4eacb25ed345770672b419f8de28814833" translate="yes" xml:space="preserve">
          <source>SQLite invokes the xShrink() method when it wants the page cache to free up as much of heap memory as possible. The page cache implementation is not obligated to free any memory, but well-behaved implementations should do their best.</source>
          <target state="translated">SQLite는 페이지 캐시가 가능한 한 많은 힙 메모리를 비우기를 원할 때 xShrink () 메소드를 호출합니다. 페이지 캐시 구현은 메모리를 비워야 할 의무는 없지만 올바르게 작동하는 구현이 최선을 다해야합니다.</target>
        </trans-unit>
        <trans-unit id="e09baf70c513977bd9de806d34790308cc119db4" translate="yes" xml:space="preserve">
          <source>SQLite is &quot;stand-alone&quot; or &quot;self-contained&quot; in the sense that it has very few dependencies. It runs on any operating system, even stripped-down bare-bones embedded operating systems. SQLite uses no external libraries or interfaces (other than a few standard C-library calls described below). The entire SQLite library is encapsulated in a &lt;a href=&quot;amalgamation&quot;&gt;single source code file&lt;/a&gt; that requires no special facilities or tools to build.</source>
          <target state="translated">SQLite는 종속성이 거의 없다는 의미에서 &quot;독립형&quot;또는 &quot;독립형&quot;입니다. 모든 운영 체제에서 실행되며 심지어 베어 본 내장 운영 체제에서도 실행됩니다. SQLite는 외부 라이브러리 나 인터페이스를 사용하지 않습니다 (아래에 설명 된 몇 가지 표준 C 라이브러리 호출 제외). 전체 SQLite 라이브러리는 빌드 할 특수 기능이나 도구가 필요없는 &lt;a href=&quot;amalgamation&quot;&gt;단일 소스 코드 파일&lt;/a&gt; 로 캡슐화됩니다 .</target>
        </trans-unit>
        <trans-unit id="1aa8dbd8175f3712e9167826d5f455eab9e98ea7" translate="yes" xml:space="preserve">
          <source>SQLite is &quot;typeless&quot;. This means that you can store any kind of data you want in any column of any table, regardless of the declared datatype of that column. (See the one exception to this rule in section 2.0 below.) This behavior is a feature, not a bug. A database is supposed to store and retrieve data and it should not matter to the database what format that data is in. The strong typing system found in most other SQL engines and codified in the SQL language spec is a misfeature - it is an example of the implementation showing through into the interface. SQLite seeks to overcome this misfeature by allowing you to store any kind of data into any kind of column and by allowing flexibility in the specification of datatypes.</source>
          <target state="translated">SQLite는 &quot;typeless&quot;입니다. 즉, 해당 열의 선언 된 데이터 유형에 관계없이 테이블의 모든 열에 원하는 모든 종류의 데이터를 저장할 수 있습니다. 아래 섹션 2.0에서이 규칙에 대한 예외를 참조하십시오.이 동작은 버그가 아닌 기능입니다. 데이터베이스는 데이터를 저장하고 검색해야하며 데이터 형식이 데이터베이스에 중요하지 않아야합니다. 대부분의 다른 SQL 엔진에서 발견되고 SQL 언어 사양으로 체계화 된 강력한 타이핑 시스템은 잘못된 기능입니다. 인터페이스로 보여지는 구현. SQLite는 모든 종류의 데이터를 모든 종류의 열에 저장할 수있게하고 데이터 유형 지정에 유연성을 부여함으로써 이러한 잘못된 기능을 극복하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6db52ed99b096682e4bd1e419d2a2aa8458af934" translate="yes" xml:space="preserve">
          <source>SQLite is &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;open-source&lt;/a&gt; but it is not open-contribution. All the code in SQLite is written by a small team of experts. The project does not accept &quot;pull requests&quot; or patches from anonymous passers-by on the internet.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;공개 소스&lt;/a&gt; 이지만 공개 기고가 아닙니다. SQLite의 모든 코드는 소규모 전문가 팀이 작성합니다. 이 프로젝트는 인터넷을 통한 익명의 발신자의 &quot;풀 요청&quot;또는 패치를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b27dcc391997a09839d3385391811a8208d72225" translate="yes" xml:space="preserve">
          <source>SQLite is &lt;a href=&quot;testing&quot;&gt;very carefully tested&lt;/a&gt; to help ensure that it is as bug-free as possible. Among the many tests that are carried out for every SQLite version are tests that simulate power failures, I/O errors, and out-of-memory (OOM) errors and verify that no database corrupt occurs during any of these events. SQLite is also field-proven with approximately two billion active deployments with no serious problems.</source>
          <target state="translated">SQLite는 가능한 한 버그가 없는지 확인하기 위해 &lt;a href=&quot;testing&quot;&gt;매우 신중하게 테스트&lt;/a&gt; 되었습니다. 모든 SQLite 버전에 대해 수행되는 많은 테스트 중에는 정전, I / O 오류 및 메모리 부족 (OOM) 오류를 시뮬레이션하고 이러한 이벤트 중 데이터베이스 손상이 없는지 확인하는 테스트가 있습니다. SQLite는 심각한 문제없이 약 20 억 건의 배포가 현장에서 입증되었습니다.</target>
        </trans-unit>
        <trans-unit id="c11334f8a6d4c90017a71fe9095e22bfd142ceb6" translate="yes" xml:space="preserve">
          <source>SQLite is &lt;u&gt;not&lt;/u&gt; client/server, however. The SQLite database runs in the same process address space as the application. Queries do not involve message round-trips, only a function call. The latency of a single SQL query is far less in SQLite. Hence, using a large number of queries with SQLite is not the problem.</source>
          <target state="translated">그러나 SQLite는 클라이언트 / 서버 가 &lt;u&gt;아닙니다&lt;/u&gt; . SQLite 데이터베이스는 애플리케이션과 동일한 프로세스 주소 공간에서 실행됩니다. 쿼리는 메시지 왕복을 포함하지 않으며 함수 호출 만 포함합니다. 단일 SQL 쿼리의 대기 시간은 SQLite에서 훨씬 적습니다. 따라서 SQLite에 많은 수의 쿼리를 사용하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4bea428b4572c3265babc195d636c85dd16cd7d" translate="yes" xml:space="preserve">
          <source>SQLite is ANSI-C source code. It must be compiled into machine code before it is useful. This article is a guide to the various ways of compiling SQLite.</source>
          <target state="translated">SQLite는 ANSI-C 소스 코드입니다. 유용하기 전에 머신 코드로 컴파일해야합니다. 이 기사는 SQLite를 컴파일하는 다양한 방법에 대한 안내서입니다.</target>
        </trans-unit>
        <trans-unit id="a694ce58bf7379de2122bb1b8b62f901618b77c1" translate="yes" xml:space="preserve">
          <source>SQLite is Transactional</source>
          <target state="translated">SQLite는 트랜잭션입니다</target>
        </trans-unit>
        <trans-unit id="41195481e984eee6b772c414244a4b448aca2f82" translate="yes" xml:space="preserve">
          <source>SQLite is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Library_(computing)&quot;&gt;software library&lt;/a&gt; that translates high-level disk I/O requests generated by an application into low-level I/O operations that can be carried out by the operating system. The application constructs high-level I/O requests using the &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL&quot;&gt;SQL language&lt;/a&gt;. SQLite translates each high-level SQL statement into a sequence of many low-level I/O requests (open a file, read a few bytes from a file, write a few bytes into a file, etc.) that do the work requested by the SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="446762c2ed93e56023348a911dcbc0d76c6f8cf2" translate="yes" xml:space="preserve">
          <source>SQLite is a &lt;a href=&quot;https://www.loc.gov/preservation/resources/rfs/&quot;&gt;Recommended Storage Format&lt;/a&gt; for datasets according to the &lt;a href=&quot;https://www.loc.gov/&quot;&gt;US Library of Congress&lt;/a&gt;. Further information:</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://www.loc.gov/&quot;&gt;미국 의회 도서관에&lt;/a&gt; 따라 데이터 세트에 &lt;a href=&quot;https://www.loc.gov/preservation/resources/rfs/&quot;&gt;권장되는 스토리지 형식&lt;/a&gt; 입니다 . 추가 정보 :</target>
        </trans-unit>
        <trans-unit id="522312ab816ca3dd4464526e62012e35cc493c25" translate="yes" xml:space="preserve">
          <source>SQLite is a &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt; software library, whereas the other systems are client-server based. With MySQL, PostgreSQL, SQL-Server, and others, the application sends a message containing some SQL over to a separate server thread or process. That separate thread or process performs the requested I/O, then send the results back to the application. But there is no separate thread or process with SQLite. SQLite runs in the same address space as the application, using the same program counter and heap storage. SQLite does no interprocess communication (IPC). When an application sends an SQL statement into SQLite (by invoking a the appropriate SQLite library subroutine), SQLite interprets the SQL in the same thread as the caller. When an SQLite API routine returns, it does not leave behind any background tasks that run separately from the application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d1971ee5b77707ce34ac0536f708076c112ecc8" translate="yes" xml:space="preserve">
          <source>SQLite is a C-library that runs in the same address space as the application that it serves. That means that stray pointers, buffer overruns, heap corruption, or other malfunctions in the application can corrupt internal SQLite data structure and ultimately result in a corrupt database file. Normally these kinds of problems manifest themselves as segfaults prior to any database corruption occurring, but there have been instances where application code errors have caused SQLite to malfunction subtly so as to corrupt the database file rather than panicking.</source>
          <target state="translated">SQLite는 서비스를 제공하는 응용 프로그램과 동일한 주소 공간에서 실행되는 C 라이브러리입니다. 즉, 응용 프로그램의 스트레이 포인터, 버퍼 오버런, 힙 손상 또는 기타 오작동으로 인해 내부 SQLite 데이터 구조가 손상되어 궁극적으로 데이터베이스 파일이 손상 될 수 있습니다. 일반적으로 이러한 종류의 문제는 데이터베이스 손상이 발생하기 전에 segfault로 나타납니다. 그러나 응용 프로그램 코드 오류로 인해 SQLite가 미묘하게 오작동하여 당황하지 않고 데이터베이스 파일이 손상되는 경우가있었습니다.</target>
        </trans-unit>
        <trans-unit id="017a47b5545e38512155b34a1d9f857de667f2bb" translate="yes" xml:space="preserve">
          <source>SQLite is a Self Contained System</source>
          <target state="translated">SQLite는 독립형 시스템입니다</target>
        </trans-unit>
        <trans-unit id="05e7f4b2364ae4b953b34f6c921b7a5ea3867f94" translate="yes" xml:space="preserve">
          <source>SQLite is a good solution for any situation that requires bundling diverse content into a self-contained and self-describing package for shipment across a network. Content is encoded in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined, cross-platform, and stable file format&lt;/a&gt;. The encoding is efficient, and receivers can extract small subsets of the content without having to read and parse the entire file.</source>
          <target state="translated">SQLite는 다양한 콘텐츠를 네트워크를 통한 배송을 위해 자체 포함 된 자체 설명 패키지로 묶어야하는 모든 상황에 적합한 솔루션입니다. 콘텐츠는 &lt;a href=&quot;fileformat2&quot;&gt;잘 정의 된 교차 플랫폼의 안정적인 파일 형식으로 인코딩됩니다&lt;/a&gt; . 인코딩이 효율적이며 수신자는 전체 파일을 읽고 구문 분석하지 않고도 콘텐츠의 작은 하위 집합을 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="663e24794b8ab537e46fb80090c661ea79493e74" translate="yes" xml:space="preserve">
          <source>SQLite is a good solution for any situation that requires bundling diverse content into a self-contained and self-describing package for shipment across a network. Content is encoding in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined, cross-platform, and stable file format&lt;/a&gt;. The encoding is efficient, and receivers can extract small subsets of the content without having to read and parse the entire file.</source>
          <target state="translated">SQLite는 네트워크를 통해 선적하기 위해 다양한 컨텐츠를 자체 포함 된 자체 설명 패키지로 묶어야하는 모든 상황에 적합한 솔루션입니다. 컨텐츠는 &lt;a href=&quot;fileformat2&quot;&gt;잘 정의되고, 크로스 플랫폼이며 안정적인 파일 형식으로&lt;/a&gt; 인코딩 됩니다 . 인코딩은 효율적이며 수신자는 전체 파일을 읽고 구문 분석하지 않고도 컨텐츠의 작은 서브 세트를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="247c4a67391b665da341d6210067738ae06e1a54" translate="yes" xml:space="preserve">
          <source>SQLite is a high-reliability storage solution. It does not give problems. It just works.</source>
          <target state="translated">SQLite는 신뢰성이 높은 스토리지 솔루션입니다. 문제가되지 않습니다. 그냥 작동합니다.</target>
        </trans-unit>
        <trans-unit id="30822bd9c64d132478b5d1bdc08a62b48e9c0cb3" translate="yes" xml:space="preserve">
          <source>SQLite is able to limit the size of a database file to prevent the database file from growing too large and consuming too much disk space. The SQLITE_MAX_PAGE_COUNT parameter, which is normally set to 1073741823, is the maximum number of pages allowed in a single database file. An attempt to insert new data that would cause the database file to grow larger than this will return SQLITE_FULL.</source>
          <target state="translated">SQLite는 데이터베이스 파일의 크기를 제한하여 데이터베이스 파일이 너무 커지고 디스크 공간을 너무 많이 사용하지 못하게 할 수 있습니다. 일반적으로 1073741823으로 설정되는 SQLITE_MAX_PAGE_COUNT 매개 변수는 단일 데이터베이스 파일에서 허용되는 최대 페이지 수입니다. 데이터베이스 파일이 이보다 커질 수있는 새 데이터를 삽입하려고하면 SQLITE_FULL이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4cbf83ed4a424e770c465325d3f9d1b3f515ba13" translate="yes" xml:space="preserve">
          <source>SQLite is able to use multiple VFSes at the same time. Each individual database connection is associated with just one VFS. But if you have multiple database connections, each connection can be associated with a different VFS.</source>
          <target state="translated">SQLite는 동시에 여러 VFS를 사용할 수 있습니다. 각 개별 데이터베이스 연결은 하나의 VFS에만 연결됩니다. 그러나 데이터베이스 연결이 여러 개인 경우 각 연결은 다른 VFS와 연관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c555b3320f8787c7d985cc510e097760a2ba67e1" translate="yes" xml:space="preserve">
          <source>SQLite is an example of a classic serverless database engine. With SQLite, there are no other processes, threads, machines, or other mechanisms (apart from host computer OS and filesystem) to help provide database services or implementation. There really is no server.</source>
          <target state="translated">SQLite는 전형적인 서버리스 데이터베이스 엔진의 예입니다. SQLite를 사용하면 데이터베이스 서비스 또는 구현을 제공하는 데 도움이되는 다른 프로세스, 스레드, 시스템 또는 기타 메커니즘 (호스트 컴퓨터 OS 및 파일 시스템 제외)이 없습니다. 실제로 서버가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2d318f0e33e483c7b8003ffacee251b811c3c5c9" translate="yes" xml:space="preserve">
          <source>SQLite is built from over one hundred files of C code and script spread across multiple directories. The implementation of SQLite is pure ANSI-C, but many of the C-language source code files are either generated or transformed by auxiliary C programs and AWK, SED, and TCL scripts prior to being incorporated into the finished SQLite library. Building the necessary C programs and transforming and/or creating the C-language source code for SQLite is a complex process.</source>
          <target state="translated">SQLite는 100 개가 넘는 C 코드 파일과 스크립트를 여러 디렉토리에 분산시켜 구축되었습니다. SQLite의 구현은 순수한 ANSI-C이지만 많은 C 언어 소스 코드 파일은 완성 된 SQLite 라이브러리에 통합되기 전에 보조 C 프로그램과 AWK, SED 및 TCL 스크립트에 의해 생성되거나 변환됩니다. 필요한 C 프로그램을 구축하고 SQLite를위한 C 언어 소스 코드를 변환 및 / 또는 작성하는 것은 복잡한 과정입니다.</target>
        </trans-unit>
        <trans-unit id="6746f394557b9dabd8af972d9d23d7f801fedd98" translate="yes" xml:space="preserve">
          <source>SQLite is built using a &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;-inspired process. The &lt;a href=&quot;testing&quot;&gt;testing standards&lt;/a&gt; for SQLite are among the highest for commercial software.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B에서&lt;/a&gt; 영감을 얻은 프로세스를 사용하여 구축되었습니다 . SQLite 의 &lt;a href=&quot;testing&quot;&gt;테스트 표준&lt;/a&gt; 은 상용 소프트웨어에서 가장 높은 수준 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="875a9efc25bbb30b8f5d1660336c59da880170b4" translate="yes" xml:space="preserve">
          <source>SQLite is competitive with, and usually faster than, blobs stored in separate files on disk, for both reading and writing.</source>
          <target state="translated">SQLite는 읽기와 쓰기 모두 디스크에서 별도의 파일에 저장된 Blob과 비교하여 경쟁이 빠르며 일반적으로 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="53b3a565f93669221f3865969fe660536421aef7" translate="yes" xml:space="preserve">
          <source>SQLite is designed to meet most developer's needs without any changes or customization. When changes are needed, they can normally be accomplished using start-time &lt;a href=&quot;c3ref/config&quot;&gt;(1)&lt;/a&gt; or runtime &lt;a href=&quot;c3ref/db_config&quot;&gt;(2)&lt;/a&gt;&lt;a href=&quot;c3ref/limit&quot;&gt;(3)&lt;/a&gt;&lt;a href=&quot;c3ref/vfs_find&quot;&gt;(4)&lt;/a&gt; configuration methods or via &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. It is very rare that an application developer will need to edit the SQLite source code in order to incorporate SQLite into a product.</source>
          <target state="translated">SQLite는 변경이나 사용자 정의없이 대부분의 개발자 요구를 충족하도록 설계되었습니다. 변경이 필요한 경우 일반적으로 시작 시간 &lt;a href=&quot;c3ref/config&quot;&gt;(1)&lt;/a&gt; 또는 런타임 &lt;a href=&quot;c3ref/db_config&quot;&gt;(2) &lt;/a&gt;&lt;a href=&quot;c3ref/limit&quot;&gt;(3) &lt;/a&gt;&lt;a href=&quot;c3ref/vfs_find&quot;&gt;(4)&lt;/a&gt; 구성 방법을 사용하거나 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션을&lt;/a&gt; 통해 수행 할 수 있습니다 . SQLite를 제품에 통합하기 위해 애플리케이션 개발자가 SQLite 소스 코드를 편집해야하는 경우는 매우 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="2b810dc63ad4381febba6bfa7d0698c8944220e9" translate="yes" xml:space="preserve">
          <source>SQLite is different in that it stores the schema in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table as the original text of the CREATE statements that define the schema. Hence ALTER TABLE needs to revise the text of the CREATE statement. Doing so can be tricky for certain &quot;creative&quot; schema designs.</source>
          <target state="translated">SQLite는 스키마 를 정의하는 CREATE 문의 원본 텍스트로 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; 테이블에 스키마를 저장한다는 점에서 다릅니다 . 따라서 ALTER TABLE은 CREATE 문의 텍스트를 수정해야합니다. 특정 &quot;크리에이티브&quot;스키마 디자인에는 까다로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba0a35d8001d8dc075689278c2e501182c6877e" translate="yes" xml:space="preserve">
          <source>SQLite is different in that it stores the schema in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table as the original text of the CREATE statements that define the schema. Hence ALTER TABLE needs to revise the text of the CREATE statement. Doing so can be tricky for certain &quot;creative&quot; schema designs.</source>
          <target state="translated">SQLite는 스키마 를 정의하는 CREATE 문의 원본 텍스트로 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 테이블에 스키마를 저장한다는 점에서 다릅니다 . 따라서 ALTER TABLE은 CREATE 문의 텍스트를 수정해야합니다. 이렇게하는 것은 특정 &quot;창의적인&quot;스키마 디자인에서 까다로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4d9fd1ad4a17767c9b0eeee58f6c4cef761ec22" translate="yes" xml:space="preserve">
          <source>SQLite is expected to operate the same, and use exactly the same &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt;, on all modern operating systems, on all modern computer architectures, and using all modern C compilers. The developers are constantly testing SQLite on as many diverse platforms as they can get their hands on.</source>
          <target state="translated">SQLite는 모든 최신 운영 체제, 모든 최신 컴퓨터 아키텍처 및 모든 최신 C 컴파일러를 사용하여 동일하게 작동하고 정확히 동일한 &lt;a href=&quot;fileformat2&quot;&gt;온 디스크 형식을&lt;/a&gt; 사용해야합니다 . 개발자는 다양한 플랫폼에서 SQLite를 지속적으로 테스트하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae04c54b68c60010dff08d4f306e294deee8ba8" translate="yes" xml:space="preserve">
          <source>SQLite is in the Public Domain.</source>
          <target state="translated">SQLite는 공개 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="41978015003a28658fac35ad1aebf308a1d4bdc1" translate="yes" xml:space="preserve">
          <source>SQLite is much faster than direct writes to disk on Windows when anti-virus protection is turned on. Since anti-virus software is and should be on by default in Windows, that means that SQLite is generally much faster than direct disk writes on Windows.</source>
          <target state="translated">안티 바이러스 보호 기능이 설정되어있는 경우 SQLite는 Windows에서 디스크에 직접 쓰는 것보다 훨씬 빠릅니다. 안티 바이러스 소프트웨어는 Windows에서 기본적으로 켜져 있어야하므로 SQLite는 일반적으로 Windows에서 직접 디스크 쓰기보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d2117a2a67d4eee0f3af565533d9cac9c29e3ebe" translate="yes" xml:space="preserve">
          <source>SQLite is normally very forgiving about mismatches between the type of a value and the declared type of the container in which that value is to be stored. For example, SQLite allows the application to store a large BLOB in a column with a declared type of BOOLEAN. But in a few cases, SQLite is strict about types. The SQLITE_MISMATCH error is returned in those few cases when the types do not match.</source>
          <target state="translated">SQLite는 일반적으로 값 유형과 해당 값이 저장 될 컨테이너의 선언 된 유형 사이의 불일치를 매우 용서합니다. 예를 들어 SQLite를 사용하면 응용 프로그램에서 선언 된 유형이 BOOLEAN 인 열에 큰 BLOB를 저장할 수 있습니다. 그러나 SQLite는 유형에 대해 엄격한 경우가 있습니다. 유형이 일치하지 않는 경우에 SQLITE_MISMATCH 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="90d38f0f8852e6f3bc8f54ade94a7ff4da3d7a52" translate="yes" xml:space="preserve">
          <source>SQLite is not directly comparable to client/server SQL database engines such as MySQL, Oracle, PostgreSQL, or SQL Server since SQLite is trying to solve a different problem.</source>
          <target state="translated">SQLite는 다른 문제를 해결하려고하기 때문에 SQLite는 MySQL, Oracle, PostgreSQL 또는 SQL Server와 같은 클라이언트 / 서버 SQL 데이터베이스 엔진과 직접 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1435c0d28bf1363ba8e34333297e06f59701df95" translate="yes" xml:space="preserve">
          <source>SQLite is not particular about the text it receives and is more than happy to process text strings that are not normalized or even well-formed UTF-8 or UTF-16. Thus, programmers who want to store IS08859 data can do so using the UTF-8 interfaces. As long as no attempts are made to use a UTF-16 collating sequence or SQL function, the byte sequence of the text will not be modified in any way.</source>
          <target state="translated">SQLite는 수신하는 텍스트를 특별히 고려하지 않았으며 정규화되지 않았거나 올바르게 구성된 UTF-8 또는 UTF-16이 아닌 텍스트 문자열을 처리하는 것이 좋습니다. 따라서 IS08859 데이터를 저장하려는 프로그래머는 UTF-8 인터페이스를 사용하여 그렇게 할 수 있습니다. UTF-16 조합 순서 또는 SQL 함수를 사용하려고 시도하지 않는 한 텍스트의 바이트 순서는 어떤 식 으로든 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79f629ab8f652eed86f8d0cea408ad231ec0a7de" translate="yes" xml:space="preserve">
          <source>SQLite is not particular about the text it receives and is more than happy to process text strings that are not normalized or even well-formed UTF-8 or UTF-16. Thus, programmers who want to store ISO8859 data can do so using the UTF-8 interfaces. As long as no attempts are made to use a UTF-16 collating sequence or SQL function, the byte sequence of the text will not be modified in any way.</source>
          <target state="translated">SQLite는 수신하는 텍스트에 대해 특별하지 않으며 정규화되지 않은 텍스트 문자열 또는 잘 구성된 UTF-8 또는 UTF-16을 처리하는 데 더 만족합니다. 따라서 ISO8859 데이터를 저장하려는 프로그래머는 UTF-8 인터페이스를 사용하여 저장할 수 있습니다. UTF-16 조합 시퀀스 또는 SQL 함수를 사용하려는 시도가없는 한 텍스트의 바이트 시퀀스는 어떤 방식으로도 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1f069bbbe7e83bd0e5742fa278486eb680133a8" translate="yes" xml:space="preserve">
          <source>SQLite is not the perfect application file format for every situation. But in many cases, SQLite is a far better choice than either a custom file format, a pile-of-files, or a wrapped pile-of-files. SQLite is a high-level, stable, reliable, cross-platform, widely-deployed, extensible, performant, accessible, concurrent file format. It deserves your consideration as the standard file format on your next application design.</source>
          <target state="translated">SQLite는 모든 상황에서 완벽한 응용 프로그램 파일 형식은 아닙니다. 그러나 많은 경우 SQLite는 사용자 지정 파일 형식, 파일 더미 또는 랩 파일 더미보다 훨씬 나은 선택입니다. SQLite는 높은 수준의 안정적이고 안정적인 크로스 플랫폼이며 광범위하게 배포되고 확장 가능하며 성능이 뛰어나고 액세스 가능한 동시 파일 형식입니다. 다음 응용 프로그램 디자인에서 표준 파일 형식으로 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="587085de5e94b94b24e4a564a72e1cd94941218f" translate="yes" xml:space="preserve">
          <source>SQLite is often &lt;a href=&quot;fasterthanfs&quot;&gt;faster than direct low-level I/O&lt;/a&gt;. This is counterintuitive. One would expect that a high-level interface such as SQLite would impose a run-time penalty. And, theoretically, that is correct. But in practice, SQL-based systems such as SQLite do so many behind-the-scenes optimizations that an application developer would never have time to create and maintain, that the SQL-based systems end up providing a net performance gain.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9638ccd4cc256f849e2db07526c184593398229" translate="yes" xml:space="preserve">
          <source>SQLite is often used as the on-disk file format for desktop applications such as version control systems, financial analysis tools, media cataloging and editing suites, CAD packages, record keeping programs, and so forth. The traditional File/Open operation calls sqlite3_open() to attach to the database file. Updates happen automatically as application content is revised so the File/Save menu option becomes superfluous. The File/Save_As menu option can be implemented using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;.</source>
          <target state="translated">SQLite는 종종 버전 제어 시스템, 재무 분석 도구, 미디어 카탈로그 및 편집 제품군, CAD 패키지, 레코드 보관 프로그램 등과 같은 데스크톱 응용 프로그램을위한 온 디스크 파일 형식으로 사용됩니다. 전통적인 File / Open 작업은 sqlite3_open ()을 호출하여 데이터베이스 파일에 연결합니다. 파일 / 저장 메뉴 옵션이 불필요 해 지므로 응용 프로그램 내용이 수정되면 자동으로 업데이트됩니다. File / Save_As 메뉴 옵션은 &lt;a href=&quot;backup&quot;&gt;백업 API를&lt;/a&gt; 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f01574bffbe492a08f6a39612436763f1dce6eab" translate="yes" xml:space="preserve">
          <source>SQLite is one of many open-source projects that OSS Fuzz tests. The &lt;a href=&quot;https://www.sqlite.org/src/file/test/ossfuzz.c&quot;&gt;test/ossfuzz.c&lt;/a&gt; source file in the SQLite repository is SQLite's interface to OSS fuzz.</source>
          <target state="translated">SQLite는 OSS Fuzz가 테스트하는 많은 오픈 소스 프로젝트 중 하나입니다. SQLite 리포지토리 의 &lt;a href=&quot;https://www.sqlite.org/src/file/test/ossfuzz.c&quot;&gt;test / ossfuzz.c&lt;/a&gt; 소스 파일은 SQLite의 OSS 퍼즈 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bf60766f31de04598304b77a31a30aab178aeaf9" translate="yes" xml:space="preserve">
          <source>SQLite is one of the &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;most used&lt;/a&gt; software libraries in the world. There are literally tens of billions of SQLite database files in use daily, on smartphones and gadgets and in desktop applications. SQLite is &lt;a href=&quot;testing&quot;&gt;carefully tested&lt;/a&gt; and proven reliable. It is not a component that needs much tuning or debugging, allowing developers to stay focused on application logic.</source>
          <target state="translated">SQLite는 세계에서 &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;가장 많이 사용되는&lt;/a&gt; 소프트웨어 라이브러리 중 하나입니다 . 문자 그대로 스마트 폰과 가제트 및 데스크톱 응용 프로그램에서 매일 수백억 개의 SQLite 데이터베이스 파일이 사용되고 있습니다. SQLite는 &lt;a href=&quot;testing&quot;&gt;신중하게 테스트&lt;/a&gt; 되었으며 신뢰성이 입증되었습니다. 많은 튜닝이나 디버깅이 필요한 구성 요소가 아니므로 개발자는 응용 프로그램 논리에 계속 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b472863a9267f026cee0ca0b35a15991ef89b036" translate="yes" xml:space="preserve">
          <source>SQLite is open source. This gives many people the idea that it is not well tested as commercial software and is perhaps unreliable. But that impression is false. SQLite has exhibited very high reliability in the field and a very low defect rate, especially considering how rapidly it is evolving. The quality of SQLite is achieved in part by careful code design and implementation. But extensive testing also plays a vital role in maintaining and improving the quality of SQLite. This document has summarized the testing procedures that every release of SQLite undergoes with the hope of inspiring confidence that SQLite is suitable for use in mission-critical applications.</source>
          <target state="translated">SQLite는 오픈 소스입니다. 이것은 많은 사람들에게 상용 소프트웨어로서 잘 테스트되지 않았으며 아마도 신뢰할 수 없다는 아이디어를 제공합니다. 그러나 그 인상은 거짓입니다. SQLite는 특히 빠르게 발전하는 것을 고려할 때 현장에서 매우 높은 신뢰성과 매우 낮은 결함률을 보여주었습니다. SQLite의 품질은 신중한 코드 디자인 및 구현으로 부분적으로 달성됩니다. 그러나 광범위한 테스트는 SQLite의 품질을 유지하고 향상시키는 데 중요한 역할을합니다. 이 문서는 SQLite가 미션 크리티컬 애플리케이션에 사용하기에 적합하다는 확신을 갖기 위해 모든 SQLite 릴리스가 수행되는 테스트 절차를 요약했습니다.</target>
        </trans-unit>
        <trans-unit id="dbc3c1fb569cecbb959acf32375d7a9409c9e7db" translate="yes" xml:space="preserve">
          <source>SQLite is required to &lt;b&gt;implement atomic and durable transactions&lt;/b&gt; (the 'A' and 'D' from the ACID acronym), even if an application, operating system or power failure occurs midway through or shortly after updating a database file.</source>
          <target state="translated">SQLite는 데이터베이스 파일을 업데이트 한 후 응용 프로그램, 운영 체제 또는 정전이 발생하더라도 &lt;b&gt;원자적이고 내구성있는 트랜잭션&lt;/b&gt; (ACID 약어의 'A'및 'D') 을 &lt;b&gt;구현&lt;/b&gt; 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="362f767a2655b7418135c488c8146a1c344658d9" translate="yes" xml:space="preserve">
          <source>SQLite is required to &lt;b&gt;implement isolated transactions&lt;/b&gt; (the 'I' from the ACID acronym).</source>
          <target state="translated">SQLite는 &lt;b&gt;격리 된 트랜잭션&lt;/b&gt; (ACID 약어의 'I') 을 &lt;b&gt;구현&lt;/b&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b642e02aa031422407ba1e2eb9a921d7af9484d1" translate="yes" xml:space="preserve">
          <source>SQLite is resilient in the face of corrupt inputs, including maliciously designed database files and SQL strings. Extensive fuzz-testing ensures that corrupt inputs will not lead to crashes or undefined behavior, but will instead cause sensible errors to be reported back to the application.</source>
          <target state="translated">SQLite는 악의적으로 설계된 데이터베이스 파일 및 SQL 문자열을 포함하여 손상된 입력에 대해 복원력이 뛰어납니다. 광범위한 퍼지 테스트는 손상된 입력으로 인해 충돌이 발생하거나 정의되지 않은 동작이 발생하지 않고 대신 응용 프로그램에 합리적인 오류가보고되도록합니다.</target>
        </trans-unit>
        <trans-unit id="80231535020620422bab08d0c25caafae2be3ab2" translate="yes" xml:space="preserve">
          <source>SQLite is resilient in the face of corrupt inputs, including maliciously designed database files and SQL strings. Extensive fuzz-testing ensures that corrupt inputs will not lead to crashes or undefined behavior, but will instead cause sensible errors to be reported back to the application. (&lt;a href=&quot;security&quot;&gt;More...&lt;/a&gt;)</source>
          <target state="translated">SQLite는 악의적으로 설계된 데이터베이스 파일 및 SQL 문자열을 포함하여 손상된 입력에 대해 탄력적입니다. 광범위한 퍼즈 테스트를 통해 손상된 입력이 충돌이나 정의되지 않은 동작으로 이어지지 않고 대신 애플리케이션에 다시보고되는 현명한 오류를 유발합니다. ( &lt;a href=&quot;security&quot;&gt;더 ...&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f5423cc6a7fa9f9530e2a51fe8a881bbb932c031" translate="yes" xml:space="preserve">
          <source>SQLite is slower at creating new indices. This is not a huge problem (since new indices are not created very often) but it is something that is being worked on. Hopefully, future versions of SQLite will do better here.</source>
          <target state="translated">SQLite는 새로운 인덱스 생성 속도가 느립니다. 이것은 새로운 문제가 자주 발생하지 않기 때문에 큰 문제는 아니지만 해결하려는 문제입니다. 다행스럽게도 향후 버전의 SQLite가 더 잘 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="54a5009f6cdb462eb942bac870b07db8a1670fab" translate="yes" xml:space="preserve">
          <source>SQLite is slower than the other databases when it comes to dropping tables. This probably is because when SQLite drops a table, it has to go through and erase the records in the database file that deal with that table. MySQL and PostgreSQL, on the other hand, use separate files to represent each table so they can drop a table simply by deleting a file, which is much faster.</source>
          <target state="translated">SQLite는 테이블을 삭제할 때 다른 데이터베이스보다 느립니다. SQLite가 테이블을 삭제하면 해당 테이블을 처리하는 데이터베이스 파일의 레코드를 거쳐 삭제해야하기 때문일 수 있습니다. 반면에 MySQL과 PostgreSQL은 별도의 파일을 사용하여 각 테이블을 나타내므로 파일을 삭제하여 테이블을 삭제하는 것이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d7366e08ffe20946fd76e62d62945bcc30d399f9" translate="yes" xml:space="preserve">
          <source>SQLite is threadsafe because it uses mutexes to serialize access to common data structures. However, the work of acquiring and releasing these mutexes will slow SQLite down slightly. Hence, if you do not need SQLite to be threadsafe, you should disable the mutexes for maximum performance. See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">SQLite는 뮤텍스를 사용하여 공통 데이터 구조에 대한 액세스를 직렬화하기 때문에 스레드로부터 안전합니다. 그러나 이러한 뮤텍스를 가져 와서 해제하면 SQLite가 약간 느려집니다. 따라서 스레드 안전을 위해 SQLite가 필요하지 않은 경우 최대 성능을 위해 뮤텍스를 비활성화해야합니다. 추가 정보 는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cd3013ad5660f204f66ad31e2c31dd8240e6bb5" translate="yes" xml:space="preserve">
          <source>SQLite is threadsafe. We make this concession since many users choose to ignore the advice given in the previous paragraph. But in order to be thread-safe, SQLite must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1. Both the Windows and Linux precompiled binaries in the distribution are compiled this way. If you are unsure if the SQLite library you are linking against is compiled to be threadsafe you can call the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface to find out.</source>
          <target state="translated">SQLite는 스레드 세이프입니다. 많은 사용자가 이전 단락에 제공된 조언을 무시하기로 선택했기 때문에 우리는이 양보를합니다. 그러나 스레드 안전을 위해 SQLite는 SQLITE_THREADSAFE 전 처리기 매크로를 1로 설정하여 컴파일해야합니다. 배포시 Windows 및 Linux 사전 컴파일 된 바이너리는이 방법으로 컴파일됩니다. 링크하는 SQLite 라이브러리가 스레드 안전으로 컴파일되었는지 확실하지 않은 경우 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스를 호출하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39eff500cd7ce6dc1730207961cc564613eaac4f" translate="yes" xml:space="preserve">
          <source>SQLite is transactional, meaning that multiple changes can be grouped together such that either all or none of them occur, and so that the changes can be rolled back if a problem is found prior to commit. This allows an application to make a change incrementally, then run various sanity and consistency checks on the resulting data prior to committing the changes to disk. The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; DVCS &lt;a href=&quot;http://www.fossil-scm.org/fossil/doc/tip/www/selfcheck.wiki&quot;&gt;uses this technique&lt;/a&gt; to verify that no repository history has been lost prior to each change.</source>
          <target state="translated">SQLite는 트랜잭션 방식이므로 여러 변경 사항을 그룹화하여 모두 또는 전혀 발생하지 않으며 커밋 전에 문제가 발견되면 변경 사항을 롤백 할 수 있습니다. 이를 통해 응용 프로그램은 점진적으로 변경 한 다음 변경 내용을 디스크에 커밋하기 전에 결과 데이터에 대해 다양한 무결성 및 일관성 검사를 실행할 수 있습니다. &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; DVCS는 &lt;a href=&quot;http://www.fossil-scm.org/fossil/doc/tip/www/selfcheck.wiki&quot;&gt;이 기술을 사용하여&lt;/a&gt; 더 저장소 역사는 각 변경 이전에 손실되지 않았 음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="431631b26b413c56876cd9120450d97fb29610b5" translate="yes" xml:space="preserve">
          <source>SQLite is typeless for the purpose of deciding what data is allowed to be stored in a column. But some notion of type comes into play when sorting and comparing data. For these purposes, a column or an expression can be one of two types: &lt;b&gt;numeric&lt;/b&gt; and &lt;b&gt;text&lt;/b&gt;. The sort or comparison may give different results depending on which type of data is being sorted or compared.</source>
          <target state="translated">SQLite는 열에 저장할 수있는 데이터를 결정하기 위해 유형이 없습니다. 그러나 데이터를 정렬하고 비교할 때 일부 유형의 개념이 작동합니다. 이러한 목적으로 열 또는 표현식은 &lt;b&gt;numeric&lt;/b&gt; 및 &lt;b&gt;text&lt;/b&gt; 두 가지 유형 중 하나 일 수 있습니다 . 정렬 또는 비교는 정렬 또는 비교중인 데이터 유형에 따라 다른 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a51a3f7b3710595af5efe3e3c4508040aaab8c5" translate="yes" xml:space="preserve">
          <source>SQLite is very flexible with regard to datatypes.</source>
          <target state="translated">SQLite는 데이터 유형과 관련하여 매우 유연합니다.</target>
        </trans-unit>
        <trans-unit id="09d4e4b5b66b8b33e92f1d4cdf491ca8f18b646b" translate="yes" xml:space="preserve">
          <source>SQLite is very good at doing INSERTs within a transaction, which probably explains why it is so much faster than the other databases at this test.</source>
          <target state="translated">SQLite는 트랜잭션 내에서 INSERT를 수행하는 데 매우 능숙합니다.이 테스트에서 다른 데이터베이스보다 훨씬 빠른 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f9422ec4c9c62f3dc785dbb76b2bd0e31c1307c2" translate="yes" xml:space="preserve">
          <source>SQLite is written in portable C code. Development work occurs on a mix of Linux, Mac, and Windows workstations. The developers use command-line tools and eschew integrated development environments (IDEs) whenever possible. All developers are expected to be fluent with the unix command-line.</source>
          <target state="translated">SQLite는 이식 가능한 C 코드로 작성되었습니다. 개발 작업은 Linux, Mac 및 Windows 워크 스테이션이 혼합되어 수행됩니다. 개발자는 명령 줄 도구를 사용하고 가능할 때마다 통합 개발 환경 (IDE)을 피합니다. 모든 개발자는 유닉스 명령 줄에 능숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e1e2d740adcf0319f2b64ec4840724790f32367" translate="yes" xml:space="preserve">
          <source>SQLite itself does not pay any attention to environment variables in this case, though presumably the GetTempPath() system call does. The search algorithm is different for CYGWIN builds. Check the source code for details.</source>
          <target state="translated">이 경우 SQLite 자체는 환경 변수에주의를 기울이지 않지만 아마도 GetTempPath () 시스템 호출은 그렇지 않습니다. 검색 알고리즘은 CYGWIN 빌드와 다릅니다. 자세한 내용은 소스 코드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="04e08b220ef652d98be99d5e0babd01a982e4f55" translate="yes" xml:space="preserve">
          <source>SQLite itself is in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt; and can be used for any purpose. But TH3 is proprietary and requires a license.</source>
          <target state="translated">SQLite 자체는 &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;공개 도메인에&lt;/a&gt; 있으며 어떤 목적으로도 사용할 수 있습니다. 그러나 TH3은 독점적이며 라이센스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d3d3e9abb52e314e484928a8bc96db9c3ff377a7" translate="yes" xml:space="preserve">
          <source>SQLite just works.</source>
          <target state="translated">SQLite는 작동합니다.</target>
        </trans-unit>
        <trans-unit id="721ec90166a13c1e4ac7e7556c93fcbe5d07f6e2" translate="yes" xml:space="preserve">
          <source>SQLite keeps track of the largest ROWID using an &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal table&lt;/a&gt; named &quot;&lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt;&quot;. The sqlite_sequence table is created and initialized automatically whenever a normal table that contains an AUTOINCREMENT column is created. The content of the sqlite_sequence table can be modified using ordinary UPDATE, INSERT, and DELETE statements. But making modifications to this table will likely perturb the AUTOINCREMENT key generation algorithm. Make sure you know what you are doing before you undertake such changes. The sqlite_sequence table does not track ROWID changes associated with UPDATE statement, only INSERT statements.</source>
          <target state="translated">SQLite 는 &quot; &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; &quot; 라는 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 테이블을&lt;/a&gt; 사용하여 가장 큰 ROWID를 추적합니다 . sqlite_sequence 테이블은 AUTOINCREMENT 컬럼을 포함하는 일반 테이블이 작성 될 때마다 자동으로 작성되고 초기화됩니다. sqlite_sequence 테이블의 내용은 일반적인 UPDATE, INSERT 및 DELETE 문을 사용하여 수정할 수 있습니다. 그러나이 테이블을 수정하면 AUTOINCREMENT 키 생성 알고리즘이 혼란 스러울 수 있습니다. 그러한 변경을 수행하기 전에 현재하고있는 일을 알아야합니다. sqlite_sequence 테이블은 UPDATE 문과 연관된 ROWID 변경 사항을 추적하지 않으며 INSERT 문만 추적합니다.</target>
        </trans-unit>
        <trans-unit id="1fdbbf49537d5896499e4f580d89d3d977843a76" translate="yes" xml:space="preserve">
          <source>SQLite lets me insert a string into a database column of type integer!</source>
          <target state="translated">SQLite를 사용하면 정수 유형의 데이터베이스 열에 문자열을 삽입 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="e525cc6d45550b4b1a265dd25df50cc71c4474b0" translate="yes" xml:space="preserve">
          <source>SQLite limits the depth of recursion of triggers in order to prevent a statement involving recursive triggers from using an unbounded amount of memory.</source>
          <target state="translated">SQLite는 재귀 트리거와 관련된 명령문이 무제한의 메모리를 사용하지 못하도록 트리거 재귀 깊이를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bb5977c1cc25afeb2b0e4bd5a50680da96bdd766" translate="yes" xml:space="preserve">
          <source>SQLite makes a copy of the content of the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object so the object can be modified after the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 객체 의 내용을 복사 하므로 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출이 반환 된 후 객체를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1791cae0a6c7259639f6781e55e553d509ec456" translate="yes" xml:space="preserve">
          <source>SQLite makes no guarantees about the order of results if a SELECT omits the ORDER BY clause. Even so, the order of results does not change from one run to the next, and so many applications mistakenly come to depend on the arbitrary output order whatever that order happens to be. However, sometimes new versions of SQLite will contain optimizer enhancements that will cause the output order of queries without ORDER BY clauses to shift. When that happens, applications that depend on a certain output order might malfunction. By running the application multiple times with this pragma both disabled and enabled, cases where the application makes faulty assumptions about output order can be identified and fixed early, reducing problems that might be caused by linking against a different version of SQLite.</source>
          <target state="translated">SELECT는 ORDER BY 절을 생략하면 SQLite는 결과 순서를 보증하지 않습니다. 그럼에도 불구하고 결과의 순서는 한 실행에서 다음 실행으로 변경되지 않으므로 많은 응용 프로그램이 순서에 관계없이 임의의 출력 순서에 의존하게됩니다. 그러나 때때로 새로운 버전의 SQLite에는 ORDER BY 절이없는 쿼리의 출력 순서가 바뀌는 최적화 기능이 향상됩니다. 이 경우 특정 출력 순서에 의존하는 응용 프로그램이 오작동 할 수 있습니다. 이 pragma를 사용 안함 및 사용으로 애플리케이션을 여러 번 실행하면 애플리케이션이 출력 순서에 대해 잘못된 가정을하는 경우를 조기에 식별하고 수정할 수 있으므로 다른 버전의 SQLite에 대한 링크로 인해 발생할 수있는 문제점을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ac4bc4025ad0a187612fd2738f58e087756b50" translate="yes" xml:space="preserve">
          <source>SQLite manipulates the contents of the file-system using a combination of the following four types of operation:</source>
          <target state="translated">SQLite는 다음 네 가지 유형의 작업 조합을 사용하여 파일 시스템의 내용을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="cd796a8c085bea850ea98c0f816e6ce6c1055032" translate="yes" xml:space="preserve">
          <source>SQLite may attempt to convert values between the storage classes INTEGER, REAL, and/or TEXT before performing a comparison. Whether or not any conversions are attempted before the comparison takes place depends on the type affinity of the operands.</source>
          <target state="translated">SQLite는 비교를 수행하기 전에 스토리지 클래스 INTEGER, REAL 및 / 또는 TEXT 간의 값 변환을 시도 할 수 있습니다. 비교를 수행하기 전에 변환을 시도할지 여부는 피연산자의 유형 선호도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="86322113b50354d8e93e1a8d65dbbd7e579ef951" translate="yes" xml:space="preserve">
          <source>SQLite may make use of transient indices to implement SQL language features such as:</source>
          <target state="translated">SQLite는 다음과 같은 SQL 언어 기능을 구현하기 위해 임시 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692bd1d4aef60fc758b11851675895cb10aedde7" translate="yes" xml:space="preserve">
          <source>SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">SQLite는 xOpen 메소드에 다음 플래그 중 하나를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="945af510f90e6578c1019b41a7ec0b83b8498700" translate="yes" xml:space="preserve">
          <source>SQLite might use a skip-scan on an index if it knows that the first one or more columns contain many duplication values. If there are too few duplicates in the left-most columns of the index, then it would be faster to simply step ahead to the next value, and thus do a full table scan, than to do a binary search on an index to locate the next left-column value.</source>
          <target state="translated">SQLite는 첫 번째 하나 이상의 열에 많은 중복 값이 ​​포함되어 있음을 알고 있으면 인덱스에서 건너 뛰기 스캔을 사용할 수 있습니다. 인덱스의 가장 왼쪽 열에 중복이 너무 적 으면 인덱스에서 이진 검색을 수행하는 것보다 단순히 다음 값으로 진행하여 전체 테이블 스캔을 수행하는 것이 더 빠릅니다. 다음 왼쪽 열 값</target>
        </trans-unit>
        <trans-unit id="ae7f6237fc49c4f40b5f79296508bbf096f1c300" translate="yes" xml:space="preserve">
          <source>SQLite must see the journal files in order to recover from a crash or power failure. If the &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal files&lt;/a&gt; are moved, deleted, or renamed after a crash or power failure, then automatic recovery will not work and the database may go corrupt.</source>
          <target state="translated">충돌 또는 정전으로부터 복구하려면 SQLite가 저널 파일을 확인해야합니다. 는 IF &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;뜨거운 저널 파일을&lt;/a&gt; 이동, 삭제, 또는 충돌이나 정전 후 이름을 바꾼 후 자동 복구가 작동하지 않습니다 데이터베이스가 손상 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e833260d531c8e2e412472ff105b04979b5cf7c" translate="yes" xml:space="preserve">
          <source>SQLite mutexes can also be disabled at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. To completely disable all mutexing, the application can invoke:</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 SQLite 뮤텍스를 비활성화 할 수도 있습니다 . 모든 뮤텍스를 완전히 비활성화하기 위해 응용 프로그램은 다음을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17328ec696bc91982c93295b65652b033f2ec296" translate="yes" xml:space="preserve">
          <source>SQLite needs to know if the native byte order of the target CPU is big-endian or little-ending. The SQLITE_BYTEORDER preprocessor is set to 4321 for big-endian machines and 1234 for little-endian machines, or it can be 0 to mean that the byte order must be determined at run-time. There are #ifdefs in the code that set SQLITE_BYTEORDER automatically for all common platforms and compilers. However, it may be advantageous to set SQLITE_BYTEORDER appropriately when compiling SQLite for obscure targets. If the target byte order cannot be determined at compile-time, then SQLite falls back to doing run-time checks, which always work, though with a small performance penalty.</source>
          <target state="translated">SQLite는 대상 CPU의 기본 바이트 순서가 빅 엔디안인지 아니면 리틀 엔딩인지 알아야합니다. SQLITE_BYTEORDER 프리 프로세서는 빅 엔디안 머신의 경우 4321, 리틀 엔디안 머신의 경우 1234로 설정되거나 바이트 순서가 런타임시 결정되어야 함을 의미하는 0 일 수 있습니다. 모든 공통 플랫폼 및 컴파일러에 대해 SQLITE_BYTEORDER를 자동으로 설정하는 #ifdef가 코드에 있습니다. 그러나 모호한 대상에 대해 SQLite를 컴파일 할 때 SQLITE_BYTEORDER를 적절하게 설정하는 것이 유리할 수 있습니다. 컴파일 타임에 대상 바이트 순서를 결정할 수 없으면 SQLite는 런타임 검사를 수행합니다.이 검사는 성능 저하가 거의 없지만 항상 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eec4b7f1b229092638c755d579865f53adc26ae9" translate="yes" xml:space="preserve">
          <source>SQLite never assumes atomic page writes &lt;em&gt;in its default configurations&lt;/em&gt;. But a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can set one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits in the result of the xDeviceCharacteristic() method and then SQLite will assume that page writes are atomic. The application must supply a custom VFS to accomplish this, however, since none of the standard VFSes will ever set any of the atomic bits in the xDeviceCharacteristics() vector.</source>
          <target state="translated">SQLite &lt;em&gt;는 기본 구성에서&lt;/em&gt; 원자 페이지 쓰기 &lt;em&gt;를&lt;/em&gt; 가정하지 않습니다 . 그러나 사용자 정의 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 xDeviceCharacteristic () 메소드의 결과에서 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; 비트 중 하나를 설정할 수 있으며 SQLite는 페이지 쓰기가 원자 적이라고 가정합니다. 그러나 표준 VFS 중 어느 것도 xDeviceCharacteristics () 벡터에 원자 비트를 설정하지 않으므로 응용 프로그램은이를 수행하기 위해 사용자 지정 VFS를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e50c611c2a64f7dc9dc711887d5a6dcc24f10de" translate="yes" xml:space="preserve">
          <source>SQLite never assumes that database page writes are atomic, regardless of the PSOW setting.&lt;sup&gt;(1)&lt;/sup&gt; And hence SQLite is always able to automatically recover from torn pages induced by a crash. Enabling PSOW does not decrease SQLite's ability to recover from a torn page.</source>
          <target state="translated">SQLite는 PSOW 설정에 관계없이 데이터베이스 페이지 쓰기가 원 자성이라고 가정하지 않습니다. &lt;sup&gt;(1)&lt;/sup&gt; 따라서 SQLite는 충돌로 인한 찢어진 페이지에서 항상 자동으로 복구 할 수 있습니다. PSOW를 활성화해도 찢어진 페이지에서 복구하는 SQLite의 기능은 감소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a73150dbd46d3caaecfb727306a8488e11089c46" translate="yes" xml:space="preserve">
          <source>SQLite normally stores all content in a single disk file. However, while performing a transaction, information necessary to recover the database following a crash or power failure is stored in auxiliary journal files. Such journal files are described as &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;&quot;hot&quot;&lt;/a&gt;. The journal files have the same name as the original database file with the addition of &lt;code&gt;-journal&lt;/code&gt; or &lt;code&gt;-wal&lt;/code&gt; suffix.</source>
          <target state="translated">SQLite는 일반적으로 모든 내용을 단일 디스크 파일에 저장합니다. 그러나 트랜잭션을 수행하는 동안 충돌 또는 정전 후 데이터베이스를 복구하는 데 필요한 정보는 보조 저널 파일에 저장됩니다. 이러한 저널 파일은 &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;&quot;hot&quot;으로&lt;/a&gt; 설명됩니다 . 저널 파일의 추가와 함께 원본 데이터베이스 파일과 동일한 이름이 &lt;code&gt;-journal&lt;/code&gt; 또는 &lt;code&gt;-wal&lt;/code&gt; 접미사.</target>
        </trans-unit>
        <trans-unit id="7c2764b7ab8c8fe2115410e837d5a49ba37682ad" translate="yes" xml:space="preserve">
          <source>SQLite now honors the UNIQUE keyword in CREATE UNIQUE INDEX. Primary keys are required to be unique.</source>
          <target state="translated">SQLite는 이제 CREATE UNIQUE INDEX에서 UNIQUE 키워드를 사용합니다. 기본 키는 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b528bcd272bd4532c5fdb40cce96437b126ffc1d" translate="yes" xml:space="preserve">
          <source>SQLite now implements all of its built-in functions using this interface. For additional information and examples on how to create new SQL functions, review the SQLite source code in the file &lt;b&gt;func.c&lt;/b&gt;.</source>
          <target state="translated">SQLite는 이제이 인터페이스를 사용하여 모든 내장 함수를 구현합니다. 새 SQL 함수를 작성하는 방법에 대한 추가 정보 및 예제는 &lt;b&gt;func.c&lt;/b&gt; 파일에서 SQLite 소스 코드를 검토하십시오 .</target>
        </trans-unit>
        <trans-unit id="741c17c0aae3a15bc76f9c3b0feb23ceb419b07b" translate="yes" xml:space="preserve">
          <source>SQLite only supports one writer at a time per database file. But in most cases, a write transaction only takes milliseconds and so multiple writers can simply take turns. SQLite will handle more write concurrency that many people suspect. Nevertheless, client/server database systems, because they have a long-running server process at hand to coordinate access, can usually handle far more write concurrency than SQLite ever will.</source>
          <target state="translated">SQLite는 데이터베이스 파일 당 한 번에 하나의 기록기 만 지원합니다. 그러나 대부분의 경우 쓰기 트랜잭션은 밀리 초에 불과하므로 여러 작성자가 간단히 전환 할 수 있습니다. SQLite는 많은 사람들이 의심하는 더 많은 쓰기 동시성을 처리합니다. 그럼에도 불구하고 클라이언트 / 서버 데이터베이스 시스템은 액세스를 조정하기 위해 오랫동안 실행되는 서버 프로세스를 가지고 있기 때문에 일반적으로 SQLite보다 훨씬 많은 쓰기 동시성을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbe82e83c540bf7ce2e1eadb8c5b0e3352775de" translate="yes" xml:space="preserve">
          <source>SQLite parses MATCH clauses (i.e. does not report a syntax error if you specify one), but does not enforce them. All foreign key constraints in SQLite are handled as if MATCH SIMPLE were specified.</source>
          <target state="translated">SQLite는 MATCH 절을 구문 분석하고 (구문을 지정하면 구문 오류를보고하지 않음) 강제로 적용하지 않습니다. SQLite의 모든 외래 키 제약 조건은 MATCH SIMPLE이 지정된 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c52abe2b4224c19357e2fb51b9983ebbf48e0915" translate="yes" xml:space="preserve">
          <source>SQLite parses expressions into a tree for processing. During code generation, SQLite walks this tree recursively. The depth of expression trees is therefore limited in order to avoid using too much stack space.</source>
          <target state="translated">SQLite는 처리를 위해 표현식을 트리로 구문 분석합니다. 코드 생성 중에 SQLite는이 트리를 재귀 적으로 안내합니다. 따라서 스택 공간을 너무 많이 사용하지 않도록 식 트리의 깊이가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="52651f8e847f0d13fb28fbf85a29bff92a837a41" translate="yes" xml:space="preserve">
          <source>SQLite processes this by gathering all the output of query and then running that output through a sorter.</source>
          <target state="translated">SQLite는 쿼리의 모든 출력을 수집 한 다음 분류기를 통해 해당 출력을 실행하여이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2e59e25078df47eeb568564146188c50381a8b44" translate="yes" xml:space="preserve">
          <source>SQLite promises to preserve the 15 most significant digits of a floating point value. However, it makes no guarantees about the accuracy of computations on floating point values, as no such guarantees are possible. Performing math on floating-point values introduces error. For example, consider what happens if you attempt to subtract two floating-point numbers of similar magnitude:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe52b85233b043a411af65af0db61d939caa292e" translate="yes" xml:space="preserve">
          <source>SQLite provides a number of enhancements to the SQL language not normally found in other database engines. The EXPLAIN keyword and manifest typing have already been mentioned above. SQLite also provides statements such as &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; and the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause that allow for added control over the resolution of constraint conflicts. SQLite supports &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands that allow multiple independent databases to be used together in the same query. And SQLite defines APIs that allows the user to add new &lt;a href=&quot;c3ref/create_function&quot;&gt;SQL functions&lt;/a&gt; and &lt;a href=&quot;c3ref/create_collation&quot;&gt;collating sequences&lt;/a&gt;.</source>
          <target state="translated">SQLite는 다른 데이터베이스 엔진에서 일반적으로 볼 수없는 SQL 언어에 대한 여러 가지 향상된 기능을 제공합니다. EXPLAIN 키워드 및 매니페스트 입력은 이미 위에서 언급했습니다. SQLite는 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 및 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절 과 같은 문을 제공 하여 제약 조건 충돌 해결을 추가로 제어 할 수 있습니다. SQLite는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; 명령을 지원하므로 여러 독립 데이터베이스를 동일한 쿼리에서 함께 사용할 수 있습니다. 그리고 SQLite는 사용자가 새로운 &lt;a href=&quot;c3ref/create_function&quot;&gt;SQL 함수&lt;/a&gt; 와 &lt;a href=&quot;c3ref/create_collation&quot;&gt;조합 순서&lt;/a&gt; 를 추가 할 수있는 API를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="75b33c10e4ae0dc9caa69a9b718ca24a25cbfeba" translate="yes" xml:space="preserve">
          <source>SQLite provides isolation between operations in separate database connections. However, there is no isolation between operations that occur within the same database connection.</source>
          <target state="translated">SQLite는 별도의 데이터베이스 연결에서 작업을 분리합니다. 그러나 동일한 데이터베이스 연결 내에서 발생하는 작업 간에는 격리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a19562eb5d14931c391924201db74f2b2170510" translate="yes" xml:space="preserve">
          <source>SQLite provides the ability for advanced programmers to exercise control over the query plan chosen by the optimizer. One method for doing this is to fudge the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; results in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;, &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;, and/or &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; tables. That approach is not recommended except for the one scenario described in the next paragraph.</source>
          <target state="translated">SQLite는 고급 프로그래머가 옵티마이 저가 선택한 쿼리 계획을 제어 할 수있는 기능을 제공합니다. 이를 수행하는 한 가지 방법 은 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; , &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; 및 / 또는 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 테이블 에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 결과를 제거하는 것 입니다. 이 방법은 다음 단락에서 설명하는 시나리오를 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="069bcc6cce5ca3be769be9d7d5d38ef69d29560b" translate="yes" xml:space="preserve">
          <source>SQLite provides these two interfaces for reporting on the status of the &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; routines, which form the built-in memory allocation subsystem.</source>
          <target state="translated">SQLite는 내장 메모리 할당 서브 시스템을 구성하는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 루틴 의 상태를보고하기 위해이 두 가지 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5be5efeb16b0a34b3e2605cf2967c7a9f9f4502b" translate="yes" xml:space="preserve">
          <source>SQLite provides these two interfaces for reporting on the status of the &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; routines, which form the built-in memory allocation subsystem.</source>
          <target state="translated">SQLite는 내장 메모리 할당 서브 시스템을 구성하는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 루틴 의 상태를보고하기 위해이 두 가지 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="796f29585c117f2d84f8816579b3c6eeec799286" translate="yes" xml:space="preserve">
          <source>SQLite queries an implementation for file-system characteristics using the xDeviceCharacteristics() and xSectorSize() methods of the database file file-handle. These two methods are only ever called on file-handles open on database files. They are not called for</source>
          <target state="translated">SQLite는 데이터베이스 파일 파일 핸들의 xDeviceCharacteristics () 및 xSectorSize () 메서드를 사용하여 파일 시스템 특성 구현을 쿼리합니다. 이 두 가지 방법은 데이터베이스 파일에서 열린 파일 핸들에서만 호출됩니다. 그들은 요구되지 않았다</target>
        </trans-unit>
        <trans-unit id="1001eecb9650b8452d3fe909aaa11b4544423e7e" translate="yes" xml:space="preserve">
          <source>SQLite reads and writes small blobs (for example, thumbnail images) &lt;a href=&quot;#approx&quot;&gt;35% faster&amp;sup1;&lt;/a&gt; than the same blobs can be read from or written to individual files on disk using fread() or fwrite().</source>
          <target state="translated">SQLite는 &lt;a href=&quot;#approx&quot;&gt;flob&lt;/a&gt; () 또는 fwrite ()를 사용하여 동일한 BLOB을 디스크의 개별 파일에서 읽거나 쓸 수있는 것보다 작은 Blob (예 : 축소판 이미지)을 35 % 더 빠르게 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="35d70ea0800f08a06761cd47e896b93495f4c9c9" translate="yes" xml:space="preserve">
          <source>SQLite responds gracefully to system errors. Obscure out-of-memory and I/O errors are reported back up to the application. These error reporting paths are all carefully tested to ensure they will always work.</source>
          <target state="translated">SQLite는 시스템 오류에 정상적으로 응답합니다. 메모리 부족 및 I / O 오류가 애플리케이션에 다시보고됩니다. 이러한 오류보고 경로는 항상 작동하는지 확인하기 위해 신중하게 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="23423829c41e2a290e377832f71a840c666910a0" translate="yes" xml:space="preserve">
          <source>SQLite seems to be a popular target for third-parties to fuzz. The developers hear about many attempts to fuzz SQLite and they do occasionally get bug reports found by independent fuzzers. All such reports are promptly fixed, so the product is improved and that the entire SQLite user community benefits. This mechanism of having many independent testers is similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/Linus%27s_law&quot;&gt;Linus's law&lt;/a&gt;: &quot;given enough eyeballs, all bugs are shallow&quot;.</source>
          <target state="translated">SQLite는 제 3자가 퍼징하는 인기있는 대상인 것 같습니다. 개발자는 SQLite를 퍼징하려는 많은 시도에 대해 듣고 때때로 독립적 인 퍼 저가 발견 한 버그 보고서를받습니다. 이러한 모든 보고서는 즉시 수정되므로 제품이 개선되고 전체 SQLite 사용자 커뮤니티에 도움이됩니다. 많은 독립적 인 테스터를 보유하는이 메커니즘은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linus%27s_law&quot;&gt;Linus의 법칙&lt;/a&gt; 과 유사합니다 . &quot;충분한 시선이 주어지면 모든 버그는 얕습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="7c0c283f7e4e05e8236569bff26a222a275bf7f9" translate="yes" xml:space="preserve">
          <source>SQLite shall attempt to obtain an</source>
          <target state="translated">SQLite는</target>
        </trans-unit>
        <trans-unit id="fc4b26fb3a3dbd3635c28a9c88ca506e8fda6086" translate="yes" xml:space="preserve">
          <source>SQLite shall ensure that a</source>
          <target state="translated">SQLite는</target>
        </trans-unit>
        <trans-unit id="68cdf5c9c482135a76a154ad68cc4116ae97dcc7" translate="yes" xml:space="preserve">
          <source>SQLite shall write the page data into the database file, using a single call to the xWrite method of the</source>
          <target state="translated">SQLite는 xWrite 메소드의 단일 호출을 사용하여 페이지 데이터를 데이터베이스 파일에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="740a9f7c5b70a08a25f10f9d2fba2d5ac406ba97" translate="yes" xml:space="preserve">
          <source>SQLite should never crash, overflow a buffer, leak memory, or exhibit any other harmful behavior, even when presented with maliciously malformed SQL inputs or database files. SQLite should always detect erroneous inputs and raise an error, not crash or corrupt memory. Any malfunction caused by an SQL input or database file is considered a serious bug and will be promptly addressed when brought to the attention of the SQLite developers. SQLite is extensively fuzz-tested to help ensure that it is resistant to these kinds of errors.</source>
          <target state="translated">악의적으로 잘못된 SQL 입력 또는 데이터베이스 파일이 표시되는 경우에도 SQLite는 충돌, 버퍼 오버플로, 메모리 누수 또는 기타 유해한 행동을 나타내지 않아야합니다. SQLite는 항상 잘못된 입력을 감지하고 충돌이나 메모리 손상이 아닌 오류를 발생시켜야합니다. SQL 입력 또는 데이터베이스 파일로 인한 오작동은 심각한 버그로 간주되며 SQLite 개발자의주의를 끌면 즉시 해결됩니다. SQLite는 이러한 종류의 오류에 대한 내성을 보장하기 위해 광범위한 퍼지 테스트를 거쳤습니다.</target>
        </trans-unit>
        <trans-unit id="8394c39a29a6c802cb3baaa5a9c23f7e97f8a73c" translate="yes" xml:space="preserve">
          <source>SQLite solves this problem by using a</source>
          <target state="translated">SQLite는 다음을 사용하여이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="a17840ca9490a98d4558d4de1067d407ae4f9392" translate="yes" xml:space="preserve">
          <source>SQLite source code is managed using the &lt;a href=&quot;https://fossil-scm.org&quot;&gt;Fossil&lt;/a&gt; version control system. Fossil was written specifically to support SQLite development. Fossil provides both distributed version control and issue tracking.</source>
          <target state="translated">SQLite 소스 코드는 &lt;a href=&quot;https://fossil-scm.org&quot;&gt;Fossil&lt;/a&gt; 버전 제어 시스템을 사용하여 관리 됩니다. 화석은 SQLite 개발을 지원하기 위해 특별히 작성되었습니다. Fossil은 분산 버전 제어 및 문제 추적을 모두 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa87de437d401b498b7d8eb223dcf3f87cf0893d" translate="yes" xml:space="preserve">
          <source>SQLite sources are maintained on three geographically dispersed servers:</source>
          <target state="translated">SQLite 소스는 지리적으로 분산 된 세 개의 서버에서 유지 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="e02e50c5282bb5b0a3a678ffe1050ddfbc21a817" translate="yes" xml:space="preserve">
          <source>SQLite stores an entire database within a single file, the format of which is described in the</source>
          <target state="translated">SQLite는 전체 데이터베이스를 단일 파일 내에 저장하며 그 형식은</target>
        </trans-unit>
        <trans-unit id="e0f7d561a2c1be86ba2359c7d925b95b359fecaf" translate="yes" xml:space="preserve">
          <source>SQLite stores integer values in the 64-bit &lt;a href=&quot;https://en.wikipedia.org/wiki/Two%27s_complement&quot;&gt;twos-complement&lt;/a&gt; format. This gives a storage range of -9223372036854775808 to +9223372036854775807, inclusive. Integers within this range are exact.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0b29ed9ca13970622475438234a3b6eb2529a8" translate="yes" xml:space="preserve">
          <source>SQLite strives to implement ORDER BY clauses using a preexisting index. If an appropriate index already exists, SQLite will walk the index, rather than the underlying table, to extract the requested information, and thus cause the rows to come out in the desired order. But if SQLite cannot find an appropriate index it will evaluate the query and store each row in a transient index whose data is the row data and whose key is the ORDER BY terms. After the query is evaluated, SQLite goes back and walks the transient index from beginning to end in order to output the rows in the desired order.</source>
          <target state="translated">SQLite는 기존 색인을 사용하여 ORDER BY 절을 구현하려고합니다. 적절한 인덱스가 이미 존재하면 SQLite는 기본 테이블이 아닌 인덱스를 따라 이동하여 요청 된 정보를 추출하므로 원하는 순서대로 행이 나오게됩니다. 그러나 SQLite가 적절한 인덱스를 찾지 못하면 쿼리를 평가하고 각 행을 데이터가 행 데이터이고 키가 ORDER BY 용어 인 임시 인덱스에 저장합니다. 쿼리가 평가 된 후 SQLite는 원하는 순서로 행을 출력하기 위해 임시 인덱스를 처음부터 끝까지 거꾸로 걸어갑니다.</target>
        </trans-unit>
        <trans-unit id="79801eb3ee90b8531950935fcb700e5d7936b51b" translate="yes" xml:space="preserve">
          <source>SQLite strives to keep error logger traffic low and only send messages to the error logger when there really is something wrong. Applications might further cull the error message traffic by deliberately ignore certain classes of error messages that they do not care about. For example, an application that makes frequent database schema changes might want to ignore all SQLITE_SCHEMA errors.</source>
          <target state="translated">SQLite는 오류 로거 트래픽을 낮게 유지하고 실제로 오류가있을 때만 오류 로거에게 메시지를 보내려고합니다. 응용 프로그램은 의도하지 않은 특정 종류의 오류 메시지를 고의로 무시하여 오류 메시지 트래픽을 추가로 차단할 수 있습니다. 예를 들어, 데이터베이스 스키마를 자주 변경하는 응용 프로그램은 모든 SQLITE_SCHEMA 오류를 무시하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b7bc709cc1bfb344641faff586e57a6d874b11" translate="yes" xml:space="preserve">
          <source>SQLite strives to verify that every branch instruction makes a difference using &lt;a href=&quot;https://en.wikipedia.org/wiki/Mutation_testing&quot;&gt;mutation testing&lt;/a&gt;. &lt;a href=&quot;th3#muttest&quot;&gt;A script&lt;/a&gt; first compiles the SQLite source code into assembly language (using, for example, the -S option to gcc). Then the script steps through the generated assembly language and, one by one, changes each branch instruction into either an unconditional jump or a no-op, compiles the result, and verifies that the test suite catches the mutation.</source>
          <target state="translated">SQLite는 모든 분기 명령어가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mutation_testing&quot;&gt;돌연변이 테스트를&lt;/a&gt; 사용하여 차이를 만드는지 확인하려고 노력합니다 . &lt;a href=&quot;th3#muttest&quot;&gt;스크립트는&lt;/a&gt; 먼저 SQLite 소스 코드를 어셈블리 언어로 컴파일합니다 (예 : gcc에 -S 옵션 사용). 그런 다음 스크립트는 생성 된 어셈블리 언어를 단계별로 살펴보고 각 분기 명령어를 무조건 점프 또는 무 작동으로 변경하고 결과를 컴파일하고 테스트 스위트가 돌연변이를 포착하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="61116c736ec15bc5b4fb2fc6a87d1890ff944be5" translate="yes" xml:space="preserve">
          <source>SQLite supports a limited subset of ALTER TABLE. The ALTER TABLE command in SQLite allows the user to rename a table, to rename a column within a table, or to add a new column to an existing table.</source>
          <target state="translated">SQLite는 ALTER TABLE의 제한된 하위 집합을 지원합니다. SQLite의 ALTER TABLE 명령을 사용하면 테이블 이름을 바꾸거나 테이블 내의 열 이름을 바꾸거나 기존 테이블에 새 열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa3301d9a603d43c374c933699b5b685c255796" translate="yes" xml:space="preserve">
          <source>SQLite supports an unlimited number of simultaneous readers, but it will only allow one writer at any instant in time. For many situations, this is not a problem. Writers queue up. Each application does its database work quickly and moves on, and no lock lasts for more than a few dozen milliseconds. But there are some applications that require more concurrency, and those applications may need to seek a different solution.</source>
          <target state="translated">SQLite는 무제한의 동시 판독기를 지원하지만 한 번에 한 명의 작성자 만 허용합니다. 많은 상황에서 이것은 문제가되지 않습니다. 작가가 대기합니다. 각 응용 프로그램은 데이터베이스가 빠르게 작동하고 계속 진행하며 수십 밀리 초 이상 동안 잠금이 지속되지 않습니다. 그러나 더 많은 동시성이 필요한 일부 응용 프로그램이 있으며 해당 응용 프로그램은 다른 솔루션을 찾아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="362a3fd555302c4f1eaf77cb8e7f778518efb28e" translate="yes" xml:space="preserve">
          <source>SQLite supports five date and time functions as follows:</source>
          <target state="translated">SQLite는 다음과 같이 5 개의 날짜 및 시간 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="91957f75e3d4e0fd1006ddb7500b87cbbf67b068" translate="yes" xml:space="preserve">
          <source>SQLite supports many &lt;a href=&quot;lang_corefunc&quot;&gt;simple&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt;, and &lt;a href=&quot;windowfunctions&quot;&gt;window&lt;/a&gt; SQL functions. For presentation purposes, simple functions are further subdivided into &lt;a href=&quot;lang_corefunc&quot;&gt;core functions&lt;/a&gt;, &lt;a href=&quot;lang_datefunc&quot;&gt;date-time functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt;. Applications can add new functions, written in C/C++, using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface.</source>
          <target state="translated">SQLite는 많은 &lt;a href=&quot;lang_corefunc&quot;&gt;단순&lt;/a&gt; , &lt;a href=&quot;lang_aggfunc&quot;&gt;집계&lt;/a&gt; 및 &lt;a href=&quot;windowfunctions&quot;&gt;창&lt;/a&gt; SQL 함수를 지원합니다. 프리젠 테이션 목적으로 간단한 함수는 &lt;a href=&quot;lang_corefunc&quot;&gt;핵심 함수&lt;/a&gt; , &lt;a href=&quot;lang_datefunc&quot;&gt;날짜-시간 함수&lt;/a&gt; 및 &lt;a href=&quot;json1&quot;&gt;JSON 함수&lt;/a&gt; 로 세분됩니다 . 응용 프로그램은 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스를 사용하여 C / C ++로 작성된 새 함수를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8df117e71ae2eb15e7237b9f17e42a408d843570" translate="yes" xml:space="preserve">
          <source>SQLite supports multiple simultaneous read transactions coming from separate database connections, possibly in separate threads or processes, but only one simultaneous write transaction.</source>
          <target state="translated">SQLite는 별도의 스레드 또는 프로세스에서 별도의 데이터베이스 연결에서 오는 여러 동시 읽기 트랜잭션을 지원하지만 동시 쓰기 트랜잭션은 하나만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bb2625e03f106cbbdee7f3db77e634d01593acaa" translate="yes" xml:space="preserve">
          <source>SQLite supports the ability of an application to specify an alternative memory allocator at run-time by filling in an instance of the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object with pointers to the routines of the alternative implementation then registering the new alternative implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. For example:</source>
          <target state="translated">SQLite는 대체 구현의 루틴에 대한 포인터로 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 오브젝트 의 인스턴스를 채우고 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 새 대체 구현을 등록 함으로써 런타임시 대체 메모리 할당자를 지정할 수있는 애플리케이션 기능을 지원합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="017fb6b291ff89e609d155a096555bd5bbe2c94f" translate="yes" xml:space="preserve">
          <source>SQLite supports the following 11 built-in window functions:</source>
          <target state="translated">SQLite는 다음 11 가지 내장 창 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a02f0bb2b069910c39ea479587454cc5f38daf81" translate="yes" xml:space="preserve">
          <source>SQLite supports three different threading modes:</source>
          <target state="translated">SQLite는 세 가지 스레딩 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4014b7a930ff3b73114947a465a719ff6e29de6d" translate="yes" xml:space="preserve">
          <source>SQLite tries to detect misuse and report the misuse using this result code. However, there is no guarantee that the detection of misuse will be successful. Misuse detection is probabilistic. Applications should never depend on an SQLITE_MISUSE return value.</source>
          <target state="translated">SQLite는이 결과 코드를 사용하여 오용을 감지하고 오용을보고하려고합니다. 그러나 오용 탐지에 성공할 것이라는 보장은 없습니다. 오용 탐지는 확률 적입니다. 응용 프로그램은 SQLITE_MISUSE 리턴 값에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="84db0173921e2cbe9f6c615710bf66e073f79708" translate="yes" xml:space="preserve">
          <source>SQLite understands a real table to be a shadow table if all of the following are true:</source>
          <target state="translated">SQLite는 다음을 모두 충족하면 실제 테이블을 새도우 테이블로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="89cbe958d74b15f24f6e6b8bc29bafc1643a7f0d" translate="yes" xml:space="preserve">
          <source>SQLite understands most of the standard SQL language. But it does &lt;a href=&quot;omitted&quot;&gt;omit some features&lt;/a&gt; while at the same time adding a few features of its own. This document attempts to describe precisely what parts of the SQL language SQLite does and does not support. A list of &lt;a href=&quot;lang_keywords&quot;&gt;SQL keywords&lt;/a&gt; is also provided. The SQL language syntax is described by &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt;.</source>
          <target state="translated">SQLite는 대부분의 표준 SQL 언어를 이해합니다. 그러나 &lt;a href=&quot;omitted&quot;&gt;일부 기능&lt;/a&gt; 은 생략 하고 동시에 자체 기능을 추가합니다. 이 문서는 SQL 언어 SQLite의 어떤 부분이 지원하고 지원하지 않는지를 정확하게 설명하려고합니다. &lt;a href=&quot;lang_keywords&quot;&gt;SQL 키워드&lt;/a&gt; 목록 도 제공됩니다. SQL 언어 구문은 &lt;a href=&quot;syntaxdiagrams&quot;&gt;구문 다이어그램으로&lt;/a&gt; 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="76a4b937d814efc3107985206c3839b75a40d5c0" translate="yes" xml:space="preserve">
          <source>SQLite understands the following binary operators, in order from highest to lowest precedence:</source>
          <target state="translated">SQLite는 다음과 같은 이진 연산자를 우선 순위가 높은 순서대로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="de40d61f7018c5b48e3c644cbaef8bf7d8b66fd1" translate="yes" xml:space="preserve">
          <source>SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. Content can be stored as INTEGER, REAL, TEXT, BLOB, or as NULL.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;datatype3&quot;&gt;동적 타이핑을&lt;/a&gt; 사용합니다 . 컨텐츠는 INTEGER, REAL, TEXT, BLOB 또는 NULL로 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9e9446caa946736bd5a01f0671ef69ec6cbe7e" translate="yes" xml:space="preserve">
          <source>SQLite uses &lt;code&gt;testcase()&lt;/code&gt; macros as described in the previous subsection to make sure that every condition in a bit-vector decision takes on every possible outcome. In this way, SQLite also achieves 100% MC/DC in addition to 100% branch coverage.</source>
          <target state="translated">SQLite는 이전 하위 섹션에서 설명한대로 &lt;code&gt;testcase()&lt;/code&gt; 매크로를 사용 하여 비트 벡터 결정의 모든 조건이 가능한 모든 결과를 가져 오도록합니다. 이러한 방식으로 SQLite는 100 % 지점 범위 외에 100 % MC / DC도 달성합니다.</target>
        </trans-unit>
        <trans-unit id="d2c828337726f1245db87b3b8499d82386b0261e" translate="yes" xml:space="preserve">
          <source>SQLite uses POSIX advisory locks to implement locking on Unix. On Windows it uses the LockFile(), LockFileEx(), and UnlockFile() system calls. SQLite assumes that these system calls all work as advertised. If that is not the case, then database corruption can result. One should note that POSIX advisory locking is known to be buggy or even unimplemented on many NFS implementations (including recent versions of Mac OS X) and that there are reports of locking problems for network filesystems under Windows. Your best defense is to not use SQLite for files on a network filesystem.</source>
          <target state="translated">SQLite는 POSIX 권고 잠금을 사용하여 Unix에서 잠금을 구현합니다. Windows에서는 LockFile (), LockFileEx () 및 UnlockFile () 시스템 호출을 사용합니다. SQLite는 이러한 시스템 호출이 모두 알려진대로 작동한다고 가정합니다. 그렇지 않은 경우 데이터베이스가 손상 될 수 있습니다. POSIX 권고 잠금은 많은 NFS 구현 (최신 Mac OS X 버전 포함)에서 버그가 있거나 구현되지 않은 것으로 알려져 있으며 Windows의 네트워크 파일 시스템에 대한 잠금 문제에 대한보고가 있습니다. 최선의 방어는 네트워크 파일 시스템의 파일에 SQLite를 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="419f5d6983bf4618f2a5dc1a95258ff9924a25c1" translate="yes" xml:space="preserve">
          <source>SQLite uses a continuous integration process. The software is under constant enhancement and refinement. The latest trunk check-ins are frequently used internally for mission-critical operations.</source>
          <target state="translated">SQLite는 지속적인 통합 프로세스를 사용합니다. 소프트웨어는 지속적으로 향상되고 개선되고 있습니다. 최신 트렁크 체크인은 업무상 중요한 작업을 위해 내부적으로 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0520919cdd7c57c0662d504d1dbd0da4f6ed1c" translate="yes" xml:space="preserve">
          <source>SQLite uses a cost-based query planner. When there are two or more ways of solving the same query, SQLite tries to estimate the total amount of time needed to run the query using each plan, and then uses the plan with the lowest estimated cost. A cost is computed mostly from the estimated time, and so this case could go either way depending on the table size and what WHERE clause constraints were available, and so forth. But generally speaking, the indexed sort would probably be chosen, if for no other reason, because it does not need to accumulate the entire result set in temporary storage before sorting and thus uses much less temporary storage.</source>
          <target state="translated">SQLite는 비용 기반 쿼리 플래너를 사용합니다. 동일한 쿼리를 해결하는 두 가지 이상의 방법이있는 경우 SQLite는 각 계획을 사용하여 쿼리를 실행하는 데 필요한 총 시간을 추정 한 다음 예상 비용이 가장 낮은 계획을 사용합니다. 비용은 대부분 예상 시간을 기준으로 계산되므로이 경우 테이블 크기 및 사용 가능한 WHERE 절 제약 조건 등에 따라 달라집니다. 그러나 일반적으로 인덱스 정렬은 다른 이유가 없다면 정렬하기 전에 전체 결과 집합을 임시 저장소에 축적 할 필요가 없으므로 훨씬 적은 임시 저장소를 사용하므로 인덱스 정렬이 선택 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9d581a988a96a28e53beca39811ace9da326e2" translate="yes" xml:space="preserve">
          <source>SQLite uses a more general dynamic type system. In SQLite, the datatype of a value is associated with the value itself, not with its container. The dynamic type system of SQLite is backwards compatible with the more common static type systems of other database engines in the sense that SQL statements that work on statically typed databases should work the same way in SQLite. However, the dynamic typing in SQLite allows it to do things which are not possible in traditional rigidly typed databases.</source>
          <target state="translated">SQLite는보다 일반적인 동적 유형 시스템을 사용합니다. SQLite에서 값의 데이터 유형은 컨테이너가 아니라 값 자체와 연관됩니다. SQLite의 동적 형식 시스템은 정적 형식의 데이터베이스에서 작동하는 SQL 문이 SQLite에서 동일한 방식으로 작동해야한다는 점에서 다른 데이터베이스 엔진의 일반적인 정적 형식 시스템과 호환됩니다. 그러나 SQLite의 동적 타이핑을 사용하면 기존의 엄격한 유형이 지정된 데이터베이스에서는 불가능한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1b55e0fd7f9c8ac0ebdd30cf39af20d7f2d3b7" translate="yes" xml:space="preserve">
          <source>SQLite uses a page cache of recently read and written database pages. This page cache is used not just for the main database file but also for transient indices and tables stored in temporary files. If SQLite needs to use a temporary index or table and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; are set to store temporary tables and index on disk, the information is still initially stored in memory in the page cache. The temporary file is not opened and the information is not truly written to disk until the page cache is full.</source>
          <target state="translated">SQLite는 최근 읽고 쓴 데이터베이스 페이지의 페이지 캐시를 사용합니다. 이 페이지 캐시는 기본 데이터베이스 파일뿐만 아니라 임시 파일에 저장된 임시 색인 및 테이블에도 사용됩니다. SQLite가 임시 인덱스 나 테이블을 사용해야하고 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수와 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 가 디스크에 임시 테이블과 인덱스를 저장하도록 설정된 경우 정보는 여전히 초기에 페이지 캐시의 메모리에 저장됩니다. 임시 파일이 열리지 않고 페이지 캐시가 가득 찰 때까지 정보가 실제로 디스크에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b12c1b1b8cc61e32991a698cfd1267c2d0f89edd" translate="yes" xml:space="preserve">
          <source>SQLite uses an efficient &lt;a href=&quot;queryplanner-ng&quot;&gt;query planner algorithm&lt;/a&gt; and so even a large join can be &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared&lt;/a&gt; quickly. Hence, there is no mechanism to raise or lower the limit on the number of tables in a join.</source>
          <target state="translated">SQLite는 효율적인 &lt;a href=&quot;queryplanner-ng&quot;&gt;쿼리 플래너 알고리즘&lt;/a&gt; 을 사용하므로 대규모 조인도 빠르게 &lt;a href=&quot;c3ref/prepare&quot;&gt;준비&lt;/a&gt; 할 수 있습니다 . 따라서 조인의 테이블 수에 대한 제한을 늘리거나 줄일 수있는 메커니즘이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c5e93f52d20c084674804c93cc58302ab86f180" translate="yes" xml:space="preserve">
          <source>SQLite uses binary arithmetic and in binary, there is no way to write 9.95 in a finite number of bits. The closest to you can get to 9.95 in a 64-bit IEEE float (which is what SQLite uses) is 9.949999999999999289457264239899814128875732421875. So when you type &quot;9.95&quot;, SQLite really understands the number to be the much longer value shown above. And that value rounds down.</source>
          <target state="translated">SQLite는 이진 산술을 사용하며 이진에서는 유한 비트 수로 9.95를 쓸 수있는 방법이 없습니다. 64 비트 IEEE float (SQLite가 사용하는 것)에서 9.95에 가장 가까운 것은 9.949999999999999289457264239899814128875732421875입니다. 따라서 &quot;9.95&quot;를 입력하면 SQLite는 숫자가 위에 표시된 값보다 훨씬 길다는 것을 실제로 이해합니다. 그리고 그 가치는 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="100c32205d77668106f751ddb49a630f21e7c164" translate="yes" xml:space="preserve">
          <source>SQLite uses dynamic memory allocation to obtain memory for storing various objects (ex: &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;) and to build a memory cache of the database file and to hold the results of queries. Much effort has gone into making the dynamic memory allocation subsystem of SQLite reliable, predictable, robust, secure, and efficient.</source>
          <target state="translated">SQLite는 동적 메모리 할당을 사용하여 다양한 객체 (예 : &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; ) 를 저장하기위한 메모리를 확보 하고 데이터베이스 파일의 메모리 캐시를 빌드하고 쿼리 결과를 보유합니다. SQLite의 동적 메모리 할당 하위 시스템을 안정적이고 예측 가능하며 강력하고 안전하며 효율적으로 만드는 데 많은 노력을 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="00d6ed4ddbc792f962a9c15a9bfff1ed56a12c03" translate="yes" xml:space="preserve">
          <source>SQLite uses dynamic run-time typing. So just because a column is declared to contain a particular type does not mean that the data stored in that column is of the declared type. SQLite is strongly typed, but the typing is dynamic not static. Type is associated with individual values, not with the containers used to hold those values.</source>
          <target state="translated">SQLite는 동적 런타임 타이핑을 사용합니다. 따라서 열이 특정 유형을 포함하도록 선언되었다고해서 해당 열에 저장된 데이터가 선언 된 유형임을 의미하지는 않습니다. SQLite는 강력하게 입력되지만 입력은 정적이 아닌 동적입니다. 유형은 해당 값을 보유하는 데 사용되는 컨테이너가 아니라 개별 값과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c675b439e8b045a5761d6f6f634a6e3c87b0d8" translate="yes" xml:space="preserve">
          <source>SQLite uses file locks on the database file, and on the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; file, to coordinate access between concurrent processes. Without coordination, two threads or processes might try to make incompatible changes to a database file at the same time, resulting in database corruption.</source>
          <target state="translated">SQLite는 데이터베이스 파일과 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 또는 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 파일에서 파일 잠금을 사용하여 동시 프로세스 간 액세스를 조정합니다. 조정없이 두 개의 스레드 또는 프로세스가 동시에 데이터베이스 파일에 대해 호환되지 않는 변경을 시도하여 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc489b7d0364b55c420255bebe8164eaf3143ec" translate="yes" xml:space="preserve">
          <source>SQLite uses filesystem locks to make sure that only one process and database connection is trying to modify the database at a time. The filesystem locking mechanism is implemented in the VFS layer and is different for every operating system. SQLite depends on this implementation being correct. If something goes wrong and two or more processes are able to write the same database file at the same time, severe damage can result.</source>
          <target state="translated">SQLite는 파일 시스템 잠금을 사용하여 한 번에 하나의 프로세스 및 데이터베이스 연결만으로 데이터베이스를 수정하려고합니다. 파일 시스템 잠금 메커니즘은 VFS 계층에서 구현되며 운영 체제마다 다릅니다. SQLite는이 구현이 올바른지에 달려 있습니다. 문제가 발생하여 두 개 이상의 프로세스가 동일한 데이터베이스 파일을 동시에 쓸 수있는 경우 심각한 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5d3144ca7b57a8fe6bfa7c95d8cd76ffe8cc05" translate="yes" xml:space="preserve">
          <source>SQLite uses one of these integer values as the second argument to calls it makes to the xLock() and xUnlock() methods of an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite는 이러한 정수 값 중 하나를 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xLock () 및 xUnlock () 메서드를 호출하는 두 번째 인수로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="06c37dcfbf68e2c7d0288d36eee6b01629eff86a" translate="yes" xml:space="preserve">
          <source>SQLite uses one of these integer values as the second argument to calls it makes to the xLock() and xUnlock() methods of an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite는 이러한 정수 값 중 하나를 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xLock () 및 xUnlock () 메서드를 호출하는 두 번째 인수로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="f6149cc0b8adc5f4defc7a195f4b03b55ce3c135" translate="yes" xml:space="preserve">
          <source>SQLite uses pthreads for its mutex implementation on Unix and SQLite requires a recursive mutex. Most modern pthread implementations support recursive mutexes, but not all do. For systems that do not support recursive mutexes, it is recommended that applications operate in single-threaded mode only. If this is not possible, SQLite provides an alternative recursive mutex implementation built on top of the standard &quot;fast&quot; mutexes of pthreads. This alternative implementation should work correctly as long as pthread_equal() is atomic and the processor has a coherent data cache. The alternative recursive mutex implementation is enabled by the following compiler command-line switch:</source>
          <target state="translated">SQLite는 Unix에서 뮤텍스 구현을 위해 pthread를 사용하며 SQLite는 재귀 뮤텍스가 필요합니다. 대부분의 최신 pthread 구현은 재귀 뮤텍스를 지원하지만 전부는 아닙니다. 재귀 뮤텍스를 지원하지 않는 시스템의 경우 응용 프로그램은 단일 스레드 모드에서만 작동하는 것이 좋습니다. 이것이 가능하지 않은 경우 SQLite는 표준 &quot;빠른&quot;pthread 뮤텍스 위에 구축 된 대체 재귀 뮤텍스 구현을 제공합니다. pthread_equal ()이 원자적이고 프로세서에 일관된 데이터 캐시가있는 한이 대체 구현은 올바르게 작동해야합니다. 대체 재귀 뮤텍스 구현은 다음 컴파일러 명령 줄 스위치를 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e2e6b108a44c0d3f75ca74e3d41c51203f95b5" translate="yes" xml:space="preserve">
          <source>SQLite uses reader/writer locks to control access to the database. (Under Win95/98/ME which lacks support for reader/writer locks, a probabilistic simulation is used instead.) But use caution: this locking mechanism might not work correctly if the database file is kept on an NFS filesystem. This is because fcntl() file locking is broken on many NFS implementations. You should avoid putting SQLite database files on NFS if multiple processes might try to access the file at the same time. On Windows, Microsoft's documentation says that locking may not work under FAT filesystems if you are not running the Share.exe daemon. People who have a lot of experience with Windows tell me that file locking of network files is very buggy and is not dependable. If what they say is true, sharing an SQLite database between two or more Windows machines might cause unexpected problems.</source>
          <target state="translated">SQLite는 리더 / 라이터 잠금을 사용하여 데이터베이스에 대한 액세스를 제어합니다. (리더 / 라이터 잠금을 지원하지 않는 Win95 / 98 / ME에서는 대신에 확률 시뮬레이션이 사용됩니다.) 그러나주의하십시오 : 데이터베이스 파일이 NFS 파일 시스템에 보관되어 있으면이 잠금 메커니즘이 제대로 작동하지 않을 수 있습니다. 많은 NFS 구현에서 fcntl () 파일 잠금이 손상 되었기 때문입니다. 여러 프로세스가 동시에 파일에 액세스하려고하면 SQLite 데이터베이스 파일을 NFS에 두지 마십시오. Windows에서 Microsoft의 설명서에 따르면 Share.exe 데몬을 실행하지 않으면 FAT 파일 시스템에서 잠금이 작동하지 않을 수 있습니다. Windows에 대한 경험이 많은 사람들은 네트워크 파일의 파일 잠금이 매우 번거롭고 신뢰할 수 없다고 말합니다. 그들이 말하는 것이 사실이라면둘 이상의 Windows 시스템간에 SQLite 데이터베이스를 공유하면 예기치 않은 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88bb033eaf6e37670d2db7d84f333ca9cade029c" translate="yes" xml:space="preserve">
          <source>SQLite uses the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; URI syntax to identify database files. SQLite strives to interpret file: URIs in exactly the same way as popular web-browsers such as &lt;a href=&quot;http://www.mozilla.com/en-US/firefox/new/&quot;&gt;Firefox&lt;/a&gt;, &lt;a href=&quot;http://www.google.com/chrome/&quot;&gt;Chrome&lt;/a&gt;, &lt;a href=&quot;http://www.apple.com/safari/&quot;&gt;Safari&lt;/a&gt;, &lt;a href=&quot;http://windows.microsoft.com/en-US/internet-explorer/products/ie/home&quot;&gt;Internet Explorer&lt;/a&gt;, and &lt;a href=&quot;http://www.opera.com/&quot;&gt;Opera&lt;/a&gt;, and command-line programs such as &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/start.mspx&quot;&gt;Windows &quot;start&quot;&lt;/a&gt; and the Mac OS-X &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/open.1.html&quot;&gt;&quot;open&quot;&lt;/a&gt; command. A succinct summary of the URI parsing rules follows:</source>
          <target state="translated">SQLite는 &quot; &lt;code&gt;file:&lt;/code&gt; &quot;URI 구문을 사용하여 데이터베이스 파일을 식별합니다. SQLite는 &lt;a href=&quot;http://www.mozilla.com/en-US/firefox/new/&quot;&gt;Firefox&lt;/a&gt; , &lt;a href=&quot;http://www.google.com/chrome/&quot;&gt;Chrome&lt;/a&gt; , &lt;a href=&quot;http://www.apple.com/safari/&quot;&gt;Safari&lt;/a&gt; , &lt;a href=&quot;http://windows.microsoft.com/en-US/internet-explorer/products/ie/home&quot;&gt;Internet Explorer&lt;/a&gt; 및 &lt;a href=&quot;http://www.opera.com/&quot;&gt;Opera&lt;/a&gt; 와 같이 널리 사용되는 웹 브라우저와 &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/start.mspx&quot;&gt;Windows&lt;/a&gt; 와 같은 명령 줄 프로그램 및 Mac OS-X &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/open.1.html&quot;&gt;&quot;open&lt;/a&gt; 과 같은 방식으로 파일 : URI를 해석하려고 노력합니다. &quot; 명령. URI 구문 분석 규칙의 간결한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69d5ac42573f581392e9517041d99daa76b38636" translate="yes" xml:space="preserve">
          <source>SQLite uses the assumptions in this section to try to speed up reading from and writing to the database file.</source>
          <target state="translated">SQLite는이 섹션의 가정을 사용하여 데이터베이스 파일을 읽고 쓰는 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="d55089274731f4bfb9ebd084387b8f1d1faf31f7" translate="yes" xml:space="preserve">
          <source>SQLite uses the following terminology:</source>
          <target state="translated">SQLite는 다음 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0ee4041bd18f2412c9c45cca33a698969a142e88" translate="yes" xml:space="preserve">
          <source>SQLite uses the fsync() system call on Unix and the FlushFileBuffers() system call on w32 in order to sync the file system buffers onto disk oxide as shown in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt;. Unfortunately, we have received reports that neither of these interfaces works as advertised on many systems. We hear that FlushFileBuffers() can be completely disabled using registry settings on some Windows versions. Some historical versions of Linux contain versions of fsync() which are no-ops on some filesystems, we are told. Even on systems where FlushFileBuffers() and fsync() are said to be working, often the IDE disk control lies and says that data has reached oxide while it is still held only in the volatile control cache.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;#section_3_7&quot;&gt;3.7 &lt;/a&gt;&lt;a href=&quot;#section_3_10&quot;&gt;단계&lt;/a&gt; 및 3.10 단계에 표시된 것처럼 파일 시스템 버퍼를 디스크 옥사이드에 동기화하기 위해 Unix에서 fsync () 시스템 호출 및 w32에서 FlushFileBuffers () 시스템 호출을 사용합니다 . 불행히도 우리는 이러한 인터페이스 중 어느 것도 많은 시스템에서 알려진대로 작동하지 않는다는보고를 받았습니다. 일부 Windows 버전에서는 레지스트리 설정을 사용하여 FlushFileBuffers ()를 완전히 비활성화 할 수 있다고 들었습니다. Linux의 일부 히스토리 버전에는 일부 파일 시스템에서 작동하지 않는 fsync () 버전이 포함되어 있습니다. FlushFileBuffers () 및 fsync ()가 작동하는 시스템에서도 IDE 디스크 제어 기능이 있으며 데이터가 여전히 휘발성 제어 캐시에만 유지되는 동안 데이터가 산화물에 도달했다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="6362e589dd1fe9de49e118297201339e71a38ea0" translate="yes" xml:space="preserve">
          <source>SQLite uses the fsync() system call to flush data to the disk under Unix and it uses the FlushFileBuffers() to do the same under Windows. Once again, SQLite assumes that these operating system services function as advertised. But it has been reported that fsync() and FlushFileBuffers() do not always work correctly, especially with inexpensive IDE disks. Apparently some manufactures of IDE disks have controller chips that report that data has reached the disk surface when in fact the data is still in volatile cache memory in the disk drive electronics. There are also reports that Windows sometimes chooses to ignore FlushFileBuffers() for unspecified reasons. The author cannot verify any of these reports. But if they are true, it means that database corruption is a possibility following an unexpected power loss. These are hardware and/or operating system bugs that SQLite is unable to defend against.</source>
          <target state="translated">SQLite는 fsync () 시스템 호출을 사용하여 Unix에서 디스크로 데이터를 플러시하고 FlushFileBuffers ()를 사용하여 Windows에서 동일하게 수행합니다. 다시 한 번 SQLite는 이러한 운영 체제 서비스가 알려진대로 작동한다고 가정합니다. 그러나 fsync () 및 FlushFileBuffers ()가 특히 저렴한 IDE 디스크에서 항상 올바르게 작동하지는 않는다고보고되었습니다. 분명히 일부 IDE 디스크 제조업체는 실제로 데이터가 디스크 드라이브 전자 장치의 휘발성 캐시 메모리에있을 때 데이터가 디스크 표면에 도달했음을보고하는 컨트롤러 칩을 가지고 있습니다. 또한 Windows가 때때로 지정되지 않은 이유로 FlushFileBuffers ()를 무시하기로 선택한 보고서도 있습니다. 작성자는 이러한 보고서를 확인할 수 없습니다. 그러나 이것이 사실이라면 예기치 않은 정전으로 인해 데이터베이스가 손상 될 수 있음을 의미합니다.이는 SQLite가 방어 할 수없는 하드웨어 및 / 또는 운영 체제 버그입니다.</target>
        </trans-unit>
        <trans-unit id="32280f4c0ca13b9e9b050e36d2463beacf57a438" translate="yes" xml:space="preserve">
          <source>SQLite uses the path component of the URI as the name of the disk file which contains the database. If the path begins with a '/' character, then it is interpreted as an absolute path. If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path. On windows, the first component of an absolute path is a drive specification (e.g. &quot;C:&quot;).</source>
          <target state="translated">SQLite는 데이터베이스를 포함하는 디스크 파일의 이름으로 URI의 경로 구성 요소를 사용합니다. 경로가 '/'문자로 시작하면 절대 경로로 해석됩니다. 경로가 '/'로 시작하지 않으면 (권한 섹션이 URI에서 생략됨을 의미) 경로는 상대 경로로 해석됩니다. Windows에서 절대 경로의 첫 번째 구성 요소는 드라이브 사양입니다 (예 : &quot;C :&quot;).</target>
        </trans-unit>
        <trans-unit id="b4d974786d3ead21fc22643249354066187d79d8" translate="yes" xml:space="preserve">
          <source>SQLite uses the sqlite3_value object to represent all values that can be stored in a database table. SQLite uses dynamic typing for the values it stores. Values stored in sqlite3_value objects can be integers, floating point values, strings, BLOBs, or NULL.</source>
          <target state="translated">SQLite는 sqlite3_value 객체를 사용하여 데이터베이스 테이블에 저장할 수있는 모든 값을 나타냅니다. SQLite는 저장된 값에 동적 타이핑을 사용합니다. sqlite3_value 객체에 저장된 값은 정수, 부동 소수점 값, 문자열, BLOB 또는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3216e45fcb6dfe91aace5bfc00370029ab1bdf71" translate="yes" xml:space="preserve">
          <source>SQLite uses the xBestIndex method of a virtual table module to determine the best way to access the virtual table. The xBestIndex method has a prototype like this:</source>
          <target state="translated">SQLite는 가상 테이블 모듈의 xBestIndex 메서드를 사용하여 가상 테이블에 액세스하는 가장 좋은 방법을 결정합니다. xBestIndex 메소드에는 다음과 같은 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0489776d40de65aee092fe1c30e018ce2c473df" translate="yes" xml:space="preserve">
          <source>SQLite uses two defenses against this problem. In the first place, SQLite records the number of pages in the rollback journal in the header of the rollback journal. This number is initially zero. So during an attempt to rollback an incomplete (and possibly corrupt) rollback journal, the process doing the rollback will see that the journal contains zero pages and will thus make no changes to the database. Prior to a commit, the rollback journal is flushed to disk to ensure that all content has been synced to disk and there is no &quot;garbage&quot; left in the file, and only then is the page count in the header changed from zero to true number of pages in the rollback journal. The rollback journal header is always kept in a separate sector from any page data so that it can be overwritten and flushed without risking damage to a data page if a power outage occurs. Notice that the rollback journal is flushed to disk twice: once to write the page content and a second time to write the page count in the header.</source>
          <target state="translated">SQLite는이 문제에 대해 두 가지 방어책을 사용합니다. 첫째, SQLite는 롤백 저널의 헤더에 롤백 저널의 페이지 수를 기록합니다. 이 숫자는 처음에는 0입니다. 따라서 불완전하고 손상된 롤백 저널을 롤백하려는 중에 롤백을 수행하는 프로세스는 저널에 0 페이지가 포함되어 데이터베이스를 변경하지 않음을 알 수 있습니다. 커밋 전에 롤백 저널은 디스크로 플러시되어 모든 내용이 디스크에 동기화되었고 파일에 &quot;쓰레기&quot;가 남아 있지 않은 경우에만 헤더의 페이지 수가 0에서 true로 변경됩니다. 롤백 저널의 페이지 수롤백 저널 헤더는 항상 페이지 데이터와 별도의 섹터에 보관되므로 정전이 발생하더라도 데이터 페이지가 손상 될 위험없이 덮어 쓰기 및 플러시 할 수 있습니다. 롤백 저널은 디스크에 두 번 플러시됩니다. 한 번은 페이지 내용을 쓰고 두 번은 헤더에 페이지 수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="d42ec8c41ede991363e3c5f0bdd1b5f73c156509" translate="yes" xml:space="preserve">
          <source>SQLite version</source>
          <target state="translated">SQLite 버전</target>
        </trans-unit>
        <trans-unit id="6c1b4a4dcbf2aebc5bc149eaa5647521eb4221db" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 allowed multiple simultaneous readers or a single writer but not both. SQLite version 3.0 allows one process to begin writing the database while other processes continue to read. The writer must still obtain an exclusive lock on the database for a brief interval in order to commit its changes, but the exclusive lock is no longer required for the entire write operation. A &lt;a href=&quot;lockingv3&quot;&gt;more detailed report&lt;/a&gt; on the locking behavior of SQLite version 3.0 is available separately.</source>
          <target state="translated">SQLite 버전 2.8에서는 여러 개의 동시 판독기 또는 단일 작성기를 허용했지만 둘 다 허용하지는 않았습니다. SQLite 버전 3.0에서는 한 프로세스가 데이터베이스 쓰기를 시작하는 반면 다른 프로세스는 계속 읽을 수 있습니다. 작성기는 변경 사항을 커미트하기 위해 데이터베이스에 대한 독점 잠금을 여전히 짧은 간격 동안 확보해야하지만 독점 쓰기는 더 이상 전체 쓰기 조작에 필요하지 않습니다. &lt;a href=&quot;lockingv3&quot;&gt;더 자세한 보고서&lt;/a&gt; SQLite는 버전 3.0의 잠금 동작에 별도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d94b9491c8be74ea2c30ca7aa647aa4aa14bb93b" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 had the feature that any type of data could be stored in any table column regardless of the declared type of that column. This feature is retained in version 3.0, though in a slightly modified form. Each table column will store any type of data, though columns have an affinity for the format of data defined by their declared datatype. When data is inserted into a column, that column will make an attempt to convert the data format into the column's declared type. All SQL database engines do this. The difference is that SQLite 3.0 will still store the data even if a format conversion is not possible.</source>
          <target state="translated">SQLite 버전 2.8에는 선언 된 유형의 열에 관계없이 모든 유형의 데이터를 모든 테이블 열에 저장할 수있는 기능이 있습니다. 이 기능은 약간 수정 된 형태로 버전 3.0에서 유지됩니다. 각 테이블 열은 모든 유형의 데이터를 저장하지만 선언 된 데이터 유형으로 정의 된 데이터 형식에 대한 선호도는 있습니다. 데이터가 열에 삽입되면 해당 열은 데이터 형식을 열의 선언 된 유형으로 변환하려고 시도합니다. 모든 SQL 데이터베이스 엔진이이를 수행합니다. 차이점은 형식 변환이 불가능하더라도 SQLite 3.0은 여전히 ​​데이터를 저장한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc60006fcf0499f5d27e14e08e37966af30b84e4" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 will continue to be supported with bug fixes for the foreseeable future. In order to allow SQLite version 2.8 and SQLite version 3.0 to peacefully coexist, the names of key files and APIs in SQLite version 3.0 have been changed to include the character &quot;3&quot;. For example, the include file used by C programs has been changed from &quot;sqlite.h&quot; to &quot;sqlite3.h&quot;. And the name of the shell program used to interact with databases has been changed from &quot;sqlite.exe&quot; to &quot;sqlite3.exe&quot;. With these changes, it is possible to have both SQLite 2.8 and SQLite 3.0 installed on the same system at the same time. And it is possible for the same C program to link against both SQLite 2.8 and SQLite 3.0 at the same time and to use both libraries at the same time.</source>
          <target state="translated">SQLite 버전 2.8은 가까운 장래에 버그 수정으로 계속 지원됩니다. SQLite 버전 2.8과 SQLite 버전 3.0이 평화롭게 공존 할 수 있도록 SQLite 버전 3.0의 키 파일 및 API 이름이 &quot;3&quot;문자를 포함하도록 변경되었습니다. 예를 들어, C 프로그램에서 사용하는 포함 파일이 &quot;sqlite.h&quot;에서 &quot;sqlite3.h&quot;로 변경되었습니다. 또한 데이터베이스와 상호 작용하는 데 사용되는 셸 프로그램의 이름이 &quot;sqlite.exe&quot;에서 &quot;sqlite3.exe&quot;로 변경되었습니다. 이러한 변경으로 SQLite 2.8과 SQLite 3.0을 같은 시스템에 동시에 설치할 수 있습니다. 또한 동일한 C 프로그램이 동시에 SQLite 2.8 및 SQLite 3.0에 대해 링크하고 두 라이브러리를 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9294985ea2869d413fc8305361b7fbc4273dc106" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 will deal with data in various formats internally, but when writing to the disk or interacting through its API, SQLite 2.8 always converts data into ASCII text. SQLite 3.0, in contrast, exposes its internal data representations to the user and stores binary representations to disk when appropriate. The exposing of non-ASCII representations was added in order to support BLOBs.</source>
          <target state="translated">SQLite 버전 2.8은 내부적으로 다양한 형식의 데이터를 처리하지만 디스크에 쓰거나 API를 통해 상호 작용할 때 SQLite 2.8은 항상 데이터를 ASCII 텍스트로 변환합니다. 대조적으로 SQLite 3.0은 내부 데이터 표현을 사용자에게 노출하고 적절한 경우 이진 표현을 디스크에 저장합니다. BLOB를 지원하기 위해 비 ASCII 표현 노출이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4aa319379218f233cb1b56ac0f70d481e776d1c7" translate="yes" xml:space="preserve">
          <source>SQLite version 3 has the usual set of SQL comparison operators including &quot;=&quot;, &quot;==&quot;, &quot;&amp;lt;&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;gt;&quot;, &quot;&amp;gt;=&quot;, &quot;!=&quot;, &quot;&quot;, &quot;IN&quot;, &quot;NOT IN&quot;, &quot;BETWEEN&quot;, &quot;IS&quot;, and &quot;IS NOT&quot;, .</source>
          <target state="translated">SQLite 버전 3에는 &quot;=&quot;, &quot;==&quot;, &quot;&amp;lt;&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;gt;&quot;, &quot;&amp;gt; =&quot;, &quot;! =&quot;, &quot;&quot;, &quot;IN&quot;을 포함한 일반적인 SQL 비교 연산자 세트가 있습니다. , &quot;NOT IN&quot;, &quot;BETWEEN&quot;, &quot;IS&quot;및 &quot;IS NOT&quot;,.</target>
        </trans-unit>
        <trans-unit id="a76401a1eda6f0ec422be63e7c58c505ecee397a" translate="yes" xml:space="preserve">
          <source>SQLite version 3 seeks to avoid writer starvation through the use of the PENDING lock. The PENDING lock allows existing readers to continue but prevents new readers from connecting to the database. So when a process wants to write a busy database, it can set a PENDING lock which will prevent new readers from coming in. Assuming existing readers do eventually complete, all SHARED locks will eventually clear and the writer will be given a chance to make its changes.</source>
          <target state="translated">SQLite 버전 3은 PENDING 잠금을 사용하여 작성기 기아를 피하려고합니다. PENDING 잠금을 사용하면 기존 독자는 계속 사용할 수 있지만 새 독자는 데이터베이스에 연결할 수 없습니다. 따라서 프로세스가 사용중인 데이터베이스를 작성하려고 할 때 PENDING 잠금을 설정하여 새 독자가 들어오는 것을 방지 할 수 있습니다. 기존 독자가 결국 완료되었다고 가정하면 모든 SHARED 잠금이 지워지고 작성자에게 해당 데이터베이스를 만들 수있는 기회가 주어집니다. 변화.</target>
        </trans-unit>
        <trans-unit id="eae91dc769edea8eecdb43451d72cf217325ea89" translate="yes" xml:space="preserve">
          <source>SQLite version 3.0 introduces important changes to the library, including:</source>
          <target state="translated">SQLite 버전 3.0에는 다음과 같은 중요한 변경 사항이 라이브러리에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f72a15b94cfd255cf997707c03d82c9e9918a44" translate="yes" xml:space="preserve">
          <source>SQLite version 3.0 is a new version of SQLite, derived from the SQLite 2.8.13 code base, but with an incompatible file format and API. SQLite version 3.0 was created to answer demand for the following features:</source>
          <target state="translated">SQLite 버전 3.0은 SQLite 2.8.13 코드 기반에서 파생 된 새로운 버전의 SQLite이지만 호환되지 않는 파일 형식과 API를 갖습니다. SQLite 버전 3.0은 다음 기능에 대한 요구에 부응하기 위해 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="ccb4f474cdcf4df9f87f4000dec5a3f14ed4609b" translate="yes" xml:space="preserve">
          <source>SQLite version 3.0 is made possible in part by AOL developers supporting and embracing great Open-Source Software.</source>
          <target state="translated">SQLite 버전 3.0은 훌륭한 오픈 소스 소프트웨어를 지원하고 수용하는 AOL 개발자들에 의해 부분적으로 가능해졌습니다.</target>
        </trans-unit>
        <trans-unit id="ef6b4fa665bce97a58d8cad0238042778638e4ea" translate="yes" xml:space="preserve">
          <source>SQLite version 3.22.0 (2018-01-22) contains 5290 assert() macros, 839 testcase() macros, 88 ALWAYS() macros, and 63 NEVER() macros.</source>
          <target state="translated">SQLite 버전 3.22.0 (2018-01-22)에는 5290 assert () 매크로, 839 testcase () 매크로, 88 ALWAYS () 매크로 및 63 NEVER () 매크로가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c307004a0921076eb49a52bd8a91c6b52b2a1b6b" translate="yes" xml:space="preserve">
          <source>SQLite version 3.3.14 adds the concept of &quot;Exclusive Access Mode&quot;. In exclusive access mode, SQLite retains the exclusive database lock at the conclusion of each transaction. This prevents other processes from accessing the database, but in many deployments only a single process is using a database so this is not a serious problem. The advantage of exclusive access mode is that disk I/O can be reduced in three ways:</source>
          <target state="translated">SQLite 버전 3.3.14에는 &quot;독점 액세스 모드&quot;라는 개념이 추가되었습니다. 단독 액세스 모드에서 SQLite는 각 트랜잭션이 끝날 때 독점 데이터베이스 잠금을 유지합니다. 이렇게하면 다른 프로세스가 데이터베이스에 액세스 할 수 없지만 많은 배포에서 단일 프로세스 만 데이터베이스를 사용하므로 심각한 문제는 아닙니다. 단독 액세스 모드의 장점은 디스크 I / O를 세 가지 방식으로 줄일 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fbb503554e7c282aedc13f070027736e1a10fc7b" translate="yes" xml:space="preserve">
          <source>SQLite version 3.5.0 (2007-09-04) introduces a new OS interface layer that is incompatible with all prior versions of SQLite. In addition, a few existing interfaces have been generalized to work across all database connections within a process rather than just all connections within a thread. The purpose of this article is to describe the changes to 3.5.0 in detail so that users of prior versions of SQLite can judge what, if any, effort will be required to upgrade to newer versions.</source>
          <target state="translated">SQLite 버전 3.5.0 (2007-09-04)에는 모든 이전 버전의 SQLite와 호환되지 않는 새로운 OS 인터페이스 계층이 도입되었습니다. 또한 스레드 내의 모든 연결이 아니라 프로세스 내의 모든 데이터베이스 연결에서 작동하도록 몇 가지 기존 인터페이스가 일반화되었습니다. 이 기사의 목적은 이전 버전의 SQLite 사용자가 최신 버전으로 업그레이드하기 위해 어떤 노력이 필요한지 판단 할 수 있도록 3.5.0의 변경 사항을 자세히 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70942f1687fac3fdda946d021fc48ca1143963c7" translate="yes" xml:space="preserve">
          <source>SQLite version 3.6.0 (2008-07-16) contains many changes. As is the custom with the SQLite project, most changes are fully backwards compatible. However, a few of the changes in version 3.6.0 are incompatible and might require modifications to application code and/or makefiles. This document is a briefing on the changes in SQLite 3.6.0 with special attention to the incompatible changes.</source>
          <target state="translated">SQLite 버전 3.6.0 (2008-07-16)에는 많은 변경 사항이 포함되어 있습니다. SQLite 프로젝트의 사용자 정의와 마찬가지로 대부분의 변경 사항은 이전 버전과 완전히 호환됩니다. 그러나 버전 3.6.0의 일부 변경 사항은 호환되지 않으며 응용 프로그램 코드 및 / 또는 makefile을 수정해야합니다. 이 문서는 호환되지 않는 변경 사항에 특히주의하면서 SQLite 3.6.0의 변경 사항에 대한 브리핑입니다.</target>
        </trans-unit>
        <trans-unit id="da041872c2ed2b85c83a9be5e4c3422e0d89ff87" translate="yes" xml:space="preserve">
          <source>SQLite version 3.7.0 introduced a number of new enhancements to the SQLite database file format (such as but not limited to &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;). The 3.7.0 release was a shake-out release for these new features. We expected to find problems and were not disappointed.</source>
          <target state="translated">SQLite 버전 3.7.0에는 SQLite 데이터베이스 파일 형식 ( &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 등으로 제한되지 않음)에 대한 여러 가지 새로운 기능이 도입되었습니다 . 3.7.0 릴리스는 이러한 새로운 기능을위한 셰이크 아웃 릴리스입니다. 우리는 문제를 찾을 것으로 예상했지만 실망하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="31e4e9d6b69cabc107d20e4736663f7980b134d1" translate="yes" xml:space="preserve">
          <source>SQLite version 3.7.16.2 fixes a subtle race condition in the locking logic on Windows systems. When a database file is in need of recovery because the previous process writing to it crashed in the middle of a transaction and two or more processes try to open the that database at the same time, then the race condition might cause one of those processes to get a false indication that the recovery has already completed, allowing that process to continue using the database file without running recovery first. If that process writes to the file, then the file might go corrupt. This race condition had apparently existed in all prior versions of SQLite for Windows going back to 2004. But the race was very tight. Practically speaking, you need a fast multi-core machine in which you launch two processes to run recovery at the same moment on two separate cores. This defect was on Windows systems only and did not affect the posix OS interface.</source>
          <target state="translated">SQLite 버전 3.7.16.2는 Windows 시스템의 잠금 로직에서 미묘한 경쟁 조건을 수정합니다. 데이터베이스 파일에 대한 이전 프로세스 쓰기가 트랜잭션 중간에 충돌하여 두 개 이상의 프로세스가 동시에 해당 데이터베이스를 열려고하기 때문에 데이터베이스 파일을 복구해야하는 경우 경쟁 조건으로 인해 해당 프로세스 중 하나가 발생할 수 있습니다. 복구가 이미 완료되었다는 잘못된 표시를 받으면 해당 프로세스가 복구를 먼저 실행하지 않고 데이터베이스 파일을 계속 사용할 수 있습니다. 해당 프로세스가 파일에 쓰면 파일이 손상 될 수 있습니다. 이 경쟁 조건은 2004 년으로 돌아 가기 이전의 모든 Windows 용 SQLite 버전에서 분명히 존재했습니다. 그러나 경쟁은 매우 빡빡했습니다. 실제로 말하면,두 개의 개별 코어에서 동시에 복구를 실행하기 위해 두 개의 프로세스를 시작하는 빠른 멀티 코어 시스템이 필요합니다. 이 결함은 Windows 시스템에서만 발생했으며 posix OS 인터페이스에는 영향을 미치지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="06c5d06f2767343fefb84004cfe2451c3fbeba78" translate="yes" xml:space="preserve">
          <source>SQLite was originally coded in such a way that the answer to all questions in the chart below would be &quot;Yes&quot;. But the experiments run on other SQL engines showed that none of them worked this way. So SQLite was modified to work the same as Oracle, PostgreSQL, and DB2. This involved making NULLs indistinct for the purposes of the SELECT DISTINCT statement and for the UNION operator in a SELECT. NULLs are still distinct in a UNIQUE column. This seems somewhat arbitrary, but the desire to be compatible with other engines outweighed that objection.</source>
          <target state="translated">SQLite는 원래 아래 차트의 모든 질문에 대한 답변이 &quot;예&quot;가되도록 코딩되었습니다. 그러나 다른 SQL 엔진에서 실행 된 실험에서는 이들 중 어느 것도 이런 방식으로 작동하지 않음을 보여주었습니다. 따라서 SQLite는 Oracle, PostgreSQL 및 DB2와 동일하게 작동하도록 수정되었습니다. 여기에는 SELECT DISTINCT 문의 목적과 SELECT의 UNION 연산자에 대해 NULL을 구분하지 않는 것이 포함됩니다. UNIQUE 열에서 NULL은 여전히 ​​고유합니다. 이것은 다소 임의적 인 것처럼 보이지만 다른 엔진과의 호환성에 대한 요구는 그 반대보다 중요했습니다.</target>
        </trans-unit>
        <trans-unit id="cc2cc08c1f222d49bc97f5f39c7b9c91ad3731d6" translate="yes" xml:space="preserve">
          <source>SQLite was originally designed with a policy of avoiding arbitrary limits. Of course, every program that runs on a machine with finite memory and disk space has limits of some kind. But in SQLite, those limits were not well defined. The policy was that if it would fit in memory and you could count it with a 32-bit integer, then it should work.</source>
          <target state="translated">SQLite는 원래 임의의 제한을 피하는 정책으로 설계되었습니다. 물론, 유한 메모리와 디스크 공간이있는 머신에서 실행되는 모든 프로그램에는 어떤 종류의 제한이 있습니다. 그러나 SQLite에서는 이러한 한계가 잘 정의되지 않았습니다. 정책은 메모리에 적합하고 32 비트 정수로 계산할 수 있으면 작동한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="769cb93a3fb24f4ad929e24b9c4fe55eeec4efe2" translate="yes" xml:space="preserve">
          <source>SQLite was tested in the same configuration that it appears on the website. It was compiled with -O6 optimization and with the -DNDEBUG=1 switch which disables the many &quot;assert()&quot; statements in the SQLite code. The -DNDEBUG=1 compiler option roughly doubles the speed of SQLite.</source>
          <target state="translated">SQLite는 웹 사이트와 동일한 구성으로 테스트되었습니다. -O6 최적화 및 -DNDEBUG = 1 스위치로 컴파일되어 SQLite 코드에서 많은 &quot;assert ()&quot;문을 비활성화합니다. -DNDEBUG = 1 컴파일러 옵션은 SQLite 속도를 거의 두 배로 높입니다.</target>
        </trans-unit>
        <trans-unit id="864e2447d8a13ac7ee35b071674f4476208c7306" translate="yes" xml:space="preserve">
          <source>SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">SQLite는 열린 객체에 따라 xOpen () 호출에 다음 플래그 중 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="131d0be5dd7e4aa0858930ddc9451eb1f3423fe0" translate="yes" xml:space="preserve">
          <source>SQLite will also attempt to use indices to help satisfy GROUP BY clauses and the DISTINCT keyword. If the nested loops of the join can be arranged such that rows that are equivalent for the GROUP BY or for the DISTINCT are consecutive, then the GROUP BY or DISTINCT logic can determine if the current row is part of the same group or if the current row is distinct simply by comparing the current row to the previous row. This can be much faster than the alternative of comparing each row to all prior rows.</source>
          <target state="translated">SQLite는 또한 GROUP BY 절과 DISTINCT 키워드를 만족시키기 위해 인덱스를 사용하려고 시도합니다. GROUP BY 또는 DISTINCT에 해당하는 행이 연속되도록 조인의 중첩 루프를 배열 할 수있는 경우 GROUP BY 또는 DISTINCT 논리는 현재 행이 동일한 그룹의 일부인지 또는 현재 행인지 판별 할 수 있습니다. 행은 단순히 현재 행과 이전 행을 비교하여 구별됩니다. 각 행을 모든 이전 행과 비교하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="03ac5706e55e0f1ceba6bf4ddd17b581fa34f6ca" translate="yes" xml:space="preserve">
          <source>SQLite will always allocate at least mxPathname+1 bytes for the output buffer xFullPathname. The exact size of the output buffer is also passed as a parameter to both methods. If the output buffer is not large enough, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; should be returned. Since this is handled as a fatal error by SQLite, vfs implementations should endeavor to prevent this by setting mxPathname to a sufficiently large value.</source>
          <target state="translated">SQLite는 항상 출력 버퍼 xFullPathname에 대해 mxPathname + 1 바이트 이상을 할당합니다. 출력 버퍼의 정확한 크기는 두 메소드 모두에 매개 변수로 전달됩니다. 출력 버퍼가 충분히 크지 않으면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 을 리턴해야합니다. 이는 SQLite에서 치명적인 오류로 처리되므로 vfs 구현에서는 mxPathname을 충분히 큰 값으로 설정하여이를 방지하기 위해 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="a98d8800d0c61913767afcbc8c0b3400cddf5e5e" translate="yes" xml:space="preserve">
          <source>SQLite will always allocate at least mxPathname+1 bytes for the output buffer xFullPathname. The exact size of the output buffer is also passed as a parameter to both methods. If the output buffer is not large enough, &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; should be returned. Since this is handled as a fatal error by SQLite, vfs implementations should endeavor to prevent this by setting mxPathname to a sufficiently large value.</source>
          <target state="translated">SQLite는 항상 출력 버퍼 xFullPathname에 대해 mxPathname + 1 바이트 이상을 할당합니다. 출력 버퍼의 정확한 크기는 두 메소드 모두에 매개 변수로 전달됩니다. 출력 버퍼가 충분히 크지 않으면 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 을 리턴해야합니다. 이는 SQLite에서 치명적인 오류로 처리되므로 vfs 구현에서는 mxPathname을 충분히 큰 값으로 설정하여이를 방지하기 위해 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e33e35f6dabafac608ead478729b44348c338ef" translate="yes" xml:space="preserve">
          <source>SQLite will invoke the xMutexEnd() method when &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; is called, but only if the prior call to xMutexInit returned SQLITE_OK. If xMutexInit fails in any way, it is expected to clean up after itself prior to returning.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 이 호출 될 때 SQLite는 xMutexEnd () 메소드를 호출하지만 xMutexInit에 대한 이전 호출이 SQLITE_OK를 리턴 한 경우에만 호출합니다. xMutexInit가 어떤 식 으로든 실패하면 반환하기 전에 자체적으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="3e7a5d17c455846b0ec61394b33dc86a1c9321c1" translate="yes" xml:space="preserve">
          <source>SQLite will invoke the xMutexEnd() method when &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; is called, but only if the prior call to xMutexInit returned SQLITE_OK. If xMutexInit fails in any way, it is expected to clean up after itself prior to returning.</source>
          <target state="translated">&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 이 호출 될 때 SQLite는 xMutexEnd () 메소드를 호출하지만 xMutexInit에 대한 이전 호출이 SQLITE_OK를 리턴 한 경우에만 호출합니다. xMutexInit가 어떤 식 으로든 실패하면 반환하기 전에 자체적으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8ba8da1a2e441af20b1b20244a8ec294fc1a9c" translate="yes" xml:space="preserve">
          <source>SQLite will make this determination, but only if it has been compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. The &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; and &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; options causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a histogram of column content in the &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; or &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; tables and to use this histogram to make a better guess at the best query to use for range constraints such as the above. The main difference between STAT3 and STAT4 is that STAT3 records histogram data for only the left-most column of an index whereas STAT4 records histogram data for all columns of an index. For single-column indexes, STAT3 and STAT4 work the same.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 로 컴파일 된 경우에만이 결정을 내 립니다 . &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 및 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 옵션은이 원인 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 에서 열 내용의 히스토그램을 수집하는 명령 &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; 또는 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 테이블과 같은 위와 같이 범위 제한에 사용할 최적의 쿼리에서 더 나은 추측을하기 위해 히스토그램을 사용합니다. STAT3과 STAT4의 주요 차이점은 STAT3이 인덱스의 가장 왼쪽 열에 대해서만 히스토그램 데이터를 기록하는 반면 STAT4는 인덱스의 모든 열에 대한 히스토그램 데이터를 기록한다는 것입니다. 단일 열 인덱스의 경우 STAT3과 STAT4가 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0feeafe3441c848d4df17e7ab2118b3ce654ef9a" translate="yes" xml:space="preserve">
          <source>SQLite will never invoke xInit() more than once without an intervening call to xShutdown().</source>
          <target state="translated">SQLite는 xShutdown ()에 대한 호출없이 xInit ()를 두 번 이상 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8141933bded4b0433c5458cd8dc4b6c9aa50dccc" translate="yes" xml:space="preserve">
          <source>SQLite will normally invoke xFetch() with a createFlag of 0 or 1. SQLite will only use a createFlag of 2 after a prior call with a createFlag of 1 failed. In between the to xFetch() calls, SQLite may attempt to unpin one or more cache pages by spilling the content of pinned pages to disk and synching the operating system disk cache.</source>
          <target state="translated">SQLite는 일반적으로 createFlag가 0 또는 1 인 xFetch ()를 호출합니다. SQLite는 createFlag가 1 인 이전 호출이 실패한 후에 만 ​​createFlag 2를 사용합니다. to xFetch () 호출 사이에서 SQLite는 고정 된 페이지의 컨텐츠를 디스크에 유출하고 운영 체제 디스크 캐시를 동기화하여 하나 이상의 캐시 페이지를 고정 해제하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0c63958ff91d6ac8d167ebbeb5d529f639eed1" translate="yes" xml:space="preserve">
          <source>SQLite will normally invoke xFetch() with a createFlag of 0 or 1. SQLite will only use a createFlag of 2 after a prior call with a createFlag of 1 failed. In between the xFetch() calls, SQLite may attempt to unpin one or more cache pages by spilling the content of pinned pages to disk and synching the operating system disk cache.</source>
          <target state="translated">SQLite는 일반적으로 createFlag가 0 또는 1 인 xFetch ()를 호출합니다. SQLite는 createFlag가 1 인 이전 호출이 실패한 후에 만 ​​createFlag 2를 사용합니다. xFetch () 호출 사이에서 SQLite는 고정 된 페이지의 내용을 디스크에 넘기고 운영 체제 디스크 캐시를 동기화하여 하나 이상의 캐시 페이지를 고정 해제하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26bbe6f761c35b13c9b3c740596c8f4fafbb74f1" translate="yes" xml:space="preserve">
          <source>SQLite will normally work fine as the database backend to a website. But if the website is write-intensive or is so busy that it requires multiple servers, then consider using an enterprise-class client/server database engine instead of SQLite.</source>
          <target state="translated">SQLite는 일반적으로 웹 사이트의 데이터베이스 백엔드로 정상적으로 작동합니다. 그러나 웹 사이트가 쓰기 집약적이거나 너무 바빠서 여러 서버가 필요한 경우 SQLite 대신 엔터프라이즈 급 클라이언트 / 서버 데이터베이스 엔진을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11d8b5641b8ccc13250b43f6ec693456aaae006d" translate="yes" xml:space="preserve">
          <source>SQLite will still omit the sorting step. But in order for output to appear in the correct order, SQLite will do the table scan starting at the end and working toward the beginning, rather than starting at the beginning and working toward the end as shown in &lt;a href=&quot;#fig17&quot;&gt;figure 17&lt;/a&gt;.</source>
          <target state="translated">SQLite는 여전히 정렬 단계를 생략합니다. 그러나 출력이 올바른 순서로 표시되도록하기 위해 SQLite는 &lt;a href=&quot;#fig17&quot;&gt;그림 17에&lt;/a&gt; 표시된 것처럼 처음부터 시작하여 끝까지 작업하지 않고 끝에서 시작하여 처음으로 작업하는 테이블 스캔을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="db0bee01e01c7f06f53ced4aa077d1b69e3e443d" translate="yes" xml:space="preserve">
          <source>SQLite works best if you group multiple operations together into a single transaction.</source>
          <target state="translated">SQLite는 여러 작업을 단일 트랜잭션으로 그룹화 할 때 가장 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5a4570a64a559f2380207d7ac2eae2dd4a188a0c" translate="yes" xml:space="preserve">
          <source>SQLite works by compiling SQL text into &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;, then running that bytecode using a virtual machine.</source>
          <target state="translated">SQLite는 SQL 텍스트를 &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; 로 컴파일 한 다음 가상 머신을 사용하여 해당 바이트 코드를 실행하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1c47334be07eef6e2c6868c4937b4803add8d7d3" translate="yes" xml:space="preserve">
          <source>SQLite works by translating SQL statements into bytecode and then running that bytecode in a virtual machine. This document describes how how the bytecode engine works.</source>
          <target state="translated">SQLite는 SQL 문을 바이트 코드로 변환 한 다음 가상 머신에서 해당 바이트 코드를 실행하여 작동합니다. 이 문서는 바이트 코드 엔진의 작동 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1ebaf35d34ab3b907a64e57112416a9de1a568a2" translate="yes" xml:space="preserve">
          <source>SQLite works by translating each SQL statement into bytecode and then running that bytecode. A &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; in SQLite is mostly just the bytecode needed to implement the corresponding SQL. The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface is a compiler that translates SQL into bytecode. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface is the virtual machine that runs the bytecode contained within the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;.</source>
          <target state="translated">SQLite는 각 SQL 문을 바이트 코드로 변환 한 다음 해당 바이트 코드를 실행하여 작동합니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; SQLite는의 대부분이 해당 SQL을 구현하는 데 필요한 단지 바이트 코드입니다. &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 인터페이스는 SQL 바이트 코드로 변환하는 컴파일러이다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스가 포함 된 바이트 코드를 실행하는 가상 머신입니다 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="535be0580b8710df785d98333c6a0024a79e6b52" translate="yes" xml:space="preserve">
          <source>SQLite works great as the database engine for most low to medium traffic websites (which is to say, most websites). The amount of web traffic that SQLite can handle depends on how heavily the website uses its database. Generally speaking, any site that gets fewer than 100K hits/day should work fine with SQLite. The 100K hits/day figure is a conservative estimate, not a hard upper bound. SQLite has been demonstrated to work with 10 times that amount of traffic.</source>
          <target state="translated">SQLite는 트래픽이 적거나 중간 정도 인 웹 사이트 (즉, 대부분의 웹 사이트)의 데이터베이스 엔진으로 작동합니다. SQLite가 처리 할 수있는 웹 트래픽의 양은 웹 사이트가 데이터베이스를 얼마나 많이 사용하는지에 따라 다릅니다. 일반적으로 하루에 조회수가 10 만 회 미만인 사이트는 SQLite에서 제대로 작동합니다. 100K 조회수 / 일 수치는 상한이 아니라 보수적 인 추정치입니다. SQLite는 트래픽 양의 10 배에 해당하는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="878697a779b4f555e31be3e87a76fb2ec64adcb9" translate="yes" xml:space="preserve">
          <source>SQLite&amp;#x27;s Built-in printf()</source>
          <target state="translated">SQLite의 내장 printf ()</target>
        </trans-unit>
        <trans-unit id="d809358342217ac1c9798a4536e992e30b5c1bbd" translate="yes" xml:space="preserve">
          <source>SQLite's Built-in printf()</source>
          <target state="translated">SQLite의 내장 printf ()</target>
        </trans-unit>
        <trans-unit id="77bf8cb88e1c9ff7655bff7a5cbb97288c41b450" translate="yes" xml:space="preserve">
          <source>SQLite, in contrast, stores all content in a &lt;a href=&quot;fileformat2&quot;&gt;single file on disk&lt;/a&gt;. That single file is something you can point to and say &quot;this is the database&quot;. It behaves as an object. An SQLite database file can be copied, renamed, sent as an email attachment, passed as the argument a POST HTTP request, or otherwise treated as other data object such as an image, document, or media file.</source>
          <target state="translated">반면 SQLite는 모든 내용 &lt;a href=&quot;fileformat2&quot;&gt;을 디스크&lt;/a&gt; 의 단일 파일에 저장합니다 . 이 단일 파일은 &quot;이것은 데이터베이스입니다&quot;라고 지적하고 말할 수있는 것입니다. 객체처럼 동작합니다. SQLite 데이터베이스 파일은 복사, 이름 변경, 이메일 첨부 파일로 전송, POST HTTP 요청의 인수로 전달되거나 이미지, 문서 또는 미디어 파일과 같은 다른 데이터 오브젝트로 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d5e7b501f4c23aeddb2e1d173f4fc5a56622fde" translate="yes" xml:space="preserve">
          <source>SQLite, in contrast, use only the amount of disk space actually needed to store the information in a row. If you store a single character in a VARCHAR(100) column, then only a single byte of disk space is consumed. (Actually two bytes - there is some overhead at the beginning of each column to record its datatype and length.)</source>
          <target state="translated">반면 SQLite는 실제로 정보를 한 행에 저장하는 데 필요한 디스크 공간 만 사용합니다. VARCHAR (100) 열에 단일 문자를 저장하면 1 바이트의 디스크 공간 만 사용됩니다. (실제로 2 바이트-데이터 유형 및 길이를 기록하기 위해 각 열의 시작 부분에 약간의 오버 헤드가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="90a2c30d411105b1866a2fb7534e120d54c087c8" translate="yes" xml:space="preserve">
          <source>SQLite, like all SQL database engines, makes extensive use of malloc() (See the separate report on &lt;a href=&quot;malloc&quot;&gt;dynamic memory allocation in SQLite&lt;/a&gt; for additional detail.) On servers and workstations, malloc() never fails in practice and so correct handling of out-of-memory (OOM) errors is not particularly important. But on embedded devices, OOM errors are frighteningly common and since SQLite is frequently used on embedded devices, it is important that SQLite be able to gracefully handle OOM errors.</source>
          <target state="translated">모든 SQL 데이터베이스 엔진과 마찬가지로 SQLite는 malloc ()을 광범위하게 사용합니다 (자세한 내용은 &lt;a href=&quot;malloc&quot;&gt;SQLite의 동적 메모리 할당에&lt;/a&gt; 대한 별도의 보고서를 참조하십시오 ). 서버와 워크 스테이션에서 malloc ()은 실제로 실패하지 않으므로 올바르게 처리하지 않습니다. 메모리 부족 (OOM) 오류는 특별히 중요하지 않습니다. 그러나 임베디드 장치에서는 OOM 오류가 매우 흔하며 SQLite가 임베디드 장치에서 자주 사용되므로 SQLite가 OOM 오류를 정상적으로 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8aba37dd603a24e82fd4f1820189539d3d0a566" translate="yes" xml:space="preserve">
          <source>SQLite: Single File Database</source>
          <target state="translated">SQLite : 단일 파일 데이터베이스</target>
        </trans-unit>
        <trans-unit id="8317c0736d9e6aaddc008372c034f2f63ca423a2" translate="yes" xml:space="preserve">
          <source>Safe languages are often touted for helping to prevent security vulnerabilities. True enough, but SQLite is not a particularly security-sensitive library. If an application is running untrusted and unverified SQL, then it already has much bigger security issues (SQL injection) that no &quot;safe&quot; language will fix.</source>
          <target state="translated">보안 취약점을 예방하는 데 도움이되는 안전한 언어가 종종 선전됩니다. 충분하지만 SQLite는 특히 보안에 민감한 라이브러리는 아닙니다. 응용 프로그램이 신뢰할 수없고 검증되지 않은 SQL을 실행하는 경우 &quot;안전한&quot;언어로 해결되지 않는 훨씬 더 큰 보안 문제 (SQL 주입)가 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="371ba39228ab4a1c3c189b797c7120e98ace4662" translate="yes" xml:space="preserve">
          <source>Safe languages insert additional machine branches to do things like verify that array accesses are in-bounds. In correct code, those branches are never taken. That means that the machine code cannot be 100% branch tested, which is an important component of SQLite's quality strategy.</source>
          <target state="translated">안전한 언어는 추가 기계 분기를 삽입하여 배열 액세스가 인바운드인지 확인하는 등의 작업을 수행합니다. 올바른 코드에서는 이러한 분기가 수행되지 않습니다. 이는 머신 코드를 100 % 분기 테스트 할 수 없다는 것을 의미하며 이는 SQLite 품질 전략의 중요한 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="fcacd9319f45f058826102f8fd4d08b85a39ed32" translate="yes" xml:space="preserve">
          <source>Safe languages usually want to abort if they encounter an out-of-memory (OOM) situation. SQLite is designed to recover gracefully from an OOM. It is unclear how this could be accomplished in the current crop of safe languages.</source>
          <target state="translated">안전한 언어는 일반적으로 메모리 부족 (OOM) 상황이 발생하면 중단하려고합니다. SQLite는 OOM에서 정상적으로 복구하도록 설계되었습니다. 이것이 안전한 언어의 현재 작물에서 어떻게 이룰 수 있는지는 불분명합니다.</target>
        </trans-unit>
        <trans-unit id="3c6da187258d5af2ebae1cdb3cc862f47c52557f" translate="yes" xml:space="preserve">
          <source>Safe languages usually want to abort if they encounter an out-of-memory (OOM) situation. SQLite is designed to recovery gracefully from an OOM. It is unclear how this could be accomplished in the current crop of safe languages.</source>
          <target state="translated">안전한 언어는 일반적으로 메모리 부족 (OOM) 상황이 발생하면 중단하려고합니다. SQLite는 OOM에서 정상적으로 복구하도록 설계되었습니다. 현재 안전한 언어로 어떻게이 작업을 수행 할 수 있는지는 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb8901e65be4e894ae11ab1d95f963f276b64fd4" translate="yes" xml:space="preserve">
          <source>Safe programming languages solve the easy problems: memory leaks, use-after-free errors, array overruns, etc. Safe languages provide no help beyond ordinary C code in solving the rather more difficult problem of computing a correct answer to an SQL statement.</source>
          <target state="translated">안전한 프로그래밍 언어는 메모리 누수, 사후 사용 오류, 어레이 오버런 등과 같은 쉬운 문제를 해결합니다. 안전한 언어는 SQL 문에 대한 정답을 계산하는 데있어 다소 어려운 문제를 해결하는 데있어 일반적인 C 코드 외에는 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c0b98b770b73c58eadb8af8b218e45dc7ebebbf" translate="yes" xml:space="preserve">
          <source>Safety-critical applications will usually want to modify the default lookaside memory configuration so that when the initial lookaside memory buffer is allocated during &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; the resulting memory allocation is not so large as to force the &lt;b&gt;n&lt;/b&gt; parameter to be too large. In order to keep &lt;b&gt;n&lt;/b&gt; under control, it is best to try to keep the largest memory allocation below 2 or 4 kilobytes. Hence, a reasonable default setup for the lookaside memory allocator might any one of the following:</source>
          <target state="translated">안전에 중요한 응용 프로그램은 일반적으로 초기 lookaside 메모리 버퍼가 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 중에 할당 될 때 결과 메모리 할당이 너무 커서 &lt;b&gt;n&lt;/b&gt; 매개 변수가 너무 커지지 않도록 기본 lookaside 메모리 구성을 수정하려고합니다 . 유지하기 위해 &lt;b&gt;N&lt;/b&gt; 통제를, 그것은 2 4킬로바이트 아래 가장 큰 메모리 할당을 유지하려고하는 것이 가장 좋습니다. 따라서 lookaside 메모리 할당 자에 대한 합리적인 기본 설정은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb272988295a04bfacb652f9f425c9751c1efcff" translate="yes" xml:space="preserve">
          <source>Salt-1 copied from the WAL header</source>
          <target state="translated">WAL 헤더에서 복사 된 Salt-1</target>
        </trans-unit>
        <trans-unit id="8f07478edf0a13be2b8353393ce58be98c5cb042" translate="yes" xml:space="preserve">
          <source>Salt-1: random integer incremented with each checkpoint</source>
          <target state="translated">Salt-1 : 각 체크 포인트마다 증가하는 임의의 정수</target>
        </trans-unit>
        <trans-unit id="fd8becc82bf3034e486b52e348505de06703eadf" translate="yes" xml:space="preserve">
          <source>Salt-2 copied from the WAL header</source>
          <target state="translated">WAL 헤더에서 복사 된 Salt-2</target>
        </trans-unit>
        <trans-unit id="2251457c30eb39ac4f98ca1b3b449998bdfb08bd" translate="yes" xml:space="preserve">
          <source>Salt-2: a different random number for each checkpoint</source>
          <target state="translated">Salt-2 : 각 체크 포인트마다 다른 난수</target>
        </trans-unit>
        <trans-unit id="2802d3bf84d06bd601abc4160930ee13b4ba8886" translate="yes" xml:space="preserve">
          <source>Same as INTEGER-&amp;gt;TEXT</source>
          <target state="translated">INTEGER-&amp;gt; TEXT와 동일</target>
        </trans-unit>
        <trans-unit id="64fe7599a1466f63ea9b7dc136b08e0468a7bcfe" translate="yes" xml:space="preserve">
          <source>Save the pointer passed as the second argument as the extension function's &quot;auxiliary data&quot;. The pointer may then be retrieved by the current or any future invocation of the same fts5 extension function made as part of the same MATCH query using the xGetAuxdata() API.</source>
          <target state="translated">두 번째 인수로 전달 된 포인터를 확장 함수의 &quot;보조 데이터&quot;로 저장합니다. 포인터는 xGetAuxdata () API를 사용하여 동일한 MATCH 쿼리의 일부로 만들어진 동일한 fts5 확장 함수의 현재 또는 향후 호출에 의해 검색 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e164ee3e19bc05538690fe1a5205fe5b7956a433" translate="yes" xml:space="preserve">
          <source>Save the pointer passed as the second argument as the extension functions &quot;auxiliary data&quot;. The pointer may then be retrieved by the current or any future invocation of the same fts5 extension function made as part of the same MATCH query using the xGetAuxdata() API.</source>
          <target state="translated">확장 함수 &quot;보조 데이터&quot;로 두 번째 인수로 전달 된 포인터를 저장하십시오. 그런 다음 xGetAuxdata () API를 사용하여 동일한 MATCH 쿼리의 일부로 만들어진 동일한 fts5 확장 함수의 현재 또는 향후 호출에 의해 포인터를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c739de5dc59a519ecc88e91c12cee776ddb9f8ec" translate="yes" xml:space="preserve">
          <source>Savepoint</source>
          <target state="translated">Savepoint</target>
        </trans-unit>
        <trans-unit id="e74ed8e87da0851118fc159806fbe103dac70bbe" translate="yes" xml:space="preserve">
          <source>Savepoints</source>
          <target state="translated">Savepoints</target>
        </trans-unit>
        <trans-unit id="4bcd8d5b6d914b78fd787d6f4862352598ee3d05" translate="yes" xml:space="preserve">
          <source>Scalar SQL functions are implemented by a single callback in the &lt;b&gt;xFunc&lt;/b&gt; parameter to sqlite3_create_function(). The following code demonstrations the implementation of a &quot;noop(X)&quot; scalar SQL function that merely returns its argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae2c6197cf9bbcd1ad8c12e21c2553a379969bd" translate="yes" xml:space="preserve">
          <source>Scan all rows of realtab and for each row, find rows in tablevaluedfunc where param1 is equal to realtab.x</source>
          <target state="translated">realtab의 모든 행을 스캔하고 각 행에 대해 param1이 realtab.x와 동일한 tablevaluedfunc에서 행을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="81b10ed131cb8283236308eac51fe1690aaceea4" translate="yes" xml:space="preserve">
          <source>Scan all rows of tablevalued func and for each row find rows in realtab where x is equal to tablevaluedfunc.param1.</source>
          <target state="translated">tablevalued func의 모든 행을 스캔하고 각 행에 대해 x가 tablevaluedfunc.param1과 동일한 realtab에서 행을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="54a7124a44e1230cb0e0f19e93fb0a0d583d3126" translate="yes" xml:space="preserve">
          <source>Schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D must be a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 스키마 S는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="4938e6644f0ad52bc0448849639259b7608261fb" translate="yes" xml:space="preserve">
          <source>Schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D must be a &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; database.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 스키마 S는 &lt;a href=&quot;../wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="783379b4d6a04cfdb7223b86944f535ee34f305b" translate="yes" xml:space="preserve">
          <source>Schema format number</source>
          <target state="translated">스키마 형식 번호</target>
        </trans-unit>
        <trans-unit id="3818a04cadbc7e36a69fd1fddf0ec427879c13a3" translate="yes" xml:space="preserve">
          <source>Search application tips</source>
          <target state="translated">응용 프로그램 검색 팁</target>
        </trans-unit>
        <trans-unit id="8f58d07a782f28f0be6c5eba33589bc58551ce12" translate="yes" xml:space="preserve">
          <source>Second Improvement: Split content into smaller pieces</source>
          <target state="translated">두 번째 개선 : 내용을 더 작은 조각으로 나누기</target>
        </trans-unit>
        <trans-unit id="ec79d2ea1a314df8f0b27d40fa827558108d418f" translate="yes" xml:space="preserve">
          <source>Second copy of the WAL Index Information</source>
          <target state="translated">WAL 색인 정보의 두 번째 사본</target>
        </trans-unit>
        <trans-unit id="f2c6b564bd8119e16a3e573a6f9e7c6d1ac7820f" translate="yes" xml:space="preserve">
          <source>Section</source>
          <target state="translated">Section</target>
        </trans-unit>
        <trans-unit id="abbdc2b8f6673a1b63bbd1262eceea1c936362ed" translate="yes" xml:space="preserve">
          <source>Sections of the database that are used more than once, or not at all</source>
          <target state="translated">두 번 이상 사용되거나 전혀 사용되지 않는 데이터베이스 섹션</target>
        </trans-unit>
        <trans-unit id="bbd835e731943b498ec1909cabc1e38a99b94296" translate="yes" xml:space="preserve">
          <source>Security and compatibilities enhancements to &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()의&lt;/a&gt; 보안 및 호환성 향상 :</target>
        </trans-unit>
        <trans-unit id="8229f87bed66ece3cde105695968321f8308f48e" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;queryplanner-ng#fossilcasestudy&quot;&gt;The Fossil NGQP Upgrade Case Study&lt;/a&gt;&quot; for another real-world example of using CROSS JOIN to manually control the nesting order of a join. The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; found later in the same document provides further guidance on manual control of the query planner.</source>
          <target state="translated">CROSS JOIN을 사용하여 조인의 중첩 순서를 수동으로 제어하는 ​​또 다른 실제 예는 &quot; &lt;a href=&quot;queryplanner-ng#fossilcasestudy&quot;&gt;Fossil NGQP 업그레이드 사례 연구&lt;/a&gt; &quot;를 참조하십시오 . &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;체크리스트 쿼리 플래너&lt;/a&gt; 같은 문서 뒷부분의 쿼리 플래너의 수동 제어에 대한 자세한 지침을 제공한다.</target>
        </trans-unit>
        <trans-unit id="c132fc8253da62def423dbfbc9e5cc8f879698fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#dbstatpath&quot;&gt;description above&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;#dbstatpath&quot;&gt;위의 설명을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc1406da130a4d62c75c39d9868f5406eb3bf35f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6719884b2a74c479ea6999c99dbf311d703b384" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://sqlite.org/'about.html'&quot;&gt;About SQLite&lt;/a&gt; for an overview of the SQLite software and what it does and how it is different.</source>
          <target state="translated">SQLite 소프트웨어에 대한 개요와 그 기능 및 기능에 대해서는 SQLite &lt;a href=&quot;https://sqlite.org/'about.html'&quot;&gt;정보를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a83862c5e73732d34809bc526149b8874a0b009" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt; for a full discussion of the limits of SQLite.</source>
          <target state="translated">SQLite의 한계에 대한 자세한 내용은 &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5702be68fafd67a2aafc342a3e205c709913ea24" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67c5fd71325238ec1a4341afb9b6cba9315dbef4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;sharedcache&quot;&gt;SQLite 공유 캐시 모드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61a08f389a25b863d0fca5015a2885ff6fd5c8cd" translate="yes" xml:space="preserve">
          <source>See Also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="93901f63e20a4a7a74fbfdbc37b4075a185c71c6" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;../backup&quot;&gt;Using the SQLite Online Backup API&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../backup&quot;&gt;SQLite는 온라인 백업 API를 사용하여&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3af600b61585b909b60b4a99e040268e0c2a856f" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;../sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../sharedcache&quot;&gt;SQLite는 공유 캐시 모드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c1b1d19f5868cf4d3018fb518dcfa6d87cc98cd" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;../unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../unlock_notify&quot;&gt;SQLite 잠금 해제 알림 기능 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7616c5088158f54a825d33709957167b8a16116d" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;backup&quot;&gt;Using the SQLite Online Backup API&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;backup&quot;&gt;SQLite는 온라인 백업 API를 사용하여&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f41977d4fff20685334fca06b182777534d39401" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;sharedcache&quot;&gt;SQLite는 공유 캐시 모드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f9e82ef52e9fb93669665e75ad01f2483ef4742" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unlock_notify&quot;&gt;SQLite 잠금 해제 알림 기능 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="432cb254f15763b7805bdd86025f5f8cf43aec8f" translate="yes" xml:space="preserve">
          <source>See above.</source>
          <target state="translated">위 참조.</target>
        </trans-unit>
        <trans-unit id="383b0d124cc39b4f92b719a490622adb9db1929b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="588a701bb21ea6498fe1cee5a08846f3a6f8999b" translate="yes" xml:space="preserve">
          <source>See also lists of &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;, &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt;, and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; , &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 목록도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c2ab778a085857c109eb7e8e5a5333d9b57f676" translate="yes" xml:space="preserve">
          <source>See also requirements H35180 and H35210 above.</source>
          <target state="translated">위의 요구 사항 H35180 및 H35210도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a69045200fe6eb4eefb6543d32d1c3986dee3e7a" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_commit_hook()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_rollback_hook()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_commit_hook ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_rollback_hook ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ee912df6c5ce3441a9860f1d9730f7218ccc4b5" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26d056bc4928cd96df481ba3bb3da36ee6f31042" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db4a83343835929e5d813cffa0b4f2b9793757ab" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;cintro&quot;&gt;Introduction To The SQLite C/C++ Interface&lt;/a&gt; for an introductory overview and roadmap to the dozens of SQLite interface functions.</source>
          <target state="translated">수십 개의 SQLite 인터페이스 함수에 대한 소개 및 로드맵 &lt;a href=&quot;cintro&quot;&gt;은 SQLite C / C ++ 인터페이스 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="339862dc13bc1d57d7288f6688c75379763064fe" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;commit_hook&quot;&gt;sqlite3_commit_hook()&lt;/a&gt;, &lt;a href=&quot;commit_hook&quot;&gt;sqlite3_rollback_hook()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;commit_hook&quot;&gt;sqlite3_commit_hook ()&lt;/a&gt; , &lt;a href=&quot;commit_hook&quot;&gt;sqlite3_rollback_hook ()&lt;/a&gt; 및 &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a86c99c5bddb628e2b84fed31d31db9e2daeedae" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9551bbf4b06565a29addd67ff920566d10532258" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b61abea4b86316c9bf1e59bfa90fae500f63cc2b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e8ceb2d0a12e5d383c6c33d1d4332e5b5c058b2" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt; pragmas.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt; pragma 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ff63025923714eccfd1fedacdb3cbe9372c3a93" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;hard_heap_limit pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;hard_heap_limit pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="303adc506bf547b9de95bc776aebd335c64bd8fc" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; command which does most of the checking of PRAGMA integrity_check but runs much faster.</source>
          <target state="translated">대부분의 PRAGMA integrity_check 점검을 수행하지만 훨씬 빠르게 실행되는 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48f81b34f529fa4aeb1d561e1f3508b8413b778f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a25a2daadf8d2856a4719203849a4c0af3fabe6d" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c007784e950bb7f56540883b26bce1ca576b693" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;quirks&quot;&gt;Quirks, Caveats, and Gotchas&lt;/a&gt; of SQLite.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;quirks&quot;&gt;Quirks, Caveats 및 Gotchas&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94811ce2c3eb27494bcc158d862a7722c04a876e" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="22db3f40cf05b62413d309725844e929dbbe0d0d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;extended result code definitions&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;확장 된 결과 코드 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5824dbe2a36217f98b17445aa829e98c24d78c0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;file control opcodes&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;파일 제어 opcode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a888d72c2aa71ea4f9e6a712bc7addf37488e84a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e55f94f79f49c504145ad61691b8c42ba593cff9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6713e8fdaa1ea389a2f09e3a9c9374683ab6d6b0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11dc488cf1e9db5102b28629a96e4392dc29104c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c6912b2b4045c6f070e0edaa93c0875be5fd821" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close를 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3f665ed626f2acf9c339d54e23c6812da36531" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c57adf1e621a68c73c17c8b0ecd787edffeb3799" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e289aacb066a0de1940f21ad59b6642609ced4a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed16()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed16 ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="513ba9fc0134937d2763a01c62173350a81c3bde" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf131b5c38b078229e14995e1d46c942918a4628" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="389c907363aca1a027a67a5b885a2319a4ec35ed" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_data_count&quot;&gt;sqlite3_data_count을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0afc966be42fd6b30d673383499cb0059d1ed149" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_db_release_memory&quot;&gt;sqlite3_db_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81c3b36cbd377bb3ed1664b49ec3d43a5bc80371" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10a7701e6ed3e748294878d5accec5c9e67c8652" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_drop_modules&quot;&gt;sqlite3_drop_modules ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c38544cc50a3f638d9d29eb83eea228ba0b685b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;SQLITE_VERSION ()&lt;/a&gt; 와 &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58d0868f2357d36a8bd2095b2af1bb408179b89d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_held()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_notheld()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_held ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_notheld ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a95fa8aab0e3bfa1d373ea225784189d0d07162" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="894a2c673c7c3998c0146ab1462bd48997eeefeb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension ()&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c349eaf02fbc75040833b27273fe78ce351a8517" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4abfc13135b30c5ca35737473e62ae50fbba518" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74b0b0a73811f9aef63fb1988c2a0ccf696926fc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64b2c6cde7a64226fbe2ef3634045cd57dde9aaa" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20e4f725a3076fc6b2bb57f870226dcb7c2cd741" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="435b8c7f1343e259185da08da01ab1604658c57c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de67037e66e6bc2405fafd89b02748ccb563c8f4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="577203775c48a36ecdbe0e166cc73a6f94c49525" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../gencol&quot;&gt;gencol.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../gencol&quot;&gt;gencol.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81cf66782a01b719b906500422d08c6d8d672682" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang&quot;&gt;lang.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang&quot;&gt;lang.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c778a0f903e6e7a229a74dcc043ab7ce222f8e91" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang&quot;&gt;lang.html&lt;/a&gt;&lt;a href=&quot;../lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang&quot;&gt;lang.html &lt;/a&gt;&lt;a href=&quot;../lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a1623c388195369765189e361912596c2725840" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cca5d37155aa556de6dfac0b27a0e25fc7f06d7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;프라그. HTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a6be53babfb0698dca91e0931b8046114c3258d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52bb34faf16293e7bf50504a84a6781db371ee0f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a14f661ac8c092f4fc1d99fc6d9d99e0d8ec786" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_conflict&quot;&gt;lang_conflict.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_conflict&quot;&gt;lang_conflict.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c07322809e26e45be23a95893f749e03af5c5ed5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="938b9621b107714962482883b255c3d80c08b6e7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15598ecd618474aabf3591017c513af8de8a6a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0485f89bf00139a21000442b6a6990659cb64b16" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="66948fd5b0afaf1cdc01aa29ecea4c1bfedab9de" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 및 &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee139ad90928eace8c30779bd5b6becd4f09c01d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79cd4e2359b15e6acab9aede873d664f2ede5a75" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2dfcbfb2abe59925659cc429708c6aec7eb406e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="658fb74ef352e297b395f96f857ceb7d3c615e2b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13d94bc3fd2a819178c3e4749e7aa371e596de86" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f527f9debd0e925c5e233506e62bf945cd29ee28" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_indexedby&quot;&gt;lang_indexedby.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_indexedby&quot;&gt;lang_indexedby.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21b664cff26300df1357262d6ec594fb9ee3555c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91b6c24c68f47aa751a5b5b8df600dcca07d313d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1033e8985d4463e32f19095fed06fce8ea5476c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9218f7d1d52e1191bd9b8fb6db8d70bf8dc438f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="466d46beb84c6c8963a2f748f70f326309fffab5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4aef55367a00e308dff9639c75772858c63ff83" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56e9b6723fb1585f18d7b60fce22ac17b792e417" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d13d914d08b8f92116b29032480e38cbe265479" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdd1d8b761b061d5aeaf839bfb496966e3e11c8e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="716c85dad4326320b2465878481f19b320bc4abf" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9246cf2807990b095780ac9e1b0dd561919984" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f43b3a3c761c07b37c7c96d59a19f91da1c40c6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59cd8724dea12b8ea965ab667c74e2d1d4fb024b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f03712d7de35eafa06ad69d4f67d162931ceee8e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="344cad8b96fcafcf74d42ebb4e8917a07994e94e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cafbbb26b01fe4aad5518dd3d8329918a47b638c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="194bd03307aa26e18f55046fce3dc35e20b6f469" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;&lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html &lt;/a&gt;&lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bbc01924ed08271e9d7d2fafae0daf0758d4c29" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90a9a8514c72ec12bafb541c92e76fe75343369a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e20ee80f88a596c72e3b5175803d94c62b49d45" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="487a9f7edcc9acbd36e71269b10f3dabc3570792" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb4119b7d69b4e6da177cbf6ff9c4d155ae67444" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;프라그. html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="695ecd24fe66b529919da4afdf535e5125baa96e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0014eee39d17cd320cfc0ffbaab392f9f613f85" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29fadfcd5bcddd556613ead0e99dda8fc7fba83b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92b532e0d0d9df2c59df298af30c18a7e1da5dfe" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c013a0edc28859aa3e70e3276bdce16a070ed083" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a7eea93b457a57fc7fe1137ef59827626192c5a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="c4c2bc470b47131356a55eedacd462eb96e84418" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1fe4145cb7c50a0d418d258d06542a1f8cb0dd39" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt;, &lt;a href=&quot;../lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../printf&quot;&gt;내장의 printf ()&lt;/a&gt; , &lt;a href=&quot;../lang_corefunc#printf&quot;&gt;printf와 () SQL 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53567bfae3ebbf8bd0c18510f50128b0fee6e144" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="907bef21249483a496207cb807a74d758d2d3c63" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c1aadec23594d958a843556680b17a72abac74b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f45be66a2c5bcb3bc142d2c447ea57f0f20e31c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37c010f71fba70b74109bbdc2b1ce08d14015c48" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close를 ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dbeda6bcc23b238fd884c3cfaafcc8fb5f1870" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34c05c2c7478ddfc9595328b9ea47d96e84f4152" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b21a0b7337431e9ee24e69d231fe8302762a853" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;c_abort_rollback&quot;&gt;extended result code definitions&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;c_abort_rollback&quot;&gt;확장 된 결과 코드 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfe354170b5e869c7270b91ade687416a54c0183" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;file control opcodes&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;파일 제어 opcode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37196415e76fa9d675c871c64b90e815741d0f92" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed()&lt;/a&gt; and &lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed16()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed ()&lt;/a&gt; 및 &lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed16 ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="879f7e7ea46313e2ea71652b9ca7565db57df9c6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="319399ff5f7d4c689210338dddef1fb99518d24d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b23baf151295ad1d1fe5328bd71961f497879ab" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8661ec8b737499d91726c5f2f8d9c2e2296d1bc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;data_count&quot;&gt;sqlite3_data_count을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e1099949ad00bb15eb69a605f4b4b3bbfd1aff7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;db_release_memory&quot;&gt;sqlite3_db_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bda4dfc70b5f71949880b44f021fef0f7b01aa87" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb201238a04d02eb3cb27c3d4ccc509df3614a14" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;drop_modules&quot;&gt;sqlite3_drop_modules ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2366873b192e78c89709e7d18ff2db2dcc967a55" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;gencol&quot;&gt;gencol.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;gencol&quot;&gt;gencol.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="524073d1a4577e6b594022dd278f36bd2dba0d4a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang&quot;&gt;lang.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang&quot;&gt;lang.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bc17dac7d9752b7811c2a93ab58e831060d9b9d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang&quot;&gt;lang.html&lt;/a&gt;&lt;a href=&quot;lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang&quot;&gt;lang.html &lt;/a&gt;&lt;a href=&quot;lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e55f6b8a291e9bc6872ef07f19648c06a63c7f96" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html#raise&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html # 인상 &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html 번호 simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3094ad1d98461c25d851d9b58614f8484829a717" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html#fromclause&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html # fromclause &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a742de555ecf28aa329a8d657a04db2888df41b9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_update.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # &lt;/a&gt;compound lang_select.html # &lt;a href=&quot;lang_update&quot;&gt;compound &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_select.html .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85abca3267512af73ec8afacb8584e803d672ab2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_update.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # &lt;/a&gt;compound lang_select.html # &lt;a href=&quot;lang_update&quot;&gt;compound &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_select.html .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14529eb0437c823ab68b15a8cd5ba3d6d655b2d3" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_update.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # &lt;/a&gt;compound lang_select.html # &lt;a href=&quot;lang_update&quot;&gt;compound &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_select.html .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # 구문&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="199a3a4fc6414fdf6ed7493a3c4733ad2cdbdb41" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html#booleanexpr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html # booleanexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caee65c71137c00f3261816c349b1186b87ab07f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d5357ce486345b38e495fdd052bc12b972eb613" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html#altertabaddcol&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html # altertabaddcol &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df7e64b5e3be337fc1f98f552de8d797b4c2b99a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html#altertabaddcol&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html # altertabaddcol &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a5b6f8bb5171cdb36ccd5c1ba734c2c233150b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_conflict&quot;&gt;lang_conflict.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;lang_createtable.html#notnullconst&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_conflict&quot;&gt;lang_conflict.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;lang_createtable.html # notnullconst&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6fcd1bfb338ad16eab298ffc4c9d868843b9b21" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a36b3fb23e6333db428ab6ad00263be2d938abe" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6b9466ba508d0dbec4f6c657f9fbfd7e620fc37" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a54b9974971120efa52636fcabe0715b49415a8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2cb6c7d068dfff53d11c81dd36fe7afde23d11e5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0913f10eba8984cde458a594e9723dae1e7b43d4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html#primkeyconst&lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html#uniqueconst&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html # primkeyconst &lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html # uniqueconst &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c7d4103ad522f08124a6ecef11b7bef6bb05216" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e9835eae374451ebfe2dabdb26ce73fec9a591b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d81d89904dc49fa50fb5551880967e2b9a7226cb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html#primkeyconst&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html#uniqueconst&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html # primkeyconst &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef &lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html # uniqueconst&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5aed25ab420fb0098c44d0bf5304a4aa707b088f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c514627329ad2c33195dc084716f51f489e5370e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e08547629c50834603a3c7451218441b495de5f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_indexedby&quot;&gt;lang_indexedby.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_indexedby&quot;&gt;lang_indexedby.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cba534e77f5dd456a33da03494144a81d39264cc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfa4d667a255f0c6828f6b1f4d098bfa8323d6e2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9614960e8904f53093287bbe50e05a997ac3824b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9b4f140896556a1fc2adbe8ac95c3f7dc29ba8a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eef9b3d74c59deea364b6f6ac6f20759d658b7f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c39b25e28ca93d32b847b9c1af840e472af33477" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a07a8a7f1e0538e7658544150917395127562b6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6d60ea259f137afddc03af15fbdb1094689ece4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="724cccf74d74960b6796259fcacc12e153ae3f1a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f80c5c57cfc045f570327a845f8127410c55f865" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76e8ddefbc493145192fc193cef9e039c65a902e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="863b8e5b897ce238b67c5c8556989e2766293313" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf4b794db9d56879de07eb5f16a8bc2477ca90d4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702f2b35823dcfd93d045f7d778af2c45120abe7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62511da10fbf7f958f155307ba6d4d102f35f3be" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html#booleanexpr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html # booleanexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="450581ca6e9de72c74dcb192b37f5747276658f1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_expr#litvalue&quot;&gt;lang_expr.html#litvalue&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_expr#litvalue&quot;&gt;lang_expr.html # litvalue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae501b11617c0c13b2d3f762254b4ff760b36123" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d27e4055359a8aeac2ce66818352ec73c032ea4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7bb5ce5fe2a8f6a8de65bf4e7bd8b65d204d6093" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;&lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html &lt;/a&gt;&lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="076fe51a7e12da80f3c9d8927a2ca4548526aa30" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9f5995b5a48f0fca91e5e282ac6950660e6528d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d233e7ebdff319d51e7bd5e01dba623d32fa9ca0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # compound&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbbded1021d4435d1532c9af272fa7bccfd9c1d0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e964459d5f1a2e61a2e2cf50351a352d90c8e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="600ef78a6f3fb8794c7d469e740f494486a2ac18" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7f048f330189613480493245819630da7093938" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_update#upfrom&quot;&gt;lang_update.html#upfrom&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_update#upfrom&quot;&gt;lang_update.html # upfrom&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ea152fe6b3f2ae351dd12abd4e8bbd78773fa59" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html#raise&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html # 인상 &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select .html 중에서 # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b469ebdf9c6c7fd0d09e8c5ea21cd29a3c4e951" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html#fromclause&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html # fromclause &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select .html 중에서 # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb12fe633d07848eb5eb066e9d5b752ffef1d5c2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bed845bd614c9a71113bf4e2612d286c51c5869c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e12f9a6f89dbcc84809953e2fd797afd11b684ab" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # 구문&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a66f16d59067e2dbd5b05e42ceffc5ed1382738" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html#primkeyconst&lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html#uniqueconst&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html # primkeyconst &lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html # uniqueconst &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10943101e04a10c530372cbdc34663b3698984dc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9086346182d6b8670bc03f1e0367b327298a39af" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73bb61ec2320cac51957bb5504dbbbfced735f05" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d881dae8fea8469aae36dd2ee790aadd7154e19f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11284ab305581840484673ba82b0814730899f19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eb5bc217d7c409f9004989bbcff9c4c5cf371c2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa9202aad9353cf3bd304d5cebf941f8826269aa" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt;, &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt;, &lt;a href=&quot;libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;, &lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; , &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; , &lt;a href=&quot;libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; , &lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;SQLITE_VERSION ()&lt;/a&gt; 와 &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59473a97c323cc840c551bb609b5c7d0085ba6eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_held()&lt;/a&gt; and &lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_notheld()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_held ()&lt;/a&gt; 및 &lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_notheld ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="630f877a63f0639718e0dd30c5ba43ed3ce847e4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;, &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt; , &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e32027cc4318d132c8299361aadd44d5d68a5d39" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;, &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt; , &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4db38cc313bd0bbfdf49c1b12a83a1dee3351e3" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Clear&quot;&gt;Clear&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Clear&quot;&gt;클리어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5545504df0c88112cd5943b39942072e292d1b27" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Destroy&quot;&gt;파괴&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20c38d168152c392bc03b5b47997e5daa1c0d099" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08083583312e5bf15079e8c8852f8fa2944302ac" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;, &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt;, &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; , &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt; , &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="728b62ca2d8ad20f62ae93f93571e44c2d32c79b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt;, &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt; , &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fd951d3cf17be16c77767dc1e177d397520dea6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekGt, SeekGe, SeekLe</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekGt, SeekGe, SeekLe</target>
        </trans-unit>
        <trans-unit id="d6d2c334da88e15e756581a4f59c5b04ba796944" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekGt, SeekGe, SeekLt</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekGt, SeekGe, SeekLt</target>
        </trans-unit>
        <trans-unit id="463d18a76e981873861ffff7fe5e29e0c6efda87" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekLt, SeekGe, SeekLe</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekLt, SeekGe, SeekLe</target>
        </trans-unit>
        <trans-unit id="5e40d5e71843bb61f4bcfed5badcd97abfd6de6d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekLt, SeekGt, SeekLe</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekLt, SeekGt, SeekLe</target>
        </trans-unit>
        <trans-unit id="a7f677a2db2a47580eeed83b42a807730b2d65e8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;, &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; , &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3e78d904f537e5ecc229d2e4161074c489fc983" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Function0&quot;&gt;Function0&lt;/a&gt;, &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Function0&quot;&gt;Function0&lt;/a&gt; , &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27fe557b8f91eb0f3354ec57fe69933ee8436f35" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#InitCoroutine&quot;&gt;InitCoroutine&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#InitCoroutine&quot;&gt;InitCoroutine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cea6a531330c212ca3ca25d87fa43558d171705c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;</source>
          <target state="translated">참고 항목 : &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab8929f50dfeea96d663b01dc70be8c6ea741b4c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt;, &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;. SeekGe</source>
          <target state="translated">&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt; , &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; 도 참조하십시오 . 찾기</target>
        </trans-unit>
        <trans-unit id="df9b249fadb76a9e89f33c8e160d939f3e2edb65" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#SeekHit&quot;&gt;SeekHit&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#SeekHit&quot;&gt;SeekHit&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77125e42082bd4063983bc366f2a58ec8989ce3d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;, &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; , &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42804456c026cdba0e420c9f8f25e7f6180f2cc2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;, &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; , &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="585491e299c7017859c50fd2fe8c2f25dc1e9732" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;, &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; , &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4168a3bf16312be37846589fb27785a113af6811" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Prev&quot;&gt;이전&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c516f46aa712315eea6584868cd627c02de7056" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;, &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; , &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f01472d4da0f8e936c195c67175f791d08d0adbf" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d54723288e675ac0abb24e0dd779375fca23df6b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bfa2363ed594f2b2eede2b270349dfc67d7ebc18" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # syntax&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a4951221a904acb6ba86986765efc2037a09378" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;printf&quot;&gt;내장의 printf ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf와 () SQL 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99bd38c265a6fb23dc830f7fe8c080eded5d7a07" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98b434bc0d8b8d185283486c42d9be672854146f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; and &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; 및 &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7299f9082103db8b34938e68ec91bd133f202916" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension()&lt;/a&gt; and &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension ()&lt;/a&gt; 및 &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension ()&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fa3c9ecf5456096c4af70cc1a45db8215c53ecad" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81c9581d614ee93295a05913a13ce83a1c537800" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51bddd2f47aedb88c82ed00196f1d5f18d63b931" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5f9c8eaf62fde3d86c43f634a7ab02bd2fa6122" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0933bf0a406419507f269f3297ab20733c0130b5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="673270029c9264ee605b8c3d4c2fd772ac5ed2ec" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7a6a573f1a49c137144c2c0c0b973878be6af5b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b9de33ebd0cee270413e31ceb4bf9982bf25845" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">SQL 함수 &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; 및 &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; 및 &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83dccf87582bc1362c408c238feac4693c82e492" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">SQL 함수 &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61cca4e5d339d369ec47f24cb61df5080a8fe143" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f095aa19ffa800ceddf0ec91e83f4521ad7e3e5" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;../uri&quot;&gt;URI 파일 이름&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14bd56e01493d3e179ad29ee876d123ae68f7d39" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;assert&quot;&gt;Use Of assert in SQLite&lt;/a&gt; document for additional information about how SQLite uses assert().</source>
          <target state="translated">SQLite가 assert ()를 사용하는 방법에 대한 추가 정보 &lt;a href=&quot;assert&quot;&gt;는 SQLite에서 assert 사용&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7c31bb847b7fb9dd4bac9cc5dd5dc1c96846800" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT documentation&lt;/a&gt; for detailed instructions on what AUTOINCREMENT does and does not do in SQLite.</source>
          <target state="translated">AUTOINCREMENT가 SQLite에서 수행하는 것과 수행하지 않는 것에 대한 자세한 지시 사항 은 &lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53b783989abda8014ea3d71299fadcaac3ac76a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;datatype3&quot;&gt;Datatypes in SQLite Version 3&lt;/a&gt; document for a detailed discussion of the type system in SQLite.</source>
          <target state="translated">&lt;a href=&quot;datatype3&quot;&gt;SQLite&lt;/a&gt; 의 유형 시스템에 대한 자세한 내용은 SQLite 버전 3 의 데이터 유형 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b929f22f98901beb9b1139bf55e5ff321f37875f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; document for instructions and hints on how to compile the program shown above.</source>
          <target state="translated">위에 표시된 프로그램을 컴파일하는 방법에 대한 지침과 힌트는 &lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일&lt;/a&gt; 하는 방법 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d23d8904a4dd8b2f59b61ec1f1d5eb8f80e47737" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information on aspects of using SQLite in a multithreaded environment.</source>
          <target state="translated">멀티 스레드 환경에서 SQLite 사용에 대한 추가 정보 는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a87fd9fe2045f5442c46fbc8912602fdbac0e8ba" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30f1bf85315b67413bef1d018f3d407e1c5b8c20" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86902a781e00345ab7ead57f5c2f261448269986" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;vtablist&quot;&gt;list of virtual tables&lt;/a&gt; page for a longer list of actual virtual table implementations.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;vtablist&quot;&gt;가상 테이블의 목록&lt;/a&gt; 실제 가상 테이블 구현의 긴 목록 페이지를.</target>
        </trans-unit>
        <trans-unit id="bd6efac597cb0708970fe4961b56a3edc46475fe" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;whentouse&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; document for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;whentouse&quot;&gt;SQLite에 적절한 사용&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07ba693c1bca5dde244a27275e6109ebcc9602e4" translate="yes" xml:space="preserve">
          <source>See the separate &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; documentation for the additional trailing syntax that can cause an INSERT to behave as an UPDATE if the INSERT would otherwise violate a uniqueness constraint. The &lt;a href=&quot;lang_upsert&quot;&gt;upsert clause&lt;/a&gt; is not allowed on an &quot;INSERT ... DEFAULT VALUES&quot;.</source>
          <target state="translated">INSERT가 고유 제한 조건을 위반하는 경우 INSERT가 UPDATE로 작동하게 할 수있는 추가 후행 구문에 대해서는 별도의 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; 문서를 참조하십시오 . &quot;INSERT ... DEFAULT VALUES&quot; 에는 &lt;a href=&quot;lang_upsert&quot;&gt;upsert 절이&lt;/a&gt; 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="939683e9d52824a9f73508cf71bd83e60abff90a" translate="yes" xml:space="preserve">
          <source>See xPhraseFirst above.</source>
          <target state="translated">위의 xPhraseFirst를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a932238dbfaf0b21024ff5809159c0de781840d" translate="yes" xml:space="preserve">
          <source>See xPhraseFirstColumn above.</source>
          <target state="translated">위의 xPhraseFirstColumn을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f853fa8d7ff147b89090825d00dc78b2f44a321" translate="yes" xml:space="preserve">
          <source>SeekEnd</source>
          <target state="translated">SeekEnd</target>
        </trans-unit>
        <trans-unit id="9fadfc9b512132149df920b10f206da2333bd9fa" translate="yes" xml:space="preserve">
          <source>SeekGE</source>
          <target state="translated">SeekGE</target>
        </trans-unit>
        <trans-unit id="1087f36e7b18281af36dad7cdbb8cd08b7115d15" translate="yes" xml:space="preserve">
          <source>SeekGT</source>
          <target state="translated">SeekGT</target>
        </trans-unit>
        <trans-unit id="460ea4a32fd1274da2db98168e01568ac9ce63a6" translate="yes" xml:space="preserve">
          <source>SeekHit</source>
          <target state="translated">SeekHit</target>
        </trans-unit>
        <trans-unit id="0b4f0d008f842f314db6efb3fa8c1e4f9ad7e37b" translate="yes" xml:space="preserve">
          <source>SeekLE</source>
          <target state="translated">SeekLE</target>
        </trans-unit>
        <trans-unit id="5c9e6758b219b2706a95d7da88c60ef0eba6fe03" translate="yes" xml:space="preserve">
          <source>SeekLT</source>
          <target state="translated">SeekLT</target>
        </trans-unit>
        <trans-unit id="141e7ed653901b0f647fda720472fc6667150f0c" translate="yes" xml:space="preserve">
          <source>SeekRowid</source>
          <target state="translated">SeekRowid</target>
        </trans-unit>
        <trans-unit id="c6ed6b18512dd3401d381c337b03a01488f90762" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Interior Node Format</source>
          <target state="translated">세그먼트 B- 트리 내부 노드 형식</target>
        </trans-unit>
        <trans-unit id="cc806c94f6fb1d331e8fb663d9d4f7e22793356b" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Leaf Node Format</source>
          <target state="translated">세그먼트 B- 트리 리프 노드 형식</target>
        </trans-unit>
        <trans-unit id="fe4aff672a9c860addca0cf569e240d57055e4c7" translate="yes" xml:space="preserve">
          <source>Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree for each row in the %_segdir table (see above). The root node of the segment b-tree is stored as a blob in the &quot;root&quot; field of the corresponding row of the %_segdir table. All other nodes (if any exist) are stored in the &quot;blob&quot; column of the %_segments table. Nodes within the %_segments table are identified by the integer value in the blockid field of the corresponding row. The following table describes the fields of the %_segdir table:</source>
          <target state="translated">세그먼트 b- 트리는 접두사 압축 b +-트리입니다. % _segdir 테이블의 각 행마다 하나의 세그먼트 b- 트리가 있습니다 (위 참조). 세그먼트 b- 트리의 루트 노드는 % _segdir 테이블의 해당 행의 &quot;루트&quot;필드에 블롭으로 저장됩니다. 다른 모든 노드 (있는 경우)는 % _segments 테이블의 &quot;blob&quot;열에 저장됩니다. % _segments 테이블 내의 노드는 해당 행의 blockid 필드에서 정수 값으로 식별됩니다. 다음 표는 % _segdir 테이블의 필드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="982d848bdbaf7ffda27f7d8aca752c82359ccf6f" translate="yes" xml:space="preserve">
          <source>Segment btree</source>
          <target state="translated">세그먼트 btree</target>
        </trans-unit>
        <trans-unit id="40bf8b12088788ad70716eb1793e4cf249c09782" translate="yes" xml:space="preserve">
          <source>Separate INTEGER and REAL affinity</source>
          <target state="translated">별도의 INTEGER 및 REAL 선호도</target>
        </trans-unit>
        <trans-unit id="ba899678ef1e0fdd6b5eb799ee7abdd42cf175bf" translate="yes" xml:space="preserve">
          <source>Separating a database from its journal</source>
          <target state="translated">저널에서 데이터베이스 분리</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="841936f1610c7b00e43fa53fbf75fb9b11abf32f" translate="yes" xml:space="preserve">
          <source>SequenceTest</source>
          <target state="translated">SequenceTest</target>
        </trans-unit>
        <trans-unit id="e12fccff7a8e896ad7cfa282736ffc4187cd7eaa" translate="yes" xml:space="preserve">
          <source>Serial Type</source>
          <target state="translated">시리얼 타입</target>
        </trans-unit>
        <trans-unit id="307ffd15fed4aa8193a8701f2970a48ccbc74bb4" translate="yes" xml:space="preserve">
          <source>Serial Type Codes Of The Record Format</source>
          <target state="translated">레코드 형식의 시리얼 타입 코드</target>
        </trans-unit>
        <trans-unit id="b61faef97a33774dc6199c619a4461fc18672af3" translate="yes" xml:space="preserve">
          <source>Serial type</source>
          <target state="translated">시리얼 타입</target>
        </trans-unit>
        <trans-unit id="44bc81d8890afcfb324491bf1c0f95cb6563d3cc" translate="yes" xml:space="preserve">
          <source>Serialize a database</source>
          <target state="translated">데이터베이스 직렬화</target>
        </trans-unit>
        <trans-unit id="90c4f08f792523112df74bc852026385bd4f8127" translate="yes" xml:space="preserve">
          <source>Session Object Handle</source>
          <target state="translated">세션 객체 핸들</target>
        </trans-unit>
        <trans-unit id="67e2e54aa75dbe4ba2529dc4e44d334d5c33427e" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">이 함수를 사용하여 작성된 세션 오브젝트 는 첨부 된 데이터베이스 핸들이 자체적으로 닫기 전에 &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 함수를 사용하여 삭제해야합니다 . 세션 객체를 삭제하기 전에 데이터베이스 핸들을 닫으면 세션 객체의 &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 를 포함하여 세션 모듈 함수를 호출 한 결과 가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36d7089db75a5bb06f2dd690097a4896b0ce0449" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">이 함수를 사용하여 작성된 세션 오브젝트 는 첨부 된 데이터베이스 핸들이 자체적으로 닫기 전에 &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 함수를 사용하여 삭제해야합니다 . 세션 객체를 삭제하기 전에 데이터베이스 핸들을 닫으면 세션 객체의 &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 를 포함하여 세션 모듈 함수를 호출 한 결과 가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea1b131b3c13e62fbcb2b7e1d8113240624fdfe2" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">첨부 된 데이터베이스 핸들을 닫기 전에 세션 오브젝트를 삭제해야합니다. 자세한 내용 은 &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8a0df1e5a24e2b0c00b060a82e0a73f3246a4f51" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">첨부 된 데이터베이스 핸들을 닫기 전에 세션 오브젝트를 삭제해야합니다. 자세한 내용 은 &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6adb93a894674d02e091209977b242c152440ac9" translate="yes" xml:space="preserve">
          <source>Set *pnInst to the total number of occurrences of all phrases within the query within the current row. Return SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">* pnInst를 현재 행 내에서 조회 내의 모든 구의 총 발생 수로 설정하십시오. 성공하면 SQLITE_OK를, 오류가 발생하면 오류 코드 (예 : SQLITE_NOMEM)를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="efdec671fc0ce8bcb4bdb00d3f437085821cf12c" translate="yes" xml:space="preserve">
          <source>Set A Busy Timeout</source>
          <target state="translated">통화 중 시간 초과 설정</target>
        </trans-unit>
        <trans-unit id="b1a0dded912756ecf2b97f232c897007421fbf5d" translate="yes" xml:space="preserve">
          <source>Set Or Clear the Indirect Change Flag</source>
          <target state="translated">간접 변경 플래그 설정 또는 해제</target>
        </trans-unit>
        <trans-unit id="3a493136e0eeea58ea401cab071add271017a5ae" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object</source>
          <target state="translated">세션 객체에 테이블 필터 설정</target>
        </trans-unit>
        <trans-unit id="732b690730c3e6587386dab945ec7951b556c520" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object.</source>
          <target state="translated">세션 개체에 테이블 필터를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1ac264a53518ed313b058a0a099912f2a35d826a" translate="yes" xml:space="preserve">
          <source>Set an upper bound on the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,N) setting that determines the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will use to aid with CPU-intensive computations (mostly sorting). See also the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; options.</source>
          <target state="translated">상부상의 바인딩 설정 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (DB, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; 한 것을 보조 스레드의 최대 번호를 결정하고, N)의 설정 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비가 문&lt;/a&gt; (주로 정렬) CPU 집약적 인 계산으로 처치하는 데 사용한다. &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92f46b19209e84ffdca742022b56dfdca2dfb583" translate="yes" xml:space="preserve">
          <source>Set register P1 to have the value NULL as seen by the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction, but do not free any string or blob memory associated with the register, so that if the value was a string or blob that was previously copied using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, the copies will continue to be valid.</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어에서 볼 수 있듯이 레지스터 P1을 NULL 값으로 설정 하지만 레지스터와 연관된 문자열 또는 블로 브 메모리를 비우지 마십시오. 값이 이전에 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy를&lt;/a&gt; 사용하여 복사 된 문자열 또는 블로 브 인 경우 사본은 계속됩니다 유효합니다.</target>
        </trans-unit>
        <trans-unit id="cd7e5b09719a46bb1ffbc4c18faade6d76d5478d" translate="yes" xml:space="preserve">
          <source>Set the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag. This prevents ordinary SQL statements from deliberately corrupting the database file. SQLite should be proof against attacks that involve both malicious SQL inputs and a maliciously corrupted database file at the same time. Nevertheless, denying a script-only attacker access to corrupt database inputs provides an extra layer of defense.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그를 설정하십시오 . 이는 일반 SQL 문이 의도적으로 데이터베이스 파일을 손상시키지 못하게합니다. SQLite는 악의적 인 SQL 입력과 악의적으로 손상된 데이터베이스 파일을 동시에 포함하는 공격에 대한 증거입니다. 그럼에도 불구하고 스크립트 전용 공격자가 손상된 데이터베이스 입력에 대한 액세스를 거부하면 추가적인 방어 계층이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="241b76cbed3f5655045e8aff832d7f03205ef4fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value</source>
          <target state="translated">마지막 삽입 Rowid 값 설정</target>
        </trans-unit>
        <trans-unit id="3a9eaa4fc5302f500031c0b5a5700811aa0eb0fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value.</source>
          <target state="translated">Last Insert Rowid 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5a5c894fd85a90ba517e62438c5aff9b40ab8cb2" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">SQLITE_DBCONFIG_RESET_DATABASE 플래그를 설정 한 후 &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행 하여 데이터베이스없이 스키마와 컨텐츠가없는 빈 데이터베이스로 데이터베이스를 재설정하십시오. 다음 프로세스는 심하게 손상된 데이터베이스 파일에 대해서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5453fe3bee790f9b36f9a933f54e5899bdab502e" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">SQLITE_DBCONFIG_RESET_DATABASE 플래그를 설정 한 후 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행 하여 데이터베이스없이 스키마와 컨텐츠가없는 빈 데이터베이스로 데이터베이스를 재설정하십시오. 다음 프로세스는 심하게 손상된 데이터베이스 파일에 대해서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61c4c40f9a1bb5c18ccdd11c74e4b4fffa0d66f4" translate="yes" xml:space="preserve">
          <source>Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll back any currently active btree transactions. If there are any active VMs (apart from this one), then a ROLLBACK fails. A COMMIT fails if there are active writing VMs or active VMs that use shared cache.</source>
          <target state="translated">데이터베이스 자동 커밋 플래그를 P1 (1 또는 0)으로 설정하십시오. P2가 true이면 현재 활성화 된 btree 트랜잭션을 롤백하십시오. 활성 VM (이 VM 제외)이 있으면 ROLLBACK이 실패합니다. 활성 쓰기 VM 또는 공유 캐시를 사용하는 활성 VM이 있으면 COMMIT가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d6cb86bbec6abe009ef2b13054a8bf71fb971e51" translate="yes" xml:space="preserve">
          <source>Set the default size limit (in bytes) for in-memory databases created using &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This is just the default. The limit can be changed at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;,N) or at run-time for individual databases using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt;. If no default is specified, 1073741824 is used.</source>
          <target state="translated">&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()를&lt;/a&gt; 사용하여 작성된 메모리 내 데이터베이스에 대한 기본 크기 제한 (바이트)을 설정하십시오 . 이것은 단지 기본값입니다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt; , N)를 사용하여 시작시 또는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어를&lt;/a&gt; 사용하여 개별 데이터베이스에 대해 런타임 시 한계를 변경할 수 있습니다 . 기본값을 지정하지 않으면 1073741824가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="866d8eaf3728a827f036375926469bd93bf88bea" translate="yes" xml:space="preserve">
          <source>Set the permutation used by the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; operator in the next instruction. The permutation is stored in the P4 operand.</source>
          <target state="translated">다음 명령어에서 &lt;a href=&quot;opcode#Compare&quot;&gt;비교&lt;/a&gt; 연산자가 사용하는 순열을 설정하십시오 . 순열은 P4 피연산자에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc497dd2e0254996f63fed1801e825a18a0d70e" translate="yes" xml:space="preserve">
          <source>Set the seekHit flag on cursor P1 to the value in P2. The seekHit flag is used by the &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode.</source>
          <target state="translated">커서 P1의 seekHit 플래그를 P2의 값으로 설정하십시오. seekHit 플래그는 &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f917c903736a886e2bae7dda91eb93f9fc5b88f2" translate="yes" xml:space="preserve">
          <source>Set up a process-wide &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">프로세스 전체 &lt;a href=&quot;errlog&quot;&gt;오류 로그를&lt;/a&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f899229bce65615b9a9aafe730afb3055fc1d664" translate="yes" xml:space="preserve">
          <source>Set up register P1 so that it will &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; to the coroutine located at address P3.</source>
          <target state="translated">이 때문에 이렇게 레지스터 P1 설정 &lt;a href=&quot;opcode#Yield&quot;&gt;수율&lt;/a&gt; 어드레스 P3에 위치하는 코 루틴에 관한 것이다.</target>
        </trans-unit>
        <trans-unit id="c422fe10a5573aa6ba7e50d9c77e20ca08878af0" translate="yes" xml:space="preserve">
          <source>SetCookie</source>
          <target state="translated">SetCookie</target>
        </trans-unit>
        <trans-unit id="01b3682b02999bc0d6273ad2e8a1ce7b60079442" translate="yes" xml:space="preserve">
          <source>Sets the &quot;fired&quot; flag to true.</source>
          <target state="translated">&quot;fired&quot;플래그를 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5f1906e535428a6ef107759522f33ae96d47ce23" translate="yes" xml:space="preserve">
          <source>Sets the default size of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; memory pool to N entries of SZ bytes each. This setting can be modified at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;) and/or as each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is opened using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자&lt;/a&gt; 메모리 풀 의 기본 크기를 각각 SZ 바이트의 N 개 항목으로 설정합니다. 이 설정은 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; )를 사용하여 시작시 및 / 또는 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; )를 사용하여 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 열릴 때 수정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8f949c67297579c935535017d3f831289e19ac6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; can cause the database to go corrupt if there is an operating-system crash or power failure, though this setting is safe from damage due to application crashes.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF를&lt;/a&gt; 설정 하면 운영 체제 충돌 또는 전원 장애가 발생하는 경우 데이터베이스가 손상 될 수 있지만이 설정은 응용 프로그램 충돌로 인한 손상으로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aefdd1b85748c7d4a0d551399e2edc72cd30afa6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; and then changing the database schema using DML statements can render the database completely unreadable, if not done carefully.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON을&lt;/a&gt; 설정 한 다음 DML 문을 사용하여 데이터베이스 스키마를 변경하면 신중하게 수행하지 않으면 데이터베이스를 완전히 읽을 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa000f3c0976d971f291c1208857c79532870ca" translate="yes" xml:space="preserve">
          <source>Setting The Result Of An SQL Function</source>
          <target state="translated">SQL 함수의 결과 설정</target>
        </trans-unit>
        <trans-unit id="1d4603c6597b76da3d906d68cccdecf5180cbe08" translate="yes" xml:space="preserve">
          <source>Setting The Subtype Of An SQL Function</source>
          <target state="translated">SQL 함수의 하위 유형 설정</target>
        </trans-unit>
        <trans-unit id="16955fa7b436cf8874edb738f171a4d0ef509182" translate="yes" xml:space="preserve">
          <source>Setting fullfsync on a Mac will guarantee that data really does get pushed out to the disk platter on a flush. But the implementation of fullfsync involves resetting the disk controller. And so not only is it profoundly slow, it also slows down other unrelated disk I/O. So its use is not recommended.</source>
          <target state="translated">Mac에서 fullfsync를 설정하면 데이터가 실제로 디스크 플래터로 플러시 될 수 있습니다. 그러나 fullfsync를 구현하려면 디스크 컨트롤러를 재설정해야합니다. 따라서 속도가 매우 느릴뿐만 아니라 관련이없는 다른 디스크 I / O도 느려집니다. 따라서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3eaa36d1b6e824ce1fa2d9dd603bd95da85fa485" translate="yes" xml:space="preserve">
          <source>Setting the automerge parameter to a non-zero value enables automatic incremental merging. This causes SQLite to do a small amount of inverted index merging after every INSERT operation. The amount of merging performed is designed so that the FTS3/4 table never reaches a point where it has 16 segments at the same level and hence has to do a large merge in order to complete an insert. In other words, automatic incremental merging is designed to prevent spiky INSERT performance.</source>
          <target state="translated">automerge 매개 변수를 0이 아닌 값으로 설정하면 자동 증분 병합이 가능합니다. 이로 인해 SQLite는 모든 INSERT 작업 후에 소량의 반전 된 인덱스 병합을 수행합니다. 수행되는 병합 양은 FTS3 / 4 테이블이 동일한 수준에서 16 개의 세그먼트를 갖는 지점에 도달하지 않으므로 삽입을 완료하기 위해 큰 병합을 수행하도록 설계되었습니다. 즉, 자동 증분 병합은 뾰족한 INSERT 성능을 방지하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="56f5ba775f4860afdbeef1efdf08d68cd3228bad" translate="yes" xml:space="preserve">
          <source>Setting the heap limits to zero disables the heap limiter mechanism.</source>
          <target state="translated">힙 제한을 0으로 설정하면 힙 제한 메커니즘이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d964c814943dd4cc633ef0ee8d21d48eb3735ca0" translate="yes" xml:space="preserve">
          <source>Setting this compile-time option prevents SQLite from being fully testable. Branch test coverage drops from 100% down to about 95%.</source>
          <target state="translated">이 컴파일 타임 옵션을 설정하면 SQLite를 완전히 테스트 할 수 없습니다. 분기 테스트 범위는 100 %에서 약 95 %로 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="00f0e8d6420ed50a38c6973317964bc318233512" translate="yes" xml:space="preserve">
          <source>Several new C-level objects are used by the virtual table implementation:</source>
          <target state="translated">가상 테이블 구현에서는 몇 가지 새로운 C 레벨 오브젝트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b7d1cf980e975f4a1d8be50f6af0bb46a6caa32" translate="yes" xml:space="preserve">
          <source>Several obscure, unrelated bugs were found and fixed while implemented the integer primary key change of the previous bullet.</source>
          <target state="translated">이전 글 머리 기호의 정수 기본 키 변경을 구현하는 동안 몇 가지 모호하고 관련이없는 버그가 발견되어 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="659f95a669a94f909d4f9c9e95d9d907e1cbadfa" translate="yes" xml:space="preserve">
          <source>Shadow tables are read/write by default. Shadow tables only become read-only when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. Shadow tables need to be read/write by default in order to maintain backwards compatibility. For example, the SQL text generated by the &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; writes directly into shadow tables.</source>
          <target state="translated">새도우 테이블은 기본적으로 읽기 / 쓰기입니다. 섀도우 테이블 은 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 설정된 경우에만 읽기 전용이됩니다 . 이전 버전과의 호환성을 유지하려면 기본적으로 새도우 테이블을 읽고 쓸 수 있어야합니다. 예를 들어 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 의 &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; 명령으로 생성 된 SQL 텍스트는 새도우 테이블에 직접 씁니다.</target>
        </trans-unit>
        <trans-unit id="19452421c69c545e0b50fcc00a18251f53c4e9f4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. But this might change in future releases of SQLite. Applications that care about shared cache setting should set it explicitly.</source>
          <target state="translated">공유 캐시는 기본적으로 비활성화되어 있습니다. 그러나 이는 향후 릴리스의 SQLite에서 변경 될 수 있습니다. 공유 캐시 설정에 관심이있는 응용 프로그램은이를 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e41d50ebd1af2b3254810c6333341257c85989e" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="translated">공유 캐시는 기본적으로 비활성화되어 있습니다. 그렇게 유지하는 것이 좋습니다. 즉,이 루틴을 사용하지 마십시오. 이 인터페이스는 기록 호환성을 위해 계속 제공되지만 사용하지 않는 것이 좋습니다. 공유 캐시를 사용하지 않는 것이 좋습니다. 공유 캐시를 사용해야 하는 경우 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 플래그가 있는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스를 사용하여 개별 데이터베이스 연결에 대해서만 공유 캐시를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="016f63b1afdc35c75766700d01c855e2a30457a4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="translated">공유 캐시는 기본적으로 비활성화되어 있습니다. 그렇게 유지하는 것이 좋습니다. 즉,이 루틴을 사용하지 마십시오. 이 인터페이스는 기록 호환성을 위해 계속 제공되지만 사용하지 않는 것이 좋습니다. 공유 캐시를 사용하지 않는 것이 좋습니다. 공유 캐시를 사용해야 하는 경우 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 플래그가 있는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스를 사용하여 개별 데이터베이스 연결에 대해서만 공유 캐시를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f477f800bdd5ba8c256608dea929d26bc988f65b" translate="yes" xml:space="preserve">
          <source>Shared libraries or DLLs can be used as &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; to SQLite.</source>
          <target state="translated">공유 라이브러리 또는 DLL 을 SQLite에 대한 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6f715dc89839324b877f33d62ebb39393f6ca50" translate="yes" xml:space="preserve">
          <source>Shared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back.</source>
          <target state="translated">데이터베이스 캐시 연결이 커밋하거나 롤백하여 현재 트랜잭션을 완료하면 공유 캐시 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="1a3aca3d24b83cc38a4313e0315e88bcb9c21c92" translate="yes" xml:space="preserve">
          <source>Shared-cache mode changes the semantics of the locking model in some cases. The details are described by this document. A basic understanding of the normal SQLite locking model (see &lt;a href=&quot;lockingv3&quot;&gt;File Locking And Concurrency In SQLite Version 3&lt;/a&gt; for details) is assumed.</source>
          <target state="translated">공유 캐시 모드는 경우에 따라 잠금 모델의 의미를 변경합니다. 자세한 내용은이 문서에서 설명합니다. 일반적인 SQLite 잠금 모델에 대한 기본 이해 (자세한 내용은 &lt;a href=&quot;lockingv3&quot;&gt;SQLite 버전 3의 파일 잠금 및 동시성&lt;/a&gt; 참조)가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3f80e6eca574b532dbb5d0c3d9a7766e7bf84a" translate="yes" xml:space="preserve">
          <source>Shared-cache mode is enabled on a per-process basis. Using the C interface, the following API can be used to globally enable or disable shared-cache mode:</source>
          <target state="translated">공유 캐시 모드는 프로세스별로 활성화됩니다. C 인터페이스를 사용하면 다음 API를 사용하여 공유 캐시 모드를 전체적으로 활성화하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f42662308d376fb67628511d59d090985566d2ae" translate="yes" xml:space="preserve">
          <source>Shared-memory files</source>
          <target state="translated">공유 메모리 파일</target>
        </trans-unit>
        <trans-unit id="c7114e495e770e3a02bbb164bf55e1f96da4aecc" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the left by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 정수로 지정된 비트 수만큼 레지스터 P2의 정수 값을 왼쪽으로 이동합니다. 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="1886429e3c21f6dfa5e69e0091250e86426fb4f9" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the right by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 정수로 지정된 비트 수만큼 레지스터 P2의 정수 값을 오른쪽으로 이동합니다. 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="62341f589b9d3a0d923d18a2b4e7f7f2edda894e" translate="yes" xml:space="preserve">
          <source>ShiftLeft</source>
          <target state="translated">ShiftLeft</target>
        </trans-unit>
        <trans-unit id="2310b475647d9a4e74a4f5d5a47bfb27340ee08b" translate="yes" xml:space="preserve">
          <source>ShiftRight</source>
          <target state="translated">ShiftRight</target>
        </trans-unit>
        <trans-unit id="c8723bf8dd0f924a9f0d00bc2ddb22a9562a76b1" translate="yes" xml:space="preserve">
          <source>Shifting a negative number.</source>
          <target state="translated">음수를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8f0ca083402d5eb462b696e15e581aaadbeb113a" translate="yes" xml:space="preserve">
          <source>Shifting an N-bit integer by more than N bits.</source>
          <target state="translated">N 비트 정수를 N 비트 이상으로 시프트</target>
        </trans-unit>
        <trans-unit id="37dcc04149816924636682bd712a1a49f1dcb38f" translate="yes" xml:space="preserve">
          <source>Shifting by a negative amount.</source>
          <target state="translated">음수만큼 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d224675e61816beeffff3a83b33b759da2cf9109" translate="yes" xml:space="preserve">
          <source>Short answer: A column declared &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; will autoincrement.</source>
          <target state="translated">짧은 답변 : &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY로&lt;/a&gt; 선언 된 열 은 자동 증가합니다.</target>
        </trans-unit>
        <trans-unit id="66f7bc664b9d82f0b84142732a02328bc0cdf8d0" translate="yes" xml:space="preserve">
          <source>Show ASCII-art abstract syntax tree diagrams using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLITE_ENABLE_SELECTTRACE, and SQLITE_ENABLE_WHERETRACE. Also provide the sqlite3TreeViewExpr() and sqlite3TreeViewSelect() entry points that can be invoked from with the debugger to show the parse tree when stopped at a breakpoint.</source>
          <target state="translated">&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , SQLITE_ENABLE_SELECTTRACE 및 SQLITE_ENABLE_WHERETRACE로 컴파일 할 때 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 &quot;.selecttrace&quot;및 &quot;.wheretrace&quot;명령을 사용하여 ASCII 아트 추상 구문 트리 다이어그램을 표시하십시오 . 또한 중단 점에서 중지 될 때 구문 분석 트리를 표시하기 위해 디버거에서 호출 할 수있는 sqlite3TreeViewExpr () 및 sqlite3TreeViewSelect () 진입 점을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="29bd1b65a367359ac801580f0f164ea797beea79" translate="yes" xml:space="preserve">
          <source>Show how many rows have changed on each table, but do not show the actual changes</source>
          <target state="translated">각 테이블에서 변경된 행 수를 표시하지만 실제 변경 내용은 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45c704a81c82ee8bb0729ae9984ab0b0befba88f" translate="yes" xml:space="preserve">
          <source>Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.</source>
          <target state="translated">순서도를 보여주고 테이블을 숨기면 계속해서 미스터리됩니다. 표를 보여 주시면 일반적으로 흐름도가 필요하지 않습니다. 그들은 명백 할 것이다.</target>
        </trans-unit>
        <trans-unit id="eadcf1db0ff39fb6bc0246ade4beb9b3e9027520" translate="yes" xml:space="preserve">
          <source>Show only differences in the schema not the table content</source>
          <target state="translated">테이블 내용이 아닌 스키마의 차이점 만 표시</target>
        </trans-unit>
        <trans-unit id="584527d924d04a23c5c08d9fd085c97f73f6da07" translate="yes" xml:space="preserve">
          <source>Show only the differences in content for TABLE, not for the entire database</source>
          <target state="translated">전체 데이터베이스가 아닌 TABLE의 내용 차이 만 표시</target>
        </trans-unit>
        <trans-unit id="c2688d3833edc37bfcee14b5515c2bff49005d0c" translate="yes" xml:space="preserve">
          <source>Show the SQL that would be run to carry out the archive operation, but do not actually change anything.</source>
          <target state="translated">아카이브 조작을 수행하기 위해 실행되지만 실제로는 변경하지 않는 SQL을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f2d6599ba5b081fd8b2869046769b3cd08250edc" translate="yes" xml:space="preserve">
          <source>Shun arrogance.</source>
          <target state="translated">오만을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="df3f4b6cc3b45148ff40b29aba7af47fbd10c1fd" translate="yes" xml:space="preserve">
          <source>Signed integer overflow. (Signed integer overflow does &lt;u&gt;not&lt;/u&gt; necessarily wrap around, as most people expect.)</source>
          <target state="translated">부호있는 정수 오버 플로우. ( 대부분의 사람들이 예상하는 것처럼 부호있는 정수 오버 플로우가 반드시 랩핑 되지는 &lt;u&gt;않습니다&lt;/u&gt; .)</target>
        </trans-unit>
        <trans-unit id="2e226f8ddc66c1a463dcf0a7c345c529980f966b" translate="yes" xml:space="preserve">
          <source>Silent &quot;d&quot; in words beginning with &quot;dj&quot;: djinn, Djikarta</source>
          <target state="translated">&quot;dj&quot;로 시작하는 단어에서 자동 &quot;d&quot;: djinn, Djikarta</target>
        </trans-unit>
        <trans-unit id="aada0dd0ffeee0e21804c55732d58986c7fd3694" translate="yes" xml:space="preserve">
          <source>Silent &quot;g&quot; in words beginning with &quot;gn&quot;: gnarly, gnome, gnat</source>
          <target state="translated">&quot;gn&quot;으로 시작하는 단어에서 무음 &quot;g&quot;: 으악, gnome, gnat</target>
        </trans-unit>
        <trans-unit id="fbaa2ec88597d6e84d9f667ee669d561de7dec36" translate="yes" xml:space="preserve">
          <source>Silent &quot;k&quot; in words beginning with &quot;kn&quot;: knight, Knuthson</source>
          <target state="translated">&quot;kn&quot;로 시작하는 단어에서 자동 &quot;k&quot;: 기사, Knuthson</target>
        </trans-unit>
        <trans-unit id="0f8ddc119a87ce25d1a07a2270fa7ab759fe3699" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pn&quot;: pneumonia, pneumatic</source>
          <target state="translated">&quot;pn&quot;로 시작하는 단어에서 무음 &quot;p&quot;: 폐렴, 공압</target>
        </trans-unit>
        <trans-unit id="9fea8d13746b11fa947fbc609fcc6f58d06a7902" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;ps&quot;: psalm, psyche</source>
          <target state="translated">&quot;ps&quot;로 시작하는 단어에서 무음 &quot;p&quot;:시, 정신</target>
        </trans-unit>
        <trans-unit id="f17200036eeba29904ebeaabba7f7630872e60fd" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pt&quot;: pterodactyl, ptolemaic</source>
          <target state="translated">&quot;pt&quot;로 시작하는 단어에서 자동 &quot;p&quot;: pterodactyl, ptolemaic</target>
        </trans-unit>
        <trans-unit id="9d3bc03d8343d400c82a4a71a8abb03ff87c2249" translate="yes" xml:space="preserve">
          <source>Similarly, SQLite allows you to store a 2000-character string into a column of type VARCHAR(50). Other SQL implementations would either throw an error or truncate the string. SQLite stores the entire 2000-character string with no loss of information and without complaint.</source>
          <target state="translated">마찬가지로 SQLite를 사용하면 2000 자 문자열을 VARCHAR (50) 유형의 열에 저장할 수 있습니다. 다른 SQL 구현은 오류를 발생 시키거나 문자열을 자릅니다. SQLite는 정보 손실없이 불만없이 전체 2000 자 문자열을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8b91c3fa499f0d4214317846c7c43d756cfd2b0a" translate="yes" xml:space="preserve">
          <source>Similarly, a</source>
          <target state="translated">마찬가지로,</target>
        </trans-unit>
        <trans-unit id="5bca9444f10a42e6ae3d406bbcd7ca872ce4cd02" translate="yes" xml:space="preserve">
          <source>Similarly, in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, the write-ahead log file is not truncated following a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. Instead, SQLite reuses the existing file for subsequent WAL entries since overwriting is faster than appending.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 미리 쓰기 로그 파일은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 다음에 잘리지 않습니다 . 대신, 덮어 쓰기가 추가하는 것보다 빠르기 때문에 SQLite는 후속 WAL 항목에 기존 파일을 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="bac336a356dc6f108086c2da32cf914ab388438e" translate="yes" xml:space="preserve">
          <source>Similarly, streaming API functions that return changesets (or patchsets) return them in chunks by way of a callback function instead of via a pointer to a single large buffer. In this case, a pair of parameters such as:</source>
          <target state="translated">마찬가지로, 변경 세트 (또는 패치 세트)를 리턴하는 스트리밍 API 함수는 단일 대형 버퍼에 대한 포인터를 통하는 대신 콜백 함수를 통해 청크 단위로 변경을 리턴합니다. 이 경우 다음과 같은 매개 변수 쌍이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d579b15000cacebe667c23c91900124e0021ffe" translate="yes" xml:space="preserve">
          <source>Similarly, the following expressions have historically evaluated to TRUE when in fact NULL is also the correct answer here:</source>
          <target state="translated">마찬가지로 다음 표현식은 실제로 NULL이 여기에도 정답 일 때 역사적으로 TRUE로 평가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8de10619f1c2dbf3cc29b124beee52534207f387" translate="yes" xml:space="preserve">
          <source>Simple Queries</source>
          <target state="translated">간단한 쿼리</target>
        </trans-unit>
        <trans-unit id="c820f89b614c85cd10dd51d0186cb9a23cd537b4" translate="yes" xml:space="preserve">
          <source>Simple SELECT</source>
          <target state="translated">간단한 선택</target>
        </trans-unit>
        <trans-unit id="2b5e01ecfaf01cf9d6fed2afce17a1e2ec85faaa" translate="yes" xml:space="preserve">
          <source>Simple Select Processing</source>
          <target state="translated">간단한 선택 처리</target>
        </trans-unit>
        <trans-unit id="25bc3effd8fab2177bf75bccfaba476dd31d7e03" translate="yes" xml:space="preserve">
          <source>Simple fts queries</source>
          <target state="translated">간단한 fts 쿼리</target>
        </trans-unit>
        <trans-unit id="d21c97069116b510ca5fd5d37452e567c518b5ee" translate="yes" xml:space="preserve">
          <source>Simple, easy to use &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt;.</source>
          <target state="translated">간단하고 사용하기 쉬운 &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20a696ed001fc7792dc03669a107ef6867be06cf" translate="yes" xml:space="preserve">
          <source>Simplified Application Development</source>
          <target state="translated">단순화 된 응용 프로그램 개발</target>
        </trans-unit>
        <trans-unit id="75e092657cf7286e756d1dede51480e5230b9edf" translate="yes" xml:space="preserve">
          <source>Simplify the design of the VDBE by restricting the number of sorters and lists to 1. In practice, no more than one sorter and one list was ever used anyhow.</source>
          <target state="translated">분류기 및 목록의 수를 1로 제한하여 VDBE의 설계를 단순화하십시오. 실제로는 하나 이상의 분류기와 하나의 목록이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="89151b192ec38384818e48383b1951487fe9cb56" translate="yes" xml:space="preserve">
          <source>Simply replace</source>
          <target state="translated">간단히 교체</target>
        </trans-unit>
        <trans-unit id="de0928c2b632719ec80087729ff90db61c097100" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;version 3.13.0&lt;/a&gt; (2016-05-18), the session extension has been included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source distribution. By default, the session extension is disabled. To enable it, build with the following compiler switches:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;버전 3.13.0&lt;/a&gt; (2016-05-18) 부터 세션 확장이 SQLite &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 소스 배포 에 포함되었습니다 . 기본적으로 세션 확장은 비활성화되어 있습니다. 이를 가능하게하려면 다음 컴파일러 스위치로 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="eaa37de22579abc7084228906dd483ab965aacfb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), SQLite has supported an interface called the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; or &quot;VFS&quot;. This object is somewhat misnamed since it is really an interface to the whole underlying operating system, not just the filesystem.</source>
          <target state="translated">이후 &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007년 9월 4일), SQLite는이 호출 된 인터페이스를 지원하고 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 또는 &quot;VFS를&quot;. 이 객체는 실제로 파일 시스템뿐만 아니라 전체 기본 운영 체제에 대한 인터페이스이기 때문에 이름이 다소 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="c659e6cde59a26a5cc98604eaf1a60217b6d7297" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), SQLite source code has been stored in the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil configuration management system&lt;/a&gt;. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.</source>
          <target state="translated">이후 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11), SQLite는 소스 코드가 저장되어 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석 형상 관리 시스템&lt;/a&gt; . SQLITE_SOURCE_ID 매크로는 구성 관리 시스템 내에서 SQLite의 특정 체크인을 식별하는 문자열로 평가됩니다. SQLITE_SOURCE_ID 문자열에는 체크인 날짜 (UTC)와 전체 소스 트리의 SHA1 또는 SHA3-256 해시가 포함됩니다. 소스 코드가 마지막으로 체크인 된 이후 어떤 방식 으로든 편집 된 경우 해시의 마지막 4 자리 16 진수가 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ef82de3319be0d75e458ab4416694f2f8299790" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite also supports &quot;&lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;&quot;. In WAL mode, changes are not written to the original database file. Instead, changes go into a separate &quot;write-ahead log&quot; or &quot;WAL&quot; file. Later, after the transaction commits, those changes will be moved from the WAL file back into the original database in an operation called &quot;checkpoint&quot;. WAL mode is enabled by running &quot;&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt;&quot;.</source>
          <target state="translated">이후 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21), SQLite는 또한 &quot;지원 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; &quot;. WAL 모드에서는 변경 내용이 원본 데이터베이스 파일에 기록되지 않습니다. 대신 변경 내용은 별도의 &quot;미리 쓰기 로그&quot;또는 &quot;WAL&quot;파일로 이동합니다. 나중에 트랜잭션이 커밋 된 후 이러한 변경 사항은 &quot;체크 포인트&quot;라는 작업으로 WAL 파일에서 원래 데이터베이스로 다시 이동됩니다. &quot; &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = WAL&lt;/a&gt; &quot; 을 실행하면 WAL 모드가 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="974a12d011bbc97d586f22e505d00eff41958058" translate="yes" xml:space="preserve">
          <source>Since SQLite always interprets any filename that does not begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot; as an ordinary filename regardless of the URI setting, and because it is very unusual to have an actual file begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot;, it is safe for most applications to enable URI processing even if URI filenames are not currently being used.</source>
          <target state="translated">SQLite 는 URI 설정에 관계없이 항상 &quot; &lt;code&gt;file:&lt;/code&gt; &quot;으로 시작하지 않는 파일 이름을 일반 파일 이름으로 해석 하므로 실제 파일이 &quot; &lt;code&gt;file:&lt;/code&gt; &quot;으로 시작하는 것은 매우 드문 일이므로 대부분의 응용 프로그램에서 안전합니다. URI 파일 이름이 현재 사용 중이 아니더라도 URI 처리를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6787bde414a9d9d049df11f55e9b93b41be95c03" translate="yes" xml:space="preserve">
          <source>Since SQLite databases are ordinary disk files, any malfunction in the filesystem can corrupt the database. Filesystems in modern operating systems are very reliable, but errors do still occur. For example, on 2013-10-01 the SQLite database that holds the &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Wiki for Tcl/Tk&lt;/a&gt; went corrupt a few days after the host computer was moved to a dodgy build of the (linux) kernel that had issues in the filesystem layer. In that event, the filesystem eventually became so badly corrupted that the machine was unusable, but the earliest symptom of trouble was the corrupted SQLite database.</source>
          <target state="translated">SQLite 데이터베이스는 일반 디스크 파일이므로 파일 시스템의 오작동으로 인해 데이터베이스가 손상 될 수 있습니다. 최신 운영 체제의 파일 시스템은 매우 안정적이지만 오류가 계속 발생합니다. 예를 들어 2013-10-01에서 호스트 컴퓨터가 파일 시스템 계층에 문제가있는 (linux) 커널의 임시 빌드로 이동 한 후 &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Tcl / Tk 용 Wiki를&lt;/a&gt; 보유한 SQLite 데이터베이스 가 손상되었습니다. 이 경우 파일 시스템이 결국 심하게 손상되어 시스템을 사용할 수 없게되었지만 문제의 가장 초기 증상은 손상된 SQLite 데이터베이스였습니다.</target>
        </trans-unit>
        <trans-unit id="c695a2f51c4b24da3c2784ee7cd9c9755809b7df" translate="yes" xml:space="preserve">
          <source>Since SQLite reads and writes an ordinary disk file, the only access permissions that can be applied are the normal file access permissions of the underlying operating system. The GRANT and REVOKE commands commonly found on client/server RDBMSes are not implemented because they would be meaningless for an embedded database engine.</source>
          <target state="translated">SQLite는 일반 디스크 파일을 읽고 쓰기 때문에 적용 할 수있는 유일한 액세스 권한은 기본 운영 체제의 일반 파일 액세스 권한입니다. 클라이언트 / 서버 RDBMS에서 일반적으로 사용되는 GRANT 및 REVOKE 명령은 내장 데이터베이스 엔진에는 의미가 없으므로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59abdbce3144e8f85a07a8dfceb62a241d9b0167" translate="yes" xml:space="preserve">
          <source>Since an SQLite database is a more general format (it is designed to do much more than simply store a bunch of files) it is not as compact as either the ZIP Archive or Tarball formats. An SQLite Archive is usually about 1% larger than the equivalent ZIP Archive. Tarballs are compressed as a single unit rather than compressing each file separately as is done by both SQLite and ZIP Archives. For these reason, Tarballs tend to be smaller than either ZIP or SQLite Archives.</source>
          <target state="translated">SQLite 데이터베이스는보다 일반적인 형식 (단순히 많은 파일을 저장하는 것보다 훨씬 많은 기능을 수행하도록 설계됨)이므로 ZIP 아카이브 또는 Tarball 형식만큼 컴팩트하지 않습니다. SQLite Archive는 일반적으로 동등한 ZIP Archive보다 약 1 % 더 큽니다. 타르볼은 SQLite와 ZIP Archives에서 수행하는 것처럼 각 파일을 개별적으로 압축하지 않고 단일 단위로 압축됩니다. 이러한 이유로 Tarball은 ZIP 또는 SQLite Archive보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="4194b98c5f98c8eb76bc03b04a9e6fbf66db418a" translate="yes" xml:space="preserve">
          <source>Since database zFilename is a file on disk, then it may be accessed externally by another process. This means that when the call to sqlite3_backup_step() attempts to read from or write data to it, it may fail to obtain the required file lock. If this happens, this implementation will fail, returning SQLITE_BUSY immediately. The solution would be to register a busy-handler callback or timeout with &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pFile using &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; as soon as it is opened. If it fails to obtain a required lock immediately, &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; uses any registered busy-handler callback or timeout in the same way as &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; does.</source>
          <target state="translated">데이터베이스 zFilename은 디스크의 파일이므로 다른 프로세스에서 외부 적으로 액세스 할 수 있습니다. 이는 sqlite3_backup_step ()에 대한 호출이 데이터를 읽거나 쓰려고 할 때 필요한 파일 잠금을 얻지 못할 수 있음을 의미합니다. 이 경우이 구현은 실패하고 SQLITE_BUSY를 즉시 리턴합니다. 해결책은 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 을 열 자마자 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; pFile을 사용하여 통화 중 처리기 콜백 또는 시간 초과를 등록하는 것입니다. 필요한 잠금을 즉시 얻지 못하면 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 와 같은 방식으로 등록 된 사용 중 처리기 콜백 또는 시간 초과를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="689371fa0cc7aa87af9ab6ee0314efa8f5ddaa1a" translate="yes" xml:space="preserve">
          <source>Since its inception on 2000-05-29, SQLite has been implemented in generic C. C was and continues to be the best language for implementing a software library like SQLite. There are no plans to recode SQLite in any other programming language at this time.</source>
          <target state="translated">2000 년 5 월 29 일에 시작된 이후 SQLite는 일반 C로 구현되었습니다. C는 SQLite와 같은 소프트웨어 라이브러리를 구현하기위한 최고의 언어입니다. 현재 다른 프로그래밍 언어로 SQLite를 다시 코딩 할 계획이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e237e23641bdbe1625752d920a811e88f9bea9fa" translate="yes" xml:space="preserve">
          <source>Since the &quot;t2&quot; imposter table is a form of database corruption, the manual approach to creating imposter tables is not recommended. Actually, any use of imposter tables is discouraged for all but expert developers, but manually created imposter tables are especially discouraged because they are permanent.</source>
          <target state="translated">&quot;t2&quot;임 포스터 테이블은 데이터베이스 손상의 한 형태이므로 임 포스터 테이블을 작성하는 수동 방법은 권장되지 않습니다. 실제로 임 포스터 테이블은 전문가를 제외한 모든 개발자에게 사용하지 않는 것이 좋지만 수동으로 생성 된 임 포스터 테이블은 영구적이기 때문에 특히 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cc48f0c85bdbc88acc6ded1a2b33b3cefbcc949" translate="yes" xml:space="preserve">
          <source>Since the SQLite database file format was designed (in 2003) the default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page size&lt;/a&gt; for new databases has been 1024 bytes. This was a reasonable choice in 2003. But on modern hardware, a 4096 byte page is a faster and better choice. So, beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29)) the default page size for new database files has been increased to 4096 bytes.</source>
          <target state="translated">SQLite 데이터베이스 파일 형식은 2003 년에 설계되었으므로 새 데이터베이스 의 기본 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;페이지 크기&lt;/a&gt; 는 1024 바이트입니다. 이것은 2003 년에 합리적인 선택이었습니다. 그러나 최신 하드웨어에서는 4096 바이트 페이지가 더 빠르고 더 나은 선택입니다. 따라서 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; (2016-03-29) 부터 새 데이터베이스 파일의 기본 페이지 크기가 4096 바이트로 늘어났습니다.</target>
        </trans-unit>
        <trans-unit id="054ac08de64845448b2fb9281541e1391100a214" translate="yes" xml:space="preserve">
          <source>Since the actions of &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; are determined to some extent by prior queries that have been evaluated on the same database connection, it is recommended that &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; be deferred until the database connection is closing and has thus had an opportunity to accumulate as much usage information as possible. It is also reasonable to set a timer to run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; every few hours, or every few days, for database connections that stay open for a long time.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 의 동작은 동일한 데이터베이스 연결에서 평가 된 이전 쿼리에 의해 어느 정도 결정 되므로 데이터베이스 연결이 닫힐 때까지 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 를 연기하여 사용량 정보를 축적 할 수있는 기회를 가지십시오 가능한 한. 오랫동안 열려있는 데이터베이스 연결에 대해 몇 시간 또는 며칠마다 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA 최적화&lt;/a&gt; 를 실행하도록 타이머를 설정하는 것도 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="a35c2dbd798622212a3da41545074117af9096bd" translate="yes" xml:space="preserve">
          <source>Since the index is used to look up values in the table, it is important that the index and table be kept consistent. Now that there is an index on the examp table, we will have to update that index whenever data is inserted, deleted, or changed in the examp table. Remember the first example above where we were able to insert a new row into the &quot;examp&quot; table using 12 VDBE instructions. Now that this table is indexed, 19 instructions are required. The SQL statement is this:</source>
          <target state="translated">인덱스는 테이블에서 값을 찾는 데 사용되므로 인덱스와 테이블의 일관성을 유지하는 것이 중요합니다. 이제 examp 테이블에 인덱스가 있으므로 examp 테이블에서 데이터를 삽입, 삭제 또는 변경할 때마다 해당 인덱스를 업데이트해야합니다. 12 개의 VDBE 명령어를 사용하여 &quot;examp&quot;테이블에 새 행을 삽입 할 수있는 위의 첫 번째 예를 기억하십시오. 이 테이블이 색인되었으므로 19 개의 명령이 필요합니다. SQL 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="792d86f988c7b4533a9df91cbaad2f47d8254db5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N element, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">정보는 rowid 순서대로 테이블에 저장되므로 SQLite는 이진 검색을 사용하여 올바른 행을 찾을 수 있습니다. 테이블에 N 요소가 포함 된 경우 전체 테이블 스캔 에서처럼 원하는 행을 찾는 데 필요한 시간은 N에 비례하지 않고 logN에 비례합니다. 테이블에 천만 개의 요소가 포함 된 경우 쿼리는 N / logN 정도 또는 약 1 백만 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f5b0a5f9338e5d6f0eb6749a38c57ac37eadf9c5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N elements, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">정보는 rowid 순서로 테이블에 저장되므로 SQLite는 이진 검색을 사용하여 올바른 행을 찾을 수 있습니다. 테이블에 N 개의 요소가 포함 된 경우 원하는 행을 찾는 데 필요한 시간은 전체 테이블 스캔에서와 같이 N에 비례하는 것이 아니라 logN에 비례합니다. 테이블에 1,000 만 개의 요소가 포함되어 있으면 쿼리가 N / logN 순서 또는 약 1 백만 배 더 빠르다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="94ff8f1fdae75cff7dbf44bfb613a96fb3fe71f5" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the canonical SQLite source code has been moved from the venerable CVS system into a Fossil repository at &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;. This means that if you are working with canonical SQLite source code (as opposed to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code files, sqlite3.c and sqlite3.h) then you can create a private repository simply by cloning the official repository:</source>
          <target state="translated">이 문서가 처음 작성된 이후, 표준 SQLite 소스 코드는 유용한 CVS 시스템에서 &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt; 의 Fossil 저장소로 옮겨졌습니다 . 이는 표준 SQLite 소스 코드를 사용하는 경우 ( &lt;a href=&quot;amalgamation&quot;&gt;아말감&lt;/a&gt; 소스 코드 파일 인 sqlite3.c 및 sqlite3.h와 반대 ) 공식 저장소를 복제하여 간단히 개인 저장소를 작성할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b7c178a22b32f8642c754bb0ef6c8c8f9f96539" translate="yes" xml:space="preserve">
          <source>Since this document was originally written some of the database engines tested have been updated and users have been kind enough to send in corrections to the chart below. The original data showed a wide variety of behaviors, but over time the range of behaviors has converged toward the PostgreSQL/Oracle model. The only significant difference is that Informix and MS-SQL both treat NULLs as indistinct in a UNIQUE column.</source>
          <target state="translated">이 문서는 원래 작성되었으므로 테스트 된 일부 데이터베이스 엔진이 업데이트되었으며 사용자는 아래 차트를 수정하여 보낼 수있을 정도로 친절했습니다. 원본 데이터는 다양한 동작을 보여 주었지만 시간이 지남에 따라 다양한 동작이 PostgreSQL / Oracle 모델로 수렴되었습니다. 유일하게 중요한 차이점은 Informix와 MS-SQL은 모두 NULL을 UNIQUE 열에서 구별되지 않은 것으로 취급한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a988ba929d7a7d98790e14aa91b1b4ee801c28ea" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">이 인터페이스는 거의 사용되지 &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;않으므로&lt;/a&gt; SQLite가 SQLITE_ENABLE_STMT_SCANSTATUS 컴파일 타임 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="fc8856dbc189b149adcf35c14f2c019d6ca39cd2" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">이 인터페이스는 거의 사용되지 &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;않으므로&lt;/a&gt; SQLite가 SQLITE_ENABLE_STMT_SCANSTATUS 컴파일 타임 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="69653584b18a40e580d58b62294b4d01dca91c5b" translate="yes" xml:space="preserve">
          <source>Since undefined and implementation-defined behavior is non-portable and can easily lead to incorrect answers, SQLite works very hard to avoid it. For example, when adding two integer column values together as part of an SQL statement, SQLite does not simply add them together using the C-language &quot;+&quot; operator. Instead, it first checks to make sure the addition will not overflow, and if it will, it does the addition using floating point instead.</source>
          <target state="translated">정의되지 않은 구현 구현 동작은 이식 ​​가능하지 않으며 쉽게 잘못된 답변을 초래할 수 있으므로 SQLite는이를 피하기 위해 매우 열심히 노력합니다. 예를 들어, SQL 문의 일부로 두 개의 정수 열 값을 함께 추가 할 때 SQLite는 단순히 C 언어 &quot;+&quot;연산자를 사용하여 함께 추가하지 않습니다. 대신, 먼저 덧셈이 오버플로되지 않는지 확인하고, 그렇다면 부동 소수점을 사용하여 덧셈을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9a1c7258f48d87f5562218d2ba5ba3886293704d" translate="yes" xml:space="preserve">
          <source>Single-File Documents</source>
          <target state="translated">단일 파일 문서</target>
        </trans-unit>
        <trans-unit id="7fd14cfbad52780046ab174d1c92328e62738415" translate="yes" xml:space="preserve">
          <source>Single-file Cross-platform Database</source>
          <target state="translated">단일 파일 크로스 플랫폼 데이터베이스</target>
        </trans-unit>
        <trans-unit id="71d9f86ea2562e67aa07344919bbe26526606087" translate="yes" xml:space="preserve">
          <source>Situations Where A Client/Server RDBMS May Work Better</source>
          <target state="translated">클라이언트 / 서버 RDBMS가 더 잘 작동 할 수있는 상황</target>
        </trans-unit>
        <trans-unit id="7606f77965da29221827e7ce60dd2a6316522a70" translate="yes" xml:space="preserve">
          <source>Situations Where SQLite Works Well</source>
          <target state="translated">SQLite가 잘 작동하는 상황</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="23dd62e305cc04b400ea8b167918d45e391e1599" translate="yes" xml:space="preserve">
          <source>Size Of The SQLite Library</source>
          <target state="translated">SQLite 라이브러리의 크기</target>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="translated">바이트 단위의 크기</target>
        </trans-unit>
        <trans-unit id="866e161f09886804ed95702c5f38517afa748243" translate="yes" xml:space="preserve">
          <source>Size of a disk sector assumed by the process that wrote this journal.</source>
          <target state="translated">이 저널을 작성한 프로세스가 가정 한 디스크 섹터의 ​​크기.</target>
        </trans-unit>
        <trans-unit id="d67d90ae080b2ba6443535a1ba1538cce623c7a0" translate="yes" xml:space="preserve">
          <source>Size of associated data in bytes after it has been uncompressed (an integer).</source>
          <target state="translated">압축 해제 된 후 바이트 단위의 관련 데이터 크기 (정수).</target>
        </trans-unit>
        <trans-unit id="af19d643ee98cb7aaa5189e1e80bb15629e35fe6" translate="yes" xml:space="preserve">
          <source>Size of pages in this journal.</source>
          <target state="translated">이 저널의 페이지 크기.</target>
        </trans-unit>
        <trans-unit id="594a08e2bfa114e1b1b2dd2a2473b57fc253e650" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages.</source>
          <target state="translated">데이터베이스 파일의 크기 (페이지)</target>
        </trans-unit>
        <trans-unit id="57e816514d2bd056545721fc5901b1263c953939" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages. The &quot;in-header database size&quot;.</source>
          <target state="translated">데이터베이스 파일의 크기 (페이지) &quot;헤더 내 데이터베이스 크기&quot;</target>
        </trans-unit>
        <trans-unit id="80dfcf68ced67397f8e69446b796772d4e573bd1" translate="yes" xml:space="preserve">
          <source>Skip NULL entries on range queries in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;표현식 인덱스의&lt;/a&gt; 범위 쿼리에서 NULL 항목을 건너 뜁니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="8597bf03434e274cab90656bf57bce61497b541d" translate="yes" xml:space="preserve">
          <source>Skip over leading spaces in text to numeric conversions.</source>
          <target state="translated">텍스트에서 숫자 변환으로 선행 공백을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="44c1dff190859dd795700849185006cec261ef11" translate="yes" xml:space="preserve">
          <source>Small code &lt;a href=&quot;footprint&quot;&gt;footprint&lt;/a&gt;: less than 600KiB fully configured or much less with optional features omitted.</source>
          <target state="translated">작은 코드 &lt;a href=&quot;footprint&quot;&gt;설치 공간&lt;/a&gt; : 600KiB 미만으로 완전히 구성되거나 옵션 기능이 생략되어 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="2d43535873c35c636399ec243f6c8a56398f45fc" translate="yes" xml:space="preserve">
          <source>Small edits only overwrite the parts of the file that change, reducing write time and wear on SSD drives.</source>
          <target state="translated">소규모 편집은 변경된 파일 부분 만 덮어 쓰므로 SSD 드라이브의 쓰기 시간과 마모가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="15cb3011196ef5ecfa387e72a64b6b9858775898" translate="yes" xml:space="preserve">
          <source>Smaller documents</source>
          <target state="translated">작은 문서</target>
        </trans-unit>
        <trans-unit id="6085ef2b0d377636644056b25b8388fdb9315be1" translate="yes" xml:space="preserve">
          <source>Snapshots of official releases of SQLite source code can often be obtained directly from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; of the SQLite website. Even if the specific version desired is not listed on the download page, the naming conventions are fairly clear and so programmers can often guess the name of an historical release and download it that way.</source>
          <target state="translated">SQLite 소스 코드의 공식 릴리스 스냅 샷은 종종 SQLite 웹 사이트 의 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 직접 얻을 수 있습니다 . 원하는 특정 버전이 다운로드 페이지에 나열되어 있지 않아도 명명 규칙은 매우 명확하므로 프로그래머는 종종 기록 릴리스의 이름을 추측하여 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7745ac392b119ee893e25a699e3cdf853f08cced" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">&lt;a href=&quot;../loadext&quot;&gt;확장 로딩&lt;/a&gt; 을 처리 할 준비가되지 않은 이전 애플리케이션에서 보안 허점을 열지 않고 사용자가 입력 한 SQL을 평가 &lt;a href=&quot;../loadext&quot;&gt;하는&lt;/a&gt; 동안 확장 로딩 을 비활성화하는 방법으로 &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 메커니즘 을 켜고 끄는 다음 API가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="38b1dd3b3f9a942c8b562e364d61d2076822b07d" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;확장 로딩&lt;/a&gt; 을 처리 할 준비가되지 않은 이전 애플리케이션에서 보안 허점을 열지 않고 사용자가 입력 한 SQL을 평가 &lt;a href=&quot;loadext&quot;&gt;하는&lt;/a&gt; 동안 확장 로딩 을 비활성화하는 방법으로 &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 메커니즘 을 켜고 끄는 다음 API가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="16d0e08c9c27f821bc14542d2dfda5e1d13ecd69" translate="yes" xml:space="preserve">
          <source>So in the vast majority of cases, applications need not worry about the WAL file at all. SQLite will automatically take care of it. But it is possible to get SQLite into a state where the WAL file will grow without bound, causing excess disk space usage and slow queries speeds. The following bullets enumerate some of the ways that this can happen and how to avoid them.</source>
          <target state="translated">따라서 대부분의 경우 응용 프로그램은 WAL 파일에 대해 전혀 걱정할 필요가 없습니다. SQLite가 자동으로 처리합니다. 그러나 SQLite를 WAL 파일이 제한없이 커져 과도한 디스크 공간 사용과 쿼리 속도 저하를 초래할 수 있습니다. 다음 글 머리 기호는 이러한 일이 발생할 수있는 몇 가지 방법과이를 피하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e294517ccb0b92866adadbcc46dbbe368da638fb" translate="yes" xml:space="preserve">
          <source>So instead of going by the standards documents, various popular SQL engines were tested to see how they handle NULLs. The idea was to make SQLite work like all the other engines. An SQL test script was developed and run by volunteers on various SQL RDBMSes and the results of those tests were used to deduce how each engine processed NULL values. The original tests were run in May of 2002. A copy of the test script is found at the end of this document.</source>
          <target state="translated">따라서 표준 문서를 사용하는 대신 널리 사용되는 다양한 SQL 엔진을 테스트하여 NULL을 처리하는 방법을 확인했습니다. 아이디어는 다른 모든 엔진과 마찬가지로 SQLite를 작동시키는 것이 었습니다. 다양한 SQL RDBMS에서 자원 봉사자가 SQL 테스트 스크립트를 개발하고 실행했으며 이러한 테스트 결과를 사용하여 각 엔진이 NULL 값을 처리하는 방식을 추론했습니다. 원래 테스트는 2002 년 5 월에 실행되었습니다. 테스트 스크립트의 사본은이 문서의 끝에 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb3fd38b2086ae5409a50744fd4fc4e629f9ceb9" translate="yes" xml:space="preserve">
          <source>So let your take-away be this: read/write latency for SQLite is competitive with read/write latency of individual files on disk. Often SQLite is faster. Sometimes SQLite is almost as fast. Either way, this article disproves the common assumption that a relational database must be slower than direct filesystem I/O.</source>
          <target state="translated">따라서 SQLite의 읽기 / 쓰기 대기 시간은 디스크에있는 개별 파일의 읽기 / 쓰기 대기 시간과 경쟁이 치열합니다. 종종 SQLite가 더 빠릅니다. 때로는 SQLite가 거의 빠릅니다. 어느 쪽이든,이 기사는 관계형 데이터베이스가 직접 파일 시스템 I / O보다 느려 야한다는 일반적인 가정을 반증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e14f136c4639ca69349a007ce6b5be7651832a1" translate="yes" xml:space="preserve">
          <source>So that</source>
          <target state="translated">그래서</target>
        </trans-unit>
        <trans-unit id="ed811e71ef3d05d3652d347ba0eec5bc9cfd6daf" translate="yes" xml:space="preserve">
          <source>So the implementation of DELETE is really in two loops. The first loop (instructions 5 through 11) locates the records that are to be deleted and saves their keys onto a temporary list, and the second loop (instructions 16 through 19) uses the key list to delete the records one by one.</source>
          <target state="translated">따라서 DELETE의 구현은 실제로 두 개의 루프에 있습니다. 첫 번째 루프 (명령 5 ~ 11)는 삭제할 레코드를 찾아 키를 임시 목록에 저장하고 두 번째 루프 (명령 16 ~ 19)는 키 목록을 사용하여 레코드를 하나씩 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c4f70ed30e8ca5ddd05ca39e32d9f73108273525" translate="yes" xml:space="preserve">
          <source>So then, instead of storing all content for all slides in a single oversized XML file (&quot;content.xml&quot;), suppose there was a separate table for storing the content of each slide separately. The table schema might look something like this:</source>
          <target state="translated">따라서 모든 슬라이드의 모든 컨텐츠를 단일 대형 XML 파일 ( &quot;content.xml&quot;)로 저장하는 대신 각 슬라이드의 컨텐츠를 별도로 저장하기위한 별도의 테이블이 있다고 가정하십시오. 테이블 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21a527776b915968f528d88d96579bf0b2cfc459" translate="yes" xml:space="preserve">
          <source>So which query plan is better? It turns out that the answer depends on what kind of data is found in the node and edge tables.</source>
          <target state="translated">어떤 쿼리 계획이 더 좋습니까? 답은 노드 및 에지 테이블에서 어떤 종류의 데이터가 발견되는지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a7d8b50c8c0de15e18cf6f21d9c00564463215" translate="yes" xml:space="preserve">
          <source>So with this simple change, the ODP file now stores not just the most recent edit to the presentation, but a history of all historic edits. The user would normally want to see just the most recent edition of the presentation, but if desired, the user can now go backwards in time to see historical versions of the same presentation.</source>
          <target state="translated">따라서이 간단한 변경으로 ODP 파일은 프레젠테이션에 대한 최신 편집 내용뿐만 아니라 모든 이전 편집 기록을 저장합니다. 사용자는 일반적으로 최신 버전의 프레젠테이션 만보고 ​​싶어하지만 원하는 경우 시간이 지나면 같은 프레젠테이션의 이전 버전을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b3d75a6fea634203c91a87ee6d0199704a76d2e" translate="yes" xml:space="preserve">
          <source>So you can see that depending on how the data is structured in the table, either query plan 1 or query plan 2 might be better. Which plan does SQLite choose by default? As of version 3.6.18, without running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;, SQLite will choose option 2. But if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is run in order to gather statistics, a different choice might be made if the statistics indicate that the alternative is likely to run faster.</source>
          <target state="translated">따라서 테이블에서 데이터가 구성되는 방식에 따라 쿼리 계획 1 또는 쿼리 계획 2가 더 나을 수 있습니다. SQLite는 기본적으로 어떤 계획을 선택합니까? 버전 3.6.18부터 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하지 않고 SQLite는 옵션 2를 선택합니다. 그러나 통계를 수집하기 위해 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하는 경우 통계가 대안이 더 빠르게 실행될 가능성이 있음을 나타내는 경우 다른 선택이 이루어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae83e266982fd9b4e55366971516ab44ce25fd32" translate="yes" xml:space="preserve">
          <source>So, SQLite is able to do one or two large and complex queries, or it can do many smaller and simpler queries. Both are efficient. An application can use either or both techniques, depending on what works best for the situation at hand.</source>
          <target state="translated">따라서 SQLite는 하나 이상의 크고 복잡한 쿼리를 수행하거나 더 작고 간단한 쿼리를 많이 수행 할 수 있습니다. 둘 다 효율적입니다. 응용 프로그램은 현재 상황에 가장 적합한 방법에 따라 기술 중 하나 또는 둘 다를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac7c0c462d374d0c622ef9a876ba7c2814954d0" translate="yes" xml:space="preserve">
          <source>So, for example, Android applications written in Java are able to invoke SQLite (through an adaptor). Maybe it would have been more convenient for Android if SQLite had been coded in Java as that would make the interface simpler. However, on iPhone applications are coded in Objective-C or Swift, neither of which have the ability to call libraries written in Java. Thus, SQLite would be unusable on iPhones had it been written in Java.</source>
          <target state="translated">예를 들어, Java로 작성된 Android 애플리케이션은 어댑터를 통해 SQLite를 호출 할 수 있습니다. SQLite가 Java로 코딩 된 경우 인터페이스가 더 간단 해지 기 때문에 Android에 더 편리했을 것입니다. 그러나 iPhone 응용 프로그램은 Objective-C 또는 Swift로 코딩되며 Java로 작성된 라이브러리를 호출 할 수 없습니다. 따라서 Java로 작성된 iPhone에서는 SQLite를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74dbcba5ce1ee9e465ff4640af1328df3383d188" translate="yes" xml:space="preserve">
          <source>So, for example, if you read on Wikipedia that the encoding for the minimum positive binary64 value is 0x0000000000000001, then you can find the corresponding floating point value like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a08fae7d5439605099534f2303acb989c7de8df" translate="yes" xml:space="preserve">
          <source>So, for example, if you wanted to see the compression efficiency (expressed as the size of the compressed content relative to the original uncompressed file size) for all files in the ZIP archive, sorted from most compressed to least compressed, you could run a query like this:</source>
          <target state="translated">따라서 예를 들어 ZIP 아카이브의 모든 파일에 대한 압축 효율성 (압축되지 않은 원본 파일 크기에 대한 압축 된 콘텐츠의 크기로 표시됨)을보고 싶다면 가장 많이 압축 된 것에서 가장 적게 압축 된 것 순으로 정렬 된 다음을 실행할 수 있습니다. 다음과 같은 쿼리 :</target>
        </trans-unit>
        <trans-unit id="181a0af408b7a72e62f37951390087a73f4bc42a" translate="yes" xml:space="preserve">
          <source>So, for example, suppose a multi-thread process has two or more threads with separate SQLite database connections to the same database file. Then a third thread comes along and wants to read something out of that same database file on its own, without using the SQLite library. The third thread does an &lt;code&gt;open()&lt;/code&gt;, a &lt;code&gt;read()&lt;/code&gt; and then a &lt;code&gt;close()&lt;/code&gt;. One would think this would be harmless. But the &lt;code&gt;close()&lt;/code&gt; system call caused the locks held on the database by all the other threads to be dropped. Those other threads have no way of knowing that their locks have just been trashed (POSIX does not provide any mechanism to determine this) and so they keep on running under the assumption that their locks are still valid. This can lead to two or more threads or processes trying to write to the database at the same time, resulting in database corruption.</source>
          <target state="translated">예를 들어, 다중 스레드 프로세스에 동일한 데이터베이스 파일에 대한 별도의 SQLite 데이터베이스 연결이있는 둘 이상의 스레드가 있다고 가정하십시오. 그런 다음 세 번째 스레드가 와서 SQLite 라이브러리를 사용하지 않고 동일한 데이터베이스 파일에서 무언가를 읽으려고합니다. 세 번째 스레드는 &lt;code&gt;open()&lt;/code&gt; , &lt;code&gt;read()&lt;/code&gt; 및 &lt;code&gt;close()&lt;/code&gt; 합니다. 이것이 무해하다고 생각할 것입니다. 그러나 &lt;code&gt;close()&lt;/code&gt; 시스템 호출로 인해 다른 모든 스레드가 데이터베이스에 보유한 잠금이 삭제되었습니다. 다른 스레드는 잠금이 방금 휴지통에 있음을 알 수 없으며 (POSIX는이를 결정하는 메커니즘을 제공하지 않음) 잠금이 여전히 유효하다는 가정하에 계속 실행됩니다. 이로 인해 둘 이상의 스레드 또는 프로세스가 동시에 데이터베이스에 쓰려고 시도하여 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e67704da7c1255179aaf24e0803cc78b548dbe91" translate="yes" xml:space="preserve">
          <source>So, for example, suppose an application runs one query against an R-Tree like this:</source>
          <target state="translated">예를 들어 애플리케이션이 다음과 같이 R- 트리에 대해 하나의 쿼리를 실행한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7734444a7a6faac12d5a5f4324148513ca147ad7" translate="yes" xml:space="preserve">
          <source>So, for example, to move a polygon by some amount DX, DY without changing its shape, use:</source>
          <target state="translated">예를 들어, 모양을 변경하지 않고 다각형을 DX, DY만큼 이동 시키려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e378604952476e70a532691c0957173825ab1905" translate="yes" xml:space="preserve">
          <source>So, in most real systems, an index should be created on the child key columns of each foreign key constraint. The child key index does not have to be (and usually will not be) a UNIQUE index. Returning again to the example in section 1, the complete database schema for efficient implementation of the foreign key constraint might be:</source>
          <target state="translated">따라서 대부분의 실제 시스템에서는 각 외래 키 제약 조건의 자식 키 열에 인덱스를 만들어야합니다. 자식 키 인덱스는 고유 인덱스 일 필요는 없으며 일반적으로 아닐 수도 있습니다. 섹션 1의 예제로 다시 돌아가서 외래 키 제약 조건을 효율적으로 구현하기위한 전체 데이터베이스 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae3d493e7575fd35c2f366541da3ece2a1661c2d" translate="yes" xml:space="preserve">
          <source>So-called &quot;REAL&quot; or floating point values are stored in the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754&quot;&gt;IEEE 754&lt;/a&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Double-precision_floating-point_format&quot;&gt;Binary-64&lt;/a&gt; format. This gives a range of positive values between approximately 1.7976931348623157e+308 and 4.9406564584124654e-324 with an equivalent range of negative values. A binary64 can also be 0.0 (and -0.0), positive and negative infinity and &quot;NaN&quot; or &quot;Not-a-Number&quot;. Floating point values are approximate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3db788b7daff3a78000d452682744db386479ec" translate="yes" xml:space="preserve">
          <source>SoftNull</source>
          <target state="translated">SoftNull</target>
        </trans-unit>
        <trans-unit id="36455d32e1724499e8736ccea81ccd08b26881c3" translate="yes" xml:space="preserve">
          <source>Solve Sudoku puzzles</source>
          <target state="translated">스도쿠 퍼즐 해결</target>
        </trans-unit>
        <trans-unit id="ea9361715e601f0c6bb314bde2f85f47f8bc5402" translate="yes" xml:space="preserve">
          <source>Some &quot;safe&quot; languages (ex: Go) dislike the use of assert(). But the use of assert() is a vital part of keeping SQLite maintainable. The lack of assert() in Go is a show-stopper as far as the developers of SQLite are concerned. See the &lt;a href=&quot;assert&quot;&gt;The Use Of assert() In SQLite&lt;/a&gt; article for additional information.</source>
          <target state="translated">일부 &quot;안전한&quot;언어 (예 : Go)는 assert () 사용을 싫어합니다. 그러나 assert () 사용은 SQLite를 유지 관리 할 수있게 유지하는 데 중요한 부분입니다. Go에서 assert ()가 부족하다는 것은 SQLite 개발자가 염려하는 한 막판입니다. 참고 항목 &lt;a href=&quot;assert&quot;&gt;어설의 사용 ()에서 SQLite는&lt;/a&gt; 추가 정보에 대한 기사를.</target>
        </trans-unit>
        <trans-unit id="82877b639e06578b26b7b6487eda6b76c0a0e3c6" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements do their work during sqlite3_prepare() rather than during sqlite3_step(). Those PRAGMA statements are unaffected by EXPLAIN. They operate the same with or without the EXPLAIN prefix. The set of PRAGMA statements that are unaffected by EXPLAIN can vary from one release to the next. Some PRAGMA statements operate during sqlite3_prepare() depending on their arguments. For consistent results, avoid using EXPLAIN on PRAGMA statements.</source>
          <target state="translated">일부 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문은 sqlite3_step ()이 아닌 sqlite3_prepare () 중에 작업을 수행합니다. 이러한 PRAGMA 문은 EXPLAIN의 영향을받지 않습니다. EXPLAIN 접두사를 사용하거나 사용하지 않고 동일하게 작동합니다. EXPLAIN의 영향을받지 않는 PRAGMA 문 세트는 릴리스마다 다를 수 있습니다. 일부 PRAGMA 문은 인수에 따라 sqlite3_prepare () 중에 작동합니다. 일관된 결과를 얻으려면 PRAGMA 문에 EXPLAIN을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5732042dba5cf74de37a47838012719f36ee8111" translate="yes" xml:space="preserve">
          <source>Some Example Triggers</source>
          <target state="translated">일부 예제 트리거</target>
        </trans-unit>
        <trans-unit id="e2da6518510111d1ca6bc33d2d1e98dff9548bb8" translate="yes" xml:space="preserve">
          <source>Some SQL database engines provide non-standard &quot;hint&quot; mechanisms which can be used to give the query optimizer clues about what indices it should use for a particular statement. The INDEX BY clause of SQLite is &lt;em&gt;not&lt;/em&gt; a hinting mechanism and it should not be used as such. The INDEXED BY clause does not give the optimizer hints about which index to use; it gives the optimizer a requirement of which index to use. If the query optimizer is unable to use the index specified by the INDEX BY clause, then the query will fail with an error.</source>
          <target state="translated">일부 SQL 데이터베이스 엔진은 비표준 &quot;힌트&quot;메커니즘을 제공하여 쿼리 최적화 프로그램이 특정 명령문에 사용해야하는 인덱스에 대한 힌트를 제공합니다. SQLite는의 BY 절 INDEX는 &lt;em&gt;하지&lt;/em&gt; 힌트 메커니즘과 같은 사용해서는 안됩니다. INDEXED BY 절은 옵티마이 저가 사용할 인덱스에 대한 힌트를 제공하지 않습니다. 옵티 마이저에 사용할 인덱스의 요구 사항을 제공합니다. 쿼리 최적화 프로그램이 INDEX BY 절에 의해 지정된 인덱스를 사용할 수 없으면 쿼리가 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fbf443b96f0d9f6eac4bc80a9c5c544e6d64bd31" translate="yes" xml:space="preserve">
          <source>Some commentators say that SQLite is &quot;weakly typed&quot; and that other SQL databases are &quot;strongly typed&quot;. We consider these terms to be inaccurate and pejorative. We prefer to say that SQLite is &quot;flexibly typed&quot; and that other SQL databases are &quot;rigidly typed&quot;.</source>
          <target state="translated">일부 의견자는 SQLite는 &quot;약한 유형&quot;이고 다른 SQL 데이터베이스는 &quot;강력한 유형&quot;이라고 말합니다. 우리는 이러한 용어가 부정확하고 중대하다고 생각합니다. 우리는 SQLite가 &quot;유연하게 형식화되어&quot;있고 다른 SQL 데이터베이스가 &quot;견고하게 형식화되어&quot;있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="ffa0bb5b46a56bce712735328de2ecfd7898dd9a" translate="yes" xml:space="preserve">
          <source>Some devices are compelled to use an older filesystem with 8+3 filename restrictions for backwards compatibility, or due to other non-technical factors. In such situations, SQLite can be coerced into using auxiliary files that fit the 8+3 pattern as follows:</source>
          <target state="translated">일부 장치는 이전 버전과의 호환성 또는 기타 기술적이지 않은 요인으로 인해 8 + 3 파일 이름 제한이있는 이전 파일 시스템을 사용해야합니다. 이러한 상황에서 다음과 같이 8 + 3 패턴에 맞는 보조 파일을 사용하여 SQLite를 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a4bdb9a86e43ef62782dbb2803e2ef7fef0a7a" translate="yes" xml:space="preserve">
          <source>Some example, cost table entries:</source>
          <target state="translated">몇 가지 예, 비용 테이블 항목 :</target>
        </trans-unit>
        <trans-unit id="9234854e8f0cb7e3b23fa0273a95bcc8f4a8eaf9" translate="yes" xml:space="preserve">
          <source>Some examples will help illustrate the difference:</source>
          <target state="translated">몇 가지 예는 차이점을 설명하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="31941b285d3264077d66c50c29fee18d7a8c1f66" translate="yes" xml:space="preserve">
          <source>Some freelist pages contain critical data; specifically the locations of other freelist pages. But most freelist pages contain nothing useful. These latter freelist pages are called &quot;leaf&quot; pages. We are free to modify the content of a leaf freelist page in the database without changing the meaning of the database in any way.</source>
          <target state="translated">일부 프리리스트 페이지에는 중요한 데이터가 있습니다. 특히 다른 프리리스트 페이지의 위치. 그러나 대부분의 프리리스트 페이지에는 유용한 정보가 없습니다. 후자의 프리리스트 페이지를 &quot;리프&quot;페이지라고합니다. 데이터베이스의 의미를 변경하지 않고 데이터베이스의 리프 프리리스트 페이지 내용을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d4f98671a50a0a922d51c622597741cdfcd893a" translate="yes" xml:space="preserve">
          <source>Some future versions of SQLite may change to enable this feature by default.</source>
          <target state="translated">이후 버전의 SQLite는 기본적으로이 기능을 사용하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4d80fea07d79c2b9292b009b4bc9dc70c5c271" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="translated">일부 강화 된 보안 설정 ( &lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema = OFF&lt;/a&gt; ) 은 함수가 SQLITE_INNOCUOUS로 태그가 지정되지 않은 경우 뷰 및 트리거 내에서 그리고 스키마 구조 (예 : &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;expridx&quot;&gt;식 인덱스&lt;/a&gt; , &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 및 &lt;a href=&quot;gencol&quot;&gt;생성 된 열)&lt;/a&gt; 에서 SQL 함수를 사용 하지 못하도록합니다. . 대부분의 내장 함수는 무해합니다. 개발자는 함수가 신중하게 감사되고 잠재적 인 보안 부작용 및 정보 유출이없는 것으로 확인되지 않는 한 애플리케이션 정의 함수에 대해 SQLITE_INNOCUOUS 플래그를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="94760af1d8102735e05f237c89411fff0859308d" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="translated">일부 강화 된 보안 설정 ( &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; 및 &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema = OFF&lt;/a&gt; ) 은 함수가 SQLITE_INNOCUOUS로 태그가 지정되지 않은 경우 뷰 및 트리거 내에서 그리고 스키마 구조 (예 : &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;../expridx&quot;&gt;식 인덱스&lt;/a&gt; , &lt;a href=&quot;../partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 및 &lt;a href=&quot;../gencol&quot;&gt;생성 된 열)&lt;/a&gt; 에서 SQL 함수를 사용 하지 못하도록합니다. . 대부분의 내장 함수는 무해합니다. 개발자는 함수가 신중하게 감사되고 잠재적 인 보안 부작용 및 정보 유출이없는 것으로 확인되지 않는 한 애플리케이션 정의 함수에 대해 SQLITE_INNOCUOUS 플래그를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1bc7150370b1275da7b22e0b3c0daa34955ce5a3" translate="yes" xml:space="preserve">
          <source>Some limits can be changed at run-time on a per-connection basis using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface with one of the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;limit categories&lt;/a&gt; defined for that interface. Run-time limits are designed for applications that have multiple databases, some of which are for internal use only and others which can be influenced or controlled by potentially hostile external agents. For example, a web browser application might use an internal database to track historical page views but have one or more separate databases that are created and controlled by javascript applications that are downloaded from the internet. The &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface allows internal databases managed by trusted code to be unconstrained while simultaneously placing tight limitations on databases created or controlled by untrusted external code in order to help prevent a denial of service attack.</source>
          <target state="translated">일부 인터페이스 는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 인터페이스를 사용하여 해당 인터페이스에 대해 정의 된 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;한계 범주&lt;/a&gt; 중 하나를 사용하여 연결별로 런타임에 변경할 수 있습니다 . 런타임 제한은 여러 데이터베이스가있는 응용 프로그램을 위해 설계되었으며 일부는 내부 전용이며 다른 일부는 잠재적으로 적대적인 외부 에이전트에 의해 영향을 받거나 제어 할 수 있습니다. 예를 들어, 웹 브라우저 애플리케이션은 내부 데이터베이스를 사용하여 히스토리 페이지보기를 추적 할 수 있지만 인터넷에서 다운로드되는 Javascript 애플리케이션에 의해 작성되고 제어되는 하나 이상의 개별 데이터베이스를 가질 수 있습니다. &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt;인터페이스는 신뢰할 수있는 코드로 관리되는 내부 데이터베이스가 제한되지 않으면 서 서비스 거부 공격을 방지하기 위해 신뢰할 수없는 외부 코드로 작성하거나 제어하는 ​​데이터베이스에 대한 제한을 동시에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="27f0f8e3878344df85d2a4246c11bee1e47d7640" translate="yes" xml:space="preserve">
          <source>Some older versions of Linux used the LinuxThreads library for thread support. LinuxThreads is similar to Pthreads, but is subtly different with respect to handling of POSIX advisory locks. SQLite versions 2.2.3 through 3.6.23 recognized that LinuxThreads were being used at runtime and took appropriate action to work around the non-standard behavior of LinuxThreads. But most modern Linux implementations make use of the newer, and correct, NPTL implementation of Pthreads. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), the use of NPTL is assumed. No checks are made. Hence, recent versions of SQLite will subtly malfunction and may corrupt database files if used in multi-threaded application that run on older linux systems that make use of LinuxThreads.</source>
          <target state="translated">일부 이전 버전의 Linux에서는 스레드 지원을 위해 LinuxThreads 라이브러리를 사용했습니다. LinuxThreads는 Pthread와 유사하지만 POSIX 권고 잠금 처리와 관련하여 미묘하게 다릅니다. SQLite 버전 2.2.3에서 3.6.23은 LinuxThreads가 런타임에 사용 중임을 인식하고 LinuxThreads의 비표준 동작을 해결하기 위해 적절한 조치를 취했습니다. 그러나 대부분의 최신 Linux 구현에서는 Pthread의 새롭고 정확한 NPTL 구현을 사용합니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21) 부터 NPTL 사용이 가정됩니다. 점검이 없습니다. 따라서 최신 버전의 SQLite는 LinuxThreads를 사용하는 구형 Linux 시스템에서 실행되는 다중 스레드 응용 프로그램에서 사용되는 경우 미묘하게 오작동하고 데이터베이스 파일을 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bef87b7bc572b2934b8ea6d4c58c70ed7dd3633" translate="yes" xml:space="preserve">
          <source>Some older versions of SQLite (prior to version 2.4.0) would show decreasing performance after a sequence of DELETEs followed by new INSERTs. As this test shows, the problem has now been resolved.</source>
          <target state="translated">일부 이전 버전의 SQLite (버전 2.4.0 이전)는 일련의 DELETE와 새 INSERT가 차례로 수행 된 후 성능이 저하됩니다. 이 테스트에서 알 수 있듯이 문제가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b536a604954c308bdf6df6ee3bb8ed7c841aa8c" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode in every bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">일부 opcode는 자체 변경됩니다. 예를 들어, &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (모든 바이트 코드 프로그램에서 항상 첫 번째 opcode)는 P1 피연산자를 증가시킵니다. 후속 &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcode 는 다음의 일회용 초기화 코드를 건너 뛰어야하는지 여부를 결정하기 위해 P1 피연산자를 &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode에 대한 P1 값 과 비교합니다. 또 다른 예는 P4 피연산자를 UTF-8에서 올바른 데이터베이스 문자열 인코딩으로 변환 한 다음 자체를 &lt;a href=&quot;opcode#String&quot;&gt;문자열&lt;/a&gt; opcode 로 변환 하는 &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="52125a8361f282383783887e4dc2c4cfed4a215d" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode run a bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">일부 opcode는 자체 변경됩니다. 예를 들어, &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (항상 첫 번째 opcode가 바이트 코드 프로그램을 실행 함)는 P1 피연산자를 증가시킵니다. 후속 &lt;a href=&quot;opcode#Once&quot;&gt;일단&lt;/a&gt; opcode는 P1 피연산자를 &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode 의 P1 값과 비교하여 다음에 오는 1 회 초기화 코드를 건너 뛸지 여부를 결정합니다. 또 다른 예는 &lt;a href=&quot;opcode#String8&quot;&gt;P8&lt;/a&gt; 피연산자를 UTF-8에서 올바른 데이터베이스 문자열 인코딩으로 변환 한 다음 자신을 &lt;a href=&quot;opcode#String&quot;&gt;문자열&lt;/a&gt; opcode 로 변환 하는 String8 opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="426e64b4a66f4f7807aa6667039b81573979fe2a" translate="yes" xml:space="preserve">
          <source>Some opcodes use all five operands. Some opcodes use one or two. Some opcodes use none of the operands.</source>
          <target state="translated">일부 opcode는 5 개의 피연산자를 모두 사용합니다. 일부 opcode는 하나 나 둘을 사용합니다. 일부 opcode는 피연산자를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b335ac36fb2d38cd00024b326c89df9316f364" translate="yes" xml:space="preserve">
          <source>Some or all of these restrictions may be removed in the future.</source>
          <target state="translated">이러한 제한 중 일부 또는 전부가 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b476a9e69a79b5371957fc7b1a40c95e375aeff4" translate="yes" xml:space="preserve">
          <source>Some other SQL database engines advise developers to store blobs in separate files and then store the filename in the database. In that case, where the database must first be consulted to find the filename before opening and reading the file, simply storing the entire blob in the database gives much faster read and write performance with SQLite. See the &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article for more information.</source>
          <target state="translated">일부 다른 SQL 데이터베이스 엔진은 개발자에게 Blob을 별도의 파일에 저장 한 다음 파일 이름을 데이터베이스에 저장하도록 조언합니다. 이 경우 파일을 열고 읽기 전에 파일 이름을 찾기 위해 데이터베이스를 먼저 참조해야하는 경우 데이터베이스에 전체 블로 브를 저장하면 SQLite를 사용하여 훨씬 더 빠른 읽기 및 쓰기 성능을 얻을 수 있습니다. 자세한 내용은 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;내부 대 외부 BLOB&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e94448e3ce0b80c02ec3cf58a3a89e81bfc4e794" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the new row is inserted.</source>
          <target state="translated">새 행이 삽입 될 때 다른 데이터베이스 제한 조건 (예 : UNIQUE 또는 CHECK 제한 조건)이 위반 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87a22bd6e23f0cc806f999949a67d71c38a0517" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the row is updated.</source>
          <target state="translated">행이 업데이트 될 때 다른 데이터베이스 제약 조건 (예 : UNIQUE 또는 CHECK 제약 조건)이 위반 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a803eb726af2b55f4a3a45a5ec6b4038451fda8a" translate="yes" xml:space="preserve">
          <source>Some other ways in which FTS5 differs from FTS3/4 are:</source>
          <target state="translated">FTS5가 FTS3 / 4와 다른 몇 가지 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2d6bed42aa0aeee6bb3a36da7e69907ed2fed99" translate="yes" xml:space="preserve">
          <source>Some people say that we should eliminate all warnings because benign warnings mask real warnings that might arise in future changes. This is true enough. But in reply, the developers observe that all warnings have already been fixed in the builds used for SQLite development (various versions of GCC, MSVC, and clang). Compiler warnings usually only arise from compilers or compile-time options that the SQLite developers do not use themselves.</source>
          <target state="translated">어떤 사람들은 양성 경고가 미래의 변화에서 발생할 수있는 실제 경고를 가리기 때문에 모든 경고를 제거해야한다고 말합니다. 이것은 사실입니다. 그러나 개발자는 모든 경고가 SQLite 개발에 사용 된 빌드 (다양한 버전의 GCC, MSVC 및 clang)에서 이미 수정되었음을 관찰합니다. 컴파일러 경고는 일반적으로 SQLite 개발자가 사용하지 않는 컴파일러 또는 컴파일 타임 옵션에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8711937cd8478cc6ecffffaffa9bef747431485f" translate="yes" xml:space="preserve">
          <source>Some people view RELEASE as the equivalent of COMMIT for a SAVEPOINT. This is an acceptable point of view as long as one remembers that the changes committed by an inner transaction might later be undone by a rollback in an outer transaction.</source>
          <target state="translated">어떤 사람들은 RELEASE를 SAVEPOINT에 대한 COMMIT와 동등한 것으로 간주합니다. 내부 트랜잭션에 의해 커밋 된 변경 사항이 나중에 외부 트랜잭션의 롤백에 의해 취소 될 수 있다는 것을 기억하는 한 이는 허용 가능한 관점입니다.</target>
        </trans-unit>
        <trans-unit id="0c7ab5e876e4a01802f6862f91dcb4e0c53f5563" translate="yes" xml:space="preserve">
          <source>Some pragmas take effect during the SQL compilation stage, not the execution stage. This means if using the C-language &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; API (or similar in a wrapper interface), the pragma may run during the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; call, not during the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call as normal SQL statements do. Or the pragma might run during sqlite3_step() just like normal SQL statements. Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends on the pragma and on the specific release of SQLite.</source>
          <target state="translated">일부 pragma는 실행 단계가 아닌 SQL 컴파일 단계에서 적용됩니다. 이 수단 C 언어 사용하는 경우 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare를 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; , &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; API (또는 래퍼 인터페이스에서 유사한), 프라 그마는 동안 실행할 수 있습니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 하지 않는 동안, 전화 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 일반 SQL로 전화 성명서. 또는 pragma는 일반 SQL 문과 마찬가지로 sqlite3_step () 중에 실행될 수 있습니다. pragma가 sqlite3_prepare () 또는 sqlite3_step () 중에 실행되는지 여부는 pragma 및 특정 SQLite 릴리스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="16b35f88ff5fdb19b220d3f1fb964fe543a7595b" translate="yes" xml:space="preserve">
          <source>Some programmers cannot imagine developing a complex system like SQLite in a language that is not &quot;object oriented&quot;. So why is SQLite not coded in C++ or Java?</source>
          <target state="translated">일부 프로그래머는 &quot;객체 지향&quot;이 아닌 언어로 SQLite와 같은 복잡한 시스템을 개발하는 것을 상상할 수 없습니다. 그렇다면 왜 SQLite가 C ++ 또는 Java로 코딩되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="b34c6a5bd79eb90989f1ccbc7f5ec2a47398a0d5" translate="yes" xml:space="preserve">
          <source>Some query parameters are interpreted by the SQLite core and used to modify the characteristics of the new connection. All query parameters are always passed through into the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; even if they are previously read and interpreted by the SQLite core.</source>
          <target state="translated">일부 쿼리 매개 변수는 SQLite 코어에서 해석되며 새 연결의 특성을 수정하는 데 사용됩니다. 모든 쿼리 매개 변수는 이전에 SQLite 코어에서 읽고 해석하더라도 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xOpen 메서드로 항상 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfe466f14dd2cc6407106f618ec85911c7fcc3f4" translate="yes" xml:space="preserve">
          <source>Some readers might be reluctant to consider SQLite as an application file format because they have been inculcated with the idea that all SQL database schemas must be factored into third normal form and store only small primitive data types such as strings and integers. Certainly relational theory is important and designers should strive to understand it. But, as demonstrated above, it is often quite acceptable to store complex information as XML or JSON in text fields of a database. Do what works, not what your database professor said you ought to do.</source>
          <target state="translated">일부 독자는 모든 SQL 데이터베이스 스키마를 세 번째 정규 형식으로 인수 화하고 문자열 및 정수와 같은 작은 기본 데이터 유형 만 저장해야한다는 아이디어를 가지고 있기 때문에 SQLite를 애플리케이션 파일 형식으로 간주하기를 꺼려 할 수 있습니다. 확실히 관계 이론은 중요하며 디자이너는 그것을 이해하려고 노력해야합니다. 그러나 위에서 설명한 것처럼 복잡한 정보를 데이터베이스의 텍스트 필드에 XML 또는 JSON으로 저장하는 것이 허용되는 경우가 많습니다. 데이터베이스 교수가해야 할 말이 아니라 작동하는 것을하십시오.</target>
        </trans-unit>
        <trans-unit id="da24c123adee2fd8a84517f276f1059ec16db37d" translate="yes" xml:space="preserve">
          <source>Some readers might resist using SQLite as an application file format due to prior exposure to enterprise SQL databases and the caveats and limitations of those other systems. For example, many enterprise database engines advise against storing large strings or BLOBs in the database and instead suggest that large strings and BLOBs be stored as separate files and the filename stored in the database. But SQLite is not like that. Any column of an SQLite database can hold a string or BLOB up to about a gigabyte in size. And for strings and BLOBs of 100 kilobytes or less, &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I/O performance is better&lt;/a&gt; than using separate files.</source>
          <target state="translated">일부 독자는 엔터프라이즈 SQL 데이터베이스에 대한 사전 노출과 다른 시스템의 경고 및 제한으로 인해 SQLite를 애플리케이션 파일 형식으로 사용하는 것을 거부 할 수 있습니다. 예를 들어, 많은 엔터프라이즈 데이터베이스 엔진은 데이터베이스에 큰 문자열 또는 BLOB를 저장하지 말고 대신 큰 문자열과 BLOB를 별도의 파일로 저장하고 파일 이름을 데이터베이스에 저장하도록 제안합니다. 그러나 SQLite는 그렇지 않습니다. SQLite 데이터베이스의 모든 열은 최대 약 기가 바이트 크기의 문자열 또는 BLOB를 보유 할 수 있습니다. 또한 100KB 이하의 문자열 및 BLOB의 경우 별도의 파일을 사용하는 것보다 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I / O 성능이 좋습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4623126273e781b93958cb9c59802c9b42b20a62" translate="yes" xml:space="preserve">
          <source>Some sanity checking code was removed from the inner loop of vdbe.c to help the library to run a little faster. The code is only removed if you compile with -DNDEBUG.</source>
          <target state="translated">라이브러리가 약간 더 빠르게 실행되도록 돕기 위해 vdbe.c의 내부 루프에서 일부 위생 검사 코드가 제거되었습니다. -DNDEBUG로 컴파일 할 경우에만 코드가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb2b13b24f119a63e7d35aeab7a0a13260e1127" translate="yes" xml:space="preserve">
          <source>Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try(). On those systems, sqlite3_mutex_try() will always return SQLITE_BUSY. The SQLite core only ever uses sqlite3_mutex_try() as an optimization so this is acceptable behavior.</source>
          <target state="translated">일부 시스템 (예 : Windows 95)은 sqlite3_mutex_try ()로 구현 된 작업을 지원하지 않습니다. 이러한 시스템에서 sqlite3_mutex_try ()는 항상 SQLITE_BUSY를 반환합니다. SQLite 코어는 sqlite3_mutex_try ()를 최적화로만 사용하므로 허용되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3594c70c212410200cff937ed0dc1d8804fee77c" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations (ex: &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;) make use of real (non-virtual) database tables to store content. For example, when content is inserted into the FTS3 virtual table, the data is ultimately stored in real tables named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot; where &quot;%&quot; is the name of the original virtual table. This auxiliary real tables that store content for a virtual table are called &quot;shadow tables&quot;. See (&lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt;), (&lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt;), and (&lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt;) for additional information.</source>
          <target state="translated">일부 가상 테이블 구현 (예 : &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; )은 실제 (가상이 아닌) 데이터베이스 테이블을 사용하여 컨텐츠를 저장합니다. 예를 들어 콘텐츠가 FTS3 가상 테이블에 삽입되면 데이터는 &quot;% _content&quot;, &quot;% _segdir&quot;, &quot;% _segments&quot;, &quot;% _stat&quot;및 &quot;% _docsize&quot;라는 실제 테이블에 저장됩니다. 여기서 &quot;% &quot;는 원래 가상 테이블의 이름입니다. 가상 테이블의 내용을 저장하는이 보조 실제 테이블을 &quot;새도우 테이블&quot;이라고합니다. 자세한 내용은 ( &lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt; ), ( &lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt; ) 및 ( &lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt; )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac3c1999dd15ec935e4c05fd2cbb35a8f0236c55" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">일부 가상 테이블 구현은 트랜잭션 커밋의 일부로 행을 rowid 테이블에 삽입 할 수 있습니다 (예 : 메모리에 축적 된 데이터를 디스크로 플러시하기 위해). 이 경우이 함수에 대한 후속 호출은 이러한 내부 INSERT 조작과 연관된 rowid를 리턴하므로 직관적이지 않은 결과가 발생합니다. 이러한 방식으로 rowid 테이블에 쓰는 가상 테이블 구현 은 사용자에게 제어를 리턴하기 전에 &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt; 를 사용하여 원래 rowid 값을 복원하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf0309e04b01e09dca18924e050475fbb9284235" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">일부 가상 테이블 구현은 트랜잭션 커밋의 일부로 행을 rowid 테이블에 삽입 할 수 있습니다 (예 : 메모리에 축적 된 데이터를 디스크로 플러시하기 위해). 이 경우이 함수에 대한 후속 호출은 이러한 내부 INSERT 조작과 연관된 rowid를 리턴하므로 직관적이지 않은 결과가 발생합니다. 이러한 방식으로 rowid 테이블에 쓰는 가상 테이블 구현 은 사용자에게 제어를 리턴하기 전에 &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt; 를 사용하여 원래 rowid 값을 복원하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37863aa03861c512ad1c77afb4b6689cfad7493b" translate="yes" xml:space="preserve">
          <source>Some virtual tables exist automatically in the &quot;main&quot; schema of every database connection in which their module is registered, even without a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. Such virtual tables are called &quot;eponymous virtual tables&quot;. To use an eponymous virtual table, simply use the module name as if it were a table. Eponymous virtual tables exist in the &quot;main&quot; schema only, so they will not work if prefixed with a different schema name.</source>
          <target state="translated">일부 가상 테이블은 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문이 없어도 모듈이 등록 된 모든 데이터베이스 연결의 &quot;주&quot;스키마에 자동으로 존재 합니다. 이러한 가상 테이블을 &quot;명명 가상 테이블&quot;이라고합니다. 시연 가상 테이블을 사용하려면 단순히 모듈 이름을 테이블 인 것처럼 사용하십시오. 동의어 가상 테이블은 &quot;주&quot;스키마에만 존재하므로 다른 스키마 이름이 접두사로 사용되면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0235dde661a1106f01332ba53a569381817a7286" translate="yes" xml:space="preserve">
          <source>Someone (or some process) might rename the database file but fail to also rename its associated journal.</source>
          <target state="translated">누군가 (또는 일부 프로세스)가 데이터베이스 파일의 이름을 바꿀 수 있지만 연관된 저널의 이름도 바꾸지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4532d3d7be4feca574a6f6430b43e863945ec230" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;b&gt;sqlite_exec()&lt;/b&gt; would return SQLITE_PROTOCOL when it should have returned SQLITE_BUSY.</source>
          <target state="translated">때때로 &lt;b&gt;sqlite_exec ()&lt;/b&gt; 는 SQLITE_BUSY를 반환했을 때 SQLITE_PROTOCOL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc0c06ae51aa05a33354304329c9c25f09e5959c" translate="yes" xml:space="preserve">
          <source>Sometimes SQLite uses compile-time evaluatable assert() statements. Consider the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt;. Four assert() statements verify the values for compile-time constants so that the reader can quickly check the validity of the if-statement that follows, without having to look up the constant values in a separate header file.</source>
          <target state="translated">때때로 SQLite는 컴파일 타임 평가 가능한 assert () 문을 사용합니다. &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt; 의 코드를 고려 하십시오 . 4 개의 assert () 문은 컴파일 타임 상수의 값을 확인하므로 독자는 별도의 헤더 파일에서 상수 값을 조회하지 않고도 다음 if 문의 유효성을 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e72dc8159e740969eabd99a1be0aa498a87e7c0f" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be completely omitted from a query without changing the result. This can happen if all of the following are true:</source>
          <target state="translated">때때로 결과를 변경하지 않고 쿼리에서 LEFT JOIN을 완전히 생략 할 수 있습니다. 다음과 같은 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8fa5c7b1abe4111bb41632dd1fff37e6c00e99" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be converted into an ordinary JOIN, if there are terms in the WHERE clause that guarantee that the two joins will give identical results. In particular, if any column in the right-hand table of the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the LEFT JOIN is demoted to an ordinary JOIN.</source>
          <target state="translated">WHERE 절에 두 개의 조인이 동일한 결과를 제공하도록 보장하는 용어가있는 경우 LEFT JOIN이 일반 JOIN으로 변환 될 수 있습니다. 특히, WHERE 절이 참이되도록 LEFT JOIN의 오른쪽 테이블에있는 열이 NULL이 아닌 경우 LEFT JOIN은 일반 JOIN으로 강등됩니다.</target>
        </trans-unit>
        <trans-unit id="f090235439a288798f47de0b5a65b1ea028dc3f6" translate="yes" xml:space="preserve">
          <source>Sometimes a power failure will cause a filesystem to be corrupted such that recently changed filenames are forgotten and the file is moved into a &quot;/lost+found&quot; directory. When that happens, the hot journal will not be found and recovery will not occur. SQLite tries to prevent this by opening and syncing the directory containing the rollback journal at the same time it syncs the journal file itself. However, the movement of files into /lost+found can be caused by unrelated processes creating unrelated files in the same directory as the main database file. And since this is out from under the control of SQLite, there is nothing that SQLite can do to prevent it. If you are running on a system that is vulnerable to this kind of filesystem namespace corruption (most modern journalling filesystems are immune, we believe) then you might want to consider putting each SQLite database file in its own private subdirectory.</source>
          <target state="translated">때때로 정전은 파일 시스템을 손상시켜 최근에 변경된 파일 이름을 잊어 버리고 파일이 &quot;/ lost + found&quot;디렉토리로 이동합니다. 이런 일이 발생하면 핫 저널이 발견되지 않고 복구가 수행되지 않습니다. SQLite는 저널 파일 자체를 동기화하는 동시에 롤백 저널이 포함 된 디렉토리를 열고 동기화하여이를 방지하려고합니다. 그러나 / lost + found로 파일을 이동시키는 것은 기본 데이터베이스 파일과 동일한 디렉토리에 관련없는 파일을 작성하는 관련없는 프로세스로 인해 발생할 수 있습니다. 그리고 이것은 SQLite의 통제하에 있기 때문에 SQLite가 그것을 막기 위해 할 수있는 일은 없습니다. 이러한 종류의 파일 시스템 네임 스페이스 손상에 취약한 시스템에서 실행중인 경우 (대부분의 최신 저널링 파일 시스템은 면역성이 있습니다.각 SQLite 데이터베이스 파일을 자체 개인 서브 디렉토리에 두는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f9f858786d7c98364aee861ef2804edc03f7313" translate="yes" xml:space="preserve">
          <source>Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt; on a system where temporary files are stored on a separate partition with much less space that the primary disk.</source>
          <target state="translated">기본 파일이 기본 디스크보다 훨씬 적은 공간으로 별도의 파티션에 저장되는 시스템에서 임시 &lt;a href=&quot;tempfiles&quot;&gt;디스크 파일&lt;/a&gt; 에 쓸 때 오류가 발생하기 때문에 기본 디스크 공간 이 충분 하더라도 응용 프로그램에서이 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="fff8b7e3376a922064133232ffd6552acd46f238" translate="yes" xml:space="preserve">
          <source>Sometimes compile-time assert() statements are used to verify that SQLite has been correctly compiled. For example, the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; verifies that the SQLITE_PTRSIZE preprocessor macro is set correctly for the target architecture.</source>
          <target state="translated">때로는 컴파일 타임 assert () 문을 사용하여 SQLite가 올바르게 컴파일되었는지 확인합니다. 예를 들어 &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; 의 코드 는 대상 아키텍처에 대해 SQLITE_PTRSIZE 전 처리기 매크로가 올바르게 설정되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d7e0873ee1e2576915056da7a06e2b494b2dd17f" translate="yes" xml:space="preserve">
          <source>Sometimes only part of an ORDER BY clause can be satisfied using indexes. Consider, for example, the following query:</source>
          <target state="translated">때로는 ORDER BY 절의 일부만 인덱스를 사용하여 만족시킬 수 있습니다. 예를 들어 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="08e9765fc44bda2fdb0012e4541cc28a30458938" translate="yes" xml:space="preserve">
          <source>Sometimes operating systems will exhibit non-standard behavior which can lead to problems. Sometimes this non-standard behavior is deliberate, and sometimes it is a mistake in the implementation. But in any event, if the operating performs differently from they way SQLite expects it to perform, the possibility of database corruption exists.</source>
          <target state="translated">때때로 운영 체제는 비표준 동작을 나타내어 문제를 일으킬 수 있습니다. 때때로이 비표준 행동은 의도적 인 것이며 때로는 구 현상 실수입니다. 그러나 어떤 경우에도 운영이 SQLite가 예상 한 방식과 다르게 작동하면 데이터베이스가 손상 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f1e4ae24175645a79034bd7c885a1e7d0f09d3" translate="yes" xml:space="preserve">
          <source>Sometimes the use of row values just makes the SQL easier to read and write. Consider the following two UPDATE statements:</source>
          <target state="translated">때때로 행 값을 사용하면 SQL을 더 쉽게 읽고 쓸 수 있습니다. 다음 두 가지 UPDATE 문을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="24e2bab9e04a22b3a6d58f84b00743d3fb69e859" translate="yes" xml:space="preserve">
          <source>Sometimes when this error code is encountered, the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; routine will convert the error into &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; and try again to prepare the SQL statement using a different query plan that does not require the use of the unknown collating sequence.</source>
          <target state="translated">때때로이 오류 코드가 발생하면 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 루틴이 오류를 &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; 로 변환 하고 알 수없는 조합 순서를 사용할 필요가없는 다른 조회 계획을 사용하여 SQL 문을 다시 준비하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="adc4e96a478be02a8147b100bd68113f38b89f80" translate="yes" xml:space="preserve">
          <source>Sort</source>
          <target state="translated">Sort</target>
        </trans-unit>
        <trans-unit id="5601af90fba7fe38466b58c08c018711849b8855" translate="yes" xml:space="preserve">
          <source>Sort order</source>
          <target state="translated">정렬 순서</target>
        </trans-unit>
        <trans-unit id="74ab25d1e3d8ae1cb528685baf2d71b92460809e" translate="yes" xml:space="preserve">
          <source>SorterCompare</source>
          <target state="translated">SorterCompare</target>
        </trans-unit>
        <trans-unit id="e274ec5d63c6eab4a322b40fa92da953e269dcf5" translate="yes" xml:space="preserve">
          <source>SorterData</source>
          <target state="translated">SorterData</target>
        </trans-unit>
        <trans-unit id="84dc5b8de2832faa332b637acd50721fb4db3efe" translate="yes" xml:space="preserve">
          <source>SorterInsert</source>
          <target state="translated">SorterInsert</target>
        </trans-unit>
        <trans-unit id="2737748d72de05dcf6eba2817820522a4badd0ec" translate="yes" xml:space="preserve">
          <source>SorterNext</source>
          <target state="translated">SorterNext</target>
        </trans-unit>
        <trans-unit id="efe2a2f235ed328025a0db49a289c00d154bb3ba" translate="yes" xml:space="preserve">
          <source>SorterOpen</source>
          <target state="translated">SorterOpen</target>
        </trans-unit>
        <trans-unit id="58a2d7ee050bba205b0d21e366ed8ecfcceedf59" translate="yes" xml:space="preserve">
          <source>SorterSort</source>
          <target state="translated">SorterSort</target>
        </trans-unit>
        <trans-unit id="7dadfa55de2cffb43bdf1a8f139a4a743a9af71b" translate="yes" xml:space="preserve">
          <source>Sorting is accomplished by writing records into a sorting index, then rewinding that index and playing it back from beginning to end. We use the &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode instead of &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; to do the rewinding so that the global variable will be incremented and regression tests can determine whether or not the optimizer is correctly optimizing out sorts.</source>
          <target state="translated">정렬은 레코드를 정렬 색인에 기록한 다음 해당 색인을 되 감고 처음부터 끝까지 재생하여 수행됩니다. &lt;a href=&quot;opcode#Rewind&quot;&gt;리와인드&lt;/a&gt; 대신 &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode를 사용하여 리 와인딩을 수행하여 전역 변수가 증가하고 회귀 테스트에서 옵티마이 저가 정렬을 올바르게 최적화하고 있는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c08b606385251adc6f9a4723f760124243a4d3" translate="yes" xml:space="preserve">
          <source>Sorting subsets of the result</source>
          <target state="translated">결과의 하위 집합 정렬</target>
        </trans-unit>
        <trans-unit id="516e89309d994acf5d94c4a4907b3ff4a8e53a80" translate="yes" xml:space="preserve">
          <source>Source Of Data In A Query Result</source>
          <target state="translated">쿼리 결과의 데이터 소스</target>
        </trans-unit>
        <trans-unit id="cfbc658da4e64bd6eef7ec70eab5adab3d14a41a" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="translated">여러 유용한 확장에 대한 소스 코드 는 SQLite 소스 트리 의 &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext / misc&lt;/a&gt; 서브 디렉토리 에서 찾을 수 있습니다 . 이러한 확장은있는 그대로 사용하거나 고유 한 특정 요구를 해결하기 위해 고유 한 사용자 지정 확장을 만드는 기초로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64243b8fe27d8786b74ebe9ad360b0c831315629" translate="yes" xml:space="preserve">
          <source>Sources are in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. Use for any purpose.</source>
          <target state="translated">출처는 &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;공개 도메인에&lt;/a&gt; 있습니다. 어떤 목적 으로든 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bdb7e396773f80244c6756a8ac8a3ba107260e6f" translate="yes" xml:space="preserve">
          <source>Spatial indices using &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-Tree를&lt;/a&gt; 사용한 공간 인덱스</target>
        </trans-unit>
        <trans-unit id="7f329318e826b6123bdadb48df921310c8b500b7" translate="yes" xml:space="preserve">
          <source>Speak no useless words or words that move to laughter.</source>
          <target state="translated">쓸데없는 말이나 웃음으로 움직이는 말을하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9cda32c171792b8ebd4697561ad451beebb8dd76" translate="yes" xml:space="preserve">
          <source>Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables. Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the table itself. INSERTs into this hidden column are interpreted as commands to the FTS3/4 table. For a table with the name &quot;xyz&quot; the following commands are supported:</source>
          <target state="translated">특수 INSERT 연산을 사용하여 FTS3 및 FTS4 테이블에 명령을 실행할 수 있습니다. 모든 FTS3 및 FTS4에는 테이블 자체와 동일한 이름의 숨겨진 읽기 전용 열이 있습니다. 이 숨겨진 열에 대한 INSERT는 FTS3 / 4 테이블에 대한 명령으로 해석됩니다. 이름이 &quot;xyz&quot;인 테이블의 경우 다음 명령이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5c62a06b3206449dc4ac80333e6db0c204db7ba5" translate="yes" xml:space="preserve">
          <source>Special processing occurs when the aggregate function is either &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt;. Example:</source>
          <target state="translated">집계 함수가 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min ()&lt;/a&gt; 또는 &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max () 인&lt;/a&gt; 경우 특수 처리가 발생합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="6937900c4a39aa0fb125a152dfd5d62be4f8822d" translate="yes" xml:space="preserve">
          <source>Special sqlite_stat1 Handling</source>
          <target state="translated">특별 sqlite_stat1 처리</target>
        </trans-unit>
        <trans-unit id="1e4c6816e6235fac1910f655a4449098f3bab054" translate="yes" xml:space="preserve">
          <source>Special versions of the SQLite amalgamation that do work with a predetermined set of SQLITE_OMIT_* options can be generated. To do so, make a copy of the Makefile.linux-gcc makefile template in the canonical source code distribution. Change the name of your copy to simply &quot;Makefile&quot;. Then edit &quot;Makefile&quot; to set up appropriate compile-time options. Then type:</source>
          <target state="translated">미리 결정된 SQLITE_OMIT_ * 옵션 세트와 함께 작동하는 특수 버전의 SQLite 통합이 생성 될 수 있습니다. 그렇게하려면 표준 소스 코드 배포에서 Makefile.linux-gcc makefile 템플릿의 복사본을 만드십시오. 사본 이름을 &quot;Makefile&quot;로 변경하십시오. 그런 다음 &quot;Makefile&quot;을 편집하여 적절한 컴파일 타임 옵션을 설정하십시오. 그런 다음 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="348842ed415067bf469c3c07cbca8231199b183f" translate="yes" xml:space="preserve">
          <source>Specialized applications for which the default implementation of shared memory is unacceptable can devise alternative methods via a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. For example, if it is known that a particular database will only be accessed by threads within a single process, the wal-index can be implemented using heap memory instead of true shared memory.</source>
          <target state="translated">공유 메모리의 기본 구현이 허용되지 않는 특수 응용 프로그램은 사용자 지정 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 통해 대체 방법을 고안 할 수 있습니다 . 예를 들어, 특정 데이터베이스가 단일 프로세스 내의 스레드에 의해서만 액세스 될 것으로 알려진 경우, wal-index는 실제 공유 메모리 대신 힙 메모리를 사용하여 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a647b0621c3756491eb85db442ab54ae4811cd09" translate="yes" xml:space="preserve">
          <source>Specific pragma statements may be removed and others added in future releases of SQLite. There is no guarantee of backwards compatibility.</source>
          <target state="translated">특정 pragma 문은 제거 할 수 있고 다른 릴리스는 SQLite의 향후 릴리스에 추가 될 수 있습니다. 이전 버전과의 호환성을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a894085a5589da14805f40b5e5ec42d34bdb30" translate="yes" xml:space="preserve">
          <source>Specify an alternative malloc implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 오브젝트 와 함께 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 동사를 사용하여 대체 malloc 구현을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7969816e7b05b7f6c6da58d9c3d55a797859dc5f" translate="yes" xml:space="preserve">
          <source>Specify an alternative mutex implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 오브젝트 와 함께 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 동사를 사용하여 대체 뮤텍스 구현을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7d9e8c303af8fa2eba928e74e37e3e2d5b8ccc2" translate="yes" xml:space="preserve">
          <source>Specify an application-defined page cache.</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="675036f344331d67d2ac3929e1284013b1817b31" translate="yes" xml:space="preserve">
          <source>Specifying a new page size does not change the page size immediately. Instead, the new page size is remembered and is used to set the page size when the database is first created, if it does not already exist when the page_size pragma is issued, or at the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command that is run on the same database connection while not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">새 페이지 크기를 지정해도 페이지 크기가 즉시 변경되지는 않습니다. 대신, page_size pragma가 발행 될 때 또는 같은 데이터베이스 연결에서 실행 되는 다음 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령에 데이터베이스가 존재하지 않는 경우, 새 페이지 크기가 기억되어 데이터베이스가 처음 작성 될 때 페이지 크기를 설정하는 데 사용됩니다. &lt;a href=&quot;wal&quot;&gt;WAL 모드가&lt;/a&gt; 아닌 동안 .</target>
        </trans-unit>
        <trans-unit id="dfdc7dcd44b7642ef54261a530f0a8d271e92800" translate="yes" xml:space="preserve">
          <source>Specifying an explicit value for the rowid field as part of an INSERT statement is not supported. Any value supplied is ignored.</source>
          <target state="translated">INSERT 문의 일부로 rowid 필드에 명시 적 값을 지정하는 것은 지원되지 않습니다. 제공된 모든 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ff83e10cd15a3b1a3684d12025d600161e1e03fe" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;../uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">URI의 쿼리 구성 요소에 알 수없는 매개 변수를 지정하는 것은 오류가 아닙니다. 이후 버전의 SQLite는 추가 쿼리 매개 변수를 이해할 수 있습니다. 추가 정보는 &quot; &lt;a href=&quot;../uri#coreqp&quot;&gt;SQLite에 특별한 의미를 가진 쿼리 매개 변수&lt;/a&gt; &quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca08c5f93bc177c41e9e1cbac8bb1b05f691f402" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">URI의 쿼리 구성 요소에 알 수없는 매개 변수를 지정하는 것은 오류가 아닙니다. 이후 버전의 SQLite는 추가 쿼리 매개 변수를 이해할 수 있습니다. 추가 정보는 &quot; &lt;a href=&quot;uri#coreqp&quot;&gt;SQLite에 특별한 의미를 가진 쿼리 매개 변수&lt;/a&gt; &quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5466deac546a32beeffc729c74a6e5fd300f895" translate="yes" xml:space="preserve">
          <source>Specifying three arguments when creating an fts5vocab table in any database other than &quot;temp&quot; results in an error.</source>
          <target state="translated">&quot;temp&quot;이외의 데이터베이스에서 fts5vocab 테이블을 작성할 때 세 개의 인수를 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">속도 개선</target>
        </trans-unit>
        <trans-unit id="65d5a13bd4511e6816f18d10b6fcf53288c30d62" translate="yes" xml:space="preserve">
          <source>Speed improvements and library footprint reductions.</source>
          <target state="translated">속도 향상 및 라이브러리 풋 프린트 감소</target>
        </trans-unit>
        <trans-unit id="886fdbf5bb356c1170f6be819f95ecf4cc1461e3" translate="yes" xml:space="preserve">
          <source>Speed improvements in the VDBE.</source>
          <target state="translated">VDBE의 속도 향상.</target>
        </trans-unit>
        <trans-unit id="67d42db811b80e228f8d1a0a01dc2cacac3b1009" translate="yes" xml:space="preserve">
          <source>Speed improvements in the btree and pager layers.</source>
          <target state="translated">btree 및 pager 레이어의 속도 향상</target>
        </trans-unit>
        <trans-unit id="0da1385bd95c04e2cef432911cc39014873cc087" translate="yes" xml:space="preserve">
          <source>Speed improvements: Do not do synchronous updates on TEMP tables.</source>
          <target state="translated">속도 향상 : TEMP 테이블에서 동기 업데이트를 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="77d342a78b198923e433b8a1315c81a6ffbf9833" translate="yes" xml:space="preserve">
          <source>Split amalgamation</source>
          <target state="translated">분할 합병</target>
        </trans-unit>
        <trans-unit id="1dac9d1634f1fa754c9cb08212550ad68bf6b1f7" translate="yes" xml:space="preserve">
          <source>Split the pager subsystem into separate pager and pcache subsystems.</source>
          <target state="translated">호출기 서브 시스템을 별도의 호출기 및 pcache 서브 시스템으로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="1bb46447f9362d79f903651b48710b55ec51dd8a" translate="yes" xml:space="preserve">
          <source>Splitting content into smaller pieces also helps File/Save operations to go faster. Instead of having to write back the content of all pages when doing a File/Save, the application only has to write back those pages that have actually changed.</source>
          <target state="translated">내용을 더 작은 조각으로 나누면 파일 / 저장 작업이 더 빨라집니다. 파일 / 저장을 수행 할 때 모든 페이지의 내용을 다시 써야하는 대신 응용 프로그램은 실제로 변경된 페이지 만 다시 써야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b1c55ba41f5df4c296b1603dd8662a874ad05f" translate="yes" xml:space="preserve">
          <source>SqlExec</source>
          <target state="translated">SqlExec</target>
        </trans-unit>
        <trans-unit id="21ba7365f757b4f24cbf08b5870a91de5cd965d8" translate="yes" xml:space="preserve">
          <source>Sqldiff --rbu</source>
          <target state="translated">Sqldiff --rbu</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="d96e5b2dd07c1733b2b013bd82922c22baade37d" translate="yes" xml:space="preserve">
          <source>Stable</source>
          <target state="translated">Stable</target>
        </trans-unit>
        <trans-unit id="ed9cb8071fd38e38b556df67e342f21ef7bd62db" translate="yes" xml:space="preserve">
          <source>Stable interfaces will be maintained indefinitely in a backwards compatible way. An application that uses only stable interfaces should always be able to relink against a newer version of SQLite without any changes.</source>
          <target state="translated">안정적인 인터페이스는 이전 버전과 호환되는 방식으로 무기한 유지 관리됩니다. 안정적인 인터페이스 만 사용하는 응용 프로그램은 변경없이 항상 최신 버전의 SQLite에 다시 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d69ca23f60003536eb90ef7c1a45510967cd2a5" translate="yes" xml:space="preserve">
          <source>Stale file descriptor</source>
          <target state="translated">오래된 파일 설명자</target>
        </trans-unit>
        <trans-unit id="aaf4ee63c814f2ac7a90ca00e168f99ba47070e5" translate="yes" xml:space="preserve">
          <source>Standard File Control Opcodes</source>
          <target state="translated">표준 파일 제어 연산 코드</target>
        </trans-unit>
        <trans-unit id="0271f691eaa2014cfdc1f8a7ed1187c67c1f03ee" translate="yes" xml:space="preserve">
          <source>Standard Query Syntax Precedence</source>
          <target state="translated">표준 쿼리 구문 우선 순위</target>
        </trans-unit>
        <trans-unit id="62af2c2f7d7a242deb88ffff88441215850f0cf0" translate="yes" xml:space="preserve">
          <source>Standard builds include the default &quot;unix&quot; or &quot;win32&quot; VFSes. But if you use the -DOS_OTHER=1 compile-time option, then SQLite is built without a default VFS. In that case, the application must register at least one VFS prior to calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. This is the approach that embedded applications should use. Rather than modifying the SQLite source to insert an alternative OS layer as was done in prior releases of SQLite, instead compile an unmodified SQLite source file (preferably the amalgamation) with the -DOS_OTHER=1 option, then invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to define the interface to the underlying filesystem prior to creating any database connections.</source>
          <target state="translated">표준 빌드에는 기본 &quot;unix&quot;또는 &quot;win32&quot;VFS가 포함됩니다. 그러나 -DOS_OTHER = 1 컴파일 타임 옵션을 사용하면 기본 VFS없이 SQLite가 빌드됩니다. 이 경우 응용 프로그램은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 을 호출하기 전에 하나 이상의 VFS를 등록해야합니다 . 이것이 임베디드 애플리케이션이 사용해야하는 접근 방식입니다. SQLite의 이전 릴리스에서 수행 된 대체 OS 계층을 삽입하도록 SQLite 소스를 수정하는 대신 -DOS_OTHER = 1 옵션을 사용하여 수정되지 않은 SQLite 소스 파일 (바람직하게는 amalgamation)을 컴파일 한 다음 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 를 호출 하여 인터페이스를 정의하십시오. 데이터베이스 연결을 작성하기 전에 기본 파일 시스템에.</target>
        </trans-unit>
        <trans-unit id="f4bb77fea34e91bf036ddd54845284d1cf9ef7e7" translate="yes" xml:space="preserve">
          <source>Standard builds of SQLite for Unix or Windows come with a single VFS named &quot;unix&quot; or &quot;win32&quot;, as appropriate. This one VFS is also the default. So if you are using the legacy open functions, everything will continue to operate as it has before. The change is that an application now has the flexibility of adding new VFS modules to implement a customized OS layer. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; API can be used to tell SQLite about one or more application-defined VFS modules:</source>
          <target state="translated">Unix 또는 Windows 용 표준 SQLite 빌드에는 &quot;unix&quot;또는 &quot;win32&quot;라는 단일 VFS가 제공됩니다. 이 하나의 VFS도 기본값입니다. 따라서 레거시 개방 기능을 사용하는 경우 모든 기능이 이전과 동일하게 계속 작동합니다. 변경 사항은 이제 응용 프로그램에 새로운 VFS 모듈을 추가하여 사용자 지정 OS 계층을 구현할 수있는 유연성이 있다는 것입니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; API는 하나 이상의 응용 프로그램 정의 VFS 모듈에 대한 SQLite는 얘기 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d9cadaed061bc7503c3155b4851296844f6b19b6" translate="yes" xml:space="preserve">
          <source>Start a read transaction on an historical snapshot</source>
          <target state="translated">히스토리 스냅 샷에서 읽기 트랜잭션 시작</target>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="translated">거래를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad3ad0c5dcdfd16f6c5507085aa11afef993658" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database (or &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;). If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">명령 프롬프트에서 &quot;sqlite3&quot;을 입력하고 선택적으로 SQLite 데이터베이스 (또는 &lt;a href=&quot;#zipdb&quot;&gt;ZIP 아카이브&lt;/a&gt; ) 를 보유하는 파일 이름을 입력 하여 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램을 시작합니다 . 명명 된 파일이 존재하지 않는 경우 지정된 이름의 새 데이터베이스 파일이 자동으로 생성됩니다. 명령 줄에 데이터베이스 파일이 지정되지 않은 경우 임시 데이터베이스가 생성 된 다음 &quot;sqlite3&quot;프로그램이 종료 될 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b65d3b5410040822706753355b83a262ca2b3805" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database. If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">명령 프롬프트에서 &quot;sqlite3&quot;을 입력하고 선택적으로 SQLite 데이터베이스를 보유하는 파일 이름을 입력 하여 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램을 시작하십시오 . 명명 된 파일이 존재하지 않으면 지정된 이름의 새 데이터베이스 파일이 자동으로 생성됩니다. 명령 행에 데이터베이스 파일이 지정되지 않은 경우 임시 데이터베이스가 작성되고 &quot;sqlite3&quot;프로그램이 종료 될 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb60319509fec567263f40a7e8bf18c02dfd219" translate="yes" xml:space="preserve">
          <source>Starting with &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;version 3.3.0&lt;/a&gt; (2006-01-11), SQLite includes a special &quot;shared-cache&quot; mode (disabled by default) intended for use in embedded servers. If shared-cache mode is enabled and a thread establishes multiple connections to the same database, the connections share a single data and schema cache. This can significantly reduce the quantity of memory and IO required by the system.</source>
          <target state="translated">시작 &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;버전 3.3.0&lt;/a&gt; (2006년 1월 11일), SQLite는은 (기본적으로 비활성화) 특별한 &quot;공유 캐시&quot;모드를 포함하는 임베디드 서버에서 사용하기위한 것. 공유 캐시 모드가 사용 가능하고 스레드가 동일한 데이터베이스에 대한 다중 연결을 설정하면 연결은 단일 데이터 및 스키마 캐시를 공유합니다. 이를 통해 시스템에 필요한 메모리 및 IO의 양을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="023a31bfb8ddab03b504852064e49a20e7d9d830" translate="yes" xml:space="preserve">
          <source>Startup time is reduced by allowing the application to read in only the content shown for the initial screen. This largely eliminates the need to show a progress bar when opening a new document. The document just pops up immediately, further enhancing the user experience.</source>
          <target state="translated">응용 프로그램이 초기 화면에 표시된 내용 만 읽을 수 있도록하여 시작 시간이 줄어 듭니다. 따라서 새 문서를 열 때 진행률 표시 줄을 표시하지 않아도됩니다. 문서가 즉시 팝업되어 사용자 경험을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="ec7c6f024748b0b4ca685edf7c9c36a22ff2bd48" translate="yes" xml:space="preserve">
          <source>Statement Rollback</source>
          <target state="translated">명령문 롤백</target>
        </trans-unit>
        <trans-unit id="b1c7b81be5c9efcc042ff8389d0cd187913125cb" translate="yes" xml:space="preserve">
          <source>Statement Transactions</source>
          <target state="translated">명세서 거래</target>
        </trans-unit>
        <trans-unit id="a90f613a0e148cacdfc6a3c9d8b61b95e2acb93e" translate="yes" xml:space="preserve">
          <source>Statement journal</source>
          <target state="translated">명세서 일지</target>
        </trans-unit>
        <trans-unit id="eb1040e934c3b0c196798a9d1961f27355d86e45" translate="yes" xml:space="preserve">
          <source>Statement journals</source>
          <target state="translated">명세서 일지</target>
        </trans-unit>
        <trans-unit id="ff8ba443e0e2998259e771cf2ecb0604dd034de1" translate="yes" xml:space="preserve">
          <source>Static analysis has not been helpful in finding bugs in SQLite. Static analysis has found a few bugs in SQLite, but those are the exceptions. More bugs have been introduced into SQLite while trying to get it to compile without warnings than have been found by static analysis.</source>
          <target state="translated">정적 분석은 SQLite에서 버그를 찾는 데 도움이되지 않았습니다. 정적 분석은 SQLite에서 몇 가지 버그를 발견했지만 예외입니다. 정적 분석에서 발견 된 것보다 경고없이 컴파일하도록 시도하는 동안 SQLite에 더 많은 버그가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="680999abb1389f8c322acbd6c1aa5dbe84be6521" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="translated">정적 분석은 컴파일 타임에 소스 코드를 분석하여 정확성을 확인하는 것을 의미합니다. 정적 분석에는 컴파일러 경고 메시지와 &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt; 와 같은보다 심층적 인 분석 엔진이 포함됩니다 . SQLite는 Linux 및 Mac에서 -Wall 및 -Wextra 플래그를 사용하여 GCC 및 Clang에서 경고없이 컴파일하고 Windows의 MSVC에서 컴파일합니다. Clang Static Analyzer 도구 &quot;scan-build&quot;에 의해 유효한 경고가 생성되지 않습니다 (최근 버전의 clang은 많은 오탐 (false-positive)을 생성하는 것으로 보입니다). 그러나 일부 경고는 다른 정적 분석기에 의해 생성 될 수 있습니다. 사용자는 이러한 경고를 강조하지 말고 위에서 설명한 SQLite의 강력한 테스트에서 위안을 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e49731cc0b88e4893c23ef28a83ddda3bfb212a" translate="yes" xml:space="preserve">
          <source>Statistics gathered by ANALYZE are not automatically updated as the content of the database changes. If the content of the database changes significantly, or if the database schema changes, then one should consider rerunning the ANALYZE command in order to update the statistics.</source>
          <target state="translated">ANALYZE에 의해 수집 된 통계는 데이터베이스의 내용이 변경 될 때 자동으로 업데이트되지 않습니다. 데이터베이스의 내용이 크게 변경되거나 데이터베이스 스키마가 변경되면 통계를 업데이트하기 위해 ANALYZE 명령을 다시 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="06d77b9bb2436857be2774ccf495a6735714ef3f" translate="yes" xml:space="preserve">
          <source>Statistics might not be available for all loops in all statements. In cases where there exist loops with no available statistics, this function behaves as if the loop did not exist - it returns non-zero and leave the variable that pOut points to unchanged.</source>
          <target state="translated">모든 명령문에서 모든 루프에 대한 통계를 사용하지 못할 수 있습니다. 사용 가능한 통계가없는 루프가있는 경우이 함수는 루프가 존재하지 않는 것처럼 작동합니다. 0이 아닌 값을 반환하고 pOut이 가리키는 변수를 변경하지 않은 채로 둡니다.</target>
        </trans-unit>
        <trans-unit id="bc97dbd639562aa95bfaa677d2f8dc3487a559db" translate="yes" xml:space="preserve">
          <source>Stats pragma</source>
          <target state="translated">통계 pragma</target>
        </trans-unit>
        <trans-unit id="df542e628beff2a0b73ed1e479f1091511d9cd6a" translate="yes" xml:space="preserve">
          <source>Status Of A Dynamic String</source>
          <target state="translated">동적 문자열의 상태</target>
        </trans-unit>
        <trans-unit id="6872312ea81433049bd70deac565b5d633fd6998" translate="yes" xml:space="preserve">
          <source>Status Parameters</source>
          <target state="translated">상태 매개 변수</target>
        </trans-unit>
        <trans-unit id="2adc22e7dbafa333d0e47ced61c20bab368c7387" translate="yes" xml:space="preserve">
          <source>Status Parameters for database connections</source>
          <target state="translated">데이터베이스 연결을위한 상태 매개 변수</target>
        </trans-unit>
        <trans-unit id="8499ef2845b7984472eeaa5eec92eef3c3ddc5e1" translate="yes" xml:space="preserve">
          <source>Status Parameters for prepared statements</source>
          <target state="translated">준비된 명령문의 상태 매개 변수</target>
        </trans-unit>
        <trans-unit id="f04daddc4070fdc058ac9e443c8962cff2f5d578" translate="yes" xml:space="preserve">
          <source>Sticky &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; or &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; errors in the pager are reset when a new transaction is started.</source>
          <target state="translated">새 트랜잭션이 시작되면 호출기의 고정 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 또는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; 오류가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dd4fde80455d82361972cd992928272cdd38d544" translate="yes" xml:space="preserve">
          <source>Storage class</source>
          <target state="translated">저장 등급</target>
        </trans-unit>
        <trans-unit id="0adf951cb70d6bfcdd293ee933bb14acec2e8923" translate="yes" xml:space="preserve">
          <source>Storage space for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트를 위한 스토리지 공간 .</target>
        </trans-unit>
        <trans-unit id="fbf3f676fb55796ce1a966642440eafe303dfddd" translate="yes" xml:space="preserve">
          <source>Storage used for</source>
          <target state="translated">저장 공간</target>
        </trans-unit>
        <trans-unit id="7a5447c3e2de40c5c68aa31375241b98a076167c" translate="yes" xml:space="preserve">
          <source>Store an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt; in a database table so that Undo could go back into prior edit sessions.</source>
          <target state="translated">저장 &lt;a href=&quot;undoredo&quot;&gt;실행 취소 / 다시 실행 스택 자동화 된&lt;/a&gt; 데이터베이스 테이블에서 실행 취소 전에 편집 세션으로 되돌아 갈 수 있도록하는 것이.</target>
        </trans-unit>
        <trans-unit id="a49a369d4dc034b2ddab0ef35e3bc0a19be08a8f" translate="yes" xml:space="preserve">
          <source>Store in register P2 an integer which is the key of the table entry that P1 is currently point to.</source>
          <target state="translated">레지스터 P2에 현재 P1이 가리키는 테이블 항목의 키인 정수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="867b15696e9fa5010d6dcd54eb51b1ee5a1a7a9e" translate="yes" xml:space="preserve">
          <source>Store in register P3 the value of the P2-th column of the current row of the virtual-table of cursor P1.</source>
          <target state="translated">커서 P1의 가상 테이블에서 현재 행의 P2 번째 열의 값을 레지스터 P3에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="c36766981b9139e0da225001d40b99095efc88b9" translate="yes" xml:space="preserve">
          <source>Store in register r[P3] the byte offset into the database file that is the start of the payload for the record at which that cursor P1 is currently pointing.</source>
          <target state="translated">커서 p1이 현재 가리키는 레코드에 대한 페이로드의 시작 인 데이터베이스 파일에 바이트 오프셋을 레지스터 r [P3]에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="30c620766d52d9f14ee6085868bffd5fb7f16c25" translate="yes" xml:space="preserve">
          <source>Store new polygons in the table using ordinary INSERT statements:</source>
          <target state="translated">일반적인 INSERT 문을 사용하여 테이블에 새 다각형을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="e312586c7080f660b8a13dd56528c07ac821e623" translate="yes" xml:space="preserve">
          <source>Store the maximum page count after the change in register P2.</source>
          <target state="translated">레지스터 P2를 변경 한 후 최대 페이지 수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="4a03a2e19022832dfb9661ede226d69d6b142a41" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2</source>
          <target state="translated">레지스터 P2의 커서 P1에 의해 열린 테이블 또는 인덱스에 항목 수 (정수 값)를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="8f97ad7b80660d239651ee854a82a3871ca04288" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2.</source>
          <target state="translated">레지스터 P2의 커서 P1에 의해 열린 테이블 또는 인덱스의 항목 수 (정수 값)를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="640b00f8e936acd9d22458864812f703b6f037f6" translate="yes" xml:space="preserve">
          <source>Store the statement journal in the temporary file directory instead of collocated with the database file.</source>
          <target state="translated">데이터베이스 파일과 함께 배치되지 않고 임시 파일 디렉토리에 명령문 저널을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="25a1d24f343a9c4193ce3147697d66befd80ac3b" translate="yes" xml:space="preserve">
          <source>Storing the schema a text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">스키마를 텍스트로 저장하면 &lt;a href=&quot;fileformat2&quot;&gt;SQLite 데이터베이스 파일 형식을&lt;/a&gt; 보다 쉽게 ​​정의, 문서화 및 이해할 수 있습니다. 이를 통해 SQLite 데이터베이스 파일을 장기 데이터 보관을위한 &lt;a href=&quot;locrsf&quot;&gt;권장 저장소 형식으로&lt;/a&gt; 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6734d41851e3e8e6c6cbda317484954f124d2cf8" translate="yes" xml:space="preserve">
          <source>Storing the schema as text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">스키마를 텍스트로 저장하면 &lt;a href=&quot;fileformat2&quot;&gt;SQLite 데이터베이스 파일 형식을&lt;/a&gt; 더 쉽게 정의하고 문서화하고 이해할 수 있습니다. 이는 SQLite 데이터베이스 파일 을 데이터의 장기 보관에 &lt;a href=&quot;locrsf&quot;&gt;권장되는 저장 형식으로&lt;/a&gt; 만드는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="9347ad87d0fbebdfc89e77280c0ab0e8462e84d1" translate="yes" xml:space="preserve">
          <source>Storing the schema as text rather than as parsed tables also give flexibility to the implementation. Since the internal parse of the schema is regenerated each time the database is opened, the internal representation of the schema can change from one release to the next. This is important, as sometimes new features require enhancements to the internal schema representation. Changing the internal schema representation would be much more difficult if the schema representation was exposed in the database file. So, in other words, storing the schema as text helps maintain backwards compatibility, and helps ensure that older database files can be read and written by newer versions of SQLite.</source>
          <target state="translated">구문 분석 된 테이블이 아닌 텍스트로 스키마를 저장하면 구현에 유연성이 제공됩니다. 데이터베이스를 열 때마다 스키마의 내부 구문 분석이 재생성되므로 스키마의 내부 표현이 릴리스마다 다를 수 있습니다. 때로는 새로운 기능이 내부 스키마 표현을 향상시켜야하기 때문에 중요합니다. 스키마 표현이 데이터베이스 파일에 노출 된 경우 내부 스키마 표현을 변경하는 것이 훨씬 더 어려울 것입니다. 즉, 스키마를 텍스트로 저장하면 이전 버전과의 호환성을 유지하고 최신 버전의 SQLite에서 오래된 데이터베이스 파일을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="275b8884950b47fafacc5239216411e5afbdc454" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions</source>
          <target state="translated">스트리밍 버전의 API 함수</target>
        </trans-unit>
        <trans-unit id="1cda8a5c429d321cd55319d79be9050795d95668" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions.</source>
          <target state="translated">API 버전의 스트리밍 버전.</target>
        </trans-unit>
        <trans-unit id="41b71513a74ee80684014356a0159868598a4ea7" translate="yes" xml:space="preserve">
          <source>Streaming function</source>
          <target state="translated">스트리밍 기능</target>
        </trans-unit>
        <trans-unit id="c76c18624ee750ab230cd2529398af4c90203056" translate="yes" xml:space="preserve">
          <source>Strengthen defenses against deliberately corrupted database files.</source>
          <target state="translated">고의로 손상된 데이터베이스 파일에 대한 방어 강화</target>
        </trans-unit>
        <trans-unit id="70d422bf6680eb42d320cae6dd4ad922e3705a6b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is not required since the convenience wrapper interfaces, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; or &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt;, can be used and these convenience wrappers encapsulate and hide the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object. Nevertheless, an understanding of &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; is needed to make full use of SQLite.</source>
          <target state="translated">엄밀히 말해서, &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문의&lt;/a&gt; 인터페이스, 래퍼 편리 성 때문에 개체가 필요하지 않습니다 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table가&lt;/a&gt; , 사용할 수 있으며, 이러한 편의 래퍼는 캡슐화와 숨길 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비 문&lt;/a&gt; 개체를. 그럼에도 불구하고 SQLite를 최대한 활용하려면 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 이해 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="f631842398197770725f42465ce9be3bb217fe7f" translate="yes" xml:space="preserve">
          <source>String Comparison</source>
          <target state="translated">문자열 비교</target>
        </trans-unit>
        <trans-unit id="bca91d4c03b6524119c1475d05b8b5503e052ba2" translate="yes" xml:space="preserve">
          <source>String Globbing</source>
          <target state="translated">끈 글 로빙</target>
        </trans-unit>
        <trans-unit id="d8c2dabd43b3a0fa081659375ff18075de8cb9f3" translate="yes" xml:space="preserve">
          <source>String LIKE Matching</source>
          <target state="translated">일치하는 문자열</target>
        </trans-unit>
        <trans-unit id="dfab1bcbfa804d1a74a7282da9ab4ff5c5353c70" translate="yes" xml:space="preserve">
          <source>String8</source>
          <target state="translated">String8</target>
        </trans-unit>
        <trans-unit id="add2080ddbdcd32891495b46eb567565fc93baa2" translate="yes" xml:space="preserve">
          <source>Strings returned by sqlite3_column_text() and sqlite3_column_text16(), even empty strings, are always zero-terminated. The return value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.</source>
          <target state="translated">sqlite3_column_text () 및 sqlite3_column_text16 ()에 의해 반환 된 문자열은 빈 문자열 일지라도 항상 0으로 종료됩니다. 길이가 0 인 BLOB에 대한 sqlite3_column_blob ()의 반환 값은 NULL 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="109fcef442d10303df5f7d59d40936a03977dfcb" translate="yes" xml:space="preserve">
          <source>Strings that include any other characters must be quoted. Characters that are not currently allowed in barewords, are not quote characters and do not currently serve any special purpose in FTS5 query expressions may at some point in the future be allowed in barewords or used to implement new query functionality. This means that queries that are currently syntax errors because they include such a character outside of a quoted string may be interpreted differently by some future version of FTS5.</source>
          <target state="translated">다른 문자를 포함하는 문자열은 따옴표로 묶어야합니다. 현재 베어 워드에서 허용되지 않고 따옴표 문자가 아니며 현재 FTS5 쿼리에서 특수한 용도로 사용되지 않는 문자는 나중에 언젠가 베어 워드에서 허용되거나 새로운 쿼리 기능을 구현하는 데 사용될 수 있습니다. 즉, 현재 구문 오류 인 쿼리에는 따옴표로 묶인 문자열 외부에 그러한 문자가 포함되어 있기 때문에 이후 버전의 FTS5에서는 다르게 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b6945b8df636a6d934a512accf12a8b76fc6265" translate="yes" xml:space="preserve">
          <source>Studies show that many applications already use SQLite as a container object. For example, &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; (no relation to the &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite developer&lt;/a&gt;) reports that 14% of Android applications never write to their SQLite databases. It is believed that these applications are downloading entire databases from the cloud and then using the information locally as needed. In other words, the applications are using SQLite not so much as a database but as a queryable wire-transfer format.</source>
          <target state="translated">연구에 따르면 많은 응용 프로그램에서 이미 SQLite를 컨테이너 개체로 사용하고 있습니다. 예를 들어 &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; ( &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite 개발자&lt;/a&gt; 와 무관 )는 Android 애플리케이션의 14 %가 SQLite 데이터베이스에 쓰지 않는다고보고합니다. 이러한 응용 프로그램은 클라우드에서 전체 데이터베이스를 다운로드 한 다음 필요에 따라 로컬로 정보를 사용하는 것으로 생각됩니다. 다시 말해, 응용 프로그램은 SQLite를 데이터베이스가 아니라 쿼리 가능한 전신 전송 형식으로 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="9a235eb288a64671965312f5d0ad9f1b72cd84b6" translate="yes" xml:space="preserve">
          <source>Subqueries might also need to be materialized when they appear in the FROM clause of a SELECT statement. For example:</source>
          <target state="translated">서브 쿼리가 SELECT 문의 FROM 절에 나타날 때 서브 쿼리를 구체화해야 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79095639cf2544d3073712b3f47816fbf8b20418" translate="yes" xml:space="preserve">
          <source>Subquery Expressions</source>
          <target state="translated">하위 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="14de4f03d3cdec3c98a5016002bc81eb0292385c" translate="yes" xml:space="preserve">
          <source>Subquery co-routines</source>
          <target state="translated">서브 쿼리 공동 루틴</target>
        </trans-unit>
        <trans-unit id="1d0025e26a750eaf886e5b666d451246677ab333" translate="yes" xml:space="preserve">
          <source>Substitution Type</source>
          <target state="translated">대체 유형</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="b2b6c0ca0db2f38dd797d319d2f786a2af93e034" translate="yes" xml:space="preserve">
          <source>Subtract 200 from X.</source>
          <target state="translated">X에서 200을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="351c38b73ce6b309921bfd5c87f12ea777d4a4ac" translate="yes" xml:space="preserve">
          <source>Subtract the value in register P1 from the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P2의 값에서 레지스터 P1의 값을 빼고 결과를 레지스터 P3에 저장합니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="b3ad01aa557050dded853fc788b3484598298d39" translate="yes" xml:space="preserve">
          <source>Such a line of C code might generate a dozen separate machine code instructions. If any one of those instructions is ever evaluated, then we say that the statement has been tested. So, for example, it might be the case that the conditional expression is always false and the &quot;d&quot; variable is never incremented. Even so, statement coverage counts this line of code as having been tested.</source>
          <target state="translated">이러한 C 코드 줄은 12 개의 개별 기계 코드 명령어를 생성 할 수 있습니다. 이러한 지침 중 하나라도 평가되면 해당 진술이 테스트되었다고합니다. 예를 들어, 조건식이 항상 false이고 &quot;d&quot;변수가 증가하지 않는 경우가 있습니다. 그럼에도 불구하고, 진술 범위는이 코드 라인을 테스트 된 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="a042ce9ca13e4d4ddb750a0fe77ea337b1cdceb1" translate="yes" xml:space="preserve">
          <source>Such a virtual table has the same columns as the table-valued function described in the previous section. It may be read from using a SELECT statement in the same way as the table-valued function can.</source>
          <target state="translated">이러한 가상 테이블에는 이전 섹션에서 설명한 테이블 반환 함수와 동일한 열이 있습니다. 테이블 반환 함수와 동일한 방식으로 SELECT 문을 사용하여 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da045363c8fb916c7bdb60bedab8cb85e2f1f5a1" translate="yes" xml:space="preserve">
          <source>Such advanced searches are requested by providing a more complicated FTS5 query string as the text to the right of the MATCH operator (or = operator, or as the first argument to a table-valued function syntax). The full query syntax is &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">이러한 고급 검색은 MATCH 연산자의 오른쪽에있는 텍스트 (또는 = 연산자 또는 테이블 반환 함수 구문의 첫 번째 인수)로 더 복잡한 FTS5 쿼리 문자열을 제공하여 요청됩니다. 전체 쿼리 구문은 &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0936ee6227b30512f2222702e2254d11d72a242" translate="yes" xml:space="preserve">
          <source>Such criticism would be well-founded for a traditional client/server database engine, such as MySQL, PostgreSQL, or SQL Server. In a client/server database, each SQL statement requires a message round-trip from the application to the database server and back to the application. Doing over 200 round-trip messages, sequentially, can be a serious performance drag. This is sometimes called the &quot;N+1 Query Problem&quot; or the &quot;N+1 Select Problem&quot; and it is an anti-pattern.</source>
          <target state="translated">이러한 비판은 MySQL, PostgreSQL 또는 SQL Server와 같은 전통적인 클라이언트 / 서버 데이터베이스 엔진에 대해 잘 알려져 있습니다. 클라이언트 / 서버 데이터베이스에서 각 SQL 문은 응용 프로그램에서 데이터베이스 서버로, 응용 프로그램으로 다시 왕복하는 메시지가 필요합니다. 200 회 이상의 왕복 메시지를 순차적으로 수행하면 성능이 크게 저하 될 수 있습니다. 이를 &quot;N + 1 쿼리 문제&quot;또는 &quot;N + 1 선택 문제&quot;라고도하며 안티 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="f834acdfa0c7dab757f2bc4e26b1966eff963a52" translate="yes" xml:space="preserve">
          <source>Suggested Uses For SQLite:</source>
          <target state="translated">SQLite의 권장 사용법 :</target>
        </trans-unit>
        <trans-unit id="f08f43d3c61d6c426d33128ee0c38e51fb6aad20" translate="yes" xml:space="preserve">
          <source>Suggested compile-time options include:</source>
          <target state="translated">제안 된 컴파일 타임 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d1a384ea1042be63f3032ea726e70fc4a04f311" translate="yes" xml:space="preserve">
          <source>Suggests completions for partially-entered words during interactive SQL input. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement tab-completion.</source>
          <target state="translated">대화식 SQL 입력 중에 부분적으로 입력 된 단어의 완성을 제안합니다. 탭 완성을 구현하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="adca4d21f8bf7900f73ede68196274afd881f1d7" translate="yes" xml:space="preserve">
          <source>Sum() will throw an &quot;integer overflow&quot; exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.</source>
          <target state="translated">Sum ()은 모든 입력이 정수이거나 NULL이고 계산 중 어느 시점에서나 정수 오버플로가 발생하면 &quot;정수 오버플로&quot;예외를 발생시킵니다. Total ()은 정수 오버플로를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="1a7bd9ebcad37a0dd711dfc793fa96bb5022047c" translate="yes" xml:space="preserve">
          <source>Summary of Technical Differences</source>
          <target state="translated">기술적 차이점 요약</target>
        </trans-unit>
        <trans-unit id="4c599c4f8f2ffb798c4263cf7f6e473784c4d396" translate="yes" xml:space="preserve">
          <source>Super-journals</source>
          <target state="translated">Super-journals</target>
        </trans-unit>
        <trans-unit id="ab2e3b9850b401306a39a3a804f43e7d4f55c01f" translate="yes" xml:space="preserve">
          <source>Support for &quot;:AAA&quot; style bind parameter names.</source>
          <target state="translated">&quot;: AAA&quot;스타일 바인드 매개 변수 이름 지원.</target>
        </trans-unit>
        <trans-unit id="8b45bd25a3b604a0eccba69e7087834ecb582853" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; following the PostgreSQL syntax.</source>
          <target state="translated">PostgreSQL 구문에 따라 &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM을&lt;/a&gt; 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="e333e85b28ab7b57a0a5c9131f54f806015a6221" translate="yes" xml:space="preserve">
          <source>Support for ALTER TABLE ... RENAME TABLE ... added</source>
          <target state="translated">ALTER TABLE ... RENAME TABLE ...에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="3251d36ace39f64a5ddca9143a5668b65028289f" translate="yes" xml:space="preserve">
          <source>Support for TCL variable names embedded in SQL statements in the TCL bindings.</source>
          <target state="translated">TCL 바인딩에서 SQL 문에 임베드 된 TCL 변수 이름 지원</target>
        </trans-unit>
        <trans-unit id="4c4e649b2faf6e7dd28f3f288044f754a9767c05" translate="yes" xml:space="preserve">
          <source>Support for UTF-16.</source>
          <target state="translated">UTF-16을 지원합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
