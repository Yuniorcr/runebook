<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="6746f394557b9dabd8af972d9d23d7f801fedd98" translate="yes" xml:space="preserve">
          <source>SQLite is built using a &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;-inspired process. The &lt;a href=&quot;testing&quot;&gt;testing standards&lt;/a&gt; for SQLite are among the highest for commercial software.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B에서&lt;/a&gt; 영감을 얻은 프로세스를 사용하여 구축되었습니다 . SQLite 의 &lt;a href=&quot;testing&quot;&gt;테스트 표준&lt;/a&gt; 은 상용 소프트웨어에서 가장 높은 수준 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="875a9efc25bbb30b8f5d1660336c59da880170b4" translate="yes" xml:space="preserve">
          <source>SQLite is competitive with, and usually faster than, blobs stored in separate files on disk, for both reading and writing.</source>
          <target state="translated">SQLite는 읽기와 쓰기 모두 디스크에서 별도의 파일에 저장된 Blob과 비교하여 경쟁이 빠르며 일반적으로 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="53b3a565f93669221f3865969fe660536421aef7" translate="yes" xml:space="preserve">
          <source>SQLite is designed to meet most developer's needs without any changes or customization. When changes are needed, they can normally be accomplished using start-time &lt;a href=&quot;c3ref/config&quot;&gt;(1)&lt;/a&gt; or runtime &lt;a href=&quot;c3ref/db_config&quot;&gt;(2)&lt;/a&gt;&lt;a href=&quot;c3ref/limit&quot;&gt;(3)&lt;/a&gt;&lt;a href=&quot;c3ref/vfs_find&quot;&gt;(4)&lt;/a&gt; configuration methods or via &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt;. It is very rare that an application developer will need to edit the SQLite source code in order to incorporate SQLite into a product.</source>
          <target state="translated">SQLite는 변경이나 사용자 정의없이 대부분의 개발자 요구를 충족하도록 설계되었습니다. 변경이 필요한 경우 일반적으로 시작 시간 &lt;a href=&quot;c3ref/config&quot;&gt;(1)&lt;/a&gt; 또는 런타임 &lt;a href=&quot;c3ref/db_config&quot;&gt;(2) &lt;/a&gt;&lt;a href=&quot;c3ref/limit&quot;&gt;(3) &lt;/a&gt;&lt;a href=&quot;c3ref/vfs_find&quot;&gt;(4)&lt;/a&gt; 구성 방법을 사용하거나 &lt;a href=&quot;compile&quot;&gt;컴파일 타임 옵션을&lt;/a&gt; 통해 수행 할 수 있습니다 . SQLite를 제품에 통합하기 위해 애플리케이션 개발자가 SQLite 소스 코드를 편집해야하는 경우는 매우 드 rare니다.</target>
        </trans-unit>
        <trans-unit id="2b810dc63ad4381febba6bfa7d0698c8944220e9" translate="yes" xml:space="preserve">
          <source>SQLite is different in that it stores the schema in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table as the original text of the CREATE statements that define the schema. Hence ALTER TABLE needs to revise the text of the CREATE statement. Doing so can be tricky for certain &quot;creative&quot; schema designs.</source>
          <target state="translated">SQLite는 스키마 를 정의하는 CREATE 문의 원본 텍스트로 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; 테이블에 스키마를 저장한다는 점에서 다릅니다 . 따라서 ALTER TABLE은 CREATE 문의 텍스트를 수정해야합니다. 특정 &quot;크리에이티브&quot;스키마 디자인에는 까다로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba0a35d8001d8dc075689278c2e501182c6877e" translate="yes" xml:space="preserve">
          <source>SQLite is different in that it stores the schema in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table as the original text of the CREATE statements that define the schema. Hence ALTER TABLE needs to revise the text of the CREATE statement. Doing so can be tricky for certain &quot;creative&quot; schema designs.</source>
          <target state="translated">SQLite는 스키마 를 정의하는 CREATE 문의 원본 텍스트로 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 테이블에 스키마를 저장한다는 점에서 다릅니다 . 따라서 ALTER TABLE은 CREATE 문의 텍스트를 수정해야합니다. 이렇게하는 것은 특정 &quot;창의적인&quot;스키마 디자인에서 까다로울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4d9fd1ad4a17767c9b0eeee58f6c4cef761ec22" translate="yes" xml:space="preserve">
          <source>SQLite is expected to operate the same, and use exactly the same &lt;a href=&quot;fileformat2&quot;&gt;on-disk format&lt;/a&gt;, on all modern operating systems, on all modern computer architectures, and using all modern C compilers. The developers are constantly testing SQLite on as many diverse platforms as they can get their hands on.</source>
          <target state="translated">SQLite는 모든 최신 운영 체제, 모든 최신 컴퓨터 아키텍처 및 모든 최신 C 컴파일러를 사용하여 동일하게 작동하고 정확히 동일한 &lt;a href=&quot;fileformat2&quot;&gt;온 디스크 형식을&lt;/a&gt; 사용해야합니다 . 개발자는 다양한 플랫폼에서 SQLite를 지속적으로 테스트하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ae04c54b68c60010dff08d4f306e294deee8ba8" translate="yes" xml:space="preserve">
          <source>SQLite is in the Public Domain.</source>
          <target state="translated">SQLite는 공개 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="41978015003a28658fac35ad1aebf308a1d4bdc1" translate="yes" xml:space="preserve">
          <source>SQLite is much faster than direct writes to disk on Windows when anti-virus protection is turned on. Since anti-virus software is and should be on by default in Windows, that means that SQLite is generally much faster than direct disk writes on Windows.</source>
          <target state="translated">안티 바이러스 보호 기능이 설정되어있는 경우 SQLite는 Windows에서 디스크에 직접 쓰는 것보다 훨씬 빠릅니다. 안티 바이러스 소프트웨어는 Windows에서 기본적으로 켜져 있어야하므로 SQLite는 일반적으로 Windows에서 직접 디스크 쓰기보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d2117a2a67d4eee0f3af565533d9cac9c29e3ebe" translate="yes" xml:space="preserve">
          <source>SQLite is normally very forgiving about mismatches between the type of a value and the declared type of the container in which that value is to be stored. For example, SQLite allows the application to store a large BLOB in a column with a declared type of BOOLEAN. But in a few cases, SQLite is strict about types. The SQLITE_MISMATCH error is returned in those few cases when the types do not match.</source>
          <target state="translated">SQLite는 일반적으로 값 유형과 해당 값이 저장 될 컨테이너의 선언 된 유형 사이의 불일치를 매우 용서합니다. 예를 들어 SQLite를 사용하면 응용 프로그램에서 선언 된 유형이 BOOLEAN 인 열에 큰 BLOB를 저장할 수 있습니다. 그러나 SQLite는 유형에 대해 엄격한 경우가 있습니다. 유형이 일치하지 않는 경우에 SQLITE_MISMATCH 오류가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="90d38f0f8852e6f3bc8f54ade94a7ff4da3d7a52" translate="yes" xml:space="preserve">
          <source>SQLite is not directly comparable to client/server SQL database engines such as MySQL, Oracle, PostgreSQL, or SQL Server since SQLite is trying to solve a different problem.</source>
          <target state="translated">SQLite는 다른 문제를 해결하려고하기 때문에 SQLite는 MySQL, Oracle, PostgreSQL 또는 SQL Server와 같은 클라이언트 / 서버 SQL 데이터베이스 엔진과 직접 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1435c0d28bf1363ba8e34333297e06f59701df95" translate="yes" xml:space="preserve">
          <source>SQLite is not particular about the text it receives and is more than happy to process text strings that are not normalized or even well-formed UTF-8 or UTF-16. Thus, programmers who want to store IS08859 data can do so using the UTF-8 interfaces. As long as no attempts are made to use a UTF-16 collating sequence or SQL function, the byte sequence of the text will not be modified in any way.</source>
          <target state="translated">SQLite는 수신하는 텍스트를 특별히 고려하지 않았으며 정규화되지 않았거나 올바르게 구성된 UTF-8 또는 UTF-16이 아닌 텍스트 문자열을 처리하는 것이 좋습니다. 따라서 IS08859 데이터를 저장하려는 프로그래머는 UTF-8 인터페이스를 사용하여 그렇게 할 수 있습니다. UTF-16 조합 순서 또는 SQL 함수를 사용하려고 시도하지 않는 한 텍스트의 바이트 순서는 어떤 식 으로든 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79f629ab8f652eed86f8d0cea408ad231ec0a7de" translate="yes" xml:space="preserve">
          <source>SQLite is not particular about the text it receives and is more than happy to process text strings that are not normalized or even well-formed UTF-8 or UTF-16. Thus, programmers who want to store ISO8859 data can do so using the UTF-8 interfaces. As long as no attempts are made to use a UTF-16 collating sequence or SQL function, the byte sequence of the text will not be modified in any way.</source>
          <target state="translated">SQLite는 수신하는 텍스트에 대해 특별하지 않으며 정규화되지 않은 텍스트 문자열 또는 잘 구성된 UTF-8 또는 UTF-16을 처리하는 데 더 만족합니다. 따라서 ISO8859 데이터를 저장하려는 프로그래머는 UTF-8 인터페이스를 사용하여 저장할 수 있습니다. UTF-16 조합 시퀀스 또는 SQL 함수를 사용하려는 시도가없는 한 텍스트의 바이트 시퀀스는 어떤 방식으로도 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c1f069bbbe7e83bd0e5742fa278486eb680133a8" translate="yes" xml:space="preserve">
          <source>SQLite is not the perfect application file format for every situation. But in many cases, SQLite is a far better choice than either a custom file format, a pile-of-files, or a wrapped pile-of-files. SQLite is a high-level, stable, reliable, cross-platform, widely-deployed, extensible, performant, accessible, concurrent file format. It deserves your consideration as the standard file format on your next application design.</source>
          <target state="translated">SQLite는 모든 상황에서 완벽한 응용 프로그램 파일 형식은 아닙니다. 그러나 많은 경우 SQLite는 사용자 지정 파일 형식, 파일 더미 또는 랩 파일 더미보다 훨씬 나은 선택입니다. SQLite는 높은 수준의 안정적이고 안정적인 크로스 플랫폼이며 광범위하게 배포되고 확장 가능하며 성능이 뛰어나고 액세스 가능한 동시 파일 형식입니다. 다음 응용 프로그램 디자인에서 표준 파일 형식으로 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9638ccd4cc256f849e2db07526c184593398229" translate="yes" xml:space="preserve">
          <source>SQLite is often used as the on-disk file format for desktop applications such as version control systems, financial analysis tools, media cataloging and editing suites, CAD packages, record keeping programs, and so forth. The traditional File/Open operation calls sqlite3_open() to attach to the database file. Updates happen automatically as application content is revised so the File/Save menu option becomes superfluous. The File/Save_As menu option can be implemented using the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;.</source>
          <target state="translated">SQLite는 종종 버전 제어 시스템, 재무 분석 도구, 미디어 카탈로그 및 편집 제품군, CAD 패키지, 레코드 보관 프로그램 등과 같은 데스크톱 응용 프로그램을위한 온 디스크 파일 형식으로 사용됩니다. 전통적인 File / Open 작업은 sqlite3_open ()을 호출하여 데이터베이스 파일에 연결합니다. 파일 / 저장 메뉴 옵션이 불필요 해 지므로 응용 프로그램 내용이 수정되면 자동으로 업데이트됩니다. File / Save_As 메뉴 옵션은 &lt;a href=&quot;backup&quot;&gt;백업 API를&lt;/a&gt; 사용하여 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f01574bffbe492a08f6a39612436763f1dce6eab" translate="yes" xml:space="preserve">
          <source>SQLite is one of many open-source projects that OSS Fuzz tests. The &lt;a href=&quot;https://www.sqlite.org/src/file/test/ossfuzz.c&quot;&gt;test/ossfuzz.c&lt;/a&gt; source file in the SQLite repository is SQLite's interface to OSS fuzz.</source>
          <target state="translated">SQLite는 OSS Fuzz가 테스트하는 많은 오픈 소스 프로젝트 중 하나입니다. SQLite 리포지토리 의 &lt;a href=&quot;https://www.sqlite.org/src/file/test/ossfuzz.c&quot;&gt;test / ossfuzz.c&lt;/a&gt; 소스 파일은 SQLite의 OSS 퍼즈 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="bf60766f31de04598304b77a31a30aab178aeaf9" translate="yes" xml:space="preserve">
          <source>SQLite is one of the &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;most used&lt;/a&gt; software libraries in the world. There are literally tens of billions of SQLite database files in use daily, on smartphones and gadgets and in desktop applications. SQLite is &lt;a href=&quot;testing&quot;&gt;carefully tested&lt;/a&gt; and proven reliable. It is not a component that needs much tuning or debugging, allowing developers to stay focused on application logic.</source>
          <target state="translated">SQLite는 세계에서 &lt;a href=&quot;https://sqlite.org/mostdeployed.html&quot;&gt;가장 많이 사용되는&lt;/a&gt; 소프트웨어 라이브러리 중 하나입니다 . 문자 그대로 스마트 폰과 가제트 및 데스크톱 응용 프로그램에서 매일 수백억 개의 SQLite 데이터베이스 파일이 사용되고 있습니다. SQLite는 &lt;a href=&quot;testing&quot;&gt;신중하게 테스트&lt;/a&gt; 되었으며 신뢰성이 입증되었습니다. 많은 튜닝이나 디버깅이 필요한 구성 요소가 아니므로 개발자는 응용 프로그램 논리에 계속 집중할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b472863a9267f026cee0ca0b35a15991ef89b036" translate="yes" xml:space="preserve">
          <source>SQLite is open source. This gives many people the idea that it is not well tested as commercial software and is perhaps unreliable. But that impression is false. SQLite has exhibited very high reliability in the field and a very low defect rate, especially considering how rapidly it is evolving. The quality of SQLite is achieved in part by careful code design and implementation. But extensive testing also plays a vital role in maintaining and improving the quality of SQLite. This document has summarized the testing procedures that every release of SQLite undergoes with the hope of inspiring confidence that SQLite is suitable for use in mission-critical applications.</source>
          <target state="translated">SQLite는 오픈 소스입니다. 이것은 많은 사람들에게 상용 소프트웨어로서 잘 테스트되지 않았으며 아마도 신뢰할 수 없다는 아이디어를 제공합니다. 그러나 그 인상은 거짓입니다. SQLite는 특히 빠르게 발전하는 것을 고려할 때 현장에서 매우 높은 신뢰성과 매우 낮은 결함률을 보여주었습니다. SQLite의 품질은 신중한 코드 디자인 및 구현으로 부분적으로 달성됩니다. 그러나 광범위한 테스트는 SQLite의 품질을 유지하고 향상시키는 데 중요한 역할을합니다. 이 문서는 SQLite가 미션 크리티컬 애플리케이션에 사용하기에 적합하다는 확신을 갖기 위해 모든 SQLite 릴리스가 수행되는 테스트 절차를 요약했습니다.</target>
        </trans-unit>
        <trans-unit id="dbc3c1fb569cecbb959acf32375d7a9409c9e7db" translate="yes" xml:space="preserve">
          <source>SQLite is required to &lt;b&gt;implement atomic and durable transactions&lt;/b&gt; (the 'A' and 'D' from the ACID acronym), even if an application, operating system or power failure occurs midway through or shortly after updating a database file.</source>
          <target state="translated">SQLite는 데이터베이스 파일을 업데이트 한 후 응용 프로그램, 운영 체제 또는 정전이 발생하더라도 &lt;b&gt;원자적이고 내구성있는 트랜잭션&lt;/b&gt; (ACID 약어의 'A'및 'D') 을 &lt;b&gt;구현&lt;/b&gt; 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="362f767a2655b7418135c488c8146a1c344658d9" translate="yes" xml:space="preserve">
          <source>SQLite is required to &lt;b&gt;implement isolated transactions&lt;/b&gt; (the 'I' from the ACID acronym).</source>
          <target state="translated">SQLite는 &lt;b&gt;격리 된 트랜잭션&lt;/b&gt; (ACID 약어의 'I') 을 &lt;b&gt;구현&lt;/b&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b642e02aa031422407ba1e2eb9a921d7af9484d1" translate="yes" xml:space="preserve">
          <source>SQLite is resilient in the face of corrupt inputs, including maliciously designed database files and SQL strings. Extensive fuzz-testing ensures that corrupt inputs will not lead to crashes or undefined behavior, but will instead cause sensible errors to be reported back to the application.</source>
          <target state="translated">SQLite는 악의적으로 설계된 데이터베이스 파일 및 SQL 문자열을 포함하여 손상된 입력에 대해 복원력이 뛰어납니다. 광범위한 퍼지 테스트는 손상된 입력으로 인해 충돌이 발생하거나 정의되지 않은 동작이 발생하지 않고 대신 응용 프로그램에 합리적인 오류가보고되도록합니다.</target>
        </trans-unit>
        <trans-unit id="80231535020620422bab08d0c25caafae2be3ab2" translate="yes" xml:space="preserve">
          <source>SQLite is resilient in the face of corrupt inputs, including maliciously designed database files and SQL strings. Extensive fuzz-testing ensures that corrupt inputs will not lead to crashes or undefined behavior, but will instead cause sensible errors to be reported back to the application. (&lt;a href=&quot;security&quot;&gt;More...&lt;/a&gt;)</source>
          <target state="translated">SQLite는 악의적으로 설계된 데이터베이스 파일 및 SQL 문자열을 포함하여 손상된 입력에 대해 탄력적입니다. 광범위한 퍼즈 테스트를 통해 손상된 입력이 충돌이나 정의되지 않은 동작으로 이어지지 않고 대신 애플리케이션에 다시보고되는 현명한 오류를 유발합니다. ( &lt;a href=&quot;security&quot;&gt;더 ...&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f5423cc6a7fa9f9530e2a51fe8a881bbb932c031" translate="yes" xml:space="preserve">
          <source>SQLite is slower at creating new indices. This is not a huge problem (since new indices are not created very often) but it is something that is being worked on. Hopefully, future versions of SQLite will do better here.</source>
          <target state="translated">SQLite는 새로운 인덱스 생성 속도가 느립니다. 이것은 새로운 문제가 자주 발생하지 않기 때문에 큰 문제는 아니지만 해결하려는 문제입니다. 다행스럽게도 향후 버전의 SQLite가 더 잘 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="54a5009f6cdb462eb942bac870b07db8a1670fab" translate="yes" xml:space="preserve">
          <source>SQLite is slower than the other databases when it comes to dropping tables. This probably is because when SQLite drops a table, it has to go through and erase the records in the database file that deal with that table. MySQL and PostgreSQL, on the other hand, use separate files to represent each table so they can drop a table simply by deleting a file, which is much faster.</source>
          <target state="translated">SQLite는 테이블을 삭제할 때 다른 데이터베이스보다 느립니다. SQLite가 테이블을 삭제하면 해당 테이블을 처리하는 데이터베이스 파일의 레코드를 거쳐 삭제해야하기 때문일 수 있습니다. 반면에 MySQL과 PostgreSQL은 별도의 파일을 사용하여 각 테이블을 나타내므로 파일을 삭제하여 테이블을 삭제하는 것이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="d7366e08ffe20946fd76e62d62945bcc30d399f9" translate="yes" xml:space="preserve">
          <source>SQLite is threadsafe because it uses mutexes to serialize access to common data structures. However, the work of acquiring and releasing these mutexes will slow SQLite down slightly. Hence, if you do not need SQLite to be threadsafe, you should disable the mutexes for maximum performance. See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">SQLite는 뮤텍스를 사용하여 공통 데이터 구조에 대한 액세스를 직렬화하기 때문에 스레드로부터 안전합니다. 그러나 이러한 뮤텍스를 가져 와서 해제하면 SQLite가 약간 느려집니다. 따라서 스레드 안전을 위해 SQLite가 필요하지 않은 경우 최대 성능을 위해 뮤텍스를 비활성화해야합니다. 추가 정보 는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cd3013ad5660f204f66ad31e2c31dd8240e6bb5" translate="yes" xml:space="preserve">
          <source>SQLite is threadsafe. We make this concession since many users choose to ignore the advice given in the previous paragraph. But in order to be thread-safe, SQLite must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1. Both the Windows and Linux precompiled binaries in the distribution are compiled this way. If you are unsure if the SQLite library you are linking against is compiled to be threadsafe you can call the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; interface to find out.</source>
          <target state="translated">SQLite는 스레드 세이프입니다. 많은 사용자가 이전 단락에 제공된 조언을 무시하기로 선택했기 때문에 우리는이 양보를합니다. 그러나 스레드 안전을 위해 SQLite는 SQLITE_THREADSAFE 전 처리기 매크로를 1로 설정하여 컴파일해야합니다. 배포시 Windows 및 Linux 사전 컴파일 된 바이너리는이 방법으로 컴파일됩니다. 링크하는 SQLite 라이브러리가 스레드 안전으로 컴파일되었는지 확실하지 않은 경우 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; 인터페이스를 호출하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39eff500cd7ce6dc1730207961cc564613eaac4f" translate="yes" xml:space="preserve">
          <source>SQLite is transactional, meaning that multiple changes can be grouped together such that either all or none of them occur, and so that the changes can be rolled back if a problem is found prior to commit. This allows an application to make a change incrementally, then run various sanity and consistency checks on the resulting data prior to committing the changes to disk. The &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; DVCS &lt;a href=&quot;http://www.fossil-scm.org/fossil/doc/tip/www/selfcheck.wiki&quot;&gt;uses this technique&lt;/a&gt; to verify that no repository history has been lost prior to each change.</source>
          <target state="translated">SQLite는 트랜잭션 방식이므로 여러 변경 사항을 그룹화하여 모두 또는 전혀 발생하지 않으며 커밋 전에 문제가 발견되면 변경 사항을 롤백 할 수 있습니다. 이를 통해 응용 프로그램은 점진적으로 변경 한 다음 변경 내용을 디스크에 커밋하기 전에 결과 데이터에 대해 다양한 무결성 및 일관성 검사를 실행할 수 있습니다. &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; DVCS는 &lt;a href=&quot;http://www.fossil-scm.org/fossil/doc/tip/www/selfcheck.wiki&quot;&gt;이 기술을 사용하여&lt;/a&gt; 더 저장소 역사는 각 변경 이전에 손실되지 않았 음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="431631b26b413c56876cd9120450d97fb29610b5" translate="yes" xml:space="preserve">
          <source>SQLite is typeless for the purpose of deciding what data is allowed to be stored in a column. But some notion of type comes into play when sorting and comparing data. For these purposes, a column or an expression can be one of two types: &lt;b&gt;numeric&lt;/b&gt; and &lt;b&gt;text&lt;/b&gt;. The sort or comparison may give different results depending on which type of data is being sorted or compared.</source>
          <target state="translated">SQLite는 열에 저장할 수있는 데이터를 결정하기 위해 유형이 없습니다. 그러나 데이터를 정렬하고 비교할 때 일부 유형의 개념이 작동합니다. 이러한 목적으로 열 또는 표현식은 &lt;b&gt;numeric&lt;/b&gt; 및 &lt;b&gt;text&lt;/b&gt; 두 가지 유형 중 하나 일 수 있습니다 . 정렬 또는 비교는 정렬 또는 비교중인 데이터 유형에 따라 다른 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a51a3f7b3710595af5efe3e3c4508040aaab8c5" translate="yes" xml:space="preserve">
          <source>SQLite is very flexible with regard to datatypes.</source>
          <target state="translated">SQLite는 데이터 유형과 관련하여 매우 유연합니다.</target>
        </trans-unit>
        <trans-unit id="09d4e4b5b66b8b33e92f1d4cdf491ca8f18b646b" translate="yes" xml:space="preserve">
          <source>SQLite is very good at doing INSERTs within a transaction, which probably explains why it is so much faster than the other databases at this test.</source>
          <target state="translated">SQLite는 트랜잭션 내에서 INSERT를 수행하는 데 매우 능숙합니다.이 테스트에서 다른 데이터베이스보다 훨씬 빠른 이유를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f9422ec4c9c62f3dc785dbb76b2bd0e31c1307c2" translate="yes" xml:space="preserve">
          <source>SQLite is written in portable C code. Development work occurs on a mix of Linux, Mac, and Windows workstations. The developers use command-line tools and eschew integrated development environments (IDEs) whenever possible. All developers are expected to be fluent with the unix command-line.</source>
          <target state="translated">SQLite는 이식 가능한 C 코드로 작성되었습니다. 개발 작업은 Linux, Mac 및 Windows 워크 스테이션이 혼합되어 수행됩니다. 개발자는 명령 줄 도구를 사용하고 가능할 때마다 통합 개발 환경 (IDE)을 피합니다. 모든 개발자는 유닉스 명령 줄에 능숙해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e1e2d740adcf0319f2b64ec4840724790f32367" translate="yes" xml:space="preserve">
          <source>SQLite itself does not pay any attention to environment variables in this case, though presumably the GetTempPath() system call does. The search algorithm is different for CYGWIN builds. Check the source code for details.</source>
          <target state="translated">이 경우 SQLite 자체는 환경 변수에주의를 기울이지 않지만 아마도 GetTempPath () 시스템 호출은 그렇지 않습니다. 검색 알고리즘은 CYGWIN 빌드와 다릅니다. 자세한 내용은 소스 코드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="04e08b220ef652d98be99d5e0babd01a982e4f55" translate="yes" xml:space="preserve">
          <source>SQLite itself is in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt; and can be used for any purpose. But TH3 is proprietary and requires a license.</source>
          <target state="translated">SQLite 자체는 &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;공개 도메인에&lt;/a&gt; 있으며 어떤 목적으로도 사용할 수 있습니다. 그러나 TH3은 독점적이며 라이센스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d3d3e9abb52e314e484928a8bc96db9c3ff377a7" translate="yes" xml:space="preserve">
          <source>SQLite just works.</source>
          <target state="translated">SQLite는 작동합니다.</target>
        </trans-unit>
        <trans-unit id="721ec90166a13c1e4ac7e7556c93fcbe5d07f6e2" translate="yes" xml:space="preserve">
          <source>SQLite keeps track of the largest ROWID using an &lt;a href=&quot;fileformat2#intschema&quot;&gt;internal table&lt;/a&gt; named &quot;&lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt;&quot;. The sqlite_sequence table is created and initialized automatically whenever a normal table that contains an AUTOINCREMENT column is created. The content of the sqlite_sequence table can be modified using ordinary UPDATE, INSERT, and DELETE statements. But making modifications to this table will likely perturb the AUTOINCREMENT key generation algorithm. Make sure you know what you are doing before you undertake such changes. The sqlite_sequence table does not track ROWID changes associated with UPDATE statement, only INSERT statements.</source>
          <target state="translated">SQLite 는 &quot; &lt;a href=&quot;fileformat2#seqtab&quot;&gt;sqlite_sequence&lt;/a&gt; &quot; 라는 &lt;a href=&quot;fileformat2#intschema&quot;&gt;내부 테이블을&lt;/a&gt; 사용하여 가장 큰 ROWID를 추적합니다 . sqlite_sequence 테이블은 AUTOINCREMENT 컬럼을 포함하는 일반 테이블이 작성 될 때마다 자동으로 작성되고 초기화됩니다. sqlite_sequence 테이블의 내용은 일반적인 UPDATE, INSERT 및 DELETE 문을 사용하여 수정할 수 있습니다. 그러나이 테이블을 수정하면 AUTOINCREMENT 키 생성 알고리즘이 혼란 스러울 수 있습니다. 그러한 변경을 수행하기 전에 현재하고있는 일을 알아야합니다. sqlite_sequence 테이블은 UPDATE 문과 연관된 ROWID 변경 사항을 추적하지 않으며 INSERT 문만 추적합니다.</target>
        </trans-unit>
        <trans-unit id="1fdbbf49537d5896499e4f580d89d3d977843a76" translate="yes" xml:space="preserve">
          <source>SQLite lets me insert a string into a database column of type integer!</source>
          <target state="translated">SQLite를 사용하면 정수 유형의 데이터베이스 열에 문자열을 삽입 할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="e525cc6d45550b4b1a265dd25df50cc71c4474b0" translate="yes" xml:space="preserve">
          <source>SQLite limits the depth of recursion of triggers in order to prevent a statement involving recursive triggers from using an unbounded amount of memory.</source>
          <target state="translated">SQLite는 재귀 트리거와 관련된 명령문이 무제한의 메모리를 사용하지 못하도록 트리거 재귀 깊이를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bb5977c1cc25afeb2b0e4bd5a50680da96bdd766" translate="yes" xml:space="preserve">
          <source>SQLite makes a copy of the content of the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object so the object can be modified after the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; call returns.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 객체 의 내용을 복사 하므로 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 호출이 반환 된 후 객체를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1791cae0a6c7259639f6781e55e553d509ec456" translate="yes" xml:space="preserve">
          <source>SQLite makes no guarantees about the order of results if a SELECT omits the ORDER BY clause. Even so, the order of results does not change from one run to the next, and so many applications mistakenly come to depend on the arbitrary output order whatever that order happens to be. However, sometimes new versions of SQLite will contain optimizer enhancements that will cause the output order of queries without ORDER BY clauses to shift. When that happens, applications that depend on a certain output order might malfunction. By running the application multiple times with this pragma both disabled and enabled, cases where the application makes faulty assumptions about output order can be identified and fixed early, reducing problems that might be caused by linking against a different version of SQLite.</source>
          <target state="translated">SELECT는 ORDER BY 절을 생략하면 SQLite는 결과 순서를 보증하지 않습니다. 그럼에도 불구하고 결과의 순서는 한 실행에서 다음 실행으로 변경되지 않으므로 많은 응용 프로그램이 순서에 관계없이 임의의 출력 순서에 의존하게됩니다. 그러나 때때로 새로운 버전의 SQLite에는 ORDER BY 절이없는 쿼리의 출력 순서가 바뀌는 최적화 기능이 향상됩니다. 이 경우 특정 출력 순서에 의존하는 응용 프로그램이 오작동 할 수 있습니다. 이 pragma를 사용 안함 및 사용으로 애플리케이션을 여러 번 실행하면 애플리케이션이 출력 순서에 대해 잘못된 가정을하는 경우를 조기에 식별하고 수정할 수 있으므로 다른 버전의 SQLite에 대한 링크로 인해 발생할 수있는 문제점을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0ac4bc4025ad0a187612fd2738f58e087756b50" translate="yes" xml:space="preserve">
          <source>SQLite manipulates the contents of the file-system using a combination of the following four types of operation:</source>
          <target state="translated">SQLite는 다음 네 가지 유형의 작업 조합을 사용하여 파일 시스템의 내용을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="cd796a8c085bea850ea98c0f816e6ce6c1055032" translate="yes" xml:space="preserve">
          <source>SQLite may attempt to convert values between the storage classes INTEGER, REAL, and/or TEXT before performing a comparison. Whether or not any conversions are attempted before the comparison takes place depends on the type affinity of the operands.</source>
          <target state="translated">SQLite는 비교를 수행하기 전에 스토리지 클래스 INTEGER, REAL 및 / 또는 TEXT 간의 값 변환을 시도 할 수 있습니다. 비교를 수행하기 전에 변환을 시도할지 여부는 피연산자의 유형 선호도에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="86322113b50354d8e93e1a8d65dbbd7e579ef951" translate="yes" xml:space="preserve">
          <source>SQLite may make use of transient indices to implement SQL language features such as:</source>
          <target state="translated">SQLite는 다음과 같은 SQL 언어 기능을 구현하기 위해 임시 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692bd1d4aef60fc758b11851675895cb10aedde7" translate="yes" xml:space="preserve">
          <source>SQLite might also add one of the following flags to the xOpen method:</source>
          <target state="translated">SQLite는 xOpen 메소드에 다음 플래그 중 하나를 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="945af510f90e6578c1019b41a7ec0b83b8498700" translate="yes" xml:space="preserve">
          <source>SQLite might use a skip-scan on an index if it knows that the first one or more columns contain many duplication values. If there are too few duplicates in the left-most columns of the index, then it would be faster to simply step ahead to the next value, and thus do a full table scan, than to do a binary search on an index to locate the next left-column value.</source>
          <target state="translated">SQLite는 첫 번째 하나 이상의 열에 많은 중복 값이 ​​포함되어 있음을 알고 있으면 인덱스에서 건너 뛰기 스캔을 사용할 수 있습니다. 인덱스의 가장 왼쪽 열에 중복이 너무 적 으면 인덱스에서 이진 검색을 수행하는 것보다 단순히 다음 값으로 진행하여 전체 테이블 스캔을 수행하는 것이 더 빠릅니다. 다음 왼쪽 열 값</target>
        </trans-unit>
        <trans-unit id="ae7f6237fc49c4f40b5f79296508bbf096f1c300" translate="yes" xml:space="preserve">
          <source>SQLite must see the journal files in order to recover from a crash or power failure. If the &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;hot journal files&lt;/a&gt; are moved, deleted, or renamed after a crash or power failure, then automatic recovery will not work and the database may go corrupt.</source>
          <target state="translated">충돌 또는 정전으로부터 복구하려면 SQLite가 저널 파일을 확인해야합니다. 는 IF &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;뜨거운 저널 파일을&lt;/a&gt; 이동, 삭제, 또는 충돌이나 정전 후 이름을 바꾼 후 자동 복구가 작동하지 않습니다 데이터베이스가 손상 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e833260d531c8e2e412472ff105b04979b5cf7c" translate="yes" xml:space="preserve">
          <source>SQLite mutexes can also be disabled at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. To completely disable all mutexing, the application can invoke:</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 런타임에 SQLite 뮤텍스를 비활성화 할 수도 있습니다 . 모든 뮤텍스를 완전히 비활성화하기 위해 응용 프로그램은 다음을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17328ec696bc91982c93295b65652b033f2ec296" translate="yes" xml:space="preserve">
          <source>SQLite needs to know if the native byte order of the target CPU is big-endian or little-ending. The SQLITE_BYTEORDER preprocessor is set to 4321 for big-endian machines and 1234 for little-endian machines, or it can be 0 to mean that the byte order must be determined at run-time. There are #ifdefs in the code that set SQLITE_BYTEORDER automatically for all common platforms and compilers. However, it may be advantageous to set SQLITE_BYTEORDER appropriately when compiling SQLite for obscure targets. If the target byte order cannot be determined at compile-time, then SQLite falls back to doing run-time checks, which always work, though with a small performance penalty.</source>
          <target state="translated">SQLite는 대상 CPU의 기본 바이트 순서가 빅 엔디안인지 아니면 리틀 엔딩인지 알아야합니다. SQLITE_BYTEORDER 프리 프로세서는 빅 엔디안 머신의 경우 4321, 리틀 엔디안 머신의 경우 1234로 설정되거나 바이트 순서가 런타임시 결정되어야 함을 의미하는 0 일 수 있습니다. 모든 공통 플랫폼 및 컴파일러에 대해 SQLITE_BYTEORDER를 자동으로 설정하는 #ifdef가 코드에 있습니다. 그러나 모호한 대상에 대해 SQLite를 컴파일 할 때 SQLITE_BYTEORDER를 적절하게 설정하는 것이 유리할 수 있습니다. 컴파일 타임에 대상 바이트 순서를 결정할 수 없으면 SQLite는 런타임 검사를 수행합니다.이 검사는 성능 저하가 거의 없지만 항상 작동합니다.</target>
        </trans-unit>
        <trans-unit id="eec4b7f1b229092638c755d579865f53adc26ae9" translate="yes" xml:space="preserve">
          <source>SQLite never assumes atomic page writes &lt;em&gt;in its default configurations&lt;/em&gt;. But a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can set one of the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; bits in the result of the xDeviceCharacteristic() method and then SQLite will assume that page writes are atomic. The application must supply a custom VFS to accomplish this, however, since none of the standard VFSes will ever set any of the atomic bits in the xDeviceCharacteristics() vector.</source>
          <target state="translated">SQLite &lt;em&gt;는 기본 구성에서&lt;/em&gt; 원자 페이지 쓰기 &lt;em&gt;를&lt;/em&gt; 가정하지 않습니다 . 그러나 사용자 정의 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 xDeviceCharacteristic () 메소드의 결과에서 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_ATOMIC&lt;/a&gt; 비트 중 하나를 설정할 수 있으며 SQLite는 페이지 쓰기가 원자 적이라고 가정합니다. 그러나 표준 VFS 중 어느 것도 xDeviceCharacteristics () 벡터에 원자 비트를 설정하지 않으므로 응용 프로그램은이를 수행하기 위해 사용자 지정 VFS를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e50c611c2a64f7dc9dc711887d5a6dcc24f10de" translate="yes" xml:space="preserve">
          <source>SQLite never assumes that database page writes are atomic, regardless of the PSOW setting.&lt;sup&gt;(1)&lt;/sup&gt; And hence SQLite is always able to automatically recover from torn pages induced by a crash. Enabling PSOW does not decrease SQLite's ability to recover from a torn page.</source>
          <target state="translated">SQLite는 PSOW 설정에 관계없이 데이터베이스 페이지 쓰기가 원 자성이라고 가정하지 않습니다. &lt;sup&gt;(1)&lt;/sup&gt; 따라서 SQLite는 충돌로 인한 찢어진 페이지에서 항상 자동으로 복구 할 수 있습니다. PSOW를 활성화해도 찢어진 페이지에서 복구하는 SQLite의 기능은 감소하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a73150dbd46d3caaecfb727306a8488e11089c46" translate="yes" xml:space="preserve">
          <source>SQLite normally stores all content in a single disk file. However, while performing a transaction, information necessary to recover the database following a crash or power failure is stored in auxiliary journal files. Such journal files are described as &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;&quot;hot&quot;&lt;/a&gt;. The journal files have the same name as the original database file with the addition of &lt;code&gt;-journal&lt;/code&gt; or &lt;code&gt;-wal&lt;/code&gt; suffix.</source>
          <target state="translated">SQLite는 일반적으로 모든 내용을 단일 디스크 파일에 저장합니다. 그러나 트랜잭션을 수행하는 동안 충돌 또는 정전 후 데이터베이스를 복구하는 데 필요한 정보는 보조 저널 파일에 저장됩니다. 이러한 저널 파일은 &lt;a href=&quot;fileformat2#hotjrnl&quot;&gt;&quot;hot&quot;으로&lt;/a&gt; 설명됩니다 . 저널 파일의 추가와 함께 원본 데이터베이스 파일과 동일한 이름이 &lt;code&gt;-journal&lt;/code&gt; 또는 &lt;code&gt;-wal&lt;/code&gt; 접미사.</target>
        </trans-unit>
        <trans-unit id="7c2764b7ab8c8fe2115410e837d5a49ba37682ad" translate="yes" xml:space="preserve">
          <source>SQLite now honors the UNIQUE keyword in CREATE UNIQUE INDEX. Primary keys are required to be unique.</source>
          <target state="translated">SQLite는 이제 CREATE UNIQUE INDEX에서 UNIQUE 키워드를 사용합니다. 기본 키는 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b528bcd272bd4532c5fdb40cce96437b126ffc1d" translate="yes" xml:space="preserve">
          <source>SQLite now implements all of its built-in functions using this interface. For additional information and examples on how to create new SQL functions, review the SQLite source code in the file &lt;b&gt;func.c&lt;/b&gt;.</source>
          <target state="translated">SQLite는 이제이 인터페이스를 사용하여 모든 내장 함수를 구현합니다. 새 SQL 함수를 작성하는 방법에 대한 추가 정보 및 예제는 &lt;b&gt;func.c&lt;/b&gt; 파일에서 SQLite 소스 코드를 검토하십시오 .</target>
        </trans-unit>
        <trans-unit id="741c17c0aae3a15bc76f9c3b0feb23ceb419b07b" translate="yes" xml:space="preserve">
          <source>SQLite only supports one writer at a time per database file. But in most cases, a write transaction only takes milliseconds and so multiple writers can simply take turns. SQLite will handle more write concurrency that many people suspect. Nevertheless, client/server database systems, because they have a long-running server process at hand to coordinate access, can usually handle far more write concurrency than SQLite ever will.</source>
          <target state="translated">SQLite는 데이터베이스 파일 당 한 번에 하나의 기록기 만 지원합니다. 그러나 대부분의 경우 쓰기 트랜잭션은 밀리 초에 불과하므로 여러 작성자가 간단히 전환 할 수 있습니다. SQLite는 많은 사람들이 의심하는 더 많은 쓰기 동시성을 처리합니다. 그럼에도 불구하고 클라이언트 / 서버 데이터베이스 시스템은 액세스를 조정하기 위해 오랫동안 실행되는 서버 프로세스를 가지고 있기 때문에 일반적으로 SQLite보다 훨씬 많은 쓰기 동시성을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbe82e83c540bf7ce2e1eadb8c5b0e3352775de" translate="yes" xml:space="preserve">
          <source>SQLite parses MATCH clauses (i.e. does not report a syntax error if you specify one), but does not enforce them. All foreign key constraints in SQLite are handled as if MATCH SIMPLE were specified.</source>
          <target state="translated">SQLite는 MATCH 절을 구문 분석하고 (구문을 지정하면 구문 오류를보고하지 않음) 강제로 적용하지 않습니다. SQLite의 모든 외래 키 제약 조건은 MATCH SIMPLE이 지정된 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c52abe2b4224c19357e2fb51b9983ebbf48e0915" translate="yes" xml:space="preserve">
          <source>SQLite parses expressions into a tree for processing. During code generation, SQLite walks this tree recursively. The depth of expression trees is therefore limited in order to avoid using too much stack space.</source>
          <target state="translated">SQLite는 처리를 위해 표현식을 트리로 구문 분석합니다. 코드 생성 중에 SQLite는이 트리를 재귀 적으로 안내합니다. 따라서 스택 공간을 너무 많이 사용하지 않도록 식 트리의 깊이가 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="52651f8e847f0d13fb28fbf85a29bff92a837a41" translate="yes" xml:space="preserve">
          <source>SQLite processes this by gathering all the output of query and then running that output through a sorter.</source>
          <target state="translated">SQLite는 쿼리의 모든 출력을 수집 한 다음 분류기를 통해 해당 출력을 실행하여이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fe52b85233b043a411af65af0db61d939caa292e" translate="yes" xml:space="preserve">
          <source>SQLite provides a number of enhancements to the SQL language not normally found in other database engines. The EXPLAIN keyword and manifest typing have already been mentioned above. SQLite also provides statements such as &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; and the &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause that allow for added control over the resolution of constraint conflicts. SQLite supports &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands that allow multiple independent databases to be used together in the same query. And SQLite defines APIs that allows the user to add new &lt;a href=&quot;c3ref/create_function&quot;&gt;SQL functions&lt;/a&gt; and &lt;a href=&quot;c3ref/create_collation&quot;&gt;collating sequences&lt;/a&gt;.</source>
          <target state="translated">SQLite는 다른 데이터베이스 엔진에서 일반적으로 볼 수없는 SQL 언어에 대한 여러 가지 향상된 기능을 제공합니다. EXPLAIN 키워드 및 매니페스트 입력은 이미 위에서 언급했습니다. SQLite는 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 및 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절 과 같은 문을 제공 하여 제약 조건 충돌 해결을 추가로 제어 할 수 있습니다. SQLite는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; 명령을 지원하므로 여러 독립 데이터베이스를 동일한 쿼리에서 함께 사용할 수 있습니다. 그리고 SQLite는 사용자가 새로운 &lt;a href=&quot;c3ref/create_function&quot;&gt;SQL 함수&lt;/a&gt; 와 &lt;a href=&quot;c3ref/create_collation&quot;&gt;조합 순서&lt;/a&gt; 를 추가 할 수있는 API를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="75b33c10e4ae0dc9caa69a9b718ca24a25cbfeba" translate="yes" xml:space="preserve">
          <source>SQLite provides isolation between operations in separate database connections. However, there is no isolation between operations that occur within the same database connection.</source>
          <target state="translated">SQLite는 별도의 데이터베이스 연결에서 작업을 분리합니다. 그러나 동일한 데이터베이스 연결 내에서 발생하는 작업 간에는 격리가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a19562eb5d14931c391924201db74f2b2170510" translate="yes" xml:space="preserve">
          <source>SQLite provides the ability for advanced programmers to exercise control over the query plan chosen by the optimizer. One method for doing this is to fudge the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; results in the &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt;, &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt;, and/or &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; tables. That approach is not recommended except for the one scenario described in the next paragraph.</source>
          <target state="translated">SQLite는 고급 프로그래머가 옵티마이 저가 선택한 쿼리 계획을 제어 할 수있는 기능을 제공합니다. 이를 수행하는 한 가지 방법 은 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1&lt;/a&gt; , &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; 및 / 또는 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 테이블 에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 결과를 제거하는 것 입니다. 이 방법은 다음 단락에서 설명하는 시나리오를 제외하고는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="069bcc6cce5ca3be769be9d7d5d38ef69d29560b" translate="yes" xml:space="preserve">
          <source>SQLite provides these two interfaces for reporting on the status of the &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc()&lt;/a&gt; routines, which form the built-in memory allocation subsystem.</source>
          <target state="translated">SQLite는 내장 메모리 할당 서브 시스템을 구성하는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 루틴 의 상태를보고하기 위해이 두 가지 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="5be5efeb16b0a34b3e2605cf2967c7a9f9f4502b" translate="yes" xml:space="preserve">
          <source>SQLite provides these two interfaces for reporting on the status of the &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;free&quot;&gt;sqlite3_realloc()&lt;/a&gt; routines, which form the built-in memory allocation subsystem.</source>
          <target state="translated">SQLite는 내장 메모리 할당 서브 시스템을 구성하는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 루틴 의 상태를보고하기 위해이 두 가지 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="796f29585c117f2d84f8816579b3c6eeec799286" translate="yes" xml:space="preserve">
          <source>SQLite queries an implementation for file-system characteristics using the xDeviceCharacteristics() and xSectorSize() methods of the database file file-handle. These two methods are only ever called on file-handles open on database files. They are not called for</source>
          <target state="translated">SQLite는 데이터베이스 파일 파일 핸들의 xDeviceCharacteristics () 및 xSectorSize () 메서드를 사용하여 파일 시스템 특성 구현을 쿼리합니다. 이 두 가지 방법은 데이터베이스 파일에서 열린 파일 핸들에서만 호출됩니다. 그들은 요구되지 않았다</target>
        </trans-unit>
        <trans-unit id="1001eecb9650b8452d3fe909aaa11b4544423e7e" translate="yes" xml:space="preserve">
          <source>SQLite reads and writes small blobs (for example, thumbnail images) &lt;a href=&quot;#approx&quot;&gt;35% faster&amp;sup1;&lt;/a&gt; than the same blobs can be read from or written to individual files on disk using fread() or fwrite().</source>
          <target state="translated">SQLite는 &lt;a href=&quot;#approx&quot;&gt;flob&lt;/a&gt; () 또는 fwrite ()를 사용하여 동일한 BLOB을 디스크의 개별 파일에서 읽거나 쓸 수있는 것보다 작은 Blob (예 : 축소판 이미지)을 35 % 더 빠르게 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="35d70ea0800f08a06761cd47e896b93495f4c9c9" translate="yes" xml:space="preserve">
          <source>SQLite responds gracefully to system errors. Obscure out-of-memory and I/O errors are reported back up to the application. These error reporting paths are all carefully tested to ensure they will always work.</source>
          <target state="translated">SQLite는 시스템 오류에 정상적으로 응답합니다. 메모리 부족 및 I / O 오류가 애플리케이션에 다시보고됩니다. 이러한 오류보고 경로는 항상 작동하는지 확인하기 위해 신중하게 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="23423829c41e2a290e377832f71a840c666910a0" translate="yes" xml:space="preserve">
          <source>SQLite seems to be a popular target for third-parties to fuzz. The developers hear about many attempts to fuzz SQLite and they do occasionally get bug reports found by independent fuzzers. All such reports are promptly fixed, so the product is improved and that the entire SQLite user community benefits. This mechanism of having many independent testers is similar to &lt;a href=&quot;https://en.wikipedia.org/wiki/Linus%27s_law&quot;&gt;Linus's law&lt;/a&gt;: &quot;given enough eyeballs, all bugs are shallow&quot;.</source>
          <target state="translated">SQLite는 제 3자가 퍼징하는 인기있는 대상인 것 같습니다. 개발자는 SQLite를 퍼징하려는 많은 시도에 대해 듣고 때때로 독립적 인 퍼 저가 발견 한 버그 보고서를받습니다. 이러한 모든 보고서는 즉시 수정되므로 제품이 개선되고 전체 SQLite 사용자 커뮤니티에 도움이됩니다. 많은 독립적 인 테스터를 보유하는이 메커니즘은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Linus%27s_law&quot;&gt;Linus의 법칙&lt;/a&gt; 과 유사합니다 . &quot;충분한 시선이 주어지면 모든 버그는 얕습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="7c0c283f7e4e05e8236569bff26a222a275bf7f9" translate="yes" xml:space="preserve">
          <source>SQLite shall attempt to obtain an</source>
          <target state="translated">SQLite는</target>
        </trans-unit>
        <trans-unit id="fc4b26fb3a3dbd3635c28a9c88ca506e8fda6086" translate="yes" xml:space="preserve">
          <source>SQLite shall ensure that a</source>
          <target state="translated">SQLite는</target>
        </trans-unit>
        <trans-unit id="68cdf5c9c482135a76a154ad68cc4116ae97dcc7" translate="yes" xml:space="preserve">
          <source>SQLite shall write the page data into the database file, using a single call to the xWrite method of the</source>
          <target state="translated">SQLite는 xWrite 메소드의 단일 호출을 사용하여 페이지 데이터를 데이터베이스 파일에 기록합니다.</target>
        </trans-unit>
        <trans-unit id="740a9f7c5b70a08a25f10f9d2fba2d5ac406ba97" translate="yes" xml:space="preserve">
          <source>SQLite should never crash, overflow a buffer, leak memory, or exhibit any other harmful behavior, even when presented with maliciously malformed SQL inputs or database files. SQLite should always detect erroneous inputs and raise an error, not crash or corrupt memory. Any malfunction caused by an SQL input or database file is considered a serious bug and will be promptly addressed when brought to the attention of the SQLite developers. SQLite is extensively fuzz-tested to help ensure that it is resistant to these kinds of errors.</source>
          <target state="translated">악의적으로 잘못된 SQL 입력 또는 데이터베이스 파일이 표시되는 경우에도 SQLite는 충돌, 버퍼 오버플로, 메모리 누수 또는 기타 유해한 행동을 나타내지 않아야합니다. SQLite는 항상 잘못된 입력을 감지하고 충돌이나 메모리 손상이 아닌 오류를 발생시켜야합니다. SQL 입력 또는 데이터베이스 파일로 인한 오작동은 심각한 버그로 간주되며 SQLite 개발자의주의를 끌면 즉시 해결됩니다. SQLite는 이러한 종류의 오류에 대한 내성을 보장하기 위해 광범위한 퍼지 테스트를 거쳤습니다.</target>
        </trans-unit>
        <trans-unit id="8394c39a29a6c802cb3baaa5a9c23f7e97f8a73c" translate="yes" xml:space="preserve">
          <source>SQLite solves this problem by using a</source>
          <target state="translated">SQLite는 다음을 사용하여이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="a17840ca9490a98d4558d4de1067d407ae4f9392" translate="yes" xml:space="preserve">
          <source>SQLite source code is managed using the &lt;a href=&quot;https://fossil-scm.org&quot;&gt;Fossil&lt;/a&gt; version control system. Fossil was written specifically to support SQLite development. Fossil provides both distributed version control and issue tracking.</source>
          <target state="translated">SQLite 소스 코드는 &lt;a href=&quot;https://fossil-scm.org&quot;&gt;Fossil&lt;/a&gt; 버전 제어 시스템을 사용하여 관리 됩니다. 화석은 SQLite 개발을 지원하기 위해 특별히 작성되었습니다. Fossil은 분산 버전 제어 및 문제 추적을 모두 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa87de437d401b498b7d8eb223dcf3f87cf0893d" translate="yes" xml:space="preserve">
          <source>SQLite sources are maintained on three geographically dispersed servers:</source>
          <target state="translated">SQLite 소스는 지리적으로 분산 된 세 개의 서버에서 유지 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="e02e50c5282bb5b0a3a678ffe1050ddfbc21a817" translate="yes" xml:space="preserve">
          <source>SQLite stores an entire database within a single file, the format of which is described in the</source>
          <target state="translated">SQLite는 전체 데이터베이스를 단일 파일 내에 저장하며 그 형식은</target>
        </trans-unit>
        <trans-unit id="1a0b29ed9ca13970622475438234a3b6eb2529a8" translate="yes" xml:space="preserve">
          <source>SQLite strives to implement ORDER BY clauses using a preexisting index. If an appropriate index already exists, SQLite will walk the index, rather than the underlying table, to extract the requested information, and thus cause the rows to come out in the desired order. But if SQLite cannot find an appropriate index it will evaluate the query and store each row in a transient index whose data is the row data and whose key is the ORDER BY terms. After the query is evaluated, SQLite goes back and walks the transient index from beginning to end in order to output the rows in the desired order.</source>
          <target state="translated">SQLite는 기존 색인을 사용하여 ORDER BY 절을 구현하려고합니다. 적절한 인덱스가 이미 존재하면 SQLite는 기본 테이블이 아닌 인덱스를 따라 이동하여 요청 된 정보를 추출하므로 원하는 순서대로 행이 나오게됩니다. 그러나 SQLite가 적절한 인덱스를 찾지 못하면 쿼리를 평가하고 각 행을 데이터가 행 데이터이고 키가 ORDER BY 용어 인 임시 인덱스에 저장합니다. 쿼리가 평가 된 후 SQLite는 원하는 순서로 행을 출력하기 위해 임시 인덱스를 처음부터 끝까지 거꾸로 걸어갑니다.</target>
        </trans-unit>
        <trans-unit id="79801eb3ee90b8531950935fcb700e5d7936b51b" translate="yes" xml:space="preserve">
          <source>SQLite strives to keep error logger traffic low and only send messages to the error logger when there really is something wrong. Applications might further cull the error message traffic by deliberately ignore certain classes of error messages that they do not care about. For example, an application that makes frequent database schema changes might want to ignore all SQLITE_SCHEMA errors.</source>
          <target state="translated">SQLite는 오류 로거 트래픽을 낮게 유지하고 실제로 오류가있을 때만 오류 로거에게 메시지를 보내려고합니다. 응용 프로그램은 의도하지 않은 특정 종류의 오류 메시지를 고의로 무시하여 오류 메시지 트래픽을 추가로 차단할 수 있습니다. 예를 들어, 데이터베이스 스키마를 자주 변경하는 응용 프로그램은 모든 SQLITE_SCHEMA 오류를 무시하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76b7bc709cc1bfb344641faff586e57a6d874b11" translate="yes" xml:space="preserve">
          <source>SQLite strives to verify that every branch instruction makes a difference using &lt;a href=&quot;https://en.wikipedia.org/wiki/Mutation_testing&quot;&gt;mutation testing&lt;/a&gt;. &lt;a href=&quot;th3#muttest&quot;&gt;A script&lt;/a&gt; first compiles the SQLite source code into assembly language (using, for example, the -S option to gcc). Then the script steps through the generated assembly language and, one by one, changes each branch instruction into either an unconditional jump or a no-op, compiles the result, and verifies that the test suite catches the mutation.</source>
          <target state="translated">SQLite는 모든 분기 명령어가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Mutation_testing&quot;&gt;돌연변이 테스트를&lt;/a&gt; 사용하여 차이를 만드는지 확인하려고 노력합니다 . &lt;a href=&quot;th3#muttest&quot;&gt;스크립트는&lt;/a&gt; 먼저 SQLite 소스 코드를 어셈블리 언어로 컴파일합니다 (예 : gcc에 -S 옵션 사용). 그런 다음 스크립트는 생성 된 어셈블리 언어를 단계별로 살펴보고 각 분기 명령어를 무조건 점프 또는 무 작동으로 변경하고 결과를 컴파일하고 테스트 스위트가 돌연변이를 포착하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="61116c736ec15bc5b4fb2fc6a87d1890ff944be5" translate="yes" xml:space="preserve">
          <source>SQLite supports a limited subset of ALTER TABLE. The ALTER TABLE command in SQLite allows the user to rename a table, to rename a column within a table, or to add a new column to an existing table.</source>
          <target state="translated">SQLite는 ALTER TABLE의 제한된 하위 집합을 지원합니다. SQLite의 ALTER TABLE 명령을 사용하면 테이블 이름을 바꾸거나 테이블 내의 열 이름을 바꾸거나 기존 테이블에 새 열을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fa3301d9a603d43c374c933699b5b685c255796" translate="yes" xml:space="preserve">
          <source>SQLite supports an unlimited number of simultaneous readers, but it will only allow one writer at any instant in time. For many situations, this is not a problem. Writers queue up. Each application does its database work quickly and moves on, and no lock lasts for more than a few dozen milliseconds. But there are some applications that require more concurrency, and those applications may need to seek a different solution.</source>
          <target state="translated">SQLite는 무제한의 동시 판독기를 지원하지만 한 번에 한 명의 작성자 만 허용합니다. 많은 상황에서 이것은 문제가되지 않습니다. 작가가 대기합니다. 각 응용 프로그램은 데이터베이스가 빠르게 작동하고 계속 진행하며 수십 밀리 초 이상 동안 잠금이 지속되지 않습니다. 그러나 더 많은 동시성이 필요한 일부 응용 프로그램이 있으며 해당 응용 프로그램은 다른 솔루션을 찾아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="362a3fd555302c4f1eaf77cb8e7f778518efb28e" translate="yes" xml:space="preserve">
          <source>SQLite supports five date and time functions as follows:</source>
          <target state="translated">SQLite는 다음과 같이 5 개의 날짜 및 시간 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="91957f75e3d4e0fd1006ddb7500b87cbbf67b068" translate="yes" xml:space="preserve">
          <source>SQLite supports many &lt;a href=&quot;lang_corefunc&quot;&gt;simple&lt;/a&gt;, &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate&lt;/a&gt;, and &lt;a href=&quot;windowfunctions&quot;&gt;window&lt;/a&gt; SQL functions. For presentation purposes, simple functions are further subdivided into &lt;a href=&quot;lang_corefunc&quot;&gt;core functions&lt;/a&gt;, &lt;a href=&quot;lang_datefunc&quot;&gt;date-time functions&lt;/a&gt;, and &lt;a href=&quot;json1&quot;&gt;JSON functions&lt;/a&gt;. Applications can add new functions, written in C/C++, using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface.</source>
          <target state="translated">SQLite는 많은 &lt;a href=&quot;lang_corefunc&quot;&gt;단순&lt;/a&gt; , &lt;a href=&quot;lang_aggfunc&quot;&gt;집계&lt;/a&gt; 및 &lt;a href=&quot;windowfunctions&quot;&gt;창&lt;/a&gt; SQL 함수를 지원합니다. 프리젠 테이션 목적으로 간단한 함수는 &lt;a href=&quot;lang_corefunc&quot;&gt;핵심 함수&lt;/a&gt; , &lt;a href=&quot;lang_datefunc&quot;&gt;날짜-시간 함수&lt;/a&gt; 및 &lt;a href=&quot;json1&quot;&gt;JSON 함수&lt;/a&gt; 로 세분됩니다 . 응용 프로그램은 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스를 사용하여 C / C ++로 작성된 새 함수를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8df117e71ae2eb15e7237b9f17e42a408d843570" translate="yes" xml:space="preserve">
          <source>SQLite supports multiple simultaneous read transactions coming from separate database connections, possibly in separate threads or processes, but only one simultaneous write transaction.</source>
          <target state="translated">SQLite는 별도의 스레드 또는 프로세스에서 별도의 데이터베이스 연결에서 오는 여러 동시 읽기 트랜잭션을 지원하지만 동시 쓰기 트랜잭션은 하나만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bb2625e03f106cbbdee7f3db77e634d01593acaa" translate="yes" xml:space="preserve">
          <source>SQLite supports the ability of an application to specify an alternative memory allocator at run-time by filling in an instance of the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object with pointers to the routines of the alternative implementation then registering the new alternative implementation using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. For example:</source>
          <target state="translated">SQLite는 대체 구현의 루틴에 대한 포인터로 &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 오브젝트 의 인스턴스를 채우고 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 새 대체 구현을 등록 함으로써 런타임시 대체 메모리 할당자를 지정할 수있는 애플리케이션 기능을 지원합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="017fb6b291ff89e609d155a096555bd5bbe2c94f" translate="yes" xml:space="preserve">
          <source>SQLite supports the following 11 built-in window functions:</source>
          <target state="translated">SQLite는 다음 11 가지 내장 창 기능을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a02f0bb2b069910c39ea479587454cc5f38daf81" translate="yes" xml:space="preserve">
          <source>SQLite supports three different threading modes:</source>
          <target state="translated">SQLite는 세 가지 스레딩 모드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4014b7a930ff3b73114947a465a719ff6e29de6d" translate="yes" xml:space="preserve">
          <source>SQLite tries to detect misuse and report the misuse using this result code. However, there is no guarantee that the detection of misuse will be successful. Misuse detection is probabilistic. Applications should never depend on an SQLITE_MISUSE return value.</source>
          <target state="translated">SQLite는이 결과 코드를 사용하여 오용을 감지하고 오용을보고하려고합니다. 그러나 오용 탐지에 성공할 것이라는 보장은 없습니다. 오용 탐지는 확률 적입니다. 응용 프로그램은 SQLITE_MISUSE 리턴 값에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="84db0173921e2cbe9f6c615710bf66e073f79708" translate="yes" xml:space="preserve">
          <source>SQLite understands a real table to be a shadow table if all of the following are true:</source>
          <target state="translated">SQLite는 다음을 모두 충족하면 실제 테이블을 새도우 테이블로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="89cbe958d74b15f24f6e6b8bc29bafc1643a7f0d" translate="yes" xml:space="preserve">
          <source>SQLite understands most of the standard SQL language. But it does &lt;a href=&quot;omitted&quot;&gt;omit some features&lt;/a&gt; while at the same time adding a few features of its own. This document attempts to describe precisely what parts of the SQL language SQLite does and does not support. A list of &lt;a href=&quot;lang_keywords&quot;&gt;SQL keywords&lt;/a&gt; is also provided. The SQL language syntax is described by &lt;a href=&quot;syntaxdiagrams&quot;&gt;syntax diagrams&lt;/a&gt;.</source>
          <target state="translated">SQLite는 대부분의 표준 SQL 언어를 이해합니다. 그러나 &lt;a href=&quot;omitted&quot;&gt;일부 기능&lt;/a&gt; 은 생략 하고 동시에 자체 기능을 추가합니다. 이 문서는 SQL 언어 SQLite의 어떤 부분이 지원하고 지원하지 않는지를 정확하게 설명하려고합니다. &lt;a href=&quot;lang_keywords&quot;&gt;SQL 키워드&lt;/a&gt; 목록 도 제공됩니다. SQL 언어 구문은 &lt;a href=&quot;syntaxdiagrams&quot;&gt;구문 다이어그램으로&lt;/a&gt; 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="76a4b937d814efc3107985206c3839b75a40d5c0" translate="yes" xml:space="preserve">
          <source>SQLite understands the following binary operators, in order from highest to lowest precedence:</source>
          <target state="translated">SQLite는 다음과 같은 이진 연산자를 우선 순위가 높은 순서대로 이해합니다.</target>
        </trans-unit>
        <trans-unit id="de40d61f7018c5b48e3c644cbaef8bf7d8b66fd1" translate="yes" xml:space="preserve">
          <source>SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. Content can be stored as INTEGER, REAL, TEXT, BLOB, or as NULL.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;datatype3&quot;&gt;동적 타이핑을&lt;/a&gt; 사용합니다 . 컨텐츠는 INTEGER, REAL, TEXT, BLOB 또는 NULL로 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9e9446caa946736bd5a01f0671ef69ec6cbe7e" translate="yes" xml:space="preserve">
          <source>SQLite uses &lt;code&gt;testcase()&lt;/code&gt; macros as described in the previous subsection to make sure that every condition in a bit-vector decision takes on every possible outcome. In this way, SQLite also achieves 100% MC/DC in addition to 100% branch coverage.</source>
          <target state="translated">SQLite는 이전 하위 섹션에서 설명한대로 &lt;code&gt;testcase()&lt;/code&gt; 매크로를 사용 하여 비트 벡터 결정의 모든 조건이 가능한 모든 결과를 가져 오도록합니다. 이러한 방식으로 SQLite는 100 % 지점 범위 외에 100 % MC / DC도 달성합니다.</target>
        </trans-unit>
        <trans-unit id="d2c828337726f1245db87b3b8499d82386b0261e" translate="yes" xml:space="preserve">
          <source>SQLite uses POSIX advisory locks to implement locking on Unix. On Windows it uses the LockFile(), LockFileEx(), and UnlockFile() system calls. SQLite assumes that these system calls all work as advertised. If that is not the case, then database corruption can result. One should note that POSIX advisory locking is known to be buggy or even unimplemented on many NFS implementations (including recent versions of Mac OS X) and that there are reports of locking problems for network filesystems under Windows. Your best defense is to not use SQLite for files on a network filesystem.</source>
          <target state="translated">SQLite는 POSIX 권고 잠금을 사용하여 Unix에서 잠금을 구현합니다. Windows에서는 LockFile (), LockFileEx () 및 UnlockFile () 시스템 호출을 사용합니다. SQLite는 이러한 시스템 호출이 모두 알려진대로 작동한다고 가정합니다. 그렇지 않은 경우 데이터베이스가 손상 될 수 있습니다. POSIX 권고 잠금은 많은 NFS 구현 (최신 Mac OS X 버전 포함)에서 버그가 있거나 구현되지 않은 것으로 알려져 있으며 Windows의 네트워크 파일 시스템에 대한 잠금 문제에 대한보고가 있습니다. 최선의 방어는 네트워크 파일 시스템의 파일에 SQLite를 사용하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="419f5d6983bf4618f2a5dc1a95258ff9924a25c1" translate="yes" xml:space="preserve">
          <source>SQLite uses a continuous integration process. The software is under constant enhancement and refinement. The latest trunk check-ins are frequently used internally for mission-critical operations.</source>
          <target state="translated">SQLite는 지속적인 통합 프로세스를 사용합니다. 소프트웨어는 지속적으로 향상되고 개선되고 있습니다. 최신 트렁크 체크인은 업무상 중요한 작업을 위해 내부적으로 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1a0520919cdd7c57c0662d504d1dbd0da4f6ed1c" translate="yes" xml:space="preserve">
          <source>SQLite uses a cost-based query planner. When there are two or more ways of solving the same query, SQLite tries to estimate the total amount of time needed to run the query using each plan, and then uses the plan with the lowest estimated cost. A cost is computed mostly from the estimated time, and so this case could go either way depending on the table size and what WHERE clause constraints were available, and so forth. But generally speaking, the indexed sort would probably be chosen, if for no other reason, because it does not need to accumulate the entire result set in temporary storage before sorting and thus uses much less temporary storage.</source>
          <target state="translated">SQLite는 비용 기반 쿼리 플래너를 사용합니다. 동일한 쿼리를 해결하는 두 가지 이상의 방법이있는 경우 SQLite는 각 계획을 사용하여 쿼리를 실행하는 데 필요한 총 시간을 추정 한 다음 예상 비용이 가장 낮은 계획을 사용합니다. 비용은 대부분 예상 시간을 기준으로 계산되므로이 경우 테이블 크기 및 사용 가능한 WHERE 절 제약 조건 등에 따라 달라집니다. 그러나 일반적으로 인덱스 정렬은 다른 이유가 없다면 정렬하기 전에 전체 결과 집합을 임시 저장소에 축적 할 필요가 없으므로 훨씬 적은 임시 저장소를 사용하므로 인덱스 정렬이 선택 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9d581a988a96a28e53beca39811ace9da326e2" translate="yes" xml:space="preserve">
          <source>SQLite uses a more general dynamic type system. In SQLite, the datatype of a value is associated with the value itself, not with its container. The dynamic type system of SQLite is backwards compatible with the more common static type systems of other database engines in the sense that SQL statements that work on statically typed databases should work the same way in SQLite. However, the dynamic typing in SQLite allows it to do things which are not possible in traditional rigidly typed databases.</source>
          <target state="translated">SQLite는보다 일반적인 동적 유형 시스템을 사용합니다. SQLite에서 값의 데이터 유형은 컨테이너가 아니라 값 자체와 연관됩니다. SQLite의 동적 형식 시스템은 정적 형식의 데이터베이스에서 작동하는 SQL 문이 SQLite에서 동일한 방식으로 작동해야한다는 점에서 다른 데이터베이스 엔진의 일반적인 정적 형식 시스템과 호환됩니다. 그러나 SQLite의 동적 타이핑을 사용하면 기존의 엄격한 유형이 지정된 데이터베이스에서는 불가능한 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1b55e0fd7f9c8ac0ebdd30cf39af20d7f2d3b7" translate="yes" xml:space="preserve">
          <source>SQLite uses a page cache of recently read and written database pages. This page cache is used not just for the main database file but also for transient indices and tables stored in temporary files. If SQLite needs to use a temporary index or table and the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter and the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; are set to store temporary tables and index on disk, the information is still initially stored in memory in the page cache. The temporary file is not opened and the information is not truly written to disk until the page cache is full.</source>
          <target state="translated">SQLite는 최근 읽고 쓴 데이터베이스 페이지의 페이지 캐시를 사용합니다. 이 페이지 캐시는 기본 데이터베이스 파일뿐만 아니라 임시 파일에 저장된 임시 색인 및 테이블에도 사용됩니다. SQLite가 임시 인덱스 나 테이블을 사용해야하고 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 타임 매개 변수와 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 가 디스크에 임시 테이블과 인덱스를 저장하도록 설정된 경우 정보는 여전히 초기에 페이지 캐시의 메모리에 저장됩니다. 임시 파일이 열리지 않고 페이지 캐시가 가득 찰 때까지 정보가 실제로 디스크에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b12c1b1b8cc61e32991a698cfd1267c2d0f89edd" translate="yes" xml:space="preserve">
          <source>SQLite uses an efficient &lt;a href=&quot;queryplanner-ng&quot;&gt;query planner algorithm&lt;/a&gt; and so even a large join can be &lt;a href=&quot;c3ref/prepare&quot;&gt;prepared&lt;/a&gt; quickly. Hence, there is no mechanism to raise or lower the limit on the number of tables in a join.</source>
          <target state="translated">SQLite는 효율적인 &lt;a href=&quot;queryplanner-ng&quot;&gt;쿼리 플래너 알고리즘&lt;/a&gt; 을 사용하므로 대규모 조인도 빠르게 &lt;a href=&quot;c3ref/prepare&quot;&gt;준비&lt;/a&gt; 할 수 있습니다 . 따라서 조인의 테이블 수에 대한 제한을 늘리거나 줄일 수있는 메커니즘이 없습니다.</target>
        </trans-unit>
        <trans-unit id="2c5e93f52d20c084674804c93cc58302ab86f180" translate="yes" xml:space="preserve">
          <source>SQLite uses binary arithmetic and in binary, there is no way to write 9.95 in a finite number of bits. The closest to you can get to 9.95 in a 64-bit IEEE float (which is what SQLite uses) is 9.949999999999999289457264239899814128875732421875. So when you type &quot;9.95&quot;, SQLite really understands the number to be the much longer value shown above. And that value rounds down.</source>
          <target state="translated">SQLite는 이진 산술을 사용하며 이진에서는 유한 비트 수로 9.95를 쓸 수있는 방법이 없습니다. 64 비트 IEEE float (SQLite가 사용하는 것)에서 9.95에 가장 가까운 것은 9.949999999999999289457264239899814128875732421875입니다. 따라서 &quot;9.95&quot;를 입력하면 SQLite는 숫자가 위에 표시된 값보다 훨씬 길다는 것을 실제로 이해합니다. 그리고 그 가치는 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="100c32205d77668106f751ddb49a630f21e7c164" translate="yes" xml:space="preserve">
          <source>SQLite uses dynamic memory allocation to obtain memory for storing various objects (ex: &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; and &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;) and to build a memory cache of the database file and to hold the results of queries. Much effort has gone into making the dynamic memory allocation subsystem of SQLite reliable, predictable, robust, secure, and efficient.</source>
          <target state="translated">SQLite는 동적 메모리 할당을 사용하여 다양한 객체 (예 : &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 및 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; ) 를 저장하기위한 메모리를 확보 하고 데이터베이스 파일의 메모리 캐시를 빌드하고 쿼리 결과를 보유합니다. SQLite의 동적 메모리 할당 하위 시스템을 안정적이고 예측 가능하며 강력하고 안전하며 효율적으로 만드는 데 많은 노력을 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="00d6ed4ddbc792f962a9c15a9bfff1ed56a12c03" translate="yes" xml:space="preserve">
          <source>SQLite uses dynamic run-time typing. So just because a column is declared to contain a particular type does not mean that the data stored in that column is of the declared type. SQLite is strongly typed, but the typing is dynamic not static. Type is associated with individual values, not with the containers used to hold those values.</source>
          <target state="translated">SQLite는 동적 런타임 타이핑을 사용합니다. 따라서 열이 특정 유형을 포함하도록 선언되었다고해서 해당 열에 저장된 데이터가 선언 된 유형임을 의미하지는 않습니다. SQLite는 강력하게 입력되지만 입력은 정적이 아닌 동적입니다. 유형은 해당 값을 보유하는 데 사용되는 컨테이너가 아니라 개별 값과 연관됩니다.</target>
        </trans-unit>
        <trans-unit id="e9c675b439e8b045a5761d6f6f634a6e3c87b0d8" translate="yes" xml:space="preserve">
          <source>SQLite uses file locks on the database file, and on the &lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt; or &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; file, to coordinate access between concurrent processes. Without coordination, two threads or processes might try to make incompatible changes to a database file at the same time, resulting in database corruption.</source>
          <target state="translated">SQLite는 데이터베이스 파일과 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; 또는 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 파일에서 파일 잠금을 사용하여 동시 프로세스 간 액세스를 조정합니다. 조정없이 두 개의 스레드 또는 프로세스가 동시에 데이터베이스 파일에 대해 호환되지 않는 변경을 시도하여 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc489b7d0364b55c420255bebe8164eaf3143ec" translate="yes" xml:space="preserve">
          <source>SQLite uses filesystem locks to make sure that only one process and database connection is trying to modify the database at a time. The filesystem locking mechanism is implemented in the VFS layer and is different for every operating system. SQLite depends on this implementation being correct. If something goes wrong and two or more processes are able to write the same database file at the same time, severe damage can result.</source>
          <target state="translated">SQLite는 파일 시스템 잠금을 사용하여 한 번에 하나의 프로세스 및 데이터베이스 연결만으로 데이터베이스를 수정하려고합니다. 파일 시스템 잠금 메커니즘은 VFS 계층에서 구현되며 운영 체제마다 다릅니다. SQLite는이 구현이 올바른지에 달려 있습니다. 문제가 발생하여 두 개 이상의 프로세스가 동일한 데이터베이스 파일을 동시에 쓸 수있는 경우 심각한 손상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c5d3144ca7b57a8fe6bfa7c95d8cd76ffe8cc05" translate="yes" xml:space="preserve">
          <source>SQLite uses one of these integer values as the second argument to calls it makes to the xLock() and xUnlock() methods of an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite는 이러한 정수 값 중 하나를 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xLock () 및 xUnlock () 메서드를 호출하는 두 번째 인수로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="06c37dcfbf68e2c7d0288d36eee6b01629eff86a" translate="yes" xml:space="preserve">
          <source>SQLite uses one of these integer values as the second argument to calls it makes to the xLock() and xUnlock() methods of an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite는 이러한 정수 값 중 하나를 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xLock () 및 xUnlock () 메서드를 호출하는 두 번째 인수로 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="f6149cc0b8adc5f4defc7a195f4b03b55ce3c135" translate="yes" xml:space="preserve">
          <source>SQLite uses pthreads for its mutex implementation on Unix and SQLite requires a recursive mutex. Most modern pthread implementations support recursive mutexes, but not all do. For systems that do not support recursive mutexes, it is recommended that applications operate in single-threaded mode only. If this is not possible, SQLite provides an alternative recursive mutex implementation built on top of the standard &quot;fast&quot; mutexes of pthreads. This alternative implementation should work correctly as long as pthread_equal() is atomic and the processor has a coherent data cache. The alternative recursive mutex implementation is enabled by the following compiler command-line switch:</source>
          <target state="translated">SQLite는 Unix에서 뮤텍스 구현을 위해 pthread를 사용하며 SQLite는 재귀 뮤텍스가 필요합니다. 대부분의 최신 pthread 구현은 재귀 뮤텍스를 지원하지만 전부는 아닙니다. 재귀 뮤텍스를 지원하지 않는 시스템의 경우 응용 프로그램은 단일 스레드 모드에서만 작동하는 것이 좋습니다. 이것이 가능하지 않은 경우 SQLite는 표준 &quot;빠른&quot;pthread 뮤텍스 위에 구축 된 대체 재귀 뮤텍스 구현을 제공합니다. pthread_equal ()이 원자적이고 프로세서에 일관된 데이터 캐시가있는 한이 대체 구현은 올바르게 작동해야합니다. 대체 재귀 뮤텍스 구현은 다음 컴파일러 명령 줄 스위치를 통해 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e2e6b108a44c0d3f75ca74e3d41c51203f95b5" translate="yes" xml:space="preserve">
          <source>SQLite uses reader/writer locks to control access to the database. (Under Win95/98/ME which lacks support for reader/writer locks, a probabilistic simulation is used instead.) But use caution: this locking mechanism might not work correctly if the database file is kept on an NFS filesystem. This is because fcntl() file locking is broken on many NFS implementations. You should avoid putting SQLite database files on NFS if multiple processes might try to access the file at the same time. On Windows, Microsoft's documentation says that locking may not work under FAT filesystems if you are not running the Share.exe daemon. People who have a lot of experience with Windows tell me that file locking of network files is very buggy and is not dependable. If what they say is true, sharing an SQLite database between two or more Windows machines might cause unexpected problems.</source>
          <target state="translated">SQLite는 리더 / 라이터 잠금을 사용하여 데이터베이스에 대한 액세스를 제어합니다. (리더 / 라이터 잠금을 지원하지 않는 Win95 / 98 / ME에서는 대신에 확률 시뮬레이션이 사용됩니다.) 그러나주의하십시오 : 데이터베이스 파일이 NFS 파일 시스템에 보관되어 있으면이 잠금 메커니즘이 제대로 작동하지 않을 수 있습니다. 많은 NFS 구현에서 fcntl () 파일 잠금이 손상 되었기 때문입니다. 여러 프로세스가 동시에 파일에 액세스하려고하면 SQLite 데이터베이스 파일을 NFS에 두지 마십시오. Windows에서 Microsoft의 설명서에 따르면 Share.exe 데몬을 실행하지 않으면 FAT 파일 시스템에서 잠금이 작동하지 않을 수 있습니다. Windows에 대한 경험이 많은 사람들은 네트워크 파일의 파일 잠금이 매우 번거롭고 신뢰할 수 없다고 말합니다. 그들이 말하는 것이 사실이라면둘 이상의 Windows 시스템간에 SQLite 데이터베이스를 공유하면 예기치 않은 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88bb033eaf6e37670d2db7d84f333ca9cade029c" translate="yes" xml:space="preserve">
          <source>SQLite uses the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; URI syntax to identify database files. SQLite strives to interpret file: URIs in exactly the same way as popular web-browsers such as &lt;a href=&quot;http://www.mozilla.com/en-US/firefox/new/&quot;&gt;Firefox&lt;/a&gt;, &lt;a href=&quot;http://www.google.com/chrome/&quot;&gt;Chrome&lt;/a&gt;, &lt;a href=&quot;http://www.apple.com/safari/&quot;&gt;Safari&lt;/a&gt;, &lt;a href=&quot;http://windows.microsoft.com/en-US/internet-explorer/products/ie/home&quot;&gt;Internet Explorer&lt;/a&gt;, and &lt;a href=&quot;http://www.opera.com/&quot;&gt;Opera&lt;/a&gt;, and command-line programs such as &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/start.mspx&quot;&gt;Windows &quot;start&quot;&lt;/a&gt; and the Mac OS-X &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/open.1.html&quot;&gt;&quot;open&quot;&lt;/a&gt; command. A succinct summary of the URI parsing rules follows:</source>
          <target state="translated">SQLite는 &quot; &lt;code&gt;file:&lt;/code&gt; &quot;URI 구문을 사용하여 데이터베이스 파일을 식별합니다. SQLite는 &lt;a href=&quot;http://www.mozilla.com/en-US/firefox/new/&quot;&gt;Firefox&lt;/a&gt; , &lt;a href=&quot;http://www.google.com/chrome/&quot;&gt;Chrome&lt;/a&gt; , &lt;a href=&quot;http://www.apple.com/safari/&quot;&gt;Safari&lt;/a&gt; , &lt;a href=&quot;http://windows.microsoft.com/en-US/internet-explorer/products/ie/home&quot;&gt;Internet Explorer&lt;/a&gt; 및 &lt;a href=&quot;http://www.opera.com/&quot;&gt;Opera&lt;/a&gt; 와 같이 널리 사용되는 웹 브라우저와 &lt;a href=&quot;http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/start.mspx&quot;&gt;Windows&lt;/a&gt; 와 같은 명령 줄 프로그램 및 Mac OS-X &lt;a href=&quot;http://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/open.1.html&quot;&gt;&quot;open&lt;/a&gt; 과 같은 방식으로 파일 : URI를 해석하려고 노력합니다. &quot; 명령. URI 구문 분석 규칙의 간결한 요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69d5ac42573f581392e9517041d99daa76b38636" translate="yes" xml:space="preserve">
          <source>SQLite uses the assumptions in this section to try to speed up reading from and writing to the database file.</source>
          <target state="translated">SQLite는이 섹션의 가정을 사용하여 데이터베이스 파일을 읽고 쓰는 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="d55089274731f4bfb9ebd084387b8f1d1faf31f7" translate="yes" xml:space="preserve">
          <source>SQLite uses the following terminology:</source>
          <target state="translated">SQLite는 다음 용어를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0ee4041bd18f2412c9c45cca33a698969a142e88" translate="yes" xml:space="preserve">
          <source>SQLite uses the fsync() system call on Unix and the FlushFileBuffers() system call on w32 in order to sync the file system buffers onto disk oxide as shown in &lt;a href=&quot;#section_3_7&quot;&gt;step 3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt;. Unfortunately, we have received reports that neither of these interfaces works as advertised on many systems. We hear that FlushFileBuffers() can be completely disabled using registry settings on some Windows versions. Some historical versions of Linux contain versions of fsync() which are no-ops on some filesystems, we are told. Even on systems where FlushFileBuffers() and fsync() are said to be working, often the IDE disk control lies and says that data has reached oxide while it is still held only in the volatile control cache.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;#section_3_7&quot;&gt;3.7 &lt;/a&gt;&lt;a href=&quot;#section_3_10&quot;&gt;단계&lt;/a&gt; 및 3.10 단계에 표시된 것처럼 파일 시스템 버퍼를 디스크 옥사이드에 동기화하기 위해 Unix에서 fsync () 시스템 호출 및 w32에서 FlushFileBuffers () 시스템 호출을 사용합니다 . 불행히도 우리는 이러한 인터페이스 중 어느 것도 많은 시스템에서 알려진대로 작동하지 않는다는보고를 받았습니다. 일부 Windows 버전에서는 레지스트리 설정을 사용하여 FlushFileBuffers ()를 완전히 비활성화 할 수 있다고 들었습니다. Linux의 일부 히스토리 버전에는 일부 파일 시스템에서 작동하지 않는 fsync () 버전이 포함되어 있습니다. FlushFileBuffers () 및 fsync ()가 작동하는 시스템에서도 IDE 디스크 제어 기능이 있으며 데이터가 여전히 휘발성 제어 캐시에만 유지되는 동안 데이터가 산화물에 도달했다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="6362e589dd1fe9de49e118297201339e71a38ea0" translate="yes" xml:space="preserve">
          <source>SQLite uses the fsync() system call to flush data to the disk under Unix and it uses the FlushFileBuffers() to do the same under Windows. Once again, SQLite assumes that these operating system services function as advertised. But it has been reported that fsync() and FlushFileBuffers() do not always work correctly, especially with inexpensive IDE disks. Apparently some manufactures of IDE disks have controller chips that report that data has reached the disk surface when in fact the data is still in volatile cache memory in the disk drive electronics. There are also reports that Windows sometimes chooses to ignore FlushFileBuffers() for unspecified reasons. The author cannot verify any of these reports. But if they are true, it means that database corruption is a possibility following an unexpected power loss. These are hardware and/or operating system bugs that SQLite is unable to defend against.</source>
          <target state="translated">SQLite는 fsync () 시스템 호출을 사용하여 Unix에서 디스크로 데이터를 플러시하고 FlushFileBuffers ()를 사용하여 Windows에서 동일하게 수행합니다. 다시 한 번 SQLite는 이러한 운영 체제 서비스가 알려진대로 작동한다고 가정합니다. 그러나 fsync () 및 FlushFileBuffers ()가 특히 저렴한 IDE 디스크에서 항상 올바르게 작동하지는 않는다고보고되었습니다. 분명히 일부 IDE 디스크 제조업체는 실제로 데이터가 디스크 드라이브 전자 장치의 휘발성 캐시 메모리에있을 때 데이터가 디스크 표면에 도달했음을보고하는 컨트롤러 칩을 가지고 있습니다. 또한 Windows가 때때로 지정되지 않은 이유로 FlushFileBuffers ()를 무시하기로 선택한 보고서도 있습니다. 작성자는 이러한 보고서를 확인할 수 없습니다. 그러나 이것이 사실이라면 예기치 않은 정전으로 인해 데이터베이스가 손상 될 수 있음을 의미합니다.이는 SQLite가 방어 할 수없는 하드웨어 및 / 또는 운영 체제 버그입니다.</target>
        </trans-unit>
        <trans-unit id="32280f4c0ca13b9e9b050e36d2463beacf57a438" translate="yes" xml:space="preserve">
          <source>SQLite uses the path component of the URI as the name of the disk file which contains the database. If the path begins with a '/' character, then it is interpreted as an absolute path. If the path does not begin with a '/' (meaning that the authority section is omitted from the URI) then the path is interpreted as a relative path. On windows, the first component of an absolute path is a drive specification (e.g. &quot;C:&quot;).</source>
          <target state="translated">SQLite는 데이터베이스를 포함하는 디스크 파일의 이름으로 URI의 경로 구성 요소를 사용합니다. 경로가 '/'문자로 시작하면 절대 경로로 해석됩니다. 경로가 '/'로 시작하지 않으면 (권한 섹션이 URI에서 생략됨을 의미) 경로는 상대 경로로 해석됩니다. Windows에서 절대 경로의 첫 번째 구성 요소는 드라이브 사양입니다 (예 : &quot;C :&quot;).</target>
        </trans-unit>
        <trans-unit id="b4d974786d3ead21fc22643249354066187d79d8" translate="yes" xml:space="preserve">
          <source>SQLite uses the sqlite3_value object to represent all values that can be stored in a database table. SQLite uses dynamic typing for the values it stores. Values stored in sqlite3_value objects can be integers, floating point values, strings, BLOBs, or NULL.</source>
          <target state="translated">SQLite는 sqlite3_value 객체를 사용하여 데이터베이스 테이블에 저장할 수있는 모든 값을 나타냅니다. SQLite는 저장된 값에 동적 타이핑을 사용합니다. sqlite3_value 객체에 저장된 값은 정수, 부동 소수점 값, 문자열, BLOB 또는 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3216e45fcb6dfe91aace5bfc00370029ab1bdf71" translate="yes" xml:space="preserve">
          <source>SQLite uses the xBestIndex method of a virtual table module to determine the best way to access the virtual table. The xBestIndex method has a prototype like this:</source>
          <target state="translated">SQLite는 가상 테이블 모듈의 xBestIndex 메서드를 사용하여 가상 테이블에 액세스하는 가장 좋은 방법을 결정합니다. xBestIndex 메소드에는 다음과 같은 프로토 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0489776d40de65aee092fe1c30e018ce2c473df" translate="yes" xml:space="preserve">
          <source>SQLite uses two defenses against this problem. In the first place, SQLite records the number of pages in the rollback journal in the header of the rollback journal. This number is initially zero. So during an attempt to rollback an incomplete (and possibly corrupt) rollback journal, the process doing the rollback will see that the journal contains zero pages and will thus make no changes to the database. Prior to a commit, the rollback journal is flushed to disk to ensure that all content has been synced to disk and there is no &quot;garbage&quot; left in the file, and only then is the page count in the header changed from zero to true number of pages in the rollback journal. The rollback journal header is always kept in a separate sector from any page data so that it can be overwritten and flushed without risking damage to a data page if a power outage occurs. Notice that the rollback journal is flushed to disk twice: once to write the page content and a second time to write the page count in the header.</source>
          <target state="translated">SQLite는이 문제에 대해 두 가지 방어책을 사용합니다. 첫째, SQLite는 롤백 저널의 헤더에 롤백 저널의 페이지 수를 기록합니다. 이 숫자는 처음에는 0입니다. 따라서 불완전하고 손상된 롤백 저널을 롤백하려는 중에 롤백을 수행하는 프로세스는 저널에 0 페이지가 포함되어 데이터베이스를 변경하지 않음을 알 수 있습니다. 커밋 전에 롤백 저널은 디스크로 플러시되어 모든 내용이 디스크에 동기화되었고 파일에 &quot;쓰레기&quot;가 남아 있지 않은 경우에만 헤더의 페이지 수가 0에서 true로 변경됩니다. 롤백 저널의 페이지 수롤백 저널 헤더는 항상 페이지 데이터와 별도의 섹터에 보관되므로 정전이 발생하더라도 데이터 페이지가 손상 될 위험없이 덮어 쓰기 및 플러시 할 수 있습니다. 롤백 저널은 디스크에 두 번 플러시됩니다. 한 번은 페이지 내용을 쓰고 두 번은 헤더에 페이지 수를 씁니다.</target>
        </trans-unit>
        <trans-unit id="d42ec8c41ede991363e3c5f0bdd1b5f73c156509" translate="yes" xml:space="preserve">
          <source>SQLite version</source>
          <target state="translated">SQLite 버전</target>
        </trans-unit>
        <trans-unit id="6c1b4a4dcbf2aebc5bc149eaa5647521eb4221db" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 allowed multiple simultaneous readers or a single writer but not both. SQLite version 3.0 allows one process to begin writing the database while other processes continue to read. The writer must still obtain an exclusive lock on the database for a brief interval in order to commit its changes, but the exclusive lock is no longer required for the entire write operation. A &lt;a href=&quot;lockingv3&quot;&gt;more detailed report&lt;/a&gt; on the locking behavior of SQLite version 3.0 is available separately.</source>
          <target state="translated">SQLite 버전 2.8에서는 여러 개의 동시 판독기 또는 단일 작성기를 허용했지만 둘 다 허용하지는 않았습니다. SQLite 버전 3.0에서는 한 프로세스가 데이터베이스 쓰기를 시작하는 반면 다른 프로세스는 계속 읽을 수 있습니다. 작성기는 변경 사항을 커미트하기 위해 데이터베이스에 대한 독점 잠금을 여전히 짧은 간격 동안 확보해야하지만 독점 쓰기는 더 이상 전체 쓰기 조작에 필요하지 않습니다. &lt;a href=&quot;lockingv3&quot;&gt;더 자세한 보고서&lt;/a&gt; SQLite는 버전 3.0의 잠금 동작에 별도로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d94b9491c8be74ea2c30ca7aa647aa4aa14bb93b" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 had the feature that any type of data could be stored in any table column regardless of the declared type of that column. This feature is retained in version 3.0, though in a slightly modified form. Each table column will store any type of data, though columns have an affinity for the format of data defined by their declared datatype. When data is inserted into a column, that column will make an attempt to convert the data format into the column's declared type. All SQL database engines do this. The difference is that SQLite 3.0 will still store the data even if a format conversion is not possible.</source>
          <target state="translated">SQLite 버전 2.8에는 선언 된 유형의 열에 관계없이 모든 유형의 데이터를 모든 테이블 열에 저장할 수있는 기능이 있습니다. 이 기능은 약간 수정 된 형태로 버전 3.0에서 유지됩니다. 각 테이블 열은 모든 유형의 데이터를 저장하지만 선언 된 데이터 유형으로 정의 된 데이터 형식에 대한 선호도는 있습니다. 데이터가 열에 삽입되면 해당 열은 데이터 형식을 열의 선언 된 유형으로 변환하려고 시도합니다. 모든 SQL 데이터베이스 엔진이이를 수행합니다. 차이점은 형식 변환이 불가능하더라도 SQLite 3.0은 여전히 ​​데이터를 저장한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc60006fcf0499f5d27e14e08e37966af30b84e4" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 will continue to be supported with bug fixes for the foreseeable future. In order to allow SQLite version 2.8 and SQLite version 3.0 to peacefully coexist, the names of key files and APIs in SQLite version 3.0 have been changed to include the character &quot;3&quot;. For example, the include file used by C programs has been changed from &quot;sqlite.h&quot; to &quot;sqlite3.h&quot;. And the name of the shell program used to interact with databases has been changed from &quot;sqlite.exe&quot; to &quot;sqlite3.exe&quot;. With these changes, it is possible to have both SQLite 2.8 and SQLite 3.0 installed on the same system at the same time. And it is possible for the same C program to link against both SQLite 2.8 and SQLite 3.0 at the same time and to use both libraries at the same time.</source>
          <target state="translated">SQLite 버전 2.8은 가까운 장래에 버그 수정으로 계속 지원됩니다. SQLite 버전 2.8과 SQLite 버전 3.0이 평화롭게 공존 할 수 있도록 SQLite 버전 3.0의 키 파일 및 API 이름이 &quot;3&quot;문자를 포함하도록 변경되었습니다. 예를 들어, C 프로그램에서 사용하는 포함 파일이 &quot;sqlite.h&quot;에서 &quot;sqlite3.h&quot;로 변경되었습니다. 또한 데이터베이스와 상호 작용하는 데 사용되는 셸 프로그램의 이름이 &quot;sqlite.exe&quot;에서 &quot;sqlite3.exe&quot;로 변경되었습니다. 이러한 변경으로 SQLite 2.8과 SQLite 3.0을 같은 시스템에 동시에 설치할 수 있습니다. 또한 동일한 C 프로그램이 동시에 SQLite 2.8 및 SQLite 3.0에 대해 링크하고 두 라이브러리를 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9294985ea2869d413fc8305361b7fbc4273dc106" translate="yes" xml:space="preserve">
          <source>SQLite version 2.8 will deal with data in various formats internally, but when writing to the disk or interacting through its API, SQLite 2.8 always converts data into ASCII text. SQLite 3.0, in contrast, exposes its internal data representations to the user and stores binary representations to disk when appropriate. The exposing of non-ASCII representations was added in order to support BLOBs.</source>
          <target state="translated">SQLite 버전 2.8은 내부적으로 다양한 형식의 데이터를 처리하지만 디스크에 쓰거나 API를 통해 상호 작용할 때 SQLite 2.8은 항상 데이터를 ASCII 텍스트로 변환합니다. 대조적으로 SQLite 3.0은 내부 데이터 표현을 사용자에게 노출하고 적절한 경우 이진 표현을 디스크에 저장합니다. BLOB를 지원하기 위해 비 ASCII 표현 노출이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4aa319379218f233cb1b56ac0f70d481e776d1c7" translate="yes" xml:space="preserve">
          <source>SQLite version 3 has the usual set of SQL comparison operators including &quot;=&quot;, &quot;==&quot;, &quot;&amp;lt;&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;gt;&quot;, &quot;&amp;gt;=&quot;, &quot;!=&quot;, &quot;&quot;, &quot;IN&quot;, &quot;NOT IN&quot;, &quot;BETWEEN&quot;, &quot;IS&quot;, and &quot;IS NOT&quot;, .</source>
          <target state="translated">SQLite 버전 3에는 &quot;=&quot;, &quot;==&quot;, &quot;&amp;lt;&quot;, &quot;&amp;lt;=&quot;, &quot;&amp;gt;&quot;, &quot;&amp;gt; =&quot;, &quot;! =&quot;, &quot;&quot;, &quot;IN&quot;을 포함한 일반적인 SQL 비교 연산자 세트가 있습니다. , &quot;NOT IN&quot;, &quot;BETWEEN&quot;, &quot;IS&quot;및 &quot;IS NOT&quot;,.</target>
        </trans-unit>
        <trans-unit id="a76401a1eda6f0ec422be63e7c58c505ecee397a" translate="yes" xml:space="preserve">
          <source>SQLite version 3 seeks to avoid writer starvation through the use of the PENDING lock. The PENDING lock allows existing readers to continue but prevents new readers from connecting to the database. So when a process wants to write a busy database, it can set a PENDING lock which will prevent new readers from coming in. Assuming existing readers do eventually complete, all SHARED locks will eventually clear and the writer will be given a chance to make its changes.</source>
          <target state="translated">SQLite 버전 3은 PENDING 잠금을 사용하여 작성기 기아를 피하려고합니다. PENDING 잠금을 사용하면 기존 독자는 계속 사용할 수 있지만 새 독자는 데이터베이스에 연결할 수 없습니다. 따라서 프로세스가 사용중인 데이터베이스를 작성하려고 할 때 PENDING 잠금을 설정하여 새 독자가 들어오는 것을 방지 할 수 있습니다. 기존 독자가 결국 완료되었다고 가정하면 모든 SHARED 잠금이 지워지고 작성자에게 해당 데이터베이스를 만들 수있는 기회가 주어집니다. 변화.</target>
        </trans-unit>
        <trans-unit id="eae91dc769edea8eecdb43451d72cf217325ea89" translate="yes" xml:space="preserve">
          <source>SQLite version 3.0 introduces important changes to the library, including:</source>
          <target state="translated">SQLite 버전 3.0에는 다음과 같은 중요한 변경 사항이 라이브러리에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="3f72a15b94cfd255cf997707c03d82c9e9918a44" translate="yes" xml:space="preserve">
          <source>SQLite version 3.0 is a new version of SQLite, derived from the SQLite 2.8.13 code base, but with an incompatible file format and API. SQLite version 3.0 was created to answer demand for the following features:</source>
          <target state="translated">SQLite 버전 3.0은 SQLite 2.8.13 코드 기반에서 파생 된 새로운 버전의 SQLite이지만 호환되지 않는 파일 형식과 API를 갖습니다. SQLite 버전 3.0은 다음 기능에 대한 요구에 부응하기 위해 만들어졌습니다.</target>
        </trans-unit>
        <trans-unit id="ccb4f474cdcf4df9f87f4000dec5a3f14ed4609b" translate="yes" xml:space="preserve">
          <source>SQLite version 3.0 is made possible in part by AOL developers supporting and embracing great Open-Source Software.</source>
          <target state="translated">SQLite 버전 3.0은 훌륭한 오픈 소스 소프트웨어를 지원하고 수용하는 AOL 개발자들에 의해 부분적으로 가능해졌습니다.</target>
        </trans-unit>
        <trans-unit id="ef6b4fa665bce97a58d8cad0238042778638e4ea" translate="yes" xml:space="preserve">
          <source>SQLite version 3.22.0 (2018-01-22) contains 5290 assert() macros, 839 testcase() macros, 88 ALWAYS() macros, and 63 NEVER() macros.</source>
          <target state="translated">SQLite 버전 3.22.0 (2018-01-22)에는 5290 assert () 매크로, 839 testcase () 매크로, 88 ALWAYS () 매크로 및 63 NEVER () 매크로가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c307004a0921076eb49a52bd8a91c6b52b2a1b6b" translate="yes" xml:space="preserve">
          <source>SQLite version 3.3.14 adds the concept of &quot;Exclusive Access Mode&quot;. In exclusive access mode, SQLite retains the exclusive database lock at the conclusion of each transaction. This prevents other processes from accessing the database, but in many deployments only a single process is using a database so this is not a serious problem. The advantage of exclusive access mode is that disk I/O can be reduced in three ways:</source>
          <target state="translated">SQLite 버전 3.3.14에는 &quot;독점 액세스 모드&quot;라는 개념이 추가되었습니다. 단독 액세스 모드에서 SQLite는 각 트랜잭션이 끝날 때 독점 데이터베이스 잠금을 유지합니다. 이렇게하면 다른 프로세스가 데이터베이스에 액세스 할 수 없지만 많은 배포에서 단일 프로세스 만 데이터베이스를 사용하므로 심각한 문제는 아닙니다. 단독 액세스 모드의 장점은 디스크 I / O를 세 가지 방식으로 줄일 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fbb503554e7c282aedc13f070027736e1a10fc7b" translate="yes" xml:space="preserve">
          <source>SQLite version 3.5.0 (2007-09-04) introduces a new OS interface layer that is incompatible with all prior versions of SQLite. In addition, a few existing interfaces have been generalized to work across all database connections within a process rather than just all connections within a thread. The purpose of this article is to describe the changes to 3.5.0 in detail so that users of prior versions of SQLite can judge what, if any, effort will be required to upgrade to newer versions.</source>
          <target state="translated">SQLite 버전 3.5.0 (2007-09-04)에는 모든 이전 버전의 SQLite와 호환되지 않는 새로운 OS 인터페이스 계층이 도입되었습니다. 또한 스레드 내의 모든 연결이 아니라 프로세스 내의 모든 데이터베이스 연결에서 작동하도록 몇 가지 기존 인터페이스가 일반화되었습니다. 이 기사의 목적은 이전 버전의 SQLite 사용자가 최신 버전으로 업그레이드하기 위해 어떤 노력이 필요한지 판단 할 수 있도록 3.5.0의 변경 사항을 자세히 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70942f1687fac3fdda946d021fc48ca1143963c7" translate="yes" xml:space="preserve">
          <source>SQLite version 3.6.0 (2008-07-16) contains many changes. As is the custom with the SQLite project, most changes are fully backwards compatible. However, a few of the changes in version 3.6.0 are incompatible and might require modifications to application code and/or makefiles. This document is a briefing on the changes in SQLite 3.6.0 with special attention to the incompatible changes.</source>
          <target state="translated">SQLite 버전 3.6.0 (2008-07-16)에는 많은 변경 사항이 포함되어 있습니다. SQLite 프로젝트의 사용자 정의와 마찬가지로 대부분의 변경 사항은 이전 버전과 완전히 호환됩니다. 그러나 버전 3.6.0의 일부 변경 사항은 호환되지 않으며 응용 프로그램 코드 및 / 또는 makefile을 수정해야합니다. 이 문서는 호환되지 않는 변경 사항에 특히주의하면서 SQLite 3.6.0의 변경 사항에 대한 브리핑입니다.</target>
        </trans-unit>
        <trans-unit id="da041872c2ed2b85c83a9be5e4c3422e0d89ff87" translate="yes" xml:space="preserve">
          <source>SQLite version 3.7.0 introduced a number of new enhancements to the SQLite database file format (such as but not limited to &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;). The 3.7.0 release was a shake-out release for these new features. We expected to find problems and were not disappointed.</source>
          <target state="translated">SQLite 버전 3.7.0에는 SQLite 데이터베이스 파일 형식 ( &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 등으로 제한되지 않음)에 대한 여러 가지 새로운 기능이 도입되었습니다 . 3.7.0 릴리스는 이러한 새로운 기능을위한 셰이크 아웃 릴리스입니다. 우리는 문제를 찾을 것으로 예상했지만 실망하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="31e4e9d6b69cabc107d20e4736663f7980b134d1" translate="yes" xml:space="preserve">
          <source>SQLite version 3.7.16.2 fixes a subtle race condition in the locking logic on Windows systems. When a database file is in need of recovery because the previous process writing to it crashed in the middle of a transaction and two or more processes try to open the that database at the same time, then the race condition might cause one of those processes to get a false indication that the recovery has already completed, allowing that process to continue using the database file without running recovery first. If that process writes to the file, then the file might go corrupt. This race condition had apparently existed in all prior versions of SQLite for Windows going back to 2004. But the race was very tight. Practically speaking, you need a fast multi-core machine in which you launch two processes to run recovery at the same moment on two separate cores. This defect was on Windows systems only and did not affect the posix OS interface.</source>
          <target state="translated">SQLite 버전 3.7.16.2는 Windows 시스템의 잠금 로직에서 미묘한 경쟁 조건을 수정합니다. 데이터베이스 파일에 대한 이전 프로세스 쓰기가 트랜잭션 중간에 충돌하여 두 개 이상의 프로세스가 동시에 해당 데이터베이스를 열려고하기 때문에 데이터베이스 파일을 복구해야하는 경우 경쟁 조건으로 인해 해당 프로세스 중 하나가 발생할 수 있습니다. 복구가 이미 완료되었다는 잘못된 표시를 받으면 해당 프로세스가 복구를 먼저 실행하지 않고 데이터베이스 파일을 계속 사용할 수 있습니다. 해당 프로세스가 파일에 쓰면 파일이 손상 될 수 있습니다. 이 경쟁 조건은 2004 년으로 돌아 가기 이전의 모든 Windows 용 SQLite 버전에서 분명히 존재했습니다. 그러나 경쟁은 매우 빡빡했습니다. 실제로 말하면,두 개의 개별 코어에서 동시에 복구를 실행하기 위해 두 개의 프로세스를 시작하는 빠른 멀티 코어 시스템이 필요합니다. 이 결함은 Windows 시스템에서만 발생했으며 posix OS 인터페이스에는 영향을 미치지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="06c5d06f2767343fefb84004cfe2451c3fbeba78" translate="yes" xml:space="preserve">
          <source>SQLite was originally coded in such a way that the answer to all questions in the chart below would be &quot;Yes&quot;. But the experiments run on other SQL engines showed that none of them worked this way. So SQLite was modified to work the same as Oracle, PostgreSQL, and DB2. This involved making NULLs indistinct for the purposes of the SELECT DISTINCT statement and for the UNION operator in a SELECT. NULLs are still distinct in a UNIQUE column. This seems somewhat arbitrary, but the desire to be compatible with other engines outweighed that objection.</source>
          <target state="translated">SQLite는 원래 아래 차트의 모든 질문에 대한 답변이 &quot;예&quot;가되도록 코딩되었습니다. 그러나 다른 SQL 엔진에서 실행 된 실험에서는 이들 중 어느 것도 이런 방식으로 작동하지 않음을 보여주었습니다. 따라서 SQLite는 Oracle, PostgreSQL 및 DB2와 동일하게 작동하도록 수정되었습니다. 여기에는 SELECT DISTINCT 문의 목적과 SELECT의 UNION 연산자에 대해 NULL을 구분하지 않는 것이 포함됩니다. UNIQUE 열에서 NULL은 여전히 ​​고유합니다. 이것은 다소 임의적 인 것처럼 보이지만 다른 엔진과의 호환성에 대한 요구는 그 반대보다 중요했습니다.</target>
        </trans-unit>
        <trans-unit id="cc2cc08c1f222d49bc97f5f39c7b9c91ad3731d6" translate="yes" xml:space="preserve">
          <source>SQLite was originally designed with a policy of avoiding arbitrary limits. Of course, every program that runs on a machine with finite memory and disk space has limits of some kind. But in SQLite, those limits were not well defined. The policy was that if it would fit in memory and you could count it with a 32-bit integer, then it should work.</source>
          <target state="translated">SQLite는 원래 임의의 제한을 피하는 정책으로 설계되었습니다. 물론, 유한 메모리와 디스크 공간이있는 머신에서 실행되는 모든 프로그램에는 어떤 종류의 제한이 있습니다. 그러나 SQLite에서는 이러한 한계가 잘 정의되지 않았습니다. 정책은 메모리에 적합하고 32 비트 정수로 계산할 수 있으면 작동한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="769cb93a3fb24f4ad929e24b9c4fe55eeec4efe2" translate="yes" xml:space="preserve">
          <source>SQLite was tested in the same configuration that it appears on the website. It was compiled with -O6 optimization and with the -DNDEBUG=1 switch which disables the many &quot;assert()&quot; statements in the SQLite code. The -DNDEBUG=1 compiler option roughly doubles the speed of SQLite.</source>
          <target state="translated">SQLite는 웹 사이트와 동일한 구성으로 테스트되었습니다. -O6 최적화 및 -DNDEBUG = 1 스위치로 컴파일되어 SQLite 코드에서 많은 &quot;assert ()&quot;문을 비활성화합니다. -DNDEBUG = 1 컴파일러 옵션은 SQLite 속도를 거의 두 배로 높입니다.</target>
        </trans-unit>
        <trans-unit id="864e2447d8a13ac7ee35b071674f4476208c7306" translate="yes" xml:space="preserve">
          <source>SQLite will also add one of the following flags to the xOpen() call, depending on the object being opened:</source>
          <target state="translated">SQLite는 열린 객체에 따라 xOpen () 호출에 다음 플래그 중 하나를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="131d0be5dd7e4aa0858930ddc9451eb1f3423fe0" translate="yes" xml:space="preserve">
          <source>SQLite will also attempt to use indices to help satisfy GROUP BY clauses and the DISTINCT keyword. If the nested loops of the join can be arranged such that rows that are equivalent for the GROUP BY or for the DISTINCT are consecutive, then the GROUP BY or DISTINCT logic can determine if the current row is part of the same group or if the current row is distinct simply by comparing the current row to the previous row. This can be much faster than the alternative of comparing each row to all prior rows.</source>
          <target state="translated">SQLite는 또한 GROUP BY 절과 DISTINCT 키워드를 만족시키기 위해 인덱스를 사용하려고 시도합니다. GROUP BY 또는 DISTINCT에 해당하는 행이 연속되도록 조인의 중첩 루프를 배열 할 수있는 경우 GROUP BY 또는 DISTINCT 논리는 현재 행이 동일한 그룹의 일부인지 또는 현재 행인지 판별 할 수 있습니다. 행은 단순히 현재 행과 이전 행을 비교하여 구별됩니다. 각 행을 모든 이전 행과 비교하는 것보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="03ac5706e55e0f1ceba6bf4ddd17b581fa34f6ca" translate="yes" xml:space="preserve">
          <source>SQLite will always allocate at least mxPathname+1 bytes for the output buffer xFullPathname. The exact size of the output buffer is also passed as a parameter to both methods. If the output buffer is not large enough, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; should be returned. Since this is handled as a fatal error by SQLite, vfs implementations should endeavor to prevent this by setting mxPathname to a sufficiently large value.</source>
          <target state="translated">SQLite는 항상 출력 버퍼 xFullPathname에 대해 mxPathname + 1 바이트 이상을 할당합니다. 출력 버퍼의 정확한 크기는 두 메소드 모두에 매개 변수로 전달됩니다. 출력 버퍼가 충분히 크지 않으면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 을 리턴해야합니다. 이는 SQLite에서 치명적인 오류로 처리되므로 vfs 구현에서는 mxPathname을 충분히 큰 값으로 설정하여이를 방지하기 위해 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="a98d8800d0c61913767afcbc8c0b3400cddf5e5e" translate="yes" xml:space="preserve">
          <source>SQLite will always allocate at least mxPathname+1 bytes for the output buffer xFullPathname. The exact size of the output buffer is also passed as a parameter to both methods. If the output buffer is not large enough, &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; should be returned. Since this is handled as a fatal error by SQLite, vfs implementations should endeavor to prevent this by setting mxPathname to a sufficiently large value.</source>
          <target state="translated">SQLite는 항상 출력 버퍼 xFullPathname에 대해 mxPathname + 1 바이트 이상을 할당합니다. 출력 버퍼의 정확한 크기는 두 메소드 모두에 매개 변수로 전달됩니다. 출력 버퍼가 충분히 크지 않으면 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 을 리턴해야합니다. 이는 SQLite에서 치명적인 오류로 처리되므로 vfs 구현에서는 mxPathname을 충분히 큰 값으로 설정하여이를 방지하기 위해 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="1e33e35f6dabafac608ead478729b44348c338ef" translate="yes" xml:space="preserve">
          <source>SQLite will invoke the xMutexEnd() method when &lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; is called, but only if the prior call to xMutexInit returned SQLITE_OK. If xMutexInit fails in any way, it is expected to clean up after itself prior to returning.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 이 호출 될 때 SQLite는 xMutexEnd () 메소드를 호출하지만 xMutexInit에 대한 이전 호출이 SQLITE_OK를 리턴 한 경우에만 호출합니다. xMutexInit가 어떤 식 으로든 실패하면 반환하기 전에 자체적으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="3e7a5d17c455846b0ec61394b33dc86a1c9321c1" translate="yes" xml:space="preserve">
          <source>SQLite will invoke the xMutexEnd() method when &lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; is called, but only if the prior call to xMutexInit returned SQLITE_OK. If xMutexInit fails in any way, it is expected to clean up after itself prior to returning.</source>
          <target state="translated">&lt;a href=&quot;initialize&quot;&gt;sqlite3_shutdown ()&lt;/a&gt; 이 호출 될 때 SQLite는 xMutexEnd () 메소드를 호출하지만 xMutexInit에 대한 이전 호출이 SQLITE_OK를 리턴 한 경우에만 호출합니다. xMutexInit가 어떤 식 으로든 실패하면 반환하기 전에 자체적으로 정리됩니다.</target>
        </trans-unit>
        <trans-unit id="2f8ba8da1a2e441af20b1b20244a8ec294fc1a9c" translate="yes" xml:space="preserve">
          <source>SQLite will make this determination, but only if it has been compiled with &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; or &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. The &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; and &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; options causes the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command to collect a histogram of column content in the &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; or &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; tables and to use this histogram to make a better guess at the best query to use for range constraints such as the above. The main difference between STAT3 and STAT4 is that STAT3 records histogram data for only the left-most column of an index whereas STAT4 records histogram data for all columns of an index. For single-column indexes, STAT3 and STAT4 work the same.</source>
          <target state="translated">SQLite는 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 로 컴파일 된 경우에만이 결정을 내 립니다 . &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; 및 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 옵션은이 원인 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 에서 열 내용의 히스토그램을 수집하는 명령 &lt;a href=&quot;fileformat2#stat3tab&quot;&gt;sqlite_stat3&lt;/a&gt; 또는 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 테이블과 같은 위와 같이 범위 제한에 사용할 최적의 쿼리에서 더 나은 추측을하기 위해 히스토그램을 사용합니다. STAT3과 STAT4의 주요 차이점은 STAT3이 인덱스의 가장 왼쪽 열에 대해서만 히스토그램 데이터를 기록하는 반면 STAT4는 인덱스의 모든 열에 대한 히스토그램 데이터를 기록한다는 것입니다. 단일 열 인덱스의 경우 STAT3과 STAT4가 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0feeafe3441c848d4df17e7ab2118b3ce654ef9a" translate="yes" xml:space="preserve">
          <source>SQLite will never invoke xInit() more than once without an intervening call to xShutdown().</source>
          <target state="translated">SQLite는 xShutdown ()에 대한 호출없이 xInit ()를 두 번 이상 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8141933bded4b0433c5458cd8dc4b6c9aa50dccc" translate="yes" xml:space="preserve">
          <source>SQLite will normally invoke xFetch() with a createFlag of 0 or 1. SQLite will only use a createFlag of 2 after a prior call with a createFlag of 1 failed. In between the to xFetch() calls, SQLite may attempt to unpin one or more cache pages by spilling the content of pinned pages to disk and synching the operating system disk cache.</source>
          <target state="translated">SQLite는 일반적으로 createFlag가 0 또는 1 인 xFetch ()를 호출합니다. SQLite는 createFlag가 1 인 이전 호출이 실패한 후에 만 ​​createFlag 2를 사용합니다. to xFetch () 호출 사이에서 SQLite는 고정 된 페이지의 컨텐츠를 디스크에 유출하고 운영 체제 디스크 캐시를 동기화하여 하나 이상의 캐시 페이지를 고정 해제하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0c63958ff91d6ac8d167ebbeb5d529f639eed1" translate="yes" xml:space="preserve">
          <source>SQLite will normally invoke xFetch() with a createFlag of 0 or 1. SQLite will only use a createFlag of 2 after a prior call with a createFlag of 1 failed. In between the xFetch() calls, SQLite may attempt to unpin one or more cache pages by spilling the content of pinned pages to disk and synching the operating system disk cache.</source>
          <target state="translated">SQLite는 일반적으로 createFlag가 0 또는 1 인 xFetch ()를 호출합니다. SQLite는 createFlag가 1 인 이전 호출이 실패한 후에 만 ​​createFlag 2를 사용합니다. xFetch () 호출 사이에서 SQLite는 고정 된 페이지의 내용을 디스크에 넘기고 운영 체제 디스크 캐시를 동기화하여 하나 이상의 캐시 페이지를 고정 해제하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26bbe6f761c35b13c9b3c740596c8f4fafbb74f1" translate="yes" xml:space="preserve">
          <source>SQLite will normally work fine as the database backend to a website. But if the website is write-intensive or is so busy that it requires multiple servers, then consider using an enterprise-class client/server database engine instead of SQLite.</source>
          <target state="translated">SQLite는 일반적으로 웹 사이트의 데이터베이스 백엔드로 정상적으로 작동합니다. 그러나 웹 사이트가 쓰기 집약적이거나 너무 바빠서 여러 서버가 필요한 경우 SQLite 대신 엔터프라이즈 급 클라이언트 / 서버 데이터베이스 엔진을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="11d8b5641b8ccc13250b43f6ec693456aaae006d" translate="yes" xml:space="preserve">
          <source>SQLite will still omit the sorting step. But in order for output to appear in the correct order, SQLite will do the table scan starting at the end and working toward the beginning, rather than starting at the beginning and working toward the end as shown in &lt;a href=&quot;#fig17&quot;&gt;figure 17&lt;/a&gt;.</source>
          <target state="translated">SQLite는 여전히 정렬 단계를 생략합니다. 그러나 출력이 올바른 순서로 표시되도록하기 위해 SQLite는 &lt;a href=&quot;#fig17&quot;&gt;그림 17에&lt;/a&gt; 표시된 것처럼 처음부터 시작하여 끝까지 작업하지 않고 끝에서 시작하여 처음으로 작업하는 테이블 스캔을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="db0bee01e01c7f06f53ced4aa077d1b69e3e443d" translate="yes" xml:space="preserve">
          <source>SQLite works best if you group multiple operations together into a single transaction.</source>
          <target state="translated">SQLite는 여러 작업을 단일 트랜잭션으로 그룹화 할 때 가장 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5a4570a64a559f2380207d7ac2eae2dd4a188a0c" translate="yes" xml:space="preserve">
          <source>SQLite works by compiling SQL text into &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;, then running that bytecode using a virtual machine.</source>
          <target state="translated">SQLite는 SQL 텍스트를 &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; 로 컴파일 한 다음 가상 머신을 사용하여 해당 바이트 코드를 실행하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1c47334be07eef6e2c6868c4937b4803add8d7d3" translate="yes" xml:space="preserve">
          <source>SQLite works by translating SQL statements into bytecode and then running that bytecode in a virtual machine. This document describes how how the bytecode engine works.</source>
          <target state="translated">SQLite는 SQL 문을 바이트 코드로 변환 한 다음 가상 머신에서 해당 바이트 코드를 실행하여 작동합니다. 이 문서는 바이트 코드 엔진의 작동 방식을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1ebaf35d34ab3b907a64e57112416a9de1a568a2" translate="yes" xml:space="preserve">
          <source>SQLite works by translating each SQL statement into bytecode and then running that bytecode. A &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; in SQLite is mostly just the bytecode needed to implement the corresponding SQL. The &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; interface is a compiler that translates SQL into bytecode. The &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface is the virtual machine that runs the bytecode contained within the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt;.</source>
          <target state="translated">SQLite는 각 SQL 문을 바이트 코드로 변환 한 다음 해당 바이트 코드를 실행하여 작동합니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; SQLite는의 대부분이 해당 SQL을 구현하는 데 필요한 단지 바이트 코드입니다. &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 인터페이스는 SQL 바이트 코드로 변환하는 컴파일러이다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스가 포함 된 바이트 코드를 실행하는 가상 머신입니다 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="535be0580b8710df785d98333c6a0024a79e6b52" translate="yes" xml:space="preserve">
          <source>SQLite works great as the database engine for most low to medium traffic websites (which is to say, most websites). The amount of web traffic that SQLite can handle depends on how heavily the website uses its database. Generally speaking, any site that gets fewer than 100K hits/day should work fine with SQLite. The 100K hits/day figure is a conservative estimate, not a hard upper bound. SQLite has been demonstrated to work with 10 times that amount of traffic.</source>
          <target state="translated">SQLite는 트래픽이 적거나 중간 정도 인 웹 사이트 (즉, 대부분의 웹 사이트)의 데이터베이스 엔진으로 작동합니다. SQLite가 처리 할 수있는 웹 트래픽의 양은 웹 사이트가 데이터베이스를 얼마나 많이 사용하는지에 따라 다릅니다. 일반적으로 하루에 조회수가 10 만 회 미만인 사이트는 SQLite에서 제대로 작동합니다. 100K 조회수 / 일 수치는 상한이 아니라 보수적 인 추정치입니다. SQLite는 트래픽 양의 10 배에 해당하는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="878697a779b4f555e31be3e87a76fb2ec64adcb9" translate="yes" xml:space="preserve">
          <source>SQLite&amp;#x27;s Built-in printf()</source>
          <target state="translated">SQLite의 내장 printf ()</target>
        </trans-unit>
        <trans-unit id="d809358342217ac1c9798a4536e992e30b5c1bbd" translate="yes" xml:space="preserve">
          <source>SQLite's Built-in printf()</source>
          <target state="translated">SQLite의 내장 printf ()</target>
        </trans-unit>
        <trans-unit id="77bf8cb88e1c9ff7655bff7a5cbb97288c41b450" translate="yes" xml:space="preserve">
          <source>SQLite, in contrast, stores all content in a &lt;a href=&quot;fileformat2&quot;&gt;single file on disk&lt;/a&gt;. That single file is something you can point to and say &quot;this is the database&quot;. It behaves as an object. An SQLite database file can be copied, renamed, sent as an email attachment, passed as the argument a POST HTTP request, or otherwise treated as other data object such as an image, document, or media file.</source>
          <target state="translated">반면 SQLite는 모든 내용 &lt;a href=&quot;fileformat2&quot;&gt;을 디스크&lt;/a&gt; 의 단일 파일에 저장합니다 . 이 단일 파일은 &quot;이것은 데이터베이스입니다&quot;라고 지적하고 말할 수있는 것입니다. 객체처럼 동작합니다. SQLite 데이터베이스 파일은 복사, 이름 변경, 이메일 첨부 파일로 전송, POST HTTP 요청의 인수로 전달되거나 이미지, 문서 또는 미디어 파일과 같은 다른 데이터 오브젝트로 처리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d5e7b501f4c23aeddb2e1d173f4fc5a56622fde" translate="yes" xml:space="preserve">
          <source>SQLite, in contrast, use only the amount of disk space actually needed to store the information in a row. If you store a single character in a VARCHAR(100) column, then only a single byte of disk space is consumed. (Actually two bytes - there is some overhead at the beginning of each column to record its datatype and length.)</source>
          <target state="translated">반면 SQLite는 실제로 정보를 한 행에 저장하는 데 필요한 디스크 공간 만 사용합니다. VARCHAR (100) 열에 단일 문자를 저장하면 1 바이트의 디스크 공간 만 사용됩니다. (실제로 2 바이트-데이터 유형 및 길이를 기록하기 위해 각 열의 시작 부분에 약간의 오버 헤드가 있습니다.)</target>
        </trans-unit>
        <trans-unit id="90a2c30d411105b1866a2fb7534e120d54c087c8" translate="yes" xml:space="preserve">
          <source>SQLite, like all SQL database engines, makes extensive use of malloc() (See the separate report on &lt;a href=&quot;malloc&quot;&gt;dynamic memory allocation in SQLite&lt;/a&gt; for additional detail.) On servers and workstations, malloc() never fails in practice and so correct handling of out-of-memory (OOM) errors is not particularly important. But on embedded devices, OOM errors are frighteningly common and since SQLite is frequently used on embedded devices, it is important that SQLite be able to gracefully handle OOM errors.</source>
          <target state="translated">모든 SQL 데이터베이스 엔진과 마찬가지로 SQLite는 malloc ()을 광범위하게 사용합니다 (자세한 내용은 &lt;a href=&quot;malloc&quot;&gt;SQLite의 동적 메모리 할당에&lt;/a&gt; 대한 별도의 보고서를 참조하십시오 ). 서버와 워크 스테이션에서 malloc ()은 실제로 실패하지 않으므로 올바르게 처리하지 않습니다. 메모리 부족 (OOM) 오류는 특별히 중요하지 않습니다. 그러나 임베디드 장치에서는 OOM 오류가 매우 흔하며 SQLite가 임베디드 장치에서 자주 사용되므로 SQLite가 OOM 오류를 정상적으로 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8aba37dd603a24e82fd4f1820189539d3d0a566" translate="yes" xml:space="preserve">
          <source>SQLite: Single File Database</source>
          <target state="translated">SQLite : 단일 파일 데이터베이스</target>
        </trans-unit>
        <trans-unit id="8317c0736d9e6aaddc008372c034f2f63ca423a2" translate="yes" xml:space="preserve">
          <source>Safe languages are often touted for helping to prevent security vulnerabilities. True enough, but SQLite is not a particularly security-sensitive library. If an application is running untrusted and unverified SQL, then it already has much bigger security issues (SQL injection) that no &quot;safe&quot; language will fix.</source>
          <target state="translated">보안 취약점을 예방하는 데 도움이되는 안전한 언어가 종종 선전됩니다. 충분하지만 SQLite는 특히 보안에 민감한 라이브러리는 아닙니다. 응용 프로그램이 신뢰할 수없고 검증되지 않은 SQL을 실행하는 경우 &quot;안전한&quot;언어로 해결되지 않는 훨씬 더 큰 보안 문제 (SQL 주입)가 이미 있습니다.</target>
        </trans-unit>
        <trans-unit id="371ba39228ab4a1c3c189b797c7120e98ace4662" translate="yes" xml:space="preserve">
          <source>Safe languages insert additional machine branches to do things like verify that array accesses are in-bounds. In correct code, those branches are never taken. That means that the machine code cannot be 100% branch tested, which is an important component of SQLite's quality strategy.</source>
          <target state="translated">안전한 언어는 추가 기계 분기를 삽입하여 배열 액세스가 인바운드인지 확인하는 등의 작업을 수행합니다. 올바른 코드에서는 이러한 분기가 수행되지 않습니다. 이는 머신 코드를 100 % 분기 테스트 할 수 없다는 것을 의미하며 이는 SQLite 품질 전략의 중요한 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="fcacd9319f45f058826102f8fd4d08b85a39ed32" translate="yes" xml:space="preserve">
          <source>Safe languages usually want to abort if they encounter an out-of-memory (OOM) situation. SQLite is designed to recover gracefully from an OOM. It is unclear how this could be accomplished in the current crop of safe languages.</source>
          <target state="translated">안전한 언어는 일반적으로 메모리 부족 (OOM) 상황이 발생하면 중단하려고합니다. SQLite는 OOM에서 정상적으로 복구하도록 설계되었습니다. 이것이 안전한 언어의 현재 작물에서 어떻게 이룰 수 있는지는 불분명합니다.</target>
        </trans-unit>
        <trans-unit id="3c6da187258d5af2ebae1cdb3cc862f47c52557f" translate="yes" xml:space="preserve">
          <source>Safe languages usually want to abort if they encounter an out-of-memory (OOM) situation. SQLite is designed to recovery gracefully from an OOM. It is unclear how this could be accomplished in the current crop of safe languages.</source>
          <target state="translated">안전한 언어는 일반적으로 메모리 부족 (OOM) 상황이 발생하면 중단하려고합니다. SQLite는 OOM에서 정상적으로 복구하도록 설계되었습니다. 현재 안전한 언어로 어떻게이 작업을 수행 할 수 있는지는 확실하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb8901e65be4e894ae11ab1d95f963f276b64fd4" translate="yes" xml:space="preserve">
          <source>Safe programming languages solve the easy problems: memory leaks, use-after-free errors, array overruns, etc. Safe languages provide no help beyond ordinary C code in solving the rather more difficult problem of computing a correct answer to an SQL statement.</source>
          <target state="translated">안전한 프로그래밍 언어는 메모리 누수, 사후 사용 오류, 어레이 오버런 등과 같은 쉬운 문제를 해결합니다. 안전한 언어는 SQL 문에 대한 정답을 계산하는 데있어 다소 어려운 문제를 해결하는 데있어 일반적인 C 코드 외에는 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4c0b98b770b73c58eadb8af8b218e45dc7ebebbf" translate="yes" xml:space="preserve">
          <source>Safety-critical applications will usually want to modify the default lookaside memory configuration so that when the initial lookaside memory buffer is allocated during &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; the resulting memory allocation is not so large as to force the &lt;b&gt;n&lt;/b&gt; parameter to be too large. In order to keep &lt;b&gt;n&lt;/b&gt; under control, it is best to try to keep the largest memory allocation below 2 or 4 kilobytes. Hence, a reasonable default setup for the lookaside memory allocator might any one of the following:</source>
          <target state="translated">안전에 중요한 응용 프로그램은 일반적으로 초기 lookaside 메모리 버퍼가 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 중에 할당 될 때 결과 메모리 할당이 너무 커서 &lt;b&gt;n&lt;/b&gt; 매개 변수가 너무 커지지 않도록 기본 lookaside 메모리 구성을 수정하려고합니다 . 유지하기 위해 &lt;b&gt;N&lt;/b&gt; 통제를, 그것은 2 4킬로바이트 아래 가장 큰 메모리 할당을 유지하려고하는 것이 가장 좋습니다. 따라서 lookaside 메모리 할당 자에 대한 합리적인 기본 설정은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb272988295a04bfacb652f9f425c9751c1efcff" translate="yes" xml:space="preserve">
          <source>Salt-1 copied from the WAL header</source>
          <target state="translated">WAL 헤더에서 복사 된 Salt-1</target>
        </trans-unit>
        <trans-unit id="8f07478edf0a13be2b8353393ce58be98c5cb042" translate="yes" xml:space="preserve">
          <source>Salt-1: random integer incremented with each checkpoint</source>
          <target state="translated">Salt-1 : 각 체크 포인트마다 증가하는 임의의 정수</target>
        </trans-unit>
        <trans-unit id="fd8becc82bf3034e486b52e348505de06703eadf" translate="yes" xml:space="preserve">
          <source>Salt-2 copied from the WAL header</source>
          <target state="translated">WAL 헤더에서 복사 된 Salt-2</target>
        </trans-unit>
        <trans-unit id="2251457c30eb39ac4f98ca1b3b449998bdfb08bd" translate="yes" xml:space="preserve">
          <source>Salt-2: a different random number for each checkpoint</source>
          <target state="translated">Salt-2 : 각 체크 포인트마다 다른 난수</target>
        </trans-unit>
        <trans-unit id="2802d3bf84d06bd601abc4160930ee13b4ba8886" translate="yes" xml:space="preserve">
          <source>Same as INTEGER-&amp;gt;TEXT</source>
          <target state="translated">INTEGER-&amp;gt; TEXT와 동일</target>
        </trans-unit>
        <trans-unit id="64fe7599a1466f63ea9b7dc136b08e0468a7bcfe" translate="yes" xml:space="preserve">
          <source>Save the pointer passed as the second argument as the extension function's &quot;auxiliary data&quot;. The pointer may then be retrieved by the current or any future invocation of the same fts5 extension function made as part of the same MATCH query using the xGetAuxdata() API.</source>
          <target state="translated">두 번째 인수로 전달 된 포인터를 확장 함수의 &quot;보조 데이터&quot;로 저장합니다. 포인터는 xGetAuxdata () API를 사용하여 동일한 MATCH 쿼리의 일부로 만들어진 동일한 fts5 확장 함수의 현재 또는 향후 호출에 의해 검색 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e164ee3e19bc05538690fe1a5205fe5b7956a433" translate="yes" xml:space="preserve">
          <source>Save the pointer passed as the second argument as the extension functions &quot;auxiliary data&quot;. The pointer may then be retrieved by the current or any future invocation of the same fts5 extension function made as part of the same MATCH query using the xGetAuxdata() API.</source>
          <target state="translated">확장 함수 &quot;보조 데이터&quot;로 두 번째 인수로 전달 된 포인터를 저장하십시오. 그런 다음 xGetAuxdata () API를 사용하여 동일한 MATCH 쿼리의 일부로 만들어진 동일한 fts5 확장 함수의 현재 또는 향후 호출에 의해 포인터를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c739de5dc59a519ecc88e91c12cee776ddb9f8ec" translate="yes" xml:space="preserve">
          <source>Savepoint</source>
          <target state="translated">Savepoint</target>
        </trans-unit>
        <trans-unit id="e74ed8e87da0851118fc159806fbe103dac70bbe" translate="yes" xml:space="preserve">
          <source>Savepoints</source>
          <target state="translated">Savepoints</target>
        </trans-unit>
        <trans-unit id="dae2c6197cf9bbcd1ad8c12e21c2553a379969bd" translate="yes" xml:space="preserve">
          <source>Scan all rows of realtab and for each row, find rows in tablevaluedfunc where param1 is equal to realtab.x</source>
          <target state="translated">realtab의 모든 행을 스캔하고 각 행에 대해 param1이 realtab.x와 동일한 tablevaluedfunc에서 행을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="81b10ed131cb8283236308eac51fe1690aaceea4" translate="yes" xml:space="preserve">
          <source>Scan all rows of tablevalued func and for each row find rows in realtab where x is equal to tablevaluedfunc.param1.</source>
          <target state="translated">tablevalued func의 모든 행을 스캔하고 각 행에 대해 x가 tablevaluedfunc.param1과 동일한 realtab에서 행을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="54a7124a44e1230cb0e0f19e93fb0a0d583d3126" translate="yes" xml:space="preserve">
          <source>Schema S of &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D must be a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 스키마 S는 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="4938e6644f0ad52bc0448849639259b7608261fb" translate="yes" xml:space="preserve">
          <source>Schema S of &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D must be a &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; database.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; D 의 스키마 S는 &lt;a href=&quot;../wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="783379b4d6a04cfdb7223b86944f535ee34f305b" translate="yes" xml:space="preserve">
          <source>Schema format number</source>
          <target state="translated">스키마 형식 번호</target>
        </trans-unit>
        <trans-unit id="3818a04cadbc7e36a69fd1fddf0ec427879c13a3" translate="yes" xml:space="preserve">
          <source>Search application tips</source>
          <target state="translated">응용 프로그램 검색 팁</target>
        </trans-unit>
        <trans-unit id="8f58d07a782f28f0be6c5eba33589bc58551ce12" translate="yes" xml:space="preserve">
          <source>Second Improvement: Split content into smaller pieces</source>
          <target state="translated">두 번째 개선 : 내용을 더 작은 조각으로 나누기</target>
        </trans-unit>
        <trans-unit id="ec79d2ea1a314df8f0b27d40fa827558108d418f" translate="yes" xml:space="preserve">
          <source>Second copy of the WAL Index Information</source>
          <target state="translated">WAL 색인 정보의 두 번째 사본</target>
        </trans-unit>
        <trans-unit id="f2c6b564bd8119e16a3e573a6f9e7c6d1ac7820f" translate="yes" xml:space="preserve">
          <source>Section</source>
          <target state="translated">Section</target>
        </trans-unit>
        <trans-unit id="abbdc2b8f6673a1b63bbd1262eceea1c936362ed" translate="yes" xml:space="preserve">
          <source>Sections of the database that are used more than once, or not at all</source>
          <target state="translated">두 번 이상 사용되거나 전혀 사용되지 않는 데이터베이스 섹션</target>
        </trans-unit>
        <trans-unit id="bbd835e731943b498ec1909cabc1e38a99b94296" translate="yes" xml:space="preserve">
          <source>Security and compatibilities enhancements to &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()의&lt;/a&gt; 보안 및 호환성 향상 :</target>
        </trans-unit>
        <trans-unit id="8229f87bed66ece3cde105695968321f8308f48e" translate="yes" xml:space="preserve">
          <source>See &quot;&lt;a href=&quot;queryplanner-ng#fossilcasestudy&quot;&gt;The Fossil NGQP Upgrade Case Study&lt;/a&gt;&quot; for another real-world example of using CROSS JOIN to manually control the nesting order of a join. The &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt; found later in the same document provides further guidance on manual control of the query planner.</source>
          <target state="translated">CROSS JOIN을 사용하여 조인의 중첩 순서를 수동으로 제어하는 ​​또 다른 실제 예는 &quot; &lt;a href=&quot;queryplanner-ng#fossilcasestudy&quot;&gt;Fossil NGQP 업그레이드 사례 연구&lt;/a&gt; &quot;를 참조하십시오 . &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;체크리스트 쿼리 플래너&lt;/a&gt; 같은 문서 뒷부분의 쿼리 플래너의 수동 제어에 대한 자세한 지침을 제공한다.</target>
        </trans-unit>
        <trans-unit id="c132fc8253da62def423dbfbc9e5cc8f879698fd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#dbstatpath&quot;&gt;description above&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;#dbstatpath&quot;&gt;위의 설명을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc1406da130a4d62c75c39d9868f5406eb3bf35f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;#sqlite3_pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6719884b2a74c479ea6999c99dbf311d703b384" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://sqlite.org/'about.html'&quot;&gt;About SQLite&lt;/a&gt; for an overview of the SQLite software and what it does and how it is different.</source>
          <target state="translated">SQLite 소프트웨어에 대한 개요와 그 기능 및 기능에 대해서는 SQLite &lt;a href=&quot;https://sqlite.org/'about.html'&quot;&gt;정보를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a83862c5e73732d34809bc526149b8874a0b009" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt; for a full discussion of the limits of SQLite.</source>
          <target state="translated">SQLite의 한계에 대한 자세한 내용은 &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5702be68fafd67a2aafc342a3e205c709913ea24" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;pcache_methods2&quot;&gt;sqlite3_pcache_methods2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="67c5fd71325238ec1a4341afb9b6cba9315dbef4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;sharedcache&quot;&gt;SQLite 공유 캐시 모드&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61a08f389a25b863d0fca5015a2885ff6fd5c8cd" translate="yes" xml:space="preserve">
          <source>See Also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="93901f63e20a4a7a74fbfdbc37b4075a185c71c6" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;../backup&quot;&gt;Using the SQLite Online Backup API&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../backup&quot;&gt;SQLite는 온라인 백업 API를 사용하여&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3af600b61585b909b60b4a99e040268e0c2a856f" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;../sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../sharedcache&quot;&gt;SQLite는 공유 캐시 모드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c1b1d19f5868cf4d3018fb518dcfa6d87cc98cd" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;../unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../unlock_notify&quot;&gt;SQLite 잠금 해제 알림 기능 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7616c5088158f54a825d33709957167b8a16116d" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;backup&quot;&gt;Using the SQLite Online Backup API&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;backup&quot;&gt;SQLite는 온라인 백업 API를 사용하여&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f41977d4fff20685334fca06b182777534d39401" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;sharedcache&quot;&gt;SQLite는 공유 캐시 모드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f9e82ef52e9fb93669665e75ad01f2483ef4742" translate="yes" xml:space="preserve">
          <source>See Also: &lt;a href=&quot;unlock_notify&quot;&gt;Using the SQLite Unlock Notification Feature&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unlock_notify&quot;&gt;SQLite 잠금 해제 알림 기능 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="432cb254f15763b7805bdd86025f5f8cf43aec8f" translate="yes" xml:space="preserve">
          <source>See above.</source>
          <target state="translated">위 참조.</target>
        </trans-unit>
        <trans-unit id="383b0d124cc39b4f92b719a490622adb9db1929b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="588a701bb21ea6498fe1cee5a08846f3a6f8999b" translate="yes" xml:space="preserve">
          <source>See also lists of &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;, &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt;, and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; , &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 목록도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4c2ab778a085857c109eb7e8e5a5333d9b57f676" translate="yes" xml:space="preserve">
          <source>See also requirements H35180 and H35210 above.</source>
          <target state="translated">위의 요구 사항 H35180 및 H35210도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a69045200fe6eb4eefb6543d32d1c3986dee3e7a" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_commit_hook()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_rollback_hook()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_commit_hook ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_commit_hook&quot;&gt;sqlite3_rollback_hook ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ee912df6c5ce3441a9860f1d9730f7218ccc4b5" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26d056bc4928cd96df481ba3bb3da36ee6f31042" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="db4a83343835929e5d813cffa0b4f2b9793757ab" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;cintro&quot;&gt;Introduction To The SQLite C/C++ Interface&lt;/a&gt; for an introductory overview and roadmap to the dozens of SQLite interface functions.</source>
          <target state="translated">수십 개의 SQLite 인터페이스 함수에 대한 소개 및 로드맵 &lt;a href=&quot;cintro&quot;&gt;은 SQLite C / C ++ 인터페이스 소개를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="339862dc13bc1d57d7288f6688c75379763064fe" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;commit_hook&quot;&gt;sqlite3_commit_hook()&lt;/a&gt;, &lt;a href=&quot;commit_hook&quot;&gt;sqlite3_rollback_hook()&lt;/a&gt;, and &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;commit_hook&quot;&gt;sqlite3_commit_hook ()&lt;/a&gt; , &lt;a href=&quot;commit_hook&quot;&gt;sqlite3_rollback_hook ()&lt;/a&gt; 및 &lt;a href=&quot;preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a86c99c5bddb628e2b84fed31d31db9e2daeedae" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension () SQL 함수&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9551bbf4b06565a29addd67ff920566d10532258" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;schema_version pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b61abea4b86316c9bf1e59bfa90fae500f63cc2b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_application_id&quot;&gt;application_id pragma&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e8ceb2d0a12e5d383c6c33d1d4332e5b5c058b2" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt; pragmas.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_fullfsync&quot;&gt;fullfsync&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;checkpoint_fullfsync&lt;/a&gt; pragma 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ff63025923714eccfd1fedacdb3cbe9372c3a93" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;hard_heap_limit pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;hard_heap_limit pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="303adc506bf547b9de95bc776aebd335c64bd8fc" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; command which does most of the checking of PRAGMA integrity_check but runs much faster.</source>
          <target state="translated">대부분의 PRAGMA integrity_check 점검을 수행하지만 훨씬 빠르게 실행되는 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 명령을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="48f81b34f529fa4aeb1d561e1f3508b8413b778f" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a25a2daadf8d2856a4719203849a4c0af3fabe6d" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_user_version&quot;&gt;user_version pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2c007784e950bb7f56540883b26bce1ca576b693" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;quirks&quot;&gt;Quirks, Caveats, and Gotchas&lt;/a&gt; of SQLite.</source>
          <target state="translated">SQLite 의 &lt;a href=&quot;quirks&quot;&gt;Quirks, Caveats 및 Gotchas&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94811ce2c3eb27494bcc158d862a7722c04a876e" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook ()&lt;/a&gt; 인터페이스 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="22db3f40cf05b62413d309725844e929dbbe0d0d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;extended result code definitions&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#SQLITE_ABORT_ROLLBACK&quot;&gt;확장 된 결과 코드 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5824dbe2a36217f98b17445aa829e98c24d78c0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;file control opcodes&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#SQLITE_FCNTL_BEGIN_ATOMIC_WRITE&quot;&gt;파일 제어 opcode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a888d72c2aa71ea4f9e6a712bc7addf37488e84a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e55f94f79f49c504145ad61691b8c42ba593cff9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6713e8fdaa1ea389a2f09e3a9c9374683ab6d6b0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="11dc488cf1e9db5102b28629a96e4392dc29104c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c6912b2b4045c6f070e0edaa93c0875be5fd821" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close를 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a3f665ed626f2acf9c339d54e23c6812da36531" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c57adf1e621a68c73c17c8b0ecd787edffeb3799" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e289aacb066a0de1940f21ad59b6642609ced4a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed16()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_collation_needed&quot;&gt;sqlite3_collation_needed16 ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="513ba9fc0134937d2763a01c62173350a81c3bde" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf131b5c38b078229e14995e1d46c942918a4628" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_create_module&quot;&gt;sqlite3_create_module을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="389c907363aca1a027a67a5b885a2319a4ec35ed" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_data_count&quot;&gt;sqlite3_data_count을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0afc966be42fd6b30d673383499cb0059d1ed149" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_db_release_memory&quot;&gt;sqlite3_db_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81c3b36cbd377bb3ed1664b49ec3d43a5bc80371" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10a7701e6ed3e748294878d5accec5c9e67c8652" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_drop_modules&quot;&gt;sqlite3_drop_modules ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8c38544cc50a3f638d9d29eb83eea228ba0b685b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;SQLITE_VERSION ()&lt;/a&gt; 와 &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58d0868f2357d36a8bd2095b2af1bb408179b89d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_held()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_notheld()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_held ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_mutex_held&quot;&gt;sqlite3_mutex_notheld ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4a95fa8aab0e3bfa1d373ea225784189d0d07162" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_release_memory&quot;&gt;sqlite3_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="894a2c673c7c3998c0146ab1462bd48997eeefeb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension ()&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c349eaf02fbc75040833b27273fe78ce351a8517" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c4abfc13135b30c5ca35737473e62ae50fbba518" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="74b0b0a73811f9aef63fb1988c2a0ccf696926fc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="64b2c6cde7a64226fbe2ef3634045cd57dde9aaa" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="20e4f725a3076fc6b2bb57f870226dcb7c2cd741" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="435b8c7f1343e259185da08da01ab1604658c57c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="de67037e66e6bc2405fafd89b02748ccb563c8f4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sqlite3_update_hook&quot;&gt;sqlite3_update_hook을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="577203775c48a36ecdbe0e166cc73a6f94c49525" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../gencol&quot;&gt;gencol.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../gencol&quot;&gt;gencol.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81cf66782a01b719b906500422d08c6d8d672682" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang&quot;&gt;lang.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang&quot;&gt;lang.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c778a0f903e6e7a229a74dcc043ab7ce222f8e91" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang&quot;&gt;lang.html&lt;/a&gt;&lt;a href=&quot;../lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang&quot;&gt;lang.html &lt;/a&gt;&lt;a href=&quot;../lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a1623c388195369765189e361912596c2725840" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cca5d37155aa556de6dfac0b27a0e25fc7f06d7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;프라그. HTML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a6be53babfb0698dca91e0931b8046114c3258d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52bb34faf16293e7bf50504a84a6781db371ee0f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a14f661ac8c092f4fc1d99fc6d9d99e0d8ec786" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_conflict&quot;&gt;lang_conflict.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_conflict&quot;&gt;lang_conflict.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c07322809e26e45be23a95893f749e03af5c5ed5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="938b9621b107714962482883b255c3d80c08b6e7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15598ecd618474aabf3591017c513af8de8a6a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0485f89bf00139a21000442b6a6990659cb64b16" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="66948fd5b0afaf1cdc01aa29ecea4c1bfedab9de" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 및 &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee139ad90928eace8c30779bd5b6becd4f09c01d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79cd4e2359b15e6acab9aede873d664f2ede5a75" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2dfcbfb2abe59925659cc429708c6aec7eb406e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="658fb74ef352e297b395f96f857ceb7d3c615e2b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="13d94bc3fd2a819178c3e4749e7aa371e596de86" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f527f9debd0e925c5e233506e62bf945cd29ee28" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_indexedby&quot;&gt;lang_indexedby.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_indexedby&quot;&gt;lang_indexedby.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21b664cff26300df1357262d6ec594fb9ee3555c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91b6c24c68f47aa751a5b5b8df600dcca07d313d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1033e8985d4463e32f19095fed06fce8ea5476c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9218f7d1d52e1191bd9b8fb6db8d70bf8dc438f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="466d46beb84c6c8963a2f748f70f326309fffab5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4aef55367a00e308dff9639c75772858c63ff83" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56e9b6723fb1585f18d7b60fce22ac17b792e417" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d13d914d08b8f92116b29032480e38cbe265479" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cdd1d8b761b061d5aeaf839bfb496966e3e11c8e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="716c85dad4326320b2465878481f19b320bc4abf" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9246cf2807990b095780ac9e1b0dd561919984" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f43b3a3c761c07b37c7c96d59a19f91da1c40c6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59cd8724dea12b8ea965ab667c74e2d1d4fb024b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f03712d7de35eafa06ad69d4f67d162931ceee8e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="344cad8b96fcafcf74d42ebb4e8917a07994e94e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cafbbb26b01fe4aad5518dd3d8329918a47b638c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="194bd03307aa26e18f55046fce3dc35e20b6f469" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;&lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_savepoint&quot;&gt;lang_savepoint.html &lt;/a&gt;&lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bbc01924ed08271e9d7d2fafae0daf0758d4c29" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90a9a8514c72ec12bafb541c92e76fe75343369a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e20ee80f88a596c72e3b5175803d94c62b49d45" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="487a9f7edcc9acbd36e71269b10f3dabc3570792" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb4119b7d69b4e6da177cbf6ff9c4d155ae67444" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;../lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;../lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;../lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;../lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;../lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;../pragma&quot;&gt;프라그. html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="695ecd24fe66b529919da4afdf535e5125baa96e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;../lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0014eee39d17cd320cfc0ffbaab392f9f613f85" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29fadfcd5bcddd556613ead0e99dda8fc7fba83b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;../lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;../lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;../lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92b532e0d0d9df2c59df298af30c18a7e1da5dfe" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c013a0edc28859aa3e70e3276bdce16a070ed083" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a7eea93b457a57fc7fe1137ef59827626192c5a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../pragma&quot;&gt;pragma.html&lt;/a&gt; 도 참조하십시오</target>
        </trans-unit>
        <trans-unit id="c4c2bc470b47131356a55eedacd462eb96e84418" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;../pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1fe4145cb7c50a0d418d258d06542a1f8cb0dd39" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;../printf&quot;&gt;built-in printf()&lt;/a&gt;, &lt;a href=&quot;../lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;../printf&quot;&gt;내장의 printf ()&lt;/a&gt; , &lt;a href=&quot;../lang_corefunc#printf&quot;&gt;printf와 () SQL 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53567bfae3ebbf8bd0c18510f50128b0fee6e144" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="907bef21249483a496207cb807a74d758d2d3c63" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c1aadec23594d958a843556680b17a72abac74b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f45be66a2c5bcb3bc142d2c447ea57f0f20e31c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count()&lt;/a&gt;, &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name()&lt;/a&gt;, and &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bind_parameter_count&quot;&gt;sqlite3_bind_parameter_count ()&lt;/a&gt; , &lt;a href=&quot;bind_parameter_name&quot;&gt;sqlite3_bind_parameter_name ()&lt;/a&gt; 및 &lt;a href=&quot;bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37c010f71fba70b74109bbdc2b1ce08d14015c48" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;, &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt;, &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;, &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt;, &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close를 ()&lt;/a&gt; , &lt;a href=&quot;blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; , &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; , &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; , &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3dbeda6bcc23b238fd884c3cfaafcc8fb5f1870" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34c05c2c7478ddfc9595328b9ea47d96e84f4152" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b21a0b7337431e9ee24e69d231fe8302762a853" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;c_abort_rollback&quot;&gt;extended result code definitions&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;c_abort_rollback&quot;&gt;확장 된 결과 코드 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cfe354170b5e869c7270b91ade687416a54c0183" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;file control opcodes&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;c_fcntl_begin_atomic_write&quot;&gt;파일 제어 opcode&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37196415e76fa9d675c871c64b90e815741d0f92" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed()&lt;/a&gt; and &lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed16()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed ()&lt;/a&gt; 및 &lt;a href=&quot;collation_needed&quot;&gt;sqlite3_collation_needed16 ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="879f7e7ea46313e2ea71652b9ca7565db57df9c6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="319399ff5f7d4c689210338dddef1fb99518d24d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;compile#omit_automatic_index&quot;&gt;SQLITE_OMIT_AUTOMATIC_INDEX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b23baf151295ad1d1fe5328bd71961f497879ab" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;create_module&quot;&gt;sqlite3_create_module을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8661ec8b737499d91726c5f2f8d9c2e2296d1bc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;data_count&quot;&gt;sqlite3_data_count()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;data_count&quot;&gt;sqlite3_data_count을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e1099949ad00bb15eb69a605f4b4b3bbfd1aff7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;db_release_memory&quot;&gt;sqlite3_db_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bda4dfc70b5f71949880b44f021fef0f7b01aa87" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb201238a04d02eb3cb27c3d4ccc509df3614a14" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;drop_modules&quot;&gt;sqlite3_drop_modules ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2366873b192e78c89709e7d18ff2db2dcc967a55" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;gencol&quot;&gt;gencol.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;gencol&quot;&gt;gencol.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="524073d1a4577e6b594022dd278f36bd2dba0d4a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang&quot;&gt;lang.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang&quot;&gt;lang.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bc17dac7d9752b7811c2a93ab58e831060d9b9d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang&quot;&gt;lang.html&lt;/a&gt;&lt;a href=&quot;lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang&quot;&gt;lang.html &lt;/a&gt;&lt;a href=&quot;lang_explain&quot;&gt;lang_explain.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e55f6b8a291e9bc6872ef07f19648c06a63c7f96" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html#raise&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html # 인상 &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html 번호 simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3094ad1d98461c25d851d9b58614f8484829a717" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html#fromclause&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html # fromclause &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a742de555ecf28aa329a8d657a04db2888df41b9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_update.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # &lt;/a&gt;compound lang_select.html # &lt;a href=&quot;lang_update&quot;&gt;compound &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_select.html .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85abca3267512af73ec8afacb8584e803d672ab2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_update.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # &lt;/a&gt;compound lang_select.html # &lt;a href=&quot;lang_update&quot;&gt;compound &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_select.html .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14529eb0437c823ab68b15a8cd5ba3d6d655b2d3" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_update.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # &lt;/a&gt;compound lang_select.html # &lt;a href=&quot;lang_update&quot;&gt;compound &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_select.html .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # 구문&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="199a3a4fc6414fdf6ed7493a3c4733ad2cdbdb41" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html#booleanexpr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html # booleanexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="caee65c71137c00f3261816c349b1186b87ab07f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d5357ce486345b38e495fdd052bc12b972eb613" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html#altertabaddcol&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html # altertabaddcol &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df7e64b5e3be337fc1f98f552de8d797b4c2b99a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html#altertabaddcol&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_altertable#altertabaddcol&quot;&gt;lang_altertable.html # altertabaddcol &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a5b6f8bb5171cdb36ccd5c1ba734c2c233150b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_conflict&quot;&gt;lang_conflict.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;lang_createtable.html#notnullconst&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_conflict&quot;&gt;lang_conflict.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;lang_createtable.html # notnullconst&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6fcd1bfb338ad16eab298ffc4c9d868843b9b21" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8a36b3fb23e6333db428ab6ad00263be2d938abe" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_analyze&quot;&gt;lang_analyze.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c6b9466ba508d0dbec4f6c657f9fbfd7e620fc37" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5a54b9974971120efa52636fcabe0715b49415a8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_comment&quot;&gt;lang_comment.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2cb6c7d068dfff53d11c81dd36fe7afde23d11e5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#sqlite_version&quot;&gt;sqlite_version ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0913f10eba8984cde458a594e9723dae1e7b43d4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html#primkeyconst&lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html#uniqueconst&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html # primkeyconst &lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html # uniqueconst &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c7d4103ad522f08124a6ecef11b7bef6bb05216" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e9835eae374451ebfe2dabdb26ce73fec9a591b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d81d89904dc49fa50fb5551880967e2b9a7226cb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html#primkeyconst&lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html#tablecoldef&lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html#uniqueconst&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html # primkeyconst &lt;/a&gt;&lt;a href=&quot;lang_createtable#tablecoldef&quot;&gt;lang_createtable.html # tablecoldef &lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html # uniqueconst&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5aed25ab420fb0098c44d0bf5304a4aa707b088f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c514627329ad2c33195dc084716f51f489e5370e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e08547629c50834603a3c7451218441b495de5f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_indexedby&quot;&gt;lang_indexedby.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_indexedby&quot;&gt;lang_indexedby.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cba534e77f5dd456a33da03494144a81d39264cc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfa4d667a255f0c6828f6b1f4d098bfa8323d6e2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9614960e8904f53093287bbe50e05a997ac3824b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9b4f140896556a1fc2adbe8ac95c3f7dc29ba8a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eef9b3d74c59deea364b6f6ac6f20759d658b7f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_upsert&quot;&gt;lang_upsert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c39b25e28ca93d32b847b9c1af840e472af33477" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a07a8a7f1e0538e7658544150917395127562b6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6d60ea259f137afddc03af15fbdb1094689ece4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_createvtab&quot;&gt;lang_createvtab.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="724cccf74d74960b6796259fcacc12e153ae3f1a" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f80c5c57cfc045f570327a845f8127410c55f865" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_detach&quot;&gt;lang_detach.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76e8ddefbc493145192fc193cef9e039c65a902e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_dropindex&quot;&gt;lang_dropindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="863b8e5b897ce238b67c5c8556989e2766293313" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_droptable&quot;&gt;lang_droptable.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cf4b794db9d56879de07eb5f16a8bc2477ca90d4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_droptrigger&quot;&gt;lang_droptrigger.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="702f2b35823dcfd93d045f7d778af2c45120abe7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_dropview&quot;&gt;lang_dropview.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62511da10fbf7f958f155307ba6d4d102f35f3be" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html#booleanexpr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_expr#booleanexpr&quot;&gt;lang_expr.html # booleanexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="450581ca6e9de72c74dcb192b37f5747276658f1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_expr#litvalue&quot;&gt;lang_expr.html#litvalue&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_expr#litvalue&quot;&gt;lang_expr.html # litvalue&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae501b11617c0c13b2d3f762254b4ff760b36123" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_reindex&quot;&gt;lang_reindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d27e4055359a8aeac2ce66818352ec73c032ea4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7bb5ce5fe2a8f6a8de65bf4e7bd8b65d204d6093" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html&lt;/a&gt;&lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_savepoint&quot;&gt;lang_savepoint.html &lt;/a&gt;&lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="076fe51a7e12da80f3c9d8927a2ca4548526aa30" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9f5995b5a48f0fca91e5e282ac6950660e6528d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # compound &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d233e7ebdff319d51e7bd5e01dba623d32fa9ca0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # compound&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbbded1021d4435d1532c9af272fa7bccfd9c1d0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e964459d5f1a2e61a2e2cf50351a352d90c8e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_transaction&quot;&gt;lang_transaction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="600ef78a6f3fb8794c7d469e740f494486a2ac18" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7f048f330189613480493245819630da7093938" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_update#upfrom&quot;&gt;lang_update.html#upfrom&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_update#upfrom&quot;&gt;lang_update.html # upfrom&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ea152fe6b3f2ae351dd12abd4e8bbd78773fa59" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html#raise&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger#raise&quot;&gt;lang_createtrigger.html # 인상 &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select .html 중에서 # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b469ebdf9c6c7fd0d09e8c5ea21cd29a3c4e951" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html#fromclause&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#fromclause&quot;&gt;lang_select.html # fromclause &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select .html 중에서 # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb12fe633d07848eb5eb066e9d5b752ffef1d5c2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bed845bd614c9a71113bf4e2612d286c51c5869c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e12f9a6f89dbcc84809953e2fd797afd11b684ab" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html&lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html&lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html&lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html&lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html#compound&lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html#simpleselect&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_aggfunc&quot;&gt;lang_aggfunc.html &lt;/a&gt;&lt;a href=&quot;lang_altertable&quot;&gt;lang_altertable.html &lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;lang_attach.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_createview&quot;&gt;lang_createview.html &lt;/a&gt;&lt;a href=&quot;lang_delete&quot;&gt;lang_delete.html &lt;/a&gt;&lt;a href=&quot;lang_expr&quot;&gt;lang_expr.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_select&quot;&gt;lang_select.html &lt;/a&gt;&lt;a href=&quot;lang_select#compound&quot;&gt;lang_select.html # 화합물 &lt;/a&gt;&lt;a href=&quot;lang_select#simpleselect&quot;&gt;lang_select.html # simpleselect &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update .html 중에서 &lt;/a&gt;&lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # 구문&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a66f16d59067e2dbd5b05e42ceffc5ed1382738" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html&lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html&lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html#primkeyconst&lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html#uniqueconst&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_createindex&quot;&gt;lang_createindex.html &lt;/a&gt;&lt;a href=&quot;lang_createtable&quot;&gt;lang_createtable.html &lt;/a&gt;&lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;lang_createtable.html # primkeyconst &lt;/a&gt;&lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;lang_createtable.html # uniqueconst &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;partialindex&quot;&gt;partialindex.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10943101e04a10c530372cbdc34663b3698984dc" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9086346182d6b8670bc03f1e0367b327298a39af" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html&lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html&lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html&lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_upsert&quot;&gt;lang_UPSERT.html &lt;/a&gt;&lt;a href=&quot;lang_createtrigger&quot;&gt;lang_createtrigger.html &lt;/a&gt;&lt;a href=&quot;lang_insert&quot;&gt;lang_insert.html &lt;/a&gt;&lt;a href=&quot;lang_update&quot;&gt;lang_update.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73bb61ec2320cac51957bb5504dbbbfced735f05" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_vacuum&quot;&gt;lang_vacuum.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d881dae8fea8469aae36dd2ee790aadd7154e19f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11284ab305581840484673ba82b0814730899f19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_with&quot;&gt;lang_with.html&lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_with&quot;&gt;lang_with.html &lt;/a&gt;&lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8eb5bc217d7c409f9004989bbcff9c4c5cf371c2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html#recursivecte&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;lang_with#recursivecte&quot;&gt;lang_with.html # recursivecte&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa9202aad9353cf3bd304d5cebf941f8826269aa" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion()&lt;/a&gt;, &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number()&lt;/a&gt;, &lt;a href=&quot;libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;, &lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;sqlite_version()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">참조 : &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion ()&lt;/a&gt; , &lt;a href=&quot;libversion&quot;&gt;sqlite3_libversion_number ()&lt;/a&gt; , &lt;a href=&quot;libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; , &lt;a href=&quot;../lang_corefunc#sqlite_version&quot;&gt;SQLITE_VERSION ()&lt;/a&gt; 와 &lt;a href=&quot;../lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="59473a97c323cc840c551bb609b5c7d0085ba6eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_held()&lt;/a&gt; and &lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_notheld()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_held ()&lt;/a&gt; 및 &lt;a href=&quot;mutex_held&quot;&gt;sqlite3_mutex_notheld ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="630f877a63f0639718e0dd30c5ba43ed3ce847e4" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;, &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt; , &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e32027cc4318d132c8299361aadd44d5d68a5d39" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;, &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt; , &lt;a href=&quot;opcode#PureFunc&quot;&gt;PureFunc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4db38cc313bd0bbfdf49c1b12a83a1dee3351e3" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Clear&quot;&gt;Clear&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Clear&quot;&gt;클리어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5545504df0c88112cd5943b39942072e292d1b27" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Destroy&quot;&gt;파괴&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20c38d168152c392bc03b5b47997e5daa1c0d099" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#EndCoroutine&quot;&gt;EndCoroutine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08083583312e5bf15079e8c8852f8fa2944302ac" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;, &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt;, &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; , &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt; , &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="728b62ca2d8ad20f62ae93f93571e44c2d32c79b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt;, &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt; , &lt;a href=&quot;opcode#SeekRowid&quot;&gt;SeekRowid&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fd951d3cf17be16c77767dc1e177d397520dea6" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekGt, SeekGe, SeekLe</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekGt, SeekGe, SeekLe</target>
        </trans-unit>
        <trans-unit id="d6d2c334da88e15e756581a4f59c5b04ba796944" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekGt, SeekGe, SeekLt</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekGt, SeekGe, SeekLt</target>
        </trans-unit>
        <trans-unit id="463d18a76e981873861ffff7fe5e29e0c6efda87" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekLt, SeekGe, SeekLe</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekLt, SeekGe, SeekLe</target>
        </trans-unit>
        <trans-unit id="5e40d5e71843bb61f4bcfed5badcd97abfd6de6d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, SeekLt, SeekGt, SeekLe</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , SeekLt, SeekGt, SeekLe</target>
        </trans-unit>
        <trans-unit id="a7f677a2db2a47580eeed83b42a807730b2d65e8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt;, &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Function&quot;&gt;Function&lt;/a&gt; , &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3e78d904f537e5ecc229d2e4161074c489fc983" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Function0&quot;&gt;Function0&lt;/a&gt;, &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt;, &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Function0&quot;&gt;Function0&lt;/a&gt; , &lt;a href=&quot;opcode#AggStep&quot;&gt;AggStep&lt;/a&gt; , &lt;a href=&quot;opcode#AggFinal&quot;&gt;AggFinal&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27fe557b8f91eb0f3354ec57fe69933ee8436f35" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#InitCoroutine&quot;&gt;InitCoroutine&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#InitCoroutine&quot;&gt;InitCoroutine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cea6a531330c212ca3ca25d87fa43558d171705c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt;, &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;</source>
          <target state="translated">참고 항목 : &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#Found&quot;&gt;Found&lt;/a&gt; , &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab8929f50dfeea96d663b01dc70be8c6ea741b4c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt;, &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt;. SeekGe</source>
          <target state="translated">&lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#NoConflict&quot;&gt;NoConflict&lt;/a&gt; , &lt;a href=&quot;opcode#NotExists&quot;&gt;NotExists&lt;/a&gt; 도 참조하십시오 . 찾기</target>
        </trans-unit>
        <trans-unit id="df9b249fadb76a9e89f33c8e160d939f3e2edb65" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt;, &lt;a href=&quot;opcode#SeekHit&quot;&gt;SeekHit&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#NotFound&quot;&gt;NotFound&lt;/a&gt; , &lt;a href=&quot;opcode#SeekHit&quot;&gt;SeekHit&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77125e42082bd4063983bc366f2a58ec8989ce3d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;, &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; , &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42804456c026cdba0e420c9f8f25e7f6180f2cc2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt;, &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#OpenRead&quot;&gt;OpenRead&lt;/a&gt; , &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="585491e299c7017859c50fd2fe8c2f25dc1e9732" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt;, &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#OpenWrite&quot;&gt;OpenWrite&lt;/a&gt; , &lt;a href=&quot;opcode#ReopenIdx&quot;&gt;ReopenIdx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4168a3bf16312be37846589fb27785a113af6811" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Prev&quot;&gt;Prev&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;opcode#Prev&quot;&gt;이전&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c516f46aa712315eea6584868cd627c02de7056" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt;, &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;opcode#Rowid&quot;&gt;Rowid&lt;/a&gt; , &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f01472d4da0f8e936c195c67175f791d08d0adbf" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;PRAGMA busy_timeout&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d54723288e675ac0abb24e0dd779375fca23df6b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bfa2363ed594f2b2eede2b270349dfc67d7ebc18" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html#syntax&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#syntax&quot;&gt;pragma.html # syntax&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8a4951221a904acb6ba86986765efc2037a09378" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;printf&quot;&gt;built-in printf()&lt;/a&gt;, &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;printf&quot;&gt;내장의 printf ()&lt;/a&gt; , &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf와 () SQL 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99bd38c265a6fb23dc830f7fe8c080eded5d7a07" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;release_memory&quot;&gt;sqlite3_release_memory을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98b434bc0d8b8d185283486c42d9be672854146f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; and &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rescode#busy_recovery&quot;&gt;SQLITE_BUSY_RECOVERY&lt;/a&gt; 및 &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7299f9082103db8b34938e68ec91bd133f202916" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension()&lt;/a&gt; and &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension()&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;reset_auto_extension&quot;&gt;sqlite3_reset_auto_extension ()&lt;/a&gt; 및 &lt;a href=&quot;cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension ()&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fa3c9ecf5456096c4af70cc1a45db8215c53ecad" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="81c9581d614ee93295a05913a13ce83a1c537800" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;status&quot;&gt;sqlite3_status()&lt;/a&gt; and &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;status&quot;&gt;sqlite3_status ()&lt;/a&gt; 및 &lt;a href=&quot;stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51bddd2f47aedb88c82ed00196f1d5f18d63b931" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;stmt_scanstatus_reset&quot;&gt;sqlite3_stmt_scanstatus_reset ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5f9c8eaf62fde3d86c43f634a7ab02bd2fa6122" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0933bf0a406419507f269f3297ab20733c0130b5" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="673270029c9264ee605b8c3d4c2fd772ac5ed2ec" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f7a6a573f1a49c137144c2c0c0b973878be6af5b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook()&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;update_hook&quot;&gt;sqlite3_update_hook을 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b9de33ebd0cee270413e31ceb4bf9982bf25845" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">SQL 함수 &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; 및 &lt;a href=&quot;../lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; 및 &lt;a href=&quot;../pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83dccf87582bc1362c408c238feac4693c82e492" translate="yes" xml:space="preserve">
          <source>See also: SQL functions &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; and the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt;.</source>
          <target state="translated">SQL 함수 &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get ()&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="61cca4e5d339d369ec47f24cb61df5080a8fe143" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f095aa19ffa800ceddf0ec91e83f4521ad7e3e5" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;../uri&quot;&gt;URI 파일 이름&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="14bd56e01493d3e179ad29ee876d123ae68f7d39" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;assert&quot;&gt;Use Of assert in SQLite&lt;/a&gt; document for additional information about how SQLite uses assert().</source>
          <target state="translated">SQLite가 assert ()를 사용하는 방법에 대한 추가 정보 &lt;a href=&quot;assert&quot;&gt;는 SQLite에서 assert 사용&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7c31bb847b7fb9dd4bac9cc5dd5dc1c96846800" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT documentation&lt;/a&gt; for detailed instructions on what AUTOINCREMENT does and does not do in SQLite.</source>
          <target state="translated">AUTOINCREMENT가 SQLite에서 수행하는 것과 수행하지 않는 것에 대한 자세한 지시 사항 은 &lt;a href=&quot;autoinc&quot;&gt;SQLite AUTOINCREMENT 문서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53b783989abda8014ea3d71299fadcaac3ac76a4" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;datatype3&quot;&gt;Datatypes in SQLite Version 3&lt;/a&gt; document for a detailed discussion of the type system in SQLite.</source>
          <target state="translated">&lt;a href=&quot;datatype3&quot;&gt;SQLite&lt;/a&gt; 의 유형 시스템에 대한 자세한 내용은 SQLite 버전 3 의 데이터 유형 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b929f22f98901beb9b1139bf55e5ff321f37875f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; document for instructions and hints on how to compile the program shown above.</source>
          <target state="translated">위에 표시된 프로그램을 컴파일하는 방법에 대한 지침과 힌트는 &lt;a href=&quot;howtocompile&quot;&gt;SQLite를 컴파일&lt;/a&gt; 하는 방법 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d23d8904a4dd8b2f59b61ec1f1d5eb8f80e47737" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information on aspects of using SQLite in a multithreaded environment.</source>
          <target state="translated">멀티 스레드 환경에서 SQLite 사용에 대한 추가 정보 는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a87fd9fe2045f5442c46fbc8912602fdbac0e8ba" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="30f1bf85315b67413bef1d018f3d407e1c5b8c20" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt; documentation for additional information.</source>
          <target state="translated">추가 정보 는 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86902a781e00345ab7ead57f5c2f261448269986" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;vtablist&quot;&gt;list of virtual tables&lt;/a&gt; page for a longer list of actual virtual table implementations.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;vtablist&quot;&gt;가상 테이블의 목록&lt;/a&gt; 실제 가상 테이블 구현의 긴 목록 페이지를.</target>
        </trans-unit>
        <trans-unit id="bd6efac597cb0708970fe4961b56a3edc46475fe" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;whentouse&quot;&gt;Appropriate Uses For SQLite&lt;/a&gt; document for additional information.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;whentouse&quot;&gt;SQLite에 적절한 사용&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07ba693c1bca5dde244a27275e6109ebcc9602e4" translate="yes" xml:space="preserve">
          <source>See the separate &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; documentation for the additional trailing syntax that can cause an INSERT to behave as an UPDATE if the INSERT would otherwise violate a uniqueness constraint. The &lt;a href=&quot;lang_upsert&quot;&gt;upsert clause&lt;/a&gt; is not allowed on an &quot;INSERT ... DEFAULT VALUES&quot;.</source>
          <target state="translated">INSERT가 고유 제한 조건을 위반하는 경우 INSERT가 UPDATE로 작동하게 할 수있는 추가 후행 구문에 대해서는 별도의 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; 문서를 참조하십시오 . &quot;INSERT ... DEFAULT VALUES&quot; 에는 &lt;a href=&quot;lang_upsert&quot;&gt;upsert 절이&lt;/a&gt; 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="939683e9d52824a9f73508cf71bd83e60abff90a" translate="yes" xml:space="preserve">
          <source>See xPhraseFirst above.</source>
          <target state="translated">위의 xPhraseFirst를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a932238dbfaf0b21024ff5809159c0de781840d" translate="yes" xml:space="preserve">
          <source>See xPhraseFirstColumn above.</source>
          <target state="translated">위의 xPhraseFirstColumn을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9f853fa8d7ff147b89090825d00dc78b2f44a321" translate="yes" xml:space="preserve">
          <source>SeekEnd</source>
          <target state="translated">SeekEnd</target>
        </trans-unit>
        <trans-unit id="9fadfc9b512132149df920b10f206da2333bd9fa" translate="yes" xml:space="preserve">
          <source>SeekGE</source>
          <target state="translated">SeekGE</target>
        </trans-unit>
        <trans-unit id="1087f36e7b18281af36dad7cdbb8cd08b7115d15" translate="yes" xml:space="preserve">
          <source>SeekGT</source>
          <target state="translated">SeekGT</target>
        </trans-unit>
        <trans-unit id="460ea4a32fd1274da2db98168e01568ac9ce63a6" translate="yes" xml:space="preserve">
          <source>SeekHit</source>
          <target state="translated">SeekHit</target>
        </trans-unit>
        <trans-unit id="0b4f0d008f842f314db6efb3fa8c1e4f9ad7e37b" translate="yes" xml:space="preserve">
          <source>SeekLE</source>
          <target state="translated">SeekLE</target>
        </trans-unit>
        <trans-unit id="5c9e6758b219b2706a95d7da88c60ef0eba6fe03" translate="yes" xml:space="preserve">
          <source>SeekLT</source>
          <target state="translated">SeekLT</target>
        </trans-unit>
        <trans-unit id="141e7ed653901b0f647fda720472fc6667150f0c" translate="yes" xml:space="preserve">
          <source>SeekRowid</source>
          <target state="translated">SeekRowid</target>
        </trans-unit>
        <trans-unit id="c6ed6b18512dd3401d381c337b03a01488f90762" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Interior Node Format</source>
          <target state="translated">세그먼트 B- 트리 내부 노드 형식</target>
        </trans-unit>
        <trans-unit id="cc806c94f6fb1d331e8fb663d9d4f7e22793356b" translate="yes" xml:space="preserve">
          <source>Segment B-Tree Leaf Node Format</source>
          <target state="translated">세그먼트 B- 트리 리프 노드 형식</target>
        </trans-unit>
        <trans-unit id="fe4aff672a9c860addca0cf569e240d57055e4c7" translate="yes" xml:space="preserve">
          <source>Segment b-trees are prefix-compressed b+-trees. There is one segment b-tree for each row in the %_segdir table (see above). The root node of the segment b-tree is stored as a blob in the &quot;root&quot; field of the corresponding row of the %_segdir table. All other nodes (if any exist) are stored in the &quot;blob&quot; column of the %_segments table. Nodes within the %_segments table are identified by the integer value in the blockid field of the corresponding row. The following table describes the fields of the %_segdir table:</source>
          <target state="translated">세그먼트 b- 트리는 접두사 압축 b +-트리입니다. % _segdir 테이블의 각 행마다 하나의 세그먼트 b- 트리가 있습니다 (위 참조). 세그먼트 b- 트리의 루트 노드는 % _segdir 테이블의 해당 행의 &quot;루트&quot;필드에 블롭으로 저장됩니다. 다른 모든 노드 (있는 경우)는 % _segments 테이블의 &quot;blob&quot;열에 저장됩니다. % _segments 테이블 내의 노드는 해당 행의 blockid 필드에서 정수 값으로 식별됩니다. 다음 표는 % _segdir 테이블의 필드를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="982d848bdbaf7ffda27f7d8aca752c82359ccf6f" translate="yes" xml:space="preserve">
          <source>Segment btree</source>
          <target state="translated">세그먼트 btree</target>
        </trans-unit>
        <trans-unit id="40bf8b12088788ad70716eb1793e4cf249c09782" translate="yes" xml:space="preserve">
          <source>Separate INTEGER and REAL affinity</source>
          <target state="translated">별도의 INTEGER 및 REAL 선호도</target>
        </trans-unit>
        <trans-unit id="ba899678ef1e0fdd6b5eb799ee7abdd42cf175bf" translate="yes" xml:space="preserve">
          <source>Separating a database from its journal</source>
          <target state="translated">저널에서 데이터베이스 분리</target>
        </trans-unit>
        <trans-unit id="5c8f4e0e1a2281faf562976c2410f76c3d8fbc95" translate="yes" xml:space="preserve">
          <source>Sequence</source>
          <target state="translated">Sequence</target>
        </trans-unit>
        <trans-unit id="841936f1610c7b00e43fa53fbf75fb9b11abf32f" translate="yes" xml:space="preserve">
          <source>SequenceTest</source>
          <target state="translated">SequenceTest</target>
        </trans-unit>
        <trans-unit id="e12fccff7a8e896ad7cfa282736ffc4187cd7eaa" translate="yes" xml:space="preserve">
          <source>Serial Type</source>
          <target state="translated">시리얼 타입</target>
        </trans-unit>
        <trans-unit id="307ffd15fed4aa8193a8701f2970a48ccbc74bb4" translate="yes" xml:space="preserve">
          <source>Serial Type Codes Of The Record Format</source>
          <target state="translated">레코드 형식의 시리얼 타입 코드</target>
        </trans-unit>
        <trans-unit id="b61faef97a33774dc6199c619a4461fc18672af3" translate="yes" xml:space="preserve">
          <source>Serial type</source>
          <target state="translated">시리얼 타입</target>
        </trans-unit>
        <trans-unit id="44bc81d8890afcfb324491bf1c0f95cb6563d3cc" translate="yes" xml:space="preserve">
          <source>Serialize a database</source>
          <target state="translated">데이터베이스 직렬화</target>
        </trans-unit>
        <trans-unit id="90c4f08f792523112df74bc852026385bd4f8127" translate="yes" xml:space="preserve">
          <source>Session Object Handle</source>
          <target state="translated">세션 객체 핸들</target>
        </trans-unit>
        <trans-unit id="67e2e54aa75dbe4ba2529dc4e44d334d5c33427e" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">이 함수를 사용하여 작성된 세션 오브젝트 는 첨부 된 데이터베이스 핸들이 자체적으로 닫기 전에 &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 함수를 사용하여 삭제해야합니다 . 세션 객체를 삭제하기 전에 데이터베이스 핸들을 닫으면 세션 객체의 &lt;a href=&quot;#sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 를 포함하여 세션 모듈 함수를 호출 한 결과 가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36d7089db75a5bb06f2dd690097a4896b0ce0449" translate="yes" xml:space="preserve">
          <source>Session objects created using this function should be deleted using the &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; function before the database handle that they are attached to is itself closed. If the database handle is closed before the session object is deleted, then the results of calling any session module function, including &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete()&lt;/a&gt; on the session object are undefined.</source>
          <target state="translated">이 함수를 사용하여 작성된 세션 오브젝트 는 첨부 된 데이터베이스 핸들이 자체적으로 닫기 전에 &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 함수를 사용하여 삭제해야합니다 . 세션 객체를 삭제하기 전에 데이터베이스 핸들을 닫으면 세션 객체의 &lt;a href=&quot;sqlite3session_delete&quot;&gt;sqlite3session_delete ()&lt;/a&gt; 를 포함하여 세션 모듈 함수를 호출 한 결과 가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea1b131b3c13e62fbcb2b7e1d8113240624fdfe2" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">첨부 된 데이터베이스 핸들을 닫기 전에 세션 오브젝트를 삭제해야합니다. 자세한 내용 은 &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="8a0df1e5a24e2b0c00b060a82e0a73f3246a4f51" translate="yes" xml:space="preserve">
          <source>Session objects must be deleted before the database handle to which they are attached is closed. Refer to the documentation for &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt; for details.</source>
          <target state="translated">첨부 된 데이터베이스 핸들을 닫기 전에 세션 오브젝트를 삭제해야합니다. 자세한 내용 은 &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt; 설명서를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="6adb93a894674d02e091209977b242c152440ac9" translate="yes" xml:space="preserve">
          <source>Set *pnInst to the total number of occurrences of all phrases within the query within the current row. Return SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">* pnInst를 현재 행 내에서 조회 내의 모든 구의 총 발생 수로 설정하십시오. 성공하면 SQLITE_OK를, 오류가 발생하면 오류 코드 (예 : SQLITE_NOMEM)를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="efdec671fc0ce8bcb4bdb00d3f437085821cf12c" translate="yes" xml:space="preserve">
          <source>Set A Busy Timeout</source>
          <target state="translated">통화 중 시간 초과 설정</target>
        </trans-unit>
        <trans-unit id="b1a0dded912756ecf2b97f232c897007421fbf5d" translate="yes" xml:space="preserve">
          <source>Set Or Clear the Indirect Change Flag</source>
          <target state="translated">간접 변경 플래그 설정 또는 해제</target>
        </trans-unit>
        <trans-unit id="3a493136e0eeea58ea401cab071add271017a5ae" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object</source>
          <target state="translated">세션 객체에 테이블 필터 설정</target>
        </trans-unit>
        <trans-unit id="732b690730c3e6587386dab945ec7951b556c520" translate="yes" xml:space="preserve">
          <source>Set a table filter on a Session Object.</source>
          <target state="translated">세션 개체에 테이블 필터를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1ac264a53518ed313b058a0a099912f2a35d826a" translate="yes" xml:space="preserve">
          <source>Set an upper bound on the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,N) setting that determines the maximum number of auxiliary threads that a single &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; will use to aid with CPU-intensive computations (mostly sorting). See also the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; options.</source>
          <target state="translated">상부상의 바인딩 설정 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (DB, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; 한 것을 보조 스레드의 최대 번호를 결정하고, N)의 설정 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비가 문&lt;/a&gt; (주로 정렬) CPU 집약적 인 계산으로 처치하는 데 사용한다. &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; 옵션 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92f46b19209e84ffdca742022b56dfdca2dfb583" translate="yes" xml:space="preserve">
          <source>Set register P1 to have the value NULL as seen by the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instruction, but do not free any string or blob memory associated with the register, so that if the value was a string or blob that was previously copied using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, the copies will continue to be valid.</source>
          <target state="translated">&lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어에서 볼 수 있듯이 레지스터 P1을 NULL 값으로 설정 하지만 레지스터와 연관된 문자열 또는 블로 브 메모리를 비우지 마십시오. 값이 이전에 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy를&lt;/a&gt; 사용하여 복사 된 문자열 또는 블로 브 인 경우 사본은 계속됩니다 유효합니다.</target>
        </trans-unit>
        <trans-unit id="cd7e5b09719a46bb1ffbc4c18faade6d76d5478d" translate="yes" xml:space="preserve">
          <source>Set the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag. This prevents ordinary SQL statements from deliberately corrupting the database file. SQLite should be proof against attacks that involve both malicious SQL inputs and a maliciously corrupted database file at the same time. Nevertheless, denying a script-only attacker access to corrupt database inputs provides an extra layer of defense.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그를 설정하십시오 . 이는 일반 SQL 문이 의도적으로 데이터베이스 파일을 손상시키지 못하게합니다. SQLite는 악의적 인 SQL 입력과 악의적으로 손상된 데이터베이스 파일을 동시에 포함하는 공격에 대한 증거입니다. 그럼에도 불구하고 스크립트 전용 공격자가 손상된 데이터베이스 입력에 대한 액세스를 거부하면 추가적인 방어 계층이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="241b76cbed3f5655045e8aff832d7f03205ef4fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value</source>
          <target state="translated">마지막 삽입 Rowid 값 설정</target>
        </trans-unit>
        <trans-unit id="3a9eaa4fc5302f500031c0b5a5700811aa0eb0fe" translate="yes" xml:space="preserve">
          <source>Set the Last Insert Rowid value.</source>
          <target state="translated">Last Insert Rowid 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5a5c894fd85a90ba517e62438c5aff9b40ab8cb2" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">SQLITE_DBCONFIG_RESET_DATABASE 플래그를 설정 한 후 &lt;a href=&quot;../lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행 하여 데이터베이스없이 스키마와 컨텐츠가없는 빈 데이터베이스로 데이터베이스를 재설정하십시오. 다음 프로세스는 심하게 손상된 데이터베이스 파일에 대해서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5453fe3bee790f9b36f9a933f54e5899bdab502e" translate="yes" xml:space="preserve">
          <source>Set the SQLITE_DBCONFIG_RESET_DATABASE flag and then run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; in order to reset a database back to an empty database with no schema and no content. The following process works even for a badly corrupted database file:</source>
          <target state="translated">SQLITE_DBCONFIG_RESET_DATABASE 플래그를 설정 한 후 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행 하여 데이터베이스없이 스키마와 컨텐츠가없는 빈 데이터베이스로 데이터베이스를 재설정하십시오. 다음 프로세스는 심하게 손상된 데이터베이스 파일에 대해서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61c4c40f9a1bb5c18ccdd11c74e4b4fffa0d66f4" translate="yes" xml:space="preserve">
          <source>Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll back any currently active btree transactions. If there are any active VMs (apart from this one), then a ROLLBACK fails. A COMMIT fails if there are active writing VMs or active VMs that use shared cache.</source>
          <target state="translated">데이터베이스 자동 커밋 플래그를 P1 (1 또는 0)으로 설정하십시오. P2가 true이면 현재 활성화 된 btree 트랜잭션을 롤백하십시오. 활성 VM (이 VM 제외)이 있으면 ROLLBACK이 실패합니다. 활성 쓰기 VM 또는 공유 캐시를 사용하는 활성 VM이 있으면 COMMIT가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d6cb86bbec6abe009ef2b13054a8bf71fb971e51" translate="yes" xml:space="preserve">
          <source>Set the default size limit (in bytes) for in-memory databases created using &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt;. This is just the default. The limit can be changed at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;,N) or at run-time for individual databases using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt;. If no default is specified, 1073741824 is used.</source>
          <target state="translated">&lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()를&lt;/a&gt; 사용하여 작성된 메모리 내 데이터베이스에 대한 기본 크기 제한 (바이트)을 설정하십시오 . 이것은 단지 기본값입니다. &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt; , N)를 사용하여 시작시 또는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어를&lt;/a&gt; 사용하여 개별 데이터베이스에 대해 런타임 시 한계를 변경할 수 있습니다 . 기본값을 지정하지 않으면 1073741824가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="866d8eaf3728a827f036375926469bd93bf88bea" translate="yes" xml:space="preserve">
          <source>Set the permutation used by the &lt;a href=&quot;opcode#Compare&quot;&gt;Compare&lt;/a&gt; operator in the next instruction. The permutation is stored in the P4 operand.</source>
          <target state="translated">다음 명령어에서 &lt;a href=&quot;opcode#Compare&quot;&gt;비교&lt;/a&gt; 연산자가 사용하는 순열을 설정하십시오 . 순열은 P4 피연산자에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="ffc497dd2e0254996f63fed1801e825a18a0d70e" translate="yes" xml:space="preserve">
          <source>Set the seekHit flag on cursor P1 to the value in P2. The seekHit flag is used by the &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode.</source>
          <target state="translated">커서 P1의 seekHit 플래그를 P2의 값으로 설정하십시오. seekHit 플래그는 &lt;a href=&quot;opcode#IfNoHope&quot;&gt;IfNoHope&lt;/a&gt; opcode에 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f917c903736a886e2bae7dda91eb93f9fc5b88f2" translate="yes" xml:space="preserve">
          <source>Set up a process-wide &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">프로세스 전체 &lt;a href=&quot;errlog&quot;&gt;오류 로그를&lt;/a&gt; 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="f899229bce65615b9a9aafe730afb3055fc1d664" translate="yes" xml:space="preserve">
          <source>Set up register P1 so that it will &lt;a href=&quot;opcode#Yield&quot;&gt;Yield&lt;/a&gt; to the coroutine located at address P3.</source>
          <target state="translated">이 때문에 이렇게 레지스터 P1 설정 &lt;a href=&quot;opcode#Yield&quot;&gt;수율&lt;/a&gt; 어드레스 P3에 위치하는 코 루틴에 관한 것이다.</target>
        </trans-unit>
        <trans-unit id="c422fe10a5573aa6ba7e50d9c77e20ca08878af0" translate="yes" xml:space="preserve">
          <source>SetCookie</source>
          <target state="translated">SetCookie</target>
        </trans-unit>
        <trans-unit id="01b3682b02999bc0d6273ad2e8a1ce7b60079442" translate="yes" xml:space="preserve">
          <source>Sets the &quot;fired&quot; flag to true.</source>
          <target state="translated">&quot;fired&quot;플래그를 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="5f1906e535428a6ef107759522f33ae96d47ce23" translate="yes" xml:space="preserve">
          <source>Sets the default size of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; memory pool to N entries of SZ bytes each. This setting can be modified at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt;) and/or as each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is opened using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자&lt;/a&gt; 메모리 풀 의 기본 크기를 각각 SZ 바이트의 N 개 항목으로 설정합니다. 이 설정은 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; )를 사용하여 시작시 및 / 또는 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; )를 사용하여 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 열릴 때 수정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8f949c67297579c935535017d3f831289e19ac6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt; can cause the database to go corrupt if there is an operating-system crash or power failure, though this setting is safe from damage due to application crashes.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF를&lt;/a&gt; 설정 하면 운영 체제 충돌 또는 전원 장애가 발생하는 경우 데이터베이스가 손상 될 수 있지만이 설정은 응용 프로그램 충돌로 인한 손상으로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="aefdd1b85748c7d4a0d551399e2edc72cd30afa6" translate="yes" xml:space="preserve">
          <source>Setting &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema=ON&lt;/a&gt; and then changing the database schema using DML statements can render the database completely unreadable, if not done carefully.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema = ON을&lt;/a&gt; 설정 한 다음 DML 문을 사용하여 데이터베이스 스키마를 변경하면 신중하게 수행하지 않으면 데이터베이스를 완전히 읽을 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa000f3c0976d971f291c1208857c79532870ca" translate="yes" xml:space="preserve">
          <source>Setting The Result Of An SQL Function</source>
          <target state="translated">SQL 함수의 결과 설정</target>
        </trans-unit>
        <trans-unit id="1d4603c6597b76da3d906d68cccdecf5180cbe08" translate="yes" xml:space="preserve">
          <source>Setting The Subtype Of An SQL Function</source>
          <target state="translated">SQL 함수의 하위 유형 설정</target>
        </trans-unit>
        <trans-unit id="16955fa7b436cf8874edb738f171a4d0ef509182" translate="yes" xml:space="preserve">
          <source>Setting fullfsync on a Mac will guarantee that data really does get pushed out to the disk platter on a flush. But the implementation of fullfsync involves resetting the disk controller. And so not only is it profoundly slow, it also slows down other unrelated disk I/O. So its use is not recommended.</source>
          <target state="translated">Mac에서 fullfsync를 설정하면 데이터가 실제로 디스크 플래터로 플러시 될 수 있습니다. 그러나 fullfsync를 구현하려면 디스크 컨트롤러를 재설정해야합니다. 따라서 속도가 매우 느릴뿐만 아니라 관련이없는 다른 디스크 I / O도 느려집니다. 따라서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3eaa36d1b6e824ce1fa2d9dd603bd95da85fa485" translate="yes" xml:space="preserve">
          <source>Setting the automerge parameter to a non-zero value enables automatic incremental merging. This causes SQLite to do a small amount of inverted index merging after every INSERT operation. The amount of merging performed is designed so that the FTS3/4 table never reaches a point where it has 16 segments at the same level and hence has to do a large merge in order to complete an insert. In other words, automatic incremental merging is designed to prevent spiky INSERT performance.</source>
          <target state="translated">automerge 매개 변수를 0이 아닌 값으로 설정하면 자동 증분 병합이 가능합니다. 이로 인해 SQLite는 모든 INSERT 작업 후에 소량의 반전 된 인덱스 병합을 수행합니다. 수행되는 병합 양은 FTS3 / 4 테이블이 동일한 수준에서 16 개의 세그먼트를 갖는 지점에 도달하지 않으므로 삽입을 완료하기 위해 큰 병합을 수행하도록 설계되었습니다. 즉, 자동 증분 병합은 뾰족한 INSERT 성능을 방지하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="56f5ba775f4860afdbeef1efdf08d68cd3228bad" translate="yes" xml:space="preserve">
          <source>Setting the heap limits to zero disables the heap limiter mechanism.</source>
          <target state="translated">힙 제한을 0으로 설정하면 힙 제한 메커니즘이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="d964c814943dd4cc633ef0ee8d21d48eb3735ca0" translate="yes" xml:space="preserve">
          <source>Setting this compile-time option prevents SQLite from being fully testable. Branch test coverage drops from 100% down to about 95%.</source>
          <target state="translated">이 컴파일 타임 옵션을 설정하면 SQLite를 완전히 테스트 할 수 없습니다. 분기 테스트 범위는 100 %에서 약 95 %로 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="00f0e8d6420ed50a38c6973317964bc318233512" translate="yes" xml:space="preserve">
          <source>Several new C-level objects are used by the virtual table implementation:</source>
          <target state="translated">가상 테이블 구현에서는 몇 가지 새로운 C 레벨 오브젝트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b7d1cf980e975f4a1d8be50f6af0bb46a6caa32" translate="yes" xml:space="preserve">
          <source>Several obscure, unrelated bugs were found and fixed while implemented the integer primary key change of the previous bullet.</source>
          <target state="translated">이전 글 머리 기호의 정수 기본 키 변경을 구현하는 동안 몇 가지 모호하고 관련이없는 버그가 발견되어 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="659f95a669a94f909d4f9c9e95d9d907e1cbadfa" translate="yes" xml:space="preserve">
          <source>Shadow tables are read/write by default. Shadow tables only become read-only when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is set using &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. Shadow tables need to be read/write by default in order to maintain backwards compatibility. For example, the SQL text generated by the &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; writes directly into shadow tables.</source>
          <target state="translated">새도우 테이블은 기본적으로 읽기 / 쓰기입니다. 섀도우 테이블 은 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()를&lt;/a&gt; 사용하여 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 설정된 경우에만 읽기 전용이됩니다 . 이전 버전과의 호환성을 유지하려면 기본적으로 새도우 테이블을 읽고 쓸 수 있어야합니다. 예를 들어 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 의 &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; 명령으로 생성 된 SQL 텍스트는 새도우 테이블에 직접 씁니다.</target>
        </trans-unit>
        <trans-unit id="19452421c69c545e0b50fcc00a18251f53c4e9f4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. But this might change in future releases of SQLite. Applications that care about shared cache setting should set it explicitly.</source>
          <target state="translated">공유 캐시는 기본적으로 비활성화되어 있습니다. 그러나 이는 향후 릴리스의 SQLite에서 변경 될 수 있습니다. 공유 캐시 설정에 관심이있는 응용 프로그램은이를 명시 적으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e41d50ebd1af2b3254810c6333341257c85989e" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="translated">공유 캐시는 기본적으로 비활성화되어 있습니다. 그렇게 유지하는 것이 좋습니다. 즉,이 루틴을 사용하지 마십시오. 이 인터페이스는 기록 호환성을 위해 계속 제공되지만 사용하지 않는 것이 좋습니다. 공유 캐시를 사용하지 않는 것이 좋습니다. 공유 캐시를 사용해야 하는 경우 &lt;a href=&quot;#SQLITE_OPEN_AUTOPROXY&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 플래그가 있는 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스를 사용하여 개별 데이터베이스 연결에 대해서만 공유 캐시를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="016f63b1afdc35c75766700d01c855e2a30457a4" translate="yes" xml:space="preserve">
          <source>Shared cache is disabled by default. It is recommended that it stay that way. In other words, do not use this routine. This interface continues to be provided for historical compatibility, but its use is discouraged. Any use of shared cache is discouraged. If shared cache must be used, it is recommended that shared cache only be enabled for individual database connections using the &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface with the &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; flag.</source>
          <target state="translated">공유 캐시는 기본적으로 비활성화되어 있습니다. 그렇게 유지하는 것이 좋습니다. 즉,이 루틴을 사용하지 마십시오. 이 인터페이스는 기록 호환성을 위해 계속 제공되지만 사용하지 않는 것이 좋습니다. 공유 캐시를 사용하지 않는 것이 좋습니다. 공유 캐시를 사용해야 하는 경우 &lt;a href=&quot;c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; 플래그가 있는 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스를 사용하여 개별 데이터베이스 연결에 대해서만 공유 캐시를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f477f800bdd5ba8c256608dea929d26bc988f65b" translate="yes" xml:space="preserve">
          <source>Shared libraries or DLLs can be used as &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt; to SQLite.</source>
          <target state="translated">공유 라이브러리 또는 DLL 을 SQLite에 대한 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6f715dc89839324b877f33d62ebb39393f6ca50" translate="yes" xml:space="preserve">
          <source>Shared-cache locks are released when a database connection concludes its current transaction, either by committing it or rolling it back.</source>
          <target state="translated">데이터베이스 캐시 연결이 커밋하거나 롤백하여 현재 트랜잭션을 완료하면 공유 캐시 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="1a3aca3d24b83cc38a4313e0315e88bcb9c21c92" translate="yes" xml:space="preserve">
          <source>Shared-cache mode changes the semantics of the locking model in some cases. The details are described by this document. A basic understanding of the normal SQLite locking model (see &lt;a href=&quot;lockingv3&quot;&gt;File Locking And Concurrency In SQLite Version 3&lt;/a&gt; for details) is assumed.</source>
          <target state="translated">공유 캐시 모드는 경우에 따라 잠금 모델의 의미를 변경합니다. 자세한 내용은이 문서에서 설명합니다. 일반적인 SQLite 잠금 모델에 대한 기본 이해 (자세한 내용은 &lt;a href=&quot;lockingv3&quot;&gt;SQLite 버전 3의 파일 잠금 및 동시성&lt;/a&gt; 참조)가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="0a3f80e6eca574b532dbb5d0c3d9a7766e7bf84a" translate="yes" xml:space="preserve">
          <source>Shared-cache mode is enabled on a per-process basis. Using the C interface, the following API can be used to globally enable or disable shared-cache mode:</source>
          <target state="translated">공유 캐시 모드는 프로세스별로 활성화됩니다. C 인터페이스를 사용하면 다음 API를 사용하여 공유 캐시 모드를 전체적으로 활성화하거나 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f42662308d376fb67628511d59d090985566d2ae" translate="yes" xml:space="preserve">
          <source>Shared-memory files</source>
          <target state="translated">공유 메모리 파일</target>
        </trans-unit>
        <trans-unit id="c7114e495e770e3a02bbb164bf55e1f96da4aecc" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the left by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 정수로 지정된 비트 수만큼 레지스터 P2의 정수 값을 왼쪽으로 이동합니다. 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="1886429e3c21f6dfa5e69e0091250e86426fb4f9" translate="yes" xml:space="preserve">
          <source>Shift the integer value in register P2 to the right by the number of bits specified by the integer in register P1. Store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 정수로 지정된 비트 수만큼 레지스터 P2의 정수 값을 오른쪽으로 이동합니다. 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="62341f589b9d3a0d923d18a2b4e7f7f2edda894e" translate="yes" xml:space="preserve">
          <source>ShiftLeft</source>
          <target state="translated">ShiftLeft</target>
        </trans-unit>
        <trans-unit id="2310b475647d9a4e74a4f5d5a47bfb27340ee08b" translate="yes" xml:space="preserve">
          <source>ShiftRight</source>
          <target state="translated">ShiftRight</target>
        </trans-unit>
        <trans-unit id="c8723bf8dd0f924a9f0d00bc2ddb22a9562a76b1" translate="yes" xml:space="preserve">
          <source>Shifting a negative number.</source>
          <target state="translated">음수를 이동합니다.</target>
        </trans-unit>
        <trans-unit id="8f0ca083402d5eb462b696e15e581aaadbeb113a" translate="yes" xml:space="preserve">
          <source>Shifting an N-bit integer by more than N bits.</source>
          <target state="translated">N 비트 정수를 N 비트 이상으로 시프트</target>
        </trans-unit>
        <trans-unit id="37dcc04149816924636682bd712a1a49f1dcb38f" translate="yes" xml:space="preserve">
          <source>Shifting by a negative amount.</source>
          <target state="translated">음수만큼 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d224675e61816beeffff3a83b33b759da2cf9109" translate="yes" xml:space="preserve">
          <source>Short answer: A column declared &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; will autoincrement.</source>
          <target state="translated">짧은 답변 : &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY로&lt;/a&gt; 선언 된 열 은 자동 증가합니다.</target>
        </trans-unit>
        <trans-unit id="66f7bc664b9d82f0b84142732a02328bc0cdf8d0" translate="yes" xml:space="preserve">
          <source>Show ASCII-art abstract syntax tree diagrams using the &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; when compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLITE_ENABLE_SELECTTRACE, and SQLITE_ENABLE_WHERETRACE. Also provide the sqlite3TreeViewExpr() and sqlite3TreeViewSelect() entry points that can be invoked from with the debugger to show the parse tree when stopped at a breakpoint.</source>
          <target state="translated">&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; , SQLITE_ENABLE_SELECTTRACE 및 SQLITE_ENABLE_WHERETRACE로 컴파일 할 때 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 에서 &quot;.selecttrace&quot;및 &quot;.wheretrace&quot;명령을 사용하여 ASCII 아트 추상 구문 트리 다이어그램을 표시하십시오 . 또한 중단 점에서 중지 될 때 구문 분석 트리를 표시하기 위해 디버거에서 호출 할 수있는 sqlite3TreeViewExpr () 및 sqlite3TreeViewSelect () 진입 점을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="29bd1b65a367359ac801580f0f164ea797beea79" translate="yes" xml:space="preserve">
          <source>Show how many rows have changed on each table, but do not show the actual changes</source>
          <target state="translated">각 테이블에서 변경된 행 수를 표시하지만 실제 변경 내용은 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45c704a81c82ee8bb0729ae9984ab0b0befba88f" translate="yes" xml:space="preserve">
          <source>Show me your flowcharts and conceal your tables, and I shall continue to be mystified. Show me your tables, and I won't usually need your flowcharts; they'll be obvious.</source>
          <target state="translated">순서도를 보여주고 테이블을 숨기면 계속해서 미스터리됩니다. 표를 보여 주시면 일반적으로 흐름도가 필요하지 않습니다. 그들은 명백 할 것이다.</target>
        </trans-unit>
        <trans-unit id="eadcf1db0ff39fb6bc0246ade4beb9b3e9027520" translate="yes" xml:space="preserve">
          <source>Show only differences in the schema not the table content</source>
          <target state="translated">테이블 내용이 아닌 스키마의 차이점 만 표시</target>
        </trans-unit>
        <trans-unit id="584527d924d04a23c5c08d9fd085c97f73f6da07" translate="yes" xml:space="preserve">
          <source>Show only the differences in content for TABLE, not for the entire database</source>
          <target state="translated">전체 데이터베이스가 아닌 TABLE의 내용 차이 만 표시</target>
        </trans-unit>
        <trans-unit id="c2688d3833edc37bfcee14b5515c2bff49005d0c" translate="yes" xml:space="preserve">
          <source>Show the SQL that would be run to carry out the archive operation, but do not actually change anything.</source>
          <target state="translated">아카이브 조작을 수행하기 위해 실행되지만 실제로는 변경하지 않는 SQL을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="f2d6599ba5b081fd8b2869046769b3cd08250edc" translate="yes" xml:space="preserve">
          <source>Shun arrogance.</source>
          <target state="translated">오만을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="df3f4b6cc3b45148ff40b29aba7af47fbd10c1fd" translate="yes" xml:space="preserve">
          <source>Signed integer overflow. (Signed integer overflow does &lt;u&gt;not&lt;/u&gt; necessarily wrap around, as most people expect.)</source>
          <target state="translated">부호있는 정수 오버 플로우. ( 대부분의 사람들이 예상하는 것처럼 부호있는 정수 오버 플로우가 반드시 랩핑 되지는 &lt;u&gt;않습니다&lt;/u&gt; .)</target>
        </trans-unit>
        <trans-unit id="2e226f8ddc66c1a463dcf0a7c345c529980f966b" translate="yes" xml:space="preserve">
          <source>Silent &quot;d&quot; in words beginning with &quot;dj&quot;: djinn, Djikarta</source>
          <target state="translated">&quot;dj&quot;로 시작하는 단어에서 자동 &quot;d&quot;: djinn, Djikarta</target>
        </trans-unit>
        <trans-unit id="aada0dd0ffeee0e21804c55732d58986c7fd3694" translate="yes" xml:space="preserve">
          <source>Silent &quot;g&quot; in words beginning with &quot;gn&quot;: gnarly, gnome, gnat</source>
          <target state="translated">&quot;gn&quot;으로 시작하는 단어에서 무음 &quot;g&quot;: 으악, gnome, gnat</target>
        </trans-unit>
        <trans-unit id="fbaa2ec88597d6e84d9f667ee669d561de7dec36" translate="yes" xml:space="preserve">
          <source>Silent &quot;k&quot; in words beginning with &quot;kn&quot;: knight, Knuthson</source>
          <target state="translated">&quot;kn&quot;로 시작하는 단어에서 자동 &quot;k&quot;: 기사, Knuthson</target>
        </trans-unit>
        <trans-unit id="0f8ddc119a87ce25d1a07a2270fa7ab759fe3699" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pn&quot;: pneumonia, pneumatic</source>
          <target state="translated">&quot;pn&quot;로 시작하는 단어에서 무음 &quot;p&quot;: 폐렴, 공압</target>
        </trans-unit>
        <trans-unit id="9fea8d13746b11fa947fbc609fcc6f58d06a7902" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;ps&quot;: psalm, psyche</source>
          <target state="translated">&quot;ps&quot;로 시작하는 단어에서 무음 &quot;p&quot;:시, 정신</target>
        </trans-unit>
        <trans-unit id="f17200036eeba29904ebeaabba7f7630872e60fd" translate="yes" xml:space="preserve">
          <source>Silent &quot;p&quot; in words beginning with &quot;pt&quot;: pterodactyl, ptolemaic</source>
          <target state="translated">&quot;pt&quot;로 시작하는 단어에서 자동 &quot;p&quot;: pterodactyl, ptolemaic</target>
        </trans-unit>
        <trans-unit id="9d3bc03d8343d400c82a4a71a8abb03ff87c2249" translate="yes" xml:space="preserve">
          <source>Similarly, SQLite allows you to store a 2000-character string into a column of type VARCHAR(50). Other SQL implementations would either throw an error or truncate the string. SQLite stores the entire 2000-character string with no loss of information and without complaint.</source>
          <target state="translated">마찬가지로 SQLite를 사용하면 2000 자 문자열을 VARCHAR (50) 유형의 열에 저장할 수 있습니다. 다른 SQL 구현은 오류를 발생 시키거나 문자열을 자릅니다. SQLite는 정보 손실없이 불만없이 전체 2000 자 문자열을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="8b91c3fa499f0d4214317846c7c43d756cfd2b0a" translate="yes" xml:space="preserve">
          <source>Similarly, a</source>
          <target state="translated">마찬가지로,</target>
        </trans-unit>
        <trans-unit id="5bca9444f10a42e6ae3d406bbcd7ca872ce4cd02" translate="yes" xml:space="preserve">
          <source>Similarly, in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, the write-ahead log file is not truncated following a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. Instead, SQLite reuses the existing file for subsequent WAL entries since overwriting is faster than appending.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 미리 쓰기 로그 파일은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 다음에 잘리지 않습니다 . 대신, 덮어 쓰기가 추가하는 것보다 빠르기 때문에 SQLite는 후속 WAL 항목에 기존 파일을 재사용합니다.</target>
        </trans-unit>
        <trans-unit id="bac336a356dc6f108086c2da32cf914ab388438e" translate="yes" xml:space="preserve">
          <source>Similarly, streaming API functions that return changesets (or patchsets) return them in chunks by way of a callback function instead of via a pointer to a single large buffer. In this case, a pair of parameters such as:</source>
          <target state="translated">마찬가지로, 변경 세트 (또는 패치 세트)를 리턴하는 스트리밍 API 함수는 단일 대형 버퍼에 대한 포인터를 통하는 대신 콜백 함수를 통해 청크 단위로 변경을 리턴합니다. 이 경우 다음과 같은 매개 변수 쌍이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d579b15000cacebe667c23c91900124e0021ffe" translate="yes" xml:space="preserve">
          <source>Similarly, the following expressions have historically evaluated to TRUE when in fact NULL is also the correct answer here:</source>
          <target state="translated">마찬가지로 다음 표현식은 실제로 NULL이 여기에도 정답 일 때 역사적으로 TRUE로 평가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8de10619f1c2dbf3cc29b124beee52534207f387" translate="yes" xml:space="preserve">
          <source>Simple Queries</source>
          <target state="translated">간단한 쿼리</target>
        </trans-unit>
        <trans-unit id="c820f89b614c85cd10dd51d0186cb9a23cd537b4" translate="yes" xml:space="preserve">
          <source>Simple SELECT</source>
          <target state="translated">간단한 선택</target>
        </trans-unit>
        <trans-unit id="2b5e01ecfaf01cf9d6fed2afce17a1e2ec85faaa" translate="yes" xml:space="preserve">
          <source>Simple Select Processing</source>
          <target state="translated">간단한 선택 처리</target>
        </trans-unit>
        <trans-unit id="25bc3effd8fab2177bf75bccfaba476dd31d7e03" translate="yes" xml:space="preserve">
          <source>Simple fts queries</source>
          <target state="translated">간단한 fts 쿼리</target>
        </trans-unit>
        <trans-unit id="d21c97069116b510ca5fd5d37452e567c518b5ee" translate="yes" xml:space="preserve">
          <source>Simple, easy to use &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt;.</source>
          <target state="translated">간단하고 사용하기 쉬운 &lt;a href=&quot;cintro&quot;&gt;API&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20a696ed001fc7792dc03669a107ef6867be06cf" translate="yes" xml:space="preserve">
          <source>Simplified Application Development</source>
          <target state="translated">단순화 된 응용 프로그램 개발</target>
        </trans-unit>
        <trans-unit id="75e092657cf7286e756d1dede51480e5230b9edf" translate="yes" xml:space="preserve">
          <source>Simplify the design of the VDBE by restricting the number of sorters and lists to 1. In practice, no more than one sorter and one list was ever used anyhow.</source>
          <target state="translated">분류기 및 목록의 수를 1로 제한하여 VDBE의 설계를 단순화하십시오. 실제로는 하나 이상의 분류기와 하나의 목록이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="89151b192ec38384818e48383b1951487fe9cb56" translate="yes" xml:space="preserve">
          <source>Simply replace</source>
          <target state="translated">간단히 교체</target>
        </trans-unit>
        <trans-unit id="de0928c2b632719ec80087729ff90db61c097100" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;version 3.13.0&lt;/a&gt; (2016-05-18), the session extension has been included in the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source distribution. By default, the session extension is disabled. To enable it, build with the following compiler switches:</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_13_0.html&quot;&gt;버전 3.13.0&lt;/a&gt; (2016-05-18) 부터 세션 확장이 SQLite &lt;a href=&quot;amalgamation&quot;&gt;합병&lt;/a&gt; 소스 배포 에 포함되었습니다 . 기본적으로 세션 확장은 비활성화되어 있습니다. 이를 가능하게하려면 다음 컴파일러 스위치로 빌드하십시오.</target>
        </trans-unit>
        <trans-unit id="eaa37de22579abc7084228906dd483ab965aacfb" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04), SQLite has supported an interface called the &lt;a href=&quot;c3ref/vfs&quot;&gt;virtual file system&lt;/a&gt; or &quot;VFS&quot;. This object is somewhat misnamed since it is really an interface to the whole underlying operating system, not just the filesystem.</source>
          <target state="translated">이후 &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007년 9월 4일), SQLite는이 호출 된 인터페이스를 지원하고 &lt;a href=&quot;c3ref/vfs&quot;&gt;가상 파일 시스템&lt;/a&gt; 또는 &quot;VFS를&quot;. 이 객체는 실제로 파일 시스템뿐만 아니라 전체 기본 운영 체제에 대한 인터페이스이기 때문에 이름이 다소 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="c659e6cde59a26a5cc98604eaf1a60217b6d7297" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), SQLite source code has been stored in the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil configuration management system&lt;/a&gt;. The SQLITE_SOURCE_ID macro evaluates to a string which identifies a particular check-in of SQLite within its configuration management system. The SQLITE_SOURCE_ID string contains the date and time of the check-in (UTC) and a SHA1 or SHA3-256 hash of the entire source tree. If the source code has been edited in any way since it was last checked in, then the last four hexadecimal digits of the hash may be modified.</source>
          <target state="translated">이후 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11), SQLite는 소스 코드가 저장되어 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석 형상 관리 시스템&lt;/a&gt; . SQLITE_SOURCE_ID 매크로는 구성 관리 시스템 내에서 SQLite의 특정 체크인을 식별하는 문자열로 평가됩니다. SQLITE_SOURCE_ID 문자열에는 체크인 날짜 (UTC)와 전체 소스 트리의 SHA1 또는 SHA3-256 해시가 포함됩니다. 소스 코드가 마지막으로 체크인 된 이후 어떤 방식 으로든 편집 된 경우 해시의 마지막 4 자리 16 진수가 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ef82de3319be0d75e458ab4416694f2f8299790" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite also supports &quot;&lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;&quot;. In WAL mode, changes are not written to the original database file. Instead, changes go into a separate &quot;write-ahead log&quot; or &quot;WAL&quot; file. Later, after the transaction commits, those changes will be moved from the WAL file back into the original database in an operation called &quot;checkpoint&quot;. WAL mode is enabled by running &quot;&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt;&quot;.</source>
          <target state="translated">이후 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21), SQLite는 또한 &quot;지원 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; &quot;. WAL 모드에서는 변경 내용이 원본 데이터베이스 파일에 기록되지 않습니다. 대신 변경 내용은 별도의 &quot;미리 쓰기 로그&quot;또는 &quot;WAL&quot;파일로 이동합니다. 나중에 트랜잭션이 커밋 된 후 이러한 변경 사항은 &quot;체크 포인트&quot;라는 작업으로 WAL 파일에서 원래 데이터베이스로 다시 이동됩니다. &quot; &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = WAL&lt;/a&gt; &quot; 을 실행하면 WAL 모드가 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="974a12d011bbc97d586f22e505d00eff41958058" translate="yes" xml:space="preserve">
          <source>Since SQLite always interprets any filename that does not begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot; as an ordinary filename regardless of the URI setting, and because it is very unusual to have an actual file begin with &quot;&lt;code&gt;file:&lt;/code&gt;&quot;, it is safe for most applications to enable URI processing even if URI filenames are not currently being used.</source>
          <target state="translated">SQLite 는 URI 설정에 관계없이 항상 &quot; &lt;code&gt;file:&lt;/code&gt; &quot;으로 시작하지 않는 파일 이름을 일반 파일 이름으로 해석 하므로 실제 파일이 &quot; &lt;code&gt;file:&lt;/code&gt; &quot;으로 시작하는 것은 매우 드문 일이므로 대부분의 응용 프로그램에서 안전합니다. URI 파일 이름이 현재 사용 중이 아니더라도 URI 처리를 활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="6787bde414a9d9d049df11f55e9b93b41be95c03" translate="yes" xml:space="preserve">
          <source>Since SQLite databases are ordinary disk files, any malfunction in the filesystem can corrupt the database. Filesystems in modern operating systems are very reliable, but errors do still occur. For example, on 2013-10-01 the SQLite database that holds the &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Wiki for Tcl/Tk&lt;/a&gt; went corrupt a few days after the host computer was moved to a dodgy build of the (linux) kernel that had issues in the filesystem layer. In that event, the filesystem eventually became so badly corrupted that the machine was unusable, but the earliest symptom of trouble was the corrupted SQLite database.</source>
          <target state="translated">SQLite 데이터베이스는 일반 디스크 파일이므로 파일 시스템의 오작동으로 인해 데이터베이스가 손상 될 수 있습니다. 최신 운영 체제의 파일 시스템은 매우 안정적이지만 오류가 계속 발생합니다. 예를 들어 2013-10-01에서 호스트 컴퓨터가 파일 시스템 계층에 문제가있는 (linux) 커널의 임시 빌드로 이동 한 후 &lt;a href=&quot;http://wiki.tcl-lang.org/&quot;&gt;Tcl / Tk 용 Wiki를&lt;/a&gt; 보유한 SQLite 데이터베이스 가 손상되었습니다. 이 경우 파일 시스템이 결국 심하게 손상되어 시스템을 사용할 수 없게되었지만 문제의 가장 초기 증상은 손상된 SQLite 데이터베이스였습니다.</target>
        </trans-unit>
        <trans-unit id="c695a2f51c4b24da3c2784ee7cd9c9755809b7df" translate="yes" xml:space="preserve">
          <source>Since SQLite reads and writes an ordinary disk file, the only access permissions that can be applied are the normal file access permissions of the underlying operating system. The GRANT and REVOKE commands commonly found on client/server RDBMSes are not implemented because they would be meaningless for an embedded database engine.</source>
          <target state="translated">SQLite는 일반 디스크 파일을 읽고 쓰기 때문에 적용 할 수있는 유일한 액세스 권한은 기본 운영 체제의 일반 파일 액세스 권한입니다. 클라이언트 / 서버 RDBMS에서 일반적으로 사용되는 GRANT 및 REVOKE 명령은 내장 데이터베이스 엔진에는 의미가 없으므로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59abdbce3144e8f85a07a8dfceb62a241d9b0167" translate="yes" xml:space="preserve">
          <source>Since an SQLite database is a more general format (it is designed to do much more than simply store a bunch of files) it is not as compact as either the ZIP Archive or Tarball formats. An SQLite Archive is usually about 1% larger than the equivalent ZIP Archive. Tarballs are compressed as a single unit rather than compressing each file separately as is done by both SQLite and ZIP Archives. For these reason, Tarballs tend to be smaller than either ZIP or SQLite Archives.</source>
          <target state="translated">SQLite 데이터베이스는보다 일반적인 형식 (단순히 많은 파일을 저장하는 것보다 훨씬 많은 기능을 수행하도록 설계됨)이므로 ZIP 아카이브 또는 Tarball 형식만큼 컴팩트하지 않습니다. SQLite Archive는 일반적으로 동등한 ZIP Archive보다 약 1 % 더 큽니다. 타르볼은 SQLite와 ZIP Archives에서 수행하는 것처럼 각 파일을 개별적으로 압축하지 않고 단일 단위로 압축됩니다. 이러한 이유로 Tarball은 ZIP 또는 SQLite Archive보다 작습니다.</target>
        </trans-unit>
        <trans-unit id="4194b98c5f98c8eb76bc03b04a9e6fbf66db418a" translate="yes" xml:space="preserve">
          <source>Since database zFilename is a file on disk, then it may be accessed externally by another process. This means that when the call to sqlite3_backup_step() attempts to read from or write data to it, it may fail to obtain the required file lock. If this happens, this implementation will fail, returning SQLITE_BUSY immediately. The solution would be to register a busy-handler callback or timeout with &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; pFile using &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; as soon as it is opened. If it fails to obtain a required lock immediately, &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step()&lt;/a&gt; uses any registered busy-handler callback or timeout in the same way as &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; does.</source>
          <target state="translated">데이터베이스 zFilename은 디스크의 파일이므로 다른 프로세스에서 외부 적으로 액세스 할 수 있습니다. 이는 sqlite3_backup_step ()에 대한 호출이 데이터를 읽거나 쓰려고 할 때 필요한 파일 잠금을 얻지 못할 수 있음을 의미합니다. 이 경우이 구현은 실패하고 SQLITE_BUSY를 즉시 리턴합니다. 해결책은 &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 을 열 자마자 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; pFile을 사용하여 통화 중 처리기 콜백 또는 시간 초과를 등록하는 것입니다. 필요한 잠금을 즉시 얻지 못하면 &lt;a href=&quot;c3ref/backup_finish#sqlite3backupstep&quot;&gt;sqlite3_backup_step ()&lt;/a&gt; 은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 와 같은 방식으로 등록 된 사용 중 처리기 콜백 또는 시간 초과를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="689371fa0cc7aa87af9ab6ee0314efa8f5ddaa1a" translate="yes" xml:space="preserve">
          <source>Since its inception on 2000-05-29, SQLite has been implemented in generic C. C was and continues to be the best language for implementing a software library like SQLite. There are no plans to recode SQLite in any other programming language at this time.</source>
          <target state="translated">2000 년 5 월 29 일에 시작된 이후 SQLite는 일반 C로 구현되었습니다. C는 SQLite와 같은 소프트웨어 라이브러리를 구현하기위한 최고의 언어입니다. 현재 다른 프로그래밍 언어로 SQLite를 다시 코딩 할 계획이 없습니다.</target>
        </trans-unit>
        <trans-unit id="e237e23641bdbe1625752d920a811e88f9bea9fa" translate="yes" xml:space="preserve">
          <source>Since the &quot;t2&quot; imposter table is a form of database corruption, the manual approach to creating imposter tables is not recommended. Actually, any use of imposter tables is discouraged for all but expert developers, but manually created imposter tables are especially discouraged because they are permanent.</source>
          <target state="translated">&quot;t2&quot;임 포스터 테이블은 데이터베이스 손상의 한 형태이므로 임 포스터 테이블을 작성하는 수동 방법은 권장되지 않습니다. 실제로 임 포스터 테이블은 전문가를 제외한 모든 개발자에게 사용하지 않는 것이 좋지만 수동으로 생성 된 임 포스터 테이블은 영구적이기 때문에 특히 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0cc48f0c85bdbc88acc6ded1a2b33b3cefbcc949" translate="yes" xml:space="preserve">
          <source>Since the SQLite database file format was designed (in 2003) the default &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;page size&lt;/a&gt; for new databases has been 1024 bytes. This was a reasonable choice in 2003. But on modern hardware, a 4096 byte page is a faster and better choice. So, beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29)) the default page size for new database files has been increased to 4096 bytes.</source>
          <target state="translated">SQLite 데이터베이스 파일 형식은 2003 년에 설계되었으므로 새 데이터베이스 의 기본 &lt;a href=&quot;pragma#pragma_page_size&quot;&gt;페이지 크기&lt;/a&gt; 는 1024 바이트입니다. 이것은 2003 년에 합리적인 선택이었습니다. 그러나 최신 하드웨어에서는 4096 바이트 페이지가 더 빠르고 더 나은 선택입니다. 따라서 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; (2016-03-29) 부터 새 데이터베이스 파일의 기본 페이지 크기가 4096 바이트로 늘어났습니다.</target>
        </trans-unit>
        <trans-unit id="054ac08de64845448b2fb9281541e1391100a214" translate="yes" xml:space="preserve">
          <source>Since the actions of &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; are determined to some extent by prior queries that have been evaluated on the same database connection, it is recommended that &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; be deferred until the database connection is closing and has thus had an opportunity to accumulate as much usage information as possible. It is also reasonable to set a timer to run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; every few hours, or every few days, for database connections that stay open for a long time.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 의 동작은 동일한 데이터베이스 연결에서 평가 된 이전 쿼리에 의해 어느 정도 결정 되므로 데이터베이스 연결이 닫힐 때까지 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 를 연기하여 사용량 정보를 축적 할 수있는 기회를 가지십시오 가능한 한. 오랫동안 열려있는 데이터베이스 연결에 대해 몇 시간 또는 며칠마다 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA 최적화&lt;/a&gt; 를 실행하도록 타이머를 설정하는 것도 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="a35c2dbd798622212a3da41545074117af9096bd" translate="yes" xml:space="preserve">
          <source>Since the index is used to look up values in the table, it is important that the index and table be kept consistent. Now that there is an index on the examp table, we will have to update that index whenever data is inserted, deleted, or changed in the examp table. Remember the first example above where we were able to insert a new row into the &quot;examp&quot; table using 12 VDBE instructions. Now that this table is indexed, 19 instructions are required. The SQL statement is this:</source>
          <target state="translated">인덱스는 테이블에서 값을 찾는 데 사용되므로 인덱스와 테이블의 일관성을 유지하는 것이 중요합니다. 이제 examp 테이블에 인덱스가 있으므로 examp 테이블에서 데이터를 삽입, 삭제 또는 변경할 때마다 해당 인덱스를 업데이트해야합니다. 12 개의 VDBE 명령어를 사용하여 &quot;examp&quot;테이블에 새 행을 삽입 할 수있는 위의 첫 번째 예를 기억하십시오. 이 테이블이 색인되었으므로 19 개의 명령이 필요합니다. SQL 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="792d86f988c7b4533a9df91cbaad2f47d8254db5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N element, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">정보는 rowid 순서대로 테이블에 저장되므로 SQLite는 이진 검색을 사용하여 올바른 행을 찾을 수 있습니다. 테이블에 N 요소가 포함 된 경우 전체 테이블 스캔 에서처럼 원하는 행을 찾는 데 필요한 시간은 N에 비례하지 않고 logN에 비례합니다. 테이블에 천만 개의 요소가 포함 된 경우 쿼리는 N / logN 정도 또는 약 1 백만 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f5b0a5f9338e5d6f0eb6749a38c57ac37eadf9c5" translate="yes" xml:space="preserve">
          <source>Since the information is stored in the table in rowid order, SQLite can find the correct row using a binary search. If the table contains N elements, the time required to look up the desired row is proportional to logN rather than being proportional to N as in a full table scan. If the table contains 10 million elements, that means the query will be on the order of N/logN or about 1 million times faster.</source>
          <target state="translated">정보는 rowid 순서로 테이블에 저장되므로 SQLite는 이진 검색을 사용하여 올바른 행을 찾을 수 있습니다. 테이블에 N 개의 요소가 포함 된 경우 원하는 행을 찾는 데 필요한 시간은 전체 테이블 스캔에서와 같이 N에 비례하는 것이 아니라 logN에 비례합니다. 테이블에 1,000 만 개의 요소가 포함되어 있으면 쿼리가 N / logN 순서 또는 약 1 백만 배 더 빠르다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="94ff8f1fdae75cff7dbf44bfb613a96fb3fe71f5" translate="yes" xml:space="preserve">
          <source>Since this document was first written, the canonical SQLite source code has been moved from the venerable CVS system into a Fossil repository at &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt;. This means that if you are working with canonical SQLite source code (as opposed to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; source code files, sqlite3.c and sqlite3.h) then you can create a private repository simply by cloning the official repository:</source>
          <target state="translated">이 문서가 처음 작성된 이후, 표준 SQLite 소스 코드는 유용한 CVS 시스템에서 &lt;a href=&quot;http://www.sqlite.org/src&quot;&gt;http://www.sqlite.org/src&lt;/a&gt; 의 Fossil 저장소로 옮겨졌습니다 . 이는 표준 SQLite 소스 코드를 사용하는 경우 ( &lt;a href=&quot;amalgamation&quot;&gt;아말감&lt;/a&gt; 소스 코드 파일 인 sqlite3.c 및 sqlite3.h와 반대 ) 공식 저장소를 복제하여 간단히 개인 저장소를 작성할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b7c178a22b32f8642c754bb0ef6c8c8f9f96539" translate="yes" xml:space="preserve">
          <source>Since this document was originally written some of the database engines tested have been updated and users have been kind enough to send in corrections to the chart below. The original data showed a wide variety of behaviors, but over time the range of behaviors has converged toward the PostgreSQL/Oracle model. The only significant difference is that Informix and MS-SQL both treat NULLs as indistinct in a UNIQUE column.</source>
          <target state="translated">이 문서는 원래 작성되었으므로 테스트 된 일부 데이터베이스 엔진이 업데이트되었으며 사용자는 아래 차트를 수정하여 보낼 수있을 정도로 친절했습니다. 원본 데이터는 다양한 동작을 보여 주었지만 시간이 지남에 따라 다양한 동작이 PostgreSQL / Oracle 모델로 수렴되었습니다. 유일하게 중요한 차이점은 Informix와 MS-SQL은 모두 NULL을 UNIQUE 열에서 구별되지 않은 것으로 취급한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a988ba929d7a7d98790e14aa91b1b4ee801c28ea" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">이 인터페이스는 거의 사용되지 &lt;a href=&quot;../compile#enable_stmt_scanstatus&quot;&gt;않으므로&lt;/a&gt; SQLite가 SQLITE_ENABLE_STMT_SCANSTATUS 컴파일 타임 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="fc8856dbc189b149adcf35c14f2c019d6ca39cd2" translate="yes" xml:space="preserve">
          <source>Since this interface is expected to be rarely used, it is only available if SQLite is compiled using the &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt; compile-time option.</source>
          <target state="translated">이 인터페이스는 거의 사용되지 &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;않으므로&lt;/a&gt; SQLite가 SQLITE_ENABLE_STMT_SCANSTATUS 컴파일 타임 옵션을 사용하여 컴파일 된 경우에만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="69653584b18a40e580d58b62294b4d01dca91c5b" translate="yes" xml:space="preserve">
          <source>Since undefined and implementation-defined behavior is non-portable and can easily lead to incorrect answers, SQLite works very hard to avoid it. For example, when adding two integer column values together as part of an SQL statement, SQLite does not simply add them together using the C-language &quot;+&quot; operator. Instead, it first checks to make sure the addition will not overflow, and if it will, it does the addition using floating point instead.</source>
          <target state="translated">정의되지 않은 구현 구현 동작은 이식 ​​가능하지 않으며 쉽게 잘못된 답변을 초래할 수 있으므로 SQLite는이를 피하기 위해 매우 열심히 노력합니다. 예를 들어, SQL 문의 일부로 두 개의 정수 열 값을 함께 추가 할 때 SQLite는 단순히 C 언어 &quot;+&quot;연산자를 사용하여 함께 추가하지 않습니다. 대신, 먼저 덧셈이 오버플로되지 않는지 확인하고, 그렇다면 부동 소수점을 사용하여 덧셈을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9a1c7258f48d87f5562218d2ba5ba3886293704d" translate="yes" xml:space="preserve">
          <source>Single-File Documents</source>
          <target state="translated">단일 파일 문서</target>
        </trans-unit>
        <trans-unit id="7fd14cfbad52780046ab174d1c92328e62738415" translate="yes" xml:space="preserve">
          <source>Single-file Cross-platform Database</source>
          <target state="translated">단일 파일 크로스 플랫폼 데이터베이스</target>
        </trans-unit>
        <trans-unit id="71d9f86ea2562e67aa07344919bbe26526606087" translate="yes" xml:space="preserve">
          <source>Situations Where A Client/Server RDBMS May Work Better</source>
          <target state="translated">클라이언트 / 서버 RDBMS가 더 잘 작동 할 수있는 상황</target>
        </trans-unit>
        <trans-unit id="7606f77965da29221827e7ce60dd2a6316522a70" translate="yes" xml:space="preserve">
          <source>Situations Where SQLite Works Well</source>
          <target state="translated">SQLite가 잘 작동하는 상황</target>
        </trans-unit>
        <trans-unit id="b7152342a267362add3c0d7f69f720f7a9c76c9e" translate="yes" xml:space="preserve">
          <source>Size</source>
          <target state="translated">Size</target>
        </trans-unit>
        <trans-unit id="23dd62e305cc04b400ea8b167918d45e391e1599" translate="yes" xml:space="preserve">
          <source>Size Of The SQLite Library</source>
          <target state="translated">SQLite 라이브러리의 크기</target>
        </trans-unit>
        <trans-unit id="23aa6e811d60088ebfe23efb308861aa99dcc44c" translate="yes" xml:space="preserve">
          <source>Size in bytes</source>
          <target state="translated">바이트 단위의 크기</target>
        </trans-unit>
        <trans-unit id="866e161f09886804ed95702c5f38517afa748243" translate="yes" xml:space="preserve">
          <source>Size of a disk sector assumed by the process that wrote this journal.</source>
          <target state="translated">이 저널을 작성한 프로세스가 가정 한 디스크 섹터의 ​​크기.</target>
        </trans-unit>
        <trans-unit id="d67d90ae080b2ba6443535a1ba1538cce623c7a0" translate="yes" xml:space="preserve">
          <source>Size of associated data in bytes after it has been uncompressed (an integer).</source>
          <target state="translated">압축 해제 된 후 바이트 단위의 관련 데이터 크기 (정수).</target>
        </trans-unit>
        <trans-unit id="af19d643ee98cb7aaa5189e1e80bb15629e35fe6" translate="yes" xml:space="preserve">
          <source>Size of pages in this journal.</source>
          <target state="translated">이 저널의 페이지 크기.</target>
        </trans-unit>
        <trans-unit id="594a08e2bfa114e1b1b2dd2a2473b57fc253e650" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages.</source>
          <target state="translated">데이터베이스 파일의 크기 (페이지)</target>
        </trans-unit>
        <trans-unit id="57e816514d2bd056545721fc5901b1263c953939" translate="yes" xml:space="preserve">
          <source>Size of the database file in pages. The &quot;in-header database size&quot;.</source>
          <target state="translated">데이터베이스 파일의 크기 (페이지) &quot;헤더 내 데이터베이스 크기&quot;</target>
        </trans-unit>
        <trans-unit id="80dfcf68ced67397f8e69446b796772d4e573bd1" translate="yes" xml:space="preserve">
          <source>Skip NULL entries on range queries in &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;표현식 인덱스의&lt;/a&gt; 범위 쿼리에서 NULL 항목을 건너 뜁니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/tktview/4baa46491212947&quot;&gt;4baa46491212947에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="8597bf03434e274cab90656bf57bce61497b541d" translate="yes" xml:space="preserve">
          <source>Skip over leading spaces in text to numeric conversions.</source>
          <target state="translated">텍스트에서 숫자 변환으로 선행 공백을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="44c1dff190859dd795700849185006cec261ef11" translate="yes" xml:space="preserve">
          <source>Small code &lt;a href=&quot;footprint&quot;&gt;footprint&lt;/a&gt;: less than 600KiB fully configured or much less with optional features omitted.</source>
          <target state="translated">작은 코드 &lt;a href=&quot;footprint&quot;&gt;설치 공간&lt;/a&gt; : 600KiB 미만으로 완전히 구성되거나 옵션 기능이 생략되어 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="2d43535873c35c636399ec243f6c8a56398f45fc" translate="yes" xml:space="preserve">
          <source>Small edits only overwrite the parts of the file that change, reducing write time and wear on SSD drives.</source>
          <target state="translated">소규모 편집은 변경된 파일 부분 만 덮어 쓰므로 SSD 드라이브의 쓰기 시간과 마모가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="15cb3011196ef5ecfa387e72a64b6b9858775898" translate="yes" xml:space="preserve">
          <source>Smaller documents</source>
          <target state="translated">작은 문서</target>
        </trans-unit>
        <trans-unit id="6085ef2b0d377636644056b25b8388fdb9315be1" translate="yes" xml:space="preserve">
          <source>Snapshots of official releases of SQLite source code can often be obtained directly from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt; of the SQLite website. Even if the specific version desired is not listed on the download page, the naming conventions are fairly clear and so programmers can often guess the name of an historical release and download it that way.</source>
          <target state="translated">SQLite 소스 코드의 공식 릴리스 스냅 샷은 종종 SQLite 웹 사이트 의 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 직접 얻을 수 있습니다 . 원하는 특정 버전이 다운로드 페이지에 나열되어 있지 않아도 명명 규칙은 매우 명확하므로 프로그래머는 종종 기록 릴리스의 이름을 추측하여 다운로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7745ac392b119ee893e25a699e3cdf853f08cced" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;../loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">&lt;a href=&quot;../loadext&quot;&gt;확장 로딩&lt;/a&gt; 을 처리 할 준비가되지 않은 이전 애플리케이션에서 보안 허점을 열지 않고 사용자가 입력 한 SQL을 평가 &lt;a href=&quot;../loadext&quot;&gt;하는&lt;/a&gt; 동안 확장 로딩 을 비활성화하는 방법으로 &lt;a href=&quot;load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 메커니즘 을 켜고 끄는 다음 API가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="38b1dd3b3f9a942c8b562e364d61d2076822b07d" translate="yes" xml:space="preserve">
          <source>So as not to open security holes in older applications that are unprepared to deal with &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt;, and as a means of disabling &lt;a href=&quot;loadext&quot;&gt;extension loading&lt;/a&gt; while evaluating user-entered SQL, the following API is provided to turn the &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; mechanism on and off.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;확장 로딩&lt;/a&gt; 을 처리 할 준비가되지 않은 이전 애플리케이션에서 보안 허점을 열지 않고 사용자가 입력 한 SQL을 평가 &lt;a href=&quot;loadext&quot;&gt;하는&lt;/a&gt; 동안 확장 로딩 을 비활성화하는 방법으로 &lt;a href=&quot;#sqlite3_load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; 메커니즘 을 켜고 끄는 다음 API가 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="16d0e08c9c27f821bc14542d2dfda5e1d13ecd69" translate="yes" xml:space="preserve">
          <source>So in the vast majority of cases, applications need not worry about the WAL file at all. SQLite will automatically take care of it. But it is possible to get SQLite into a state where the WAL file will grow without bound, causing excess disk space usage and slow queries speeds. The following bullets enumerate some of the ways that this can happen and how to avoid them.</source>
          <target state="translated">따라서 대부분의 경우 응용 프로그램은 WAL 파일에 대해 전혀 걱정할 필요가 없습니다. SQLite가 자동으로 처리합니다. 그러나 SQLite를 WAL 파일이 제한없이 커져 과도한 디스크 공간 사용과 쿼리 속도 저하를 초래할 수 있습니다. 다음 글 머리 기호는 이러한 일이 발생할 수있는 몇 가지 방법과이를 피하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e294517ccb0b92866adadbcc46dbbe368da638fb" translate="yes" xml:space="preserve">
          <source>So instead of going by the standards documents, various popular SQL engines were tested to see how they handle NULLs. The idea was to make SQLite work like all the other engines. An SQL test script was developed and run by volunteers on various SQL RDBMSes and the results of those tests were used to deduce how each engine processed NULL values. The original tests were run in May of 2002. A copy of the test script is found at the end of this document.</source>
          <target state="translated">따라서 표준 문서를 사용하는 대신 널리 사용되는 다양한 SQL 엔진을 테스트하여 NULL을 처리하는 방법을 확인했습니다. 아이디어는 다른 모든 엔진과 마찬가지로 SQLite를 작동시키는 것이 었습니다. 다양한 SQL RDBMS에서 자원 봉사자가 SQL 테스트 스크립트를 개발하고 실행했으며 이러한 테스트 결과를 사용하여 각 엔진이 NULL 값을 처리하는 방식을 추론했습니다. 원래 테스트는 2002 년 5 월에 실행되었습니다. 테스트 스크립트의 사본은이 문서의 끝에 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb3fd38b2086ae5409a50744fd4fc4e629f9ceb9" translate="yes" xml:space="preserve">
          <source>So let your take-away be this: read/write latency for SQLite is competitive with read/write latency of individual files on disk. Often SQLite is faster. Sometimes SQLite is almost as fast. Either way, this article disproves the common assumption that a relational database must be slower than direct filesystem I/O.</source>
          <target state="translated">따라서 SQLite의 읽기 / 쓰기 대기 시간은 디스크에있는 개별 파일의 읽기 / 쓰기 대기 시간과 경쟁이 치열합니다. 종종 SQLite가 더 빠릅니다. 때로는 SQLite가 거의 빠릅니다. 어느 쪽이든,이 기사는 관계형 데이터베이스가 직접 파일 시스템 I / O보다 느려 야한다는 일반적인 가정을 반증하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e14f136c4639ca69349a007ce6b5be7651832a1" translate="yes" xml:space="preserve">
          <source>So that</source>
          <target state="translated">그래서</target>
        </trans-unit>
        <trans-unit id="ed811e71ef3d05d3652d347ba0eec5bc9cfd6daf" translate="yes" xml:space="preserve">
          <source>So the implementation of DELETE is really in two loops. The first loop (instructions 5 through 11) locates the records that are to be deleted and saves their keys onto a temporary list, and the second loop (instructions 16 through 19) uses the key list to delete the records one by one.</source>
          <target state="translated">따라서 DELETE의 구현은 실제로 두 개의 루프에 있습니다. 첫 번째 루프 (명령 5 ~ 11)는 삭제할 레코드를 찾아 키를 임시 목록에 저장하고 두 번째 루프 (명령 16 ~ 19)는 키 목록을 사용하여 레코드를 하나씩 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c4f70ed30e8ca5ddd05ca39e32d9f73108273525" translate="yes" xml:space="preserve">
          <source>So then, instead of storing all content for all slides in a single oversized XML file (&quot;content.xml&quot;), suppose there was a separate table for storing the content of each slide separately. The table schema might look something like this:</source>
          <target state="translated">따라서 모든 슬라이드의 모든 컨텐츠를 단일 대형 XML 파일 ( &quot;content.xml&quot;)로 저장하는 대신 각 슬라이드의 컨텐츠를 별도로 저장하기위한 별도의 테이블이 있다고 가정하십시오. 테이블 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21a527776b915968f528d88d96579bf0b2cfc459" translate="yes" xml:space="preserve">
          <source>So which query plan is better? It turns out that the answer depends on what kind of data is found in the node and edge tables.</source>
          <target state="translated">어떤 쿼리 계획이 더 좋습니까? 답은 노드 및 에지 테이블에서 어떤 종류의 데이터가 발견되는지에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="15a7d8b50c8c0de15e18cf6f21d9c00564463215" translate="yes" xml:space="preserve">
          <source>So with this simple change, the ODP file now stores not just the most recent edit to the presentation, but a history of all historic edits. The user would normally want to see just the most recent edition of the presentation, but if desired, the user can now go backwards in time to see historical versions of the same presentation.</source>
          <target state="translated">따라서이 간단한 변경으로 ODP 파일은 프레젠테이션에 대한 최신 편집 내용뿐만 아니라 모든 이전 편집 기록을 저장합니다. 사용자는 일반적으로 최신 버전의 프레젠테이션 만보고 ​​싶어하지만 원하는 경우 시간이 지나면 같은 프레젠테이션의 이전 버전을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b3d75a6fea634203c91a87ee6d0199704a76d2e" translate="yes" xml:space="preserve">
          <source>So you can see that depending on how the data is structured in the table, either query plan 1 or query plan 2 might be better. Which plan does SQLite choose by default? As of version 3.6.18, without running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;, SQLite will choose option 2. But if the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is run in order to gather statistics, a different choice might be made if the statistics indicate that the alternative is likely to run faster.</source>
          <target state="translated">따라서 테이블에서 데이터가 구성되는 방식에 따라 쿼리 계획 1 또는 쿼리 계획 2가 더 나을 수 있습니다. SQLite는 기본적으로 어떤 계획을 선택합니까? 버전 3.6.18부터 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하지 않고 SQLite는 옵션 2를 선택합니다. 그러나 통계를 수집하기 위해 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하는 경우 통계가 대안이 더 빠르게 실행될 가능성이 있음을 나타내는 경우 다른 선택이 이루어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae83e266982fd9b4e55366971516ab44ce25fd32" translate="yes" xml:space="preserve">
          <source>So, SQLite is able to do one or two large and complex queries, or it can do many smaller and simpler queries. Both are efficient. An application can use either or both techniques, depending on what works best for the situation at hand.</source>
          <target state="translated">따라서 SQLite는 하나 이상의 크고 복잡한 쿼리를 수행하거나 더 작고 간단한 쿼리를 많이 수행 할 수 있습니다. 둘 다 효율적입니다. 응용 프로그램은 현재 상황에 가장 적합한 방법에 따라 기술 중 하나 또는 둘 다를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bac7c0c462d374d0c622ef9a876ba7c2814954d0" translate="yes" xml:space="preserve">
          <source>So, for example, Android applications written in Java are able to invoke SQLite (through an adaptor). Maybe it would have been more convenient for Android if SQLite had been coded in Java as that would make the interface simpler. However, on iPhone applications are coded in Objective-C or Swift, neither of which have the ability to call libraries written in Java. Thus, SQLite would be unusable on iPhones had it been written in Java.</source>
          <target state="translated">예를 들어, Java로 작성된 Android 애플리케이션은 어댑터를 통해 SQLite를 호출 할 수 있습니다. SQLite가 Java로 코딩 된 경우 인터페이스가 더 간단 해지 기 때문에 Android에 더 편리했을 것입니다. 그러나 iPhone 응용 프로그램은 Objective-C 또는 Swift로 코딩되며 Java로 작성된 라이브러리를 호출 할 수 없습니다. 따라서 Java로 작성된 iPhone에서는 SQLite를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a08fae7d5439605099534f2303acb989c7de8df" translate="yes" xml:space="preserve">
          <source>So, for example, if you wanted to see the compression efficiency (expressed as the size of the compressed content relative to the original uncompressed file size) for all files in the ZIP archive, sorted from most compressed to least compressed, you could run a query like this:</source>
          <target state="translated">따라서 예를 들어 ZIP 아카이브의 모든 파일에 대한 압축 효율성 (압축되지 않은 원본 파일 크기에 대한 압축 된 콘텐츠의 크기로 표시됨)을보고 싶다면 가장 많이 압축 된 것에서 가장 적게 압축 된 것 순으로 정렬 된 다음을 실행할 수 있습니다. 다음과 같은 쿼리 :</target>
        </trans-unit>
        <trans-unit id="181a0af408b7a72e62f37951390087a73f4bc42a" translate="yes" xml:space="preserve">
          <source>So, for example, suppose a multi-thread process has two or more threads with separate SQLite database connections to the same database file. Then a third thread comes along and wants to read something out of that same database file on its own, without using the SQLite library. The third thread does an &lt;code&gt;open()&lt;/code&gt;, a &lt;code&gt;read()&lt;/code&gt; and then a &lt;code&gt;close()&lt;/code&gt;. One would think this would be harmless. But the &lt;code&gt;close()&lt;/code&gt; system call caused the locks held on the database by all the other threads to be dropped. Those other threads have no way of knowing that their locks have just been trashed (POSIX does not provide any mechanism to determine this) and so they keep on running under the assumption that their locks are still valid. This can lead to two or more threads or processes trying to write to the database at the same time, resulting in database corruption.</source>
          <target state="translated">예를 들어, 다중 스레드 프로세스에 동일한 데이터베이스 파일에 대한 별도의 SQLite 데이터베이스 연결이있는 둘 이상의 스레드가 있다고 가정하십시오. 그런 다음 세 번째 스레드가 와서 SQLite 라이브러리를 사용하지 않고 동일한 데이터베이스 파일에서 무언가를 읽으려고합니다. 세 번째 스레드는 &lt;code&gt;open()&lt;/code&gt; , &lt;code&gt;read()&lt;/code&gt; 및 &lt;code&gt;close()&lt;/code&gt; 합니다. 이것이 무해하다고 생각할 것입니다. 그러나 &lt;code&gt;close()&lt;/code&gt; 시스템 호출로 인해 다른 모든 스레드가 데이터베이스에 보유한 잠금이 삭제되었습니다. 다른 스레드는 잠금이 방금 휴지통에 있음을 알 수 없으며 (POSIX는이를 결정하는 메커니즘을 제공하지 않음) 잠금이 여전히 유효하다는 가정하에 계속 실행됩니다. 이로 인해 둘 이상의 스레드 또는 프로세스가 동시에 데이터베이스에 쓰려고 시도하여 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e67704da7c1255179aaf24e0803cc78b548dbe91" translate="yes" xml:space="preserve">
          <source>So, for example, suppose an application runs one query against an R-Tree like this:</source>
          <target state="translated">예를 들어 애플리케이션이 다음과 같이 R- 트리에 대해 하나의 쿼리를 실행한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7734444a7a6faac12d5a5f4324148513ca147ad7" translate="yes" xml:space="preserve">
          <source>So, for example, to move a polygon by some amount DX, DY without changing its shape, use:</source>
          <target state="translated">예를 들어, 모양을 변경하지 않고 다각형을 DX, DY만큼 이동 시키려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e378604952476e70a532691c0957173825ab1905" translate="yes" xml:space="preserve">
          <source>So, in most real systems, an index should be created on the child key columns of each foreign key constraint. The child key index does not have to be (and usually will not be) a UNIQUE index. Returning again to the example in section 1, the complete database schema for efficient implementation of the foreign key constraint might be:</source>
          <target state="translated">따라서 대부분의 실제 시스템에서는 각 외래 키 제약 조건의 자식 키 열에 인덱스를 만들어야합니다. 자식 키 인덱스는 고유 인덱스 일 필요는 없으며 일반적으로 아닐 수도 있습니다. 섹션 1의 예제로 다시 돌아가서 외래 키 제약 조건을 효율적으로 구현하기위한 전체 데이터베이스 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a3db788b7daff3a78000d452682744db386479ec" translate="yes" xml:space="preserve">
          <source>SoftNull</source>
          <target state="translated">SoftNull</target>
        </trans-unit>
        <trans-unit id="36455d32e1724499e8736ccea81ccd08b26881c3" translate="yes" xml:space="preserve">
          <source>Solve Sudoku puzzles</source>
          <target state="translated">스도쿠 퍼즐 해결</target>
        </trans-unit>
        <trans-unit id="ea9361715e601f0c6bb314bde2f85f47f8bc5402" translate="yes" xml:space="preserve">
          <source>Some &quot;safe&quot; languages (ex: Go) dislike the use of assert(). But the use of assert() is a vital part of keeping SQLite maintainable. The lack of assert() in Go is a show-stopper as far as the developers of SQLite are concerned. See the &lt;a href=&quot;assert&quot;&gt;The Use Of assert() In SQLite&lt;/a&gt; article for additional information.</source>
          <target state="translated">일부 &quot;안전한&quot;언어 (예 : Go)는 assert () 사용을 싫어합니다. 그러나 assert () 사용은 SQLite를 유지 관리 할 수있게 유지하는 데 중요한 부분입니다. Go에서 assert ()가 부족하다는 것은 SQLite 개발자가 염려하는 한 막판입니다. 참고 항목 &lt;a href=&quot;assert&quot;&gt;어설의 사용 ()에서 SQLite는&lt;/a&gt; 추가 정보에 대한 기사를.</target>
        </trans-unit>
        <trans-unit id="82877b639e06578b26b7b6487eda6b76c0a0e3c6" translate="yes" xml:space="preserve">
          <source>Some &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements do their work during sqlite3_prepare() rather than during sqlite3_step(). Those PRAGMA statements are unaffected by EXPLAIN. They operate the same with or without the EXPLAIN prefix. The set of PRAGMA statements that are unaffected by EXPLAIN can vary from one release to the next. Some PRAGMA statements operate during sqlite3_prepare() depending on their arguments. For consistent results, avoid using EXPLAIN on PRAGMA statements.</source>
          <target state="translated">일부 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문은 sqlite3_step ()이 아닌 sqlite3_prepare () 중에 작업을 수행합니다. 이러한 PRAGMA 문은 EXPLAIN의 영향을받지 않습니다. EXPLAIN 접두사를 사용하거나 사용하지 않고 동일하게 작동합니다. EXPLAIN의 영향을받지 않는 PRAGMA 문 세트는 릴리스마다 다를 수 있습니다. 일부 PRAGMA 문은 인수에 따라 sqlite3_prepare () 중에 작동합니다. 일관된 결과를 얻으려면 PRAGMA 문에 EXPLAIN을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5732042dba5cf74de37a47838012719f36ee8111" translate="yes" xml:space="preserve">
          <source>Some Example Triggers</source>
          <target state="translated">일부 예제 트리거</target>
        </trans-unit>
        <trans-unit id="e2da6518510111d1ca6bc33d2d1e98dff9548bb8" translate="yes" xml:space="preserve">
          <source>Some SQL database engines provide non-standard &quot;hint&quot; mechanisms which can be used to give the query optimizer clues about what indices it should use for a particular statement. The INDEX BY clause of SQLite is &lt;em&gt;not&lt;/em&gt; a hinting mechanism and it should not be used as such. The INDEXED BY clause does not give the optimizer hints about which index to use; it gives the optimizer a requirement of which index to use. If the query optimizer is unable to use the index specified by the INDEX BY clause, then the query will fail with an error.</source>
          <target state="translated">일부 SQL 데이터베이스 엔진은 비표준 &quot;힌트&quot;메커니즘을 제공하여 쿼리 최적화 프로그램이 특정 명령문에 사용해야하는 인덱스에 대한 힌트를 제공합니다. SQLite는의 BY 절 INDEX는 &lt;em&gt;하지&lt;/em&gt; 힌트 메커니즘과 같은 사용해서는 안됩니다. INDEXED BY 절은 옵티마이 저가 사용할 인덱스에 대한 힌트를 제공하지 않습니다. 옵티 마이저에 사용할 인덱스의 요구 사항을 제공합니다. 쿼리 최적화 프로그램이 INDEX BY 절에 의해 지정된 인덱스를 사용할 수 없으면 쿼리가 오류와 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="fbf443b96f0d9f6eac4bc80a9c5c544e6d64bd31" translate="yes" xml:space="preserve">
          <source>Some commentators say that SQLite is &quot;weakly typed&quot; and that other SQL databases are &quot;strongly typed&quot;. We consider these terms to be inaccurate and pejorative. We prefer to say that SQLite is &quot;flexibly typed&quot; and that other SQL databases are &quot;rigidly typed&quot;.</source>
          <target state="translated">일부 의견자는 SQLite는 &quot;약한 유형&quot;이고 다른 SQL 데이터베이스는 &quot;강력한 유형&quot;이라고 말합니다. 우리는 이러한 용어가 부정확하고 중대하다고 생각합니다. 우리는 SQLite가 &quot;유연하게 형식화되어&quot;있고 다른 SQL 데이터베이스가 &quot;견고하게 형식화되어&quot;있다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="ffa0bb5b46a56bce712735328de2ecfd7898dd9a" translate="yes" xml:space="preserve">
          <source>Some devices are compelled to use an older filesystem with 8+3 filename restrictions for backwards compatibility, or due to other non-technical factors. In such situations, SQLite can be coerced into using auxiliary files that fit the 8+3 pattern as follows:</source>
          <target state="translated">일부 장치는 이전 버전과의 호환성 또는 기타 기술적이지 않은 요인으로 인해 8 + 3 파일 이름 제한이있는 이전 파일 시스템을 사용해야합니다. 이러한 상황에서 다음과 같이 8 + 3 패턴에 맞는 보조 파일을 사용하여 SQLite를 강제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1a4bdb9a86e43ef62782dbb2803e2ef7fef0a7a" translate="yes" xml:space="preserve">
          <source>Some example, cost table entries:</source>
          <target state="translated">몇 가지 예, 비용 테이블 항목 :</target>
        </trans-unit>
        <trans-unit id="9234854e8f0cb7e3b23fa0273a95bcc8f4a8eaf9" translate="yes" xml:space="preserve">
          <source>Some examples will help illustrate the difference:</source>
          <target state="translated">몇 가지 예는 차이점을 설명하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="31941b285d3264077d66c50c29fee18d7a8c1f66" translate="yes" xml:space="preserve">
          <source>Some freelist pages contain critical data; specifically the locations of other freelist pages. But most freelist pages contain nothing useful. These latter freelist pages are called &quot;leaf&quot; pages. We are free to modify the content of a leaf freelist page in the database without changing the meaning of the database in any way.</source>
          <target state="translated">일부 프리리스트 페이지에는 중요한 데이터가 있습니다. 특히 다른 프리리스트 페이지의 위치. 그러나 대부분의 프리리스트 페이지에는 유용한 정보가 없습니다. 후자의 프리리스트 페이지를 &quot;리프&quot;페이지라고합니다. 데이터베이스의 의미를 변경하지 않고 데이터베이스의 리프 프리리스트 페이지 내용을 자유롭게 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d4f98671a50a0a922d51c622597741cdfcd893a" translate="yes" xml:space="preserve">
          <source>Some future versions of SQLite may change to enable this feature by default.</source>
          <target state="translated">이후 버전의 SQLite는 기본적으로이 기능을 사용하도록 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f4d80fea07d79c2b9292b009b4bc9dc70c5c271" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="translated">일부 강화 된 보안 설정 ( &lt;a href=&quot;#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema = OFF&lt;/a&gt; ) 은 함수가 SQLITE_INNOCUOUS로 태그가 지정되지 않은 경우 뷰 및 트리거 내에서 그리고 스키마 구조 (예 : &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;expridx&quot;&gt;식 인덱스&lt;/a&gt; , &lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 및 &lt;a href=&quot;gencol&quot;&gt;생성 된 열)&lt;/a&gt; 에서 SQL 함수를 사용 하지 못하도록합니다. . 대부분의 내장 함수는 무해합니다. 개발자는 함수가 신중하게 감사되고 잠재적 인 보안 부작용 및 정보 유출이없는 것으로 확인되지 않는 한 애플리케이션 정의 함수에 대해 SQLITE_INNOCUOUS 플래그를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="94760af1d8102735e05f237c89411fff0859308d" translate="yes" xml:space="preserve">
          <source>Some heightened security settings (&lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; and &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt;) disable the use of SQL functions inside views and triggers and in schema structures such as &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt;, &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT clauses&lt;/a&gt;, &lt;a href=&quot;../expridx&quot;&gt;expression indexes&lt;/a&gt;, &lt;a href=&quot;../partialindex&quot;&gt;partial indexes&lt;/a&gt;, and &lt;a href=&quot;../gencol&quot;&gt;generated columns&lt;/a&gt; unless the function is tagged with SQLITE_INNOCUOUS. Most built-in functions are innocuous. Developers are advised to avoid using the SQLITE_INNOCUOUS flag for application-defined functions unless the function has been carefully audited and found to be free of potentially security-adverse side-effects and information-leaks.</source>
          <target state="translated">일부 강화 된 보안 설정 ( &lt;a href=&quot;c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; 및 &lt;a href=&quot;../pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema = OFF&lt;/a&gt; ) 은 함수가 SQLITE_INNOCUOUS로 태그가 지정되지 않은 경우 뷰 및 트리거 내에서 그리고 스키마 구조 (예 : &lt;a href=&quot;../lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; , &lt;a href=&quot;../lang_createtable#dfltval&quot;&gt;DEFAULT 절&lt;/a&gt; , &lt;a href=&quot;../expridx&quot;&gt;식 인덱스&lt;/a&gt; , &lt;a href=&quot;../partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 및 &lt;a href=&quot;../gencol&quot;&gt;생성 된 열)&lt;/a&gt; 에서 SQL 함수를 사용 하지 못하도록합니다. . 대부분의 내장 함수는 무해합니다. 개발자는 함수가 신중하게 감사되고 잠재적 인 보안 부작용 및 정보 유출이없는 것으로 확인되지 않는 한 애플리케이션 정의 함수에 대해 SQLITE_INNOCUOUS 플래그를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1bc7150370b1275da7b22e0b3c0daa34955ce5a3" translate="yes" xml:space="preserve">
          <source>Some limits can be changed at run-time on a per-connection basis using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface with one of the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;limit categories&lt;/a&gt; defined for that interface. Run-time limits are designed for applications that have multiple databases, some of which are for internal use only and others which can be influenced or controlled by potentially hostile external agents. For example, a web browser application might use an internal database to track historical page views but have one or more separate databases that are created and controlled by javascript applications that are downloaded from the internet. The &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface allows internal databases managed by trusted code to be unconstrained while simultaneously placing tight limitations on databases created or controlled by untrusted external code in order to help prevent a denial of service attack.</source>
          <target state="translated">일부 인터페이스 는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 인터페이스를 사용하여 해당 인터페이스에 대해 정의 된 &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitlength&quot;&gt;한계 범주&lt;/a&gt; 중 하나를 사용하여 연결별로 런타임에 변경할 수 있습니다 . 런타임 제한은 여러 데이터베이스가있는 응용 프로그램을 위해 설계되었으며 일부는 내부 전용이며 다른 일부는 잠재적으로 적대적인 외부 에이전트에 의해 영향을 받거나 제어 할 수 있습니다. 예를 들어, 웹 브라우저 애플리케이션은 내부 데이터베이스를 사용하여 히스토리 페이지보기를 추적 할 수 있지만 인터넷에서 다운로드되는 Javascript 애플리케이션에 의해 작성되고 제어되는 하나 이상의 개별 데이터베이스를 가질 수 있습니다. &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt;인터페이스는 신뢰할 수있는 코드로 관리되는 내부 데이터베이스가 제한되지 않으면 서 서비스 거부 공격을 방지하기 위해 신뢰할 수없는 외부 코드로 작성하거나 제어하는 ​​데이터베이스에 대한 제한을 동시에 적용합니다.</target>
        </trans-unit>
        <trans-unit id="27f0f8e3878344df85d2a4246c11bee1e47d7640" translate="yes" xml:space="preserve">
          <source>Some older versions of Linux used the LinuxThreads library for thread support. LinuxThreads is similar to Pthreads, but is subtly different with respect to handling of POSIX advisory locks. SQLite versions 2.2.3 through 3.6.23 recognized that LinuxThreads were being used at runtime and took appropriate action to work around the non-standard behavior of LinuxThreads. But most modern Linux implementations make use of the newer, and correct, NPTL implementation of Pthreads. Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), the use of NPTL is assumed. No checks are made. Hence, recent versions of SQLite will subtly malfunction and may corrupt database files if used in multi-threaded application that run on older linux systems that make use of LinuxThreads.</source>
          <target state="translated">일부 이전 버전의 Linux에서는 스레드 지원을 위해 LinuxThreads 라이브러리를 사용했습니다. LinuxThreads는 Pthread와 유사하지만 POSIX 권고 잠금 처리와 관련하여 미묘하게 다릅니다. SQLite 버전 2.2.3에서 3.6.23은 LinuxThreads가 런타임에 사용 중임을 인식하고 LinuxThreads의 비표준 동작을 해결하기 위해 적절한 조치를 취했습니다. 그러나 대부분의 최신 Linux 구현에서는 Pthread의 새롭고 정확한 NPTL 구현을 사용합니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21) 부터 NPTL 사용이 가정됩니다. 점검이 없습니다. 따라서 최신 버전의 SQLite는 LinuxThreads를 사용하는 구형 Linux 시스템에서 실행되는 다중 스레드 응용 프로그램에서 사용되는 경우 미묘하게 오작동하고 데이터베이스 파일을 손상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bef87b7bc572b2934b8ea6d4c58c70ed7dd3633" translate="yes" xml:space="preserve">
          <source>Some older versions of SQLite (prior to version 2.4.0) would show decreasing performance after a sequence of DELETEs followed by new INSERTs. As this test shows, the problem has now been resolved.</source>
          <target state="translated">일부 이전 버전의 SQLite (버전 2.4.0 이전)는 일련의 DELETE와 새 INSERT가 차례로 수행 된 후 성능이 저하됩니다. 이 테스트에서 알 수 있듯이 문제가 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b536a604954c308bdf6df6ee3bb8ed7c841aa8c" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode in every bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">일부 opcode는 자체 변경됩니다. 예를 들어, &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (모든 바이트 코드 프로그램에서 항상 첫 번째 opcode)는 P1 피연산자를 증가시킵니다. 후속 &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcode 는 다음의 일회용 초기화 코드를 건너 뛰어야하는지 여부를 결정하기 위해 P1 피연산자를 &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode에 대한 P1 값 과 비교합니다. 또 다른 예는 P4 피연산자를 UTF-8에서 올바른 데이터베이스 문자열 인코딩으로 변환 한 다음 자체를 &lt;a href=&quot;opcode#String&quot;&gt;문자열&lt;/a&gt; opcode 로 변환 하는 &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="52125a8361f282383783887e4dc2c4cfed4a215d" translate="yes" xml:space="preserve">
          <source>Some opcodes are self-altering. For example, the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (which is always the first opcode run a bytecode program) increments its P1 operand. Subsequent &lt;a href=&quot;opcode#Once&quot;&gt;Once&lt;/a&gt; opcodes compare their P1 operands to the P1 value for the &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode in order to determine if the one-time initialization code that follows should be skipped. Another example is the &lt;a href=&quot;opcode#String8&quot;&gt;String8&lt;/a&gt; opcode which converts its P4 operand from UTF-8 into the correct database string encoding, then converts itself into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode.</source>
          <target state="translated">일부 opcode는 자체 변경됩니다. 예를 들어, &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode (항상 첫 번째 opcode가 바이트 코드 프로그램을 실행 함)는 P1 피연산자를 증가시킵니다. 후속 &lt;a href=&quot;opcode#Once&quot;&gt;일단&lt;/a&gt; opcode는 P1 피연산자를 &lt;a href=&quot;opcode#Init&quot;&gt;Init&lt;/a&gt; opcode 의 P1 값과 비교하여 다음에 오는 1 회 초기화 코드를 건너 뛸지 여부를 결정합니다. 또 다른 예는 &lt;a href=&quot;opcode#String8&quot;&gt;P8&lt;/a&gt; 피연산자를 UTF-8에서 올바른 데이터베이스 문자열 인코딩으로 변환 한 다음 자신을 &lt;a href=&quot;opcode#String&quot;&gt;문자열&lt;/a&gt; opcode 로 변환 하는 String8 opcode입니다 .</target>
        </trans-unit>
        <trans-unit id="426e64b4a66f4f7807aa6667039b81573979fe2a" translate="yes" xml:space="preserve">
          <source>Some opcodes use all five operands. Some opcodes use one or two. Some opcodes use none of the operands.</source>
          <target state="translated">일부 opcode는 5 개의 피연산자를 모두 사용합니다. 일부 opcode는 하나 나 둘을 사용합니다. 일부 opcode는 피연산자를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="18b335ac36fb2d38cd00024b326c89df9316f364" translate="yes" xml:space="preserve">
          <source>Some or all of these restrictions may be removed in the future.</source>
          <target state="translated">이러한 제한 중 일부 또는 전부가 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b476a9e69a79b5371957fc7b1a40c95e375aeff4" translate="yes" xml:space="preserve">
          <source>Some other SQL database engines advise developers to store blobs in separate files and then store the filename in the database. In that case, where the database must first be consulted to find the filename before opening and reading the file, simply storing the entire blob in the database gives much faster read and write performance with SQLite. See the &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; article for more information.</source>
          <target state="translated">일부 다른 SQL 데이터베이스 엔진은 개발자에게 Blob을 별도의 파일에 저장 한 다음 파일 이름을 데이터베이스에 저장하도록 조언합니다. 이 경우 파일을 열고 읽기 전에 파일 이름을 찾기 위해 데이터베이스를 먼저 참조해야하는 경우 데이터베이스에 전체 블로 브를 저장하면 SQLite를 사용하여 훨씬 더 빠른 읽기 및 쓰기 성능을 얻을 수 있습니다. 자세한 내용은 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;내부 대 외부 BLOB&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e94448e3ce0b80c02ec3cf58a3a89e81bfc4e794" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the new row is inserted.</source>
          <target state="translated">새 행이 삽입 될 때 다른 데이터베이스 제한 조건 (예 : UNIQUE 또는 CHECK 제한 조건)이 위반 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87a22bd6e23f0cc806f999949a67d71c38a0517" translate="yes" xml:space="preserve">
          <source>Some other database constraint, for example a UNIQUE or CHECK constraint, may be violated when the row is updated.</source>
          <target state="translated">행이 업데이트 될 때 다른 데이터베이스 제약 조건 (예 : UNIQUE 또는 CHECK 제약 조건)이 위반 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a803eb726af2b55f4a3a45a5ec6b4038451fda8a" translate="yes" xml:space="preserve">
          <source>Some other ways in which FTS5 differs from FTS3/4 are:</source>
          <target state="translated">FTS5가 FTS3 / 4와 다른 몇 가지 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e2d6bed42aa0aeee6bb3a36da7e69907ed2fed99" translate="yes" xml:space="preserve">
          <source>Some people say that we should eliminate all warnings because benign warnings mask real warnings that might arise in future changes. This is true enough. But in reply, the developers observe that all warnings have already been fixed in the builds used for SQLite development (various versions of GCC, MSVC, and clang). Compiler warnings usually only arise from compilers or compile-time options that the SQLite developers do not use themselves.</source>
          <target state="translated">어떤 사람들은 양성 경고가 미래의 변화에서 발생할 수있는 실제 경고를 가리기 때문에 모든 경고를 제거해야한다고 말합니다. 이것은 사실입니다. 그러나 개발자는 모든 경고가 SQLite 개발에 사용 된 빌드 (다양한 버전의 GCC, MSVC 및 clang)에서 이미 수정되었음을 관찰합니다. 컴파일러 경고는 일반적으로 SQLite 개발자가 사용하지 않는 컴파일러 또는 컴파일 타임 옵션에서만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8711937cd8478cc6ecffffaffa9bef747431485f" translate="yes" xml:space="preserve">
          <source>Some people view RELEASE as the equivalent of COMMIT for a SAVEPOINT. This is an acceptable point of view as long as one remembers that the changes committed by an inner transaction might later be undone by a rollback in an outer transaction.</source>
          <target state="translated">어떤 사람들은 RELEASE를 SAVEPOINT에 대한 COMMIT와 동등한 것으로 간주합니다. 내부 트랜잭션에 의해 커밋 된 변경 사항이 나중에 외부 트랜잭션의 롤백에 의해 취소 될 수 있다는 것을 기억하는 한 이는 허용 가능한 관점입니다.</target>
        </trans-unit>
        <trans-unit id="0c7ab5e876e4a01802f6862f91dcb4e0c53f5563" translate="yes" xml:space="preserve">
          <source>Some pragmas take effect during the SQL compilation stage, not the execution stage. This means if using the C-language &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; API (or similar in a wrapper interface), the pragma may run during the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; call, not during the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; call as normal SQL statements do. Or the pragma might run during sqlite3_step() just like normal SQL statements. Whether or not the pragma runs during sqlite3_prepare() or sqlite3_step() depends on the pragma and on the specific release of SQLite.</source>
          <target state="translated">일부 pragma는 실행 단계가 아닌 SQL 컴파일 단계에서 적용됩니다. 이 수단 C 언어 사용하는 경우 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare를 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; , &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; API (또는 래퍼 인터페이스에서 유사한), 프라 그마는 동안 실행할 수 있습니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 하지 않는 동안, 전화 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 일반 SQL로 전화 성명서. 또는 pragma는 일반 SQL 문과 마찬가지로 sqlite3_step () 중에 실행될 수 있습니다. pragma가 sqlite3_prepare () 또는 sqlite3_step () 중에 실행되는지 여부는 pragma 및 특정 SQLite 릴리스에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="16b35f88ff5fdb19b220d3f1fb964fe543a7595b" translate="yes" xml:space="preserve">
          <source>Some programmers cannot imagine developing a complex system like SQLite in a language that is not &quot;object oriented&quot;. So why is SQLite not coded in C++ or Java?</source>
          <target state="translated">일부 프로그래머는 &quot;객체 지향&quot;이 아닌 언어로 SQLite와 같은 복잡한 시스템을 개발하는 것을 상상할 수 없습니다. 그렇다면 왜 SQLite가 C ++ 또는 Java로 코딩되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="b34c6a5bd79eb90989f1ccbc7f5ec2a47398a0d5" translate="yes" xml:space="preserve">
          <source>Some query parameters are interpreted by the SQLite core and used to modify the characteristics of the new connection. All query parameters are always passed through into the xOpen method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; even if they are previously read and interpreted by the SQLite core.</source>
          <target state="translated">일부 쿼리 매개 변수는 SQLite 코어에서 해석되며 새 연결의 특성을 수정하는 데 사용됩니다. 모든 쿼리 매개 변수는 이전에 SQLite 코어에서 읽고 해석하더라도 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xOpen 메서드로 항상 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="dfe466f14dd2cc6407106f618ec85911c7fcc3f4" translate="yes" xml:space="preserve">
          <source>Some readers might be reluctant to consider SQLite as an application file format because they have been inculcated with the idea that all SQL database schemas must be factored into third normal form and store only small primitive data types such as strings and integers. Certainly relational theory is important and designers should strive to understand it. But, as demonstrated above, it is often quite acceptable to store complex information as XML or JSON in text fields of a database. Do what works, not what your database professor said you ought to do.</source>
          <target state="translated">일부 독자는 모든 SQL 데이터베이스 스키마를 세 번째 정규 형식으로 인수 화하고 문자열 및 정수와 같은 작은 기본 데이터 유형 만 저장해야한다는 아이디어를 가지고 있기 때문에 SQLite를 애플리케이션 파일 형식으로 간주하기를 꺼려 할 수 있습니다. 확실히 관계 이론은 중요하며 디자이너는 그것을 이해하려고 노력해야합니다. 그러나 위에서 설명한 것처럼 복잡한 정보를 데이터베이스의 텍스트 필드에 XML 또는 JSON으로 저장하는 것이 허용되는 경우가 많습니다. 데이터베이스 교수가해야 할 말이 아니라 작동하는 것을하십시오.</target>
        </trans-unit>
        <trans-unit id="da24c123adee2fd8a84517f276f1059ec16db37d" translate="yes" xml:space="preserve">
          <source>Some readers might resist using SQLite as an application file format due to prior exposure to enterprise SQL databases and the caveats and limitations of those other systems. For example, many enterprise database engines advise against storing large strings or BLOBs in the database and instead suggest that large strings and BLOBs be stored as separate files and the filename stored in the database. But SQLite is not like that. Any column of an SQLite database can hold a string or BLOB up to about a gigabyte in size. And for strings and BLOBs of 100 kilobytes or less, &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I/O performance is better&lt;/a&gt; than using separate files.</source>
          <target state="translated">일부 독자는 엔터프라이즈 SQL 데이터베이스에 대한 사전 노출과 다른 시스템의 경고 및 제한으로 인해 SQLite를 애플리케이션 파일 형식으로 사용하는 것을 거부 할 수 있습니다. 예를 들어, 많은 엔터프라이즈 데이터베이스 엔진은 데이터베이스에 큰 문자열 또는 BLOB를 저장하지 말고 대신 큰 문자열과 BLOB를 별도의 파일로 저장하고 파일 이름을 데이터베이스에 저장하도록 제안합니다. 그러나 SQLite는 그렇지 않습니다. SQLite 데이터베이스의 모든 열은 최대 약 기가 바이트 크기의 문자열 또는 BLOB를 보유 할 수 있습니다. 또한 100KB 이하의 문자열 및 BLOB의 경우 별도의 파일을 사용하는 것보다 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;I / O 성능이 좋습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4623126273e781b93958cb9c59802c9b42b20a62" translate="yes" xml:space="preserve">
          <source>Some sanity checking code was removed from the inner loop of vdbe.c to help the library to run a little faster. The code is only removed if you compile with -DNDEBUG.</source>
          <target state="translated">라이브러리가 약간 더 빠르게 실행되도록 돕기 위해 vdbe.c의 내부 루프에서 일부 위생 검사 코드가 제거되었습니다. -DNDEBUG로 컴파일 할 경우에만 코드가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fdb2b13b24f119a63e7d35aeab7a0a13260e1127" translate="yes" xml:space="preserve">
          <source>Some systems (for example, Windows 95) do not support the operation implemented by sqlite3_mutex_try(). On those systems, sqlite3_mutex_try() will always return SQLITE_BUSY. The SQLite core only ever uses sqlite3_mutex_try() as an optimization so this is acceptable behavior.</source>
          <target state="translated">일부 시스템 (예 : Windows 95)은 sqlite3_mutex_try ()로 구현 된 작업을 지원하지 않습니다. 이러한 시스템에서 sqlite3_mutex_try ()는 항상 SQLITE_BUSY를 반환합니다. SQLite 코어는 sqlite3_mutex_try ()를 최적화로만 사용하므로 허용되는 동작입니다.</target>
        </trans-unit>
        <trans-unit id="3594c70c212410200cff937ed0dc1d8804fee77c" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations (ex: &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt;) make use of real (non-virtual) database tables to store content. For example, when content is inserted into the FTS3 virtual table, the data is ultimately stored in real tables named &quot;%_content&quot;, &quot;%_segdir&quot;, &quot;%_segments&quot;, &quot;%_stat&quot;, and &quot;%_docsize&quot; where &quot;%&quot; is the name of the original virtual table. This auxiliary real tables that store content for a virtual table are called &quot;shadow tables&quot;. See (&lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt;), (&lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt;), and (&lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt;) for additional information.</source>
          <target state="translated">일부 가상 테이블 구현 (예 : &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; )은 실제 (가상이 아닌) 데이터베이스 테이블을 사용하여 컨텐츠를 저장합니다. 예를 들어 콘텐츠가 FTS3 가상 테이블에 삽입되면 데이터는 &quot;% _content&quot;, &quot;% _segdir&quot;, &quot;% _segments&quot;, &quot;% _stat&quot;및 &quot;% _docsize&quot;라는 실제 테이블에 저장됩니다. 여기서 &quot;% &quot;는 원래 가상 테이블의 이름입니다. 가상 테이블의 내용을 저장하는이 보조 실제 테이블을 &quot;새도우 테이블&quot;이라고합니다. 자세한 내용은 ( &lt;a href=&quot;fts3#*shadowtab&quot;&gt;1&lt;/a&gt; ), ( &lt;a href=&quot;fts5#appendix_b&quot;&gt;2&lt;/a&gt; ) 및 ( &lt;a href=&quot;rtree#xshadow&quot;&gt;3&lt;/a&gt; )을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ac3c1999dd15ec935e4c05fd2cbb35a8f0236c55" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">일부 가상 테이블 구현은 트랜잭션 커밋의 일부로 행을 rowid 테이블에 삽입 할 수 있습니다 (예 : 메모리에 축적 된 데이터를 디스크로 플러시하기 위해). 이 경우이 함수에 대한 후속 호출은 이러한 내부 INSERT 조작과 연관된 rowid를 리턴하므로 직관적이지 않은 결과가 발생합니다. 이러한 방식으로 rowid 테이블에 쓰는 가상 테이블 구현 은 사용자에게 제어를 리턴하기 전에 &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt; 를 사용하여 원래 rowid 값을 복원하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf0309e04b01e09dca18924e050475fbb9284235" translate="yes" xml:space="preserve">
          <source>Some virtual table implementations may INSERT rows into rowid tables as part of committing a transaction (e.g. to flush data accumulated in memory to disk). In this case subsequent calls to this function return the rowid associated with these internal INSERT operations, which leads to unintuitive results. Virtual table implementations that do write to rowid tables in this way can avoid this problem by restoring the original rowid value using &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; before returning control to the user.</source>
          <target state="translated">일부 가상 테이블 구현은 트랜잭션 커밋의 일부로 행을 rowid 테이블에 삽입 할 수 있습니다 (예 : 메모리에 축적 된 데이터를 디스크로 플러시하기 위해). 이 경우이 함수에 대한 후속 호출은 이러한 내부 INSERT 조작과 연관된 rowid를 리턴하므로 직관적이지 않은 결과가 발생합니다. 이러한 방식으로 rowid 테이블에 쓰는 가상 테이블 구현 은 사용자에게 제어를 리턴하기 전에 &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt; 를 사용하여 원래 rowid 값을 복원하여이 문제를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="37863aa03861c512ad1c77afb4b6689cfad7493b" translate="yes" xml:space="preserve">
          <source>Some virtual tables exist automatically in the &quot;main&quot; schema of every database connection in which their module is registered, even without a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement. Such virtual tables are called &quot;eponymous virtual tables&quot;. To use an eponymous virtual table, simply use the module name as if it were a table. Eponymous virtual tables exist in the &quot;main&quot; schema only, so they will not work if prefixed with a different schema name.</source>
          <target state="translated">일부 가상 테이블은 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문이 없어도 모듈이 등록 된 모든 데이터베이스 연결의 &quot;주&quot;스키마에 자동으로 존재 합니다. 이러한 가상 테이블을 &quot;명명 가상 테이블&quot;이라고합니다. 시연 가상 테이블을 사용하려면 단순히 모듈 이름을 테이블 인 것처럼 사용하십시오. 동의어 가상 테이블은 &quot;주&quot;스키마에만 존재하므로 다른 스키마 이름이 접두사로 사용되면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0235dde661a1106f01332ba53a569381817a7286" translate="yes" xml:space="preserve">
          <source>Someone (or some process) might rename the database file but fail to also rename its associated journal.</source>
          <target state="translated">누군가 (또는 일부 프로세스)가 데이터베이스 파일의 이름을 바꿀 수 있지만 연관된 저널의 이름도 바꾸지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4532d3d7be4feca574a6f6430b43e863945ec230" translate="yes" xml:space="preserve">
          <source>Sometimes &lt;b&gt;sqlite_exec()&lt;/b&gt; would return SQLITE_PROTOCOL when it should have returned SQLITE_BUSY.</source>
          <target state="translated">때때로 &lt;b&gt;sqlite_exec ()&lt;/b&gt; 는 SQLITE_BUSY를 반환했을 때 SQLITE_PROTOCOL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc0c06ae51aa05a33354304329c9c25f09e5959c" translate="yes" xml:space="preserve">
          <source>Sometimes SQLite uses compile-time evaluatable assert() statements. Consider the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt;. Four assert() statements verify the values for compile-time constants so that the reader can quickly check the validity of the if-statement that follows, without having to look up the constant values in a separate header file.</source>
          <target state="translated">때때로 SQLite는 컴파일 타임 평가 가능한 assert () 문을 사용합니다. &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=2130-2138&lt;/a&gt; 의 코드를 고려 하십시오 . 4 개의 assert () 문은 컴파일 타임 상수의 값을 확인하므로 독자는 별도의 헤더 파일에서 상수 값을 조회하지 않고도 다음 if 문의 유효성을 신속하게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e72dc8159e740969eabd99a1be0aa498a87e7c0f" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be completely omitted from a query without changing the result. This can happen if all of the following are true:</source>
          <target state="translated">때때로 결과를 변경하지 않고 쿼리에서 LEFT JOIN을 완전히 생략 할 수 있습니다. 다음과 같은 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f8fa5c7b1abe4111bb41632dd1fff37e6c00e99" translate="yes" xml:space="preserve">
          <source>Sometimes a LEFT JOIN can be converted into an ordinary JOIN, if there are terms in the WHERE clause that guarantee that the two joins will give identical results. In particular, if any column in the right-hand table of the LEFT JOIN must be non-NULL in order for the WHERE clause to be true, then the LEFT JOIN is demoted to an ordinary JOIN.</source>
          <target state="translated">WHERE 절에 두 개의 조인이 동일한 결과를 제공하도록 보장하는 용어가있는 경우 LEFT JOIN이 일반 JOIN으로 변환 될 수 있습니다. 특히, WHERE 절이 참이되도록 LEFT JOIN의 오른쪽 테이블에있는 열이 NULL이 아닌 경우 LEFT JOIN은 일반 JOIN으로 강등됩니다.</target>
        </trans-unit>
        <trans-unit id="f090235439a288798f47de0b5a65b1ea028dc3f6" translate="yes" xml:space="preserve">
          <source>Sometimes a power failure will cause a filesystem to be corrupted such that recently changed filenames are forgotten and the file is moved into a &quot;/lost+found&quot; directory. When that happens, the hot journal will not be found and recovery will not occur. SQLite tries to prevent this by opening and syncing the directory containing the rollback journal at the same time it syncs the journal file itself. However, the movement of files into /lost+found can be caused by unrelated processes creating unrelated files in the same directory as the main database file. And since this is out from under the control of SQLite, there is nothing that SQLite can do to prevent it. If you are running on a system that is vulnerable to this kind of filesystem namespace corruption (most modern journalling filesystems are immune, we believe) then you might want to consider putting each SQLite database file in its own private subdirectory.</source>
          <target state="translated">때때로 정전은 파일 시스템을 손상시켜 최근에 변경된 파일 이름을 잊어 버리고 파일이 &quot;/ lost + found&quot;디렉토리로 이동합니다. 이런 일이 발생하면 핫 저널이 발견되지 않고 복구가 수행되지 않습니다. SQLite는 저널 파일 자체를 동기화하는 동시에 롤백 저널이 포함 된 디렉토리를 열고 동기화하여이를 방지하려고합니다. 그러나 / lost + found로 파일을 이동시키는 것은 기본 데이터베이스 파일과 동일한 디렉토리에 관련없는 파일을 작성하는 관련없는 프로세스로 인해 발생할 수 있습니다. 그리고 이것은 SQLite의 통제하에 있기 때문에 SQLite가 그것을 막기 위해 할 수있는 일은 없습니다. 이러한 종류의 파일 시스템 네임 스페이스 손상에 취약한 시스템에서 실행중인 경우 (대부분의 최신 저널링 파일 시스템은 면역성이 있습니다.각 SQLite 데이터베이스 파일을 자체 개인 서브 디렉토리에 두는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3f9f858786d7c98364aee861ef2804edc03f7313" translate="yes" xml:space="preserve">
          <source>Sometimes applications encounter this error even though there is an abundance of primary disk space because the error occurs when writing into &lt;a href=&quot;tempfiles&quot;&gt;temporary disk files&lt;/a&gt; on a system where temporary files are stored on a separate partition with much less space that the primary disk.</source>
          <target state="translated">기본 파일이 기본 디스크보다 훨씬 적은 공간으로 별도의 파티션에 저장되는 시스템에서 임시 &lt;a href=&quot;tempfiles&quot;&gt;디스크 파일&lt;/a&gt; 에 쓸 때 오류가 발생하기 때문에 기본 디스크 공간 이 충분 하더라도 응용 프로그램에서이 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="fff8b7e3376a922064133232ffd6552acd46f238" translate="yes" xml:space="preserve">
          <source>Sometimes compile-time assert() statements are used to verify that SQLite has been correctly compiled. For example, the code at &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; verifies that the SQLITE_PTRSIZE preprocessor macro is set correctly for the target architecture.</source>
          <target state="translated">때로는 컴파일 타임 assert () 문을 사용하여 SQLite가 올바르게 컴파일되었는지 확인합니다. 예를 들어 &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=157&lt;/a&gt; 의 코드 는 대상 아키텍처에 대해 SQLITE_PTRSIZE 전 처리기 매크로가 올바르게 설정되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d7e0873ee1e2576915056da7a06e2b494b2dd17f" translate="yes" xml:space="preserve">
          <source>Sometimes only part of an ORDER BY clause can be satisfied using indexes. Consider, for example, the following query:</source>
          <target state="translated">때로는 ORDER BY 절의 일부만 인덱스를 사용하여 만족시킬 수 있습니다. 예를 들어 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="08e9765fc44bda2fdb0012e4541cc28a30458938" translate="yes" xml:space="preserve">
          <source>Sometimes operating systems will exhibit non-standard behavior which can lead to problems. Sometimes this non-standard behavior is deliberate, and sometimes it is a mistake in the implementation. But in any event, if the operating performs differently from they way SQLite expects it to perform, the possibility of database corruption exists.</source>
          <target state="translated">때때로 운영 체제는 비표준 동작을 나타내어 문제를 일으킬 수 있습니다. 때때로이 비표준 행동은 의도적 인 것이며 때로는 구 현상 실수입니다. 그러나 어떤 경우에도 운영이 SQLite가 예상 한 방식과 다르게 작동하면 데이터베이스가 손상 될 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f1e4ae24175645a79034bd7c885a1e7d0f09d3" translate="yes" xml:space="preserve">
          <source>Sometimes the use of row values just makes the SQL easier to read and write. Consider the following two UPDATE statements:</source>
          <target state="translated">때때로 행 값을 사용하면 SQL을 더 쉽게 읽고 쓸 수 있습니다. 다음 두 가지 UPDATE 문을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="24e2bab9e04a22b3a6d58f84b00743d3fb69e859" translate="yes" xml:space="preserve">
          <source>Sometimes when this error code is encountered, the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; routine will convert the error into &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; and try again to prepare the SQL statement using a different query plan that does not require the use of the unknown collating sequence.</source>
          <target state="translated">때때로이 오류 코드가 발생하면 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 루틴이 오류를 &lt;a href=&quot;rescode#error_retry&quot;&gt;SQLITE_ERROR_RETRY&lt;/a&gt; 로 변환 하고 알 수없는 조합 순서를 사용할 필요가없는 다른 조회 계획을 사용하여 SQL 문을 다시 준비하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="adc4e96a478be02a8147b100bd68113f38b89f80" translate="yes" xml:space="preserve">
          <source>Sort</source>
          <target state="translated">Sort</target>
        </trans-unit>
        <trans-unit id="5601af90fba7fe38466b58c08c018711849b8855" translate="yes" xml:space="preserve">
          <source>Sort order</source>
          <target state="translated">정렬 순서</target>
        </trans-unit>
        <trans-unit id="74ab25d1e3d8ae1cb528685baf2d71b92460809e" translate="yes" xml:space="preserve">
          <source>SorterCompare</source>
          <target state="translated">SorterCompare</target>
        </trans-unit>
        <trans-unit id="e274ec5d63c6eab4a322b40fa92da953e269dcf5" translate="yes" xml:space="preserve">
          <source>SorterData</source>
          <target state="translated">SorterData</target>
        </trans-unit>
        <trans-unit id="84dc5b8de2832faa332b637acd50721fb4db3efe" translate="yes" xml:space="preserve">
          <source>SorterInsert</source>
          <target state="translated">SorterInsert</target>
        </trans-unit>
        <trans-unit id="2737748d72de05dcf6eba2817820522a4badd0ec" translate="yes" xml:space="preserve">
          <source>SorterNext</source>
          <target state="translated">SorterNext</target>
        </trans-unit>
        <trans-unit id="efe2a2f235ed328025a0db49a289c00d154bb3ba" translate="yes" xml:space="preserve">
          <source>SorterOpen</source>
          <target state="translated">SorterOpen</target>
        </trans-unit>
        <trans-unit id="58a2d7ee050bba205b0d21e366ed8ecfcceedf59" translate="yes" xml:space="preserve">
          <source>SorterSort</source>
          <target state="translated">SorterSort</target>
        </trans-unit>
        <trans-unit id="7dadfa55de2cffb43bdf1a8f139a4a743a9af71b" translate="yes" xml:space="preserve">
          <source>Sorting is accomplished by writing records into a sorting index, then rewinding that index and playing it back from beginning to end. We use the &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode instead of &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; to do the rewinding so that the global variable will be incremented and regression tests can determine whether or not the optimizer is correctly optimizing out sorts.</source>
          <target state="translated">정렬은 레코드를 정렬 색인에 기록한 다음 해당 색인을 되 감고 처음부터 끝까지 재생하여 수행됩니다. &lt;a href=&quot;opcode#Rewind&quot;&gt;리와인드&lt;/a&gt; 대신 &lt;a href=&quot;opcode#Sort&quot;&gt;Sort&lt;/a&gt; opcode를 사용하여 리 와인딩을 수행하여 전역 변수가 증가하고 회귀 테스트에서 옵티마이 저가 정렬을 올바르게 최적화하고 있는지 여부를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c08b606385251adc6f9a4723f760124243a4d3" translate="yes" xml:space="preserve">
          <source>Sorting subsets of the result</source>
          <target state="translated">결과의 하위 집합 정렬</target>
        </trans-unit>
        <trans-unit id="516e89309d994acf5d94c4a4907b3ff4a8e53a80" translate="yes" xml:space="preserve">
          <source>Source Of Data In A Query Result</source>
          <target state="translated">쿼리 결과의 데이터 소스</target>
        </trans-unit>
        <trans-unit id="cfbc658da4e64bd6eef7ec70eab5adab3d14a41a" translate="yes" xml:space="preserve">
          <source>Source code for several useful extensions can be found in the &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext/misc&lt;/a&gt; subdirectory of the SQLite source tree. You can use these extensions as-is, or as a basis for creating your own custom extensions to address your own particular needs.</source>
          <target state="translated">여러 유용한 확장에 대한 소스 코드 는 SQLite 소스 트리 의 &lt;a href=&quot;http://www.sqlite.org/src/tree?name=ext/misc&amp;amp;ci=trunk&quot;&gt;ext / misc&lt;/a&gt; 서브 디렉토리 에서 찾을 수 있습니다 . 이러한 확장은있는 그대로 사용하거나 고유 한 특정 요구를 해결하기 위해 고유 한 사용자 지정 확장을 만드는 기초로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64243b8fe27d8786b74ebe9ad360b0c831315629" translate="yes" xml:space="preserve">
          <source>Sources are in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. Use for any purpose.</source>
          <target state="translated">출처는 &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;공개 도메인에&lt;/a&gt; 있습니다. 어떤 목적 으로든 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bdb7e396773f80244c6756a8ac8a3ba107260e6f" translate="yes" xml:space="preserve">
          <source>Spatial indices using &lt;a href=&quot;rtree&quot;&gt;R-Trees&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-Tree를&lt;/a&gt; 사용한 공간 인덱스</target>
        </trans-unit>
        <trans-unit id="7f329318e826b6123bdadb48df921310c8b500b7" translate="yes" xml:space="preserve">
          <source>Speak no useless words or words that move to laughter.</source>
          <target state="translated">쓸데없는 말이나 웃음으로 움직이는 말을하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9cda32c171792b8ebd4697561ad451beebb8dd76" translate="yes" xml:space="preserve">
          <source>Special INSERT operates can be used to issue commands to FTS3 and FTS4 tables. Every FTS3 and FTS4 has a hidden, read-only column which is the same name as the table itself. INSERTs into this hidden column are interpreted as commands to the FTS3/4 table. For a table with the name &quot;xyz&quot; the following commands are supported:</source>
          <target state="translated">특수 INSERT 연산을 사용하여 FTS3 및 FTS4 테이블에 명령을 실행할 수 있습니다. 모든 FTS3 및 FTS4에는 테이블 자체와 동일한 이름의 숨겨진 읽기 전용 열이 있습니다. 이 숨겨진 열에 대한 INSERT는 FTS3 / 4 테이블에 대한 명령으로 해석됩니다. 이름이 &quot;xyz&quot;인 테이블의 경우 다음 명령이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5c62a06b3206449dc4ac80333e6db0c204db7ba5" translate="yes" xml:space="preserve">
          <source>Special processing occurs when the aggregate function is either &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt;. Example:</source>
          <target state="translated">집계 함수가 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min ()&lt;/a&gt; 또는 &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max () 인&lt;/a&gt; 경우 특수 처리가 발생합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="6937900c4a39aa0fb125a152dfd5d62be4f8822d" translate="yes" xml:space="preserve">
          <source>Special sqlite_stat1 Handling</source>
          <target state="translated">특별 sqlite_stat1 처리</target>
        </trans-unit>
        <trans-unit id="1e4c6816e6235fac1910f655a4449098f3bab054" translate="yes" xml:space="preserve">
          <source>Special versions of the SQLite amalgamation that do work with a predetermined set of SQLITE_OMIT_* options can be generated. To do so, make a copy of the Makefile.linux-gcc makefile template in the canonical source code distribution. Change the name of your copy to simply &quot;Makefile&quot;. Then edit &quot;Makefile&quot; to set up appropriate compile-time options. Then type:</source>
          <target state="translated">미리 결정된 SQLITE_OMIT_ * 옵션 세트와 함께 작동하는 특수 버전의 SQLite 통합이 생성 될 수 있습니다. 그렇게하려면 표준 소스 코드 배포에서 Makefile.linux-gcc makefile 템플릿의 복사본을 만드십시오. 사본 이름을 &quot;Makefile&quot;로 변경하십시오. 그런 다음 &quot;Makefile&quot;을 편집하여 적절한 컴파일 타임 옵션을 설정하십시오. 그런 다음 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="348842ed415067bf469c3c07cbca8231199b183f" translate="yes" xml:space="preserve">
          <source>Specialized applications for which the default implementation of shared memory is unacceptable can devise alternative methods via a custom &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. For example, if it is known that a particular database will only be accessed by threads within a single process, the wal-index can be implemented using heap memory instead of true shared memory.</source>
          <target state="translated">공유 메모리의 기본 구현이 허용되지 않는 특수 응용 프로그램은 사용자 지정 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 통해 대체 방법을 고안 할 수 있습니다 . 예를 들어, 특정 데이터베이스가 단일 프로세스 내의 스레드에 의해서만 액세스 될 것으로 알려진 경우, wal-index는 실제 공유 메모리 대신 힙 메모리를 사용하여 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a647b0621c3756491eb85db442ab54ae4811cd09" translate="yes" xml:space="preserve">
          <source>Specific pragma statements may be removed and others added in future releases of SQLite. There is no guarantee of backwards compatibility.</source>
          <target state="translated">특정 pragma 문은 제거 할 수 있고 다른 릴리스는 SQLite의 향후 릴리스에 추가 될 수 있습니다. 이전 버전과의 호환성을 보장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a894085a5589da14805f40b5e5ec42d34bdb30" translate="yes" xml:space="preserve">
          <source>Specify an alternative malloc implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mem_methods&quot;&gt;sqlite3_mem_methods&lt;/a&gt; 오브젝트 와 함께 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmalloc&quot;&gt;SQLITE_CONFIG_MALLOC&lt;/a&gt; 동사를 사용하여 대체 malloc 구현을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="7969816e7b05b7f6c6da58d9c3d55a797859dc5f" translate="yes" xml:space="preserve">
          <source>Specify an alternative mutex implementation using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; verb with the &lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mutex_methods&quot;&gt;sqlite3_mutex_methods&lt;/a&gt; 오브젝트 와 함께 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 동사를 사용하여 대체 뮤텍스 구현을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7d9e8c303af8fa2eba928e74e37e3e2d5b8ccc2" translate="yes" xml:space="preserve">
          <source>Specify an application-defined page cache.</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="675036f344331d67d2ac3929e1284013b1817b31" translate="yes" xml:space="preserve">
          <source>Specifying a new page size does not change the page size immediately. Instead, the new page size is remembered and is used to set the page size when the database is first created, if it does not already exist when the page_size pragma is issued, or at the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command that is run on the same database connection while not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">새 페이지 크기를 지정해도 페이지 크기가 즉시 변경되지는 않습니다. 대신, page_size pragma가 발행 될 때 또는 같은 데이터베이스 연결에서 실행 되는 다음 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령에 데이터베이스가 존재하지 않는 경우, 새 페이지 크기가 기억되어 데이터베이스가 처음 작성 될 때 페이지 크기를 설정하는 데 사용됩니다. &lt;a href=&quot;wal&quot;&gt;WAL 모드가&lt;/a&gt; 아닌 동안 .</target>
        </trans-unit>
        <trans-unit id="dfdc7dcd44b7642ef54261a530f0a8d271e92800" translate="yes" xml:space="preserve">
          <source>Specifying an explicit value for the rowid field as part of an INSERT statement is not supported. Any value supplied is ignored.</source>
          <target state="translated">INSERT 문의 일부로 rowid 필드에 명시 적 값을 지정하는 것은 지원되지 않습니다. 제공된 모든 값은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ff83e10cd15a3b1a3684d12025d600161e1e03fe" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;../uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">URI의 쿼리 구성 요소에 알 수없는 매개 변수를 지정하는 것은 오류가 아닙니다. 이후 버전의 SQLite는 추가 쿼리 매개 변수를 이해할 수 있습니다. 추가 정보는 &quot; &lt;a href=&quot;../uri#coreqp&quot;&gt;SQLite에 특별한 의미를 가진 쿼리 매개 변수&lt;/a&gt; &quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca08c5f93bc177c41e9e1cbac8bb1b05f691f402" translate="yes" xml:space="preserve">
          <source>Specifying an unknown parameter in the query component of a URI is not an error. Future versions of SQLite might understand additional query parameters. See &quot;&lt;a href=&quot;uri#coreqp&quot;&gt;query parameters with special meaning to SQLite&lt;/a&gt;&quot; for additional information.</source>
          <target state="translated">URI의 쿼리 구성 요소에 알 수없는 매개 변수를 지정하는 것은 오류가 아닙니다. 이후 버전의 SQLite는 추가 쿼리 매개 변수를 이해할 수 있습니다. 추가 정보는 &quot; &lt;a href=&quot;uri#coreqp&quot;&gt;SQLite에 특별한 의미를 가진 쿼리 매개 변수&lt;/a&gt; &quot;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5466deac546a32beeffc729c74a6e5fd300f895" translate="yes" xml:space="preserve">
          <source>Specifying three arguments when creating an fts5vocab table in any database other than &quot;temp&quot; results in an error.</source>
          <target state="translated">&quot;temp&quot;이외의 데이터베이스에서 fts5vocab 테이블을 작성할 때 세 개의 인수를 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="076b62c1c3d09beab9691ee6f442faa2e62ef7a7" translate="yes" xml:space="preserve">
          <source>Speed improvements</source>
          <target state="translated">속도 개선</target>
        </trans-unit>
        <trans-unit id="65d5a13bd4511e6816f18d10b6fcf53288c30d62" translate="yes" xml:space="preserve">
          <source>Speed improvements and library footprint reductions.</source>
          <target state="translated">속도 향상 및 라이브러리 풋 프린트 감소</target>
        </trans-unit>
        <trans-unit id="886fdbf5bb356c1170f6be819f95ecf4cc1461e3" translate="yes" xml:space="preserve">
          <source>Speed improvements in the VDBE.</source>
          <target state="translated">VDBE의 속도 향상.</target>
        </trans-unit>
        <trans-unit id="67d42db811b80e228f8d1a0a01dc2cacac3b1009" translate="yes" xml:space="preserve">
          <source>Speed improvements in the btree and pager layers.</source>
          <target state="translated">btree 및 pager 레이어의 속도 향상</target>
        </trans-unit>
        <trans-unit id="0da1385bd95c04e2cef432911cc39014873cc087" translate="yes" xml:space="preserve">
          <source>Speed improvements: Do not do synchronous updates on TEMP tables.</source>
          <target state="translated">속도 향상 : TEMP 테이블에서 동기 업데이트를 수행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="77d342a78b198923e433b8a1315c81a6ffbf9833" translate="yes" xml:space="preserve">
          <source>Split amalgamation</source>
          <target state="translated">분할 합병</target>
        </trans-unit>
        <trans-unit id="1dac9d1634f1fa754c9cb08212550ad68bf6b1f7" translate="yes" xml:space="preserve">
          <source>Split the pager subsystem into separate pager and pcache subsystems.</source>
          <target state="translated">호출기 서브 시스템을 별도의 호출기 및 pcache 서브 시스템으로 분할하십시오.</target>
        </trans-unit>
        <trans-unit id="1bb46447f9362d79f903651b48710b55ec51dd8a" translate="yes" xml:space="preserve">
          <source>Splitting content into smaller pieces also helps File/Save operations to go faster. Instead of having to write back the content of all pages when doing a File/Save, the application only has to write back those pages that have actually changed.</source>
          <target state="translated">내용을 더 작은 조각으로 나누면 파일 / 저장 작업이 더 빨라집니다. 파일 / 저장을 수행 할 때 모든 페이지의 내용을 다시 써야하는 대신 응용 프로그램은 실제로 변경된 페이지 만 다시 써야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b1c55ba41f5df4c296b1603dd8662a874ad05f" translate="yes" xml:space="preserve">
          <source>SqlExec</source>
          <target state="translated">SqlExec</target>
        </trans-unit>
        <trans-unit id="21ba7365f757b4f24cbf08b5870a91de5cd965d8" translate="yes" xml:space="preserve">
          <source>Sqldiff --rbu</source>
          <target state="translated">Sqldiff --rbu</target>
        </trans-unit>
        <trans-unit id="785ca9526809c90e3417966be7d5844fd2a0c5c8" translate="yes" xml:space="preserve">
          <source>Stability</source>
          <target state="translated">Stability</target>
        </trans-unit>
        <trans-unit id="d96e5b2dd07c1733b2b013bd82922c22baade37d" translate="yes" xml:space="preserve">
          <source>Stable</source>
          <target state="translated">Stable</target>
        </trans-unit>
        <trans-unit id="ed9cb8071fd38e38b556df67e342f21ef7bd62db" translate="yes" xml:space="preserve">
          <source>Stable interfaces will be maintained indefinitely in a backwards compatible way. An application that uses only stable interfaces should always be able to relink against a newer version of SQLite without any changes.</source>
          <target state="translated">안정적인 인터페이스는 이전 버전과 호환되는 방식으로 무기한 유지 관리됩니다. 안정적인 인터페이스 만 사용하는 응용 프로그램은 변경없이 항상 최신 버전의 SQLite에 다시 연결할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d69ca23f60003536eb90ef7c1a45510967cd2a5" translate="yes" xml:space="preserve">
          <source>Stale file descriptor</source>
          <target state="translated">오래된 파일 설명자</target>
        </trans-unit>
        <trans-unit id="aaf4ee63c814f2ac7a90ca00e168f99ba47070e5" translate="yes" xml:space="preserve">
          <source>Standard File Control Opcodes</source>
          <target state="translated">표준 파일 제어 연산 코드</target>
        </trans-unit>
        <trans-unit id="0271f691eaa2014cfdc1f8a7ed1187c67c1f03ee" translate="yes" xml:space="preserve">
          <source>Standard Query Syntax Precedence</source>
          <target state="translated">표준 쿼리 구문 우선 순위</target>
        </trans-unit>
        <trans-unit id="62af2c2f7d7a242deb88ffff88441215850f0cf0" translate="yes" xml:space="preserve">
          <source>Standard builds include the default &quot;unix&quot; or &quot;win32&quot; VFSes. But if you use the -DOS_OTHER=1 compile-time option, then SQLite is built without a default VFS. In that case, the application must register at least one VFS prior to calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;. This is the approach that embedded applications should use. Rather than modifying the SQLite source to insert an alternative OS layer as was done in prior releases of SQLite, instead compile an unmodified SQLite source file (preferably the amalgamation) with the -DOS_OTHER=1 option, then invoke &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; to define the interface to the underlying filesystem prior to creating any database connections.</source>
          <target state="translated">표준 빌드에는 기본 &quot;unix&quot;또는 &quot;win32&quot;VFS가 포함됩니다. 그러나 -DOS_OTHER = 1 컴파일 타임 옵션을 사용하면 기본 VFS없이 SQLite가 빌드됩니다. 이 경우 응용 프로그램은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 을 호출하기 전에 하나 이상의 VFS를 등록해야합니다 . 이것이 임베디드 애플리케이션이 사용해야하는 접근 방식입니다. SQLite의 이전 릴리스에서 수행 된 대체 OS 계층을 삽입하도록 SQLite 소스를 수정하는 대신 -DOS_OTHER = 1 옵션을 사용하여 수정되지 않은 SQLite 소스 파일 (바람직하게는 amalgamation)을 컴파일 한 다음 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 를 호출 하여 인터페이스를 정의하십시오. 데이터베이스 연결을 작성하기 전에 기본 파일 시스템에.</target>
        </trans-unit>
        <trans-unit id="f4bb77fea34e91bf036ddd54845284d1cf9ef7e7" translate="yes" xml:space="preserve">
          <source>Standard builds of SQLite for Unix or Windows come with a single VFS named &quot;unix&quot; or &quot;win32&quot;, as appropriate. This one VFS is also the default. So if you are using the legacy open functions, everything will continue to operate as it has before. The change is that an application now has the flexibility of adding new VFS modules to implement a customized OS layer. The &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; API can be used to tell SQLite about one or more application-defined VFS modules:</source>
          <target state="translated">Unix 또는 Windows 용 표준 SQLite 빌드에는 &quot;unix&quot;또는 &quot;win32&quot;라는 단일 VFS가 제공됩니다. 이 하나의 VFS도 기본값입니다. 따라서 레거시 개방 기능을 사용하는 경우 모든 기능이 이전과 동일하게 계속 작동합니다. 변경 사항은 이제 응용 프로그램에 새로운 VFS 모듈을 추가하여 사용자 지정 OS 계층을 구현할 수있는 유연성이 있다는 것입니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; API는 하나 이상의 응용 프로그램 정의 VFS 모듈에 대한 SQLite는 얘기 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="d9cadaed061bc7503c3155b4851296844f6b19b6" translate="yes" xml:space="preserve">
          <source>Start a read transaction on an historical snapshot</source>
          <target state="translated">히스토리 스냅 샷에서 읽기 트랜잭션 시작</target>
        </trans-unit>
        <trans-unit id="789445bbe2e230b404b0877611cb047ff79a2a8a" translate="yes" xml:space="preserve">
          <source>Start a transaction.</source>
          <target state="translated">거래를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad3ad0c5dcdfd16f6c5507085aa11afef993658" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database (or &lt;a href=&quot;#zipdb&quot;&gt;ZIP archive&lt;/a&gt;). If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">명령 프롬프트에서 &quot;sqlite3&quot;을 입력하고 선택적으로 SQLite 데이터베이스 (또는 &lt;a href=&quot;#zipdb&quot;&gt;ZIP 아카이브&lt;/a&gt; ) 를 보유하는 파일 이름을 입력 하여 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램을 시작합니다 . 명명 된 파일이 존재하지 않는 경우 지정된 이름의 새 데이터베이스 파일이 자동으로 생성됩니다. 명령 줄에 데이터베이스 파일이 지정되지 않은 경우 임시 데이터베이스가 생성 된 다음 &quot;sqlite3&quot;프로그램이 종료 될 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b65d3b5410040822706753355b83a262ca2b3805" translate="yes" xml:space="preserve">
          <source>Start the &lt;b&gt;sqlite3&lt;/b&gt; program by typing &quot;sqlite3&quot; at the command prompt, optionally followed by the name the file that holds the SQLite database. If the named file does not exist, a new database file with the given name will be created automatically. If no database file is specified on the command-line, a temporary database is created, then deleted when the &quot;sqlite3&quot; program exits.</source>
          <target state="translated">명령 프롬프트에서 &quot;sqlite3&quot;을 입력하고 선택적으로 SQLite 데이터베이스를 보유하는 파일 이름을 입력 하여 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램을 시작하십시오 . 명명 된 파일이 존재하지 않으면 지정된 이름의 새 데이터베이스 파일이 자동으로 생성됩니다. 명령 행에 데이터베이스 파일이 지정되지 않은 경우 임시 데이터베이스가 작성되고 &quot;sqlite3&quot;프로그램이 종료 될 때 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="9eb60319509fec567263f40a7e8bf18c02dfd219" translate="yes" xml:space="preserve">
          <source>Starting with &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;version 3.3.0&lt;/a&gt; (2006-01-11), SQLite includes a special &quot;shared-cache&quot; mode (disabled by default) intended for use in embedded servers. If shared-cache mode is enabled and a thread establishes multiple connections to the same database, the connections share a single data and schema cache. This can significantly reduce the quantity of memory and IO required by the system.</source>
          <target state="translated">시작 &lt;a href=&quot;https://sqlite.org/releaselog/3_3_0.html&quot;&gt;버전 3.3.0&lt;/a&gt; (2006년 1월 11일), SQLite는은 (기본적으로 비활성화) 특별한 &quot;공유 캐시&quot;모드를 포함하는 임베디드 서버에서 사용하기위한 것. 공유 캐시 모드가 사용 가능하고 스레드가 동일한 데이터베이스에 대한 다중 연결을 설정하면 연결은 단일 데이터 및 스키마 캐시를 공유합니다. 이를 통해 시스템에 필요한 메모리 및 IO의 양을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="023a31bfb8ddab03b504852064e49a20e7d9d830" translate="yes" xml:space="preserve">
          <source>Startup time is reduced by allowing the application to read in only the content shown for the initial screen. This largely eliminates the need to show a progress bar when opening a new document. The document just pops up immediately, further enhancing the user experience.</source>
          <target state="translated">응용 프로그램이 초기 화면에 표시된 내용 만 읽을 수 있도록하여 시작 시간이 줄어 듭니다. 따라서 새 문서를 열 때 진행률 표시 줄을 표시하지 않아도됩니다. 문서가 즉시 팝업되어 사용자 경험을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="ec7c6f024748b0b4ca685edf7c9c36a22ff2bd48" translate="yes" xml:space="preserve">
          <source>Statement Rollback</source>
          <target state="translated">명령문 롤백</target>
        </trans-unit>
        <trans-unit id="b1c7b81be5c9efcc042ff8389d0cd187913125cb" translate="yes" xml:space="preserve">
          <source>Statement Transactions</source>
          <target state="translated">명세서 거래</target>
        </trans-unit>
        <trans-unit id="a90f613a0e148cacdfc6a3c9d8b61b95e2acb93e" translate="yes" xml:space="preserve">
          <source>Statement journal</source>
          <target state="translated">명세서 일지</target>
        </trans-unit>
        <trans-unit id="eb1040e934c3b0c196798a9d1961f27355d86e45" translate="yes" xml:space="preserve">
          <source>Statement journals</source>
          <target state="translated">명세서 일지</target>
        </trans-unit>
        <trans-unit id="ff8ba443e0e2998259e771cf2ecb0604dd034de1" translate="yes" xml:space="preserve">
          <source>Static analysis has not been helpful in finding bugs in SQLite. Static analysis has found a few bugs in SQLite, but those are the exceptions. More bugs have been introduced into SQLite while trying to get it to compile without warnings than have been found by static analysis.</source>
          <target state="translated">정적 분석은 SQLite에서 버그를 찾는 데 도움이되지 않았습니다. 정적 분석은 SQLite에서 몇 가지 버그를 발견했지만 예외입니다. 정적 분석에서 발견 된 것보다 경고없이 컴파일하도록 시도하는 동안 SQLite에 더 많은 버그가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="680999abb1389f8c322acbd6c1aa5dbe84be6521" translate="yes" xml:space="preserve">
          <source>Static analysis means analyzing source code at compile-time to check for correctness. Static analysis includes compiler warning messages and more in-depth analysis engines such as the &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt;. SQLite compiles without warnings on GCC and Clang using the -Wall and -Wextra flags on Linux and Mac and on MSVC on Windows. No valid warnings are generated by the Clang Static Analyzer tool &quot;scan-build&quot; either (though recent versions of clang seem to generate many false-positives.) Nevertheless, some warnings might be generated by other static analyzers. Users are encouraged not to stress over these warnings and to instead take solace in the intense testing of SQLite described above.</source>
          <target state="translated">정적 분석은 컴파일 타임에 소스 코드를 분석하여 정확성을 확인하는 것을 의미합니다. 정적 분석에는 컴파일러 경고 메시지와 &lt;a href=&quot;http://clang-analyzer.llvm.org/&quot;&gt;Clang Static Analyzer&lt;/a&gt; 와 같은보다 심층적 인 분석 엔진이 포함됩니다 . SQLite는 Linux 및 Mac에서 -Wall 및 -Wextra 플래그를 사용하여 GCC 및 Clang에서 경고없이 컴파일하고 Windows의 MSVC에서 컴파일합니다. Clang Static Analyzer 도구 &quot;scan-build&quot;에 의해 유효한 경고가 생성되지 않습니다 (최근 버전의 clang은 많은 오탐 (false-positive)을 생성하는 것으로 보입니다). 그러나 일부 경고는 다른 정적 분석기에 의해 생성 될 수 있습니다. 사용자는 이러한 경고를 강조하지 말고 위에서 설명한 SQLite의 강력한 테스트에서 위안을 취하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e49731cc0b88e4893c23ef28a83ddda3bfb212a" translate="yes" xml:space="preserve">
          <source>Statistics gathered by ANALYZE are not automatically updated as the content of the database changes. If the content of the database changes significantly, or if the database schema changes, then one should consider rerunning the ANALYZE command in order to update the statistics.</source>
          <target state="translated">ANALYZE에 의해 수집 된 통계는 데이터베이스의 내용이 변경 될 때 자동으로 업데이트되지 않습니다. 데이터베이스의 내용이 크게 변경되거나 데이터베이스 스키마가 변경되면 통계를 업데이트하기 위해 ANALYZE 명령을 다시 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="06d77b9bb2436857be2774ccf495a6735714ef3f" translate="yes" xml:space="preserve">
          <source>Statistics might not be available for all loops in all statements. In cases where there exist loops with no available statistics, this function behaves as if the loop did not exist - it returns non-zero and leave the variable that pOut points to unchanged.</source>
          <target state="translated">모든 명령문에서 모든 루프에 대한 통계를 사용하지 못할 수 있습니다. 사용 가능한 통계가없는 루프가있는 경우이 함수는 루프가 존재하지 않는 것처럼 작동합니다. 0이 아닌 값을 반환하고 pOut이 가리키는 변수를 변경하지 않은 채로 둡니다.</target>
        </trans-unit>
        <trans-unit id="bc97dbd639562aa95bfaa677d2f8dc3487a559db" translate="yes" xml:space="preserve">
          <source>Stats pragma</source>
          <target state="translated">통계 pragma</target>
        </trans-unit>
        <trans-unit id="df542e628beff2a0b73ed1e479f1091511d9cd6a" translate="yes" xml:space="preserve">
          <source>Status Of A Dynamic String</source>
          <target state="translated">동적 문자열의 상태</target>
        </trans-unit>
        <trans-unit id="6872312ea81433049bd70deac565b5d633fd6998" translate="yes" xml:space="preserve">
          <source>Status Parameters</source>
          <target state="translated">상태 매개 변수</target>
        </trans-unit>
        <trans-unit id="2adc22e7dbafa333d0e47ced61c20bab368c7387" translate="yes" xml:space="preserve">
          <source>Status Parameters for database connections</source>
          <target state="translated">데이터베이스 연결을위한 상태 매개 변수</target>
        </trans-unit>
        <trans-unit id="8499ef2845b7984472eeaa5eec92eef3c3ddc5e1" translate="yes" xml:space="preserve">
          <source>Status Parameters for prepared statements</source>
          <target state="translated">준비된 명령문의 상태 매개 변수</target>
        </trans-unit>
        <trans-unit id="f04daddc4070fdc058ac9e443c8962cff2f5d578" translate="yes" xml:space="preserve">
          <source>Sticky &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; or &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; errors in the pager are reset when a new transaction is started.</source>
          <target state="translated">새 트랜잭션이 시작되면 호출기의 고정 &lt;a href=&quot;rescode#full&quot;&gt;SQLITE_FULL&lt;/a&gt; 또는 &lt;a href=&quot;rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; 오류가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dd4fde80455d82361972cd992928272cdd38d544" translate="yes" xml:space="preserve">
          <source>Storage class</source>
          <target state="translated">저장 등급</target>
        </trans-unit>
        <trans-unit id="0adf951cb70d6bfcdd293ee933bb14acec2e8923" translate="yes" xml:space="preserve">
          <source>Storage space for &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; objects.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트를 위한 스토리지 공간 .</target>
        </trans-unit>
        <trans-unit id="fbf3f676fb55796ce1a966642440eafe303dfddd" translate="yes" xml:space="preserve">
          <source>Storage used for</source>
          <target state="translated">저장 공간</target>
        </trans-unit>
        <trans-unit id="7a5447c3e2de40c5c68aa31375241b98a076167c" translate="yes" xml:space="preserve">
          <source>Store an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt; in a database table so that Undo could go back into prior edit sessions.</source>
          <target state="translated">저장 &lt;a href=&quot;undoredo&quot;&gt;실행 취소 / 다시 실행 스택 자동화 된&lt;/a&gt; 데이터베이스 테이블에서 실행 취소 전에 편집 세션으로 되돌아 갈 수 있도록하는 것이.</target>
        </trans-unit>
        <trans-unit id="a49a369d4dc034b2ddab0ef35e3bc0a19be08a8f" translate="yes" xml:space="preserve">
          <source>Store in register P2 an integer which is the key of the table entry that P1 is currently point to.</source>
          <target state="translated">레지스터 P2에 현재 P1이 가리키는 테이블 항목의 키인 정수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="867b15696e9fa5010d6dcd54eb51b1ee5a1a7a9e" translate="yes" xml:space="preserve">
          <source>Store in register P3 the value of the P2-th column of the current row of the virtual-table of cursor P1.</source>
          <target state="translated">커서 P1의 가상 테이블에서 현재 행의 P2 번째 열의 값을 레지스터 P3에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="c36766981b9139e0da225001d40b99095efc88b9" translate="yes" xml:space="preserve">
          <source>Store in register r[P3] the byte offset into the database file that is the start of the payload for the record at which that cursor P1 is currently pointing.</source>
          <target state="translated">커서 p1이 현재 가리키는 레코드에 대한 페이로드의 시작 인 데이터베이스 파일에 바이트 오프셋을 레지스터 r [P3]에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="30c620766d52d9f14ee6085868bffd5fb7f16c25" translate="yes" xml:space="preserve">
          <source>Store new polygons in the table using ordinary INSERT statements:</source>
          <target state="translated">일반적인 INSERT 문을 사용하여 테이블에 새 다각형을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="e312586c7080f660b8a13dd56528c07ac821e623" translate="yes" xml:space="preserve">
          <source>Store the maximum page count after the change in register P2.</source>
          <target state="translated">레지스터 P2를 변경 한 후 최대 페이지 수를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="4a03a2e19022832dfb9661ede226d69d6b142a41" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2</source>
          <target state="translated">레지스터 P2의 커서 P1에 의해 열린 테이블 또는 인덱스에 항목 수 (정수 값)를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="8f97ad7b80660d239651ee854a82a3871ca04288" translate="yes" xml:space="preserve">
          <source>Store the number of entries (an integer value) in the table or index opened by cursor P1 in register P2.</source>
          <target state="translated">레지스터 P2의 커서 P1에 의해 열린 테이블 또는 인덱스의 항목 수 (정수 값)를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="640b00f8e936acd9d22458864812f703b6f037f6" translate="yes" xml:space="preserve">
          <source>Store the statement journal in the temporary file directory instead of collocated with the database file.</source>
          <target state="translated">데이터베이스 파일과 함께 배치되지 않고 임시 파일 디렉토리에 명령문 저널을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="25a1d24f343a9c4193ce3147697d66befd80ac3b" translate="yes" xml:space="preserve">
          <source>Storing the schema a text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">스키마를 텍스트로 저장하면 &lt;a href=&quot;fileformat2&quot;&gt;SQLite 데이터베이스 파일 형식을&lt;/a&gt; 보다 쉽게 ​​정의, 문서화 및 이해할 수 있습니다. 이를 통해 SQLite 데이터베이스 파일을 장기 데이터 보관을위한 &lt;a href=&quot;locrsf&quot;&gt;권장 저장소 형식으로&lt;/a&gt; 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6734d41851e3e8e6c6cbda317484954f124d2cf8" translate="yes" xml:space="preserve">
          <source>Storing the schema as text also makes the &lt;a href=&quot;fileformat2&quot;&gt;SQLite database file format&lt;/a&gt; easier to define, document, and understand. This helps make SQLite database files a &lt;a href=&quot;locrsf&quot;&gt;recommended storage format&lt;/a&gt; for long-term archiving of data.</source>
          <target state="translated">스키마를 텍스트로 저장하면 &lt;a href=&quot;fileformat2&quot;&gt;SQLite 데이터베이스 파일 형식을&lt;/a&gt; 더 쉽게 정의하고 문서화하고 이해할 수 있습니다. 이는 SQLite 데이터베이스 파일 을 데이터의 장기 보관에 &lt;a href=&quot;locrsf&quot;&gt;권장되는 저장 형식으로&lt;/a&gt; 만드는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="9347ad87d0fbebdfc89e77280c0ab0e8462e84d1" translate="yes" xml:space="preserve">
          <source>Storing the schema as text rather than as parsed tables also give flexibility to the implementation. Since the internal parse of the schema is regenerated each time the database is opened, the internal representation of the schema can change from one release to the next. This is important, as sometimes new features require enhancements to the internal schema representation. Changing the internal schema representation would be much more difficult if the schema representation was exposed in the database file. So, in other words, storing the schema as text helps maintain backwards compatibility, and helps ensure that older database files can be read and written by newer versions of SQLite.</source>
          <target state="translated">구문 분석 된 테이블이 아닌 텍스트로 스키마를 저장하면 구현에 유연성이 제공됩니다. 데이터베이스를 열 때마다 스키마의 내부 구문 분석이 재생성되므로 스키마의 내부 표현이 릴리스마다 다를 수 있습니다. 때로는 새로운 기능이 내부 스키마 표현을 향상시켜야하기 때문에 중요합니다. 스키마 표현이 데이터베이스 파일에 노출 된 경우 내부 스키마 표현을 변경하는 것이 훨씬 더 어려울 것입니다. 즉, 스키마를 텍스트로 저장하면 이전 버전과의 호환성을 유지하고 최신 버전의 SQLite에서 오래된 데이터베이스 파일을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="275b8884950b47fafacc5239216411e5afbdc454" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions</source>
          <target state="translated">스트리밍 버전의 API 함수</target>
        </trans-unit>
        <trans-unit id="1cda8a5c429d321cd55319d79be9050795d95668" translate="yes" xml:space="preserve">
          <source>Streaming Versions of API functions.</source>
          <target state="translated">API 버전의 스트리밍 버전.</target>
        </trans-unit>
        <trans-unit id="41b71513a74ee80684014356a0159868598a4ea7" translate="yes" xml:space="preserve">
          <source>Streaming function</source>
          <target state="translated">스트리밍 기능</target>
        </trans-unit>
        <trans-unit id="c76c18624ee750ab230cd2529398af4c90203056" translate="yes" xml:space="preserve">
          <source>Strengthen defenses against deliberately corrupted database files.</source>
          <target state="translated">고의로 손상된 데이터베이스 파일에 대한 방어 강화</target>
        </trans-unit>
        <trans-unit id="70d422bf6680eb42d320cae6dd4ad922e3705a6b" translate="yes" xml:space="preserve">
          <source>Strictly speaking, the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is not required since the convenience wrapper interfaces, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; or &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table&lt;/a&gt;, can be used and these convenience wrappers encapsulate and hide the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object. Nevertheless, an understanding of &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; is needed to make full use of SQLite.</source>
          <target state="translated">엄밀히 말해서, &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문의&lt;/a&gt; 인터페이스, 래퍼 편리 성 때문에 개체가 필요하지 않습니다 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free_table&quot;&gt;sqlite3_get_table가&lt;/a&gt; , 사용할 수 있으며, 이러한 편의 래퍼는 캡슐화와 숨길 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비 문&lt;/a&gt; 개체를. 그럼에도 불구하고 SQLite를 최대한 활용하려면 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 이해 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="f631842398197770725f42465ce9be3bb217fe7f" translate="yes" xml:space="preserve">
          <source>String Comparison</source>
          <target state="translated">문자열 비교</target>
        </trans-unit>
        <trans-unit id="bca91d4c03b6524119c1475d05b8b5503e052ba2" translate="yes" xml:space="preserve">
          <source>String Globbing</source>
          <target state="translated">끈 글 로빙</target>
        </trans-unit>
        <trans-unit id="d8c2dabd43b3a0fa081659375ff18075de8cb9f3" translate="yes" xml:space="preserve">
          <source>String LIKE Matching</source>
          <target state="translated">일치하는 문자열</target>
        </trans-unit>
        <trans-unit id="dfab1bcbfa804d1a74a7282da9ab4ff5c5353c70" translate="yes" xml:space="preserve">
          <source>String8</source>
          <target state="translated">String8</target>
        </trans-unit>
        <trans-unit id="add2080ddbdcd32891495b46eb567565fc93baa2" translate="yes" xml:space="preserve">
          <source>Strings returned by sqlite3_column_text() and sqlite3_column_text16(), even empty strings, are always zero-terminated. The return value from sqlite3_column_blob() for a zero-length BLOB is a NULL pointer.</source>
          <target state="translated">sqlite3_column_text () 및 sqlite3_column_text16 ()에 의해 반환 된 문자열은 빈 문자열 일지라도 항상 0으로 종료됩니다. 길이가 0 인 BLOB에 대한 sqlite3_column_blob ()의 반환 값은 NULL 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="109fcef442d10303df5f7d59d40936a03977dfcb" translate="yes" xml:space="preserve">
          <source>Strings that include any other characters must be quoted. Characters that are not currently allowed in barewords, are not quote characters and do not currently serve any special purpose in FTS5 query expressions may at some point in the future be allowed in barewords or used to implement new query functionality. This means that queries that are currently syntax errors because they include such a character outside of a quoted string may be interpreted differently by some future version of FTS5.</source>
          <target state="translated">다른 문자를 포함하는 문자열은 따옴표로 묶어야합니다. 현재 베어 워드에서 허용되지 않고 따옴표 문자가 아니며 현재 FTS5 쿼리에서 특수한 용도로 사용되지 않는 문자는 나중에 언젠가 베어 워드에서 허용되거나 새로운 쿼리 기능을 구현하는 데 사용될 수 있습니다. 즉, 현재 구문 오류 인 쿼리에는 따옴표로 묶인 문자열 외부에 그러한 문자가 포함되어 있기 때문에 이후 버전의 FTS5에서는 다르게 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b6945b8df636a6d934a512accf12a8b76fc6265" translate="yes" xml:space="preserve">
          <source>Studies show that many applications already use SQLite as a container object. For example, &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; (no relation to the &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite developer&lt;/a&gt;) reports that 14% of Android applications never write to their SQLite databases. It is believed that these applications are downloading entire databases from the cloud and then using the information locally as needed. In other words, the applications are using SQLite not so much as a database but as a queryable wire-transfer format.</source>
          <target state="translated">연구에 따르면 많은 응용 프로그램에서 이미 SQLite를 컨테이너 개체로 사용하고 있습니다. 예를 들어 &lt;a href=&quot;https://odin.cse.buffalo.edu/papers/2015/TPCTC-sqlite-final.pdf&quot;&gt;Kennedy&lt;/a&gt; ( &lt;a href=&quot;https://sqlite.org/crew.html#dan&quot;&gt;SQLite 개발자&lt;/a&gt; 와 무관 )는 Android 애플리케이션의 14 %가 SQLite 데이터베이스에 쓰지 않는다고보고합니다. 이러한 응용 프로그램은 클라우드에서 전체 데이터베이스를 다운로드 한 다음 필요에 따라 로컬로 정보를 사용하는 것으로 생각됩니다. 다시 말해, 응용 프로그램은 SQLite를 데이터베이스가 아니라 쿼리 가능한 전신 전송 형식으로 사용하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd17ca7716d1959474368eb0c63e1ad9ad957be" translate="yes" xml:space="preserve">
          <source>Subqueries</source>
          <target state="translated">Subqueries</target>
        </trans-unit>
        <trans-unit id="9a235eb288a64671965312f5d0ad9f1b72cd84b6" translate="yes" xml:space="preserve">
          <source>Subqueries might also need to be materialized when they appear in the FROM clause of a SELECT statement. For example:</source>
          <target state="translated">서브 쿼리가 SELECT 문의 FROM 절에 나타날 때 서브 쿼리를 구체화해야 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79095639cf2544d3073712b3f47816fbf8b20418" translate="yes" xml:space="preserve">
          <source>Subquery Expressions</source>
          <target state="translated">하위 쿼리 표현식</target>
        </trans-unit>
        <trans-unit id="14de4f03d3cdec3c98a5016002bc81eb0292385c" translate="yes" xml:space="preserve">
          <source>Subquery co-routines</source>
          <target state="translated">서브 쿼리 공동 루틴</target>
        </trans-unit>
        <trans-unit id="1d0025e26a750eaf886e5b666d451246677ab333" translate="yes" xml:space="preserve">
          <source>Substitution Type</source>
          <target state="translated">대체 유형</target>
        </trans-unit>
        <trans-unit id="ae5f61e523ef194692c08eae320b323a03f8bb9b" translate="yes" xml:space="preserve">
          <source>Subtract</source>
          <target state="translated">Subtract</target>
        </trans-unit>
        <trans-unit id="b2b6c0ca0db2f38dd797d319d2f786a2af93e034" translate="yes" xml:space="preserve">
          <source>Subtract 200 from X.</source>
          <target state="translated">X에서 200을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="351c38b73ce6b309921bfd5c87f12ea777d4a4ac" translate="yes" xml:space="preserve">
          <source>Subtract the value in register P1 from the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P2의 값에서 레지스터 P1의 값을 빼고 결과를 레지스터 P3에 저장합니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="b3ad01aa557050dded853fc788b3484598298d39" translate="yes" xml:space="preserve">
          <source>Such a line of C code might generate a dozen separate machine code instructions. If any one of those instructions is ever evaluated, then we say that the statement has been tested. So, for example, it might be the case that the conditional expression is always false and the &quot;d&quot; variable is never incremented. Even so, statement coverage counts this line of code as having been tested.</source>
          <target state="translated">이러한 C 코드 줄은 12 개의 개별 기계 코드 명령어를 생성 할 수 있습니다. 이러한 지침 중 하나라도 평가되면 해당 진술이 테스트되었다고합니다. 예를 들어, 조건식이 항상 false이고 &quot;d&quot;변수가 증가하지 않는 경우가 있습니다. 그럼에도 불구하고, 진술 범위는이 코드 라인을 테스트 된 것으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="a042ce9ca13e4d4ddb750a0fe77ea337b1cdceb1" translate="yes" xml:space="preserve">
          <source>Such a virtual table has the same columns as the table-valued function described in the previous section. It may be read from using a SELECT statement in the same way as the table-valued function can.</source>
          <target state="translated">이러한 가상 테이블에는 이전 섹션에서 설명한 테이블 반환 함수와 동일한 열이 있습니다. 테이블 반환 함수와 동일한 방식으로 SELECT 문을 사용하여 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da045363c8fb916c7bdb60bedab8cb85e2f1f5a1" translate="yes" xml:space="preserve">
          <source>Such advanced searches are requested by providing a more complicated FTS5 query string as the text to the right of the MATCH operator (or = operator, or as the first argument to a table-valued function syntax). The full query syntax is &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;described here&lt;/a&gt;.</source>
          <target state="translated">이러한 고급 검색은 MATCH 연산자의 오른쪽에있는 텍스트 (또는 = 연산자 또는 테이블 반환 함수 구문의 첫 번째 인수)로 더 복잡한 FTS5 쿼리 문자열을 제공하여 요청됩니다. 전체 쿼리 구문은 &lt;a href=&quot;fts5#full_text_query_syntax&quot;&gt;여기&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0936ee6227b30512f2222702e2254d11d72a242" translate="yes" xml:space="preserve">
          <source>Such criticism would be well-founded for a traditional client/server database engine, such as MySQL, PostgreSQL, or SQL Server. In a client/server database, each SQL statement requires a message round-trip from the application to the database server and back to the application. Doing over 200 round-trip messages, sequentially, can be a serious performance drag. This is sometimes called the &quot;N+1 Query Problem&quot; or the &quot;N+1 Select Problem&quot; and it is an anti-pattern.</source>
          <target state="translated">이러한 비판은 MySQL, PostgreSQL 또는 SQL Server와 같은 전통적인 클라이언트 / 서버 데이터베이스 엔진에 대해 잘 알려져 있습니다. 클라이언트 / 서버 데이터베이스에서 각 SQL 문은 응용 프로그램에서 데이터베이스 서버로, 응용 프로그램으로 다시 왕복하는 메시지가 필요합니다. 200 회 이상의 왕복 메시지를 순차적으로 수행하면 성능이 크게 저하 될 수 있습니다. 이를 &quot;N + 1 쿼리 문제&quot;또는 &quot;N + 1 선택 문제&quot;라고도하며 안티 패턴입니다.</target>
        </trans-unit>
        <trans-unit id="f834acdfa0c7dab757f2bc4e26b1966eff963a52" translate="yes" xml:space="preserve">
          <source>Suggested Uses For SQLite:</source>
          <target state="translated">SQLite의 권장 사용법 :</target>
        </trans-unit>
        <trans-unit id="f08f43d3c61d6c426d33128ee0c38e51fb6aad20" translate="yes" xml:space="preserve">
          <source>Suggested compile-time options include:</source>
          <target state="translated">제안 된 컴파일 타임 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d1a384ea1042be63f3032ea726e70fc4a04f311" translate="yes" xml:space="preserve">
          <source>Suggests completions for partially-entered words during interactive SQL input. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to help implement tab-completion.</source>
          <target state="translated">대화식 SQL 입력 중에 부분적으로 입력 된 단어의 완성을 제안합니다. 탭 완성을 구현하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="adca4d21f8bf7900f73ede68196274afd881f1d7" translate="yes" xml:space="preserve">
          <source>Sum() will throw an &quot;integer overflow&quot; exception if all inputs are integers or NULL and an integer overflow occurs at any point during the computation. Total() never throws an integer overflow.</source>
          <target state="translated">Sum ()은 모든 입력이 정수이거나 NULL이고 계산 중 어느 시점에서나 정수 오버플로가 발생하면 &quot;정수 오버플로&quot;예외를 발생시킵니다. Total ()은 정수 오버플로를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="1a7bd9ebcad37a0dd711dfc793fa96bb5022047c" translate="yes" xml:space="preserve">
          <source>Summary of Technical Differences</source>
          <target state="translated">기술적 차이점 요약</target>
        </trans-unit>
        <trans-unit id="4c599c4f8f2ffb798c4263cf7f6e473784c4d396" translate="yes" xml:space="preserve">
          <source>Super-journals</source>
          <target state="translated">Super-journals</target>
        </trans-unit>
        <trans-unit id="ab2e3b9850b401306a39a3a804f43e7d4f55c01f" translate="yes" xml:space="preserve">
          <source>Support for &quot;:AAA&quot; style bind parameter names.</source>
          <target state="translated">&quot;: AAA&quot;스타일 바인드 매개 변수 이름 지원.</target>
        </trans-unit>
        <trans-unit id="8b45bd25a3b604a0eccba69e7087834ecb582853" translate="yes" xml:space="preserve">
          <source>Support for &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM&lt;/a&gt; following the PostgreSQL syntax.</source>
          <target state="translated">PostgreSQL 구문에 따라 &lt;a href=&quot;lang_update#upfrom&quot;&gt;UPDATE FROM을&lt;/a&gt; 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="e333e85b28ab7b57a0a5c9131f54f806015a6221" translate="yes" xml:space="preserve">
          <source>Support for ALTER TABLE ... RENAME TABLE ... added</source>
          <target state="translated">ALTER TABLE ... RENAME TABLE ...에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="3251d36ace39f64a5ddca9143a5668b65028289f" translate="yes" xml:space="preserve">
          <source>Support for TCL variable names embedded in SQL statements in the TCL bindings.</source>
          <target state="translated">TCL 바인딩에서 SQL 문에 임베드 된 TCL 변수 이름 지원</target>
        </trans-unit>
        <trans-unit id="4c4e649b2faf6e7dd28f3f288044f754a9767c05" translate="yes" xml:space="preserve">
          <source>Support for UTF-16.</source>
          <target state="translated">UTF-16을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="49ef276ba874be88caa55a5b3e4a37db519f9394" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and ISO8859 characters in column and table names.</source>
          <target state="translated">열 및 테이블 이름에서 UTF-8 및 ISO8859 문자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="78dc81c2a8faafa4c84493782b19c441e17956a6" translate="yes" xml:space="preserve">
          <source>Support for UTF-8 and UTF-16</source>
          <target state="translated">UTF-8 및 UTF-16 지원</target>
        </trans-unit>
        <trans-unit id="1e1164bc2160d30de5ee08ec06fc2a323f2028fc" translate="yes" xml:space="preserve">
          <source>Support for both UTF-8 and UTF-16 text.</source>
          <target state="translated">UTF-8 및 UTF-16 텍스트를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bf37e2ec021b62a6c46ffa2eb125d86eb07ffbc5" translate="yes" xml:space="preserve">
          <source>Support for correlated subqueries added.</source>
          <target state="translated">상관 하위 쿼리에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ec9173b8e288c70be66cdbfa81d0ba7ad6705c9c" translate="yes" xml:space="preserve">
          <source>Support for full text search using the FTS1 module (beta)</source>
          <target state="translated">FTS1 모듈 (베타)을 사용한 전체 텍스트 검색 지원</target>
        </trans-unit>
        <trans-unit id="09344ff56160150e5ec18eb5a71ba2f29a6312fc" translate="yes" xml:space="preserve">
          <source>Support for internationalization including UTF-8, UTF-16, and user defined collating sequences.</source>
          <target state="translated">UTF-8, UTF-16 및 사용자 정의 배열 순서를 포함한 국제화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="091e86f3d19a27b9089ddce8c418dcc49fd9c304" translate="yes" xml:space="preserve">
          <source>Support for non-ASCII characters in win95 filenames</source>
          <target state="translated">win95 파일 이름에서 비 ASCII 문자 지원</target>
        </trans-unit>
        <trans-unit id="cfddf0106ec96c94ef54d4e7b75188870573ef30" translate="yes" xml:space="preserve">
          <source>Support for the EXISTS clause added.</source>
          <target state="translated">EXISTS 절에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="21d1badc676c125ad5e671e3ae8383a4753e9f6c" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">컴파일시 &lt;a href=&quot;../compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; 옵션을 지정하여 sqlite3_compileoption_used () 및 sqlite3_compileoption_get () 진단 ​​기능에 대한 지원을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceaebbe4250e5e44fc85c0a7be72215c2fc6b3df" translate="yes" xml:space="preserve">
          <source>Support for the diagnostic functions sqlite3_compileoption_used() and sqlite3_compileoption_get() may be omitted by specifying the &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; option at compile time.</source>
          <target state="translated">컴파일시 &lt;a href=&quot;compile#omit_compileoption_diags&quot;&gt;SQLITE_OMIT_COMPILEOPTION_DIAGS&lt;/a&gt; 옵션을 지정하여 sqlite3_compileoption_used () 및 sqlite3_compileoption_get () 진단 ​​기능에 대한 지원을 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e227243100baec383101a5e3e5550db71fb48de1" translate="yes" xml:space="preserve">
          <source>Support operators IS TRUE, IS FALSE, IS NOT TRUE, and IS NOT FALSE.</source>
          <target state="translated">지원 연산자는 참, 거짓, 거짓이 아니며 거짓이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="8b76c3512f29a884a102a942cd3b81fe8d384ace" translate="yes" xml:space="preserve">
          <source>Supported unary prefix operators are these:</source>
          <target state="translated">지원되는 단항 접두사 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14453b6f0216ab7b03129623da62580288e5db4c" translate="yes" xml:space="preserve">
          <source>Supports terabyte-sized databases and gigabyte-sized strings and blobs. (See &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt;.)</source>
          <target state="translated">테라 바이트 크기의 데이터베이스와 기가 바이트 크기의 문자열 및 Blob을 지원합니다. ( &lt;a href=&quot;limits&quot;&gt;limits.html&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="f2a1709933364d69e93326e81a6775d317d15202" translate="yes" xml:space="preserve">
          <source>Suppose N=4. Then for the TPC-H Q8 graph, the first step finds the four shortest paths to visit any single node in the graph:</source>
          <target state="translated">N = 4라고 가정하자. 그런 다음 TPC-H Q8 그래프의 경우 첫 번째 단계는 그래프에서 단일 노드를 방문하는 가장 짧은 4 개의 경로를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="61fbb5bff735b0969304e1938310f741780fb8bb" translate="yes" xml:space="preserve">
          <source>Suppose SQLite is used as the &lt;a href=&quot;appfileformat&quot;&gt;application file format&lt;/a&gt; for a particular design application. Two users, Alice and Bob, each start with a baseline design that is about a gigabyte in size. They work all day, in parallel, each making their own customizations and tweaks to the design. At the end of the day, they would like to merge their changes together into a single unified design.</source>
          <target state="translated">SQLite가 특정 디자인 응용 프로그램 의 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용되었다고 가정 합니다. 두 명의 사용자 인 Alice와 Bob은 각각 기가 바이트 크기의 기본 디자인으로 시작합니다. 그들은 하루 종일 동시에 작동하며 각각 자체적으로 사용자 정의하고 디자인을 조정합니다. 하루가 끝나면 변경 사항을 하나의 통합 된 디자인으로 병합하려고합니다.</target>
        </trans-unit>
        <trans-unit id="ef94f961eb3bb04314c719aa5da9edd146e885d3" translate="yes" xml:space="preserve">
          <source>Suppose an application wants to display a list of contacts in alphabetical order by lastname, firstname, in a scrolling window that can only show 7 contacts at a time. Initialize the scrolling window to the first 7 entries is easy:</source>
          <target state="translated">애플리케이션이 한 번에 7 개의 연락처 만 표시 할 수있는 스크롤 창에서 성을 기준으로 알파벳순으로 연락처 목록을 표시하려고한다고 가정하십시오. 스크롤 창을 처음 7 개 항목으로 초기화하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="56904d3ea47369b0068186e8a39203c8a5f870c3" translate="yes" xml:space="preserve">
          <source>Suppose each entry in the BIG table is a JSON object with a '$.id' field that is a unique identifier and a '$.partlist' field that can be a deeply nested object. You want to find the id of every entry that contains one or more references to uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808' anywhere in its '$.partlist'.</source>
          <target state="translated">BIG 테이블의 각 항목이 고유 식별자 인 '$ .id'필드와 깊이 중첩 된 오브젝트 일 수있는 '$ .partlist'필드가있는 JSON 오브젝트라고 가정하십시오. uuid '6fa5181e-5721-11e5-a04e-57f3d7b32808'에 대한 하나 이상의 참조가 포함 된 모든 항목의 ID를 '$ .partlist'의 어디에서나 찾으려고합니다.</target>
        </trans-unit>
        <trans-unit id="01636cb9299568d887d10674105e44b34b08d5bf" translate="yes" xml:space="preserve">
          <source>Suppose that after a while (about a month, usually) a new version of SQLite is released: 3.6.16. You will want to incorporate this new public version of SQLite into your repository in the public branch (the trunk). To do this, first change your repository over to the trunk:</source>
          <target state="translated">잠시 후 (일반적으로 약 한 달) 새 버전의 SQLite가 3.6.16으로 릴리스되었다고 가정하십시오. 이 새로운 공용 버전의 SQLite를 공용 분기 (트렁크)의 저장소에 통합하려고합니다. 이렇게하려면 먼저 저장소를 트렁크로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="cede4c6f59f784278daddf56ee62d38bbe080c9a" translate="yes" xml:space="preserve">
          <source>Suppose that in addition to the index on &quot;fruit&quot; there was also an index on &quot;state&quot;.</source>
          <target state="translated">&quot;fruit&quot;에 대한 인덱스 외에 &quot;state&quot;에 대한 인덱스도 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="66f9ffa5f1e3c7efa56791a73580d03426c293ab" translate="yes" xml:space="preserve">
          <source>Suppose the &lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; file format, and specifically the &quot;ODP&quot; OpenDocument Presentation format, were built around SQLite. Benefits would include:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/OpenDocument&quot;&gt;OpenDocument&lt;/a&gt; 파일 형식, 특히 &quot;ODP&quot;OpenDocument 프레젠테이션 형식이 SQLite를 중심으로 구축되었다고 가정합니다 . 이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a6796b2c9a16b027d38641aa802a501818a470f" translate="yes" xml:space="preserve">
          <source>Suppose the SQLite source tree is stored in a directory named &quot;sqlite&quot;. Plan to construct the amalgamation in a parallel directory named (for example) &quot;bld&quot;. First construct an appropriate Makefile by either running the configure script at the top of the SQLite source tree, or by making a copy of one of the template Makefiles at the top of the source tree. Then hand edit this Makefile to include the desired compile-time options. Finally run:</source>
          <target state="translated">SQLite 소스 트리가 &quot;sqlite&quot;라는 디렉토리에 저장되었다고 가정하십시오. 이름이 &quot;bld&quot;인 병렬 디렉토리에 통합을 계획하십시오. 먼저 SQLite 소스 트리 맨 위에서 configure 스크립트를 실행하거나 소스 트리 맨 위에 Makefile 템플리트 중 하나의 사본을 작성하여 적절한 Makefile을 구성하십시오. 그런 다음 원하는 Make-time 옵션을 포함하도록이 Makefile을 수동으로 편집하십시오. 마지막으로 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="3af5f7045e9a9cbdbcc9c95551ce4e94ea5602be" translate="yes" xml:space="preserve">
          <source>Suppose the demo_data.boundary field holds some proprietary data description of a complex two-dimensional boundary for an object and suppose that the application has used the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface to created application-defined functions &quot;contained_in&quot; and &quot;overlaps&quot; accepting two demo_data.boundary objects and return true or false. One may assume that &quot;contained_in&quot; and &quot;overlaps&quot; are relatively slow functions that we do not want to invoke too frequently. Then an efficient way to find the name of all objects located within the North Carolina 12th District, one may be to run a query like this:</source>
          <target state="translated">demo_data.boundary 필드에 객체의 복잡한 2 차원 경계에 대한 독점 데이터 설명이 있다고 가정하고 애플리케이션이 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 인터페이스를 사용하여 두 개의 demo_data를 허용하는 &quot;contained_in&quot;및 &quot;overlaps&quot;애플리케이션 정의 함수를 작성했다고 가정하십시오. 경계 객체를 반환하고 true 또는 false를 반환합니다. &quot;contained_in&quot;과 &quot;overlaps&quot;는 우리가 너무 자주 호출하고 싶지 않은 비교적 느린 함수라고 가정 할 수 있습니다. 그런 다음 North Carolina 12th District에 위치한 모든 개체의 이름을 찾는 효율적인 방법은 다음과 같은 쿼리를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="be9cbf4654b2bfbdcf1b2bf833bfb8cf7cccef29" translate="yes" xml:space="preserve">
          <source>Suppose the initial sequence of non-wildcard characters on the right-hand side of the LIKE or GLOB operator is</source>
          <target state="translated">LIKE 또는 GLOB 연산자의 오른쪽에 와일드 카드가 아닌 문자의 초기 순서가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="15341cf73e257c233d78d57ae1e295622b133b68" translate="yes" xml:space="preserve">
          <source>Suppose the power loss occurred during &lt;a href=&quot;#section_3_10&quot;&gt;step 3.10&lt;/a&gt; above, while the database changes were being written to disk. After power is restored, the situation might be something like what is shown to the right. We were trying to change three pages of the database file but only one page was successfully written. Another page was partially written and a third page was not written at all.</source>
          <target state="translated">데이터베이스 변경 사항이 디스크에 기록되는 동안 위의 &lt;a href=&quot;#section_3_10&quot;&gt;3.10 단계&lt;/a&gt; 에서 전원 손실이 발생했다고 가정하십시오 . 전원이 복구 된 후 상황은 오른쪽에 표시된 것과 같은 것일 수 있습니다. 데이터베이스 파일의 세 페이지를 변경하려고했으나 한 페이지 만 성공적으로 작성되었습니다. 다른 페이지는 부분적으로 작성되었고 세 번째 페이지는 전혀 작성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="502f7a3363de6f918e427baeeb23c0fbeb554eda" translate="yes" xml:space="preserve">
          <source>Suppose the table &quot;CREATE TABLE user(name,phone)&quot; stores zero or more phone numbers as a JSON array object in the user.phone field. To find all users who have any phone number with a 704 area code:</source>
          <target state="translated">&quot;CREATE TABLE user (name, phone)&quot;테이블이 0 개 이상의 전화 번호를 user.phone 필드에 JSON 배열 오브젝트로 저장한다고 가정하십시오. 지역 번호가 704 인 전화 번호를 가진 모든 사용자를 찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d5297ab1e192fe178acfe6ab94a19f582b117e15" translate="yes" xml:space="preserve">
          <source>Suppose the term that is being spell-corrected is X. To limit the search space, X is converted to a k2-like key using the equivalent of:</source>
          <target state="translated">철자가 수정되는 용어가 X라고 가정합니다. 검색 공간을 제한하기 위해 X는 다음과 같은 것을 사용하여 k2와 같은 키로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b244116e469acf86fbb0e19b53f1d8598b689446" translate="yes" xml:space="preserve">
          <source>Suppose there is a site hosting a database in state S0. And that modifications are made that move that database to state S1 and a changeset recorded (the &quot;local&quot; changeset). Then, a changeset based on S0 is received from another site (the &quot;remote&quot; changeset) and applied to the database. The database is then in state (S1+&quot;remote&quot;), where the exact state depends on any conflict resolution decisions (OMIT or REPLACE) made while applying &quot;remote&quot;. Rebasing a changeset is to update it to take those conflict resolution decisions into account, so that the same conflicts do not have to be resolved elsewhere in the network.</source>
          <target state="translated">상태 S0에 데이터베이스를 호스팅하는 사이트가 있다고 가정하십시오. 그리고 데이터베이스를 상태 S1로 옮기고 변경 세트 ( &quot;로컬&quot;변경 세트)를 기록하도록 수정되었습니다. 그런 다음 S0을 기반으로하는 변경 집합이 다른 사이트 ( &quot;원격&quot;변경 집합)에서 수신되어 데이터베이스에 적용됩니다. 그런 다음 데이터베이스는 상태 (S1 + &quot;원격&quot;)에 있으며, 여기서 정확한 상태는 &quot;원격&quot;을 적용하는 동안 작성된 충돌 해결 결정 (OMIT 또는 REPLACE)에 따라 다릅니다. 변경 세트를 리베이스하는 것은 이러한 충돌 해결 결정을 고려하여 네트워크의 다른 곳에서 동일한 충돌을 해결할 필요가 없도록 업데이트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ead91310400eb3c0d2b88fd20fde2e0225bdf31" translate="yes" xml:space="preserve">
          <source>Suppose we have a table X1 defined as follows:</source>
          <target state="translated">다음과 같이 정의 된 테이블 X1이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="538e32b0b37a9243b789f735088e6724ac330912" translate="yes" xml:space="preserve">
          <source>Suppose we want to find the prices of all kinds of oranges sorted in order of the state where they are grown. The query is this:</source>
          <target state="translated">모든 종류의 오렌지 가격이 자란 상태로 정렬되어 있다고 가정 해 봅시다. 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="064cebf29367ccdae2597fb8c1cb7630379e90ac" translate="yes" xml:space="preserve">
          <source>Suppose we want to know the order number, product number, and quantity for any item in which the product number and quantity match the product number and quantity of any item in order number 365:</source>
          <target state="translated">제품 번호 및 수량이 주문 번호 365의 품목 번호 및 수량과 일치하는 품목의 주문 번호, 제품 번호 및 수량을 알고 싶다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="465043a8fd6b7a4a4148ce99421e90822984188c" translate="yes" xml:space="preserve">
          <source>Suppose you want to look up the price of peaches. The query would be as follows:</source>
          <target state="translated">복숭아의 가격을 찾고 싶다고 가정 해보십시오. 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5cde9a11c3caa7425e0b0c2c0bc60b2a242f9c61" translate="yes" xml:space="preserve">
          <source>Surprisingly, using SQLite in place of ZIP makes the presentation file smaller. Really. One would think that a relational database file would be larger than a ZIP archive, but at least in the case of NeoOffice that is not so. The following is an actual screen-scrape showing the sizes of the same NeoOffice presentation, both in its original ZIP archive format as generated by NeoOffice (self2014.odp), and as repacked as an SQLite database using the &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; utility:</source>
          <target state="translated">놀랍게도 ZIP 대신 SQLite를 사용하면 프리젠 테이션 파일이 더 작아집니다. 정말. 관계형 데이터베이스 파일은 ZIP 아카이브보다 크지 만 최소한 NeoOffice의 경우에는 그렇지 않습니다. 다음은 NeoOffice에서 생성 한 원본 ZIP 아카이브 형식 (self2014.odp)과 &lt;a href=&quot;http://www.sqlite.org/sqlar/doc/trunk/README.md&quot;&gt;SQLAR&lt;/a&gt; 유틸리티를 사용하여 SQLite 데이터베이스로 다시 압축 한 동일한 NeoOffice 프리젠 테이션의 크기를 보여주는 실제 화면 스크랩입니다 .</target>
        </trans-unit>
        <trans-unit id="055c319b3692b1bab785599b3ba80b0068542bb5" translate="yes" xml:space="preserve">
          <source>Suspend Execution For A Short Time</source>
          <target state="translated">짧은 시간 동안 실행 일시 중단</target>
        </trans-unit>
        <trans-unit id="7bdfc376d6f876239b6de7abf665805218ef476e" translate="yes" xml:space="preserve">
          <source>Swap the program counter with the value in register P1. This has the effect of yielding to a coroutine.</source>
          <target state="translated">프로그램 카운터를 레지스터 P1의 값으로 교체하십시오. 이것은 코 루틴에 항복하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cb264ae88f7fbec3546350312b9af582b1fc481" translate="yes" xml:space="preserve">
          <source>Swapping journal files between two different databases.</source>
          <target state="translated">서로 다른 두 데이터베이스간에 저널 파일 교환</target>
        </trans-unit>
        <trans-unit id="e8485294b019aa85fdb1a929771cba23d5593c45" translate="yes" xml:space="preserve">
          <source>Swarmvtab Virtual Table</source>
          <target state="translated">Swarmvtab 가상 테이블</target>
        </trans-unit>
        <trans-unit id="01d32f35e7401403e071bd64f5c3b26a4e4dc5be" translate="yes" xml:space="preserve">
          <source>Swarmvtab context</source>
          <target state="translated">Swarmvtab 컨텍스트</target>
        </trans-unit>
        <trans-unit id="875cb081d7d2e461450da0199489f1266311e3ff" translate="yes" xml:space="preserve">
          <source>Swarmvtab efficiently handles range and equality constraints on the rowid (or other INTEGER PRIMARY KEY) field only. If a query does not contain such a constraint, then swarmvtab finds the results by opening each database in turn and linearly scanning the component table. Which generates a correct result, but is often slow.</source>
          <target state="translated">Swarmvtab은 rowid (또는 다른 INTEGER PRIMARY KEY) 필드에서만 범위 및 동등 제한 조건을 효율적으로 처리합니다. 쿼리에 이러한 제약 조건이 포함되어 있지 않으면 swarmvtab은 각 데이터베이스를 차례로 열고 구성 요소 테이블을 선형으로 검색하여 결과를 찾습니다. 올바른 결과를 생성하지만 종종 느립니다.</target>
        </trans-unit>
        <trans-unit id="85aa4db2e47035bd4c2140f56e8799ea09c7ae90" translate="yes" xml:space="preserve">
          <source>Swarmvtab virtual tables must be created in the temp schema. Attempting to create a swarmvtab in the main or an attached database is an error.</source>
          <target state="translated">Swarmvtab 가상 테이블은 임시 스키마에서 작성해야합니다. 기본 또는 연결된 데이터베이스에서 swarmvtab을 작성하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0d92527f493460a8c4ce6ccbbd585c5ead2d11f" translate="yes" xml:space="preserve">
          <source>Synchronization Type Flags</source>
          <target state="translated">동기화 유형 플래그</target>
        </trans-unit>
        <trans-unit id="a7e6b31b20f1d4434bcadd521f6861e2f3378f97" translate="yes" xml:space="preserve">
          <source>Synchronous pragma</source>
          <target state="translated">동기식 프라 그마</target>
        </trans-unit>
        <trans-unit id="4ae6fa22bc9918cf39eb8d8cef197a88e78982e8" translate="yes" xml:space="preserve">
          <source>Syncing</source>
          <target state="translated">Syncing</target>
        </trans-unit>
        <trans-unit id="c66891a446af4f02e4055198cbfa371561a78fd4" translate="yes" xml:space="preserve">
          <source>Syncing the Journal File</source>
          <target state="translated">저널 파일 동기화</target>
        </trans-unit>
        <trans-unit id="17aba038fa3266b07efa450a91b91b1e792d66c5" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams</source>
          <target state="translated">구문 다이어그램</target>
        </trans-unit>
        <trans-unit id="33bbfae733b0f97c3ea72475efb5dfbb61ebe1e1" translate="yes" xml:space="preserve">
          <source>Syntax Diagrams For SQLite</source>
          <target state="translated">SQLite의 구문 다이어그램</target>
        </trans-unit>
        <trans-unit id="70a8fcc6fa01af0d580c320ddb0e42484905e68e" translate="yes" xml:space="preserve">
          <source>Syntax Restrictions On UPDATE, DELETE, and INSERT Statements Within Triggers</source>
          <target state="translated">트리거 내의 UPDATE, DELETE 및 INSERT 문에 대한 구문 제한</target>
        </trans-unit>
        <trans-unit id="34b408d97f8998a54cd64e9461c53dd4d1067b38" translate="yes" xml:space="preserve">
          <source>System Failure Related Assumptions</source>
          <target state="translated">시스템 장애 관련 가정</target>
        </trans-unit>
        <trans-unit id="ba2da263deb1258b36edfe6f11f1b761d86b8d6d" translate="yes" xml:space="preserve">
          <source>Systems designers report success using SQLite as a data store on server applications running in the datacenter, or in other words, using SQLite as the underlying storage engine for an application-specific database server.</source>
          <target state="translated">시스템 설계자는 데이터 센터에서 실행되는 서버 응용 프로그램에서 SQLite를 데이터 저장소로 사용하는 것으로, 즉 응용 프로그램 별 데이터베이스 서버의 기본 저장소 엔진으로 SQLite를 사용하여 성공을보고합니다.</target>
        </trans-unit>
        <trans-unit id="7244bff04e9f7001cbde5e129092d3ed31f1946c" translate="yes" xml:space="preserve">
          <source>Systems that run automatic backups in the background might try to make a backup copy of an SQLite database file while it is in the middle of a transaction. The backup copy then might contain some old and some new content, and thus be corrupt.</source>
          <target state="translated">백그라운드에서 자동 백업을 실행하는 시스템은 트랜잭션 도중에 SQLite 데이터베이스 파일의 백업 사본을 작성하려고 할 수 있습니다. 그런 다음 백업 사본에 오래된 내용과 일부 새로운 내용이 포함되어 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4394edb00669dc4429b903f672c10ae13c95e90" translate="yes" xml:space="preserve">
          <source>TABLE</source>
          <target state="translated">TABLE</target>
        </trans-unit>
        <trans-unit id="2ba83e39946a4ce4cedf8d25757aa5972284aa54" translate="yes" xml:space="preserve">
          <source>TABLENAME</source>
          <target state="translated">TABLENAME</target>
        </trans-unit>
        <trans-unit id="4ff4bacb6a130128f6603752138b57217ef9b6fa" translate="yes" xml:space="preserve">
          <source>TBD...</source>
          <target state="translated">TBD...</target>
        </trans-unit>
        <trans-unit id="e44916ac43724313d53ca25dbe2f20ee993ff6ec" translate="yes" xml:space="preserve">
          <source>TBD: More information about the header</source>
          <target state="translated">TBD : 헤더에 대한 추가 정보</target>
        </trans-unit>
        <trans-unit id="cdd060df603a64a7bee550bbc1c098580b231ab0" translate="yes" xml:space="preserve">
          <source>TCL interface authorizer method</source>
          <target state="translated">TCL 인터페이스 인증 자 방법</target>
        </trans-unit>
        <trans-unit id="aa517168bae4e2e388a6074b5a96fe2e5afc293f" translate="yes" xml:space="preserve">
          <source>TCL interface backup method</source>
          <target state="translated">TCL 인터페이스 백업 방법</target>
        </trans-unit>
        <trans-unit id="a29047291bb3d39d19d4b03699cb7f433f5736f2" translate="yes" xml:space="preserve">
          <source>TCL interface bind_fallback method</source>
          <target state="translated">TCL 인터페이스 bind_fallback 메소드</target>
        </trans-unit>
        <trans-unit id="1c5ad56544d8041c9b02f88d11a25782f14e4c9f" translate="yes" xml:space="preserve">
          <source>TCL interface busy method</source>
          <target state="translated">TCL 인터페이스 사용 방법</target>
        </trans-unit>
        <trans-unit id="6e4d989bf3b3b512cc61d500b0cb58cfc259ca59" translate="yes" xml:space="preserve">
          <source>TCL interface cache method</source>
          <target state="translated">TCL 인터페이스 캐시 방법</target>
        </trans-unit>
        <trans-unit id="f25b192d00bf0645e7eae602ec160016f797e6ac" translate="yes" xml:space="preserve">
          <source>TCL interface changes method</source>
          <target state="translated">TCL 인터페이스 변경 방법</target>
        </trans-unit>
        <trans-unit id="33f884ed1b8425d04cb3811d2ea16b66af480340" translate="yes" xml:space="preserve">
          <source>TCL interface close method</source>
          <target state="translated">TCL 인터페이스 닫기 방법</target>
        </trans-unit>
        <trans-unit id="96c5f46c7769b7e1d49b804ecba806907889a771" translate="yes" xml:space="preserve">
          <source>TCL interface collate method</source>
          <target state="translated">TCL 인터페이스 조합 방법</target>
        </trans-unit>
        <trans-unit id="2332befec61c50669cde60f3b1533591736f6a66" translate="yes" xml:space="preserve">
          <source>TCL interface collation_needed method</source>
          <target state="translated">TCL 인터페이스 collation_needed 메소드</target>
        </trans-unit>
        <trans-unit id="8cd4b4c1ed1732eb767f776cef0372d6c6cd1054" translate="yes" xml:space="preserve">
          <source>TCL interface commit_hook method</source>
          <target state="translated">TCL 인터페이스 commit_hook 메소드</target>
        </trans-unit>
        <trans-unit id="0157c2d923f1a0bec3d0245febd3f5035181a5aa" translate="yes" xml:space="preserve">
          <source>TCL interface complete method</source>
          <target state="translated">TCL 인터페이스 완료 방법</target>
        </trans-unit>
        <trans-unit id="c09e584a42654f26d29ff74df19ed9ca909905e4" translate="yes" xml:space="preserve">
          <source>TCL interface config method</source>
          <target state="translated">TCL 인터페이스 구성 방법</target>
        </trans-unit>
        <trans-unit id="b70df1b7dc237a292692ace288ac2eb93a3bcef2" translate="yes" xml:space="preserve">
          <source>TCL interface copy method</source>
          <target state="translated">TCL 인터페이스 복사 방법</target>
        </trans-unit>
        <trans-unit id="347f513a80d88ab334df317b8f83092d3ee26571" translate="yes" xml:space="preserve">
          <source>TCL interface deserialize method</source>
          <target state="translated">TCL 인터페이스 역 직렬화 방법</target>
        </trans-unit>
        <trans-unit id="0aa7225f1cfbaa7982110594b19739c6dbdfb9ac" translate="yes" xml:space="preserve">
          <source>TCL interface enable_load_extension method</source>
          <target state="translated">TCL 인터페이스 enable_load_extension 메소드</target>
        </trans-unit>
        <trans-unit id="64987beca677d7a4b95b820f3bed800e413b8cde" translate="yes" xml:space="preserve">
          <source>TCL interface errorcode method</source>
          <target state="translated">TCL 인터페이스 오류 코드 방법</target>
        </trans-unit>
        <trans-unit id="2189980d19fa911ed2ea4bb8d946cfdc55a53bc7" translate="yes" xml:space="preserve">
          <source>TCL interface eval method</source>
          <target state="translated">TCL 인터페이스 평가 방법</target>
        </trans-unit>
        <trans-unit id="f1bf6449a26eb7b025248f0b61a91066e3c39b49" translate="yes" xml:space="preserve">
          <source>TCL interface exists method</source>
          <target state="translated">TCL 인터페이스 존재 방법</target>
        </trans-unit>
        <trans-unit id="648b3c74c3afc3cad32dadd0965691c51538573c" translate="yes" xml:space="preserve">
          <source>TCL interface function method</source>
          <target state="translated">TCL 인터페이스 기능 방법</target>
        </trans-unit>
        <trans-unit id="4d842678586502cd1c46097c8ca3621079c38b98" translate="yes" xml:space="preserve">
          <source>TCL interface incrblob method</source>
          <target state="translated">TCL 인터페이스 incrblob 방법</target>
        </trans-unit>
        <trans-unit id="066821d02e0db49a10a7937ff6d8bc5c5b5055c7" translate="yes" xml:space="preserve">
          <source>TCL interface interrupt method</source>
          <target state="translated">TCL 인터페이스 인터럽트 방법</target>
        </trans-unit>
        <trans-unit id="f2e3158832088a3ccb54fc358c6461aace750451" translate="yes" xml:space="preserve">
          <source>TCL interface last_insert_rowid method</source>
          <target state="translated">TCL 인터페이스 last_insert_rowid 메소드</target>
        </trans-unit>
        <trans-unit id="50f8a5afc729daeaa27f3e057a6884d99bd7f622" translate="yes" xml:space="preserve">
          <source>TCL interface nullvalue method</source>
          <target state="translated">TCL 인터페이스 널값 방법</target>
        </trans-unit>
        <trans-unit id="e0711044ae2edb8698df1518d744c5b6309e1ba0" translate="yes" xml:space="preserve">
          <source>TCL interface onecolumn method</source>
          <target state="translated">TCL 인터페이스 onecolumn 방법</target>
        </trans-unit>
        <trans-unit id="7eb062b4a3cda7b5c21d07e42888d6f537605587" translate="yes" xml:space="preserve">
          <source>TCL interface profile method</source>
          <target state="translated">TCL 인터페이스 프로파일 방법</target>
        </trans-unit>
        <trans-unit id="4bd65df2fc14e08847cf659f886e3675b02fd603" translate="yes" xml:space="preserve">
          <source>TCL interface progress method</source>
          <target state="translated">TCL 인터페이스 진행 방법</target>
        </trans-unit>
        <trans-unit id="24560fa957755f945fd0a996100a7a50130fe691" translate="yes" xml:space="preserve">
          <source>TCL interface restore method</source>
          <target state="translated">TCL 인터페이스 복원 방법</target>
        </trans-unit>
        <trans-unit id="2c81f806023d5b1efa791fd568b8a71993cb3fc8" translate="yes" xml:space="preserve">
          <source>TCL interface rollback_hook method</source>
          <target state="translated">TCL 인터페이스 rollback_hook 메소드</target>
        </trans-unit>
        <trans-unit id="5d16200e0392f874424c9d693d564e213809df7d" translate="yes" xml:space="preserve">
          <source>TCL interface serialize method</source>
          <target state="translated">TCL 인터페이스 직렬화 방법</target>
        </trans-unit>
        <trans-unit id="8ad2308cc6d8c87dd4d39e3a54c207bf26684239" translate="yes" xml:space="preserve">
          <source>TCL interface status method</source>
          <target state="translated">TCL 인터페이스 상태 방법</target>
        </trans-unit>
        <trans-unit id="149cac088a8935337f35ceed17575a182fb384dd" translate="yes" xml:space="preserve">
          <source>TCL variable substitution</source>
          <target state="translated">TCL 변수 대체</target>
        </trans-unit>
        <trans-unit id="def1cac8277b55b62d6889e51352a77e3186587b" translate="yes" xml:space="preserve">
          <source>TEMP</source>
          <target state="translated">TEMP</target>
        </trans-unit>
        <trans-unit id="c02f25e228aca3bb6f42e48160b40dd55194b2cc" translate="yes" xml:space="preserve">
          <source>TEMP Triggers on Non-TEMP Tables</source>
          <target state="translated">비 TEMP 테이블에 대한 TEMP 트리거</target>
        </trans-unit>
        <trans-unit id="8d43ca29f9403615d1a5c8f0da40adcdae819802" translate="yes" xml:space="preserve">
          <source>TEMP databases</source>
          <target state="translated">TEMP 데이터베이스</target>
        </trans-unit>
        <trans-unit id="0c21d62a74809c85ca0475d94b6c298ee066de4e" translate="yes" xml:space="preserve">
          <source>TEMP tables and indices</source>
          <target state="translated">TEMP 테이블 및 인덱스</target>
        </trans-unit>
        <trans-unit id="df7db63622b3659c5ca6d357417169e72078f0bc" translate="yes" xml:space="preserve">
          <source>TEMP triggers on non-TEMP tables</source>
          <target state="translated">비 TEMP 테이블에 대한 TEMP 트리거</target>
        </trans-unit>
        <trans-unit id="2ec4186ff6dd054f66dc48342664cc916e7cee64" translate="yes" xml:space="preserve">
          <source>TEMPORARY</source>
          <target state="translated">TEMPORARY</target>
        </trans-unit>
        <trans-unit id="7d4e42ef9d04a046b5679f952cb0b6b5c498c73c" translate="yes" xml:space="preserve">
          <source>TEXT</source>
          <target state="translated">TEXT</target>
        </trans-unit>
        <trans-unit id="6e2d2a0b927ccbcb0059d0c7ba90d9609187d08f" translate="yes" xml:space="preserve">
          <source>TH3</source>
          <target state="translated">TH3</target>
        </trans-unit>
        <trans-unit id="f0b11e9a80109508da2e3cbd3b7a0a8827845799" translate="yes" xml:space="preserve">
          <source>TH3 achieves 100% branch test coverage (and 100% &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC/DC&lt;/a&gt;) over the SQLite core. (Test coverage of extensions such as FTS and RTREE is less than 100%).</source>
          <target state="translated">TH3는 SQLite 코어에서 100 % 분기 테스트 적용 범위 (및 100 % &lt;a href=&quot;https://en.wikipedia.org/wiki/Modified_condition/decision_coverage&quot;&gt;MC / DC&lt;/a&gt; )를 달성합니다. (FTS 및 RTREE와 같은 확장의 테스트 범위는 100 % 미만입니다).</target>
        </trans-unit>
        <trans-unit id="b39ec8bc0fe82988bb1da1f05fc2de8eb41887fa" translate="yes" xml:space="preserve">
          <source>TH3 checks SQLite's response to out-of-memory errors, disk I/O errors, and power loss during transaction commit.</source>
          <target state="translated">TH3는 메모리 부족 오류, 디스크 I / O 오류 및 트랜잭션 커밋 중 전원 손실에 대한 SQLite의 응답을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="055f71da54f782f8f65239fd4fb6b9c021760b69" translate="yes" xml:space="preserve">
          <source>TH3 comes with additional TCL scripts that help automate the testing process on workstations. The &quot;th3make&quot; script automatically runs &quot;mkth3.tcl&quot; and &quot;gcc&quot; and then runs the resulting test program and checks the results. Arguments to th3make include all of the &quot;*.test&quot; test modules and &quot;*.cfg&quot; configurations that are to be included in the test. Additional options to th3make can cause the test program to be compiled using different compilers (GCC, Clang, MSVC), to use different output verbosity levels, to run the test program under valgrind, to check the output for coverage using gcov, and so forth. The th3make script also accepts &quot;*.rc&quot; filenames as arguments. These *.rc files are just collections of other arguments that are commonly used together for a single purpose. For example, the &quot;quick.rc&quot; file contains a set of eight arguments to th3make that run a fast (3-minute) full-coverage test. This allows the operator to type &quot;./th3make quick.rc&quot; as a short-cut to typing out all of the required command-line options. The following are a few of the more than 40 available *.rc files:</source>
          <target state="translated">TH3에는 워크 스테이션에서 테스트 프로세스를 자동화하는 데 도움이되는 추가 TCL 스크립트가 제공됩니다. &quot;th3make&quot;스크립트는 &quot;mkth3.tcl&quot;및 &quot;gcc&quot;를 자동으로 실행 한 다음 결과 테스트 프로그램을 실행하고 결과를 확인합니다. th3make에 대한 인수에는 테스트에 포함될 모든 &quot;* .test&quot;테스트 모듈 및 &quot;* .cfg&quot;구성이 포함됩니다. th3make에 대한 추가 옵션은 다른 컴파일러 (GCC, Clang, MSVC)를 사용하여 테스트 프로그램을 컴파일하고, 다른 출력 상세 레벨을 사용하고, valgrind에서 테스트 프로그램을 실행하고, gcov를 사용하여 커버리지에 대한 출력을 확인하는 등의 작업을 수행 할 수 있습니다. . th3make 스크립트는 또한 &quot;* .rc&quot;파일 이름을 인수로 허용합니다. 이 * .rc 파일은 단일 목적으로 공통적으로 사용되는 다른 인수의 모음입니다. 예를 들어&quot;quick.rc&quot;파일에는 빠른 (3 분) 전체 범위 테스트를 실행하는 th3make에 대한 8 개의 인수 세트가 포함되어 있습니다. 이를 통해 작업자는 필요한 모든 명령 줄 옵션을 바로 입력 할 수있는 &quot;./th3make quick.rc&quot;를 바로 입력 할 수 있습니다. 다음은 사용 가능한 40 개가 넘는 * .rc 파일 중 일부입니다.</target>
        </trans-unit>
        <trans-unit id="a2a05ad4acef3c330bf37c9357e657e9ed2af845" translate="yes" xml:space="preserve">
          <source>TH3 exercises SQLite in a variety of run-time configurations (UTF8 vs UTF16, different pages sizes, varying journal modes, etc.)</source>
          <target state="translated">TH3는 다양한 런타임 구성 (UTF8 vs UTF16, 다른 페이지 크기, 다양한 저널 모드 등)에서 SQLite를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f8e21da8c02749a044b3aef819f8092fd00ef786" translate="yes" xml:space="preserve">
          <source>TH3 is a test program generator. The output of TH3 is a program implemented in C-code and intended to be linked against the SQLite library under test. The generated test program is compiled and run on the target platform in order to verify correct operation of SQLite on that platform.</source>
          <target state="translated">TH3은 테스트 프로그램 생성기입니다. TH3의 출력은 C 코드로 구현 된 프로그램이며 테스트중인 SQLite 라이브러리와 연결되도록 고안되었습니다. 생성 된 테스트 프로그램은 해당 플랫폼에서 SQLite가 올바르게 작동하는지 확인하기 위해 대상 플랫폼에서 컴파일 및 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="35be3734cb33090a9156032bab76a3246a8875be" translate="yes" xml:space="preserve">
          <source>TH3 is able to run on embedded platforms that lack the support infrastructure of workstations.</source>
          <target state="translated">TH3는 워크 스테이션의 지원 인프라가없는 임베디드 플랫폼에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="924274e45e00b2de29022bcd422e62f257c51552" translate="yes" xml:space="preserve">
          <source>TH3 originated from an effort to test SQLite on &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS&lt;/a&gt;. Prior to TH3, all SQLite tests were run using the &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; script language, but TCL would not (easily) compile on SymbianOS which made testing difficult. The first attempt to remedy this problem was the &quot;TH1&quot; (Test Harness #1) scripting language - a reimplementation of parts of the TCL language in a more portable form that would compile and run on SymbianOS, and that was sufficient to run the SQLite tests. TH1 did not survive as a standard testing tool for SQLite, but it did find continued service as a scripting language used to customize the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; version control system. There was also a &quot;Test Harness #2&quot; which was an attempt to create a simple scripting language using operator prefix notation to drive tests. TH3 was the third attempt.</source>
          <target state="translated">TH3는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Symbian&quot;&gt;SymbianOS에서&lt;/a&gt; SQLite를 테스트하려는 노력에서 비롯되었습니다 . TH3 이전에는 모든 SQLite 테스트가 &lt;a href=&quot;http://www.tcl.tk/&quot;&gt;TCL&lt;/a&gt; 스크립트 언어를 사용하여 실행 되었지만 TCL은 SymbianOS에서 (쉽게) 컴파일되지 않아 테스트가 어려웠습니다. 이 문제를 해결하기위한 첫 번째 시도는 &quot;TH1&quot;(Test Harness # 1) 스크립팅 언어였습니다. TCL 언어의 일부를보다 이식 가능한 형태로 다시 구현하여 SymbianOS에서 컴파일하고 실행할 수 있었으며 SQLite를 실행하기에 충분했습니다. 테스트. TH1은 SQLite의 표준 테스트 도구로 살아남지 못했지만 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;화석&lt;/a&gt; 을 사용자 정의하는 데 사용되는 스크립팅 언어로 지속적인 서비스를 찾았습니다.버전 관리 시스템. 또한 &quot;Test Harness # 2&quot;도있었습니다. 이것은 테스트를 구동하기 위해 연산자 접두사 표기법을 사용하여 간단한 스크립팅 언어를 만들려는 시도였습니다. TH3은 세 번째 시도였습니다.</target>
        </trans-unit>
        <trans-unit id="2607d86f3f95561abb29b75d3920751195896dbd" translate="yes" xml:space="preserve">
          <source>TH3 tests SQLite in an as-deployed configuration using only published and documented interfaces. In other words, TH3 tests the compiled object code, not the source code, thus verifying that no problems were introduced by compiler bugs. &quot;Test what you fly and fly what you test.&quot;</source>
          <target state="translated">TH3는 게시 및 문서화 된 인터페이스 만 사용하여 배포 된 구성에서 SQLite를 테스트합니다. 즉, TH3는 소스 코드가 아닌 컴파일 된 객체 코드를 테스트하여 컴파일러 버그로 인한 문제가 없는지 확인합니다. &quot;무엇을 비행하고 테스트 한 것을 비행하십시오.&quot;</target>
        </trans-unit>
        <trans-unit id="c87cfbcfb0ff68ef8b8fa0759657744ff88b88af" translate="yes" xml:space="preserve">
          <source>TH3 was originally written for validation testing only, but has subsequently been used for development testing and debugging as well, and has proven very helpful in those roles. A full-coverage test takes less than five minutes on a workstation and hence serves as a fast regression test during day-to-day maintenance of the SQLite code base.</source>
          <target state="translated">TH3는 원래 검증 테스트 용으로 만 작성되었지만 이후에는 개발 테스트 및 디버깅에도 사용되었으며 이러한 역할에 매우 유용한 것으로 입증되었습니다. 전체 범위 테스트는 워크 스테이션에서 5 분 이내에 완료되므로 SQLite 코드베이스를 매일 유지 보수하는 동안 빠른 회귀 테스트 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="bd7f8a83e07337beedb291a476a0abdb89ed6b4f" translate="yes" xml:space="preserve">
          <source>THEN</source>
          <target state="translated">THEN</target>
        </trans-unit>
        <trans-unit id="2c1d90a10bc6577f471f3c2c8cd6836385b31b82" translate="yes" xml:space="preserve">
          <source>TIES</source>
          <target state="translated">TIES</target>
        </trans-unit>
        <trans-unit id="4fe5a3682f8029783789ec9b3abba10f67f03ffa" translate="yes" xml:space="preserve">
          <source>TINYINT</source>
          <target state="translated">TINYINT</target>
        </trans-unit>
        <trans-unit id="15f51444be75bc88e935c57ef2ee7477dc73a64e" translate="yes" xml:space="preserve">
          <source>TO</source>
          <target state="translated">TO</target>
        </trans-unit>
        <trans-unit id="cd4fd03fe967437fff9a9133b579cdd5421577a6" translate="yes" xml:space="preserve">
          <source>TODO:  Add something about checking the page-cache first etc.</source>
          <target state="translated">TODO : 페이지 캐시를 먼저 확인하는 것에 대해 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="7fb66aab7e490b4f8a5b13b306c51e116175236a" translate="yes" xml:space="preserve">
          <source>TODO:  After sections 4 and 5 are finished, come back here and see if we can add a list of state items associated with each database connection to make things easier to understand. i.e each database connection has a file handle, a set of entries in the page cache, an expected page size etc.</source>
          <target state="translated">TODO : 섹션 4와 5가 끝나면 여기로 돌아와서 각 데이터베이스 연결과 관련된 상태 항목 목록을 추가하여 이해하기 쉽도록하십시오. 즉, 각 데이터베이스 연결에는 파일 핸들, 페이지 캐시의 항목 세트, 예상 페이지 크기 등이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dc847eb4b63db6446f6040c4f09bb7ba16604ab" translate="yes" xml:space="preserve">
          <source>TODO:  After this document is ready, make the vocabulary consistent and then add a glossary here.</source>
          <target state="translated">TODO :이 문서가 준비되면 어휘를 일관성있게 만든 다음 여기에 용어집을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f4e2201a943d83ad82ae3edd3d70f87d9d34b73f" translate="yes" xml:space="preserve">
          <source>TODO:  Describe the parameters set to configure the page cache limits.</source>
          <target state="translated">TODO : 페이지 캐시 한계를 구성하기 위해 설정된 매개 변수를 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="30bb6265750b23e36fff26fba218f095577396da" translate="yes" xml:space="preserve">
          <source>TODO:  Expand on and explain the above a bit.</source>
          <target state="translated">해야할 일 : 위의 내용을 확장하고 설명하십시오.</target>
        </trans-unit>
        <trans-unit id="55f19663a5c44b6305b426b72aadfc9a70eb894d" translate="yes" xml:space="preserve">
          <source>TODO:  Introduce the following sub-sections.</source>
          <target state="translated">TODO : 다음 하위 섹션을 소개하십시오.</target>
        </trans-unit>
        <trans-unit id="593039ec1c1939952bb9949b2bcbe1140a495e60" translate="yes" xml:space="preserve">
          <source>TODO:  Is the shared lock held after committing a</source>
          <target state="translated">TODO : 커밋 후 공유 잠금이 유지됩니까?</target>
        </trans-unit>
        <trans-unit id="c4a151926d0634538ee91af79c910ea2132025f5" translate="yes" xml:space="preserve">
          <source>TODO:  Master journal file pointers?</source>
          <target state="translated">TODO : 마스터 저널 파일 포인터?</target>
        </trans-unit>
        <trans-unit id="2c459077da83b75d52b821b2b77b9e73be290e1e" translate="yes" xml:space="preserve">
          <source>TODO:  Requirements describing the way in which the configuration parameters are used. About LRU etc.</source>
          <target state="translated">TODO : 구성 매개 변수 사용 방법을 설명하는 요구 사항. LRU 등에 대하여</target>
        </trans-unit>
        <trans-unit id="f7e945f52e85f69c533b2d7abf6ea281ed104013" translate="yes" xml:space="preserve">
          <source>TODO:  System requirement references for the above points.</source>
          <target state="translated">TODO : 위의 포인트에 대한 시스템 요구 사항 참조.</target>
        </trans-unit>
        <trans-unit id="840394002935b6f4d9da99212e26895929cd86d7" translate="yes" xml:space="preserve">
          <source>TODO:  What happens if the exclusive lock cannot be obtained? It is not possible for the attempt to upgrade from a reserved to a pending lock to fail.</source>
          <target state="translated">TODO : 독점 잠금을 얻을 수 없으면 어떻게됩니까? 예약 된 잠금에서 보류중인 잠금으로 업그레이드하려는 시도는 실패 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6714ad8471919f57bc47d379c3524d08542a02be" translate="yes" xml:space="preserve">
          <source>TODO:  Why a 16 byte block? Why not 4? (something to do with encrypted databases).</source>
          <target state="translated">TODO : 왜 16 바이트 블록입니까? 왜 4가 아닌가? (암호화 된 데이터베이스와 관련이 있음).</target>
        </trans-unit>
        <trans-unit id="2e614c97a332a0295344a53ea5da2a36633b1954" translate="yes" xml:space="preserve">
          <source>TPC-H Q8 is an eight-way join. As observed above, the main task of the query planner is to figure out the best nesting order of the eight loops in order to minimize the work needed to complete the join. A simplified model of this problem for the case of TPC-H Q8 is shown by the following diagram:</source>
          <target state="translated">TPC-H Q8은 8 방향 조인입니다. 위에서 살펴본 것처럼 쿼리 플래너의 주요 작업은 조인을 완료하는 데 필요한 작업을 최소화하기 위해 8 개의 루프 중 최상의 중첩 순서를 파악하는 것입니다. TPC-H Q8의 경우이 문제의 단순화 된 모델이 다음 다이어그램으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bac722ed74faff65da62171d3c4183479a271d1f" translate="yes" xml:space="preserve">
          <source>TRANSACTION</source>
          <target state="translated">TRANSACTION</target>
        </trans-unit>
        <trans-unit id="c162c076dc07a546449be9e07aa7a5c312ecbfe1" translate="yes" xml:space="preserve">
          <source>TRIGGER</source>
          <target state="translated">TRIGGER</target>
        </trans-unit>
        <trans-unit id="74303786eb95ccd75228db361d37b804576e18e6" translate="yes" xml:space="preserve">
          <source>TRUNCATE</source>
          <target state="translated">TRUNCATE</target>
        </trans-unit>
        <trans-unit id="dc45fdb7de43a003177f8df9ee10d01f58f57a58" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell (header 0x05):</source>
          <target state="translated">표 B- 트리 내부 셀 (헤더 0x05) :</target>
        </trans-unit>
        <trans-unit id="984abe18431413aca60298750d5de10b6d8716c4" translate="yes" xml:space="preserve">
          <source>Table B-Tree Interior Cell:</source>
          <target state="translated">표 B- 트리 내부 셀 :</target>
        </trans-unit>
        <trans-unit id="94d19a21f457eb5da8f03166c4dbc3a6ef641531" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell (header 0x0d):</source>
          <target state="translated">표 B- 트리 잎 세포 (헤더 0x0d) :</target>
        </trans-unit>
        <trans-unit id="31beedcdbc76a09dd63a101eacf4e15dc87e80c5" translate="yes" xml:space="preserve">
          <source>Table B-Tree Leaf Cell:</source>
          <target state="translated">표 B- 트리 잎 세포 :</target>
        </trans-unit>
        <trans-unit id="cdad59a82a2e26e2fc2225d0629f7733aef385c4" translate="yes" xml:space="preserve">
          <source>Table Column Names</source>
          <target state="translated">테이블 열 이름</target>
        </trans-unit>
        <trans-unit id="1225362d8c3c05de317acf9684ffe2e1a7649c08" translate="yes" xml:space="preserve">
          <source>Table Interior (0x05)</source>
          <target state="translated">테이블 인테리어 (0x05)</target>
        </trans-unit>
        <trans-unit id="de156b09866349ad52b0a535e8144a86d129a154" translate="yes" xml:space="preserve">
          <source>Table Leaf (0x0d)</source>
          <target state="translated">테이블 리프 (0x0d)</target>
        </trans-unit>
        <trans-unit id="c27c7c360e130231f97ba874c98e3448dd648d35" translate="yes" xml:space="preserve">
          <source>Table Name</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="6a975d3ec2f404cfb761b1314fc6745ca72f942e" translate="yes" xml:space="preserve">
          <source>Table b-tree</source>
          <target state="translated">테이블 b- 트리</target>
        </trans-unit>
        <trans-unit id="92db13efcb630c92ecf1220fd763e9d0e237c97e" translate="yes" xml:space="preserve">
          <source>Table name</source>
          <target state="translated">테이블 이름</target>
        </trans-unit>
        <trans-unit id="cf3467c6281e0ea2be2b55952d6893e3fbba049d" translate="yes" xml:space="preserve">
          <source>Table or index entries that are out of sequence</source>
          <target state="translated">순서를 벗어난 테이블 또는 인덱스 항목</target>
        </trans-unit>
        <trans-unit id="70aee3388a925e7cbb0852fe8dcdd4c402a95fd1" translate="yes" xml:space="preserve">
          <source>Table zTable does not exist within database zDb,</source>
          <target state="translated">테이블 zTable이 데이터베이스 zDb 내에 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8886ec4df0da407409b6e2c6457e09d78592c0c0" translate="yes" xml:space="preserve">
          <source>Table zTable is a WITHOUT ROWID table,</source>
          <target state="translated">테이블 zTable은 WITHOUT ROWID 테이블입니다.</target>
        </trans-unit>
        <trans-unit id="053f4c073c904977c9ac1e40ab060f8397a0907f" translate="yes" xml:space="preserve">
          <source>Table-name must already exists as a table. File-name must exist, and each row must contain the same number of columns as defined in the table. If a line in the file contains more or less than the number of columns defined, the copy method rollbacks any inserts, and returns an error.</source>
          <target state="translated">Table-name은 이미 테이블로 존재해야합니다. 파일 이름이 존재해야하며 각 행에는 테이블에 정의 된 것과 동일한 수의 열이 포함되어야합니다. 파일의 행에 정의 된 열 수보다 많거나 적은 행이 있으면 copy 메소드는 모든 삽입을 롤백하고 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aea731c8e5cbf2292cf08d50a7760fa0d709eb35" translate="yes" xml:space="preserve">
          <source>Table-valued Functions In The FROM Clause</source>
          <target state="translated">FROM 절의 테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="fc3ba8bea68a8b6f73ff90024cfd6082eaf4a791" translate="yes" xml:space="preserve">
          <source>Table-valued functions</source>
          <target state="translated">테이블 반환 함수</target>
        </trans-unit>
        <trans-unit id="b503117e6dd30a0beff0cc1ab7fb7d005000dd03" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for PRAGMAs that return results and that have no side-effects.</source>
          <target state="translated">테이블 반환 함수는 결과를 반환하고 부작용이없는 PRAGMA에 대해서만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="f155ed85208e2d25c37ff0660af9e88e0ce41331" translate="yes" xml:space="preserve">
          <source>Table-valued functions exist only for built-in PRAGMAs, not for PRAGMAs defined using the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control.</source>
          <target state="translated">테이블 반환 함수는 내장 PRAGMA에만 존재하며 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 컨트롤을 사용하여 정의 된 PRAGMA에는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="81ea5c3f4a86eb9511e7fd13ab5c2a7a105f6e9f" translate="yes" xml:space="preserve">
          <source>TableLock</source>
          <target state="translated">TableLock</target>
        </trans-unit>
        <trans-unit id="c52e87aa9f54904a290a1ea1125feb8f0b12b884" translate="yes" xml:space="preserve">
          <source>Tables are removed using the &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 문을 사용하여 테이블을 제거 합니다.</target>
        </trans-unit>
        <trans-unit id="5bee9f4ba2588a4abe8a5e77c961e698fb909d93" translate="yes" xml:space="preserve">
          <source>Tables created using CREATE TABLE AS are initially populated with the rows of data returned by the SELECT statement. Rows are assigned contiguously ascending &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; values, starting with 1, in the &lt;a href=&quot;lang_select#orderby&quot;&gt;order&lt;/a&gt; that they are returned by the SELECT statement.</source>
          <target state="translated">CREATE TABLE AS를 사용하여 작성된 테이블은 처음에 SELECT 문이 리턴 한 데이터 행으로 채워집니다. 행은 SELECT 문에 의해 반환되는 &lt;a href=&quot;lang_select#orderby&quot;&gt;순서대로&lt;/a&gt; 1부터 시작하여 연속적으로 상승하는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 값 으로 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b08405f06556bfc4a2cd40880fee5d5df353fe5" translate="yes" xml:space="preserve">
          <source>Tables created using the &quot;CREATE TEMP TABLE&quot; syntax are only visible to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; in which the &quot;CREATE TEMP TABLE&quot; statement is originally evaluated. These TEMP tables, together with any associated indices, triggers, and views, are collectively stored in a separate temporary database file that is created as soon as the first &quot;CREATE TEMP TABLE&quot; statement is seen. This separate temporary database file also has an associated rollback journal. The temporary database file used to store TEMP tables is deleted automatically when the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed using &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt;.</source>
          <target state="translated">&quot;CREATE TEMP TABLE&quot;구문을 사용하여 작성된 테이블 은 &quot;CREATE TEMP TABLE&quot;문이 원래 평가 된 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서만 볼 수 있습니다 . 이러한 TEMP 테이블은 연관된 인덱스, 트리거 및 뷰와 함께 첫 번째 &quot;CREATE TEMP TABLE&quot;문이 표시되는 즉시 작성되는 별도의 임시 데이터베이스 파일에 집합 적으로 저장됩니다. 이 별도의 임시 데이터베이스 파일에도 관련 롤백 저널이 있습니다. &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()를&lt;/a&gt; 사용하여 닫으면 TEMP 테이블을 저장하는 데 사용 된 임시 데이터베이스 파일이 자동으로 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="398c675fc2fa417398cf9f153388d4a182136954" translate="yes" xml:space="preserve">
          <source>Tables in an attached database can be referred to using the syntax</source>
          <target state="translated">첨부 된 데이터베이스의 테이블은 구문을 사용하여 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230baa2e574ece0e6ffe7c574dcbbb9cd18fff76" translate="yes" xml:space="preserve">
          <source>Tables with names of the form &quot;sqlite_statN&quot; where N is an integer. Such tables store database statistics gathered by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command and used by the query planner to help determine the best algorithm to use for each query.</source>
          <target state="translated">&quot;sqlite_statN&quot;형식의 이름을 가진 테이블. 여기서 N은 정수입니다. 이러한 테이블은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령으로 수집 하고 쿼리 플래너가 사용하는 데이터베이스 통계를 저장 하여 각 쿼리에 사용할 최상의 알고리즘을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6dbeddaf590f294decd7c12cd9b3ac14168d3997" translate="yes" xml:space="preserve">
          <source>Take advantage of the atomic-write capabilities in the &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS filesystem&lt;/a&gt; when available, for greatly reduced transaction overhead. This currently requires the &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; compile-time option.</source>
          <target state="translated">사용 가능한 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/F2FS&quot;&gt;F2FS 파일 시스템&lt;/a&gt; 의 원자 쓰기 기능을 활용하여 트랜잭션 오버 헤드를 크게 줄입니다. 현재 &lt;a href=&quot;compile#enable_batch_atomic_write&quot;&gt;SQLITE_ENABLE_BATCH_ATOMIC_WRITE&lt;/a&gt; 컴파일 타임 옵션 이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="acf997da6bf4365bf440bc3ad9c07d7d7925e743" translate="yes" xml:space="preserve">
          <source>Take into account the fact WHERE clause terms that cannot be used with indices still probably reduce the number of output rows.</source>
          <target state="translated">인덱스와 함께 사용할 수없는 WHERE 절 용어를 고려하면 여전히 출력 행 수를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2975a6466c6b11f1519a6c8652f37b3cef0c265" translate="yes" xml:space="preserve">
          <source>Take the bit-wise AND of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1 및 P2에있는 값의 비트 단위 AND를 가져 와서 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="23882df60c1b18a8b147b1926280887dfe7acb8a" translate="yes" xml:space="preserve">
          <source>Take the bit-wise OR of the values in register P1 and P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1 및 P2에있는 값의 비트 단위 OR을 가져 와서 결과를 레지스터 P3에 저장하십시오. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="6a0b05dea29609663a6574c364045bd831c5b261" translate="yes" xml:space="preserve">
          <source>Take the logical AND of the values in registers P1 and P2 and write the result into register P3.</source>
          <target state="translated">레지스터 P1 및 P2에있는 값의 논리 AND를 가져 와서 결과를 레지스터 P3에 씁니다.</target>
        </trans-unit>
        <trans-unit id="9fe2090d6b7e599d38b33eca83b4b2c09d8a131d" translate="yes" xml:space="preserve">
          <source>Take the logical OR of the values in register P1 and P2 and store the answer in register P3.</source>
          <target state="translated">레지스터 P1 및 P2의 값에 대한 논리 OR을 취하여 레지스터 P3에 답을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="86743ec77172a00f99a2bc089314b61779948598" translate="yes" xml:space="preserve">
          <source>Taking into consideration all of the above, the SQLite developers recommend compiling SQLite using GCC-7 with the -Os optimization setting.</source>
          <target state="translated">위의 모든 사항을 고려하여 SQLite 개발자는 -Os 최적화 설정으로 GCC-7을 사용하여 SQLite를 컴파일하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="76c9ad6f3798c330d93462b6d6a9dc1c1bbb0620" translate="yes" xml:space="preserve">
          <source>Tarball</source>
          <target state="translated">Tarball</target>
        </trans-unit>
        <trans-unit id="81919e9867e82f4145f1c83ee343766917076a71" translate="yes" xml:space="preserve">
          <source>Tcl Interface</source>
          <target state="translated">Tcl 인터페이스</target>
        </trans-unit>
        <trans-unit id="5962096d8eee555590e081b0968ff7c28d5fa0d8" translate="yes" xml:space="preserve">
          <source>Tcl command. Here is an example of opening and then immediately closing a database:</source>
          <target state="translated">Tcl 명령. 다음은 데이터베이스를 연 다음 즉시 닫는 예입니다.</target>
        </trans-unit>
        <trans-unit id="30d70929c5f61502f6c778af83fbc14057a6c36d" translate="yes" xml:space="preserve">
          <source>Tcl interface allows BLOB values to be transferred to user-defined functions</source>
          <target state="translated">Tcl 인터페이스를 통해 BLOB 값을 사용자 정의 함수로 전송할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="82fe9aa4119c1f18902f153a0d50a82f529e5cfb" translate="yes" xml:space="preserve">
          <source>Tcl variable names can appear in the SQL statement of the second argument in any position where it is legal to put a string or number literal. The value of the variable is substituted for the variable name. If the variable does not exist a NULL values is used. For example:</source>
          <target state="translated">Tcl 변수 이름은 문자열 또는 숫자 리터럴을 넣는 것이 합법적 인 위치에서 두 번째 인수의 SQL 문에 나타날 수 있습니다. 변수의 값은 변수 이름으로 대체됩니다. 변수가 존재하지 않으면 NULL 값이 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2087e1ec9a4eee3edea091cbf4ce24dad9709230" translate="yes" xml:space="preserve">
          <source>Technical and Design Documentation</source>
          <target state="translated">기술 및 디자인 문서</target>
        </trans-unit>
        <trans-unit id="b6d6d722a0223fd3e9343b1f4796db6a665b091d" translate="yes" xml:space="preserve">
          <source>Temporary Databases</source>
          <target state="translated">임시 데이터베이스</target>
        </trans-unit>
        <trans-unit id="6035a1db7f899a29bfadee59c52d9c07fdd98c4f" translate="yes" xml:space="preserve">
          <source>Temporary Files Used By SQLite</source>
          <target state="translated">SQLite가 사용하는 임시 파일</target>
        </trans-unit>
        <trans-unit id="9fb2a1ec0fce944f3e17c8ab4b4f05b81d7ac8a9" translate="yes" xml:space="preserve">
          <source>Temporary directory search algorithm</source>
          <target state="translated">임시 디렉토리 검색 알고리즘</target>
        </trans-unit>
        <trans-unit id="72f84f0ca9f1ad9f151e46cd589374308dcbfc81" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored in memory regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 설정에 관계없이 항상 메모리에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="92a5156680aa1ea2c11db1f65a26abbd9db39a63" translate="yes" xml:space="preserve">
          <source>Temporary files are always stored on disk regardless of the setting of the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 설정에 관계없이 항상 디스크에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7777ca8353568841ffb0454d79b2cf5d09f1f51b" translate="yes" xml:space="preserve">
          <source>Temporary files are now automatically deleted by the operating system when closed. There are no more dangling temporary files on a program crash. (If the OS crashes, fsck will delete the file after reboot under Unix. I do not know what happens under Windows.)</source>
          <target state="translated">임시 파일은 이제 닫힐 때 운영 체제에 의해 자동으로 삭제됩니다. 프로그램 충돌시 더 이상 매달려있는 임시 파일이 없습니다. (OS가 충돌하면 fsck가 Unix에서 재부팅 한 후 파일을 삭제합니다. Windows에서 어떤 일이 발생하는지 모르겠습니다.)</target>
        </trans-unit>
        <trans-unit id="96da9e1a1910e6d40a0e879229d60b3a31a1bf7a" translate="yes" xml:space="preserve">
          <source>Temporary files are stored in memory by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 기본적으로 메모리에 저장되지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11e15117ca75e55537b6f5f3dded721aee297def" translate="yes" xml:space="preserve">
          <source>Temporary files are stored on disk by default but this can be overridden by the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt;.</source>
          <target state="translated">임시 파일은 기본적으로 디스크에 저장되지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;temp_store pragma&lt;/a&gt; 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7500f7d38f84089cbb32d6695814260f35c022d2" translate="yes" xml:space="preserve">
          <source>Temporary journal files are created as part of transaction control, but those extra files are not part of the steady-state database.</source>
          <target state="translated">임시 저널 파일은 트랜잭션 제어의 일부로 작성되지만 이러한 추가 파일은 정상 상태 데이터베이스의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="455a1e08ff236bc4fc37f10c45a4f1a9d962e921" translate="yes" xml:space="preserve">
          <source>Temporary tables</source>
          <target state="translated">임시 테이블</target>
        </trans-unit>
        <trans-unit id="4dff3aa4061b74df07e184cd766c027d8d0851b5" translate="yes" xml:space="preserve">
          <source>Terminate the sqlite3 program by typing your system End-Of-File character (usually a Control-D). Use the interrupt character (usually a Control-C) to stop a long-running SQL statement.</source>
          <target state="translated">시스템 파일 끝 문자 (일반적으로 Control-D)를 입력하여 sqlite3 프로그램을 종료하십시오. 인터럽트 문자 (일반적으로 Control-C)를 사용하여 오래 실행되는 SQL 문을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="f859f91a5306999f44ef0e2194daef49cbdeb611" translate="yes" xml:space="preserve">
          <source>Terminating a read-only transaction.</source>
          <target state="translated">읽기 전용 트랜잭션 종료</target>
        </trans-unit>
        <trans-unit id="46428866c7ab286d2c6ac557b2373b6b72377ee3" translate="yes" xml:space="preserve">
          <source>Terms of the ORDER BY clause that is part of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement may be assigned a collating sequence using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, in which case the specified collating function is used for sorting. Otherwise, if the expression sorted by an ORDER BY clause is a column, then the collating sequence of the column is used to determine sort order. If the expression is not a column and has no COLLATE clause, then the BINARY collating sequence is used.</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 일부인 ORDER BY 절의 용어 에는 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용하여 조합 순서가 지정 될 수 있으며 ,이 경우 지정된 조합 함수가 정렬에 사용됩니다. 그렇지 않으면 ORDER BY 절에 의해 정렬 된 표현식이 열인 경우 정렬 순서를 결정하기 위해 열의 조합 순서가 사용됩니다. 표현식이 열이 아니고 COLLATE 절이없는 경우 BINARY 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb252ee8cea482226d27c4a24f04af58befef27" translate="yes" xml:space="preserve">
          <source>Terms of the WHERE clause can be manually disqualified for use with indices by prepending a unary *+* operator to the column name. The unary *+* is a no-op and will not generate any byte code in the prepared statement. But the unary *+* operator will prevent the term from constraining an index. So, in the example above, if the query were rewritten as:</source>
          <target state="translated">단항 * + * 연산자를 열 이름 앞에 추가하여 WHERE 절의 용어를 인덱스와 함께 사용하기 위해 수동으로 실격 할 수 있습니다. 단항 * + *는 작동하지 않으며 준비된 명령문에서 바이트 코드를 생성하지 않습니다. 그러나 단항 * + * 연산자는 용어가 색인을 제한하지 못하게합니다. 따라서 위의 예에서 쿼리가 다음과 같이 다시 작성된 경우 :</target>
        </trans-unit>
        <trans-unit id="db8a7aee242ffd686d07e20367e523410ddf047e" translate="yes" xml:space="preserve">
          <source>Test 10: 25000 text UPDATEs with an index</source>
          <target state="translated">테스트 10 : 인덱스가있는 25000 개의 텍스트 업데이트</target>
        </trans-unit>
        <trans-unit id="aacbc05d861c7b90deae327687214123e261d5d7" translate="yes" xml:space="preserve">
          <source>Test 11: INSERTs from a SELECT</source>
          <target state="translated">테스트 11 : SELECT에서 INSERT</target>
        </trans-unit>
        <trans-unit id="aca64bdf90089bb1a7f070072ce5ba7eb929e0ca" translate="yes" xml:space="preserve">
          <source>Test 12: DELETE without an index</source>
          <target state="translated">테스트 12 : 인덱스없이 삭제</target>
        </trans-unit>
        <trans-unit id="24752c37e60c377f791b489053904e7999992109" translate="yes" xml:space="preserve">
          <source>Test 13: DELETE with an index</source>
          <target state="translated">테스트 13 : 인덱스를 사용하여 삭제</target>
        </trans-unit>
        <trans-unit id="00cb0edebe54a9c5c407d066d9fcba0da202194b" translate="yes" xml:space="preserve">
          <source>Test 14: A big INSERT after a big DELETE</source>
          <target state="translated">테스트 14 : 큰 삭제 후 큰 삽입</target>
        </trans-unit>
        <trans-unit id="8033466c1d65a1a2a0c68dc77e0e42697e35f88b" translate="yes" xml:space="preserve">
          <source>Test 15: A big DELETE followed by many small INSERTs</source>
          <target state="translated">테스트 15 : 큰 삭제 후 많은 작은 INSERT</target>
        </trans-unit>
        <trans-unit id="391b748d4bf30ad6ba35b1537b20fb9263b9be11" translate="yes" xml:space="preserve">
          <source>Test 16: DROP TABLE</source>
          <target state="translated">테스트 16 : DROP TABLE</target>
        </trans-unit>
        <trans-unit id="700f1cfb18cec62b7bd8f4bd15b16b69774b094a" translate="yes" xml:space="preserve">
          <source>Test 1: 1000 INSERTs</source>
          <target state="translated">시험 1 : 1000 INSERT</target>
        </trans-unit>
        <trans-unit id="a74380705222d36f436d75c90099251831b68c6d" translate="yes" xml:space="preserve">
          <source>Test 2: 25000 INSERTs in a transaction</source>
          <target state="translated">테스트 2 : 트랜잭션에서 25000 INSERT</target>
        </trans-unit>
        <trans-unit id="d01c89b36c5ea1e456013c3cc10174d42005deaa" translate="yes" xml:space="preserve">
          <source>Test 3: 25000 INSERTs into an indexed table</source>
          <target state="translated">테스트 3 : 인덱스 테이블에 25000 INSERT</target>
        </trans-unit>
        <trans-unit id="5150380a9467a7720fe9216afc4866b3aea9f992" translate="yes" xml:space="preserve">
          <source>Test 4: 100 SELECTs without an index</source>
          <target state="translated">테스트 4 : 인덱스가없는 100 개의 SELECT</target>
        </trans-unit>
        <trans-unit id="2d07089542c5b6e56dea3631a868016dd2267c55" translate="yes" xml:space="preserve">
          <source>Test 5: 100 SELECTs on a string comparison</source>
          <target state="translated">테스트 5 : 문자열 비교에서 100 개의 SELECT</target>
        </trans-unit>
        <trans-unit id="1ee313e9981650c288efefb71dc3528b68b2a91a" translate="yes" xml:space="preserve">
          <source>Test 6: Creating an index</source>
          <target state="translated">테스트 6 : 색인 작성</target>
        </trans-unit>
        <trans-unit id="e0797e7844f18b5e63c9d2f6207a7266e87d829e" translate="yes" xml:space="preserve">
          <source>Test 7: 5000 SELECTs with an index</source>
          <target state="translated">테스트 7 : 인덱스가있는 5000 개의 SELECT</target>
        </trans-unit>
        <trans-unit id="fccbfc70f55db2b38d057e5e2decb47d90df070e" translate="yes" xml:space="preserve">
          <source>Test 8: 1000 UPDATEs without an index</source>
          <target state="translated">테스트 8 : 인덱스가없는 1000 개의 업데이트</target>
        </trans-unit>
        <trans-unit id="47ad12d810778d98e72de67605dc988105d4b09b" translate="yes" xml:space="preserve">
          <source>Test 9: 25000 UPDATEs with an index</source>
          <target state="translated">테스트 9 : 인덱스를 사용한 25000 업데이트</target>
        </trans-unit>
        <trans-unit id="18a302ee283ea042f30ca2cb852a2846f97c9413" translate="yes" xml:space="preserve">
          <source>Test Code</source>
          <target state="translated">테스트 코드</target>
        </trans-unit>
        <trans-unit id="fbcf57d6160711801ae44b031c459127add7faaa" translate="yes" xml:space="preserve">
          <source>Test Environment</source>
          <target state="translated">테스트 환경</target>
        </trans-unit>
        <trans-unit id="a76dd0a3dd495aa45fe2a39614c44782afcb01ca" translate="yes" xml:space="preserve">
          <source>Test For Auto-Commit Mode</source>
          <target state="translated">자동 커밋 모드 테스트</target>
        </trans-unit>
        <trans-unit id="c05597ed0dba53dda21d6b294858039879f34b2b" translate="yes" xml:space="preserve">
          <source>Test To See If The Library Is Threadsafe</source>
          <target state="translated">라이브러리가 스레드로부터 안전한지 테스트</target>
        </trans-unit>
        <trans-unit id="02446da6bfd0c0c261b870c2d7a5bfb426f2969d" translate="yes" xml:space="preserve">
          <source>Test data unavailable.</source>
          <target state="translated">테스트 데이터를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a364e52356a7ca07cff67161e3755ffa1a5b6b19" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes</source>
          <target state="translated">변경 세트가 변경을 기록했는지 테스트</target>
        </trans-unit>
        <trans-unit id="0687fd76855654ace6e8592132670b232e8466bb" translate="yes" xml:space="preserve">
          <source>Test if a changeset has recorded any changes.</source>
          <target state="translated">변경 세트가 변경을 기록했는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="975278e4cf4ae85f07454f0bd57ddce6fc5bd9a5" translate="yes" xml:space="preserve">
          <source>Testcase macros are also used when two or more cases of a switch statement go to the same block of code, to make sure that the code was reached for all cases:</source>
          <target state="translated">테스트 사례 매크로는 둘 이상의 switch 문의 사례가 동일한 코드 블록으로 이동하여 모든 경우에 대해 코드에 도달했는지 확인하는 데에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d38ba7cbc400f9b209719e16e540214a64776c" translate="yes" xml:space="preserve">
          <source>Testing Interface</source>
          <target state="translated">테스트 인터페이스</target>
        </trans-unit>
        <trans-unit id="8adc754de4730d9303e4e9dfdc04c11250d45d3c" translate="yes" xml:space="preserve">
          <source>Testing Interface Operation Codes</source>
          <target state="translated">테스트 인터페이스 작동 코드</target>
        </trans-unit>
        <trans-unit id="61b27896db003bc4e45807f83422aff3b0ba8af9" translate="yes" xml:space="preserve">
          <source>Testing of both source code and object code</source>
          <target state="translated">소스 코드와 객체 코드 모두 테스트</target>
        </trans-unit>
        <trans-unit id="e1859263f675753d24029e449e12bbca3196f641" translate="yes" xml:space="preserve">
          <source>Testing on multiple platforms and with multiple compilers</source>
          <target state="translated">여러 플랫폼 및 여러 컴파일러에서 테스트</target>
        </trans-unit>
        <trans-unit id="c9efb9d787a1a844d9d75c706c96b2d104de210f" translate="yes" xml:space="preserve">
          <source>Text Encodings</source>
          <target state="translated">텍스트 인코딩</target>
        </trans-unit>
        <trans-unit id="104683d616e58eaef10d6dc4873ecdc3df7b2908" translate="yes" xml:space="preserve">
          <source>Text encoding</source>
          <target state="translated">텍스트 인코딩</target>
        </trans-unit>
        <trans-unit id="e12c4eeb80ad1f4c53769014c35b62416e040202" translate="yes" xml:space="preserve">
          <source>Text files read by the COPY command can now have line terminators of LF, CRLF, or CR.</source>
          <target state="translated">COPY 명령으로 읽은 텍스트 파일은 이제 LF, CRLF 또는 CR의 줄 종결자를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc9a8c0f2eca40d02a98349a624352ec809c4662" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">텍스트는 &lt;a href=&quot;#sqlite3_str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; 와 같은 다양한 방법을 사용하여 sqlite3_str 객체에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="3f06b000ef5df2cf2524013049769bc8b85cadef" translate="yes" xml:space="preserve">
          <source>Text is appended to the sqlite3_str object using various methods, such as &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf()&lt;/a&gt;.</source>
          <target state="translated">텍스트는 &lt;a href=&quot;str_append&quot;&gt;sqlite3_str_appendf ()&lt;/a&gt; 와 같은 다양한 방법을 사용하여 sqlite3_str 객체에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="65ebd99ce12ebe199710e41e33f5f3620f55ed7a" translate="yes" xml:space="preserve">
          <source>Text values (odd serial types 13 and larger) sort after numeric values in the order determined by the columns &lt;a href=&quot;datatype3#collation&quot;&gt;collating function&lt;/a&gt;.</source>
          <target state="translated">텍스트 값 (홀수 직렬 유형 13 이상)은 열 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 기능에&lt;/a&gt; 의해 결정된 순서대로 숫자 값 뒤에 정렬됩니다 .</target>
        </trans-unit>
        <trans-unit id="beca9771feb98f615524a1df72482f4458f93607" translate="yes" xml:space="preserve">
          <source>Text values come after numerics</source>
          <target state="translated">텍스트 값은 숫자 뒤에옵니다</target>
        </trans-unit>
        <trans-unit id="938716cf9d2d773dc94de020d7864e49e44b2b9d" translate="yes" xml:space="preserve">
          <source>Th functionality described in this section may be integrated into other applications or tools using the &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt; SQLite expert extension&lt;/a&gt; code.</source>
          <target state="translated">이 섹션에서 설명하는 기능은 &lt;a href=&quot;http://www.sqlite.org/src/dir?ci=trunk&amp;amp;name=ext/expert&quot;&gt;SQLite 전문가 확장&lt;/a&gt; 코드를 사용하여 다른 응용 프로그램이나 도구에 통합 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5401c7212b5c2e26aee89d6b33a167be2b97f64d" translate="yes" xml:space="preserve">
          <source>That command only works as written on Windows. The equivalent line on a Mac would be:</source>
          <target state="translated">이 명령은 Windows에서 작성된 대로만 작동합니다. Mac에서 동등한 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5b3c3c06cd257877a1f47703881aa426e835ba23" translate="yes" xml:space="preserve">
          <source>That last command is the same &quot;ui&quot; command that we ran before. It starts a mini-webserver running and points your web browser at it. But this time we didn't have to specify the repository file because we are located inside a checkout and so fossil can figure out the repository for itself. If you want to type in the repository filename as the second argument, you can. But it is optional.</source>
          <target state="translated">마지막 명령은 이전에 실행했던 것과 동일한 &quot;ui&quot;명령입니다. 미니 웹 서버가 실행되고 웹 브라우저가 나타납니다. 그러나 이번에는 체크 아웃 내부에 위치하고 있기 때문에 저장소 파일을 지정할 필요가 없었으므로 화석은 저장소 자체를 알아낼 수 있습니다. 저장소 파일 이름을 두 번째 인수로 입력하려는 경우 가능합니다. 그러나 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="3ec5cf39a76e0d09154e1a51128f437190f411ce" translate="yes" xml:space="preserve">
          <source>That said, there are a number of things that external programs or bugs in your hardware or OS can do to corrupt a database file. See &lt;a href=&quot;howtocorrupt&quot;&gt;How To Corrupt An SQLite Database File&lt;/a&gt; for further information.</source>
          <target state="translated">그러나 하드웨어 나 OS의 외부 프로그램이나 버그가 데이터베이스 파일을 손상시키기 위해 할 수있는 일이 많이 있습니다. 자세한 내용 &lt;a href=&quot;howtocorrupt&quot;&gt;은 SQLite 데이터베이스 파일을 손상시키는 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac09579911e9129dbe219b67c0bf67a294beccfa" translate="yes" xml:space="preserve">
          <source>That statement is ambiguous, having at least two possible interpretations:</source>
          <target state="translated">이 진술은 모호하며 적어도 두 가지 해석이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c679c2a5140d95b7fe5e7a9c937890448e4790a5" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_parent table as there are non-leaf cells in the r-tree structure, and that there is a non-leaf cell that corresponds to each entry in the %_parent table.</source>
          <target state="translated">r-tree 구조에 리프가 아닌 셀이 있고 % _parent 테이블의 각 항목에 해당하는 리프가 아닌 셀이 % _parent 테이블에 같은 수의 항목이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bc14fa3c4653db3dfe511c9da292c9e32677da7" translate="yes" xml:space="preserve">
          <source>That there are the same number of entries in the %_rowid table as there are leaf cells in the r-tree structure, and that there is a leaf cell that corresponds to each entry in the %_rowid table.</source>
          <target state="translated">r-tree 구조에 리프 셀이있는 것과 % _rowid 테이블에 동일한 개수의 항목이 있고 % _rowid 테이블의 각 항목에 해당하는 리프 셀이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="c3fcc1dd87de9c9ad15a933b970c62ff1decbfcb" translate="yes" xml:space="preserve">
          <source>The &quot;%&quot; in the name of each shadow table is replaced by the name of the R*Tree virtual table. So, if the name of the R*Tree table is &quot;xyz&quot; then the three shadow tables would be &quot;xyz_node&quot;, &quot;xyz_parent&quot;, and &quot;xyz_rowid&quot;.</source>
          <target state="translated">각 새도우 테이블 이름의 &quot;%&quot;는 R * Tree 가상 테이블 이름으로 바뀝니다. 따라서 R * Tree 테이블의 이름이 &quot;xyz&quot;이면 세 개의 새도우 테이블은 &quot;xyz_node&quot;, &quot;xyz_parent&quot;및 &quot;xyz_rowid&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ac1d4dc22d0f78dbeef0512926462de5ac6f42" translate="yes" xml:space="preserve">
          <source>The &quot;-1&quot; term at the start of the formula is not found in most implementations of the BM25 algorithm. Without it, a better match is assigned a numerically higher BM25 score. Since the default sorting order is &quot;ascending&quot;, this means that appending &quot;ORDER BY bm25(fts)&quot; to a query would cause results to be returned in order from worst to best. The &quot;DESC&quot; keyword would be required in order to return the best matches first. In order to avoid this pitfall, the FTS5 implementation of BM25 multiplies the result by -1 before returning it, ensuring that better matches are assigned numerically lower scores.</source>
          <target state="translated">수식 시작시 &quot;-1&quot;용어는 대부분의 BM25 알고리즘 구현에서 찾을 수 없습니다. 그것없이, 더 나은 경기는 수치 적으로 더 높은 BM25 점수가 할당됩니다. 기본 정렬 순서는 &quot;오름차순&quot;이므로 쿼리에 &quot;ORDER BY bm25 (fts)&quot;를 추가하면 결과가 최악에서 최상의 순서로 반환됩니다. 가장 일치하는 항목을 먼저 반환하려면 &quot;DESC&quot;키워드가 필요합니다. 이러한 함정을 피하기 위해, BM25의 FTS5 구현은 결과를 반환하기 전에 -1을 곱하여 더 나은 일치에 수치 적으로 낮은 점수를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="e8a8a21328c61527fb3df55781ac56d188f8d80f" translate="yes" xml:space="preserve">
          <source>The &quot;.archive&quot; dot-command and the &quot;-A&quot; command-line option provide built-in support for the &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive format&lt;/a&gt;. The interface is similar to that of the &quot;tar&quot; command on unix systems. Each invocation of the &quot;.ar&quot; command must specify a single command option. The following commands are available for &quot;.archive&quot;:</source>
          <target state="translated">&quot;.archive&quot;도트 명령 및 &quot;-A&quot;명령 행 옵션은 &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive 형식&lt;/a&gt; 을 기본적으로 지원 합니다 . 인터페이스는 유닉스 시스템에서 &quot;tar&quot;명령의 인터페이스와 유사합니다. &quot;.ar&quot;명령을 호출 할 때마다 단일 명령 옵션을 지정해야합니다. &quot;.archive&quot;에 대해 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83487a27f6e8c5a3e4b3ee1c0c3210033e4ad993" translate="yes" xml:space="preserve">
          <source>The &quot;.breakpoint&quot; command in the CLI does nothing but invoke the procedure named &quot;test_breakpoint()&quot;, which is a no-op.</source>
          <target state="translated">CLI의 &quot;.breakpoint&quot;명령은 no-op 인 &quot;test_breakpoint ()&quot;라는 프로 시저를 호출 할뿐입니다.</target>
        </trans-unit>
        <trans-unit id="469a3442411a65b2a429f963b79791f612ed7d6e" translate="yes" xml:space="preserve">
          <source>The &quot;.databases&quot; command shows a list of all databases open in the current connection. There will always be at least 2. The first one is &quot;main&quot;, the original database opened. The second is &quot;temp&quot;, the database used for temporary tables. There may be additional databases listed for databases attached using the ATTACH statement. The first output column is the name the database is attached with, and the second column is the filename of the external file.</source>
          <target state="translated">&quot;.databases&quot;명령은 현재 연결에서 열린 모든 데이터베이스 목록을 보여줍니다. 항상 2 개 이상이 있어야합니다. 첫 번째는 &quot;main&quot;이며 원래 데이터베이스가 열립니다. 두 번째는 임시 테이블에 사용되는 데이터베이스 인 &quot;temp&quot;입니다. ATTACH 문을 사용하여 첨부 된 데이터베이스에 대해 추가 데이터베이스가 나열 될 수 있습니다. 첫 번째 출력 열은 데이터베이스가 연결된 이름이고 두 번째 열은 외부 파일의 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ee926b57bed300f9a7e5c92f6be433c508e9bcc7" translate="yes" xml:space="preserve">
          <source>The &quot;.dump&quot; output from the shell does not work if there are embedded newlines anywhere in the data. This is an old bug that was carried forward from version 1.0. To fix it, the &quot;.dump&quot; output no longer uses the COPY command. It instead generates INSERT statements.</source>
          <target state="translated">데이터의 아무 곳에도 줄 바꿈이 포함되어 있으면 셸의 &quot;.dump&quot;출력이 작동하지 않습니다. 이것은 버전 1.0에서 수행 된 오래된 버그입니다. 이 문제를 해결하기 위해 &quot;.dump&quot;출력은 더 이상 COPY 명령을 사용하지 않습니다. 대신 INSERT 문을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1b85291d31b07e89b01fbd9925959d88473c2a10" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is an alias for &quot;.once -x&quot;. It does exactly the same thing.</source>
          <target state="translated">&quot;.excel&quot;명령은 &quot;.once -x&quot;의 별명입니다. 정확히 같은 일을합니다.</target>
        </trans-unit>
        <trans-unit id="9686c64857b56634cf1d980b549835b7a48ecb3c" translate="yes" xml:space="preserve">
          <source>The &quot;.excel&quot; command is really an alias for &quot;.once -x&quot;. The -x option to .once causes it to writes results as CSV into a temporary file that is named with a &quot;.csv&quot; suffix, then invoke the systems default handler for CSV files.</source>
          <target state="translated">&quot;.excel&quot;명령은 실제로 &quot;.once -x&quot;의 별명입니다. -x 옵션을 .once로 설정하면 &quot;.csv&quot;접미사로 이름 지정된 임시 파일에 결과를 CSV로 기록한 다음 CSV 파일에 대한 시스템 기본 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="a0ea244938baaf074aedf53e702eadce70d483bf" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command accepts the following options:</source>
          <target state="translated">&quot;.expert&quot;명령은 다음 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="62869dd914f2d45ca628931082045505cc0aa98c" translate="yes" xml:space="preserve">
          <source>The &quot;.expert&quot; command is issued first, followed by the SQL query on a separate line. For example, consider the following session:</source>
          <target state="translated">&quot;.expert&quot;명령이 먼저 발행 된 후 별도의 행에 SQL 조회가 수행됩니다. 예를 들어 다음 세션을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bf73e6ae296e826f7923e0357132694890491637" translate="yes" xml:space="preserve">
          <source>The &quot;.fullschema&quot; dot-command works like the &quot;.schema&quot; command in that it displays the entire database schema. But &quot;.fullschema&quot; also includes dumps of the statistics tables &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;, and &quot;sqlite_stat4&quot;, if they exist. The &quot;.fullschema&quot; command normally provides all of the information needed to exactly recreate a query plan for a specific query. When reporting suspected problems with the SQLite query planner to the SQLite development team, developers are requested to provide the complete &quot;.fullschema&quot; output as part of the trouble report. Note that the sqlite_stat3 and sqlite_stat4 tables contain samples of index entries and so might contain sensitive data, so do not send the &quot;.fullschema&quot; output of a proprietary database over a public channel.</source>
          <target state="translated">&quot;.fullschema&quot;도트 명령은 전체 데이터베이스 스키마를 표시한다는 점에서 &quot;.schema&quot;명령과 동일하게 작동합니다. 그러나 &quot;.fullschema&quot;에는 통계 테이블 &quot;sqlite_stat1&quot;, &quot;sqlite_stat3&quot;및 &quot;sqlite_stat4&quot;(있는 경우)의 덤프도 포함됩니다. &quot;.fullschema&quot;명령은 일반적으로 특정 쿼리에 대한 쿼리 계획을 정확하게 재생성하는 데 필요한 모든 정보를 제공합니다. SQLite 쿼리 플래너에서 의심되는 문제를 SQLite 개발 팀에보고 할 때 개발자는 문제 보고서의 일부로 완전한 &quot;.fullschema&quot;출력을 제공해야합니다. sqlite_stat3 및 sqlite_stat4 테이블에는 색인 항목의 샘플이 포함되므로 민감한 데이터가 포함될 수 있으므로 &quot;.fullschema&quot;를 보내지 마십시오.공개 채널을 통한 독점 데이터베이스 출력.</target>
        </trans-unit>
        <trans-unit id="8c41f773b4bec069e65cdeb1f84472339fd67927" translate="yes" xml:space="preserve">
          <source>The &quot;.genfkey&quot; operator has been removed from the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">&quot;.genfkey&quot;연산자가 &lt;a href=&quot;cli&quot;&gt;명령 행 인터페이스&lt;/a&gt; 에서 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6da1e8e52719870c46e4714e803817bbb945c7a2" translate="yes" xml:space="preserve">
          <source>The &quot;.indexes&quot; command works in a similar way to list all of the indexes. If the &quot;.indexes&quot; command is given an argument which is the name of a table, then it shows just indexes on that table.</source>
          <target state="translated">&quot;.indexes&quot;명령은 모든 색인을 나열하는 유사한 방식으로 작동합니다. &quot;.indexes&quot;명령에 테이블 이름 인 인수가 제공되면 해당 테이블의 인덱스 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="332e81eb83bf30c51e9f2eb4830d160fd5e91b60" translate="yes" xml:space="preserve">
          <source>The &quot;.load&quot; command with one argument invokes sqlite3_load_extension() with the zProc parameter set to NULL, causing SQLite to first look for an entry point named &quot;sqlite3_extension_init&quot; and then &quot;sqlite3_X_init&quot; where &quot;X&quot; is derived from the filename. If your extension has an entry point with a different name, simply supply that name as the second argument. For example:</source>
          <target state="translated">하나의 인수가있는 &quot;.load&quot;명령은 zProc 매개 변수가 NULL로 설정된 sqlite3_load_extension ()을 호출하여 SQLite가 먼저 &quot;sqlite3_extension_init&quot;라는 진입 점을 찾은 다음 &quot;sqlite3_X_init&quot;를 찾게되며 여기서 &quot;X&quot;는 파일 이름에서 파생됩니다. 확장에 다른 이름의 진입 점이 있으면 해당 이름을 두 번째 인수로 제공하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e0f642688db88c440c3786a62b2e62ab2274b87" translate="yes" xml:space="preserve">
          <source>The &quot;.parameter&quot; command exists to simplify managing this table. The &quot;.parameter init&quot; command (often abbreviated as just &quot;.param init&quot;) creates the temp.sqlite_parameters table if it does not already exist. The &quot;.param list&quot; command shows all entries in the temp.sqlite_parameters table. The &quot;.param clear&quot; command drops the temp.sqlite_parameters table. The &quot;.param set KEY VALUE&quot; and &quot;.param unset KEY&quot; commands create or delete entries from the temp.sqlite_parameters table.</source>
          <target state="translated">이 테이블 관리를 단순화하기 위해 &quot;.parameter&quot;명령이 존재합니다. &quot;.parameter init&quot;명령 (종종 &quot;.param init&quot;로 축약 됨)은 temp.sqlite_parameters 테이블이없는 경우이를 작성합니다. &quot;.param list&quot;명령은 temp.sqlite_parameters 테이블의 모든 항목을 보여줍니다. &quot;.param clear&quot;명령은 temp.sqlite_parameters 테이블을 삭제합니다. &quot;.param set KEY VALUE&quot;및 &quot;.param unset KEY&quot;명령은 temp.sqlite_parameters 테이블에서 항목을 작성하거나 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="789a156efc523de5bfce09730a51219cae2ec0c9" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command can be augmented with the &quot;--indent&quot; option, in which case it tries to reformat the various CREATE statements of the schema so that they are more easily readable by humans.</source>
          <target state="translated">&quot;. 들여 쓰기&quot;옵션을 사용하여 &quot;.schema&quot;명령을 보강 할 수 있습니다.이 경우 스키마는 사람이보다 쉽게 ​​읽을 수 있도록 스키마의 다양한 CREATE 문을 다시 형식화하려고합니다.</target>
        </trans-unit>
        <trans-unit id="754968254f462d66877df03c1c7cd51953693cab" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command is roughly the same as setting list mode, then entering the following query:</source>
          <target state="translated">&quot;.schema&quot;명령은 설정 목록 모드와 거의 동일하며 다음 쿼리를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="7428559526f83a5c56d268af9889807faae2685e" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the complete schema for the database, or for a single table if an optional tablename argument is provided:</source>
          <target state="translated">&quot;.schema&quot;명령은 데이터베이스 또는 선택적 tablename 인수가 제공되는 경우 단일 테이블에 대한 전체 스키마를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="52ace065300c40138c37799338bd3ec51aca18df" translate="yes" xml:space="preserve">
          <source>The &quot;.schema&quot; command shows the structure of virtual tables.</source>
          <target state="translated">&quot;.schema&quot;명령은 가상 테이블의 구조를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="73bcba8970e82dc921d7f4ec8db20bb33cbfb0a3" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest --init&quot; command creates the selftest table if it does not already exists, then appends entries that check the SHA3 hash of the content of all tables. Subsequent runs of &quot;.selftest&quot; will verify that the database has not been changed in any way. To generates tests to verify that a subset of the tables are unchanged, simply run &quot;.selftest --init&quot; then &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; the selftest rows that refer to tables that are not constant.</source>
          <target state="translated">&quot;.selftest --init&quot;명령은 selftest 테이블이 없으면 작성하고 모든 테이블 내용의 SHA3 해시를 확인하는 항목을 추가합니다. &quot;.selftest&quot;의 후속 실행은 데이터베이스가 변경되지 않았 음을 확인합니다. 테이블의 하위 집합이 변경되지 않았 음을 확인하는 테스트를 생성하려면 &quot;.selftest --init&quot;를 실행 한 다음 상수가 아닌 테이블을 참조하는 자체 테스트 행 을 &lt;a href=&quot;lang_delete&quot;&gt;삭제&lt;/a&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="b23d6efbb796b87124747de656b1313433a59a58" translate="yes" xml:space="preserve">
          <source>The &quot;.selftest&quot; command attempts to verify that a database is intact and is not corrupt. The .selftest command looks for a table in schema named &quot;selftest&quot; and defined as follows:</source>
          <target state="translated">&quot;.selftest&quot;명령은 데이터베이스가 손상되지 않았는지 확인하려고 시도합니다. .selftest 명령은 &quot;selftest&quot;라는 스키마에서 다음과 같이 정의 된 테이블을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="da3394cbf6e430093bb273dc53c5c24290fb42a2" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command is implemented with the help of the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;extension function &quot;sha3_query()&quot;&lt;/a&gt; that is included with the command-line shell.</source>
          <target state="translated">&quot;.sha3sum&quot;명령은 명령 행 쉘에 포함 된 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/shathree.c&quot;&gt;확장 기능 &quot;sha3_query ()&quot;&lt;/a&gt; 의 도움으로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="49607863a0b317eaa9e0bb0334b35c6b17a96a09" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command supports options &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;, and &quot;--sha3-512&quot; to define which variety of SHA3 to use for the hash. The default is SHA3-256.</source>
          <target state="translated">&quot;.sha3sum&quot;명령은 &quot;--sha3-224&quot;, &quot;--sha3-256&quot;, &quot;--sha3-384&quot;및 &quot;--sha3-512&quot;옵션을 지원하여 다양한 SHA3에 사용할 SHA3를 정의합니다. 해시시. 기본값은 SHA3-256입니다.</target>
        </trans-unit>
        <trans-unit id="e496b68fde3cba7a6d3e4d071d1b64676cd89817" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; command takes a single optional argument which is a &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern. If this option is present, only tables whose names match the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; pattern will be hashed.</source>
          <target state="translated">&quot;.sha3sum&quot;명령은 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 패턴 인 단일 선택적 인수를 사용 합니다. 이 옵션이 있으면 이름이 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 패턴 과 일치하는 테이블 만 해시됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e55e4c460c47133735d47238f402c87368287c" translate="yes" xml:space="preserve">
          <source>The &quot;.sha3sum&quot; dot-command computes a &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; hash of the &lt;em&gt;content&lt;/em&gt; of the database. To be clear, the hash is computed over the database content, not its representation on disk. This means, for example, that a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or similar data-preserving transformation does not change the hash.</source>
          <target state="translated">&quot;.sha3sum&quot;도트 명령은 데이터베이스 &lt;em&gt;컨텐츠&lt;/em&gt; 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-3&quot;&gt;SHA3&lt;/a&gt; 해시를 계산 합니다. 분명히 해시는 디스크상의 표현이 아니라 데이터베이스 내용에 대해 계산됩니다. 예를 들어, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 또는 이와 유사한 데이터 보존 변환은 해시를 변경하지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2252b9e19709b03f7ab086b59b1a77291173bd1" translate="yes" xml:space="preserve">
          <source>The &quot;.tables&quot; command is similar to setting list mode then executing the following query:</source>
          <target state="translated">&quot;.tables&quot;명령은 목록 모드를 설정 한 후 다음 쿼리를 실행하는 것과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="9eda9619ee5cbc80757e21696103e58ade470ff1" translate="yes" xml:space="preserve">
          <source>The &quot;.width&quot; command in the example above sets the width of the first column to 12 and the width of the second column to 6. All other column widths were unaltered. You can give as many arguments to &quot;.width&quot; as necessary to specify the widths of as many columns as are in your query results.</source>
          <target state="translated">위 예에서 &quot;.width&quot;명령은 첫 번째 열의 너비를 12로 설정하고 두 번째 열의 너비를 6으로 설정합니다. 다른 모든 열 너비는 변경되지 않았습니다. 쿼리 결과에있는 열의 너비를 지정하는 데 필요한만큼 &quot;.width&quot;에 인수를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d28508cd52964017863df7d9bff1bae6f7b1b73" translate="yes" xml:space="preserve">
          <source>The &quot;1&quot; at the end of the name for the json1 extension is deliberate. The designers anticipate that there will be future incompatible JSON extensions building upon the lessons learned from json1. Once sufficient experience is gained, some kind of JSON extension might be folded into the SQLite core. For now, JSON support remains an extension.</source>
          <target state="translated">json1 확장자의 이름 끝에 &quot;1&quot;이 있습니다. 설계자는 json1에서 배운 교훈을 바탕으로 미래에 호환되지 않는 JSON 확장이있을 것으로 예상합니다. 충분한 경험을 얻으면 어떤 종류의 JSON 확장이 SQLite 코어로 접힐 수 있습니다. 현재 JSON 지원은 확장으로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec1a7b1bff513b8dc885dad8096593de50c679b9" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt;&quot; command ignores an initial UTF-8 BOM.</source>
          <target state="translated">&quot; &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; &quot;명령은 초기 UTF-8 BOM을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="39a3b12173588647fa6bbe9bfdec68cffc6ff3a2" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; must be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt; where the right-most &lt;a href=&quot;syntax/compound-operator&quot;&gt;compound-operator&lt;/a&gt; is either UNION or UNION ALL.</source>
          <target state="translated">&quot; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &quot;는 가장 오른쪽의 &lt;a href=&quot;syntax/compound-operator&quot;&gt;복합 연산자&lt;/a&gt; 가 UNION 또는 UNION ALL 인 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 선택&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6e1ee86a4eb35dd217941c49a4c1f826afe5d0c7" translate="yes" xml:space="preserve">
          <source>The &quot;&lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt;&quot; syntax diagram above attempts to show as much of the SELECT statement syntax as possible in a single diagram, because some readers find that helpful. The following &quot;&lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&quot; is an alternative syntax diagrams that expresses the same syntax but tries to break the syntax down into smaller chunks.</source>
          <target state="translated">위의 &quot; &lt;a href=&quot;syntax/select-stmt&quot;&gt;select-stmt&lt;/a&gt; &quot;구문 다이어그램은 일부 독자가 유용하다고 생각하기 때문에 단일 다이어그램에서 가능한 많은 SELECT 문 구문을 표시하려고 시도합니다. 다음 &quot; &lt;a href=&quot;syntax/factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt; &quot;는 동일한 구문을 표현하지만 구문을 더 작은 청크로 나누는 대체 구문 다이어그램입니다.</target>
        </trans-unit>
        <trans-unit id="9f631ef63bea49256ea8a2d7bafc4554c3faedfb" translate="yes" xml:space="preserve">
          <source>The &quot;Application ID&quot; set by &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt;.</source>
          <target state="translated">에 의해 &quot;응용 프로그램 ID&quot;세트 &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA는 APPLICATION_ID&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f5d1070df133cbc828d184fa205995550d45fd" translate="yes" xml:space="preserve">
          <source>The &quot;CREATE TABLE&quot; command is used to create a new table in an SQLite database. A CREATE TABLE command specifies the following attributes of the new table:</source>
          <target state="translated">&quot;CREATE TABLE&quot;명령은 SQLite 데이터베이스에서 새 테이블을 작성하는 데 사용됩니다. CREATE TABLE 명령은 새 테이블의 다음 속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5736b1f20cbfd4541c75d144c2bb263b3a789707" translate="yes" xml:space="preserve">
          <source>The &quot;INDEXED BY index-name&quot; phrase specifies that the named index must be used in order to look up values on the preceding table. If index-name does not exist or cannot be used for the query, then the preparation of the SQL statement fails. The &quot;NOT INDEXED&quot; clause specifies that no index shall be used when accessing the preceding table, including implied indices create by UNIQUE and PRIMARY KEY constraints. However, the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; can still be used to look up entries even when &quot;NOT INDEXED&quot; is specified.</source>
          <target state="translated">&quot;INDEXED BY index-name&quot;구문은 이전 표에서 값을 조회하기 위해 명명 된 색인을 사용해야 함을 지정합니다. index-name이 없거나 조회에 사용할 수없는 경우 SQL 문 준비에 실패합니다. &quot;NOT INDEXED&quot;절은 UNIQUE 및 PRIMARY KEY 제약 조건에 의해 생성 된 암시 적 인덱스를 포함하여 앞의 테이블에 액세스 할 때 인덱스를 사용하지 않도록 지정합니다. 그러나 &quot;NOT INDEXED&quot;가 지정된 경우에도 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 사용하여 항목을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21fa27bc6e581b8fb060c98b51ebafd394898e71" translate="yes" xml:space="preserve">
          <source>The &quot;INSERT INTO</source>
          <target state="translated">&quot;삽입</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
