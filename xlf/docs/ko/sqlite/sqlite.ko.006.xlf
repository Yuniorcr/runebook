<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="0059fb3429a6e57de6b5c01cc5ac92570ab99c32" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">인수 iVal은 0보다 크거나 같아야하며 현재 변경의 영향을받는 테이블의 열 수보다 작아야합니다. 그렇지 않으면 &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="12689143ab00ad889ba38fb7f63c86273b0da663" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">인수 iVal은 0보다 크거나 같아야하며 현재 변경의 영향을받는 테이블의 열 수보다 작아야합니다. 그렇지 않으면 &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="71b5b8ce6122da2fb2f466eddd7275074f8cc26d" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">인수 pIn은 변경 집합 nIn 바이트 크기를 포함하는 버퍼를 가리켜 야합니다. 이 함수는 첫 번째 인수로 전달 된 rebaser 개체의 구성에 따라 변경 집합의 복사본을 할당하고 채 웁니다. 성공하면 (* ppOut)은 리베이스 변경 집합을 포함하는 새 버퍼를 가리 키도록 설정되고 (* pnOut)은 바이트 단위의 크기를 가리키고 SQLITE_OK가 반환됩니다. 결국 sqlite3_free ()를 사용하여 새 버퍼를 해제하는 것은 호출자의 책임입니다. 그렇지 않고 오류가 발생하면 (* ppOut) 및 (* pnOut)이 0으로 설정되고 SQLite 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1502f4d9bcf958ec2d3f9df8d5434c6f3fb95622" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">인수 pIn은 크기의 변경 세트 nIn 바이트를 포함하는 버퍼를 가리켜 야합니다. 이 함수는 첫 번째 인수로 전달 된 rebaser 객체의 구성에 따라 rebased rebased rebased의 사본으로 버퍼를 할당하고 채 웁니다. 성공하면 (* ppOut)은 재 기반 변경 세트를 포함하는 새 버퍼를 가리 키도록 설정되고 (* pnOut)은 바이트 단위의 크기를 나타내며 SQLITE_OK가 리턴됩니다. sqlite3_free ()를 사용하여 새 버퍼를 결국 해제하는 것은 호출자의 책임입니다. 그렇지 않으면 오류가 발생하면 (* ppOut) 및 (* pnOut)이 0으로 설정되고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3273cfe93e49705347b0b90c1dbaf9e32a834424" translate="yes" xml:space="preserve">
          <source>Argument zFromDb must be the name of a database (&quot;main&quot;, &quot;temp&quot; etc.) attached to the same database handle as the session object that contains a table compatible with the table attached to the session by this function. A table is considered compatible if it:</source>
          <target state="translated">인수 zFromDb는이 함수에 의해 세션에 첨부 된 테이블과 호환되는 테이블을 포함하는 세션 오브젝트와 동일한 데이터베이스 핸들에 첨부 된 데이터베이스 이름 ( &quot;main&quot;, &quot;temp&quot;등)이어야합니다. 다음과 같은 경우 테이블이 호환 가능한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c2dd08aa3192624f9fd5e4d0f584709c36b430c5" translate="yes" xml:space="preserve">
          <source>Arguments on the virtual table name are matched to &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in order. The number of arguments can be less than the number of hidden columns, in which case the latter hidden columns are unconstrained. However, an error results if there are more arguments than there are hidden columns in the virtual table.</source>
          <target state="translated">가상 테이블 이름의 인수는 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열과&lt;/a&gt; 순서대로 일치합니다 . 인수의 수는 숨겨진 열의 수보다 적을 수 있으며,이 경우 후자의 숨겨진 열은 제한되지 않습니다. 그러나 가상 테이블에 숨겨진 열이있는 것보다 많은 인수가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90539d8182e17636548ae12105ee212ec9b16743" translate="yes" xml:space="preserve">
          <source>As SQLite developers edit the SQLite source code, they run the &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script to track the performance impact of changes. This script compiles the speedtest1.c program, runs it under cachegrind, processes the cachegrind output using the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL script, then saves the results in a series of text files. Typical output from the speed-check.sh script looks like this:</source>
          <target state="translated">SQLite 개발자는 SQLite 소스 코드를 편집 할 때 &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; 셸 스크립트를 실행하여 변경으로 인한 성능 영향을 추적합니다. 이 스크립트는 speedtest1.c 프로그램을 컴파일하고 cachegrind에서 실행하며 &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL 스크립트를 사용하여 cachegrind 출력을 처리 한 다음 결과를 일련의 텍스트 파일로 저장합니다. speed-check.sh 스크립트의 일반적인 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ed7acd0a6e6b88f39315ac5d476eef951a2dd64" translate="yes" xml:space="preserve">
          <source>As a REAL value that is the fractional &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt;.</source>
          <target state="translated">소수 &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;줄리안 일 수인&lt;/a&gt; REAL 값으로 .</target>
        </trans-unit>
        <trans-unit id="a4eeeee2e0c94cffee5c99d0db2b5529b4ec1659" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8601 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">ISO-8601 형식의 TEXT 문자열로. 예 : '2018-04-02 12:13:46'.</target>
        </trans-unit>
        <trans-unit id="e71c00fe61fb07ca9e09493bb8ec226ec4260341" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8610 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">ISO-8610 형식의 TEXT 문자열로. 예 : '2018-04-02 12:13:46'.</target>
        </trans-unit>
        <trans-unit id="1f5eb53c0fa9975ea0940d4a4405ff35765d1d45" translate="yes" xml:space="preserve">
          <source>As a performance optimization, reduce actions in the Lemon input grammar are allowed to contain comments of the form &quot;/*A-overwrites-Z*/&quot; to indicate that the semantic value &quot;A&quot; on the right-hand side of the rule is allowed to directly overwrite the semantic value &quot;Z&quot; on the left-hand side. This simple optimization reduces the number of stack operations in the push-down automaton used to parse the input grammar, and thus improve performance of the parser. It also makes the generated code a little smaller.</source>
          <target state="translated">성능 최적화로서, 레몬 입력 문법의 감소 조치에는 규칙의 오른쪽에 의미 상 값 &quot;A&quot;가 있음을 표시하기 위해 &quot;/ * A-overwrites-Z * /&quot;형식의 주석이 포함될 수 있습니다. 왼쪽의 의미 값 &quot;Z&quot;를 직접 덮어 쓸 수 있습니다. 이 간단한 최적화는 입력 문법을 구문 분석하는 데 사용되는 푸시 다운 오토 마톤의 스택 작업 수를 줄이고 파서의 성능을 향상시킵니다. 또한 생성 된 코드를 약간 작게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7bcc1829db91ffdb7536f92aca2feacdc8bcb274" translate="yes" xml:space="preserve">
          <source>As an FTS5 bareword that is not &quot;AND&quot;, &quot;OR&quot; or &quot;NOT&quot; (case sensitive). An FTS5 bareword is a string of one or more consecutive characters that are all either:</source>
          <target state="translated">&quot;AND&quot;, &quot;OR&quot;또는 &quot;NOT&quot;(대소 문자 구분)가 아닌 FTS5 베어 워드입니다. FTS5 베어 워드는 하나 이상의 연속 문자로 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3f6cab6c41155dd3c9ab5be0d8403065e3d7dbaf" translate="yes" xml:space="preserve">
          <source>As an INTEGER number of seconds since 1970 (also known as &quot;unix time&quot;).</source>
          <target state="translated">1970 년 이후의 초 단위의 INTEGER 수 ( &quot;유닉스 시간&quot;이라고도 함).</target>
        </trans-unit>
        <trans-unit id="32bbd071581bca01328b9dfe1b573f6b34f404d8" translate="yes" xml:space="preserve">
          <source>As an alternative to step 3 above, the transaction may be rolled back. Transaction rollback is described in section</source>
          <target state="translated">위의 3 단계에 대한 대안으로 트랜잭션이 롤백 될 수 있습니다. 트랜잭션 롤백은 섹션에 설명되어 있습니다</target>
        </trans-unit>
        <trans-unit id="71c1a7847b731be97050a398f7845485ca21aaa1" translate="yes" xml:space="preserve">
          <source>As an example of how UPDATE-FROM can be useful, suppose you have a point-of-sale application that accumulates purchases in the SALES table. At the end of the day, you want to adjust the INVENTORY table according to the daily sales. To do this, you can run an UPDATE against the INVENTORY table that adjusts the quantity by the aggregated sales for the day. The statement would look like this:</source>
          <target state="translated">UPDATE-FROM이 어떻게 유용 할 수 있는지에 대한 예로, SALES 테이블에 구매를 누적하는 POS 애플리케이션이 있다고 가정합니다. 하루가 끝나면 일일 ​​판매량에 따라 INVENTORY 테이블을 조정하려고합니다. 이렇게하려면 해당 날짜의 총 판매량으로 수량을 조정하는 INVENTORY 테이블에 대해 UPDATE를 실행할 수 있습니다. 문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="131746c3b1aff392f599c85628677c24f8811860" translate="yes" xml:space="preserve">
          <source>As an example of the result table format, suppose a query result is as follows:</source>
          <target state="translated">결과 테이블 형식의 예로 쿼리 결과가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="592d95d98cfd4f715eed1be5091215e09168934a" translate="yes" xml:space="preserve">
          <source>As an example, consider a virtual table implementation that provides read-only access to existing comma-separated-value (CSV) files on disk. There is no backing store that needs to be created or initialized for such a virtual table (since the CSV files already exist on disk) so the xCreate and xConnect methods will be identical for that module.</source>
          <target state="translated">예를 들어, 디스크의 기존 CSV (쉼표로 분리 된 값) 파일에 대한 읽기 전용 액세스를 제공하는 가상 테이블 구현을 고려하십시오. CSV 파일이 디스크에 이미 존재하기 때문에 이러한 가상 테이블에 대해 작성 또는 초기화해야하는 백업 저장소가 없으므로 해당 모듈에 대해 xCreate 및 xConnect 메소드가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0e3486a0e62ced4a8499838d1b8b7393bbcb9f1f" translate="yes" xml:space="preserve">
          <source>As an example, consider creating a two-dimensional R*Tree index for use in spatial queries:</source>
          <target state="translated">예를 들어, 공간 쿼리에 사용하기 위해 2 차원 R * Tree 인덱스를 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1f3a827b13a126faa4b33b0ce651746d14a8fc48" translate="yes" xml:space="preserve">
          <source>As an example, consider the following query:</source>
          <target state="translated">예를 들어, 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="22e02419a6c1aa60126918f747f9d30c0add3ddc" translate="yes" xml:space="preserve">
          <source>As an example, consider the following table that tracks dollar-amount changes on various &quot;accounts&quot;:</source>
          <target state="translated">예를 들어, 다양한 &quot;계정&quot;에 대한 달러 금액 변경을 추적하는 다음 표를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9685f258b372a754415995a52cb6b9f9c3a80f7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose someone (perhaps a customer) asks you: &quot;What ever became of that 'prefer-coroutine-sort-subquery' branch from two years ago?&quot; You might try to answer the query by consulting the history in your version control system, thusly:</source>
          <target state="translated">예를 들어, 누군가 (아마도 고객)가 &quot;2 년 전에 나온 '선호-코르 테인-소트-하위 쿼리'브랜치 중 무엇이 되었습니까?&quot; 버전 제어 시스템의 히스토리를 참조하여 쿼리에 응답하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34ff54cf6acce621207ec9ac9f6485fedf9ef893" translate="yes" xml:space="preserve">
          <source>As an example, the following graphic:</source>
          <target state="translated">예를 들어, 다음 그래픽 :</target>
        </trans-unit>
        <trans-unit id="d8a7709446ce5823dd6ac2917092a6664f0dbd82" translate="yes" xml:space="preserve">
          <source>As an example, the following setup causes TCL to throw an error if an SQL statement contains an parameter that does not match any global TCL variable:</source>
          <target state="translated">예를 들어, 다음 명령문은 SQL 문에 글로벌 TCL 변수와 일치하지 않는 매개 변수가 포함 된 경우 TCL에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0ed757795f16facadb1fc50b83304333bb04670f" translate="yes" xml:space="preserve">
          <source>As an example, the following table show the relative sizes for an SQLite Archive, a ZIP Archive, and a Tarball of the 1,743 files in the SQLite 3.22.0 source tree:</source>
          <target state="translated">예를 들어, 다음 표는 SQLite 3.22.0 소스 트리에서 1,743 개 파일의 SQLite Archive, ZIP Archive 및 Tarball의 상대 크기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9d15dfd61e0635160b8312b26c2789af818a9391" translate="yes" xml:space="preserve">
          <source>As an ordinary SQLite table, &quot;wordcount&quot; is implemented as two separate B-Trees. The main table uses the hidden rowid value as the key and stores the &quot;word&quot; and &quot;cnt&quot; columns as data. The &quot;TEXT PRIMARY KEY&quot; phrase of the CREATE TABLE statement causes the creation of an &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt; on the &quot;word&quot; column. This index is a separate B-Tree that uses &quot;word&quot; and the &quot;rowid&quot; as the key and stores no data at all. Note that the complete text of every &quot;word&quot; is stored twice: once in the main table and again in the index.</source>
          <target state="translated">일반적인 SQLite 테이블 인 &quot;wordcount&quot;는 두 개의 개별 B- 트리로 구현됩니다. 기본 테이블은 숨겨진 rowid 값을 키로 사용하고 &quot;word&quot;및 &quot;cnt&quot;열을 데이터로 저장합니다. CREATE TABLE 문의 &quot;TEXT PRIMARY KEY&quot;구문은 &quot;word&quot;열에 &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;고유 인덱스&lt;/a&gt; 를 생성 합니다. 이 인덱스는 &quot;word&quot;와 &quot;rowid&quot;를 키로 사용하고 데이터를 전혀 저장하지 않는 별도의 B-Tree입니다. 모든 &quot;단어&quot;의 전체 텍스트는 기본 테이블에 한 번, 인덱스에 다시 두 번 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8276f7702973f7730b88b6137faf5d630b77f015" translate="yes" xml:space="preserve">
          <source>As before, SQLite does single binary search for the range of rows in the covering index that satisfy the WHERE clause, the scans that range from top to bottom to get the desired results. The rows that satisfy the WHERE clause are guaranteed to be adjacent since the WHERE clause is an equality constraint on the left-most column of the index. And by scanning the matching index rows from top to bottom, the output is guaranteed to be ordered by state since the state column is the very next column to the right of the fruit column. And so the resulting query is very efficient.</source>
          <target state="translated">이전과 마찬가지로 SQLite는 WHERE 절을 만족하는 커버링 인덱스에서 행 범위에 대한 단일 이진 검색을 수행합니다. 원하는 결과를 얻기 위해 위에서 아래로 스캔합니다. WHERE 절이 색인의 가장 왼쪽 열에 대한 등식 제한 조건이므로 WHERE 절을 만족시키는 행은 인접해야합니다. 그리고 일치하는 인덱스 행을 위에서 아래로 스캔하면 상태 열이 과일 열 오른쪽의 바로 다음 열이므로 상태별로 출력이 정렬됩니다. 결과 쿼리는 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="15882cefbefb220ce1658791117147edd8cba359" translate="yes" xml:space="preserve">
          <source>As before, the Column instruction uses cursor P1 and pushes the data record in column P2 (1, column &quot;two&quot;) onto the stack. The Integer instruction pushes the value 50 onto the top of the stack. After these two instructions the stack looks like:</source>
          <target state="translated">이전과 같이 열 명령어는 커서 P1을 사용하고 열 P2 (1, 열 &quot;2&quot;)의 데이터 레코드를 스택으로 푸시합니다. 정수 명령어는 값 50을 스택의 상단으로 푸시합니다. 이 두 가지 지침을 따르면 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c0707574912e68bc0443d44af5e83d6ee57452b" translate="yes" xml:space="preserve">
          <source>As before, the second insert on the left will fail because the comparison will convert both strings into floating-point number first and the only difference in the strings is in the 20-th digit which exceeds the resolution of a 64-bit float. In contrast, the second insert on the right will work because in that case, the numbers being inserted are strings and are compared using memcmp().</source>
          <target state="translated">이전과 같이 왼쪽의 두 번째 삽입은 비교에서 두 문자열을 부동 소수점 숫자로 먼저 변환하고 문자열의 유일한 차이는 64 번째 부동 소수점의 해상도를 초과하는 20 번째 자리에 있기 때문에 실패합니다. 반대로 오른쪽의 두 번째 삽입은 작동하는 경우 삽입되는 숫자는 문자열이며 memcmp ()를 사용하여 비교되기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="021a9e62497cd6d1534e29c131c8485644cff8ee" translate="yes" xml:space="preserve">
          <source>As can be seen above, a single run of multitest.tcl invokes th3make dozens of times and takes between 12 and 24 CPU hours. The middle section of the output shows the arguments to each individual th3make run and the result and elapse time for that th3make. All build products and output for the separate th3make runs are captures in subdirectories for post-test analysis. The two-line summary at the bottom shows the total number of errors and tests over all th3make runs and the total elapse time, together with the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; information for the version of SQLite that was tested. This summary information is recorded in the &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; during final testing.</source>
          <target state="translated">위에서 볼 수 있듯이 multitest.tcl의 단일 실행은 th3make를 수십 번 호출하며 CPU 시간은 12-24 시간입니다. 출력의 중간 부분에는 각 th3make 실행에 대한 인수와 해당 th3make에 대한 결과 및 경과 시간이 표시됩니다. 별도의 th3make 실행에 대한 모든 빌드 제품 및 출력은 테스트 후 분석을 위해 서브 디렉토리에서 캡처됩니다. 하단의 두 줄 요약 은 테스트 된 SQLite 버전에 대한 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 정보 와 함께 모든 th3make 실행에 대한 총 오류 및 테스트 수와 총 경과 시간을 보여줍니다 . 이 요약 정보는 최종 테스트 중에 &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;릴리스 점검 목록에&lt;/a&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="a57eec57195e396346032e284f403497e2a6ca2c" translate="yes" xml:space="preserve">
          <source>As far as we can tell, the SQL language specification allows the use of manifest typing. Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and Python.</source>
          <target state="translated">우리가 알 수있는 한 SQL 언어 사양은 매니페스트 입력을 사용할 수 있습니다. 그럼에도 불구하고 대부분의 다른 SQL 데이터베이스 엔진은 정적으로 유형이 지정되므로 일부 사람들은 매니페스트 유형 사용이 SQLite의 버그라고 생각합니다. 그러나 SQLite의 저자는 이것이 기능이라는 것을 매우 강하게 느낍니다. SQLite에서 매니페스트 타이핑을 사용하는 것은 실제로 Tcl 및 Python과 같이 동적으로 유형이 지정된 프로그래밍 언어와 함께 사용될 때 SQLite를보다 안정적이고 사용하기 쉽게 만드는 것으로 입증 된 의도적 인 디자인 결정입니다.</target>
        </trans-unit>
        <trans-unit id="fc29e0fdbff3d25477a8e029f9259bac6f50556e" translate="yes" xml:space="preserve">
          <source>As for all other SQLite tables, virtual or otherwise, data is retrieved from FTS tables using a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="translated">다른 모든 SQLite 테이블의 경우 가상 또는 다른 방법으로 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 사용하여 FTS 테이블에서 데이터를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="e10a21db398e4cbe3920a0271ec03a17da9374a2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;, the journal file might be truncated to zero length or its header might be overwritten with zeros as an optimization on systems where deleting a file is expensive. Either way, the journal is no longer hot after this step.</source>
          <target state="translated">&lt;a href=&quot;#section_3_11&quot;&gt;섹션 3.11&lt;/a&gt; 에서처럼 저널 파일은 길이가 0으로 잘 리거나 파일 삭제 비용이 높은 시스템에서 최적화로 헤더가 0으로 겹쳐 써질 수 있습니다. 어느 쪽이든,이 단계 후에 저널이 더 이상 뜨겁지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a052665302d7ed15dacb760a0e1d99f7e61c18a" translate="yes" xml:space="preserve">
          <source>As in the INSERT example, we push the database number P1 (0, the main database) onto the stack and use OpenWrite to open the cursor P1 on table P2 (base page 3, &quot;examp&quot;) for modification.</source>
          <target state="translated">INSERT 예제에서와 같이 데이터베이스 번호 P1 (0, 주 데이터베이스)을 스택으로 푸시하고 OpenWrite를 사용하여 수정을 위해 테이블 ​​P2 (기본 페이지 3, &quot;examp&quot;)에서 커서 P1을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="493b86f021b95461d337801ffc16a105b55e8b55" translate="yes" xml:space="preserve">
          <source>As in the SELECT example, the &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction rewinds the cursor to the beginning of the table, readying it for use in the loop body.</source>
          <target state="translated">SELECT 예에서와 같이 &lt;a href=&quot;opcode#Rewind&quot;&gt;되감기&lt;/a&gt; 명령은 커서를 테이블의 시작 부분으로 되감기 고 루프 본문에서 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="164cc333da63b4862e96f8a93857b770263a0e06" translate="yes" xml:space="preserve">
          <source>As is the case for a</source>
          <target state="translated">의 경우와 마찬가지로</target>
        </trans-unit>
        <trans-unit id="ed24902923099bb89f817d03e0f964e2ddf3fe73" translate="yes" xml:space="preserve">
          <source>As its name implies, an R*Tree is organized as a tree. Each node of the tree is a bounding box. The root of the tree is a bounding box that encapsulates all elements of the tree. Beneath the root are a number of subtrees (typically 20 or more) each with their own smaller bounding boxes and each containing some subset of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until finally one reaches the leaves of the tree which are the actual R*Tree entries.</source>
          <target state="translated">이름에서 알 수 있듯이 R * Tree는 트리로 구성됩니다. 트리의 각 노드는 경계 상자입니다. 트리의 루트는 트리의 모든 요소를 ​​캡슐화하는 경계 상자입니다. 루트 아래에는 각각 더 작은 경계 상자가 있고 각각 R * Tree 항목의 일부를 포함하는 여러 하위 트리 (일반적으로 20 개 이상)가 있습니다. 서브 트리는 서브-서브 트리를 가질 수 있으며, 최종적으로 실제 R * Tree 엔트리 인 트리의 잎에 도달 할 때까지 계속된다.</target>
        </trans-unit>
        <trans-unit id="1329f3ec0fa61448c27dc490e807fec1b74fd581" translate="yes" xml:space="preserve">
          <source>As its name suggests, the &quot;close&quot; method to an SQLite database just closes the database. This has the side-effect of deleting the</source>
          <target state="translated">이름에서 알 수 있듯이 SQLite 데이터베이스에 대한 &quot;close&quot;메소드는 데이터베이스를 닫습니다. 이것은 삭제하는 부작용이 있습니다</target>
        </trans-unit>
        <trans-unit id="3b9e6df535e040569dafb3fcef3111ff226a3e67" translate="yes" xml:space="preserve">
          <source>As long as the buffer size is greater than zero, sqlite3_snprintf() guarantees that the buffer is always zero-terminated. The first parameter &quot;n&quot; is the total size of the buffer, including space for the zero terminator. So the longest string that can be completely written will be n-1 characters.</source>
          <target state="translated">버퍼 크기가 0보다 큰 한, sqlite3_snprintf ()는 버퍼가 항상 0으로 종료되도록 보장합니다. 첫 번째 매개 변수 &quot;n&quot;은 제로 터미네이터를위한 공간을 포함하여 버퍼의 전체 크기입니다. 따라서 완전히 쓸 수있는 가장 긴 문자열은 n-1 자입니다.</target>
        </trans-unit>
        <trans-unit id="26ea5ee053d47ffa17dd452debb3d0d447e3ffce" translate="yes" xml:space="preserve">
          <source>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">입력 매개 변수가 올 바르면 형식 변환 중에 메모리 부족 오류가 발생하는 경우에만 이러한 루틴이 실패 할 수 있습니다. 다음과 같은 인터페이스 하위 집합 만 메모리 부족 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc7938d9d029402b8371ec96dc41a03cdd95d8f8" translate="yes" xml:space="preserve">
          <source>As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">입력 매개 변수가 올바른 한 형식 변환 중에 메모리 부족 오류가 발생하는 경우에만이 루틴이 실패합니다. 다음과 같은 인터페이스 하위 집합 만 메모리 부족 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af3758ac84a3f79558343e605f45f43dad96f8ef" translate="yes" xml:space="preserve">
          <source>As new versions of SQLite are released, repeat steps 3.6 and 3.7 to add changes in the new release to the private branch. Additional private changes can be made on the private branch in between releases if desired.</source>
          <target state="translated">새 버전의 SQLite가 릴리스되면 3.6 및 3.7 단계를 반복하여 새 릴리스의 변경 사항을 개인 브랜치에 추가하십시오. 원하는 경우 릴리스간에 개인 브랜치에서 추가 개인 변경을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e442983efbc639e95659cc425a72881ca75f93d3" translate="yes" xml:space="preserve">
          <source>As noted above, there really is no such thing as a &quot;sqlite3_column()&quot; function in the SQLite API. Instead, what we here call &quot;sqlite3_column()&quot; is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.</source>
          <target state="translated">위에서 언급했듯이 SQLite API에는 실제로 &quot;sqlite3_column ()&quot;함수가 없습니다. 대신, 여기에서 &quot;sqlite3_column ()&quot;이라고 부르는 것은 다양한 데이터 유형의 결과 집합에서 값을 반환하는 전체 함수 계열의 자리 표시 자입니다. 이 패밀리에는 결과의 크기 (문자열 또는 BLOB 인 경우)와 결과 세트의 열 수를 리턴하는 루틴도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f8a41bee17850d3fdbafd1837635d4f3b48596" translate="yes" xml:space="preserve">
          <source>As of 2017-03-12, you must use Fossil version 2.0 or later for the following instructions to work. The SQLite repository started using artifacts named using SHA3 hashes instead of SHA1 hashes on that date, and Fossil 2.0 or later is needed in order to understand the new SHA3 hashes. To find out what version of Fossil you are running, type &quot;fossil -v&quot;.</source>
          <target state="translated">2017-03-12부터 다음 지침이 작동하려면 Fossil 버전 2.0 이상을 사용해야합니다. SQLite 리포지토리는 해당 날짜의 SHA1 해시 대신 SHA3 해시를 사용하여 명명 된 아티팩트를 사용하기 시작했으며 새 SHA3 해시를 이해하려면 Fossil 2.0 이상이 필요합니다. 실행중인 Fossil 버전을 확인하려면 &quot;fossil -v&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="46e28b72fbe9e739630682b02359c85a23e23fe2" translate="yes" xml:space="preserve">
          <source>As of 2018-05-19, the TH3 source tree consists and well over 500,000 lines of source code in 1709 separate files.</source>
          <target state="translated">2018-05-19 현재 TH3 소스 트리는 1709 개의 개별 파일에 500,000 개가 넘는 소스 코드로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="32045934e18d7d7235684ae81bb4ad3e112f0c5b" translate="yes" xml:space="preserve">
          <source>As of 2019-03-20, there is now an &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;official Git mirror&lt;/a&gt; of the SQLite sources on GitHub.</source>
          <target state="translated">2019-03-20 현재 GitHub에 SQLite 소스 의 &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;공식 Git 미러&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e28505b65fc1d015c678e6ae0f3c3ddff268608" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10), the SQLite library consists of approximately 138.9 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 662 times as much test code and test scripts - 91946.2 KSLOC.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;버전 3.29.0&lt;/a&gt; (2019년 7월 10일), SQLite는 라이브러리는 C 코드의 약 138.9 KSLOC로 구성되어 있습니다. (KSLOC는 수천 개의 &quot;소스 라인 코드&quot;를 의미합니다. 즉, 빈 줄과 주석을 제외한 코드 줄을 의미합니다.) 비교하면 프로젝트의 테스트 코드와 테스트 스크립트는 662 배나됩니다-91946.2 KSLOC.</target>
        </trans-unit>
        <trans-unit id="2f1c2b6d73cf26867292aed34f667ddc2bada8a1" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;version 3.33.0&lt;/a&gt; (2020-08-14), the SQLite library consists of approximately 143.4 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 640 times as much test code and test scripts - 91911.0 KSLOC.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_33_0.html&quot;&gt;버전 3.33.0&lt;/a&gt; (2020년 8월 14일), SQLite는 라이브러리는 C 코드의 약 143.4 KSLOC로 구성되어 있습니다. (KSLOC는 수천 개의 &quot;Source Lines Of Code&quot;또는 즉, 빈 줄과 주석을 제외한 코드 줄을 의미합니다.) 이에 비해 프로젝트에는 640 배 많은 테스트 코드와 테스트 스크립트가 있습니다.-91911.0 KSLOC.</target>
        </trans-unit>
        <trans-unit id="a53c8d218bf20b0261060ea362ee56f13c07c935" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14), SQLite supports &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. But enforcement of foreign key constraints is turned off by default (for backwards compatibility). To enable foreign key constraint enforcement, run &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt; or compile with &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; (2009-10-14), SQLite는 지원 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건을&lt;/a&gt; . 그러나 외래 키 제약 조건 적용은 기본적으로 해제되어 있습니다 (이전 버전과의 호환성을 위해). 외래 키 제약 조건 적용을 활성화하려면 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON을&lt;/a&gt; 실행 하거나 &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1로&lt;/a&gt; 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="836b2728d9d516fbe942ba314e801009ae9980b0" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12), SQLite includes a new virtual table module called &quot;fts4aux&quot;, which can be used to inspect the full-text index of an existing FTS table directly. Despite its name, fts4aux works just as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only. The only way to modify the contents of an fts4aux table is by modifying the contents of the associated FTS table. The fts4aux module is automatically included in all &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;builds that include FTS&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;버전 3.7.6&lt;/a&gt; (2011-04-12), SQLite는 직접 기존 FTS 테이블의 전체 텍스트 인덱스를 검사 할 수 있습니다 &quot;fts4aux&quot;라는 새로운 가상 테이블 모듈을 포함한다. 이름에도 불구하고 fts4aux는 FTS4 테이블과 마찬가지로 FTS3 테이블에서도 작동합니다. Fts4aux 테이블은 읽기 전용입니다. fts4aux 테이블의 내용을 수정하는 유일한 방법은 관련 FTS 테이블의 내용을 수정하는 것입니다. fts4aux 모듈은 &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;FTS가&lt;/a&gt; 포함 된 모든 빌드에 자동으로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d225f240bc36e795cb50632150d857ce4c4d78e" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. If using one of the two autoconf build system, FTS5 is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script. (FTS5 is currently disabled by default for the source-tree configure script and enabled by default for the amalgamation configure script, but these defaults might change in the future.)</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015년 10월 14일) FTS5는 SQLite는의 일부로 포함되어 &lt;a href=&quot;amalgamation&quot;&gt;융합&lt;/a&gt; . 두 개의 autoconf 빌드 시스템 중 하나를 사용하는 경우 구성 스크립트를 실행할 때 &quot;--enable-fts5&quot;옵션을 지정하여 FTS5를 활성화합니다. (FTS5는 현재 소스 트리 구성 스크립트에 대해 기본적으로 비활성화되고 통합 구성 스크립트에 대해 기본적으로 활성화되어 있지만 이러한 기본값은 향후 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="03eb89fc06866a1260f6276654306363ba727d94" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It is disabled by default. If using the two autoconf build system, it is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015년 10월 14일) FTS5는 SQLite는의 일부로 포함되어 &lt;a href=&quot;amalgamation&quot;&gt;융합&lt;/a&gt; . 기본적으로 비활성화되어 있습니다. 두 개의 autoconf 빌드 시스템을 사용하는 경우 configure 스크립트를 실행할 때 &quot;--enable-fts5&quot;옵션을 지정하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cba18acfc338d803dd183b86646f960bc3ebd65" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.16.0 (2017-01-02), the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains a dot-command &quot;.imposter&quot; that does all of the work of setting up a transient imposter table. Instead of making multiple calls to sqlite3_test_control() and figuring out and invoking a compatible CREATE TABLE statement, a transient imposter table can be constructed as follows:</source>
          <target state="translated">SQLite 3.16.0 (2017-01-02)부터 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에는 임시 임 포스터 테이블 설정 작업을 모두 수행하는 도트 명령 &quot;.imposter&quot;가 포함되어 있습니다. sqlite3_test_control ()을 여러 번 호출하고 호환 가능한 CREATE TABLE 문을 알아 내고 호출하는 대신 임시 임 포스터 테이블을 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a2e1c87379924c2c171b5738373e64a2f944b7" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.27.0 (2019-02-07) the use of a double-quoted string literal causes a warning message to be sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.27.0 (2019-02-07)부터 큰 따옴표로 묶인 문자열 리터럴을 사용하면 경고 메시지가 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="477279c68e157e3c69007f56a275a12b81ee766f" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.29.0 (2019-07-10) the use of double-quoted string literals can be disabled at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. The default settings can be altered at compile-time using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; compile-time option. Application developers are encouraged to compile using -DSQLITE_DQS=0 in order to disable the double-quoted string literal misfeature by default. If that is not possible, then disable double-quoted string literals for individual database connections using C-code like this:</source>
          <target state="translated">SQLite 3.29.0 (2019-07-10) &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;부터는 &lt;/a&gt;&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; 및 SQLITE_DBCONFIG_DQS_DML 작업을 사용하여 큰 따옴표로 묶인 문자열 리터럴을 런타임에 비활성화 할 수 있습니다 . &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = &lt;/a&gt;&lt;i&gt;N&lt;/i&gt; 컴파일 시간 옵션을 사용하여 컴파일시 기본 설정을 변경할 수 있습니다 . 응용 프로그램 개발자는 기본적으로 큰 따옴표로 묶인 문자열 리터럴 오작동을 비활성화하기 위해 -DSQLITE_DQS = 0을 사용하여 컴파일하는 것이 좋습니다. 이것이 가능하지 않은 경우 다음과 같이 C 코드를 사용하여 개별 데이터베이스 연결에 대해 큰 따옴표로 묶인 문자열 리터럴을 비활성화하십시오.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="27ccd6edc0578e2c50724724d1f7e72fc2202881" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the WAL file for a single transaction should be proportional in size to the transaction itself. Pages that are changed by the transaction should only be written into the WAL file once. However, with older versions of SQLite, the same page might be written into the WAL file multiple times if the transaction grows larger than the page cache.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;버전 3.11.0&lt;/a&gt; (2016-02-15)부터 단일 트랜잭션의 WAL 파일 크기는 트랜잭션 자체에 비례해야합니다. 트랜잭션에 의해 변경된 페이지는 WAL 파일에 한 번만 기록되어야합니다. 그러나 이전 버전의 SQLite에서는 트랜잭션이 페이지 캐시보다 커지면 동일한 페이지가 WAL 파일에 여러 번 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9002d4afcf5621573059e14d645945f49cc82521" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;version 3.6.1&lt;/a&gt; (2008-08-06), the soft heap limit only applies to the general-purpose memory allocator. The soft heap limit does not know about or interact with the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; or the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;. This deficiency will likely be addressed in a future release.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;버전 3.6.1&lt;/a&gt; (2008-08-06)부터 소프트 힙 제한은 범용 메모리 할당 자에만 적용됩니다. 소프트 힙 한계는 &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache 메모리 할당 자&lt;/a&gt; 또는 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자에&lt;/a&gt; 대해 알고 있거나 상호 작용하지 않습니다 . 이 결함은 향후 릴리스에서 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b175c36534eb0163084a39638e664737aba3d613" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt;, the default setting for foreign key enforcement is OFF. However, that might change in a future release of SQLite. The default setting for foreign key enforcement can be specified at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; preprocessor macro. To minimize future problems, applications should set the foreign key enforcement flag as required by the application and not depend on the default setting.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; 부터 외래 키 적용의 기본 설정은 OFF입니다. 그러나 이후 릴리스의 SQLite에서는 변경 될 수 있습니다. 외래 키 적용에 대한 기본 설정은 &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; 전 처리기 매크로를 사용하여 컴파일 타임에 지정할 수 있습니다 . 향후 문제를 최소화하기 위해 응용 프로그램은 응용 프로그램에 필요한 외래 키 적용 플래그를 설정해야하며 기본 설정에 의존하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0e6461cc943c138056429ef3ecea61d0043a0402" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; utility is able to generate RBU databases representing the difference between two databases with identical schemas. For example, the following command:</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14)부터 &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; 유틸리티는 동일한 스키마를 가진 두 데이터베이스의 차이점을 나타내는 RBU 데이터베이스를 생성 할 수 있습니다. 예를 들어, 다음 명령은</target>
        </trans-unit>
        <trans-unit id="dfbf6fd8aef52e316e037404ed7145e5b99ccf6d" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer to use a co-routine to implement FROM-clause subqueries that contains an ORDER BY clause and that are not part of a join when the result set of the outer query is &quot;complex&quot;. This feature allows applications to shift expensive computations from before the sorter until after the sorter, which can result in faster operation. For example, consider this query:</source>
          <target state="translated">SQLite 버전 3.21.0 (2017-10-24)부터 쿼리 플래너는 항상 코 루틴을 사용하여 ORDER BY 절을 포함하고 결과가 조인의 일부가 아닌 FROM-clause 하위 쿼리를 구현하는 것을 선호합니다. 외부 쿼리 집합은 &quot;복잡&quot;입니다. 이 기능을 사용하면 응용 프로그램이 분류기 이전에서 분류기 이후까지 고가의 계산을 전환 할 수 있으므로 작업이 더 빨라질 수 있습니다. 예를 들어 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="242b46186535aea87c089fafc2bda700b6f5e078" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.22.0, the &quot;sqlite_stat1&quot; table is an exception to some of the rules above. In SQLite, the schema of sqlite_stat1 is:</source>
          <target state="translated">SQLite 버전 3.22.0부터 &quot;sqlite_stat1&quot;테이블은 위의 규칙 중 일부에 대한 예외입니다. SQLite에서 sqlite_stat1의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ddb98490083a7f2dc1ca2a3b26fa7d781b747ca" translate="yes" xml:space="preserve">
          <source>As of this writing (2017-07-13), the completion virtual table only looks for SQL keywords, and schema, table, and column names. The context contained in $wholeline is completely ignored. Future enhancements will try to return new completions taken from function and pragma names and other sources, as well as consider more context. The completion table should be considered a work-in-progress.</source>
          <target state="translated">이 글을 쓰는 시점 (2017-07-13)에서 완료 가상 테이블은 SQL 키워드, 스키마, 테이블 및 열 이름 만 찾습니다. $ wholeline에 포함 된 컨텍스트는 완전히 무시됩니다. 향후 개선 사항은 기능 및 pragma 이름 및 기타 소스에서 가져온 새로운 완료 사항을 반환하고 더 많은 컨텍스트를 고려할 것입니다. 완료 테이블은 진행중인 작업으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b289cb5373e1ff5a5a0c905eb902dc91bdb7b556" translate="yes" xml:space="preserve">
          <source>As of this writing (2018-05-29) the only other recommended storage formats for datasets are XML, JSON, and CSV.</source>
          <target state="translated">이 글을 쓰는 시점 (2018-05-29)에 데이터 세트에 권장되는 유일한 다른 스토리지 형식은 XML, JSON 및 CSV입니다.</target>
        </trans-unit>
        <trans-unit id="f2ad4e776d39a3ec2c252f71f4dae40cd1708a1c" translate="yes" xml:space="preserve">
          <source>As of this writing (2019-07-16), the SQLite developers have stopped using AFL for routine testing and instead are focused on running dbsqlfuzz. At least one instance of dbsqlfuzz is running on the latest SQLite source code at all times, in order to catch any new problems that might be introduced into the source tree as features are added and routine maintenance is performed.</source>
          <target state="translated">이 글을 쓰는 시점 (2019-07-16)에 SQLite 개발자는 일상적인 테스트에 AFL 사용을 중단했으며 대신 dbsqlfuzz 실행에 중점을 둡니다. 기능이 추가되고 일상적인 유지 보수가 수행 될 때 소스 트리에 발생할 수있는 새로운 문제점을 포착하기 위해 최신 SQLite 소스 코드에서 최소한 하나의 dbsqlfuzz 인스턴스가 항상 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="c36686a25a23f2cfaee766f9bfb5607ad00a8413" translate="yes" xml:space="preserve">
          <source>As one might expect, the amount of data read from the database file is minimized by caching portions of the database file in main memory. Additionally, multiple updates to the database file that are part of the same</source>
          <target state="translated">예상 한대로, 데이터베이스 파일에서 읽은 데이터의 양은 주 메모리에 데이터베이스 파일의 일부를 캐싱함으로써 최소화됩니다. 또한 동일한 데이터베이스 파일에 대한 여러 업데이트</target>
        </trans-unit>
        <trans-unit id="972efc3fd6678a6e105ba1a8f1aac17c41abd523" translate="yes" xml:space="preserve">
          <source>As part of opening a new</source>
          <target state="translated">새로운 개통의 일환으로</target>
        </trans-unit>
        <trans-unit id="9b40d60a44eca2b862c669b4ece8404effe70c95" translate="yes" xml:space="preserve">
          <source>As part of the query planning process, SQLite enumerates all usable combinations of indexes and WHERE-clause constraints. For certain pathological queries, the number of these index-and-constraint combinations can be very large, resulting in slow performance by the query planner. The SQLITE_QUERY_PLANNER_LIMIT value (in conjunction with the related &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; setting) limits the number of index-and-constraint combinations that the query planner will consider, in order to prevent the query planner from using excess CPU time. The default value for SQLITE_QUERY_PLANNER_LIMIT is set high enough so that is never reached for real-world queries. The query planner search limit only applies to queries that are deliberately crafted to use excess planning time.</source>
          <target state="translated">쿼리 계획 프로세스의 일부로 SQLite는 사용 가능한 모든 인덱스 조합과 WHERE 절 제약 조건을 열거합니다. 특정 병리학 적 쿼리의 경우 이러한 인덱스-제약 조합의 수가 매우 많을 수 있으므로 쿼리 플래너의 성능이 저하됩니다. SQLITE_QUERY_PLANNER_LIMIT 값 (관련 &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; 설정 과 함께 )은 쿼리 플래너가 과도한 CPU 시간을 사용하지 못하도록 쿼리 플래너가 고려할 인덱스 및 제약 조합의 수를 제한합니다. SQLITE_QUERY_PLANNER_LIMIT의 기본값은 실제 쿼리에 도달 할 수 없을 정도로 충분히 높게 설정되어 있습니다. 쿼리 플래너 검색 제한은 계획 시간이 초과되도록 의도적으로 만들어진 쿼리에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="69ee480d16c703172bf696c37d4bed26f84974f4" translate="yes" xml:space="preserve">
          <source>As part of the task of creating a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure, this method &lt;u&gt;must&lt;/u&gt; invoke &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; to tell the SQLite core about the columns and datatypes in the virtual table. The &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; API has the following prototype:</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조 를 작성하는 작업의 일부로이 메소드 &lt;u&gt;는 &lt;/u&gt;&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 을 호출 하여 SQLite 코어에 가상 테이블의 열 및 데이터 유형에 대해 알려야합니다. &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; API는 다음과 같은 프로토 타입이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c00876adc6de8fc473fb32b80195d17d4fda9f03" translate="yes" xml:space="preserve">
          <source>As pointed out in the previous paragraph, SQLite takes steps to work around the quirks of POSIX advisory locking. Part of that work-around involves keeping a global list (mutex protected) of open SQLite database files. But, if multiple copies of SQLite are linked into the same application, then there will be multiple instances of this global list. Database connections opened using one copy of the SQLite library will be unaware of database connections opened using the other copy, and will be unable to work around the POSIX advisory locking quirks. A &lt;code&gt;close()&lt;/code&gt; operation on one connection might unknowingly clear the locks on a different database connection, leading to database corruption.</source>
          <target state="translated">이전 단락에서 지적했듯이 SQLite는 POSIX 권고 잠금 문제를 해결하기위한 조치를 취합니다. 이 문제를 해결하려면 열려있는 SQLite 데이터베이스 파일의 전체 목록 (뮤텍스 보호)을 유지해야합니다. 그러나 여러 SQLite 사본이 동일한 애플리케이션에 링크 된 경우이 글로벌 목록의 인스턴스가 여러 개 있습니다. 하나의 SQLite 라이브러리 사본을 사용하여 열린 데이터베이스 연결은 다른 사본을 사용하여 열린 데이터베이스 연결을 인식하지 못하며 POSIX 권고 잠금 문제를 해결할 수 없습니다. &lt;code&gt;close()&lt;/code&gt; 하나 개의 연결에 대한 작업은 무의식적으로 데이터베이스 손상으로 이어지는, 다른 데이터베이스 연결에 잠금을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d67b507fa18e45da7b000070cada26cbc7cde7" translate="yes" xml:space="preserve">
          <source>As recently as version 2.7.0, SQLite ran at about the same speed as MySQL on this test. But recent optimizations to SQLite have more than doubled speed of UPDATEs.</source>
          <target state="translated">최근 버전 2.7.0에서 SQLite는이 테스트에서 MySQL과 거의 같은 속도로 실행되었습니다. 그러나 최근 SQLite에 대한 최적화는 UPDATE 속도가 두 배 이상 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="9a13d6d8189152816b2ae81d060e78c812a6905c" translate="yes" xml:space="preserve">
          <source>As soon as the PENDING lock is released from the database file, other processes can begin reading the database again. In the current implementation, the RESERVED lock is also released, but that is not essential for correct operation.</source>
          <target state="translated">PENDING 잠금이 데이터베이스 파일에서 해제 되 자마자 다른 프로세스가 데이터베이스를 다시 읽을 수 있습니다. 현재 구현에서는 RESERVED 잠금도 해제되지만 올바른 작동에 필수적인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="555c3a9cda5a4b25e0cdbc43fe5e7c8c0b690222" translate="yes" xml:space="preserve">
          <source>As the last step in opening a</source>
          <target state="translated">열기의 마지막 단계로</target>
        </trans-unit>
        <trans-unit id="de5e740293d719649dc267008b44fcf5aaa20455" translate="yes" xml:space="preserve">
          <source>As we enter the interior of the second loop (at instruction 17) the stack contains a single integer which is the key of the record we want to modify. We are going to need to use this key twice: once to fetch the old value of the record and a second time to write back the revised record. So the first instruction is a Dup to make a duplicate of the key on the top of the stack. The Dup instruction will duplicate any element of the stack, not just the top element. You specify which element to duplication using the P1 operand. When P1 is 0, the top of the stack is duplicated. When P1 is 1, the next element down on the stack duplication. And so forth.</source>
          <target state="translated">두 번째 루프의 내부에 들어가면 (명령 17에서) 스택에는 수정하려는 레코드의 키인 단일 정수가 포함됩니다. 이 키를 두 번 사용해야합니다. 한 번은 레코드의 이전 값을 가져오고 두 번째는 수정 된 레코드를 다시 쓰는 것입니다. 따라서 첫 번째 명령어는 스택 상단에 키 복제본을 만드는 Dup입니다. Dup 명령어는 최상위 요소뿐만 아니라 스택의 모든 요소를 ​​복제합니다. P1 피연산자를 사용하여 복제 할 요소를 지정합니다. P1이 0이면 스택의 상단이 복제됩니다. P1이 1이면 스택 복제에서 다음 요소가 내려갑니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="cf4c617d0371eb7d2e50bdeaba7f0656cfa12c47" translate="yes" xml:space="preserve">
          <source>As well as a list of columns, the module arguments passed to a CREATE VIRTUAL TABLE statement used to create an FTS table may be used to specify a &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. This is done by specifying a string of the form &quot;tokenize=&amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot; in place of a column name, where &amp;lt;tokenizer name&amp;gt; is the name of the tokenizer to use and &amp;lt;tokenizer args&amp;gt; is an optional list of whitespace separated qualifiers to pass to the tokenizer implementation. A tokenizer specification may be placed anywhere in the column list, but at most one tokenizer declaration is allowed for each CREATE VIRTUAL TABLE statement. &lt;a href=&quot;fts3#tokenizer&quot;&gt;See below&lt;/a&gt; for a detailed description of using (and, if necessary, implementing) a tokenizer.</source>
          <target state="translated">열 목록뿐만 아니라 FTS 테이블을 만드는 데 사용 된 CREATE VIRTUAL TABLE 문에 전달 된 모듈 인수를 사용하여 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 를 지정할 수 있습니다 . 열 이름 대신 &quot;tokenize = &amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot;형식의 문자열을 지정하면됩니다. 여기서 &amp;lt;tokenizer name&amp;gt;은 사용할 토크 나이저의 이름이고 &amp;lt;tokenizer args&amp;gt;는 선택적입니다 토크 나이저 구현에 전달할 공백으로 구분 된 한정자 목록 토크 나이저 스펙은 열 목록의 어느 곳에 나 배치 할 수 있지만 각 CREATE VIRTUAL TABLE 문에 대해 최대 하나의 토크 나이저 선언이 허용됩니다. 토크 나이저 사용 (및 필요한 경우 구현)에 대한 자세한 설명은 &lt;a href=&quot;fts3#tokenizer&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba6435071ee404f8eb600e0af17ad3d0179b00e" translate="yes" xml:space="preserve">
          <source>As well as aggregate window functions, SQLite features a set of built-in window functions based on &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt; those supported by PostgreSQL&lt;/a&gt;.</source>
          <target state="translated">SQLite는 집계 창 함수뿐만 아니라 &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt;PostgreSQL에서 지원하는&lt;/a&gt; 기능을 기반으로 하는 내장 창 함수 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4c2adc03d8772b0c49ef19569e284dd9591a16b0" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">행이 데이터베이스 테이블에 삽입 될 때 자동으로 설정 될뿐만 아니라이 함수에 의해 리턴 된 값은 &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()에&lt;/a&gt; 의해 명시 적으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da8075b78c1059d6422bee1d474218e1b6600d9" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">행이 데이터베이스 테이블에 삽입 될 때 자동으로 설정 될뿐만 아니라이 함수에 의해 리턴 된 값은 &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()에&lt;/a&gt; 의해 명시 적으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a715526e2153a56ee0a3cbcb2c8454333e9e1d8" translate="yes" xml:space="preserve">
          <source>As well as searching for all rows that contain a term, FTS5 allows the user to search for rows that contain:</source>
          <target state="translated">FTS5를 사용하면 용어가 포함 된 모든 행을 검색 할 수있을뿐만 아니라 다음을 포함하는 행을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f6e18c709ce14d58e4401d523e835813272b3a" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="translated">&quot;간단한&quot;토크 나이저뿐만 아니라 FTS 소스 코드에는 &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt; Porter Stemming 알고리즘&lt;/a&gt;. 이 토크 나이 저는 동일한 규칙을 사용하여 모든 문서를 소문자로 접는 것을 포함하여 입력 문서를 용어로 분리하지만 Porter Stemming 알고리즘을 사용하여 관련 영어 단어를 공통 루트로 줄입니다. 예를 들어, 위의 단락에서와 동일한 입력 문서를 사용하여 포터 토크 나이 저는 다음 토큰을 추출합니다. &quot;현재 바로 그 절두체&quot;. 이러한 용어 중 일부는 영어 단어도 아니지만 일부 경우 전체 텍스트 인덱스를 작성하기 위해 해당 단어를 사용하는 것이 간단한 토크 나이저로 생성 된보다 이해하기 쉬운 결과보다 더 유용합니다. 포터 토크 나이저를 사용하면 &quot;MATCH 'Frustrated'&quot;와 같은 전체 텍스트 쿼리뿐만 아니라 &quot;Frustration&quot;이라는 용어로 &quot;MATCH 'Frustration&quot; &quot;과 같은 쿼리도 일치합니다.&quot;Frustrated&quot;와 마찬가지로 Porter stemmer 알고리즘에 의해 &quot;frustrat&quot;로 줄어 듭니다. 따라서 포터 토크 나이저를 사용할 때 FTS는 쿼리 된 용어와 정확히 일치하는 단어뿐만 아니라 유사한 영어 용어와 일치하는 것을 찾을 수 있습니다. Porter Stemmer 알고리즘에 대한 자세한 내용은 위의 링크 된 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03b7b3d7c7af14aee8c40f5a5eff47a557f13b7f" translate="yes" xml:space="preserve">
          <source>As well as the column values and rowid of a matching row, an application may use &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt; to retrieve extra information regarding the matched row. For example, an auxiliary function may be used to retrieve a copy of a column value for a matched row with all instances of the matched term surrounded by html &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; tags. Auxiliary functions are invoked in the same way as SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;scalar functions&lt;/a&gt;, except that the name of the FTS5 table is specified as the first argument. For example:</source>
          <target state="translated">일치하는 행의 열 값과 rowid뿐만 아니라 응용 프로그램은 &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 보조 기능&lt;/a&gt; 을 사용 하여 일치하는 행에 대한 추가 정보를 검색 할 수 있습니다 . 예를 들어 보조 함수를 사용하여 html &amp;lt;b&amp;gt; &amp;lt;/ b&amp;gt; 태그로 둘러싸인 일치하는 용어의 모든 인스턴스가있는 일치 된 행의 열 값 사본을 검색 할 수 있습니다. 보조 함수는 FTS5 테이블의 이름이 첫 번째 인수로 지정되는 것을 제외하고 SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;스칼라 함수&lt;/a&gt; 와 동일한 방식으로 호출됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f0b425505ed4df313764b933ddda058638fd396" translate="yes" xml:space="preserve">
          <source>As well as the columns named by the user (or the &quot;content&quot; column if no module arguments were specified as part of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement), each FTS table has a &quot;rowid&quot; column. The rowid of an FTS table behaves in the same way as the rowid column of an ordinary SQLite table, except that the values stored in the rowid column of an FTS table remain unchanged if the database is rebuilt using the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. For FTS tables, &quot;docid&quot; is allowed as an alias along with the usual &quot;rowid&quot;, &quot;oid&quot; and &quot;_oid_&quot; identifiers. Attempting to insert or update a row with a docid value that already exists in the table is an error, just as it would be with an ordinary SQLite table.</source>
          <target state="translated">사용자가 명명 한 열 (또는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문의 일부로 모듈 인수가 지정되지 않은 경우 &quot;content&quot;열)뿐만 아니라 각 FTS 테이블에는 &quot;rowid&quot;열이 있습니다. FTS 테이블의 rowid는 데이터베이스가 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 사용하여 다시 빌드되는 경우 FTS 테이블의 rowid 열에 저장된 값이 변경되지 않은 것을 제외하고 일반 SQLite 테이블의 rowid 열과 동일한 방식으로 작동합니다 . FTS 테이블의 경우 &quot;docid&quot;는 일반적인 &quot;rowid&quot;, &quot;oid&quot;및 &quot;_oid_&quot;식별자와 함께 별칭으로 허용됩니다. 테이블에 이미 존재하는 docid 값으로 행을 삽입하거나 업데이트하려고하면 일반 SQLite 테이블에서와 마찬가지로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8231b142308216452ffa1a9e5faf9c8e3f6c4c97" translate="yes" xml:space="preserve">
          <source>As well as the command option, each invocation of &quot;.ar&quot; may specify one or more modifier options. Some modifier options require an argument, some do not. The following modifier options are available:</source>
          <target state="translated">명령 옵션뿐만 아니라 &quot;.ar&quot;을 호출 할 때마다 하나 이상의 수정 자 옵션을 지정할 수 있습니다. 일부 수정 자 옵션에는 인수가 필요하지만 일부는 그렇지 않습니다. 다음과 같은 수정 자 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a7e6bcced1d592a4403e3d9c67fd5b0f5481cf" translate="yes" xml:space="preserve">
          <source>As well as the regular sqlite3changegroup_add() and sqlite3changegroup_output() functions, also available are the streaming versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().</source>
          <target state="translated">일반적인 sqlite3changegroup_add () 및 sqlite3changegroup_output () 함수뿐만 아니라 스트리밍 버전 sqlite3changegroup_add_strm () 및 sqlite3changegroup_output_strm ()도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c79aa6a7ac9fe81930f35128aa127b04b14a76a2" translate="yes" xml:space="preserve">
          <source>As with &quot;.tables&quot;, the &quot;.schema&quot; command shows the schema for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases. If you only want to see the schema for a single database (perhaps &quot;main&quot;) then you can add an argument to &quot;.schema&quot; to restrict its output:</source>
          <target state="translated">&quot;.tables&quot;와 마찬가지로 &quot;.schema&quot;명령은 &lt;a href=&quot;lang_attach&quot;&gt;연결된&lt;/a&gt; 모든 데이터베이스 의 스키마를 보여줍니다 . 단일 데이터베이스 (아마 &quot;main&quot;)에 대한 스키마 만 보려면 &quot;.schema&quot;에 인수를 추가하여 출력을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea1906458c679a89c4cf89131d2ffd0b8ce0439a" translate="yes" xml:space="preserve">
          <source>As with all SQL syntax, the case of the keywords does not matter. One can write &quot;WITHOUT rowid&quot; or &quot;without rowid&quot; or &quot;WiThOuT rOwId&quot; and it will mean the same thing.</source>
          <target state="translated">모든 SQL 구문과 마찬가지로 키워드의 경우는 중요하지 않습니다. &quot;WITHOUT rowid&quot;또는 &quot;with rowid&quot;또는 &quot;WiThOuT rOwId&quot;를 쓸 수 있으며 같은 의미입니다.</target>
        </trans-unit>
        <trans-unit id="08e240ecd7ad7f6958c55717608dff9d30301be2" translate="yes" xml:space="preserve">
          <source>As with all other SQLite APIs, those whose names end with &quot;16&quot; return UTF-16 encoded strings and the other functions return UTF-8.</source>
          <target state="translated">다른 모든 SQLite API와 마찬가지로 이름이 &quot;16&quot;으로 끝나는 API는 UTF-16으로 인코딩 된 문자열을 반환하고 다른 함수는 UTF-8을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dad941d012cf3c0fecce4040017740b92b3cab9e" translate="yes" xml:space="preserve">
          <source>As with all virtual table types, it is not possible to create indices or triggers attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add extra columns to FTS tables (although it is possible to use ALTER TABLE to rename an FTS table).</source>
          <target state="translated">모든 가상 테이블 유형과 마찬가지로 FTS 테이블에 연결된 인덱스 또는 트리거를 생성 할 수 없습니다. ALTER TABLE 명령을 사용하여 FTS 테이블에 열을 추가 할 수도 없습니다 (ALTER TABLE을 사용하여 FTS 테이블의 이름을 바꿀 수는 있지만).</target>
        </trans-unit>
        <trans-unit id="2c9244ac5b5d0550aa0d1fc8ca3aa52ca8dfaf6c" translate="yes" xml:space="preserve">
          <source>As with custom file formats, and unlike pure pile-of-file formats, a wrapped pile-of-files format is not as easy to edit, since usually the entire file must be rewritten in order to change any component part.</source>
          <target state="translated">사용자 정의 파일 형식과 마찬가지로 순수 파일 형식과 달리 줄 바꿈 된 파일 형식은 편집하기 쉽지 않습니다. 일반적으로 구성 요소 부분을 변경하려면 전체 파일을 다시 작성해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="236d7f982d31124f4b94b3c6bc8e43ed33b0fc4b" translate="yes" xml:space="preserve">
          <source>As with the output of the sqlite3session_changeset() and sqlite3session_patchset() functions, all changes related to a single table are grouped together in the output of this function. Tables appear in the same order as for the very first changeset added to the changegroup. If the second or subsequent changesets added to the changegroup contain changes for tables that do not appear in the first changeset, they are appended onto the end of the output changeset, again in the order in which they are first encountered.</source>
          <target state="translated">sqlite3session_changeset () 및 sqlite3session_patchset () 함수의 출력과 마찬가지로 단일 테이블과 관련된 모든 변경 사항이이 함수의 출력에 그룹화됩니다. 변경 그룹에 추가 된 첫 번째 변경 집합과 동일한 순서로 테이블이 나타납니다. 변경 그룹에 추가 된 두 번째 또는 그 이후의 변경 세트에 첫 번째 변경 세트에 나타나지 않는 테이블에 대한 변경 사항이 포함 된 경우, 변경 사항이 처음 발생한 순서대로 출력 변경 세트의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="38abe488c2a235f79f98488263f0f24db0790ef4" translate="yes" xml:space="preserve">
          <source>As with unix, most of the code for the various Windows VFSes is shared.</source>
          <target state="translated">유닉스와 마찬가지로 다양한 Windows VFS에 대한 대부분의 코드가 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="ae23c67b5810fa3b2f8c5dc0de91ee63f46fa321" translate="yes" xml:space="preserve">
          <source>As you can see above, our simple insert statement is implemented in 12 instructions. The first 3 and last 2 instructions are a standard prologue and epilogue, so the real work is done in the middle 7 instructions. There are no jumps, so the program executes once through from top to bottom. Let's now look at each instruction in detail.</source>
          <target state="translated">위에서 볼 수 있듯이 간단한 insert 문은 12 개의 명령어로 구현됩니다. 처음 3 개와 마지막 2 개 명령은 표준 프롤로그 및 에필로그이므로 실제 작업은 중간 7 개 명령에서 수행됩니다. 점프는 없으므로 프로그램은 위에서 아래로 한 번 실행됩니다. 이제 각 명령어를 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5e7f8dc6fe3c7e8373b6401e629567228cb8e775" translate="yes" xml:space="preserve">
          <source>As you would expect, it is not possible to manipulate the database to a state that violates the foreign key constraint by deleting or updating rows in the</source>
          <target state="translated">예상 한대로 데이터베이스에서 행을 삭제하거나 업데이트하여 외래 키 제약 조건을 위반하는 상태로 데이터베이스를 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d60ffe4ee5253e97c8077a55a44490538dd90ceb" translate="yes" xml:space="preserve">
          <source>Aside from those read operations described by H35070 and H21XXX, SQLite shall read data from the database file in aligned blocks of</source>
          <target state="translated">SQLite는 H35070 및 H21XXX에서 설명하는 읽기 작업 외에도 데이터베이스 파일에서 데이터를 정렬 된 블록으로 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="42e2846af72fd7f80a66045f0952619fc82cc85d" translate="yes" xml:space="preserve">
          <source>Assert() macros are disabled by compiling with the NDEBUG macro defined. In most systems, asserts are enabled by default. But in SQLite, the asserts are so numerous and are in such performance critical places, that the database engine runs about three times slower when asserts are enabled. Hence, the default (production) build of SQLite disables asserts. Assert statements are only enabled when SQLite is compiled with the SQLITE_DEBUG preprocessor macro defined.</source>
          <target state="translated">Assert () 매크로는 정의 된 NDEBUG 매크로로 컴파일하여 비활성화됩니다. 대부분의 시스템에서 기본적으로 어설 션이 활성화되어 있습니다. 그러나 SQLite에서는 어설 션이 너무 많고 성능이 중요한 장소에 있으므로 어설 션을 사용할 때 데이터베이스 엔진이 약 3 배 느리게 실행됩니다. 따라서 SQLite의 기본 (프로덕션) 빌드는 어설 션을 비활성화합니다. Assert 문은 SQLite가 정의 된 SQLITE_DEBUG 전 처리기 매크로로 컴파일 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c350f30044b71a607c57f6c34de0b1ed5d9089b9" translate="yes" xml:space="preserve">
          <source>Assertion fault in FTS4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</source>
          <target state="translated">FTS4의 어설 션 오류. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;D6EC09ECCF68CFC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebc26a866ddd19c561f95f02b90e42c3048bf831" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="translated">&quot;x IN (?)&quot;형식의 표현식과 관련된 쿼리에서 어설 션 오류. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c84e5f05e8b60b78b6a824b91605a18f1523027" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing REPLACE on an index on an expression. Ticket &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</source>
          <target state="translated">식의 인덱스에서 REPLACE를 수행 할 때 어설 션 오류가 발생했습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14462bb4d8840870eeb8b473a0f255cc7e22e056" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing an IN operator on a constant index. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</source>
          <target state="translated">상수 인덱스에서 IN 연산자를 수행 할 때 어설 션 오류가 발생했습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cea6f6a832fd7bbb6517d045402e777f939a795" translate="yes" xml:space="preserve">
          <source>Assigned the integer at offset 68 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt; as the &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; for when SQLite is used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. Added the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command to query and set the Application ID.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용되는 경우 에 대한 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 &lt;/a&gt;&lt;a href=&quot;fileformat2#appid&quot;&gt;ID&lt;/a&gt; 의 오프셋 68에서 정수를 응용 프로그램 ID 로 할당했습니다 . &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; 명령을 추가하여 응용 프로그램 ID를 쿼리하고 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="ea6dcdcecbe15c6b4677215943bc88e69426e6db" translate="yes" xml:space="preserve">
          <source>Assuming no errors have occurred, then after attempting to detect and roll back a</source>
          <target state="translated">오류가 발생하지 않았다고 가정하고 감지 및 롤백 시도 후</target>
        </trans-unit>
        <trans-unit id="2d3766c3aab2fade58e514ea17fb6dc49420a581" translate="yes" xml:space="preserve">
          <source>Assuming statistics are enabled, the following routine can be used to access them:</source>
          <target state="translated">통계가 사용 가능하다고 가정하면 다음 루틴을 사용하여 통계에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="836ad82865d510ff9a297c7660cf9d810b0b4728" translate="yes" xml:space="preserve">
          <source>Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.</source>
          <target state="translated">잠금 해제 알림 콜백에 등록한 후 데이터베이스가 추가 조치를 취하기 전에 콜백이 발행 될 때까지 대기한다고 가정하면 (합리적인 가정)이 API를 사용하면 애플리케이션이 교착 상태에 빠질 수 있습니다. 예를 들어, 연결 X가 연결 Y의 트랜잭션이 완료되기를 기다리고 있고 연결 Y가 연결 X의 트랜잭션을 기다리고있는 경우 연결이 진행되지 않고 시스템이 무기한 교착 상태를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba1c75f29bb0c1b541e404f389344df8b7d3190" translate="yes" xml:space="preserve">
          <source>Assuming that any and all sectors in the transient state may be corrupted following a power or system failure is a very pessimistic approach. Some modern systems provide more sophisticated guarantees than this. SQLite allows the VFS implementation to specify at runtime that the current platform supports zero or more of the following properties:</source>
          <target state="translated">과도 상태의 모든 섹터가 전원 또는 시스템 장애 후 손상 될 수 있다고 가정하는 것은 매우 비관적 인 접근법입니다. 일부 최신 시스템은 이보다 더 정교한 보증을 제공합니다. SQLite를 사용하면 VFS 구현에서 런타임시 현재 플랫폼이 다음 특성 중 0 개 이상을 지원하도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e7a33261340b9207abc7f6240781daed2437d8" translate="yes" xml:space="preserve">
          <source>Assuming that customer records are stored in the &quot;customers&quot; table, and that order records are stored in the &quot;orders&quot; table, the following UPDATE trigger ensures that all associated orders are redirected when a customer changes his or her address:</source>
          <target state="translated">고객 레코드가 &quot;고객&quot;테이블에 저장되고 주문 레코드가 &quot;주문&quot;테이블에 저장되어 있다고 가정하면 다음 UPDATE 트리거는 고객이 자신의 주소를 변경할 때 모든 관련 주문이 리디렉션되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ff40c2070ad237bff82bd7bce4ef0b45898889d0" translate="yes" xml:space="preserve">
          <source>Assuming that the compile-time threading mode is not single-thread, then the threading mode can be changed during initialization using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; verb puts SQLite into single-thread mode, the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; verb sets multi-thread mode, and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; verb sets serialized mode.</source>
          <target state="translated">컴파일 타임 스레딩 모드가 단일 스레드가 아니라고 가정하면 초기화 중에 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 스레딩 모드를 변경할 수 있습니다 . &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; 풋 동사는 단일 스레드 모드에서로 SQLite에 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 세트 멀티 스레드 모드 동사 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; 모드를 직렬화 세트 동사.</target>
        </trans-unit>
        <trans-unit id="5e4099134714457b667c5a0d0c91727935a69b43" translate="yes" xml:space="preserve">
          <source>Assuming that the first hidden column of &quot;tablevaluedfunc&quot; is &quot;param1&quot;, the query above is semantically equivalent to this:</source>
          <target state="translated">&quot;tablevaluedfunc&quot;의 첫 번째 숨겨진 열이 &quot;param1&quot;이라고 가정하면 위 쿼리는 의미 적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a392f90a65c67ef3276bb011e52cf4659579c18e" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">변경 세트 Blob이 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; 함수 중 하나에 의해 작성되었다고 가정하면 단일 테이블에 적용되는 변경 세트 내의 모든 변경 사항이 함께 그룹화됩니다. 이는 애플리케이션이이 함수로 작성된 반복기를 사용하여 변경 세트를 반복 할 때 단일 테이블과 관련된 모든 변경 사항이 연속적으로 방문됨을 의미합니다. 반복자가 테이블 X에 적용되는 변경 사항을 방문한 다음 테이블 Y에 대한 변경 사항을 방문한 다음 나중에 테이블 X에 대한 다른 변경 사항을 방문 할 가능성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae768e26e15e53e036c5e372149bd64f61fe40d5" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">변경 세트 Blob이 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; 또는 &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; 함수 중 하나에 의해 작성되었다고 가정하면 단일 테이블에 적용되는 변경 세트 내의 모든 변경 사항이 함께 그룹화됩니다. 이는 애플리케이션이이 함수로 작성된 반복기를 사용하여 변경 세트를 반복 할 때 단일 테이블과 관련된 모든 변경 사항이 연속적으로 방문됨을 의미합니다. 반복자가 테이블 X에 적용되는 변경 사항을 방문한 다음 테이블 Y에 대한 변경 사항을 방문한 다음 나중에 테이블 X에 대한 다른 변경 사항을 방문 할 가능성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae27622bf93c5f8e58c667e3d2b3f8634b153cf3" translate="yes" xml:space="preserve">
          <source>Assuming the library is compiled with foreign key constraints enabled, it must still be enabled by the application at runtime, using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command. For example:</source>
          <target state="translated">라이브러리가 외래 키 제약 조건이 활성화 된 상태로 컴파일되었다고 가정하면 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; 명령을 사용하여 런타임시 응용 프로그램에서 라이브러리를 계속 활성화해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a1dda34c843a460a37b4389bc3fdea530b33452" translate="yes" xml:space="preserve">
          <source>Assuming the nominated table does exist, then its columns must be the same as or a superset of those defined for the FTS table. The external table must also be in the same database file as the FTS table. In other words, The external table cannot be in a different database file connected using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; nor may one of the FTS table and the external content be in the TEMP database when the other is in a persistent database file such as MAIN.</source>
          <target state="translated">지명 된 테이블이 존재한다고 가정하면 해당 열은 FTS 테이블에 대해 정의 된 열과 동일하거나 상위 집합이어야합니다. 외부 테이블도 FTS 테이블과 동일한 데이터베이스 파일에 있어야합니다. 즉, 외부 테이블은 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH를&lt;/a&gt; 사용하여 연결된 다른 데이터베이스 파일에 있을 수 없으며 다른 하나는 MAIN과 같은 지속적 데이터베이스 파일에있을 때 FTS 테이블 및 외부 컨텐츠 중 하나가 TEMP 데이터베이스에있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="921866ee0046d5a80db64dfb8749244f24a09ba6" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt;, &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;, &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; and &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; are slower than usual. This is because instead of reading the required data directly from the FTS index they have to load and tokenize the document text on demand.</source>
          <target state="translated">테이블을 가정하면도 아닌 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는 테이블&lt;/a&gt; 의 &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt; , &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt; , &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; 및 &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext는&lt;/a&gt; 느린 평소보다 있습니다. FTS 인덱스에서 직접 필요한 데이터를 읽는 대신 요청시 문서 텍스트를로드하고 토큰 화해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dc375c212f41b57083889574933fcd5e4987a611" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a contentless table, the &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;xPhraseFirstColumn&lt;/a&gt; and &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; are slower than usual.</source>
          <target state="translated">테이블이 &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;컨텐츠&lt;/a&gt; 가없는 테이블이 아니라고 가정하면 xPhraseFirstColumn 및 &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; 이 평소보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="504be981e8ff80c0d63cd17a340b7f1cd587e84d" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O appears to give better responsiveness, but at a price. You lose the Durable property. With the default I/O backend of SQLite, once a write completes, you know that the information you wrote is safely on disk. With the asynchronous I/O, this is not the case. If your program crashes or if a power loss occurs after the database write but before the asynchronous write thread has completed, then the database change might never make it to disk and the next user of the database might not see your change.</source>
          <target state="translated">비동기 I / O는 더 나은 응답 성을 제공하지만 비용이 많이 드는 것으로 보입니다. 내구력을 잃습니다. SQLite의 기본 I / O 백엔드를 사용하면 쓰기가 완료되면 작성한 정보가 디스크에 안전하게 저장되어 있음을 알 수 있습니다. 비동기식 I / O에서는 그렇지 않습니다. 데이터베이스 쓰기 후 비동기 쓰기 스레드가 완료되기 전에 프로그램이 중단되거나 전원 손실이 발생하면 데이터베이스 변경으로 인해 디스크가 변경되지 않고 다음 데이터베이스 사용자가 변경 사항을 보지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c26b5cd54f0029b1a3269b19cfe3a6ff6addbcc" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O works by creating an SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; and registering it with &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. When files opened via this VFS are written to (using the vfs xWrite() method), the data is not written directly to disk, but is placed in the &quot;write-queue&quot; to be handled by the background thread.</source>
          <target state="translated">비동기 I / O는 SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS 객체&lt;/a&gt; 를 생성하고 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()에&lt;/a&gt; 등록 하여 작동합니다 . 이 VFS를 통해 열린 파일이 (vfs xWrite () 메소드를 사용하여) 기록 될 때, 데이터는 디스크에 직접 기록되지 않지만 백그라운드 쓰레드가 처리 할 &quot;쓰기 큐&quot;에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="4c91d5ce458c482219d3664734d8a556293b6cdf" translate="yes" xml:space="preserve">
          <source>At a shell or DOS prompt, enter: &quot;&lt;b&gt;sqlite3 test.db&lt;/b&gt;&quot;. This will create a new database named &quot;test.db&quot;. (You can use a different name if you like.)</source>
          <target state="translated">쉘 또는 DOS 프롬프트에서 &quot; &lt;b&gt;sqlite3 test.db&lt;/b&gt; &quot;를 입력하십시오 . &quot;test.db&quot;라는 새 데이터베이스가 생성됩니다. 원하는 경우 다른 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449f6270af54115e84fbbfac0ca3ab28ec064210" translate="yes" xml:space="preserve">
          <source>At about that same time, some avionics manufacturers were expressing interest in SQLite, which prompted the SQLite developers to design TH3 to support the rigorous testing standards of &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;.</source>
          <target state="translated">거의 동시에, 일부 항공 전자 제품 제조업체는 SQLite에 대한 관심을 표명하면서 SQLite 개발자는 &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt; 의 엄격한 테스트 표준을 지원하도록 TH3을 설계해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="d3fd57d066718d01302089d95d92c8454d1b5f4a" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">언제든지 단일 테이블은 여러 개의 활성 읽기 잠금 또는 단일 활성 쓰기 잠금을 가질 수 있습니다. 테이블에서 데이터를 읽으려면 먼저 연결에서 읽기 잠금을 얻어야합니다. 테이블에 쓰려면 연결에서 해당 테이블에 대한 쓰기 잠금을 얻어야합니다. 필요한 테이블 잠금을 확보 할 수 없으면 쿼리가 실패하고 SQLITE_LOCKED가 호출자에게 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b7a3b82c7cb7013957f0c0e0e4f1a6c43e18aa55" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data from a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">한 번에 하나의 테이블에는 여러 활성 읽기 잠금 또는 단일 활성 쓰기 잠금이있을 수 있습니다. 테이블에서 데이터를 읽으려면 먼저 연결이 읽기 잠금을 얻어야합니다. 테이블에 쓰려면 연결이 해당 테이블에 대한 쓰기 잠금을 획득해야합니다. 필요한 테이블 잠금을 얻을 수없는 경우 쿼리가 실패하고 SQLITE_LOCKED가 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2c8ad5daed2b52823fb4c80a495b310ef19384a" translate="yes" xml:space="preserve">
          <source>At any one time, each</source>
          <target state="translated">언제든지, 각각</target>
        </trans-unit>
        <trans-unit id="8560f4e49c6caa4d7228201f89aa3ea44ff72f5b" translate="yes" xml:space="preserve">
          <source>At any one time, the</source>
          <target state="translated">언제든지</target>
        </trans-unit>
        <trans-unit id="faefe425b3756bc94c56346d8a50b44d5ccda922" translate="yes" xml:space="preserve">
          <source>At any point in time, every page in the main database has a single use which is one of the following:</source>
          <target state="translated">어느 시점에서든 주 데이터베이스의 모든 페이지는 다음 중 하나 인 단일 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4998acdc6089555e0887c221354101b4a2253663" translate="yes" xml:space="preserve">
          <source>At first glance, the final two full-text queries in the example above seem to be syntactically incorrect, as there is a table name (&quot;mail&quot;) used as an SQL expression. The reason this is acceptable is that each FTS table actually has a &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; column with the same name as the table itself (in this case, &quot;mail&quot;). The value stored in this column is not meaningful to the application, but can be used as the left-hand operand to a MATCH operator. This special column may also be passed as an argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">언뜻보기에, 위의 예제에서 마지막 두 개의 전체 텍스트 쿼리는 SQL 표현식으로 사용되는 테이블 이름 ( &quot;mail&quot;)이 있으므로 구문 상 올바르지 않은 것 같습니다. 이것이 허용되는 이유는 각 FTS 테이블에 실제로 테이블 자체와 이름이 같은 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; 열 (이 경우에는 &quot;mail&quot;)이 있기 때문입니다. 이 열에 저장된 값은 응용 프로그램에는 의미가 없지만 MATCH 연산자의 왼쪽 피연산자로 사용할 수 있습니다. 이 특수 열은 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 기능에&lt;/a&gt; 대한 인수로 전달 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f5836449640e20f49edf00efccee8083a6bcb35" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite 는 xsz에 세 번째 인수로 전달 된 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 를 보유하기 위해 최소 szOsFile 바이트의 메모리를 할당합니다 . xOpen 메소드는 구조를 할당 할 필요가 없습니다. xOpen 메소드는 sqlite3_file.pMethods를 유효한 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 또는 NULL로 설정해야 합니다. xOpen은 열기에 실패하더라도이를 수행해야합니다. SQLite는 xOpen 호출의 성공 또는 실패에 관계없이 xOpen이 반환 된 후 sqlite3_file.pMethods 요소가 유효 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="59514e13b273471c6ec6f5f109fedbde115ba166" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite 는 xsz에 세 번째 인수로 전달 된 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 를 보유하기 위해 최소 szOsFile 바이트의 메모리를 할당합니다 . xOpen 메소드는 구조를 할당 할 필요가 없습니다. xOpen 메소드는 sqlite3_file.pMethods를 유효한 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 또는 NULL로 설정해야 합니다. xOpen은 열기에 실패하더라도이를 수행해야합니다. SQLite는 xOpen 호출의 성공 또는 실패에 관계없이 xOpen이 반환 된 후 sqlite3_file.pMethods 요소가 유효 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="5cf0c7d5d4e31a3622d3bed10cffc599203f902a" translate="yes" xml:space="preserve">
          <source>At most one connection to a single shared cache may open a write transaction at any one time. This may co-exist with any number of read transactions.</source>
          <target state="translated">단일 공유 캐시에 대한 최대 하나의 연결은 언제든지 쓰기 트랜잭션을 열 수 있습니다. 여러 읽기 트랜잭션과 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2549fa7b8565911915cfbc5b3b9d42147224732f" translate="yes" xml:space="preserve">
          <source>At one point, &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; was sometimes licensed to third-parties. Such licensing no longer occurs. However, back when it was occurring, some of the TH3 test cases contained information that was sensitive and could not be released even to licensees. This sensitive information is stored in yet another repository.</source>
          <target state="translated">한때 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 는 때때로 제 3 자에게 라이센스를 부여했습니다. 이러한 라이센스는 더 이상 발생하지 않습니다. 그러나 문제가 발생했을 때 TH3 테스트 사례 중 일부에는 민감한 정보가 포함되어 있으며 라이센스 사용자에게도 공개 할 수 없었습니다. 이 민감한 정보는 또 다른 저장소에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4d936f8adee7e8e3dc2d8a9b26c4bae945a9dd4c" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">현재이 기능을 사용하여 구성 할 수있는 옵션은 하나뿐입니다. ( &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT를&lt;/a&gt; 참조하십시오 .) 나중에 추가 옵션이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0662b7a2bebf7dce7d12510693eb67ca1548c61" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">현재이 기능을 사용하여 구성 할 수있는 옵션은 하나뿐입니다. ( &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT를&lt;/a&gt; 참조하십시오 .) 나중에 추가 옵션이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="598f95760d8ef9fc04e0c94379f28c6b7cd53470" translate="yes" xml:space="preserve">
          <source>At the beginning of a cache spill, the status of the database connection is as shown in &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Original page content has been saved in the rollback journal and modifications of the pages exist in user memory. To spill the cache, SQLite executes steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; through &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;. In other words, the rollback journal is flushed to disk, an exclusive lock is acquired, and changes are written into the database. But the remaining steps are deferred until the transaction really commits. A new journal header is appended to the end of the rollback journal (in its own sector) and the exclusive database lock is retained, but otherwise processing returns to &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. When the transaction commits, or if another cache spill occurs, steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; are repeated. (Step &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; is omitted on second and subsequent passes since an exclusive database lock is already held due to the first pass.)</source>
          <target state="translated">캐시 유출이 시작될 때 데이터베이스 연결 상태는 &lt;a href=&quot;#section_3_6&quot;&gt;3.6 단계와 같습니다&lt;/a&gt; . 원본 페이지 내용이 롤백 저널에 저장되었으며 페이지 수정 사항이 사용자 메모리에 있습니다. 캐시를 흘리기 위해 SQLite는 &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; 에서 &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; 단계를 실행합니다 . 즉, 롤백 저널이 디스크로 플러시되고 독점 잠금이 획득되고 변경 사항이 데이터베이스에 기록됩니다. 그러나 나머지 단계는 트랜잭션이 실제로 커밋 될 때까지 연기됩니다. 새로운 저널 헤더가 (자체 섹터에있는) 롤백 저널의 끝에 추가되고 배타적 데이터베이스 잠금은 유지되지만 그렇지 않으면 처리는 &lt;a href=&quot;#section_3_6&quot;&gt;3.6 단계로&lt;/a&gt; 돌아갑니다 . 트랜잭션이 커밋되거나 다른 캐시 유출이 발생하면 &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; 단계및 &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; 반복한다. 배타적 데이터베이스 잠금이 첫 번째 패스로 인해 이미 보유되었으므로 &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; 단계 는 두 번째 및 후속 패스에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a07c0967c09d3dbc3e32b1c4ad8479eec1c47ba2" translate="yes" xml:space="preserve">
          <source>At this point you are ready to type &quot;&lt;code&gt;./configure; make&lt;/code&gt;&quot; (or on Windows with MSVC, &quot;&lt;code&gt;nmake /f Makefile.msc&lt;/code&gt;&quot;).</source>
          <target state="translated">이제 &quot; &lt;code&gt;./configure; make&lt;/code&gt; &quot;(또는 MSVC가있는 Windows의 경우 &quot; &lt;code&gt;nmake /f Makefile.msc&lt;/code&gt; &quot;) 를 입력 할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5d9739e0c9d62ebb2f85f2435395edecdd3fc346" translate="yes" xml:space="preserve">
          <source>At this point, you can measure the amount of disk space used by the test1.db database and the space used by the test1.dir directory and all of its content. On a standard Ubuntu Linux desktop, the database file will be 1,024,512,000 bytes in size and the test1.dir directory will use 1,228,800,000 bytes of space (according to &quot;du -k&quot;), about 20% more than the database.</source>
          <target state="translated">이 시점에서 test1.db 데이터베이스가 사용하는 디스크 공간과 test1.dir 디렉토리가 사용하는 공간 및 모든 컨텐츠를 측정 할 수 있습니다. 표준 Ubuntu Linux 데스크탑에서 데이터베이스 파일의 크기는 1,024,512,000 바이트이며 test1.dir 디렉토리는 1,228,800,000 바이트의 공간 ( &quot;du -k&quot;에 따라)을 데이터베이스보다 약 20 % 더 많이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="05593853b78d4288d0ab3317d42f66fcc3356044" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the VDBE well enough to figure out on your own how the above program works. So we will not discuss it further in this text.</source>
          <target state="translated">이 시점에서 VDBE를 잘 이해하여 위 프로그램의 작동 방식을 스스로 파악해야합니다. 따라서 우리는이 본문에서 더 이상 논의하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ed93611b051b3f2ce2f2e18dd2aa20d02819e82" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the basics of how the VDBE writes to a database. Now let's look at how it does queries. We will use the following simple SELECT statement as our example:</source>
          <target state="translated">이 시점에서 VDBE가 데이터베이스에 쓰는 방법의 기본 사항을 이해해야합니다. 이제 어떻게 쿼리를하는지 봅시다. 다음 간단한 SELECT 문을 예제로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ca131936c53e26b047834300b8b5909015686af9" translate="yes" xml:space="preserve">
          <source>At this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire.</source>
          <target state="translated">현재 SQLite는 FOR EACH STATEMENT 트리거가 아닌 FOR EACH ROW 트리거 만 지원합니다. 따라서 FOR EACH ROW를 명시 적으로 지정하는 것은 선택 사항입니다. FOR EACH ROW는 트리거에 지정된 SQL 문이 명령문에 의해 삽입, 갱신 또는 삭제되는 각 데이터베이스 행에 대해 트리거에 지정된 SQL 문이 실행될 수 있음을 나타냅니다 (WHEN 절에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="9f2f2ddc27722f56f60ce157d4213f6b2caed0bd" translate="yes" xml:space="preserve">
          <source>At this writing, 2050 is still 34 years in the future. Nobody knows what will happen in that time, and we cannot absolutely promise that SQLite will be viable or useful that far out. But we can promise this: we plan as if we will be supporting SQLite until 2050. That long-term outlook affects our decisions in important ways.</source>
          <target state="translated">이 글을 쓰는 시점에서 2050 년은 여전히 ​​34 년입니다. 그 당시에 어떤 일이 일어날 지 아무도 모르며, SQLite가 멀리서도 가능하거나 유용 할 것이라고 절대 약속 할 수는 없습니다. 그러나 우리는 이것을 약속 할 수 있습니다. 2050 년까지 SQLite를 지원할 계획입니다. 이러한 장기적인 전망은 중요한 방식으로 의사 결정에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="5dc594be0856868f818e54abe920fd51cc599639" translate="yes" xml:space="preserve">
          <source>Atomic Commit In SQLite</source>
          <target state="translated">SQLite의 원자 커밋</target>
        </trans-unit>
        <trans-unit id="2d4c9569233db52020accb44326c29045c8c4cce" translate="yes" xml:space="preserve">
          <source>Atomic Transactions</source>
          <target state="translated">원자 거래</target>
        </trans-unit>
        <trans-unit id="01c8139f3cad23c8756bfadca13473ed3a8e76ee" translate="yes" xml:space="preserve">
          <source>Atomic commits for ATTACHed databases.</source>
          <target state="translated">첨부 된 데이터베이스에 대한 원자 커밋.</target>
        </trans-unit>
        <trans-unit id="d81553de52fcfae8fe4cc1bad5f59236dea06c3f" translate="yes" xml:space="preserve">
          <source>Atomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">뮤텍스를 원자 적으로 해제하고 비동기 신호를 기다리기 시작합니다. 신호가 도착하면 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="92dd7a0665a3434edc8f121885515c600f18e15b" translate="yes" xml:space="preserve">
          <source>Attach A Table To A Session Object</source>
          <target state="translated">세션 객체에 테이블 첨부</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">힙 메모리를 비우려고 시도</target>
        </trans-unit>
        <trans-unit id="88ccf4926dcde2d4398cadb109fcd1c1c1205d36" translate="yes" xml:space="preserve">
          <source>Attempt to optimize the database. All schemas are optimized in the first two forms, and only the specified schema is optimized in the latter two.</source>
          <target state="translated">데이터베이스를 최적화하십시오. 모든 스키마는 처음 두 가지 형식으로 최적화되며 지정된 스키마 만 두 가지 형식으로 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="72b5f89658d37542e4f2f47adfbbada66e9f74c3" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">가장 최근의 I / O 오류 또는 파일 열기 실패의 원인이 된 기본 운영 체제 오류 코드 또는 오류 번호를 리턴하려고 시도하십시오. 반환 값은 OS에 따라 다릅니다. 예를 들어, UNIX 시스템에서 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 가 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN을&lt;/a&gt; 리턴 한 후이 인터페이스를 호출하여 ENOSPC, EAUTH, EISDIR 등과 같은 문제점을 야기한 기본 &quot;errno&quot;를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50dfefcf7c07518a2714e6179a3b3e2c44246560" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">가장 최근의 I / O 오류 또는 파일 열기 실패의 원인이 된 기본 운영 체제 오류 코드 또는 오류 번호를 리턴하려고 시도하십시오. 반환 값은 OS에 따라 다릅니다. 예를 들어, UNIX 시스템에서 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 가 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN을&lt;/a&gt; 리턴 한 후이 인터페이스를 호출하여 ENOSPC, EAUTH, EISDIR 등과 같은 문제점을 야기한 기본 &quot;errno&quot;를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316c0eb6ee34ebe2465e653e0615de6cea48d923" translate="yes" xml:space="preserve">
          <source>Attempting to read any column value except the rowid from a contentless FTS5 table returns an SQL NULL value.</source>
          <target state="translated">컨텐츠가없는 FTS5 테이블에서 rowid를 제외한 모든 열 값을 읽으려고하면 SQL NULL 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="759ff226aedc6e7693575bc9de2859284a195a00" translate="yes" xml:space="preserve">
          <source>Attempts to signal a waiting thread.</source>
          <target state="translated">대기중인 스레드에 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="70c4d17e8ff8b4302eac4e4e2a0df21e83e7e1f7" translate="yes" xml:space="preserve">
          <source>Attribute to God, and not to self, whatever good you see in yourself.</source>
          <target state="translated">자신이 보는 선이 무엇이든 자기 자신이 아니라 신을 대리하십시오.</target>
        </trans-unit>
        <trans-unit id="825e25e0e089626089745a27ce2ef2c2c1ea38e6" translate="yes" xml:space="preserve">
          <source>Authorizer Action Codes</source>
          <target state="translated">권한 부 여자 조치 코드</target>
        </trans-unit>
        <trans-unit id="1592d27599a37fb2c21560009556822d633223ac" translate="yes" xml:space="preserve">
          <source>Authorizer Return Codes</source>
          <target state="translated">권한 부 여자 리턴 코드</target>
        </trans-unit>
        <trans-unit id="8d4b099d8f18d61aaa97d7c1192205d9f09f6d1b" translate="yes" xml:space="preserve">
          <source>Authorizer callback now notified of ALTER TABLE ADD COLUMN commands</source>
          <target state="translated">ALTER TABLE ADD COLUMN 명령을 알리는 권한 부 여자 콜백</target>
        </trans-unit>
        <trans-unit id="f99108c69c3665b09cc818cd43a65b08e779b2ac" translate="yes" xml:space="preserve">
          <source>Auto-vacuuming is only possible if the database stores some additional information that allows each database page to be traced backwards to its referrer. Therefore, auto-vacuuming must be turned on before any tables are created. It is not possible to enable or disable auto-vacuum after a table has been created.</source>
          <target state="translated">데이터베이스는 각 데이터베이스 페이지를 참조 자까지 역 추적 할 수있는 추가 정보를 데이터베이스에 저장 한 경우에만 자동 진공 청소가 가능합니다. 따라서 테이블을 작성하기 전에 자동 진공 청소기를 켜야합니다. 테이블이 생성 된 후 자동 진공을 활성화 또는 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20745b1bcf8af10b98b427193825b087099c77ec" translate="yes" xml:space="preserve">
          <source>AutoCommit</source>
          <target state="translated">AutoCommit</target>
        </trans-unit>
        <trans-unit id="356d8f675fe3749abf68433babe7ea3575fd985f" translate="yes" xml:space="preserve">
          <source>Autocheckpointing is enabled by default with an interval of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;.</source>
          <target state="translated">자동 검사 점은 기본적으로 1000 간격 또는 &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; 간격으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="22f681c869bb1ea71c5ddca4b639af93b4fef9e9" translate="yes" xml:space="preserve">
          <source>Autoincrement now works for INSERT from a SELECT.</source>
          <target state="translated">자동 증가는 이제 SELECT에서 INSERT에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be6b6b970c4ffe43f44cd98c8c080e19e0935d7d" translate="yes" xml:space="preserve">
          <source>Automatic Creation Of Triggers</source>
          <target state="translated">트리거 자동 생성</target>
        </trans-unit>
        <trans-unit id="b08dba6041d7d4235968c19294ed55fda427f921" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo Using SQLite</source>
          <target state="translated">SQLite를 사용하여 자동 실행 취소 / 다시 실행</target>
        </trans-unit>
        <trans-unit id="e4c6cb294be7b858504d17f8ae3afc2b1d34ca14" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo With SQLite</source>
          <target state="translated">SQLite를 사용한 자동 실행 취소 / 다시 실행</target>
        </trans-unit>
        <trans-unit id="21544829b41ef1983cd743adcc40b46678a3e3f5" translate="yes" xml:space="preserve">
          <source>Automatic caching of prepared statements in the TCL interface</source>
          <target state="translated">TCL 인터페이스에서 준비된 명령문의 자동 캐싱</target>
        </trans-unit>
        <trans-unit id="5c31289d03ed4b24b0edaf412e508ce77bc130da" translate="yes" xml:space="preserve">
          <source>Automatic indexing</source>
          <target state="translated">자동 인덱싱</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">정적으로 연결된 확장 프로그램 자동로드</target>
        </trans-unit>
        <trans-unit id="1866c31db7344041c61c845f3e6c7f6209984d28" translate="yes" xml:space="preserve">
          <source>Automatically Running ANALYZE</source>
          <target state="translated">자동 실행 분석</target>
        </trans-unit>
        <trans-unit id="4babc7f522c90b701f1e40024660f0e6d3fdb828" translate="yes" xml:space="preserve">
          <source>Automatically build binaries for Linux and Windows and put them on the website.</source>
          <target state="translated">Linux 및 Windows 용 바이너리를 자동으로 빌드하여 웹 사이트에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="b5a9f83671a7145cd855649b0b10c0da797dd48a" translate="yes" xml:space="preserve">
          <source>Automatically generated ROWIDs are now sequential.</source>
          <target state="translated">자동 생성 된 ROWID는 이제 순차적입니다.</target>
        </trans-unit>
        <trans-unit id="33b507ce65fb930f163c0cce40902e91ce9a4aa2" translate="yes" xml:space="preserve">
          <source>Automatically intercepts the raw &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output and reformats it into an ASCII-art graph.</source>
          <target state="translated">원시 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 출력을 자동으로 가로 채서 ASCII 아트 그래프로 다시 포맷합니다.</target>
        </trans-unit>
        <trans-unit id="415678a6fe9db48ebfdb4a92834062e2d75ff761" translate="yes" xml:space="preserve">
          <source>Automatically running ANALYZE</source>
          <target state="translated">ANALYZE 자동 실행</target>
        </trans-unit>
        <trans-unit id="38a90bc3ee0845edb1d6db34dc8f58cfefb8e89a" translate="yes" xml:space="preserve">
          <source>Autovacuum support added</source>
          <target state="translated">Autovacuum 지원 추가</target>
        </trans-unit>
        <trans-unit id="1e357312422cd5ec59a0a1ff553c35208f6f0981" translate="yes" xml:space="preserve">
          <source>Auxiliary Function Changes</source>
          <target state="translated">보조 기능 변경</target>
        </trans-unit>
        <trans-unit id="2291a1b828f145bde8901e514ec4c748f1d3e7aa" translate="yes" xml:space="preserve">
          <source>Auxiliary columns are marked with a &quot;+&quot; symbol before the column name. Auxiliary columns must come after all of the coordinate boundary columns. There is a limit of no more than 100 auxiliary columns. The following example shows an r-tree table with auxiliary columns that is equivalent to the two tables &quot;demo_index&quot; and &quot;demo_data&quot; above:</source>
          <target state="translated">보조 열은 열 이름 앞에 &quot;+&quot;기호로 표시됩니다. 보조 열은 모든 좌표 경계 열 뒤에 와야합니다. 보조 열은 100 개 이하로 제한됩니다. 다음 예는 위의 두 테이블 &quot;demo_index&quot;및 &quot;demo_data&quot;에 해당하는 보조 열이있는 r- 트리 테이블을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="107b868f1f6fb032b0de401c1fdc39f9a1324503" translate="yes" xml:space="preserve">
          <source>Auxiliary columns in r-tree tables</source>
          <target state="translated">r- 트리 테이블의 보조 열</target>
        </trans-unit>
        <trans-unit id="6771e220703ae7d95117926a910b1882f3865ed2" translate="yes" xml:space="preserve">
          <source>Auxiliary function mapping</source>
          <target state="translated">보조 기능 매핑</target>
        </trans-unit>
        <trans-unit id="2a6030396538d218b7dda424404dbcc0322cf175" translate="yes" xml:space="preserve">
          <source>Auxiliary functions are similar to &lt;a href=&quot;lang_corefunc&quot;&gt;SQL scalar functions&lt;/a&gt;, except that they may only be used within full-text queries (those that use the MATCH operator) on an FTS5 table. Their results are calculated based not only on the arguments passed to them, but also on the current match and matched row. For example, an auxiliary function may return a numeric value indicating the accuracy of the match (see the &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25()&lt;/a&gt; function), or a fragment of text from the matched row that contains one or more instances of the search terms (see the &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet()&lt;/a&gt; function).</source>
          <target state="translated">보조 함수는 FTS5 테이블의 전체 텍스트 쿼리 (MATCH 연산자를 사용하는 쿼리) 내에서만 사용할 수 있다는 점을 제외하고 &lt;a href=&quot;lang_corefunc&quot;&gt;SQL 스칼라 함수&lt;/a&gt; 와 유사 합니다. 결과는 전달 된 인수뿐만 아니라 현재 일치 및 일치하는 행을 기반으로 계산됩니다. 예를 들어 보조 함수는 일치 정확도를 나타내는 숫자 값 ( &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ()&lt;/a&gt; 함수 참조) 또는 하나 이상의 검색어 인스턴스를 포함하는 일치하는 행의 텍스트 조각을 반환 할 수 있습니다 ( &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;스 니펫 ( )&lt;/a&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="ad21e0c1521884ee05b9ffda048d19b6293bf5a4" translate="yes" xml:space="preserve">
          <source>Available as a &lt;a href=&quot;amalgamation&quot;&gt;single ANSI-C source-code file&lt;/a&gt; that is &lt;a href=&quot;howtocompile&quot;&gt;easy to compile&lt;/a&gt; and hence is easy to add into a larger project.</source>
          <target state="translated">A와 가능한 &lt;a href=&quot;amalgamation&quot;&gt;한 ANSI-C 소스 코드 파일&lt;/a&gt; 입니다 &lt;a href=&quot;howtocompile&quot;&gt;컴파일하기 쉽고&lt;/a&gt; 따라서 더 큰 프로젝트에 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91da5ef1fa7e2e4b29d2c4baf5ea203498773356" translate="yes" xml:space="preserve">
          <source>Avoid a possible use-after-free error by deferring schema resets until after the query planner has finished running. Ticket &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</source>
          <target state="translated">쿼리 플래너 실행이 완료 될 때까지 스키마 재설정을 연기하여 사용 후 사용 가능 오류를 피하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;BE436A7F4587CE5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e3177c978c905dc59ea3eac3bcce9510d2af169" translate="yes" xml:space="preserve">
          <source>Avoid cache pages leaks following disk-full or I/O errors</source>
          <target state="translated">디스크 가득 참 또는 I / O 오류로 인한 캐시 페이지 누출 방지</target>
        </trans-unit>
        <trans-unit id="61ddd5eec59e56887e4ac83b6d688d5421fe618d" translate="yes" xml:space="preserve">
          <source>Avoid excess heap usage when copying expressions.</source>
          <target state="translated">표현식을 복사 할 때 과도한 힙 사용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="24ba1f7d7979447a7e96cb25e07064d86e5bb1c8" translate="yes" xml:space="preserve">
          <source>Avoid invoking the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; callback multiple times when a statement is automatically reprepared due to &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors.</source>
          <target state="translated">&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 로 인해 명령문이 자동으로 다시 준비 될 때 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 콜백을 여러 번 호출하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="7080f3e1eff1f709a6ca19cf689cc05b5715bf56" translate="yes" xml:space="preserve">
          <source>Avoid recomputing &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; and &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt; on unchanged columns in &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 에서 변경되지 않은 열에 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제한 조건&lt;/a&gt; 을 다시 계산 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b9f47e376b982a42c816c624a45b787e38257b92" translate="yes" xml:space="preserve">
          <source>Avoid resetting the schema of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; connections when any one connection closes. Instead, wait for the last connection to close before resetting the schema.</source>
          <target state="translated">하나의 연결이 닫힐 때 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 연결 의 스키마를 재설정하지 마십시오 . 대신 스키마를 재설정하기 전에 마지막 연결이 닫힐 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="d3426fcb94fc158c5d46e9b08cc237640ca2e54e" translate="yes" xml:space="preserve">
          <source>Avoid running foreign-key constraint checks on an UPDATE if none of the modified columns are associated with foreign keys.</source>
          <target state="translated">수정 된 열이 외래 키와 연결되어 있지 않으면 UPDATE에서 외래 키 제약 조건 검사를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fc8f5db6ab5f0aaaf5afe5d9db180abf76160161" translate="yes" xml:space="preserve">
          <source>Avoid this step if possible, as it defeats one of the huge advantages of the whole SQL language concept, specifically that the application programmer does not need to get involved with query planning. If you do use CROSS JOIN, wait until late in your development cycle to do so, and comment the use of CROSS JOIN carefully so that you can take it out later if possible. Avoid using CROSS JOIN early in the development cycle as doing so is a premature optimization, which is well known to be &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;the root of all evil&lt;/a&gt;.</source>
          <target state="translated">전체 SQL 언어 개념의 큰 장점 중 하나, 특히 응용 프로그램 프로그래머가 쿼리 계획에 관여 할 필요가 없다는 점을 무시하므로 가능하면이 단계를 피하십시오. CROSS JOIN을 사용하는 경우 개발주기가 늦을 때까지 기다렸다가 나중에 CROSS JOIN을 사용할 수 있도록주의하여 사용하십시오. 개발주기 초기에 CROSS JOIN을 사용하지 마십시오. 조기 최적화 &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;는 모든 악의 근원으로&lt;/a&gt; 잘 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d522f897af88e992f364f85aee2e8282258fc265" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary foreign key processing in UPDATE statements that do not touch the columns that are constrained by the foreign keys.</source>
          <target state="translated">외래 키로 제한되는 열을 건드리지 않는 UPDATE 문에서 불필요한 외래 키 처리를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="f0262f30f0e72ef13d068b5ef0d92433c9097800" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary invalidation of &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; handles when making changes to unrelated tables.</source>
          <target state="translated">관련이없는 테이블을 변경할 때 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 핸들 의 불필요한 무효화를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="2faf372496683418fb5422fedd49afd1602aeb2d" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary loads of columns in an aggregate query that are not within an aggregate function and that are not part of the GROUP BY clause.</source>
          <target state="translated">집계 함수 내에없고 GROUP BY 절의 일부가 아닌 집계 쿼리에서 불필요한 열로드를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="0da85f25c4d81aabb9be26649b6528ed9da5a865" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary reparsing of the database schema.</source>
          <target state="translated">데이터베이스 스키마의 불필요한 재분석을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="31ab1c695488dd1d3fd9d54bae9338af8b817457" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary writes to the sqlite_sequence table when an &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; table is updated with an rowid that is less than the maximum.</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 테이블이 최대 값보다 작은 rowid로 업데이트 될 때 sqlite_sequence 테이블에 대한 불필요한 쓰기를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="446e18ff4fd4514774047f13cdefc3e3875bc4b1" translate="yes" xml:space="preserve">
          <source>Avoid using a prepared statement for &quot;.stats on&quot; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; after it has been closed by the &quot;.eqp full&quot; logicc. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;.</source>
          <target state="translated">&quot;.eqp full&quot;logicc에 의해 닫힌 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 의 &quot;.stats on&quot;명령에 대해 준비된 명령문을 사용하지 마십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="e234fd1edb94740adc1207ebef38597b49b7c1f2" translate="yes" xml:space="preserve">
          <source>Avoiding the use of low-numbered file descriptors is a defense against accidental database corruption. If a database file was opened using file descriptor 2, for example, and then an assert() failed and invoked write(2,...), that would likely cause database corruption by overwriting part of the database file with the assertion error message. Using only higher-valued file descriptors avoids this potential problem. The protection against using low-numbered file descriptors can be disabled by setting this compile-time option to 0.</source>
          <target state="translated">번호가 낮은 파일 디스크립터를 사용하지 않는 것은 우발적 인 데이터베이스 손상을 방지합니다. 예를 들어 파일 디스크립터 2를 사용하여 데이터베이스 파일을 연 다음 assert ()가 실패하고 write (2, ...)를 호출 한 경우 데이터베이스 파일의 일부를 어설 션 오류 메시지로 겹쳐 써서 데이터베이스가 손상 될 수 있습니다. . 가치가 높은 파일 디스크립터 만 사용하면이 잠재적 인 문제를 피할 수 있습니다. 이 컴파일 타임 옵션을 0으로 설정하면 낮은 번호의 파일 디스크립터를 사용하지 못하도록 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4253b60bc870d118d832ba2a3c8eabe133ebeb0" translate="yes" xml:space="preserve">
          <source>Aways stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="translated">자리 비움은 이진 형식을 사용하여 다각형을 저장하므로 더 빠르고 공간을 덜 사용합니다.</target>
        </trans-unit>
        <trans-unit id="209ebb59c54866e4ac4c2bdf04c9d0b7b4a958ec" translate="yes" xml:space="preserve">
          <source>B-Tree</source>
          <target state="translated">B-Tree</target>
        </trans-unit>
        <trans-unit id="b149afb9ac3420444ce1e62aefbcdead10e7e777" translate="yes" xml:space="preserve">
          <source>B-tree</source>
          <target state="translated">B-tree</target>
        </trans-unit>
        <trans-unit id="5b87dc158f4c367648401e86eddf1c6445bb5bf6" translate="yes" xml:space="preserve">
          <source>B-tree Cell Format</source>
          <target state="translated">B- 트리 셀 형식</target>
        </trans-unit>
        <trans-unit id="92950af5441bd3255130ef7a72cc86532e49b1e9" translate="yes" xml:space="preserve">
          <source>B-tree Page Header Format</source>
          <target state="translated">B- 트리 페이지 헤더 형식</target>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="4821edeb87e72ffadc6bc2dd7758d1af495e515f" translate="yes" xml:space="preserve">
          <source>BEGIN IMMEDIATE</source>
          <target state="translated">시작 즉시</target>
        </trans-unit>
        <trans-unit id="8913dda08c8185748e987da82c484c6d35030cb9" translate="yes" xml:space="preserve">
          <source>BEGIN TRANSACTION</source>
          <target state="translated">거래 시작</target>
        </trans-unit>
        <trans-unit id="51b1b0c3e98b1211a4bf44a668731efbeb0029e7" translate="yes" xml:space="preserve">
          <source>BEGIN;</source>
          <target state="translated">BEGIN;</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="21ca9d91ce78c58717f1f26654ca03e2a7b624ba" translate="yes" xml:space="preserve">
          <source>BLOB (a.k.a &quot;NONE&quot;)</source>
          <target state="translated">BLOB (일명 &quot;NONE&quot;)</target>
        </trans-unit>
        <trans-unit id="16304f06bca682f9f5ee4a2a62fcbf2abac5ed50" translate="yes" xml:space="preserve">
          <source>BLOB literals are string literals containing hexadecimal data and preceded by a single &quot;x&quot; or &quot;X&quot; character. Example: X'53514C697465'</source>
          <target state="translated">BLOB 리터럴은 16 진 데이터를 포함하고 단일 &quot;x&quot;또는 &quot;X&quot;문자가 앞에 오는 문자열 리터럴입니다. 예 : X'53514C697465 '</target>
        </trans-unit>
        <trans-unit id="fb465d6672ffe8826d619cf7ad2f842e941cbb22" translate="yes" xml:space="preserve">
          <source>BLOB size</source>
          <target state="translated">BLOB 크기</target>
        </trans-unit>
        <trans-unit id="80845ed51d0eb2f39da54fe848593b51f5b7523f" translate="yes" xml:space="preserve">
          <source>BLOB support.</source>
          <target state="translated">BLOB 지원.</target>
        </trans-unit>
        <trans-unit id="9bf36d55a66f6b65f2497e6f96eb9c688f9ee788" translate="yes" xml:space="preserve">
          <source>BLOB values (even serial types 12 and larger) sort last and in the order determined by memcmp().</source>
          <target state="translated">BLOB 값 (직렬 유형 12 이상)도 memcmp ()에 의해 결정된 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="066ed32331b295c453ee3f4c55916aa0d7c725b0" translate="yes" xml:space="preserve">
          <source>BLOBs sort last</source>
          <target state="translated">BLOB 마지막 정렬</target>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="987f01f766f58cd662fc3c685393d0d4667cbc0b" translate="yes" xml:space="preserve">
          <source>Back up cursor P1 so that it points to the previous key/data pair in its table or index. If there is no previous key/value pairs then fall through to the following instruction. But if the cursor backup was successful, jump immediately to P2.</source>
          <target state="translated">테이블 또는 인덱스의 이전 키 / 데이터 쌍을 가리 키도록 커서 P1을 백업하십시오. 이전 키 / 값 쌍이없는 경우 다음 명령어로 넘어갑니다. 그러나 커서 백업에 성공하면 즉시 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f09881dbbda2f40a1bff480104e690d3c9470795" translate="yes" xml:space="preserve">
          <source>Backport a &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;simple query planner optimization&lt;/a&gt; that allows the IS operator to drive an index on a LEFT OUTER JOIN. No other changes from the &lt;a href=&quot;#version_3_9_2&quot;&gt;version 3.9.2&lt;/a&gt; baseline.</source>
          <target state="translated">IS 연산자가 LEFT OUTER JOIN에서 인덱스를 구동 할 수 있도록 하는 &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;간단한 쿼리 플래너 최적화&lt;/a&gt; 를 백 포트합니다 . &lt;a href=&quot;#version_3_9_2&quot;&gt;버전 3.9.2&lt;/a&gt; 기준 과 다른 변경 사항은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="88c7762ebd772cef5a8b0f5dbf885740af02d796" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">백업 A : &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3758d4866043fb72f7921be565221b2798bf18ec" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">백업 A : &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5635a7bbe580f297d0f1cfe698eb39a60af249f7" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">백업 A : &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="354ff6f3afacd7c64aab0b45ca232e39fd5ab191" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">백업 B : &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a437cf7f4394ac5ab3c8c6bf1f4decbf817f299c" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">백업 B : &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06b0bc099757fb937c2145628c4ebe2caf89fed6" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">백업 B : &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad652023d4f99d0238bf9d42108eaead0a853d3a" translate="yes" xml:space="preserve">
          <source>Backup-filename</source>
          <target state="translated">Backup-filename</target>
        </trans-unit>
        <trans-unit id="8999e5aefef2d471c86fa4aebf649d22b2fddfc3" translate="yes" xml:space="preserve">
          <source>Backups on private servers</source>
          <target state="translated">개인 서버의 백업</target>
        </trans-unit>
        <trans-unit id="63591d4f03e6c8c8462a238e710f0f3cd900691f" translate="yes" xml:space="preserve">
          <source>Backwards compatibility constraints mean that SQLite is only able to store values that are NULL, integers, floating-point numbers, text, and BLOBs. It is not possible to add a sixth &quot;JSON&quot; type.</source>
          <target state="translated">이전 버전과의 호환성 제약 조건은 SQLite가 NULL, 정수, 부동 소수점 숫자, 텍스트 및 BLOB 값만 저장할 수 있음을 의미합니다. 여섯 번째 &quot;JSON&quot;유형을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac8e908309343005a016d54d23589bde15362521" translate="yes" xml:space="preserve">
          <source>Backwards compatibility note:</source>
          <target state="translated">이전 버전과의 호환성 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="70457c51de59bc0303eae7ef527e14f90b80a187" translate="yes" xml:space="preserve">
          <source>Backwards-incompatible changes to some extensions in order to take advantage of the improved security offered by the new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;:</source>
          <target state="translated">새로운 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스&lt;/a&gt; 에서 제공하는 향상된 보안 기능을 활용하기 위해 일부 확장에 대한 이전 버전과 호환되지 않는 변경 사항 :</target>
        </trans-unit>
        <trans-unit id="af928fbbb6d75554958505ba9734eca9710f8051" translate="yes" xml:space="preserve">
          <source>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</source>
          <target state="translated">나쁜 프로그래머는 코드에 대해 걱정합니다. 훌륭한 프로그래머는 데이터 구조와 관계에 대해 걱정합니다.</target>
        </trans-unit>
        <trans-unit id="d97ded08ec4df20e52b3ce05668bb0a2705fa978" translate="yes" xml:space="preserve">
          <source>Bare aggregate terms</source>
          <target state="translated">베어 집계 용어</target>
        </trans-unit>
        <trans-unit id="5e2b9b9d48fdc95bbb5af1e6353dd4395e3738d9" translate="yes" xml:space="preserve">
          <source>Based on the above, SQLite is designed around a model of the file-system whereby any sector of a file written to is considered to be in a transient state until after the file has been successfully</source>
          <target state="translated">위의 내용을 기반으로 SQLite는 파일 시스템 모델을 중심으로 설계되었으므로 파일의 모든 섹터는 파일이 성공적으로 완료 될 때까지 일시적 상태로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="2843b17c6eb4616657b580040fb118c722f6edb6" translate="yes" xml:space="preserve">
          <source>Be a help in times of trouble.</source>
          <target state="translated">어려움에 처했을 때 도움을 받으십시오.</target>
        </trans-unit>
        <trans-unit id="d1a6a5570deb3a7eb7ea55daa060ee1c39dbe74c" translate="yes" xml:space="preserve">
          <source>Be a stranger to the world's ways.</source>
          <target state="translated">세상의 길에 낯선 사람이 되십시오.</target>
        </trans-unit>
        <trans-unit id="7fe99077b2a420989db9a6580456c2197461f868" translate="yes" xml:space="preserve">
          <source>Be careful when using the &quot;.save&quot; command as it will overwrite any preexisting database files having the same name without prompting for confirmation. As with the &quot;.open&quot; command, you might want to use a full pathname with forward-slash directory separators to avoid ambiguity.</source>
          <target state="translated">&quot;.save&quot;명령을 사용할 때는 확인을 요구하지 않고 동일한 이름을 가진 기존 데이터베이스 파일을 덮어 쓰므로주의하십시오. &quot;.open&quot;명령과 마찬가지로, 애매함을 피하기 위해 슬래시 디렉토리 구분 기호와 함께 전체 경로 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131acb5be798f8713c6bbeeaf8a6813dbe81748d" translate="yes" xml:space="preserve">
          <source>Be in dread of hell.</source>
          <target state="translated">지옥을 두려워하십시오.</target>
        </trans-unit>
        <trans-unit id="dbdb220ba30f3bde62d258265aacea82a8c9ef6a" translate="yes" xml:space="preserve">
          <source>Be not a detractor.</source>
          <target state="translated">낙담하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d18586b20264d29baf4b88bd2bdc140f64986d83" translate="yes" xml:space="preserve">
          <source>Be not a great eater.</source>
          <target state="translated">훌륭한 먹는 사람이되지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7c62076277d9f6b2639631bb528912ff4eff4ffa" translate="yes" xml:space="preserve">
          <source>Be not a grumbler.</source>
          <target state="translated">불평꾼이되지 마십시오.</target>
        </trans-unit>
        <trans-unit id="288a450b2fc66179cb51c9c9d0a00b7f03fc2121" translate="yes" xml:space="preserve">
          <source>Be not addicted to wine.</source>
          <target state="translated">와인에 중독되지 마십시오.</target>
        </trans-unit>
        <trans-unit id="30d66a95d2dfd76a1e01a40e31a7daa8f6db0117" translate="yes" xml:space="preserve">
          <source>Be not drowsy.</source>
          <target state="translated">졸리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c8f81046cf302e1b08a651f45ee31005254461af" translate="yes" xml:space="preserve">
          <source>Be not jealous, nor harbor envy.</source>
          <target state="translated">질투하거나 부러워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f5bf647a944160204f29d66b6480eda5640fcdc" translate="yes" xml:space="preserve">
          <source>Be not lazy.</source>
          <target state="translated">게으르지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1c899d6734a837258800bab2a2f7343b95199829" translate="yes" xml:space="preserve">
          <source>Be not proud.</source>
          <target state="translated">자랑스러워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9305ebf69b60c3d882da16805b530bbf3e6f3d95" translate="yes" xml:space="preserve">
          <source>Bear persecution for justice's sake.</source>
          <target state="translated">정의를 위해 박해를가하십시오.</target>
        </trans-unit>
        <trans-unit id="6ca5c28c37834244df00d49b68c2bef2606b1e1f" translate="yes" xml:space="preserve">
          <source>Because &quot;text&quot; columns have a different sort order from numeric, indices on &quot;text&quot; columns occur in a different order for version 2.7.0 and later database. Hence version 2.6.3 and earlier of SQLite will be unable to read a 2.7.0 or later database. But version 2.7.0 and later of SQLite will read earlier databases.</source>
          <target state="translated">&quot;텍스트&quot;열은 숫자와 정렬 순서가 다르기 때문에 &quot;텍스트&quot;열의 인덱스는 버전 2.7.0 이상의 데이터베이스에서 다른 순서로 발생합니다. 따라서 SQLite 2.6.3 및 이전 버전은 2.7.0 이상의 데이터베이스를 읽을 수 없습니다. 그러나 SQLite 버전 2.7.0 이상에서는 이전 데이터베이스를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="85eeb52404350645676cc7b1bb211e4acfd5ad5b" translate="yes" xml:space="preserve">
          <source>Because AUTOINCREMENT keyword changes the behavior of the ROWID selection algorithm, AUTOINCREMENT is not allowed on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or on any table column other than INTEGER PRIMARY KEY. Any attempt to use AUTOINCREMENT on a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or on a column other than the INTEGER PRIMARY KEY column results in an error.</source>
          <target state="translated">AUTOINCREMENT 키워드는 ROWID 선택 알고리즘의 동작을 변경하므로 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 또는 INTEGER PRIMARY KEY 이외의 테이블 열에 는 AUTOINCREMENT가 허용되지 않습니다 . &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 또는 INTEGER PRIMARY KEY 컬럼 이외의 컬럼에서 AUTOINCREMENT를 사용하려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eeb868502c2d293980db003c26a1d7e59cde0343" translate="yes" xml:space="preserve">
          <source>Because FTS3 and FTS4 are virtual tables, The &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; compile-time option is incompatible with the &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; option.</source>
          <target state="translated">FTS3 및 FTS4는 가상 테이블이므로 &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; 컴파일 타임 옵션은 &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4912d0649aa9ed8b2a285af375de29c2823b504b" translate="yes" xml:space="preserve">
          <source>Because Lemon is a program not normally found on development machines, the complete source code to Lemon (just one C file) is included in the SQLite distribution in the &quot;tool&quot; subdirectory.</source>
          <target state="translated">레몬은 일반적으로 개발 머신에서 찾을 수없는 프로그램이므로 레몬에 대한 완전한 소스 코드 (단 하나의 C 파일)는 &quot;tool&quot;서브 디렉토리의 SQLite 배포에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c877f3293b1082ca722e1e4a350d52f335812101" translate="yes" xml:space="preserve">
          <source>Because SQLite is flexible and forgiving with regard to datatypes, table columns can be created that have no specified datatype at all. For example:</source>
          <target state="translated">SQLite는 데이터 유형과 관련하여 유연하고 관대하기 때문에 지정된 데이터 유형이 전혀없는 테이블 열을 만들 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="89b4ac6aceecf052168be7879566274bb4b65047" translate="yes" xml:space="preserve">
          <source>Because ZIP archives are optimized for storing big chunks of content, they encourage a style of programming where the entire document is read into memory at startup, all editing occurs in memory, then the entire document is written to disk during &quot;File/Save&quot;. OpenOffice and its descendants embrace that pattern.</source>
          <target state="translated">ZIP 아카이브는 많은 양의 컨텐츠를 저장하는 데 최적화되어 있기 때문에 시작시 전체 문서를 메모리로 읽어들이는 모든 프로그래밍 방식을 메모리에서 읽은 다음 &quot;파일 / 저장&quot;중에 전체 문서를 디스크에 쓰는 프로그래밍 스타일을 권장합니다. OpenOffice와 그 후손들은 그 패턴을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="1aef204394eb2f42a054518ac1383e25f6308e7c" translate="yes" xml:space="preserve">
          <source>Because allocations are all the same size, the memory allocator can operate much faster. The allocator need not bother with coalescing adjacent free slots or searching for a slot of an appropriate size. All unallocated memory slots can be stored on a linked list. Allocating consists of removing the first entry from the list. Deallocating is simply adding an entry to the beginning of the list.</source>
          <target state="translated">할당은 모두 같은 크기이므로 메모리 할당자는 훨씬 빠르게 작동 할 수 있습니다. 할당자는 인접한 빈 슬롯을 병합하거나 적절한 크기의 슬롯을 검색 할 필요가 없습니다. 할당되지 않은 모든 메모리 슬롯은 연결된 목록에 저장할 수 있습니다. 할당은 목록에서 첫 번째 항목을 제거하는 것으로 구성됩니다. 할당 해제는 단순히 목록의 시작 부분에 항목을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8fe792a90bccd6800bd67f3f37ebbaabb1467610" translate="yes" xml:space="preserve">
          <source>Because an SQLite database is a single compact file in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined cross-platform format&lt;/a&gt;, it is often used as a container for transferring content from one system to another. The sender gathers content into an SQLite database file, transfers that one file to the receiver, then the receiver uses SQL to extract the content as needed.</source>
          <target state="translated">SQLite 데이터베이스는 &lt;a href=&quot;fileformat2&quot;&gt;잘 정의 된 크로스 플랫폼 형식&lt;/a&gt; 의 단일 압축 파일이기 때문에 종종 한 시스템에서 다른 시스템으로 컨텐츠를 전송하기위한 컨테이너로 사용됩니다. 송신자는 컨텐츠를 SQLite 데이터베이스 파일로 수집하고 해당 파일을 수신자에게 전송 한 다음 수신자는 SQL을 사용하여 필요에 따라 컨텐츠를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a4c1f92dc828402b18e6e117bb816b40d1c734ed" translate="yes" xml:space="preserve">
          <source>Because an SQLite database requires no administration, it works well in devices that must operate without expert human support. SQLite is a good fit for use in cellphones, set-top boxes, televisions, game consoles, cameras, watches, kitchen appliances, thermostats, automobiles, machine tools, airplanes, remote sensors, drones, medical devices, and robots: the &quot;internet of things&quot;.</source>
          <target state="translated">SQLite 데이터베이스는 관리가 필요하지 않으므로 전문가의 전문적인 지원없이 작동해야하는 장치에서 잘 작동합니다. SQLite는 휴대폰, 셋톱 박스, 텔레비전, 게임 콘솔, 카메라, 시계, 주방 용품, 온도 조절 장치, 자동차, 공작 기계, 비행기, 원격 센서, 드론, 의료 기기 및 로봇에 사용하기에 적합합니다. &quot;의.</target>
        </trans-unit>
        <trans-unit id="788be5cf964c9ee21f08ece0ea7377ef2e19234d" translate="yes" xml:space="preserve">
          <source>Because assert() can be and is commonly misused, some programming language theorists and designers look upon it with disfavor. For example, the designers of the &lt;a href=&quot;https://golang.org&quot;&gt;Go programming language&lt;/a&gt; intentionally &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;omit a built-in assert()&lt;/a&gt;. They feel that the harm caused by misuse of assert() outweighs the benefits of including it as a language built-in. The SQLite developers disagree. In fact, the original purpose of this article is to push back against the common notion that assert() is harmful. In our experience, SQLite would be much more difficult to develop, test, and maintain without assert().</source>
          <target state="translated">assert ()는 일반적으로 오용 될 수 있고 일반적으로 오용되기 때문에 일부 프로그래밍 언어 이론가와 디자이너는이를 선호하지 않습니다. 예를 들어 &lt;a href=&quot;https://golang.org&quot;&gt;Go 프로그래밍 언어&lt;/a&gt; 디자이너는 의도적 &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;으로 내장 assert ()를 생략합니다&lt;/a&gt; . 그들은 assert ()의 오용으로 인한 피해가 언어를 내장 언어로 포함시키는 것의 이점보다 중요하다고 생각합니다. SQLite 개발자는 동의하지 않습니다. 사실,이 기사의 원래 목적은 assert ()가 해롭다는 일반적인 개념에 반하여 반대하는 것입니다. 경험상 SQLite는 assert () 없이는 개발, 테스트 및 유지 관리가 훨씬 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6c8b76107dc390feb365087dd23a9e6847d8ec8" translate="yes" xml:space="preserve">
          <source>Because it does not have a central server to coordinate access, SQLite must close and reopen the database file, and thus invalidate its cache, for each transaction. In this test, each SQL statement is a separate transaction so the database file must be opened and closed and the cache must be flushed 1000 times. In spite of this, the asynchronous version of SQLite is still nearly as fast as MySQL. Notice how much slower the synchronous version is, however. SQLite calls &lt;b&gt;fsync()&lt;/b&gt; after each synchronous transaction to make sure that all data is safely on the disk surface before continuing. For most of the 13 seconds in the synchronous test, SQLite was sitting idle waiting on disk I/O to complete.</source>
          <target state="translated">액세스를 조정하는 중앙 서버가 없기 때문에 SQLite는 데이터베이스 파일을 닫았다가 다시 열어야하므로 각 트랜잭션마다 캐시를 ​​무효화해야합니다. 이 테스트에서 각 SQL 문은 별도의 트랜잭션이므로 데이터베이스 파일을 열고 닫고 캐시를 1000 번 플러시해야합니다. 그럼에도 불구하고 SQLite의 비동기 버전은 여전히 ​​MySQL만큼 빠릅니다. 그러나 동기 버전이 얼마나 느리게 진행되는지 확인하십시오. SQLite는 각 동기화 트랜잭션 후에 &lt;b&gt;fsync ()를&lt;/b&gt; 호출 하여 계속하기 전에 모든 데이터가 디스크 표면에 안전하게 있는지 확인합니다. 동기 테스트에서 13 초 동안 대부분 SQLite는 디스크 I / O가 완료되기를 기다리면서 유휴 상태였습니다.</target>
        </trans-unit>
        <trans-unit id="44c3dab6a322e3be0dd40f52ec50b7f7abadf611" translate="yes" xml:space="preserve">
          <source>Because it is a simulator, running a binary in Valgrind is slower than running it on native hardware. (To a first approximation, an application running in Valgrind on a workstation will perform about the same as it would running natively on a smartphone.) So it is impractical to run the full SQLite test suite through Valgrind. However, the veryquick tests and the coverage of the TH3 tests are run through Valgrind prior to every release.</source>
          <target state="translated">시뮬레이터이기 때문에 Valgrind에서 바이너리를 실행하는 것이 기본 하드웨어에서 실행하는 것보다 느립니다. (첫 번째 근사치로 워크 스테이션에서 Valgrind에서 실행되는 응용 프로그램은 기본적으로 스마트 폰에서 실행되는 것과 거의 동일하게 수행됩니다.) 따라서 Valgrind를 통해 전체 SQLite 테스트 스위트를 실행하는 것은 비현실적입니다. 그러나 매우 빠른 테스트와 TH3 테스트의 적용 범위는 모든 릴리스 전에 Valgrind를 통해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d7f244d51b1fc8bd92e3755f3ff4412ae2f2b57" translate="yes" xml:space="preserve">
          <source>Because it is simple to setup and use (installation is trivial: just copy the &lt;b&gt;sqlite3&lt;/b&gt; or &lt;b&gt;sqlite3.exe&lt;/b&gt; executable to the target machine and run it) SQLite makes a good database engine for use in teaching SQL. Students can easily create as many databases as they like and can email databases to the instructor for comments or grading. For more advanced students who are interested in studying how an RDBMS is implemented, the modular and well-commented and documented SQLite code can serve as a good basis.</source>
          <target state="translated">설정 및 사용이 간단하기 때문에 (설치는 간단합니다. &lt;b&gt;sqlite3&lt;/b&gt; 또는 &lt;b&gt;sqlite3.exe&lt;/b&gt; 실행 파일을 대상 시스템에 복사 하고 실행하면됩니다) SQLite는 SQL을 교육하는 데 사용하기에 적합한 데이터베이스 엔진을 만듭니다. 학생들은 원하는만큼 데이터베이스를 쉽게 만들 수 있으며, 의견이나 채점을 위해 강사에게 데이터베이스를 이메일로 보낼 수 있습니다. RDBMS가 어떻게 구현되는지 연구하는 데 관심이있는 상급 학생들을 위해, 잘 짜여진 모듈화되고 문서화 된 SQLite 코드가 좋은 기반이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f8ea41ffd9236f49c6f3b48d5813c7ba03da82f" translate="yes" xml:space="preserve">
          <source>Because it reorganizes the entire FTS index, the optimize command can take a long time to run. The &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt; can be used to divide the work of optimizing the FTS index into multiple steps. To do this:</source>
          <target state="translated">전체 FTS 인덱스를 재구성하므로 optimize 명령을 실행하는 데 시간이 오래 걸릴 수 있습니다. &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 병합 명령은&lt;/a&gt; 여러 단계로 FTS 인덱스를 최적화하는 작업을 분할하는 데 사용할 수 있습니다. 이것을하기 위해:</target>
        </trans-unit>
        <trans-unit id="444393da5087c1cdc4456d5a26de8bf63b917b08" translate="yes" xml:space="preserve">
          <source>Because it stores extra information on disk in two new &lt;a href=&quot;fts3#*shadowtab&quot;&gt;shadow tables&lt;/a&gt; in order to support the performance optimizations and extra matchinfo() options, FTS4 tables may consume more disk space than the equivalent table created using FTS3. Usually the overhead is 1-2% or less, but may be as high as 10% if the documents stored in the FTS table are very small. The overhead may be reduced by specifying the directive &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; as part of the FTS4 table declaration, but this comes at the expense of sacrificing some of the extra supported matchinfo() options.</source>
          <target state="translated">성능 최적화 및 추가 matchinfo () 옵션을 지원하기 위해 디스크에 추가 정보를 두 개의 새 &lt;a href=&quot;fts3#*shadowtab&quot;&gt;새도우 테이블&lt;/a&gt; 에 저장 하므로 FTS4 테이블은 FTS3을 사용하여 작성된 동등한 테이블보다 많은 디스크 공간을 소비 할 수 있습니다. 일반적으로 오버 헤드는 1-2 % 이하이지만 FTS 테이블에 저장된 문서가 매우 작은 경우 10 %가 될 수 있습니다. FTS4 테이블 선언의 일부로 지시문 &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo = fts3&quot;&lt;/a&gt; 을 지정하여 오버 헤드를 줄일 수 있지만, 이는 지원되는 추가 matchinfo () 옵션 중 일부를 희생하는 대신 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9b96b15368e6c99132d7d8a67a04e723712af54" translate="yes" xml:space="preserve">
          <source>Because lookaside allocations are always the same size, the allocation and deallocation algorithms are very quick. There is no need to coalesce adjacent free slots or search for a slot of a particular size. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; maintains a singly-linked list of unused slots. Allocation requests simply pull the first element of this list. Deallocations simply push the element back onto the front of the list. Furthermore, each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is assumed to already be running in a single thread (there are mutexes already in place to enforce this) so no additional mutexing is required to serialize access to the lookaside slot freelist. Consequently, lookaside memory allocations and deallocations are very fast. In speed tests on Linux and Mac OS X workstations, SQLite has shown overall performance improvements as high as 10% and 15%, depending on the workload how and lookaside is configured.</source>
          <target state="translated">lookaside 할당은 항상 같은 크기이므로 할당 및 할당 해제 알고리즘이 매우 빠릅니다. 인접한 빈 슬롯을 통합하거나 특정 크기의 슬롯을 검색 할 필요가 없습니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 단일 링크로 사용되지 않는 슬롯 목록을 유지 관리합니다. 할당 요청은 단순히이 목록의 첫 번째 요소를 가져옵니다. 할당 해제는 단순히 요소를 목록의 맨 앞으로 다시 밀어 넣습니다. 또한 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt;는 이미 단일 스레드에서 실행중인 것으로 가정하고 (이를 강제하기 위해 이미 뮤텍스가 있음) lookaside 슬롯 사용 가능 목록에 대한 액세스를 직렬화하는 데 추가 뮤텍스가 필요하지 않습니다. 따라서 lookaside 메모리 할당 및 할당 해제가 매우 빠릅니다. Linux 및 Mac OS X 워크 스테이션의 속도 테스트에서 SQLite는 워크로드 및 구성 방법에 따라 전체 성능이 10 % 및 15 % 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="668e105a1044bfeea3b1760bf6f04ba2a54183c0" translate="yes" xml:space="preserve">
          <source>Because main-memory is a limited resource, the</source>
          <target state="translated">메인 메모리는 제한된 리소스이므로</target>
        </trans-unit>
        <trans-unit id="fdc0f2ea6af2e7d5aa2876f1718288d4bc691129" translate="yes" xml:space="preserve">
          <source>Because of continuing security concerns, the two-argument version of of the seldom-used and little-known &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function is disabled unless SQLite is compiled with the &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;.</source>
          <target state="translated">지속적인 보안 문제로 인해 SQLite가 &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt; 로 컴파일되지 않으면 거의 사용되지 않고 거의 알려지지 않은 &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 함수 의 2 인수 버전 이 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f16662c44c98100b991163c6c6a9a2f0174c0613" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07) until it was superseded by better fuzzers in &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10).</source>
          <target state="translated">과거의 성공으로 인해 AFL은 &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;버전 3.29.0&lt;/a&gt; (2019-07-10) 에서 더 나은 퍼저 로 대체 될 때까지 &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;버전 3.8.10&lt;/a&gt; (2015-05-07) 부터 SQLite 테스트 전략의 표준 부분이되었습니다 .</target>
        </trans-unit>
        <trans-unit id="70e6d86d9770a8829aec592e59f4248ba67ce358" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07). Both SQL statements and database files are fuzzed. Billions and billions of mutations have been tried, but AFL's instrumentation has narrowed them down to less than 50,000 test cases that cover all distinct behaviors. Newly discovered test cases are periodically captured and added to the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; where they can be rerun using the &quot;make fuzztest&quot; or &quot;make valgrindfuzz&quot; commands.</source>
          <target state="translated">과거의 성공으로 인해 AFL은 &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;버전 3.8.10&lt;/a&gt; (2015-05-07) 부터 SQLite 테스트 전략의 표준이되었습니다 . SQL 문과 데이터베이스 파일 모두 퍼지됩니다. 수십억 개의 돌연변이가 시도되었지만 AFL의 계측은 그것들을 모든 별개의 행동을 다루는 50,000 개 미만의 테스트 사례로 좁혔습니다. 새로 발견 된 테스트 케이스는 주기적으로 캡처되어 &quot;make fuzztest&quot;또는 &quot;make valgrindfuzz&quot;명령을 사용하여 다시 실행할 수있는 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트에&lt;/a&gt; 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="35a2bab974445beaebfdcb0d2e216e6aab6976e2" translate="yes" xml:space="preserve">
          <source>Because of security concerns, the two-argument fts3_tokenizer() feature was disabled beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;Version 3.11.0&lt;/a&gt; (2016-02-15) unless this compile-time option is used. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Version 3.12.0&lt;/a&gt; (2016-03-29) added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0) interface that activates the two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; for a specific &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at run-time.</source>
          <target state="translated">보안 문제로 &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;인해이&lt;/a&gt; 컴파일 타임 옵션을 사용하지 않으면 두 인수 fts3_tokenizer () 기능이 버전 3.11.0 (2016-02-15) 부터 비활성화되었습니다 . &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; (2016-03-29)은 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0) 인터페이스를 추가하여 런타임시 특정 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 위해 두 인수 버전의 &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="90667c0d2f4c3f9e700d1a02bf683d36a408bbd8" translate="yes" xml:space="preserve">
          <source>Because of the behaviors described above, programmers are encouraged to prefer AFTER triggers over BEFORE triggers.</source>
          <target state="translated">위에서 설명한 동작으로 인해 프로그래머는 BEFORE 트리거보다 AFTER 트리거를 선호하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="428b411cc0640abd27f1cf3a950377d2c4b5358f" translate="yes" xml:space="preserve">
          <source>Because of the potential disadvantages, memory-mapped I/O is disabled by default. To activate memory-mapped I/O, use the &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma&lt;/a&gt; and set the mmap_size to some large number, usually 256MB or larger, depending on how much address space your application can spare. The rest is automatic. The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will be a silent no-op on systems that do not support memory-mapped I/O.</source>
          <target state="translated">잠재적 인 단점으로 인해 메모리 매핑 I / O는 기본적으로 비활성화되어 있습니다. 메모리 매핑 된 I / O를 활성화하려면 &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma를&lt;/a&gt; 사용하고 응용 프로그램이 할당 할 수있는 주소 공간의 양에 따라 mmap_size를 보통 256MB 이상으로 설정하십시오. 나머지는 자동입니다. &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA의 mmap_size의&lt;/a&gt; 문이 지원하지 않는 시스템에서 자동 무 조작 될 것입니다 I / O를 메모리 매핑.</target>
        </trans-unit>
        <trans-unit id="3b4a67ca1996129326c7f0bddce34637e22bf4f7" translate="yes" xml:space="preserve">
          <source>Because of these advantages, SQLite always tries to do a partial sort using an index even if a complete sort by index is not possible.</source>
          <target state="translated">이러한 장점 때문에 SQLite는 인덱스별로 완전한 정렬이 불가능하더라도 항상 인덱스를 사용하여 부분 정렬을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0aff0a8b5eb6e0fbec96bd0626840af7bfdbee19" translate="yes" xml:space="preserve">
          <source>Because resetting a database is destructive and irreversible, the process requires the use of this obscure API and multiple steps to help ensure that it does not happen by accident.</source>
          <target state="translated">데이터베이스를 재설정하는 것은 파괴적이고 되돌릴 수 없기 때문에이 프로세스는이 모호한 API와 여러 단계를 사용하여 우발적으로 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b538eb844bddf9ea8a5b9a11872b1b61bfa979d" translate="yes" xml:space="preserve">
          <source>Because sorting can be expensive, SQLite works hard to convert ORDER BY clauses into no-ops. If SQLite determines that output will naturally appear in the order specified, then no sorting is done. So, for example, if you request the output in rowid order, no sorting will be done:</source>
          <target state="translated">정렬은 비용이 많이들 수 있으므로 SQLite는 ORDER BY 절을 no-ops로 변환하기 위해 열심히 노력합니다. SQLite가 출력이 지정된 순서대로 자연스럽게 나타날 것으로 판단하면 정렬이 수행되지 않습니다. 예를 들어, rowid 순서로 출력을 요청하면 정렬이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9e05ab9d98b3cd637f9791d810eeb3b04a00c42" translate="yes" xml:space="preserve">
          <source>Because the SQLite developers do not know whether the SQLITE_ENABLE_SORTER_REFERENCES option will help or hurt performance, it is disabled by default at this time (2018-05-04). It might be enabled by default in some future release, depending on what is learned about its impact on performance.</source>
          <target state="translated">SQLite 개발자는 SQLITE_ENABLE_SORTER_REFERENCES 옵션이 성능에 도움이 될지 여부를 알 수 없으므로 현재 기본적으로 비활성화되어 있습니다 (2018-05-04). 성능에 미치는 영향에 대해 학습 한 내용에 따라 향후 릴리스에서 기본적으로 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ba7f227189763df8625f3bee22f683d880802a" translate="yes" xml:space="preserve">
          <source>Because the completion table is built into the command-line shell in order to provide for tab-completions, you can run test queries against the completion table directly in the command-line shell. Simply type a query such as the example shown above, filling in appropriate values for $prefix and $wholeline, and observe the output.</source>
          <target state="translated">완료 테이블이 탭 완성을 제공하기 위해 명령 행 쉘에 내장되어 있으므로 명령 행 쉘에서 완료 테이블에 대해 테스트 쿼리를 직접 실행할 수 있습니다. $ prefix 및 $ wholeline에 적절한 값을 입력하여 위의 예와 같은 쿼리를 입력하고 출력을 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="a8514da27bd50380cff29e01b5a61eb7772e130b" translate="yes" xml:space="preserve">
          <source>Because the content of leaf freelist pages is unimportant, SQLite avoids storing leaf freelist page content in the rollback journal in &lt;a href=&quot;#section_3_5&quot;&gt;step 3.5&lt;/a&gt; of the commit process. If a leaf freelist page is changed and that change does not get rolled back during a transaction recovery, the database is not harmed by the omission. Similarly, the content of a new freelist page is never written back into the database at &lt;a href=&quot;#section_3_9&quot;&gt;step 3.9&lt;/a&gt; nor read from the database at &lt;a href=&quot;#section_3_3&quot;&gt;step 3.3&lt;/a&gt;. These optimizations can greatly reduce the amount of I/O that occurs when making changes to a database file that contains free space.</source>
          <target state="translated">리프 프리리스트 페이지의 컨텐츠는 중요하지 않으므로 SQLite는 커밋 프로세스의 &lt;a href=&quot;#section_3_5&quot;&gt;3.5 단계&lt;/a&gt; 에서 롤백 저널에 리프 프리리스트 페이지 컨텐츠를 저장하지 않습니다 . 리프 프리리스트 페이지가 변경되고 트랜잭션 복구 중에 해당 변경 사항이 롤백되지 않으면 데이터베이스가 누락되어 피해를받지 않습니다. 마찬가지로, 새로운 프리리스트 페이지의 내용은 &lt;a href=&quot;#section_3_9&quot;&gt;3.9 단계&lt;/a&gt; 에서 데이터베이스에 다시 쓰거나 &lt;a href=&quot;#section_3_3&quot;&gt;3.3 단계&lt;/a&gt; 에서 데이터베이스에서 읽지 않습니다 . 이러한 최적화는 여유 공간이있는 데이터베이스 파일을 변경할 때 발생하는 I / O의 양을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09f5109878254b678ca47d639d75e4bf226a1da" translate="yes" xml:space="preserve">
          <source>Because the indexed documents themselves are usually much larger than the full-text index, the content option can be used to achieve significant space savings.</source>
          <target state="translated">인덱싱 된 문서 자체는 일반적으로 전체 텍스트 인덱스보다 훨씬 크기 때문에 내용 옵션을 사용하여 공간을 크게 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761cb8246ba69558ca8aeb80b8dbab8c62f5efed" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. But SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="translated">인덱스의 가장 왼쪽 열이 쿼리의 WHERE 절에 나타나지 않기 때문에 여기서는 인덱스를 사용할 수 없다고 결론을 내릴 수 있습니다. 그러나 SQLite는 인덱스를 사용할 수 있습니다. 개념적으로 SQLite는 쿼리가 다음과 같은 것처럼 인덱스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d3bc49abdbbec51c89e15d286d4a875e6d32447c" translate="yes" xml:space="preserve">
          <source>Because the name of the schema table does not appear anywhere in the file format, the meaning of the database file is not changed if the application chooses to refer to the schema table by one of these alternative names.</source>
          <target state="translated">스키마 테이블의 이름은 파일 형식의 어디에도 나타나지 않기 때문에 애플리케이션이 이러한 대체 이름 중 하나로 스키마 테이블을 참조하도록 선택하면 데이터베이스 파일의 의미가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a128485eb3a76806acc833997f2bb0ca8f3bab85" translate="yes" xml:space="preserve">
          <source>Because the non-primary key &quot;old.*&quot; fields are omitted, no SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset is passed to the sqlite3changeset_apply() API. Other conflict types work in the same way as for changesets.</source>
          <target state="translated">기본이 아닌 키 &quot;old. *&quot;필드는 생략되므로 패치 세트가 sqlite3changeset_apply () API에 전달되면 SQLITE_CHANGESET_DATA 충돌을 감지하거나보고 할 수 없습니다. 다른 충돌 유형은 변경 세트와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2e558ba54b31e234aa1a29ff45d5a07a13c1806f" translate="yes" xml:space="preserve">
          <source>Because the pointer is passed in the t1 column of the t1 table as a BLOB (in older versions of SQLite), such a query would have shown the value of the pointer in hex. The attacker could then modify that pointer to try to get the snippet() function to modify memory in some other part of the application address space instead of the fts3cursor object it was supposed to be operating on:</source>
          <target state="translated">포인터는 t1 테이블의 t1 열에 BLOB (이전 버전의 SQLite)으로 전달되므로 이러한 쿼리는 포인터 값을 16 진수로 표시했을 것입니다. 그런 다음 공격자는 해당 포인터를 수정하여 snippet () 함수가 응용 프로그램 주소 공간의 다른 부분에서 fts3cursor 객체 대신 메모리를 수정하도록 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ea5223eef09f4a78746e1785e07a1242a94565" translate="yes" xml:space="preserve">
          <source>Because the same query could be written without the use of row values, row values do not provide new capabilities. However, many developers say that the row value format is easier to read, write, and debug.</source>
          <target state="translated">행 값을 사용하지 않고 동일한 쿼리를 작성할 수 있으므로 행 값은 새로운 기능을 제공하지 않습니다. 그러나 많은 개발자들은 행 값 형식이 읽기, 쓰기 및 디버그가 더 쉽다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="fc8629347e97d2900d75943390265d789337dab5" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">세션 모듈이 &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; API를 사용하기 때문에 애플리케이션이 하나 이상의 세션 오브젝트가 첨부 된 데이터베이스 핸들에 사전 업데이트 후크를 등록 할 수 없습니다. 사전 갱신 후크가 이미 정의 된 데이터베이스 핸들에 첨부 된 세션 오브젝트를 작성할 수도 없습니다. 이 중 하나를 시도한 결과는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2d755c27985069d9c58f3f925b7f20c86ab3fc1d" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">세션 모듈이 &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; API를 사용하기 때문에 애플리케이션이 하나 이상의 세션 오브젝트가 첨부 된 데이터베이스 핸들에 사전 업데이트 후크를 등록 할 수 없습니다. 사전 갱신 후크가 이미 정의 된 데이터베이스 핸들에 첨부 된 세션 오브젝트를 작성할 수도 없습니다. 이 중 하나를 시도한 결과는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="adc547a5fb4644ceebfd077fa4efa0549df654d8" translate="yes" xml:space="preserve">
          <source>Because the shm file is not involved in recovery, the shm file does not need to be machine byte-order independent. Hence, numeric values in the shm file are written in the native byte order of the host computer, rather than being converted into a specific cross-platform byte order as is done with the main database file and the wal file.</source>
          <target state="translated">shm 파일은 복구에 관여하지 않기 때문에 shm 파일은 기계 바이트 순서와 무관 할 필요가 없습니다. 따라서 shm 파일의 숫자 값은 기본 데이터베이스 파일 및 wal 파일에서와 같이 특정 크로스 플랫폼 바이트 순서로 변환되지 않고 호스트 컴퓨터의 기본 바이트 순서로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="57d0b82e26ee2d676d928a1d7402d5916fc2656a" translate="yes" xml:space="preserve">
          <source>Because the shm is only used to coordinate access between concurrent clients, the shm file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, as an optimization. When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, SQLite uses heap memory in place of the memory-mapped shm file.</source>
          <target state="translated">shm은 동시 클라이언트 간의 액세스를 조정하는 데만 사용되므로 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;배타적 잠금 모드&lt;/a&gt; 가 최적화로 설정된 경우 shm 파일이 생략됩니다 . 때 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드가&lt;/a&gt; 설정되어, SQLite는 메모리 매핑 SHM 파일 대신에 힙 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2da09f02d441cbe1ccd49c9803ec08e4160143a9" translate="yes" xml:space="preserve">
          <source>Because there is no cross-platform way to specify 64-bit integer types SQLite includes typedefs for 64-bit signed and unsigned integers.</source>
          <target state="translated">64 비트 정수 유형을 지정하는 크로스 플랫폼 방법이 없기 때문에 SQLite에는 64 비트 부호있는 정수 및 부호없는 정수에 대한 typedef가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8871399a86a3489a9f90b012e36a01ad56791fa8" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">SQLite는 데이터베이스에 쓰기 전에 먼저 데이터베이스를 읽어서 이미 무엇이 있는지 확인해야합니다. 새 데이터 만 추가하는 경우에도 SQLite는 &quot; &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; &quot;테이블 에서 데이터베이스 스키마를 읽어야 하므로 INSERT 문을 구문 분석하고 데이터베이스 파일에서 새 정보를 저장해야하는 위치를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d5873520ec115c715db00ab0ac94f393f103400" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &lt;b&gt;sqlite_master&lt;/b&gt; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">SQLite가 데이터베이스에 쓰려면 먼저 데이터베이스를 읽고 이미 존재하는 것을 확인해야합니다. 새 데이터를 추가하는 경우에도 SQLite는 &lt;b&gt;sqlite_master&lt;/b&gt; 테이블 에서 데이터베이스 스키마를 읽어야 INSERT 문을 구문 분석하고 데이터베이스 파일에서 새 정보를 저장할 위치를 &lt;b&gt;찾는&lt;/b&gt; 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccacc0177cbd2ba716b19132f920379d439772e2" translate="yes" xml:space="preserve">
          <source>Before a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement can be run, the module specified in that statement must be registered with the database connection. This is accomplished using either of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces:</source>
          <target state="translated">&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문을 실행 하기 전에 해당 명령문에 지정된 모듈을 데이터베이스 연결에 등록해야합니다. 이는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 인터페이스 중 하나를 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="c589001febca68c36ef8079ff9faca5b3d4efc6b" translate="yes" xml:space="preserve">
          <source>Before a new auxiliary function or tokenizer implementation may be registered with FTS5, an application must obtain a pointer to the &quot;fts5_api&quot; structure. There is one fts5_api structure for each database connection with which the FTS5 extension is registered. To obtain the pointer, the application invokes the SQL user-defined function fts5() with a single argument. That argument must be set to a pointer to a pointer to an fts5_api object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. The following example code demonstrates the technique:</source>
          <target state="translated">새로운 보조 기능 또는 토크 나이저 구현이 FTS5에 등록되기 전에 응용 프로그램은 &quot;fts5_api&quot;구조에 대한 포인터를 가져와야합니다. FTS5 확장이 등록 된 각 데이터베이스 연결마다 하나의 fts5_api 구조가 있습니다. 포인터를 얻기 위해 응용 프로그램은 단일 인수로 SQL 사용자 정의 함수 fts5 ()를 호출합니다. 이 인수는 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 인터페이스를 사용하여 fts5_api 객체에 대한 포인터를 가리키는 포인터로 설정해야합니다 . 다음 예제 코드는 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6ae8b38a31b33865e805e86015a35fae53d45a85" translate="yes" xml:space="preserve">
          <source>Before any database pages may be modified within the</source>
          <target state="translated">데이터베이스 페이지 내에서 데이터베이스 페이지를 수정하기 전에</target>
        </trans-unit>
        <trans-unit id="2aafeb2e2bb5cf3269cb7e705f038008b263f110" translate="yes" xml:space="preserve">
          <source>Before any information-bearing page of the database is modified, the original unmodified content of that page is written into the rollback journal. If a transaction is interrupted and needs to be rolled back, the rollback journal can then be used to restore the database to its original state. Freelist leaf pages bear no information that would need to be restored on a rollback and so they are not written to the journal prior to modification, in order to reduce disk I/O.</source>
          <target state="translated">데이터베이스의 정보가 포함 된 페이지를 수정하기 전에 해당 페이지의 수정되지 않은 원본 내용이 롤백 저널에 기록됩니다. 트랜잭션이 중단되어 롤백해야하는 경우 롤백 저널을 사용하여 데이터베이스를 원래 상태로 복원 할 수 있습니다. 프리리스트 리프 페이지에는 롤백시 복원해야 할 정보가 없으므로 디스크 I / O를 줄이기 위해 수정 전에 저널에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e31e39238fffa8a7d3425c769271d3112873aa6f" translate="yes" xml:space="preserve">
          <source>Before calling this method, the SQLite core initializes an instance of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure with information about the query that it is currently trying to process. This information derives mainly from the WHERE clause and ORDER BY or GROUP BY clauses of the query, but also from any ON or USING clauses if the query is a join. The information that the SQLite core provides to the xBestIndex method is held in the part of the structure that is marked as &quot;Inputs&quot;. The &quot;Outputs&quot; section is initialized to zero.</source>
          <target state="translated">이 메소드를 호출하기 전에 SQLite 코어 는 현재 처리하려는 쿼리에 대한 정보로 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 인스턴스를 초기화합니다 . 이 정보는 주로 쿼리의 WHERE 절과 ORDER BY 또는 GROUP BY 절에서 파생되며 쿼리가 조인 인 경우 ON 또는 USING 절에서도 파생됩니다. SQLite 코어가 xBestIndex 메소드에 제공하는 정보는 &quot;입력&quot;으로 표시된 구조 부분에 보유됩니다. &quot;출력&quot;섹션이 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="29b6c291315b8e1fb3f265c15e369937b630aaf5" translate="yes" xml:space="preserve">
          <source>Before data may be read from a</source>
          <target state="translated">데이터를 읽기 전에</target>
        </trans-unit>
        <trans-unit id="cae7b06f8fadf1f8b2bbb51c0629366481aebe32" translate="yes" xml:space="preserve">
          <source>Before entering a trigger program the value returned by sqlite3_changes() function is saved. After the trigger program has finished, the original value is restored.</source>
          <target state="translated">트리거 프로그램을 시작하기 전에 sqlite3_changes () 함수가 반환 한 값이 저장됩니다. 트리거 프로그램이 완료되면 원래 값이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="7968bdea3fbca698f15e058c3369cb48f81fd4ca" translate="yes" xml:space="preserve">
          <source>Before executing a statement that modifies the database schema (i.e. a CREATE or DROP TABLE statement), a connection must obtain a write-lock on</source>
          <target state="translated">데이터베이스 스키마를 수정하는 명령문 (예 : CREATE 또는 DROP TABLE 문)을 실행하기 전에 연결에서 쓰기 잠금을 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="64443a5dc257f480bf4a79d829dcae9017cc971a" translate="yes" xml:space="preserve">
          <source>Before making changes to any page of the database, the process writes the original content of that page into the rollback journal. Changes to pages are held in memory at first and are not written to the disk. The original database file remains unaltered, which means that other processes can continue to read the database.</source>
          <target state="translated">데이터베이스의 페이지를 변경하기 전에 프로세스는 해당 페이지의 원래 컨텐츠를 롤백 저널에 기록합니다. 페이지 변경 사항은 처음에 메모리에 유지되며 디스크에 기록되지 않습니다. 원래 데이터베이스 파일은 변경되지 않은 상태로 유지되므로 다른 프로세스가 데이터베이스를 계속 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed294139e05d80e58de31e418d68f4cfaebeb6a7" translate="yes" xml:space="preserve">
          <source>Before making changes to the database, SQLite first obtains a &quot;reserved&quot; lock on the database file. A reserved lock is similar to a shared lock in that both a reserved lock and shared lock allow other processes to read from the database file. A single reserve lock can coexist with multiple shared locks from other processes. However, there can only be a single reserved lock on the database file. Hence only a single process can be attempting to write to the database at one time.</source>
          <target state="translated">데이터베이스를 변경하기 전에 SQLite는 먼저 데이터베이스 파일에 대한 &quot;예약 된&quot;잠금을 얻습니다. 예약 잠금은 예약 잠금과 공유 잠금이 다른 프로세스가 데이터베이스 파일에서 읽을 수 있다는 점에서 공유 잠금과 유사합니다. 단일 예약 잠금은 다른 프로세스의 여러 공유 잠금과 공존 할 수 있습니다. 그러나 데이터베이스 파일에는 단일 예약 잠금 만있을 수 있습니다. 따라서 한 번에 하나의 프로세스 만 데이터베이스에 쓰려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b64dbebb4ad46a9aeb1a098c15aadd4e3eaf44" translate="yes" xml:space="preserve">
          <source>Before modifying a database page within the</source>
          <target state="translated">데이터베이스 페이지에서 데이터베이스 페이지를 수정하기 전에</target>
        </trans-unit>
        <trans-unit id="98e0ccf77dc018ac7ea18b90477a40f1a7c510fa" translate="yes" xml:space="preserve">
          <source>Before opening a</source>
          <target state="translated">열기 전에</target>
        </trans-unit>
        <trans-unit id="6822a9cef8f0664c32cddfaac23e4bff41485b02" translate="yes" xml:space="preserve">
          <source>Before reading from a database file, SQLite always checks to see if that database file has a hot journal. If the file does have a hot journal, then the journal is rolled back before the file is read. In this way, we ensure that the database file is in a consistent state before it is read.</source>
          <target state="translated">데이터베이스 파일에서 읽기 전에 SQLite는 항상 해당 데이터베이스 파일에 핫 저널이 있는지 확인합니다. 파일에 핫 저널이있는 경우 파일을 읽기 전에 저널이 롤백됩니다. 이러한 방식으로, 데이터베이스 파일을 읽기 전에 일관성있는 상태에 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2ffabc9625263621654187c58d31675c59e6730d" translate="yes" xml:space="preserve">
          <source>Before the content of a page modified within the</source>
          <target state="translated">페이지 내용이 페이지 내부에서 수정되기 전에</target>
        </trans-unit>
        <trans-unit id="2a76187aef00ad8a5abadfac889a6b98dd1db2fb" translate="yes" xml:space="preserve">
          <source>Before the contents of the</source>
          <target state="translated">내용 전에</target>
        </trans-unit>
        <trans-unit id="5f97138118a317cbc3bf1e3e8dd4c6fd1edd23a0" translate="yes" xml:space="preserve">
          <source>Before we begin looking at this problem, let's briefly review how queries work in SQLite so that we will know what we are trying to accomplish. For each row in the result of a query, SQLite will invoke a callback function with the following prototype:</source>
          <target state="translated">이 문제를 살펴보기 전에 SQLite에서 쿼리가 작동하는 방식을 간단히 검토하여 수행하려는 작업을 알도록하겠습니다. 쿼리 결과의 각 행에 대해 SQLite는 다음 프로토 타입을 사용하여 콜백 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5c00a0d3ea5cf97be2cbc8e0c749bfff4206bbf5" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started.</source>
          <target state="translated">트랜잭션이 아직 활성화되지 않은 경우 데이터베이스 P1에서 트랜잭션을 시작하십시오. P2가 0이 아닌 경우 쓰기 트랜잭션이 시작되거나 읽기 트랜잭션이 이미 활성화 된 경우 쓰기 트랜잭션으로 업그레이드됩니다. P2가 0이면 읽기 트랜잭션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd194a93ac6ccfaf40c7f7cd5a992cb067293a7" translate="yes" xml:space="preserve">
          <source>Begin adding lots of new documentation</source>
          <target state="translated">많은 새로운 문서 추가 시작</target>
        </trans-unit>
        <trans-unit id="90c994ef269c7ca4806cc0aace7ca7e97ba28671" translate="yes" xml:space="preserve">
          <source>Begin by obtaining a copy of SQLite in whatever form you use it. The public SQLite you obtain should be as close to your private edited copy as possible. If your project uses the SQLite amalgamation, then get a copy of the amalgamation. If you use the preprocessed separate source files, get those instead. Put all the source files in the checkout directory created in the previous step.</source>
          <target state="translated">어떤 형태로든 SQLite 사본을 구하십시오. 당신이 얻는 공개 SQLite는 가능한 한 개인 편집 사본에 가깝습니다. 프로젝트에서 SQLite 합병을 사용하는 경우 합병의 사본을 받으십시오. 사전 처리 된 별도의 소스 파일을 사용하는 경우 해당 파일을 대신 가져 오십시오. 모든 소스 파일을 이전 단계에서 작성된 체크 아웃 디렉토리에 두십시오.</target>
        </trans-unit>
        <trans-unit id="c95a84f6810e9547323b7d36381036499b6e85a2" translate="yes" xml:space="preserve">
          <source>Begin enforcing &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;. This can be used, for example, to prevent excessively large prepared statements in systems that accept SQL queries from untrusted users.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt; 시행을 시작하십시오 . 예를 들어, 신뢰할 수없는 사용자의 SQL 쿼리를 허용하는 시스템에서 너무 큰 준비된 명령문을 방지하기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5e2f03338f65ea55efadd743c2073f0844124d" translate="yes" xml:space="preserve">
          <source>Begin every identifier with the letter &quot;Z&quot; as no SQL keywords start with &quot;Z&quot;.</source>
          <target state="translated">SQL 키워드가 &quot;Z&quot;로 시작하지 않으므로 문자 &quot;Z&quot;로 모든 식별자를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c9b7ac07f4b963268a3915518a82c60026c1c8" translate="yes" xml:space="preserve">
          <source>Begin writing documentation on the TCL interface.</source>
          <target state="translated">TCL 인터페이스에서 문서 작성을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d93624195948cab4e3c3cf8a06c4ba66150434ee" translate="yes" xml:space="preserve">
          <source>Begin writing the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vdbe&quot;&gt;VDBE 튜토리얼&lt;/a&gt; 작성을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="2891bac57361d1d80487ccfbba99ba09325df3b5" translate="yes" xml:space="preserve">
          <source>Beginning a Write Transaction</source>
          <target state="translated">쓰기 트랜잭션 시작</target>
        </trans-unit>
        <trans-unit id="60eca843fdd7093ad8665839ef32416ade71c639" translate="yes" xml:space="preserve">
          <source>Beginning in 2016, a team of engineers at Google started the &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure. The Fuzzer automatically downloads the latest check-ins for participating projects, fuzzes them, and sends email to the developers reporting any problems. When a fix is checked in, the fuzzer automatically detects this and emails a confirmation to the developers.</source>
          <target state="translated">2016 년부터 Google 엔지니어 팀이 &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; 프로젝트를 시작했습니다 . OSS Fuzz는 Google 인프라에서 실행되는 AFL 스타일 안내 식 퍼저를 사용합니다. Fuzzer는 참여 프로젝트에 대한 최신 체크인을 자동으로 다운로드하여 퍼징 한 다음 문제를보고 한 개발자에게 이메일을 보냅니다. 수정 프로그램이 체크인되면 퍼 저가이를 자동으로 감지하여 개발자에게 확인 이메일을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="52ddec92a44c4044495e3a4272f88fb5bf0d2787" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14), an assignment in the SET clause can be a &lt;a href=&quot;syntax/column-name-list&quot;&gt;parenthesized list of column names&lt;/a&gt; on the left and a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the same size on the right.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;버전 3.15.0&lt;/a&gt; (2016-10-14) 부터 SET 절의 할당 은 왼쪽에 &lt;a href=&quot;syntax/column-name-list&quot;&gt;괄호로 묶인 열 이름 목록&lt;/a&gt; 과 오른쪽에 동일한 크기 의 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e0744464084ddf340ea6c6e0a24aad6d9c12c18" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;version 3.6.4&lt;/a&gt; (2008-10-15), the TRUNCATE journal mode is also supported:</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;버전 3.6.4&lt;/a&gt; (2008-10-15)부터 TRUNCATE 저널 모드도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6adac7327da12129344605aed8c6230ec2a45b5c" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07), WAL databases can be created, read, and written even if shared memory is unavailable as long as the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE before the first attempted access. In other words, a process can interact with a WAL database without using shared memory if that process is guaranteed to be the only process accessing the database. This feature allows WAL databases to be created, read, and written by legacy &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; that lack the &quot;version 2&quot; shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;버전 3.7.4&lt;/a&gt; (2010-12-07) 부터는 첫 번째 액세스 시도 전에 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; 가 EXCLUSIVE로 설정 되어있는 한 공유 메모리를 사용할 수없는 경우에도 WAL 데이터베이스를 작성하고 읽고 쓸 수 있습니다. 즉, 프로세스가 데이터베이스에 액세스하는 유일한 프로세스 인 경우 프로세스는 공유 메모리를 사용하지 않고 WAL 데이터베이스와 상호 작용할 수 있습니다. 이 기능을 사용 하면 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 에서 &quot;버전 2&quot;공유 메모리 메소드 xShmMap, xShmLock, xShmBarrier 및 xShmUnmap이없는 레거시 &lt;a href=&quot;vfs&quot;&gt;VFS에서&lt;/a&gt; WAL 데이터베이스를 작성하고 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f100a899b26537fc63caa4230653ce9716130e4" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite version 3.5.0, the new Virtual File System (VFS) interface contains a method named xDeviceCharacteristics which reports on special properties that the underlying mass storage device might have. Among the special properties that xDeviceCharacteristics might report is the ability of to do an atomic sector write.</source>
          <target state="translated">SQLite 버전 3.5.0부터 새로운 가상 파일 시스템 (VFS) 인터페이스에는 기본 대용량 저장 장치가 가질 수있는 특수 속성을보고하는 xDeviceCharacteristics라는 메서드가 포함되어 있습니다. xDeviceCharacteristics가보고 할 수있는 특수한 속성 중에는 원자 섹터 쓰기 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe6df39f8d021809fb2ab3e47422b19fa74d670" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="translated">2018 년 후반부터 SQLite는 &quot;dbsqlfuzz&quot;라는 새로운 독점적 퍼저를 사용하여 퍼징되었습니다. Dbsqlfuzz는 LLVM 의 &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; 프레임 워크를 사용하여 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4f6d3a3a096224887296bd514258ca7ceae764c" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite supports a new transaction control mechanism called &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;. When a database is in WAL mode, all connections to that database must use the WAL. A particular database will use either a rollback journal or a WAL, but not both at the same time. The WAL is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; appended.</source>
          <target state="translated">를 시작으로 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21), SQLite는이 &quot;라는 새로운 트랜잭션 제어 메커니즘 지원 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; &quot; &quot;또는 &lt;a href=&quot;wal&quot;&gt;WAL을&lt;/a&gt; &quot;. 데이터베이스가 WAL 모드 인 경우 해당 데이터베이스에 대한 모든 연결은 WAL을 사용해야합니다. 특정 데이터베이스는 롤백 저널 또는 WAL을 사용하지만 동시에 둘 다 사용하지는 않습니다. WAL은 항상 데이터베이스 파일과 동일한 디렉토리에 있으며 데이터베이스 파일과 이름은 동일하지만 문자열 &quot; &lt;code&gt;-wal&lt;/code&gt; &quot;이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d9839d2cef57fa5d151a0ce9cbe15a6e0c36fbc7" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), SQLite has the option of accessing disk content directly using memory-mapped I/O and the new xFetch() and xUnfetch() methods on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">로 시작하는 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013년 5월 20일), SQLite는 직접 디스크 콘텐츠에 액세스 메모리 매핑 I / O 및 새로운 xFetch ()와 xUnfetch () 메소드를 사용하는 옵션이있다 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26a395622db69c8b77803fcd06e3a2c5d4cdefa3" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23), the SQLite database file argument to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces and to the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command can be specified either as an ordinary filename or as a Uniform Resource Identifier or URI. The advantage of using a URI filename is that query parameters on the URI can be used to control details of the newly created database connection. For example, an alternative &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be specified using a &quot;vfs=&quot; query parameter. Or the database can be opened read-only by using &quot;mode=ro&quot; as a query parameter.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;버전 3.7.7&lt;/a&gt; (2011-06-23) 부터 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스 및 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령에 대한 SQLite 데이터베이스 파일 인수 는 일반 파일 이름 또는 a로 지정할 수 있습니다. URI (Uniform Resource Identifier). URI 파일 이름을 사용하면 URI에서 쿼리 매개 변수를 사용하여 새로 만든 데이터베이스 연결의 세부 정보를 제어 할 수 있다는 이점이 있습니다. 예를 들어 &quot;vfs =&quot;쿼리 매개 변수를 사용하여 대체 &lt;a href=&quot;vfs&quot;&gt;VFS를&lt;/a&gt; 지정할 수 있습니다. 또는 &quot;mode = ro&quot;를 쿼리 매개 변수로 사용하여 데이터베이스를 읽기 전용으로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b26610830584adfe4c3b1f430311725c505dc65" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14) SQLite uses &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt;. Prior to that time, SQLite employed a version identifier that contained between two and four numbers.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 부터 SQLite는 &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전 관리를&lt;/a&gt; 사용합니다 . 그 전에 SQLite는 2-4 개의 숫자로 구성된 버전 식별자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="e8a7a785dc79c6f97e7e9b629f10c98e7d6eaa12" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite 3.23.0 (2018-04-02), SQLite recognizes the identifiers &quot;TRUE&quot; and &quot;FALSE&quot; as boolean literals, if and only if those identifiers are not already used for some other meaning. If there already exists columns or tables or other objects named TRUE or FALSE, then for the sake of backwards compatibility, the TRUE and FALSE identifiers refer to those other objects, not to the boolean values.</source>
          <target state="translated">SQLite 3.23.0 (2018-04-02)부터 SQLite는 식별자 &quot;TRUE&quot;및 &quot;FALSE&quot;를 부울 리터럴로 인식합니다 (만약 식별자가 다른 의미로 사용되지 않은 경우에만). TRUE 또는 FALSE라는 열 또는 테이블 또는 다른 개체가 이미있는 경우 이전 버전과의 호환성을 위해 TRUE 및 FALSE 식별자는 부울 값이 아닌 다른 개체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e27a2a72ed98b30f89096b193da3e3a912285cdd" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06), the unix OS interface will attempt to resolve symbolic links and open the database file by its canonical name. Prior to version 3.10.0, opening a database file through a symbolic link was similar to opening a database file that had multiple hard links and resulted in undefined behavior.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;버전 3.10.0&lt;/a&gt; (2016-01-06) 부터 Uniix OS 인터페이스는 심볼릭 링크를 확인하고 표준 이름으로 데이터베이스 파일을 열려고 시도합니다. 버전 3.10.0 이전에는 기호 링크를 통해 데이터베이스 파일을 여는 것이 여러 개의 하드 링크가있는 데이터베이스 파일을 여는 것과 유사하며 정의되지 않은 동작이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="669009bffd329a7525e12f992041efbc93a9e4fc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;version 3.14.0&lt;/a&gt; (2016-08-08), the CREATE TABLE statement that is passed into &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; may contain a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; clause. This is useful for cases where the virtual table rows cannot easily be mapped into unique integers. A CREATE TABLE statement that includes WITHOUT ROWID must define one or more columns as the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL and all columns for each row must be collectively unique.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;버전 3.14.0&lt;/a&gt; (2016-08-08) 부터 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()에&lt;/a&gt; 전달 된 CREATE TABLE 문 에 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 절이 포함될 수 있습니다 . 이는 가상 테이블 행을 고유 한 정수로 쉽게 맵핑 할 수없는 경우에 유용합니다. WITHOUT ROWID를 포함하는 CREATE TABLE 문은 하나 이상의 열을 PRIMARY KEY로 정의해야합니다. PRIMARY KEY의 모든 열은 개별적으로 NOT NULL이어야하며 각 행의 모든 ​​열은 집합 적으로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="914fd4075646f327da4b592c31312990facc6a8d" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02), SQLite also recognizes TRUE and FALSE keywords as aliases for integer values 1 and 0, respectively. This provides better compatibility with other SQL implementations. But to retain backwards compatibility, if there are columns named TRUE or FALSE, then the keywords are treated as identifiers referencing those columns, rather than BOOLEAN literals.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;버전 3.23.0&lt;/a&gt; (2018-04-02)부터 SQLite는 TRUE 및 FALSE 키워드를 각각 정수 값 1 및 0의 별칭으로 인식합니다. 이것은 다른 SQL 구현과의 호환성을 향상시킵니다. 그러나 이전 버전과의 호환성을 유지하기 위해 TRUE 또는 FALSE라는 열이있는 경우 키워드는 BOOLEAN 리터럴이 아니라 해당 열을 참조하는 식별자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="67498fb6faa33682195156e0b1885f3794748cc2" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;version 3.31.0&lt;/a&gt; (2020-01-22) the input F parameter can also be the name of a rollback journal file or WAL file in addition to the main database file. Prior to version 3.31.0, these routines would only work if F was the name of the main database file. When the F parameter is the name of the rollback journal or WAL file, it has access to all the same query parameters as were found on the main database file.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_31_0.html&quot;&gt;버전 3.31.0&lt;/a&gt; (2020-01-22)부터 입력 F 매개 변수는 기본 데이터베이스 파일 외에 롤백 저널 파일 또는 WAL 파일의 이름이 될 수도 있습니다. 3.31.0 이전 버전에서는 F가 기본 데이터베이스 파일의 이름 인 경우에만 이러한 루틴이 작동했습니다. F 매개 변수가 롤백 저널 또는 WAL 파일의 이름 인 경우 기본 데이터베이스 파일에서 발견 된 것과 동일한 모든 쿼리 매개 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9f2cb99d27921b6ac8152e7a3c891a53596352b" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disable for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;버전 3.7.13&lt;/a&gt; (2012-06-11) 부터는 데이터베이스가 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 사용하여 생성되는 경우 &lt;a href=&quot;inmemorydb&quot;&gt;메모리 내 데이터베이스에서&lt;/a&gt; 공유 캐시를 사용할 수 있습니다 . 이전 버전과의 호환성을 위해 비공식 이름 &quot;: memory :&quot;를 사용하여 데이터베이스를 열면 메모리 내 데이터베이스에 대해 공유 캐시가 항상 비활성화됩니다. 버전 3.7.13 이전에는 사용 된 데이터베이스 이름, 현재 시스템 공유 캐시 설정 또는 쿼리 매개 변수 또는 플래그에 관계없이 메모리 내 데이터베이스에 대해 공유 캐시가 항상 사용 안함으로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="6365abc3c758d3309a8a458a1000945ef77510f8" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disabled for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;버전 3.7.13&lt;/a&gt; (2012-06-11) 부터는 데이터베이스가 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 사용하여 생성 된 경우 &lt;a href=&quot;inmemorydb&quot;&gt;메모리 내 데이터베이스에서&lt;/a&gt; 공유 캐시를 사용할 수 있습니다 . 이전 버전과의 호환성을 위해 데이터베이스를 여는 데 표시되지 않은 이름 &quot;: memory :&quot;를 사용하는 경우 메모리 내 데이터베이스에 대해 공유 캐시가 항상 비활성화됩니다. 버전 3.7.13 이전에는 사용 된 데이터베이스 이름, 현재 시스템 공유 캐시 설정, 쿼리 매개 변수 또는 플래그에 관계없이 메모리 내 데이터베이스에 대해 공유 캐시가 항상 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d897fef3b918d90f462942b797bcba2f181cd38" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file has multiple hard links.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20) 부터는 데이터베이스 파일에 여러 개의 하드 링크가있는 경우 UNIX OS 인터페이스가 &lt;a href=&quot;errlog&quot;&gt;오류 로그에&lt;/a&gt; SQLITE_WARNING 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="7fa120398347f1152da8e84a3905c5d3c58c3466" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file is unlinked while it is still in use.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20) 부터는 데이터베이스 파일이 아직 사용 중일 때 링크 해제 된 경우 unix OS 인터페이스가 SQLITE_WARNING 메시지를 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8f4af8bd16f5f6dcf0575ed25d9da5ad7a3cecfc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;버전 3.7.3&lt;/a&gt; (2010-10-08) &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;부터는 SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션의 호출 여부에 관계없이 소프트 힙 제한이 적용 됩니다. &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하면 모든 메모리 할당에서 소프트 힙 제한이 적용됩니다. &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT가&lt;/a&gt; 없으면 소프트 힙 한계는 메모리가 페이지 캐시에 의해 할당 된 경우에만 적용됩니다. 테스트 결과, 페이지 캐시가 SQLite의 주요 메모리 사용자이므로 대부분의 응용 프로그램은 &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하지 않고도 적절한 소프트 힙 제한 적용을 달성 할 수 있다고 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="a0dfecc63fffa644348dc3e00941cc0dedd6014a" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;버전 3.7.3&lt;/a&gt; (2010-10-08) &lt;a href=&quot;compile#enable_memory_management&quot;&gt;부터는 SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션의 호출 여부에 관계없이 소프트 힙 제한이 적용 됩니다. &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하면 모든 메모리 할당에서 소프트 힙 제한이 적용됩니다. &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT가&lt;/a&gt; 없으면 소프트 힙 한계는 메모리가 페이지 캐시에 의해 할당 된 경우에만 적용됩니다. 테스트 결과, 페이지 캐시가 SQLite의 주요 메모리 사용자이므로 대부분의 응용 프로그램은 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하지 않고도 적절한 소프트 힙 제한 적용을 달성 할 수 있다고 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="c179ab3e7d04af330c7efc2cec123a479ee926c3" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary columns that store arbitrary data. Auxiliary columns can be used in place of secondary tables such as &quot;demo_data&quot;.</source>
          <target state="translated">SQLite 버전 3.24.0 (2018-06-04)부터 r-tree 테이블에는 임의의 데이터를 저장하는 보조 열이있을 수 있습니다. &quot;demo_data&quot;와 같은 보조 테이블 대신 보조 열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6d8128996ffada537e69bde476b38bfd6abdaaa" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.3.14 a mechanism has been added to try to reduce the needless rereading of data. In newer versions of SQLite, the data in the user-space pager cache is retained when the lock on the database file is released. Later, after the shared lock is acquired at the beginning of the next transaction, SQLite checks to see if any other process has modified the database file. If the database has been changed in any way since the lock was last released, the user-space cache is erased at that point. But commonly the database file is unchanged and the user-space cache can be retained, and some unnecessary read operations can be avoided.</source>
          <target state="translated">SQLite 버전 3.3.14부터 불필요한 데이터 다시 읽기를 줄이기위한 메커니즘이 추가되었습니다. 최신 버전의 SQLite에서는 데이터베이스 파일에 대한 잠금이 해제 될 때 사용자 공간 호출기 캐시의 데이터가 유지됩니다. 나중에 다음 트랜잭션이 시작될 때 공유 잠금이 획득 된 후 SQLite는 다른 프로세스가 데이터베이스 파일을 수정했는지 확인합니다. 잠금이 마지막으로 해제 된 이후 데이터베이스가 어떤 식 으로든 변경되면 해당 시점에서 사용자 공간 캐시가 지워집니다. 그러나 일반적으로 데이터베이스 파일은 변경되지 않고 사용자 공간 캐시를 보유 할 수 있으며 불필요한 읽기 조작을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c39116a071141537c93dfcacc99b39343f685f47" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), lookaside supports two memory pools, each with a different size slot. The small-slot pool uses 128-byte slots and the large-slot pool uses whatever size is specified by &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; (defaulting to 1200 bytes). Splitting the pool in two like this allows memory allocations to be covered by lookaside more often while at the same time reducing per-database-connection heap usage from 120KB down to 48KB.</source>
          <target state="translated">SQLite 버전 3.31.0 (2020-01-22)부터 lookaside는 각각 다른 크기의 슬롯을 가진 두 개의 메모리 풀을 지원합니다. 소형 슬롯 풀은 128 바이트 슬롯을 사용하고 대형 슬롯 풀은 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfiglookaside&quot;&gt;SQLITE_DBCONFIG_LOOKASIDE&lt;/a&gt; (기본값 1200 바이트)에 지정된 크기를 사용합니다 . 이와 같이 풀을 두 개로 분할하면 메모리 할당을 더 자주 lookaside로 처리하는 동시에 데이터베이스 연결 당 힙 사용량을 120KB에서 48KB로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="635d1349e5a7c9b8fbfcde84b9ea3c1fb202bc64" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.31.0 (2020-01-22), the DBSTAT table has a new &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; named &quot;aggregate&quot;, which if constrained to be TRUE will cause DBSTAT to generate one row per btree in the database, rather than one row per page. When running in aggregated mode, the &quot;path&quot;, &quot;pagetype&quot;, and &quot;pgoffset&quot; columns are always NULL and the &quot;pageno&quot; column holds the number of pages in the entire btree, rather than the number of the page that corresponds to the row.</source>
          <target state="translated">SQLite 버전 3.31.0 (2020-01-22)부터 DBSTAT 테이블에는 &quot;aggregate&quot;라는 새로운 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열&lt;/a&gt; 이 있습니다. TRUE로 제한하면 DBSTAT가 데이터베이스에서 btree 당 하나의 행이 아닌 하나의 행을 생성합니다. 페이지 당 행. 집계 모드에서 실행하는 경우 &quot;path&quot;, &quot;pagetype&quot;및 &quot;pgoffset&quot;열은 항상 NULL이고 &quot;pageno&quot;열은 해당하는 페이지 번호가 아니라 전체 btree의 페이지 수를 보유합니다. 열.</target>
        </trans-unit>
        <trans-unit id="c0eba5a240e8bc3220e00f595afb167768fa6cb7" translate="yes" xml:space="preserve">
          <source>Beginning with release 3.25.0 (2018-09-15), references to the table within trigger bodies and view definitions are also renamed.</source>
          <target state="translated">릴리스 3.25.0 (2018-09-15)부터 트리거 본문 및 뷰 정의 내의 테이블에 대한 참조 이름도 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="d654ce8d1a877b686fbd470426c428e02c9409c6" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.2.0, SQLite no longer builds an index for an INTEGER PRIMARY KEY column. Instead, it uses that column as the actual B-Tree key for the main table.</source>
          <target state="translated">버전 2.2.0부터 SQLite는 더 이상 INTEGER PRIMARY KEY 열에 대한 색인을 작성하지 않습니다. 대신, 해당 열을 기본 테이블의 실제 B- 트리 키로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="042e0229fee0d8bfed5724fa18cd980bad0c1945" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.3.0, SQLite supports some additional syntax (the &quot;ON CONFLICT&quot; clause) in the CREATE TABLE and CREATE INDEX statements that are stored in the SQLITE_MASTER table. If you create a database that contains this new syntax, then try to read that database using version 2.2.5 or earlier, the parser will not understand the new syntax and you will get an error. Otherwise, databases for 2.2.x and 2.3.x are interchangeable.</source>
          <target state="translated">버전 2.3.0부터 SQLite는 SQLITE_MASTER 테이블에 저장된 CREATE TABLE 및 CREATE INDEX 문에서 일부 추가 구문 ( &quot;ON CONFLICT&quot;절)을 지원합니다. 이 새 구문이 포함 된 데이터베이스를 작성하는 경우 버전 2.2.5 이하를 사용하여 해당 데이터베이스를 읽으려고하면 구문 분석기가 새 구문을 이해하지 못하므로 오류가 발생합니다. 그렇지 않은 경우 2.2.x 및 2.3.x의 데이터베이스는 서로 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="d9bdf31e2f633cc8ef293e098f7f5d722da8a2a8" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite added support for views. Information about views is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains VIEW information in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail. Also, the way SQLite keeps track of unused disk blocks in the database file changed slightly. If an older version of SQLite attempts to write a database that was previously written by version 2.4.0 or later, then it may leak disk blocks.</source>
          <target state="translated">버전 2.4.0부터 SQLite는 뷰에 대한 지원을 추가했습니다. 뷰에 대한 정보는 SQLITE_MASTER 테이블에 저장됩니다. 이전 버전의 SQLite가 SQLITE_MASTER 테이블에 VIEW 정보가 포함 된 데이터베이스를 읽으려고하면 구문 분석기가 새 구문을 이해하지 못하므로 초기화에 실패합니다. 또한 SQLite가 데이터베이스 파일에서 사용되지 않은 디스크 블록을 추적하는 방식이 약간 변경되었습니다. 이전 버전의 SQLite가 이전에 버전 2.4.0 이상에서 작성된 데이터베이스를 쓰려고 시도하면 디스크 블록이 누출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="413008ed4f165a3aca53c2fe0890bace8386a170" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite allows the SQL language to be extended with new functions implemented as C code. The following interface is used:</source>
          <target state="translated">버전 2.4.0부터 SQLite는 C 코드로 구현 된 새로운 기능으로 SQL 언어를 확장 할 수 있습니다. 다음과 같은 인터페이스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dad8b696b630a32cf19067fe14052c10b2bac25" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.5.0, SQLite added support for triggers. Information about triggers is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains a CREATE TRIGGER in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail.</source>
          <target state="translated">버전 2.5.0부터 SQLite는 트리거에 대한 지원을 추가했습니다. 트리거에 대한 정보는 SQLITE_MASTER 테이블에 저장됩니다. 이전 버전의 SQLite가 SQLITE_MASTER 테이블에 CREATE TRIGGER가 포함 된 데이터베이스를 읽으려고하면 구문 분석기가 새 구문을 이해하지 못하므로 초기화에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="50c1ec93a00d0cbe5badad130d3d4fbd2db53937" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.7.0, SQLite understands two different datatypes: text and numeric. Text data sorts in memcmp() order. Numeric data sorts in numerical order if it looks like a number, or in memcmp() order if it does not.</source>
          <target state="translated">버전 2.7.0부터 SQLite는 텍스트와 숫자의 두 가지 데이터 유형을 이해합니다. 텍스트 데이터는 memcmp () 순서로 정렬됩니다. 숫자 데이터는 숫자처럼 보이는 경우 숫자 순서로 정렬되거나 그렇지 않으면 memcmp () 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c06e002a374c4a8233bf3048a5c902a5ad629404" translate="yes" xml:space="preserve">
          <source>Beginning with version 3.5, SQLite obtains all of the heap memory it needs using the routines &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;. These routines have existed in prior versions of SQLite, but SQLite has previously bypassed these routines and used its own memory allocator. This all changes in version 3.5.0.</source>
          <target state="translated">버전 3.5부터 SQLite는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 루틴을 사용하여 필요한 모든 힙 메모리를 얻습니다 . 이러한 루틴은 이전 버전의 SQLite에 존재했지만 SQLite는 이전에 이러한 루틴을 무시하고 자체 메모리 할당자를 사용했습니다. 이것은 버전 3.5.0에서 모두 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb8a180b3917332f0d153bfa0ea4cd9cfa4625e" translate="yes" xml:space="preserve">
          <source>Behavior when page is not already in cache</source>
          <target state="translated">페이지가 캐시에없는 경우의 동작</target>
        </trans-unit>
        <trans-unit id="8f48bb3f768498f6c1f4331bb2d5a6b0f760fe90" translate="yes" xml:space="preserve">
          <source>Below is a simple &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL program&lt;/a&gt; that demonstrates how to use the TCL interface to SQLite. The program executes the SQL statements given as the second argument on the database defined by the first argument. The commands to watch for are the &lt;b&gt;sqlite3&lt;/b&gt; command on line 7 which opens an SQLite database and creates a new object named &quot;&lt;b&gt;db&lt;/b&gt;&quot; to access that database, the use of the &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval method&lt;/a&gt; on the &lt;b&gt;db&lt;/b&gt; object on line 8 to run SQL commands against the database, and the closing of the database connection on the last line of the script.</source>
          <target state="translated">다음은 TCL 인터페이스를 사용하여 SQLite에 사용하는 방법을 보여주는 간단한 &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL 프로그램&lt;/a&gt; 입니다. 프로그램은 첫 번째 인수로 정의 된 데이터베이스에서 두 번째 인수로 제공된 SQL 문을 실행합니다. 감시 할 명령은 7 행 의 &lt;b&gt;sqlite3&lt;/b&gt; 명령으로 SQLite 데이터베이스를 열고 해당 데이터베이스에 액세스하기 위해 &quot; &lt;b&gt;db&lt;/b&gt; &quot; 라는 새 오브젝트를 작성합니다. 8 행 의 &lt;b&gt;db&lt;/b&gt; 오브젝트에서 &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval 메소드&lt;/a&gt; 를 사용하여 SQL 명령을 실행합니다. 데이터베이스 및 스크립트의 마지막 행에서 데이터베이스 연결을 닫습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51e427c04349f8bec5760358d6c76a33f48f0315" translate="yes" xml:space="preserve">
          <source>Below is a simple C program that demonstrates how to use the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ interface&lt;/a&gt; to SQLite. The name of a database is given by the first argument and the second argument is one or more SQL statements to execute against the database. The function calls to pay attention to here are the call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; on line 22 which opens the database, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; on line 28 that executes SQL commands against the database, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on line 33 that closes the database connection.</source>
          <target state="translated">다음은 &lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++ 인터페이스&lt;/a&gt; 를 사용하여 SQLite 에 사용하는 방법을 보여주는 간단한 C 프로그램입니다 . 데이터베이스 이름은 첫 번째 인수로 제공되며 두 번째 인수는 데이터베이스에 대해 실행할 하나 이상의 SQL 문입니다. 여기에 임금의 관심에 함수 호출에 대한 호출입니다 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 데이터베이스가 열립니다 라인 (22)에 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 가 실행이 데이터베이스에 대해 명령을 SQL 것을 라인 (28)과의 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 데이터베이스 연결을 닫 라인 (33)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ff95327015619a83afc17706ad74370a046f84" translate="yes" xml:space="preserve">
          <source>Benefits of SQLite As A File Format</source>
          <target state="translated">파일 형식으로 SQLite의 장점</target>
        </trans-unit>
        <trans-unit id="616211207d8aaf668be94882f808c6f4c9f8f380" translate="yes" xml:space="preserve">
          <source>Benefits of using WITHOUT ROWID</source>
          <target state="translated">ROWID없이 사용할 때의 이점</target>
        </trans-unit>
        <trans-unit id="115df5f31354f3b89a7926f5d6643866714998ab" translate="yes" xml:space="preserve">
          <source>Better Applications</source>
          <target state="translated">더 나은 응용</target>
        </trans-unit>
        <trans-unit id="4f38499da00d33476ac2d33142547447ccd5f2e2" translate="yes" xml:space="preserve">
          <source>Better detection and handling of corrupt database files.</source>
          <target state="translated">손상된 데이터베이스 파일을보다 잘 감지하고 처리합니다.</target>
        </trans-unit>
        <trans-unit id="add6069aec6aedde19e26e2f4dc8b5d52557685c" translate="yes" xml:space="preserve">
          <source>Better error reporting when problems occur during the automatic 2.5.6 to 2.6.0 database format upgrade.</source>
          <target state="translated">자동 2.5.6에서 2.6.0 데이터베이스 형식으로 업그레이드하는 동안 문제가 발생하면 오류보고 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c0db7dca50a13779a4f0032e6c97723feb41348" translate="yes" xml:space="preserve">
          <source>Better handling of aggregate queries where the aggregate functions are contained within subqueries.</source>
          <target state="translated">집계 함수가 서브 쿼리 내에 포함되어있는 집계 쿼리를보다 잘 처리합니다.</target>
        </trans-unit>
        <trans-unit id="da084dd71de733c50c5b48104f01706c6f95c252" translate="yes" xml:space="preserve">
          <source>Better labels on column names of the result.</source>
          <target state="translated">결과의 열 이름에 더 나은 레이블.</target>
        </trans-unit>
        <trans-unit id="03681c8056a98d5199927eacf80bcf86a612f164" translate="yes" xml:space="preserve">
          <source>Better optimization of some IN operator expressions.</source>
          <target state="translated">일부 IN 연산자 표현식의 최적화가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="591ea8e488260fd421c2b234d660007536c8a620" translate="yes" xml:space="preserve">
          <source>Better support for file locking so that two or more processes (or threads) can access the same database simultaneously. More work needed in this area, though.</source>
          <target state="translated">둘 이상의 프로세스 (또는 스레드)가 동일한 데이터베이스에 동시에 액세스 할 수 있도록 파일 잠금 지원이 향상되었습니다. 하지만이 분야에서 더 많은 작업이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="edfa329825b8b1d38ad9507f28f42ef4366de8b4" translate="yes" xml:space="preserve">
          <source>Between them, the contents of the &quot;level&quot; and &quot;idx&quot; fields define the relative age of the segment b-tree. The smaller the value stored in the &quot;level&quot; field, the more recently the segment b-tree was created. If two segment b-trees are of the same &quot;level&quot;, the segment with the larger value stored in the &quot;idx&quot; column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents any two segments from having the same value for both the &quot;level&quot; and &quot;idx&quot; fields.</source>
          <target state="translated">그들 사이에서, &quot;level&quot;및 &quot;idx&quot;필드의 내용은 세그먼트 b- 트리의 상대적 연령을 정의합니다. &quot;레벨&quot;필드에 저장된 값이 작을수록 더 최근에 세그먼트 b- 트리가 작성되었습니다. 두 개의 세그먼트 b- 트리가 동일한 &quot;레벨&quot;인 경우 &quot;idx&quot;열에 더 큰 값을 저장 한 세그먼트가 더 최신입니다. % _segdir 테이블의 PRIMARY KEY 제약 조건으로 인해 두 세그먼트가 &quot;level&quot;및 &quot;idx&quot;필드 모두에 대해 동일한 값을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a826f46e213d85c4e2bac37d6cf8440b8e199d0" translate="yes" xml:space="preserve">
          <source>Beware of deleting persistent journal files by any other means since the journal file might be hot, in which case deleting it will corrupt the corresponding database file.</source>
          <target state="translated">저널 파일이 뜨거울 수 있으므로 다른 방법으로 영구 저널 파일을 삭제하지 않도록주의하십시오.이 경우 삭제하면 해당 데이터베이스 파일이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="bb96cbd05d1971e3d28050245a8829dd6b6aafd2" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
          <target state="translated">이진 연산자</target>
        </trans-unit>
        <trans-unit id="d2ac1eab329712a8a9c96ce99d077a92e950ad90" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">sqlite3_bind _ * () 인터페이스를 사용하여 값을 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수에&lt;/a&gt; 바인드하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8d99e3f4d2a89e533a8c574a3feaf717d81ec03" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">sqlite3_bind _ * () 인터페이스를 사용하여 값을 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수에&lt;/a&gt; 바인드하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">준비된 명령문에 값 바인딩</target>
        </trans-unit>
        <trans-unit id="416ca5a10db41c1cbc8b3d0b2abf3f34e937f4af" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 루틴으로 바인딩을 지우지 않습니다 . 언 바운드 매개 변수는 NULL로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="712e7456596b23817bd39e4145191dbf11698c78" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 루틴으로 바인딩을 지우지 않습니다 . 언 바운드 매개 변수는 NULL로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="0c26c52f02ad0e8a5ab4b7954c846a924ecffb7e" translate="yes" xml:space="preserve">
          <source>BitNot</source>
          <target state="translated">BitNot</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="d309b3faf2ef71b6ca2ba079fca1c0074e7599d4" translate="yes" xml:space="preserve">
          <source>Blob containing the root node of the segment b-tree.</source>
          <target state="translated">세그먼트 b- 트리의 루트 노드를 포함하는 Blob.</target>
        </trans-unit>
        <trans-unit id="d284e53d53a1c613b92c33b3c974704b23b2a857" translate="yes" xml:space="preserve">
          <source>Block until the unlock-notify callback is invoked by another thread.</source>
          <target state="translated">다른 스레드가 잠금 해제 알림 콜백을 호출 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="translated">부울 식</target>
        </trans-unit>
        <trans-unit id="c4e413aea96ae1ca804567104303036969e3a88f" translate="yes" xml:space="preserve">
          <source>Boolean datatype</source>
          <target state="translated">부울 데이터 유형</target>
        </trans-unit>
        <trans-unit id="cb72c24cf8f622cb6c601ea54b18c1fb6181c3db" translate="yes" xml:space="preserve">
          <source>Boolean expression</source>
          <target state="translated">부울 식</target>
        </trans-unit>
        <trans-unit id="275cc7006db94d75505db825dc5542aed9bfc26c" translate="yes" xml:space="preserve">
          <source>Borland</source>
          <target state="translated">Borland</target>
        </trans-unit>
        <trans-unit id="2198db2aa3b167004c136853d6cdd281fb62f84a" translate="yes" xml:space="preserve">
          <source>Borland Interbase does not support CASE expressions.</source>
          <target state="translated">Borland Interbase는 CASE 표현식을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddec281bbecd09ca0988545c1af57dbffaa268c1" translate="yes" xml:space="preserve">
          <source>Both UPDATE statements do exactly the same thing. (They generate identical &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;.) But the first form, the row value form, seems to make it clearer that the intent of the statement is to swap the values in columns A and B.</source>
          <target state="translated">두 UPDATE 문은 모두 정확히 똑같습니다. (동일한 &lt;a href=&quot;opcode&quot;&gt;바이트 코드를&lt;/a&gt; 생성합니다 .) 그러나 첫 번째 형식 인 행 값 형식은 명령문의 의도가 열 A와 B의 값을 바꾸는 것임을 분명히하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dfb4c7d44434c0c4d4db97610721023fe7e4509" translate="yes" xml:space="preserve">
          <source>Both forms of the CASE expression use lazy, or short-circuit, evaluation.</source>
          <target state="translated">CASE 표현의 두 가지 형태는 모두 게으른 또는 단락 평가를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bb63583b07e5e464e63e50a8a4cb32ce2f9c5978" translate="yes" xml:space="preserve">
          <source>Both methods for loading an extension allow you to specify the name of an entry point for the extension. You can leave this argument blank - passing in a NULL pointer for the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language interface or omitting the second argument for the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL interface - and the extension loader logic will attempt to figure out the entry point on its own. It will first try the generic extension name &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a entry point using the template &quot;sqlite3_X_init&quot; where the X is replaced by the lowercase equivalent of every ASCII character in the filename after the last &quot;/&quot; and before the first following &quot;.&quot; omitting the first three characters if they happen to be &quot;lib&quot;. So, for example, if the filename is &quot;/usr/lib/libmathfunc-4.8.so&quot; the entry point name would be &quot;sqlite3_mathfunc_init&quot;. Or if the filename is &quot;./SpellFixExt.dll&quot; then the entry point would be called &quot;sqlite3_spellfixext_init&quot;.</source>
          <target state="translated">확장을로드하는 두 가지 방법 모두 확장에 대한 진입 점의 이름을 지정할 수 있습니다. &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C 언어 인터페이스에 NULL 포인터를 전달 하거나 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()에&lt;/a&gt; 대한 두 번째 인수를 생략 하여이 인수를 비워 둘 수 있습니다.SQL 인터페이스-확장 로더 로직은 자체적으로 진입 점을 파악하려고 시도합니다. 먼저 일반 확장명 &quot;sqlite3_extension_init&quot;를 시도합니다. 그래도 작동하지 않으면 &quot;sqlite3_X_init&quot;템플릿을 사용하여 시작점을 생성합니다. 여기서 X는 마지막 &quot;/&quot;다음 및 첫 번째 &quot;&quot; &quot;이전의 파일 이름에서 모든 ASCII 문자에 해당하는 소문자로 바뀝니다. &quot;lib&quot;인 경우 처음 세 문자를 생략합니다. 예를 들어 파일 이름이 &quot;/usr/lib/libmathfunc-4.8.so&quot;인 경우 진입 점 이름은 &quot;sqlite3_mathfunc_init&quot;입니다. 또는 파일 이름이 &quot;./SpellFixExt.dll&quot;인 경우 진입 점은 &quot;sqlite3_spellfixext_init&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8d91ab9fdfa652980c96ceff09049c0ea85b3c70" translate="yes" xml:space="preserve">
          <source>Both of the RBU functions may be accomplished using SQLite's built-in SQL commands - RBU update via a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands within a single transaction, and RBU vacuum by a single &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. The RBU module provides the following advantages over these simpler approaches:</source>
          <target state="translated">두 RBU 기능은 단일 트랜잭션 내에서 일련의 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 명령을 통한 SQLite의 내장 SQL 명령-RBU 업데이트 및 단일 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령에 의한 RBU 진공을 사용하여 수행 할 수 있습니다. RBU 모듈은 이러한 간단한 접근 방식에 비해 다음과 같은 장점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e0f6600d4e5a9c39fa518762238ad90dd63b65fb" translate="yes" xml:space="preserve">
          <source>Both of the above example queries would work fine without the acctchng_magnitude index. The acctchng_magnitude index index merely helps the queries to run faster, especially on databases where there are many entries in the table for each account.</source>
          <target state="translated">위의 두 예제 쿼리 모두 acctchng_magnitude 인덱스가 없으면 제대로 작동합니다. acctchng_magnitude 인덱스 인덱스는 특히 각 계정에 대해 테이블에 많은 항목이있는 데이터베이스에서 쿼리 실행 속도를 높이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a2132ed90a9ffb07d66917a3fc0b34d8d92cac4" translate="yes" xml:space="preserve">
          <source>Both the TCL and TH3 test harnesses automatically track system resources and report resource leaks on &lt;u&gt;every&lt;/u&gt; test run. No special configuration or setup is required. The test harnesses are especially vigilant with regard to memory leaks. If a change causes a memory leak, the test harnesses will recognize this quickly. SQLite is designed to never leak memory, even after an exception such as an OOM error or disk I/O error. The test harnesses are zealous to enforce this.</source>
          <target state="translated">TCL 및 TH3 테스트 하네스는 시스템 테스트를 자동으로 추적하고 &lt;u&gt;모든&lt;/u&gt; 테스트 실행 에서 리소스 누수를보고 합니다. 특별한 구성이나 설정이 필요하지 않습니다. 테스트 하네스는 특히 메모리 누수와 관련하여주의를 기울입니다. 변경으로 인해 메모리 누수가 발생하는 경우 테스트 장치가이를 빠르게 인식합니다. SQLite는 OOM 오류 또는 디스크 I / O 오류와 같은 예외 후에도 메모리가 누출되지 않도록 설계되었습니다. 테스트 하네스는이를 시행하기 위해 열성적입니다.</target>
        </trans-unit>
        <trans-unit id="0ad3d82720f17203691deee7f5777d99c121ae33" translate="yes" xml:space="preserve">
          <source>Both the WHEN clause and the trigger actions may access elements of the row being inserted, deleted or updated using references of the form &quot;NEW.</source>
          <target state="translated">WHEN 절과 트리거 조치 모두 &quot;NEW. 형식의 참조를 사용하여 삽입, 삭제 또는 업데이트되는 행의 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f093637993a88624b64eec10be0614efea759e81" translate="yes" xml:space="preserve">
          <source>Both the pointer and the pointer type parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interfaces are &quot;owned&quot; by the caller. In other words, the caller is responsible for ensuring that both values remain valid until after the last access via &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 인터페이스에 대한 포인터 및 포인터 유형 매개 변수 는 호출자가 &quot;소유&quot;합니다. 다시 말해, 호출자는 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 를 통한 마지막 액세스 이후까지 두 값이 모두 유효한 상태를 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d575a966c9a089363bea2d3980a3ff66687213c3" translate="yes" xml:space="preserve">
          <source>Both virtual tables are read-only &lt;a href=&quot;vtab#epoonlyvtab&quot;&gt;eponymous-only virtual tables&lt;/a&gt;. You use them by mentioning them directly in the FROM clause of a SELECT statement. They both require a single argument which is the SQL statement to be analyzed. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2992a96404e75efb9d5d247c72b5e6d63bb4aa3e" translate="yes" xml:space="preserve">
          <source>Boundary value tests</source>
          <target state="translated">경계 값 테스트</target>
        </trans-unit>
        <trans-unit id="3145fd01726b003b2b97b5a9fb483277f3a90dd2" translate="yes" xml:space="preserve">
          <source>Branch coverage in SQLite is currently measured using &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; with the &quot;-b&quot; option. First the test program is compiled using options &quot;-g -fprofile-arcs -ftest-coverage&quot; and then the test program is run. Then &quot;gcov -b&quot; is run to generate a coverage report. The coverage report is verbose and inconvenient to read, so the gcov-generated report is processed using some simple scripts to put it into a more human-friendly format. This entire process is automated using scripts, of course.</source>
          <target state="translated">SQLite의 분기 범위는 현재 &quot;-b&quot;옵션과 함께 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; 를 사용하여 측정됩니다 . 먼저 &quot;-g -fprofile-arcs -ftest-coverage&quot;옵션을 사용하여 테스트 프로그램을 컴파일 한 다음 테스트 프로그램을 실행합니다. 그런 다음 &quot;gcov -b&quot;가 실행되어 적용 범위 보고서를 생성합니다. 적용 범위 보고서는 장황하고 읽기가 불편하므로 gcov 생성 보고서는 간단한 스크립트를 사용하여보다 인간 친화적 인 형식으로 작성됩니다. 이 전체 프로세스는 물론 스크립트를 사용하여 자동화됩니다.</target>
        </trans-unit>
        <trans-unit id="c4adfe3c542d88432092f783bc046835df0fe815" translate="yes" xml:space="preserve">
          <source>Branch coverage is more rigorous than statement coverage. Branch coverage measures the number of machine-code branch instructions that are evaluated at least once on both directions.</source>
          <target state="translated">지점 범위는 명세서 범위보다 더 엄격합니다. 분기 범위는 양방향에서 한 번 이상 평가되는 기계 코드 분기 명령어의 수를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="a22b75ea309c645c4530e03f4541cb259f2d61c7" translate="yes" xml:space="preserve">
          <source>Branch coverage is more strict. With branch coverage, each test and each subblock within the statement is considered separately. In order to achieve 100% branch coverage in the example above, there must be at least three test cases:</source>
          <target state="translated">지점 적용 범위가 더 엄격합니다. 분기 적용 범위를 사용하면 명령문 내의 각 테스트와 각 하위 블록이 별도로 고려됩니다. 위의 예에서 100 % 분기 적용 범위를 달성하려면 최소한 세 가지 테스트 사례가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="97c730065aaff2da27316c3a4fdb27f33630fd48" translate="yes" xml:space="preserve">
          <source>Break out the &quot;Presentor Notes&quot; from each slide into a separate table, for easier access from third-party applications and/or scripts.</source>
          <target state="translated">타사 응용 프로그램 및 / 또는 스크립트에서 쉽게 액세스 할 수 있도록 각 슬라이드의 &quot;발표자 노트&quot;를 별도의 테이블로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="c53bff6ff25ebaccf14a4078fdb0261d0ccc01ee" translate="yes" xml:space="preserve">
          <source>Break out the GDBM driver into a separate file in anticipation to added new drivers.</source>
          <target state="translated">새 드라이버를 추가 할 것으로 예상하여 GDBM 드라이버를 별도의 파일로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="282c5dfb378bb6abed7a208812bdb6a15f29a876" translate="yes" xml:space="preserve">
          <source>Bring the OS/2 porting layer up-to-date.</source>
          <target state="translated">OS / 2 포팅 계층을 최신 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="82e575ff594a72cfcaccd19ccbf9ad35b704bb47" translate="yes" xml:space="preserve">
          <source>Bring the processing of ORDER BY into compliance with the SQL standard for case where a result alias and a table column name are in conflict. Correct behavior is to prefer the result alias. Older versions of SQLite incorrectly picked the table column. (See ticket #2822.)</source>
          <target state="translated">결과 별명과 테이블 열 이름이 충돌하는 경우 ORDER BY 처리를 SQL 표준에 따르십시오. 올바른 동작은 결과 별칭을 선호하는 것입니다. 이전 버전의 SQLite는 테이블 열을 잘못 선택했습니다. (티켓 # 2822 참조)</target>
        </trans-unit>
        <trans-unit id="4f04fd57f5bfebe96a862aebe73b135def3ab6df" translate="yes" xml:space="preserve">
          <source>Bug fix in the processing of the ORDER BY clause for GROUP BY queries</source>
          <target state="translated">GROUP BY 쿼리에 대한 ORDER BY 절 처리시 버그 수정</target>
        </trans-unit>
        <trans-unit id="a725ca76655ec9003bb82b1a676029a85c0e7d07" translate="yes" xml:space="preserve">
          <source>Bug fix: &quot;SELECT count(*)&quot; was returning NULL for empty tables. Now it returns 0.</source>
          <target state="translated">버그 수정 : &quot;SELECT count (*)&quot;가 빈 테이블에 대해 NULL을 반환했습니다. 이제 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e476047ffbbf1baca852a2317f6d224dd2d875a" translate="yes" xml:space="preserve">
          <source>Bug fix: Add in a mutex that was omitted from the previous release.</source>
          <target state="translated">버그 수정 : 이전 릴리스에서 생략 된 뮤텍스를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ab7e0eb1f7494f905f4da13b15772e1fb07bbe1e" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing if &quot;PRAGMA full_column_names=ON;&quot; was set and you did a query that used a rowid, like this: &quot;SELECT rowid, * FROM ...&quot;.</source>
          <target state="translated">버그 수정 : &quot;PRAGMA full_column_names = ON;&quot;인 경우 어설 션이 실패했습니다. &quot;SELECT rowid, * FROM ...&quot;과 같이 rowid를 사용하는 쿼리를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="421117f09c1ef6c1c766b17bffc8c48c0d11cebc" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing when a temporary table with an index had the same name as a permanent table created by a separate process.</source>
          <target state="translated">버그 수정 : 인덱스가있는 임시 테이블의 이름이 별도의 프로세스로 작성된 영구 테이블과 동일한 경우 어설 션이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="0dceede8b9155b23f776e96cfdf9ce26f1c18497" translate="yes" xml:space="preserve">
          <source>Bug fix: An attempt to delete a single row of a table with a WHERE clause of &quot;ROWID=x&quot; when no such rowid exists was causing an error.</source>
          <target state="translated">버그 수정 : 그러한 rowid가 없을 때 WHERE 절이 &quot;ROWID = x&quot;인 테이블의 단일 행을 삭제하려는 시도로 인해 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="faaa0c6caea2e40fd936178cd8a1148168d7f164" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid a deadlock or crash if the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;, &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, and the SQLite Encryption Extension are all used at once.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;backup&quot;&gt;백업 API&lt;/a&gt; , &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 및 SQLite 암호화 확장이 모두 동시에 사용되는 경우 교착 상태 또는 충돌을 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9851f7cc2ef1b47f1ede36a70787a28d8a73936" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid leaking memory on LIMIT and OFFSET clauses in deeply nested UNION ALL queries.</source>
          <target state="translated">버그 수정 : 깊이 중첩 된 UNION ALL 쿼리에서 LIMIT 및 OFFSET 절의 메모리 누수를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="eb351871f180a85fd09c35dd04ce4b51eee599a0" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid segfault when using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; inside of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 내 에서 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용 하거나 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 를 사용할 때는 segfault를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="a618ecebefb94412f1562472983ff94e3605eaab" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid various concurrency problems in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 다양한 동시성 문제를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="633b128d954ff36563e10076bd92bfc7d4d254bc" translate="yes" xml:space="preserve">
          <source>Bug fix: Bare identifiers in ORDER BY clauses bind more tightly to output column names, but identifiers in expressions bind more tightly to input column names. Identifiers in GROUP BY clauses always prefer output column names, however.</source>
          <target state="translated">버그 수정 : ORDER BY 절의 베어 식별자는 출력 열 이름에 더 밀접하게 바인딩되지만 식의 식별자는 입력 열 이름에 더 밀접하게 바인딩됩니다. 그러나 GROUP BY 절의 식별자는 항상 출력 열 이름을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="6a402a829e3faf4148ff927e5cc1ab64a56cfa4a" translate="yes" xml:space="preserve">
          <source>Bug fix: Column names in the result set were not being generated correctly for some (rather complex) VIEWs. This could cause a segfault under certain circumstances.</source>
          <target state="translated">버그 수정 : 결과 집합의 열 이름이 일부 (보다 복잡한) VIEW에 대해 올바르게 생성되지 않았습니다. 특정 상황에서 segfault가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6507d4034fca406ed1e6de7d9c69eb86666298e" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute correct table names with the FULL_COLUMN_NAMES pragma is turned on.</source>
          <target state="translated">버그 수정 : FULL_COLUMN_NAMES pragma를 사용하여 올바른 테이블 이름을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="d170d4831a6701524951017930d51215c0de3ceb" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : WHERE 절에 IS NOT NULL 용어가 포함되어 있고 WHERE 절에 OR 용어가 포함되어 있고 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 로 컴파일 된 쿼리에 대한 정답을 계산하십시오 . &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;티켓 [4c86b126f2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9e9fa36344bc0f04a7e81c8fa8066aa6b76c8c72" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle functions that appear in the WHERE clause of a join.</source>
          <target state="translated">버그 수정 : 조인의 WHERE 절에 나타나는 함수를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="b19417477425f028b30221d15629f2e13bb03e35" translate="yes" xml:space="preserve">
          <source>Bug fix: Correctly handle terms in the WHERE clause of a join that do not contain a comparison operator.</source>
          <target state="translated">버그 수정 : 비교 연산자가 포함되지 않은 조인의 WHERE 절에서 용어를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="f1c7035443112823f2488a80b27044cd7dc930ca" translate="yes" xml:space="preserve">
          <source>Bug fix: Creating and dropping a table all within a single transaction was not working.</source>
          <target state="translated">버그 수정 : 단일 트랜잭션 내에서 테이블 작성 및 삭제가 모두 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a65ee45495a64aa4ac7b00532e7dcdea10a45c93" translate="yes" xml:space="preserve">
          <source>Bug fix: DISTINCT now recognizes that a &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; and a blob of all 0x00 bytes are the same thing. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;Ticket [fccbde530a]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : DISTINCT는 이제 &lt;a href=&quot;lang_corefunc#zeroblob&quot;&gt;zeroblob&lt;/a&gt; 과 모든 0x00 바이트의 얼룩이 같은 것을 인식합니다. &lt;a href=&quot;http://www.sqlite.org/src/info/fccbde530a&quot;&gt;티켓 [fccbde530a]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e1c19457c6bcac61af13a07643a50b8996bac51" translate="yes" xml:space="preserve">
          <source>Bug fix: DROP TABLE followed by a CREATE TABLE with the same name all within a single transaction was causing a coredump.</source>
          <target state="translated">버그 수정 : 단일 트랜잭션 내에서 DROP TABLE 다음에 같은 이름을 가진 CREATE TABLE이 코어 덤프를 일으켰습니다.</target>
        </trans-unit>
        <trans-unit id="ba00de2c0632584e59e348681ca42b12b644bcbe" translate="yes" xml:space="preserve">
          <source>Bug fix: Database corruption can occur due to the optimization that was introduced in version 2.4.0 (check-in [410]). The problem should now be fixed. The use of versions 2.4.0 through 2.5.2 is not recommended.</source>
          <target state="translated">버그 수정 : 버전 2.4.0 (체크인 [410])에서 도입 된 최적화로 인해 데이터베이스 손상이 발생할 수 있습니다. 이제 문제가 해결되었습니다. 버전 2.4.0부터 2.5.2는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bbe70e0c57d51f533365c58d207cdfb57683c5ef" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not allow a virtual table to cancel the ORDER BY clause unless all outer loops are guaranteed to return no more than one row result. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 모든 외부 루프가 하나 이상의 행 결과를 반환하도록 보장되지 않는 한 가상 테이블이 ORDER BY 절을 취소하도록 허용하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/ba82a4a41eac1&quot;&gt;ba82a4a41eac1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4c3b898a085ef4e9fd7492842026dc724b1316d2" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not attempt the subquery flattening optimization on queries that lack a FROM clause. To do so causes a segfault.</source>
          <target state="translated">버그 수정 : FROM 절이없는 쿼리에서 하위 쿼리 병합 최적화를 시도하지 마십시오. 그렇게하면 segfault가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7d832b024aa33f5c367340914044de719478c03" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not automatically remove the DISTINCT keyword from a SELECT that forms the right-hand side of an IN operator since it is necessary if the SELECT also contains a LIMIT. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : SELECT에 LIMIT도 포함되어 있으면 IN 연산자의 오른쪽을 구성하는 SELECT에서 DISTINCT 키워드를 자동으로 제거하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/db87229497&quot;&gt;db87229497&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ec8b17071def3e40c2a66c3efc8f85f8fbeb60d" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not discard the DISTINCT as superfluous unless a subset of the result set is subject to a UNIQUE constraint &lt;em&gt;and&lt;/em&gt; it none of the columns in that subset can be NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 결과 집합의 부분 집합이 UNIQUE 제약 조건이 적용되지 않는 음주 불필요한으로 DISTINCT를 버리지 &lt;em&gt;과&lt;/em&gt; 그 부분 집합의 열 그 어느 것도 NULL이 될 수 있습니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/385a5b56b9&quot;&gt;385a5b56b9&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d122c8d80295b61ea78f7985674ee07265e9fe63" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not move WHERE clause terms inside OR expressions that are contained within an ON clause of a LEFT JOIN. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</source>
          <target state="translated">버그 수정 : WHERE 절 용어를 LEFT JOIN의 ON 절에 포함 된 OR 표현식으로 이동하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/f2369304e4&quot;&gt;f2369304e4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b3ae0e3595ba9969a417594021c4332e3d08633" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not optimize away an ORDER BY clause that has the same terms as a UNIQUE index unless those terms are also NOT NULL. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 해당 용어도 NOT NULL이 아닌 한 UNIQUE 인덱스와 동일한 용어를 가진 ORDER BY 절을 최적화하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2a5629202f&quot;&gt;2a5629202f&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6453e25436ce2c11dc1b6194ae2dc12f5ca5250" translate="yes" xml:space="preserve">
          <source>Bug fix: Do not suppress the ORDER BY clause on a virtual table query if an IN constraint is used. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : IN 제약 조건이 사용되는 경우 가상 테이블 쿼리에서 ORDER BY 절을 억제하지 마십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/f69b96e3076e&quot;&gt;f69b96e3076e&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f89fece6f5c7d025fca0afff2d5506eaef79c01" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure that &quot;ORDER BY random()&quot; clauses do not get optimized out. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;Ticket [65bdeb9739]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : &quot;ORDER BY random ()&quot;절이 최적화되지 않았는지 확인하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/65bdeb9739&quot;&gt;티켓 [65bdeb9739]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad5b813b289d7e750591bfb845e4ba940a74acee" translate="yes" xml:space="preserve">
          <source>Bug fix: Ensure the cached KeyInfo objects (an internal abstraction not visible to the application) do not go stale when operating in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; and frequently closing and reopening some database connections while leaving other database connections on the same shared cache open continuously. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 작동 하고 동일한 공유 캐시의 다른 데이터베이스 연결을 계속 열어두고 일부 데이터베이스 연결을 자주 닫았다가 다시 열 때 캐시 된 KeyInfo 객체 (애플리케이션에 보이지 않는 내부 추상화)가 오래 걸리지 않도록 하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/e4a18565a36884b00edf&quot;&gt;e4a18565a36884b00edf&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c94982c68fc72ac2f6ac980a3323226e84f8466" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a 32-bit overflow problem on CREATE INDEX for databases larger than 16GB.</source>
          <target state="translated">버그 수정 : 16GB보다 큰 데이터베이스의 CREATE INDEX에서 32 비트 오버 플로우 문제를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="b6580b5e5232c84824bf613c858acbb24fc5f483" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix a potential &lt;b&gt;database corruption bug&lt;/b&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; when one &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is closed while another is in the middle of a write transaction. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 한 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 닫히고 다른 데이터베이스 연결 이 쓰기 트랜잭션 도중에 있을 때 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 잠재적 인 &lt;b&gt;데이터베이스 손상 버그&lt;/b&gt; 를 수정 합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/e636a050b7&quot;&gt;e636a050b7&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28f644aa67590d02891787c2b2d9de10e303faef" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an assertion failure that occurred when ROWID was a column in a SELECT statement on a view.</source>
          <target state="translated">버그 수정 : ROWID가 뷰의 SELECT 문의 열일 때 발생하는 어설 션 오류를 수정합니다.</target>
        </trans-unit>
        <trans-unit id="6de63655427b8362357e0b9729e0309dea102b68" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix an uninitialized variable in the VDBE that would could an assert failure.</source>
          <target state="translated">버그 수정 : VDBE에서 초기화되지 않은 변수를 수정하여 어설 션 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15567e970418f92d21404d2b997ca55ed7870f2d" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix column default values expressions of the form &quot;DEFAULT(-(-9223372036854775808))&quot; so that they work correctly, initializing the column to a floating point value approximately equal to +9223372036854775808.0.</source>
          <target state="translated">버그 수정 : &quot;DEFAULT (-(-9223372036854775808))&quot;형식의 열 기본값 표현식을 수정하여 열이 거의 +9223372036854775808.0과 같은 부동 소수점 값으로 초기화되도록 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b572be392d93fe8f8aa3c731cb70e9adb855b95a" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; SQL function so that it returns an empty string rather than an &quot;out of memory&quot; error when called with zero arguments.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;lang_corefunc#char&quot;&gt;char ()&lt;/a&gt; SQL 함수를 수정하여 인수가 0 인 경우 &quot;메모리 부족&quot;오류가 아닌 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec8ef57ae219363ebc2f9d36c425f7585ca571b1" translate="yes" xml:space="preserve">
          <source>Bug fix: Fix the &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; command so that it does not cancel pending queries. This repairs a problem introduced in 3.7.11.</source>
          <target state="translated">버그 수정 : 보류중인 쿼리를 취소하지 않도록 &lt;a href=&quot;lang_savepoint&quot;&gt;RELEASE&lt;/a&gt; 명령을 수정하십시오 . 3.7.11에서 소개 된 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="df416fd402ae79122987fd712ad3deeb5c8f5458" translate="yes" xml:space="preserve">
          <source>Bug fix: Generate correct column headers when a compound SELECT is used as a subquery.</source>
          <target state="translated">버그 수정 : 복합 SELECT가 하위 쿼리로 사용될 때 올바른 열 헤더를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8607f97a039e79f9d7bbfb840d1dbfffbf0765f7" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; CSV import feature, do not end a field when an escaped double-quote occurs at the end of a CRLN line.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; CSV 가져 오기 기능에서 이스케이프 된 큰 따옴표가 CRLN 줄의 끝에서 발생할 때 필드를 끝내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d77f01bc12cfaa192da17d51a33bb2f997769b11" translate="yes" xml:space="preserve">
          <source>Bug fix: In the &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; tokenizer of &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, treat all private code points as identifier symbols.</source>
          <target state="translated">버그 수정 다음에서 &lt;a href=&quot;fts3#unicode61&quot;&gt;unicode61&lt;/a&gt; 의 토크 나이 &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; , 식별자 상징으로 모든 개인 코드 포인트를 취급합니다.</target>
        </trans-unit>
        <trans-unit id="fc0e959c372e361cf7f33ef8b8f20d674104ba00" translate="yes" xml:space="preserve">
          <source>Bug fix: Issue an error message if the 16-bit reference counter on a view overflows due to an overly complex query.</source>
          <target state="translated">버그 수정 : 지나치게 복잡한 쿼리로 인해 뷰의 16 비트 참조 카운터가 오버플로되면 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="796cd2d86e5fad8940076a58510533a97b2c56bf" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &quot;rowid&quot; columns are correctly resolved in joins between normal tables and WITHOUT ROWID tables. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;Ticket [c34d0557f7]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 일반 테이블과 WITHOUT ROWID 테이블 사이의 조인에서 &quot;rowid&quot;열이 올바르게 분석되는지 확인하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/c34d0557f7&quot;&gt;티켓 [c34d0557f7]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="adf0baa27394f8041aaae283cf02f3ee1bfa8b41" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements appear in &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; output.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문이 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 출력에 나타나는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="2334a8bc658fa8a7b723fcf78436e06aa632b55a" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure an error is always reported when attempting to preform an operation that requires a &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; that is missing. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 누락 된 &lt;a href=&quot;datatype3#collation&quot;&gt;배열 순서&lt;/a&gt; 가 필요한 작업을 수행 할 때 항상 오류가보고되는지 확인하십시오 . 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/0fc59f908b&quot;&gt;0fc59f908b&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b7a3c06c81b08010533a335b71314ea1246750e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure that NULL results from OP_Column are fully and completely NULL and do not have the MEM_Ephem bit set. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : OP_Column의 NULL 결과가 완전하고 완전히 NULL이며 MEM_Ephem 비트가 설정되어 있지 않은지 확인하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/094d39a4c95ee4&quot;&gt;094d39a4c95ee4&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b6a649b8a7464f814f81388b6be52f54e12c25e" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the journal file directory entry is committed to disk before writing the database file.</source>
          <target state="translated">버그 수정 : 데이터베이스 파일을 쓰기 전에 저널 파일 디렉토리 항목이 디스크에 커밋되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e185f43b49a3251f6e6597892c2f724efa586d32" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the same temporary registers are not used in concurrent co-routines used to implement compound SELECT statements containing ORDER BY clauses, as such use can lead to incorrect answers. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;Ticket [8c63ff0eca]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : ORDER BY 절을 포함하는 복합 SELECT 문을 구현하는 데 사용되는 동시 동시 루틴에서 동일한 임시 레지스터를 사용하지 마십시오. 오답으로 이어질 수 있습니다. &lt;a href=&quot;http://www.sqlite.org/src/info/8c63ff0eca&quot;&gt;티켓 [8c63ff0eca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51326d84193d9019e013ecb68f17ddd96b5b7cd8" translate="yes" xml:space="preserve">
          <source>Bug fix: Make sure the schema is up-to-date prior to running pragmas table_info, index_list, index_info, and foreign_key_list.</source>
          <target state="translated">버그 수정 : pragmas table_info, index_list, index_info 및 foreign_key_list를 실행하기 전에 스키마가 최신인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="21876ec37a821c06e59ab2273c8a26e3a12144f2" translate="yes" xml:space="preserve">
          <source>Bug fix: Makes sure the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;authorizer&lt;/a&gt; callback gets a valid pointer to the string &quot;ROWID&quot; for the column-name parameter when doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; that changes the rowid. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;권한 부 여자&lt;/a&gt; 콜백이 rowid를 변경 하는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 를 수행 할 때 column-name 매개 변수에 대한 &quot;ROWID&quot;문자열에 대한 유효한 포인터를 가져 오도록합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/0eb70d77cb05bb2272&quot;&gt;0eb70d77cb05bb2272&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa2f91d43fa97f1a5999350e4addb5cbb3edaca1" translate="yes" xml:space="preserve">
          <source>Bug fix: Only consider AS names from the result set as candidates for resolving identifiers in the WHERE clause if there are no other matches. In the ORDER BY clause, AS names take priority over any column names. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 일치하는 다른 항목이없는 경우 결과 집합의 AS 이름 만 WHERE 절에서 식별자를 해결할 후보로 고려하십시오. ORDER BY 절에서 AS 이름은 모든 열 이름보다 우선합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2500cdb9be05&quot;&gt;2500cdb9be05&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="141fde2a748db5215be1ecb9d4a778d891f1cb31" translate="yes" xml:space="preserve">
          <source>Bug fix: Passing in a NULL as the 3rd parameter to &lt;b&gt;sqlite_open()&lt;/b&gt; would sometimes cause a coredump.</source>
          <target state="translated">버그 수정 : &lt;b&gt;sqlite_open ()에&lt;/b&gt; 세 번째 매개 변수로 NULL을 전달하면 때때로 코어 덤프가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2ab06e54b175379ab13bc77c3e0d9c481bc0c496" translate="yes" xml:space="preserve">
          <source>Bug fix: Recognize that any column in the right-hand table of a LEFT JOIN can be NULL even if the column has a NOT NULL constraint. Do not apply optimizations that assume the column is never NULL. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 열에 NOT NULL 제약 조건이 있어도 LEFT JOIN의 오른쪽 테이블에있는 열이 NULL 일 수 있음을 인식하십시오. 열이 NULL이 아니라고 가정하는 최적화를 적용하지 마십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/6f2222d550f5b0ee7ed&quot;&gt;6f2222d550f5b0ee7ed&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03f2e3e890c570259cec0056bb1e5602f41a8fe5" translate="yes" xml:space="preserve">
          <source>Bug fix: Repair a name-resolution error that can occur in sub-select statements contained within a TRIGGER. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;Ticket [4ef7e3cfca]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : TRIGGER에 포함 된 하위 선택문에서 발생할 수있는 이름 확인 오류를 수정하십시오. &lt;a href=&quot;http://www.sqlite.org/src/info/4ef7e3cfca&quot;&gt;티켓 [4ef7e3cfca]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179d04a255aba0b12c6e57bf1304a5f158b18e87" translate="yes" xml:space="preserve">
          <source>Bug fix: SQL functions created using the TCL interface honor the &quot;nullvalue&quot; setting.</source>
          <target state="translated">버그 수정 : TCL 인터페이스를 사용하여 작성된 SQL 함수는 &quot;널값&quot;설정을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="0cd3dbb56d1124c2a6604fca7c97c5b4d246ad99" translate="yes" xml:space="preserve">
          <source>Bug fix: Sometimes arbitrary strings were passed to the callback function when the actual value of a column was NULL.</source>
          <target state="translated">버그 수정 : 때때로 열의 실제 값이 NULL 일 때 임의의 문자열이 콜백 함수에 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="e6069685c787f1f2374ad59005630cac33f83a18" translate="yes" xml:space="preserve">
          <source>Bug fix: The %c format in sqlite3_mprintf() is able to handle precisions greater than 70.</source>
          <target state="translated">버그 수정 : sqlite3_mprintf ()의 % c 형식은 70보다 큰 정밀도를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8545ae69eab7462c35ca27db0ca5feb48e882da0" translate="yes" xml:space="preserve">
          <source>Bug fix: The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; gives an exit code of 0 when terminated using the &quot;.quit&quot; command.</source>
          <target state="translated">버그 수정 : &quot;.quit&quot;명령을 사용하여 종료하면 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 종료 코드 0을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3c4dbfc44f9dd05912067f94c3eb5f1e8372f6d5" translate="yes" xml:space="preserve">
          <source>Bug fix: There was an incorrect assert() in pager.c. The real code was all correct (as far as is known) so everything should work OK if you compile with -DNDEBUG=1. When asserts are not disabled, there could be a fault.</source>
          <target state="translated">버그 수정 : pager.c에 잘못된 assert ()가있었습니다. 실제 코드는 (알고있는 한) 모두 정확하므로 -DNDEBUG = 1로 컴파일하면 모든 것이 정상적으로 작동합니다. 어설 션이 비활성화되지 않은 경우 결함이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7bd89e49a8af821827d6b028e2e799f12e2e1e" translate="yes" xml:space="preserve">
          <source>Bug fix: Updates to tables containing an INTEGER PRIMARY KEY and an index could fail.</source>
          <target state="translated">버그 수정 : INTEGER PRIMARY KEY 및 인덱스를 포함하는 테이블 업데이트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b758d1f8710d23a2038913ec37dece3bec7abf6" translate="yes" xml:space="preserve">
          <source>Bug fix: Virtual tables now handle IS NOT NULL constraints correctly.</source>
          <target state="translated">버그 수정 : 가상 테이블은 이제 IS NOT NULL 제약 조건을 올바르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="332e05b490c4cb7238853c006e2e916e2a9e4dbc" translate="yes" xml:space="preserve">
          <source>Bug fix: When a &lt;a href=&quot;lang_select#compound&quot;&gt;compound query&lt;/a&gt; that uses an ORDER BY clause with a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, make sure that the sorting occurs according to the specified collation and that the comparisons associate with the compound query use the native collation. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 와 함께 ORDER BY 절을 사용하는 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 쿼리&lt;/a&gt; 는 지정된 데이터 정렬에 따라 정렬이 수행되고 복합 쿼리와 연관된 비교가 기본 데이터 정렬을 사용하는지 확인하십시오. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/6709574d2a8d8&quot;&gt;6709574d2a8d8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cfdb97a345b3ce143f2abc5fd945ed42741b35a" translate="yes" xml:space="preserve">
          <source>Bug fix: allow a VACUUM (without segfaulting) on an empty database after setting the EMPTY_RESULT_CALLBACKS pragma.</source>
          <target state="translated">버그 수정 : EMPTY_RESULT_CALLBACKS pragma를 설정 한 후 빈 데이터베이스에서 VACUUM (segfaulting 없음)을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e76d1db13ab52fcac380bd0ae95fbf87bf5df38" translate="yes" xml:space="preserve">
          <source>Bug fix: an assertion was failing if the disk holding the database file became full or stopped accepting writes for some other reason. New tests were added to detect similar problems in the future.</source>
          <target state="translated">버그 수정 : 데이터베이스 파일을 보유한 디스크가 가득 차거나 다른 이유로 쓰기 허용을 중지하면 어설 션이 실패했습니다. 앞으로 비슷한 문제를 발견하기 위해 새로운 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f481a7837f1627a5d4384fe68dbbc8fae1d3d0ad" translate="yes" xml:space="preserve">
          <source>Bug fix: an obscure and relatively harmless bug was causing one of the tests to fail when gcc optimizations are turned on. This release fixes the problem.</source>
          <target state="translated">버그 수정 : 모호하고 비교적 무해한 버그로 인해 gcc 최적화를 켤 때 테스트 중 하나가 실패했습니다. 이 릴리스는 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="1817a2a23947bcba57e850537b31bddd01fd4808" translate="yes" xml:space="preserve">
          <source>Bug fix: correctly evaluate a view of a view without segfaulting.</source>
          <target state="translated">버그 수정 : segfaulting없이 뷰의 뷰를 올바르게 평가합니다.</target>
        </trans-unit>
        <trans-unit id="0bbfec3e6b5b062aa0e10ea3e3ec25c68f3b48e5" translate="yes" xml:space="preserve">
          <source>Bug fix: do not invoke the authorizer when reparsing the schema after a schema change.</source>
          <target state="translated">버그 수정 : 스키마 변경 후 스키마를 재분석 할 때 권한 부여자를 호출하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ff59932ad9e1623e668bc5144d9efca6daa5ff06" translate="yes" xml:space="preserve">
          <source>Bug fix: if an integer value will not fit in a 32-bit int, store it in a double instead.</source>
          <target state="translated">버그 수정 : 정수 값이 32 비트 int에 맞지 않으면 대신 double로 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="09579acd43ac94145eab3e50236de9b1df09778c" translate="yes" xml:space="preserve">
          <source>Bug fix: incorrect VDBE code was being generated for the following circumstance: a query on an indexed table containing a WHERE clause with an IN operator that had a subquery on its right-hand side.</source>
          <target state="translated">버그 수정 : 다음과 같은 상황에서 잘못된 VDBE 코드가 생성되었습니다. 오른쪽에 하위 쿼리가있는 IN 연산자가있는 WHERE 절이 포함 된 인덱스 테이블의 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="e8c1bb430eed1f84c250a2cbb94468adfcff9f43" translate="yes" xml:space="preserve">
          <source>Bug fix: prevent database corruption if you dropped a trigger that had the same name as a table.</source>
          <target state="translated">버그 수정 : 테이블과 이름이 같은 트리거를 삭제 한 경우 데이터베이스 손상을 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="77f87bfdf4072c6e0867b3768c5f7d3818056770" translate="yes" xml:space="preserve">
          <source>Bug fix: repair a long-standing problem that could cause incorrect query results in a 3-way or larger join that compared INTEGER fields against TEXT fields in two or more places. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</source>
          <target state="translated">버그 수정 : 잘못된 쿼리로 인해 INTEGER 필드와 두 개 이상의 위치에있는 TEXT 필드를 비교하는 3 방향 이상의 조인이 발생할 수있는 오랜 문제를 해결합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/fc7bd6358f&quot;&gt;fc7bd6358f&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c0e4c435db089ba66d14c6f426f1ca923c3e24a" translate="yes" xml:space="preserve">
          <source>Bug fix: the &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; function was delaying 1000 times too long before failing.</source>
          <target state="translated">버그 수정 : &lt;b&gt;sqlite_busy_timeout ()&lt;/b&gt; 함수가 실패하기 전에 1000 배 너무 오래 지연되었습니다.</target>
        </trans-unit>
        <trans-unit id="1de9526f456e5138884e0e01586b12298617b6e1" translate="yes" xml:space="preserve">
          <source>Bug fixes</source>
          <target state="translated">버그 수정</target>
        </trans-unit>
        <trans-unit id="9af1a1169b55646981d441c46e6271c5d4e76c17" translate="yes" xml:space="preserve">
          <source>Bug fixes and performance enhancements in the query optimizer</source>
          <target state="translated">쿼리 최적화 프로그램의 버그 수정 및 성능 향상</target>
        </trans-unit>
        <trans-unit id="c92ef11c871ae07b2d656ca889c918e8054c9d2e" translate="yes" xml:space="preserve">
          <source>Bug fixes and speed improvements. Improved test coverage.</source>
          <target state="translated">버그 수정 및 속도 개선 테스트 범위가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="fa58e385720020fa0c169f308e1843b2e873b0c1" translate="yes" xml:space="preserve">
          <source>Bug fixes in fts1 and fts2 modules.</source>
          <target state="translated">fts1 및 fts2 모듈의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="7084081296e3ad1cf8f7221181be2c129e0aee5c" translate="yes" xml:space="preserve">
          <source>Bug fixes in the TCL interface identified by Oleg Oleinick.</source>
          <target state="translated">Oleg Oleinick로 식별 된 TCL 인터페이스의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="e8aa6f5aee0afe8811b93445b5db21495039c63d" translate="yes" xml:space="preserve">
          <source>Bug fixes in the experimental date/time functions.</source>
          <target state="translated">실험 날짜 / 시간 기능의 버그 수정.</target>
        </trans-unit>
        <trans-unit id="b9c7777bb06388cb9dbb8f975e3fd09b2142a8c1" translate="yes" xml:space="preserve">
          <source>Bug fixes to date/time functions.</source>
          <target state="translated">날짜 / 시간 기능에 대한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="081661d86510940c54a252302be8551477973958" translate="yes" xml:space="preserve">
          <source>Bug fixes too numerous to mention (see the change log).</source>
          <target state="translated">언급하기에는 너무 많은 버그 수정 (변경 로그 참조)</target>
        </trans-unit>
        <trans-unit id="54d964bde3b45008273493e091d5fc828d1a6056" translate="yes" xml:space="preserve">
          <source>Bug fixes:</source>
          <target state="translated">버그 수정:</target>
        </trans-unit>
        <trans-unit id="a6d45e893c4329669744195bd786da10bdc76da3" translate="yes" xml:space="preserve">
          <source>Bug fixes: Correctly handle nested correlated subqueries used with indices in a WHERE clause.</source>
          <target state="translated">버그 수정 : WHERE 절에서 인덱스와 함께 사용되는 중첩 된 상관 서브 쿼리를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="24673ce72a32d2ab5eb79f34d4f1d1eb683d14be" translate="yes" xml:space="preserve">
          <source>Bug fixes: Multiple problems in the legacy query optimizer were fixed by the move to &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : 레거시 쿼리 최적화 프로그램의 여러 문제가 &lt;a href=&quot;queryplanner-ng&quot;&gt;NGQP&lt;/a&gt; 로 이동하여 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="58535f3c8aa73d70d81e761cda2cb8486c811f2f" translate="yes" xml:space="preserve">
          <source>Bugs are far less likely in SQLite than in custom-written file I/O code.</source>
          <target state="translated">버그는 사용자 정의 파일 I / O 코드보다 SQLite에서 훨씬 적습니다.</target>
        </trans-unit>
        <trans-unit id="5a61f35b0599148f4a6890e52dcef0661cb0913e" translate="yes" xml:space="preserve">
          <source>Bugs in the FTS3/4 virtual table. (The &quot;integrity-check&quot; command was original conceived as part of the test suite for FTS3/4.)</source>
          <target state="translated">FTS3 / 4 가상 테이블의 버그 &quot;무결성 검사&quot;명령은 FTS3 / 4 용 테스트 스위트의 일부로 원래 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="8f202605eb190dddba6e0719369e8fd2b96ba2d8" translate="yes" xml:space="preserve">
          <source>Build the &quot;fts5.c&quot; target. Which also creates fts5.h.</source>
          <target state="translated">&quot;fts5.c&quot;대상을 빌드하십시오. 또한 fts5.h를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="00497bbc4dcbda4f80e1ffef6721bc5a34a86a97" translate="yes" xml:space="preserve">
          <source>Building SQLite directly from individual source code files is certainly possible, but it is not recommended. For some specialized applications, it might be necessary to modify the build process in ways that cannot be done using just the prebuilt amalgamation source file downloaded from the website. For those situations, it is recommended that a customized amalgamation be built (as described &lt;a href=&quot;howtocompile#amal&quot;&gt;below&lt;/a&gt;) and used. In other words, even if a project requires building SQLite beginning with individual source files, it is still recommended that an amalgamation source file be used as an intermediate step.</source>
          <target state="translated">개별 소스 코드 파일에서 직접 SQLite를 빌드하는 것은 가능하지만 권장되지는 않습니다. 일부 특수 응용 프로그램의 경우 웹 사이트에서 다운로드 한 사전 빌드 된 합병 소스 파일을 사용하여 수행 할 수없는 방식으로 빌드 프로세스를 수정해야 할 수도 있습니다. 이러한 상황에서는 맞춤형 아말감 화 ( &lt;a href=&quot;howtocompile#amal&quot;&gt;아래&lt;/a&gt; 설명 참조 )를 만들어 사용 하는 것이 좋습니다 . 즉, 프로젝트에서 개별 소스 파일로 시작하는 SQLite를 빌드해야하더라도 여전히 합병 소스 파일을 중간 단계로 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0a71cb495d76b612c809648873b36b593c7393c1" translate="yes" xml:space="preserve">
          <source>Building a DLL</source>
          <target state="translated">DLL 작성</target>
        </trans-unit>
        <trans-unit id="280b6f6ad70e8ba6e9e400ea3d8e0a9edc8b3677" translate="yes" xml:space="preserve">
          <source>Building shared libraries for Mac OS X and Windows is not nearly so simple, unfortunately. For those platforms it is best to use the configure script and makefile that is included with the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball&lt;/a&gt;.</source>
          <target state="translated">불행히도 Mac OS X 및 Windows 용 공유 라이브러리를 구축하는 것은 그리 간단하지 않습니다. 이러한 플랫폼의 경우 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;TEA tarball에&lt;/a&gt; 포함 된 configure 스크립트 및 makefile을 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="22bc37f7023e946a78cac7bbfe5894c0db4b3f89" translate="yes" xml:space="preserve">
          <source>Building the amalgamation</source>
          <target state="translated">융합을 구축</target>
        </trans-unit>
        <trans-unit id="baa9f6c7f9720c4460c1521a23a159ddd34e81a1" translate="yes" xml:space="preserve">
          <source>Built-In Scalar SQL Functions</source>
          <target state="translated">내장 스칼라 SQL 함수</target>
        </trans-unit>
        <trans-unit id="c2d49de15987506a3eaf80acc91b361f30b458bf" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; that return the results of &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements for use within ordinary SQL queries.</source>
          <target state="translated">일반 SQL 쿼리 내에서 사용하기 위해 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문의 결과를 반환하는 내장 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78cbf7ad58abfcde67b880290a3fdb26ae265ea9" translate="yes" xml:space="preserve">
          <source>Built-in Aggregate Functions</source>
          <target state="translated">내장 집계 함수</target>
        </trans-unit>
        <trans-unit id="fb80809ef25b3a813f862af2f128324a798b2745" translate="yes" xml:space="preserve">
          <source>Built-in functions may be overloaded by new application-defined functions.</source>
          <target state="translated">내장 함수는 새로운 응용 프로그램 정의 함수에 의해 오버로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224b755bc066a07e060bb8deb0ae84ff72d8c6e6" translate="yes" xml:space="preserve">
          <source>Built-in window functions honor any PARTITION BY clause in the same way as aggregate window functions - each selected row is assigned to a partition and each partition is processed separately. The ways in which any ORDER BY clause affects each built-in window function is described below. Some of the window functions (rank(), dense_rank(), percent_rank() and ntile()) use the concept of &quot;peer groups&quot; (rows within the same partition that have the same values for all ORDER BY expressions). In these cases, it does not matter whether the frame-spec specifies ROWS, GROUPS, or RANGE. For the purposes of built-in window function processing, rows with the same values for all ORDER BY expressions are considered peers regardless of the frame type.</source>
          <target state="translated">내장 창 함수는 집계 창 함수와 동일한 방식으로 PARTITION BY 절을 준수합니다. 선택한 각 행이 파티션에 지정되고 각 파티션이 개별적으로 처리됩니다. ORDER BY 절이 각 내장 창 함수에 영향을주는 방식은 아래에 설명되어 있습니다. 일부 창 함수 (rank (), dense_rank (), percent_rank () 및 ntile ())는 &quot;피어 그룹&quot;(모든 ORDER BY 표현식에 대해 동일한 값을 갖는 동일한 파티션 내의 행) 개념을 사용합니다. 이 경우 frame-spec이 ROWS, GROUPS 또는 RANGE를 지정하는지 여부는 중요하지 않습니다. 내장 창 함수 처리를 위해 프레임 유형에 관계없이 모든 ORDER BY 표현식에 대해 동일한 값을 가진 행은 피어로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="5a25ccfc2ab6b23f400787b0cd05318c6367c6b9" translate="yes" xml:space="preserve">
          <source>Builtin window functions</source>
          <target state="translated">내장 윈도우 기능</target>
        </trans-unit>
        <trans-unit id="3fddbac5f0f5f0b32fe70d555580cce7a2b2229b" translate="yes" xml:space="preserve">
          <source>Bundle sqlite_encode_binary() and sqlite_decode_binary() with the library.</source>
          <target state="translated">라이브러리와 함께 sqlite_encode_binary () 및 sqlite_decode_binary ()를 번들하십시오.</target>
        </trans-unit>
        <trans-unit id="f637663e6355164a78b8db75eb1fc4755242d81d" translate="yes" xml:space="preserve">
          <source>Bury the dead.</source>
          <target state="translated">죽은자를 묻어 라.</target>
        </trans-unit>
        <trans-unit id="c86307059b070b415312a3a5cc51007f6e153433" translate="yes" xml:space="preserve">
          <source>But SQLite does use the declared type of a column as a hint that you prefer values in that format. So, for example, if a column is of type INTEGER and you try to insert a string into that column, SQLite will attempt to convert the string into an integer. If it can, it inserts the integer instead. If not, it inserts the string. This feature is called &lt;a href=&quot;datatype3#affinity&quot;&gt;type affinity&lt;/a&gt;.</source>
          <target state="translated">그러나 SQLite는 선언 된 유형의 열을 해당 형식의 값을 선호한다는 힌트로 사용합니다. 예를 들어, 열이 INTEGER 유형 인 경우 해당 열에 문자열을 삽입하려고하면 SQLite는 문자열을 정수로 변환하려고 시도합니다. 가능하면 정수를 대신 삽입합니다. 그렇지 않으면 문자열을 삽입합니다. 이 기능을 &lt;a href=&quot;datatype3#affinity&quot;&gt;유형 선호도&lt;/a&gt; 라고 합니다 .</target>
        </trans-unit>
        <trans-unit id="23199e0b44d24bd1ee4c96e22ea9bb3d1c2f67f4" translate="yes" xml:space="preserve">
          <source>But SQLite is built into the application. So if the data is on a separate device from the application, it is required that the higher bandwidth engine-to-disk link be across the network. This works, but it is suboptimal. Hence, it is usually better to select a client/server database engine when the data is on a separate device from the application.</source>
          <target state="translated">그러나 SQLite는 응용 프로그램에 내장되어 있습니다. 따라서 데이터가 응용 프로그램과 별도의 장치에있는 경우 더 높은 대역폭의 엔진 대 디스크 링크가 네트워크를 거쳐야합니다. 이것은 작동하지만 차선책입니다. 따라서 데이터가 응용 프로그램과 별도의 장치에있는 경우 일반적으로 클라이언트 / 서버 데이터베이스 엔진을 선택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="09ce2891d1601356f9a03f1d38be77a08462a437" translate="yes" xml:space="preserve">
          <source>But an SQLite database is not limited to a simple key/value structure like a pile-of-files database. An SQLite database can have dozens or hundreds or thousands of different tables, with dozens or hundreds or thousands of fields per table, each with different datatypes and constraints and particular meanings, all cross-referencing each other, appropriately and automatically indexed for rapid retrieval, and all stored efficiently and compactly in a single disk file. And all of this structure is succinctly documented for humans by the SQL schema.</source>
          <target state="translated">그러나 SQLite 데이터베이스는 파일 더미 데이터베이스와 같은 간단한 키 / 값 구조로 제한되지 않습니다. SQLite 데이터베이스는 테이블 당 수십 또는 수백 또는 수천 개의 서로 다른 테이블을 가질 수 있으며, 각각 테이블마다 수십 또는 수백 또는 수천 개의 필드가 있으며, 각각 서로 다른 데이터 유형 및 제약 조건 및 특정 의미를 가지며, 서로를 상호 참조하고, 빠른 검색을 위해 적절하고 자동으로 색인을 생성합니다. 하나의 디스크 파일에 효율적이고 컴팩트하게 저장됩니다. 그리고이 구조는 모두 SQL 스키마에 의해 간결하게 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d929882a8a439200f669cf52bfce1643d73dfffb" translate="yes" xml:space="preserve">
          <source>But as with any query planner change, upgrading to the NGQP does carry a small risk of introducing performance regressions. The problem here is not that the NGQP is incorrect or buggy or inferior to the legacy query planner. Given reliable information about the selectivity of indexes, the NGQP should always pick a plan that is as good or better than before. The problem is that some applications may be using low-quality and low-selectivity indexes without having run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt;. The older query planners look at many fewer possible implementations for each query and so they may have stumbled over a good plan by stupid luck. The NGQP, on the other hand, looks at many more query plan possibilities, and it may choose a different query plan that works better in theory, assuming good indexes, but which gives a performance regression in practice, because of the shape of the data.</source>
          <target state="translated">그러나 쿼리 플래너 변경과 마찬가지로 NGQP로 업그레이드해도 성능이 저하 될 위험이 적습니다. 여기서 문제는 NGQP가 잘못되었거나 버그가 있거나 레거시 쿼리 플래너보다 열등하지 않다는 것입니다. 인덱스의 선택성에 대한 신뢰할 수있는 정보가 제공되면 NGQP는 항상 이전보다 좋은 계획을 선택해야합니다. 문제는 일부 응용 프로그램이 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하지 않고 저품질 및 저 선택성 인덱스를 사용하고있을 수 있다는 것입니다. 오래된 쿼리 플래너는 각 쿼리에 대해 가능한 적은 구현을 검토하므로 어리석은 운으로 좋은 계획을 우연히 발견했을 수 있습니다. 반면에 NGQP는 더 많은 쿼리 계획 가능성을 검토하며, 좋은 인덱스를 가정 할 때 이론적으로 더 잘 작동하지만 데이터의 모양으로 인해 실제로 성능 회귀를 제공하는 다른 쿼리 계획을 선택할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="bcf6c11e8e6d47ec28df41f7ffce035dc6edbeac" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">그러나 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 데이터베이스 파일을 직접 변경하지 않기 때문에 sqlite3_stmt_readonly ()는 여전히 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="452ab026c840b3ee756da71d85f2e4c8edc72d0b" translate="yes" xml:space="preserve">
          <source>But because the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement does not change the database file directly, sqlite3_stmt_readonly() would still return true.</source>
          <target state="translated">그러나 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 데이터베이스 파일을 직접 변경하지 않기 때문에 sqlite3_stmt_readonly ()는 여전히 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ff4e39f9bba0236549d62b5ae4b68b2eb0a104f9" translate="yes" xml:space="preserve">
          <source>But database engines like SQLite are usually not this way. The SQL scripts that are passed into SQLite come from the (trusted) application itself, not from an attacker. Sometimes applications contain bugs by which an external attacker can trick the application into sending SQL of the attackers design into the database engine. This is a separate bug in the application called an &lt;a href=&quot;https://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL Injection vulnerability&lt;/a&gt;. Since SQL text is executable code, an SQL Injection vulnerability is actually a special case of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;Remote Code Execution (RCE) vulnerability&lt;/a&gt;. An SQL Injection is perhaps not quite as bad as other kinds of RCEs because, while SQL is a powerful language, it is not as convenient for crafting an exploit as Python or shell script or raw machine code. Nevertheless, an SQL Injection is a serious problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3654dae88afc03c2b5b644ec401c70beb10ac13" translate="yes" xml:space="preserve">
          <source>But does this really save time? The number of steps in the &lt;a href=&quot;#fig16&quot;&gt;original indexless sort&lt;/a&gt; is proportional to NlogN since that is how much time it takes to sort N rows. But when we use Idx1 as shown here, we have to do N rowid lookups which take logN time each, so the total time of NlogN is the same!</source>
          <target state="translated">그러나 이것이 실제로 시간을 절약합니까? &lt;a href=&quot;#fig16&quot;&gt;원래 인덱스없는 정렬&lt;/a&gt; 의 단계 수는 N 행을 정렬하는 데 걸리는 시간이므로 NlogN에 비례합니다. 그러나 여기에 표시된대로 Idx1을 사용할 때는 각각 logN 시간이 걸리는 N rowid 조회를 수행해야하므로 NlogN의 총 시간은 동일합니다!</target>
        </trans-unit>
        <trans-unit id="d6fc31d48c09d06ad4b37abcbcf5f0dce6a8ec76" translate="yes" xml:space="preserve">
          <source>But from the point of view of the VDBE, a CREATE works pretty much like an INSERT and a DROP works like a DELETE. When the SQLite library opens to an existing database, the first thing it does is a SELECT to read the &quot;sql&quot; columns from all entries of the sqlite_master table. The &quot;sql&quot; column contains the complete SQL text of the CREATE statement that originally generated the index or table. This text is fed back into the SQLite parser and used to reconstruct the internal data structures describing the index or table.</source>
          <target state="translated">그러나 VDBE의 관점에서 CREATE는 INSERT와 거의 유사하게 작동하며 DROP은 DELETE와 유사하게 작동합니다. SQLite 라이브러리가 기존 데이터베이스를 열 때 가장 먼저하는 일은 sqlite_master 테이블의 모든 항목에서 &quot;sql&quot;열을 읽는 SELECT입니다. &quot;sql&quot;열에는 원래 인덱스 또는 테이블을 생성 한 CREATE 문의 전체 SQL 텍스트가 포함됩니다. 이 텍스트는 SQLite 파서로 피드백되어 인덱스 또는 테이블을 설명하는 내부 데이터 구조를 재구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48911d596580c34107a4030f62db573e6c27c85f" translate="yes" xml:space="preserve">
          <source>But if SQLite wants to access a page of the database file and memory mapped I/O is enabled, it first calls the xFetch() method. The xFetch() method asks the operating system to return a pointer to the requested page, if possible. If the requested page has been or can be mapped into the application address space, then xFetch returns a pointer to that page for SQLite to use without having to copy anything. Skipping the copy step is what makes memory mapped I/O faster.</source>
          <target state="translated">그러나 SQLite가 데이터베이스 파일의 페이지에 액세스하려고하고 메모리 매핑 된 I / O가 활성화 된 경우 먼저 xFetch () 메서드를 호출합니다. xFetch () 메소드는 가능한 경우 운영 체제에 요청 된 페이지에 대한 포인터를 리턴하도록 요청합니다. 요청 된 페이지가 응용 프로그램 주소 공간에 맵핑되었거나 맵핑 될 수있는 경우, xFetch는 아무것도 복사하지 않고 SQLite가 사용할 페이지에 대한 포인터를 리턴합니다. 복사 단계를 건너 뛰면 메모리 매핑 I / O가 더 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="29180962652da325c9c8e705d40a3befafb60fff" translate="yes" xml:space="preserve">
          <source>But if a hacker is able to run arbitrary SQL, he might run a slightly different query, like this:</source>
          <target state="translated">그러나 해커가 임의의 SQL을 실행할 수 있으면 다음과 같이 약간 다른 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42f14da1dea8e44296cffda380cd3db71f9a44b1" translate="yes" xml:space="preserve">
          <source>But if an attacker can already run arbitrary SQL, they do not need a bug to cause a denial of service. There are plenty of perfectly legal and valid SQL statements that will consume unlimited CPU, memory, and disk I/O in order to create a denial-of-service without requiring help from bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="560c7f07ebe8e7827f02303fd33e3696ffc6d5d9" translate="yes" xml:space="preserve">
          <source>But if the</source>
          <target state="translated">그러나</target>
        </trans-unit>
        <trans-unit id="a0cdbfa12f5d3945de1878cd75d88dc29371bd31" translate="yes" xml:space="preserve">
          <source>But if the EMPTY_RESULT_CALLBACKS pragma is ON, then the following is returned:</source>
          <target state="translated">그러나 EMPTY_RESULT_CALLBACKS pragma가 ON이면 다음이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3b2f2e220bf3a85ffdbd93e68cd80fcba741ecfe" translate="yes" xml:space="preserve">
          <source>But if the case_sensitive_like pragma is enabled as follows:</source>
          <target state="translated">그러나 case_sensitive_like pragma가 다음과 같이 사용 가능한 경우 :</target>
        </trans-unit>
        <trans-unit id="917ffdb9308404a9f9ecbb2338ae37ba101af829" translate="yes" xml:space="preserve">
          <source>But if the i-th parameter is NULL we will get:</source>
          <target state="translated">그러나 i 번째 매개 변수가 NULL이면 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="418b21f56edf736ac615f67f52f5ff8cd5de8694" translate="yes" xml:space="preserve">
          <source>But if we change the ORDER BY clause to add the &quot;DESC&quot; modifier, that will cause lower levels in the organization (with larger &quot;level&quot; values) to be processed first by the recursive-select, resulting in a depth-first search:</source>
          <target state="translated">그러나 ORDER BY 절을 변경하여 &quot;DESC&quot;수정자를 추가하면 조직의 하위 수준 (더 큰 &quot;수준&quot;값)이 재귀 선택에 의해 먼저 처리되어 깊이 우선 검색이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b73aaf5e4e2de9f2adc91308c0011207fcb7df2b" translate="yes" xml:space="preserve">
          <source>But in a coverage measuring build, the &lt;code&gt;testcase()&lt;/code&gt; macro generates code that evaluates the conditional expression in its argument. Then during analysis, a check is made to ensure tests exist that evaluate the conditional to both true and false. &lt;code&gt;Testcase()&lt;/code&gt; macros are used, for example, to help verify that boundary values are tested. For example:</source>
          <target state="translated">그러나 커버리지 측정 빌드에서 &lt;code&gt;testcase()&lt;/code&gt; 매크로는 인수에서 조건식을 평가하는 코드를 생성합니다. 그런 다음 분석 중에 조건부 참과 거짓 모두를 평가하는 테스트가 존재하는지 확인합니다. 예를 들어 &lt;code&gt;Testcase()&lt;/code&gt; 매크로는 경계 값이 테스트되는지 확인하는 데 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6cba989629259efaf3551fd795674dc99bb4d48d" translate="yes" xml:space="preserve">
          <source>But in the following logically equivalent formulation of the same query, the substitution of &quot;CROSS JOIN&quot; for the &quot;,&quot; means that the order of tables must be N1, E, N2.</source>
          <target state="translated">그러나 동일한 쿼리의 다음과 같은 논리적으로 동등한 공식에서 &quot;,&quot;에 대한 &quot;CROSS JOIN&quot;의 대체는 테이블 순서가 N1, E, N2 여야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2a172174425039b0a04cf59d0c65f9b7b37ef450" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">그러나 &quot;.tables&quot;명령은 더 많은 일을합니다. 기본 데이터베이스뿐만 아니라 &lt;a href=&quot;lang_attach&quot;&gt;연결된&lt;/a&gt; 모든 데이터베이스에 대해 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 테이블을 쿼리 합니다. 그리고 출력을 깔끔한 열로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="07070136c4e43ff98642891d2498eeab4c61ffd9" translate="yes" xml:space="preserve">
          <source>But the &quot;.tables&quot; command does more. It queries the sqlite_master table for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases, not just the primary database. And it arranges its output into neat columns.</source>
          <target state="translated">그러나 &quot;.tables&quot;명령은 더 많은 작업을 수행합니다. 기본 데이터베이스뿐만 아니라 &lt;a href=&quot;lang_attach&quot;&gt;연결된&lt;/a&gt; 모든 데이터베이스에 대해 sqlite_master 테이블을 쿼리 합니다. 그리고 출력을 깔끔한 열로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="cc1b6b83457a776880f02cbe1ed99910a24b8fb2" translate="yes" xml:space="preserve">
          <source>But the following declaration does not result in &quot;x&quot; being an alias for the rowid:</source>
          <target state="translated">그러나 다음 선언으로 인해 &quot;x&quot;가 rowid의 별칭이되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d13a39c7ff19d1a4a67287041174bb7cee527dd" translate="yes" xml:space="preserve">
          <source>But the next query can not use the partial index:</source>
          <target state="translated">그러나 다음 쿼리는 부분 인덱스를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4968c094e6119e8a687db966e94b26bef2ebe4a4" translate="yes" xml:space="preserve">
          <source>But the use of subtypes does nothing to prevent the value of a pointer from being read using SQL code like this:</source>
          <target state="translated">그러나 하위 유형을 사용하면 다음과 같은 SQL 코드를 사용하여 포인터 값을 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6310277e9a108b401d7850bc8ffad69350ce478c" translate="yes" xml:space="preserve">
          <source>But there are also disadvantages:</source>
          <target state="translated">그러나 단점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1e940122523fbd2f68feec81164dcb25704b65b" translate="yes" xml:space="preserve">
          <source>But those routines are optional can can be omitted using a &lt;a href=&quot;compile#zero_malloc&quot;&gt;compile-time option&lt;/a&gt;.</source>
          <target state="translated">그러나 이러한 루틴은 선택 사항이며 &lt;a href=&quot;compile#zero_malloc&quot;&gt;컴파일 타임 옵션을&lt;/a&gt; 사용하여 생략 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b843ee326d7f7cdf5b63dd9bf52bb27bf7756e78" translate="yes" xml:space="preserve">
          <source>But what value to choose for N? One might try N=K. This makes the algorithm O(K&lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt;) which is actually still quite efficient, since the maximum value of K is 64 and K rarely exceeds 10. But that is not enough for the TPC-H Q8 problem. With N=8 on TPC-H Q8 the N3 algorithm finds the solution R-N1-C-O-L-S-N2-P with a cost of 29.78. That is a big improvement over NN, but it is still not optimal. N3 finds the optimal solution for TPC-H Q8 when N is 10 or greater.</source>
          <target state="translated">그러나 N은 어떤 가치를 선택해야할까요? N = K를 시도 할 수 있습니다. K 의 최대 값이 64이고 K가 거의 10을 초과하지 않기 때문에 알고리즘 O (K &lt;small&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/small&gt; )는 실제로 여전히 매우 효율적입니다. 그러나 TPC-H Q8 문제에는 충분하지 않습니다. TPC-H Q8에서 N = 8 인 N3 알고리즘은 29.78의 비용으로 솔루션 R-N1-COLS-N2-P를 찾습니다. 이는 NN에 비해 크게 개선되었지만 여전히 최적은 아닙니다. N3은 N이 10 이상인 경우 TPC-H Q8에 대한 최적의 솔루션을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="65129801103eda08bf342c707b068d5b768e6daf" translate="yes" xml:space="preserve">
          <source>But with SQLite, 200 or more SQL statement per webpage is not a problem.</source>
          <target state="translated">그러나 SQLite를 사용하면 웹 페이지 당 200 개 이상의 SQL 문이 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36f51675b3471666e7cff23ca3ceb542e736b084" translate="yes" xml:space="preserve">
          <source>But, generally speaking, the more constraints that the R*Tree module has to work with, and the smaller the bounding box, the faster the results will come back.</source>
          <target state="translated">그러나 일반적으로 R * Tree 모듈이 처리해야하는 제약 조건이 많을수록 경계 상자가 작을수록 결과가 더 빨리 나타납니다.</target>
        </trans-unit>
        <trans-unit id="bb3dd504a4ceaa15395efbf567f6c35a7b699cba" translate="yes" xml:space="preserve">
          <source>By &quot;static string&quot;, we mean a zero-terminated array of bytes that is fixed and unchanging for the life of the program. In other words, the pointer type string should be a string constant. In contrast, a &quot;dynamic string&quot; is a zero-terminated array of bytes that is held in memory allocated from the heap, and which must be freed to avoid a memory leak. Do not use dynamic strings as the pointer type string.</source>
          <target state="translated">&quot;정적 문자열&quot;은 프로그램 수명 동안 고정되고 변경되지 않는 0으로 끝나는 바이트 배열을 의미합니다. 즉, 포인터 유형 문자열은 문자열 상수 여야합니다. 반대로, &quot;동적 문자열&quot;은 힙에서 할당 된 메모리에 보유되는 0으로 끝나는 바이트 배열이며 메모리 누수를 방지하기 위해 해제되어야합니다. 동적 문자열을 포인터 유형 문자열로 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="f606d9b23ace8996276bde7ccd24b4d280a3c7c4" translate="yes" xml:space="preserve">
          <source>By adding multiple synonyms for a single term to the FTS index. Using this method, when tokenizing document text, the tokenizer provides multiple synonyms for each token. So that when a document such as &quot;I won first place&quot; is tokenized, entries are added to the FTS index for &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot; and &quot;place&quot;.</source>
          <target state="translated">단일 용어에 대한 여러 동의어를 FTS 색인에 추가합니다. 이 방법을 사용하면 문서 텍스트를 토큰화할 때 토크 나이 저는 각 토큰에 대해 여러 동의어를 제공합니다. 따라서 &quot;I won first place&quot;와 같은 문서가 토큰 화되면 &quot;i&quot;, &quot;won&quot;, &quot;first&quot;, &quot;1st&quot;및 &quot;place&quot;에 대한 항목이 FTS 색인에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="80b3f84643451df0998b16a1d70d04019fc8e45c" translate="yes" xml:space="preserve">
          <source>By combining location data and related information into the same table, auxiliary columns can provide a cleaner model and reduce the need to joins. For example, the earlier &lt;a href=&quot;#diquery&quot;&gt;join between demo_index and demo_data&lt;/a&gt; can now be written as a simple query, like this:</source>
          <target state="translated">보조 열은 위치 데이터와 관련 정보를 동일한 테이블로 결합하여보다 깔끔한 모델을 제공하고 조인 필요성을 줄일 수 있습니다. 예를 들어, &lt;a href=&quot;#diquery&quot;&gt;demo_index와 demo_data 사이&lt;/a&gt; 의 이전 조인 은 이제 다음과 같이 간단한 쿼리로 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e37637c9870320bdf8cbf8ef62058290a2f74da5" translate="yes" xml:space="preserve">
          <source>By configuring a callback to be invoked the first time each table is written to that indicates to the session module whether or not changes on the table should be monitored.</source>
          <target state="translated">각 테이블이 처음 기록 될 때 호출되도록 콜백을 구성하여 테이블의 변경 사항을 모니터해야하는지 여부를 세션 모듈에 표시합니다.</target>
        </trans-unit>
        <trans-unit id="06b847c7709546cccdb0e536dbda4965ee6a96e1" translate="yes" xml:space="preserve">
          <source>By contrast, if foreign key errors can be recognized simply by looking at the definition of the child table and without having to consult the parent table definition, then the &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement for the child table fails. Because the error occurs during a schema change, this is a DDL error. Foreign key DDL errors are reported regardless of whether or not foreign key constraints are enabled when the table is created.</source>
          <target state="translated">반대로, 자식 테이블의 정의를보고 부모 테이블 정의를 참조하지 않고 외래 키 오류를 쉽게 인식 할 수 있으면 자식 테이블의 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문이 실패합니다. 스키마 변경 중에 오류가 발생하기 때문에 이는 DDL 오류입니다. 외래 키 DDL 오류는 테이블을 만들 때 외래 키 제약 조건의 활성화 여부에 관계없이보고됩니다.</target>
        </trans-unit>
        <trans-unit id="aedeaa844f352e8e17d5cb589064ea1e4109a539" translate="yes" xml:space="preserve">
          <source>By default a session object does not monitor changes on any database table. Before it does so it must be configured. There are three ways to configure the set of tables to monitor changes on:</source>
          <target state="translated">기본적으로 세션 오브젝트는 데이터베이스 테이블의 변경 사항을 모니터하지 않습니다. 그렇게하기 전에 반드시 구성해야합니다. 변경 사항을 모니터하도록 테이블 세트를 구성하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="55442bbcc7ceaf84de94fa28a3aed619ae9955e0" translate="yes" xml:space="preserve">
          <source>By default, &quot;unicode61&quot; attempts to remove diacritics from Latin script characters. This behaviour can be overridden by adding the tokenizer argument &quot;remove_diacritics=0&quot;. For example:</source>
          <target state="translated">기본적으로 &quot;unicode61&quot;은 라틴 스크립트 문자에서 분음 부호를 제거하려고 시도합니다. 토크 나이저 인수 &quot;remove_diacritics = 0&quot;을 추가하면이 동작을 무시할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7302d3f42259627d0861634979d66a761d287cd5" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 는 비 결정적인 것으로 간주됩니다. 그러나 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 ()에&lt;/a&gt; 대한 네 번째 매개 변수 가 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 과 OR로 연결 되면 SQLite는 해당 함수를 결정적인 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="be3a7476bfd030e836d226174214b4408b10de5a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; are considered to be non-deterministic. However, if the 4th parameter to &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; is OR-ed with &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt;, then SQLite will treat that function as if it were deterministic.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 는 비 결정적인 것으로 간주됩니다. 그러나 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 ()&lt;/a&gt; 의 네 번째 매개 변수 가 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC으로&lt;/a&gt; OR-ed 인 경우 SQLite는 해당 함수를 결정적인 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="53685ae8370637562174590d6e02187741d1cecd" translate="yes" xml:space="preserve">
          <source>By default, ANALYZE does a full scan of every index. This can be slow for large databases. So beginning with SQLite version 3.32.0 (2020-05-22), the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; command can be used to limit the amount of scanning performed by ANALYZE, and thus help ANALYZE to run faster, even on very large database files. We call this running an &quot;approximate ANALYZE&quot;.</source>
          <target state="translated">기본적으로 ANALYZE는 모든 인덱스의 전체 스캔을 수행합니다. 대규모 데이터베이스의 경우 속도가 느릴 수 있습니다. 따라서 SQLite 버전 3.32.0 (2020-05-22)부터 &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; 명령을 사용하여 ANALYZE가 수행하는 검색 양을 제한 할 수 있으므로 매우 큰 데이터베이스 파일에서도 ANALYZE를 더 빠르게 실행할 수 있습니다. 이를 &quot;대략적인 분석&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="78cc7d781eb449f29366e3574bdcdf238af76b02" translate="yes" xml:space="preserve">
          <source>By default, FTS queries (those that use the MATCH operator) consider only those rows with the languageid column set to 0. To query for rows with other languageid values, a constraint of the form &quot;</source>
          <target state="translated">기본적으로 FTS 쿼리 (MATCH 연산자를 사용하는 쿼리)는 languageid 열이 0으로 설정된 행만 고려합니다. 다른 languageid 값이있는 행을 쿼리하려면 &quot;</target>
        </trans-unit>
        <trans-unit id="a4ce99b6ecd6b9193290236a519a16ace8c29ade" translate="yes" xml:space="preserve">
          <source>By default, FTS3/4 occasionally merges together two or more of the b-trees that make up its full-text index within an INSERT, UPDATE or DELETE statement executed by the user. This means that any operation on an FTS3/4 table may turn out to be surprisingly slow, as FTS3/4 may unpredictably choose to merge together two or more large b-trees within it. FTS5 uses incremental merging by default, which limits the amount of processing that may take place within any given INSERT, UPDATE or DELETE operation.</source>
          <target state="translated">기본적으로 FTS3 / 4는 때때로 사용자가 실행하는 INSERT, UPDATE 또는 DELETE 문 내에서 전체 텍스트 인덱스를 구성하는 둘 이상의 b- 트리를 병합합니다. 즉, FTS3 / 4가 예상치 못하게 두 개 이상의 큰 b- 트리를 함께 병합하도록 선택할 수 있으므로 FTS3 / 4 테이블의 작업이 놀랍게도 느려질 수 있습니다. FTS5는 기본적으로 증분 병합을 사용하여 지정된 INSERT, UPDATE 또는 DELETE 작업 내에서 발생할 수있는 처리량을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="f6e0aaa9f2f3d9d7bf351208161c2a3a5ac7e955" translate="yes" xml:space="preserve">
          <source>By default, FTS5 full-text searches are case-independent. Like any other SQL query that does not contain an ORDER BY clause, the example above returns results in an arbitrary order. To sort results by relevance (most to least relevant), an ORDER BY may be added to a full-text query as follows:</source>
          <target state="translated">기본적으로 FTS5 전체 텍스트 검색은 대소 문자를 구분하지 않습니다. ORDER BY 절을 포함하지 않는 다른 SQL 쿼리와 마찬가지로 위의 예는 임의의 순서로 결과를 반환합니다. 관련성에 따라 (가장 관련성이 높거나 가장 낮은) 결과를 정렬하기 위해 ORDER BY를 다음과 같이 전체 텍스트 쿼리에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bae9dce645a20ac5b291708dfb54aa225ce0774" translate="yes" xml:space="preserve">
          <source>By default, FTS5 maintains a single index recording the location of each token instance within the document set. This means that querying for complete tokens is fast, as it requires a single lookup, but querying for a prefix token can be slow, as it requires a range scan. For example, to query for the prefix token &quot;abc*&quot; requires a range scan of all tokens greater than or equal to &quot;abc&quot; and less than &quot;abd&quot;.</source>
          <target state="translated">기본적으로 FTS5는 문서 세트 내에서 각 토큰 인스턴스의 위치를 ​​기록하는 단일 인덱스를 유지합니다. 즉, 단일 조회가 필요하므로 완전한 토큰에 대한 쿼리가 빠르지 만 범위 스캔이 필요하므로 접두사 토큰에 대한 쿼리가 느려질 수 있습니다. 예를 들어, 접두사 토큰 &quot;abc *&quot;를 쿼리하려면 &quot;abc&quot;이상 &quot;abd&quot;보다 작은 모든 토큰의 범위 스캔이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ff82a6b03b77139ee1bba47d5624340bd5b1daef" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that all data uses a fixed-size 8-bit character (iso8859). But if you give the --enable-utf8 option to the configure script, then the library assumes UTF-8 variable sized characters. This makes a difference for the LIKE and GLOB operators and the LENGTH() and SUBSTR() functions. The static string &lt;b&gt;sqlite_encoding&lt;/b&gt; will be set to either &quot;UTF-8&quot; or &quot;iso8859&quot; to indicate how the library was compiled. In addition, the &lt;b&gt;sqlite.h&lt;/b&gt; header file will define one of the macros &lt;b&gt;SQLITE_UTF8&lt;/b&gt; or &lt;b&gt;SQLITE_ISO8859&lt;/b&gt;, as appropriate.</source>
          <target state="translated">기본적으로 SQLite는 모든 데이터가 고정 크기 8 비트 문자 (iso8859)를 사용한다고 가정합니다. 그러나 --enable-utf8 옵션을 configure 스크립트에 제공하면 라이브러리는 UTF-8 가변 크기 문자를 가정합니다. 이는 LIKE 및 GLOB 연산자와 LENGTH () 및 SUBSTR () 함수에 차이를 만듭니다. 정적 문자열 &lt;b&gt;sqlite_encoding&lt;/b&gt; 은 &quot;UTF-8&quot;또는 &quot;iso8859&quot;로 설정되어 라이브러리 컴파일 방법을 나타냅니다. 또한 &lt;b&gt;sqlite.h&lt;/b&gt; 헤더 파일은 적절하게 매크로 &lt;b&gt;SQLITE_UTF8&lt;/b&gt; 또는 &lt;b&gt;SQLITE_ISO8859&lt;/b&gt; 중 하나를 정의 합니다.</target>
        </trans-unit>
        <trans-unit id="cbc8ea1232230a6d65d66bdbfc39e47fe8c9edc5" translate="yes" xml:space="preserve">
          <source>By default, SQLite assumes that an operating system call to write a range of bytes will not damage or alter any bytes outside of that range even if a power loss or OS crash occurs during that write. We call this the &quot;&lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt;&quot; property. Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01), SQLite did not assume powersafe overwrite. But with the standard sector size increasing from 512 to 4096 bytes on most disk drives, it has become necessary to assume powersafe overwrite in order to maintain historical performance levels and so powersafe overwrite is assumed by default in recent versions of SQLite. The assumption of powersafe overwrite property can be disabled at compile-time or a run-time if desired. See the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite documentation&lt;/a&gt; for further details.</source>
          <target state="translated">기본적으로 SQLite는 쓰기 중 전원 손실이나 OS 충돌이 발생하더라도 바이트 범위를 작성하기위한 운영 체제 호출이 해당 범위 밖의 바이트를 손상 시키거나 변경하지 않는다고 가정합니다. 이것을 &quot; &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; &quot;속성이라고합니다. &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;버전 3.7.9&lt;/a&gt; (2011-11-01) 이전에는 SQLite가 전원 안전 덮어 쓰기를 가정하지 않았습니다. 그러나 대부분의 디스크 드라이브에서 표준 섹터 크기가 512 바이트에서 4096 바이트로 증가함에 따라 기록 성능 수준을 유지하기 위해 전원 안전 덮어 쓰기를 가정해야하므로 최신 버전의 SQLite에서는 기본적으로 전원 안전 덮어 쓰기가 가정됩니다. powersafe 덮어 쓰기 속성의 가정은 컴파일 타임 또는 원하는 경우 런타임에 비활성화 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;psow&quot;&gt;powersafe 덮어 쓰기 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f018eca355fa9ae5d020ba88bd8ea21f258703c5" translate="yes" xml:space="preserve">
          <source>By default, SQLite does a checkpoint automatically when the WAL file reaches a threshold size of 1000 pages. (The &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; compile-time option can be used to specify a different default.) Applications using WAL do not have to do anything in order to for these checkpoints to occur. But if they want to, applications can adjust the automatic checkpoint threshold. Or they can turn off the automatic checkpoints and run checkpoints during idle moments or in a separate thread or process.</source>
          <target state="translated">기본적으로 SQLite는 WAL 파일이 임계 값 크기 인 1000 페이지에 도달하면 자동으로 검사 점을 수행합니다. 합니다 ( &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; WAL를 사용하여 컴파일시 옵션이 다른 기본을 지정할 수 있습니다.) 응용 프로그램은 이러한 체크 포인트가 발생하기에 위해 아무것도 할 필요가 없습니다. 그러나 원하는 경우 응용 프로그램에서 자동 검사 점 임계 값을 조정할 수 있습니다. 또는 유휴 순간이나 별도의 스레드 또는 프로세스에서 자동 검사 점을 끄고 검사 점을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c47d73038962ba3e0484234ad47892e41a6eccb3" translate="yes" xml:space="preserve">
          <source>By default, SQLite keeps statistics on its memory usage. These statistics are useful in helping to determine how much memory an application really needs. The statistics can also be used in high-reliability system to determine if the memory usage is coming close to or exceeding the limits of the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; and hence that the memory allocation subsystem is liable to breakdown.</source>
          <target state="translated">기본적으로 SQLite는 메모리 사용량에 대한 통계를 유지합니다. 이 통계는 응용 프로그램에 실제로 필요한 메모리 양을 결정하는 데 도움이됩니다. 통계는 메모리 사용량이 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson 증명&lt;/a&gt; 의 한계에 근접하거나이를 초과하는지 여부를 판별하기 위해 고 신뢰성 시스템에서 사용될 수 있으며 , 따라서 메모리 할당 서브 시스템이 고장날 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="45a42d60e1bd3a274255ba5930fab23192de66e7" translate="yes" xml:space="preserve">
          <source>By default, SQLite obtains the memory it needs for objects and cache from the malloc()/free() implementation of the standard library. There is also on-going work with experimental memory allocators that satisfy all memory requests from a single fixed memory buffer handed to SQLite at application start. Additional information on these experimental memory allocators will be provided in a future revision of this document.</source>
          <target state="translated">기본적으로 SQLite는 표준 라이브러리의 malloc () / free () 구현에서 객체 및 캐시에 필요한 메모리를 얻습니다. 또한 응용 프로그램 시작시 SQLite로 전달 된 단일 고정 메모리 버퍼에서 모든 메모리 요청을 만족시키는 실험용 메모리 할당 자에 대한 작업도 진행 중입니다. 이 실험 메모리 할당 자에 대한 추가 정보는이 문서의 향후 개정판에서 제공 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1f4239650661b10de63616260d0037b2cc6746e" translate="yes" xml:space="preserve">
          <source>By default, SQLite uses the malloc(), realloc(), and free() routines from the standard C library for its memory allocation needs. These routines are surrounded by a thin wrapper that also provides a &quot;memsize()&quot; function that will return the size of an existing allocation. The memsize() function is needed to keep an accurate count of the number of bytes of outstanding memory; memsize() determines how many bytes to remove from the outstanding count when an allocation is freed. The default allocator implements memsize() by always allocating 8 extra bytes on each malloc() request and storing the size of the allocation in that 8-byte header.</source>
          <target state="translated">기본적으로 SQLite는 메모리 할당 요구에 표준 C 라이브러리의 malloc (), realloc () 및 free () 루틴을 사용합니다. 이러한 루틴은 얇은 래퍼로 둘러싸여 있으며 기존 할당의 크기를 반환하는 &quot;memsize ()&quot;함수도 제공합니다. 미해결 메모리의 바이트 수를 정확하게 계산하려면 memsize () 함수가 필요합니다. memsize ()는 할당이 해제 될 때 미해결 카운트에서 제거 할 바이트 수를 결정합니다. 기본 할당자는 각 malloc () 요청에 항상 8 개의 추가 바이트를 할당하고 해당 8 바이트 헤더에 할당 크기를 저장하여 memsize ()를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ac7bf7e7f400c7dac01c89761055dce039c96113" translate="yes" xml:space="preserve">
          <source>By default, SQLite will automatically checkpoint whenever a &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; occurs that causes the WAL file to be 1000 pages or more in size, or when the last database connection on a database file closes. The default configuration is intended to work well for most applications. But programs that want more control can force a checkpoint using the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The automatic checkpoint threshold can be changed or automatic checkpointing can be completely disabled using the &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma&lt;/a&gt; or by calling the &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint()&lt;/a&gt; C interface. A program can also use &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt; to register a callback to be invoked whenever any transaction commits to the WAL. This callback can then invoke &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; based on whatever criteria it thinks is appropriate. (The automatic checkpoint mechanism is implemented as a simple wrapper around &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook()&lt;/a&gt;.)</source>
          <target state="translated">기본적으로 SQLite는 &lt;a href=&quot;lang_transaction&quot;&gt;COMAL이&lt;/a&gt; 발생할 때마다 WAL 파일의 크기가 1000 페이지 이상이되거나 데이터베이스 파일의 마지막 데이터베이스 연결이 닫힐 때 자동으로 검사 점을 검사 합니다. 기본 구성은 대부분의 응용 프로그램에 적합합니다. 그러나 더 많은 제어를 원하는 프로그램은 &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C 인터페이스를 호출 하여 검사 점을 강제 실행할 수 있습니다. &lt;a href=&quot;pragma#pragma_wal_autocheckpoint&quot;&gt;wal_autocheckpoint pragma를 사용&lt;/a&gt; 하거나 &lt;a href=&quot;c3ref/wal_autocheckpoint&quot;&gt;sqlite3_wal_autocheckpoint ()&lt;/a&gt; C 인터페이스를 호출하여 자동 검사 점 임계 값을 변경하거나 자동 검사 점을 완전히 비활성화 할 수 있습니다 . 프로그램은 &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()을&lt;/a&gt; 사용할 수도 있습니다트랜잭션이 WAL에 커밋 될 때마다 호출 할 콜백을 등록합니다. 이 콜백 은 적절하다고 생각하는 기준에 따라 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 를 호출 할 수 있습니다 . (자동 체크 포인트 메커니즘은 &lt;a href=&quot;c3ref/wal_hook&quot;&gt;sqlite3_wal_hook ()&lt;/a&gt; 주위에 간단한 래퍼로 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="dfe31588b0add6c729f8eab371bfea7925cb6297" translate="yes" xml:space="preserve">
          <source>By default, VACUUM only works only on the main database. &lt;a href=&quot;lang_attach&quot;&gt;Attached databases&lt;/a&gt; can be vacuumed by appending the appropriate schema-name to the VACUUM statement.</source>
          <target state="translated">기본적으로 VACUUM은 기본 데이터베이스에서만 작동합니다. VACUUM 문에 적절한 스키마 이름을 추가하여 &lt;a href=&quot;lang_attach&quot;&gt;연결된 데이터베이스&lt;/a&gt; 를 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="609f717a6d90d2816632d1db2908a5d9109c172f" translate="yes" xml:space="preserve">
          <source>By default, coordinates are stored in an R*Tree using 32-bit floating point values. When a coordinate cannot be exactly represented by a 32-bit floating point number, the lower-bound coordinates are rounded down and the upper-bound coordinates are rounded up. Thus, bounding boxes might be slightly larger than specified, but will never be any smaller. This is exactly what is desired for doing the more common &quot;overlapping&quot; queries where the application wants to find every entry in the R*Tree that overlaps a query bounding box. Rounding the entry bounding boxes outward might cause a few extra entries to appears in an overlapping query if the edge of the entry bounding box corresponds to an edge of the query bounding box. But the overlapping query will never miss a valid table entry.</source>
          <target state="translated">기본적으로 좌표는 32 비트 부동 소수점 값을 사용하여 R * Tree에 저장됩니다. 좌표가 32 비트 부동 소수점 숫자로 정확하게 표현 될 수없는 경우 하한 좌표는 내림되고 상한 좌표는 내림됩니다. 따라서 경계 상자는 지정된 것보다 약간 클 수 있지만 더 작을 수는 없습니다. 응용 프로그램이 쿼리 경계 상자와 겹치는 R * Tree의 모든 항목을 찾으려는 일반적인 &quot;중복&quot;쿼리를 수행하는 데 필요한 것입니다. 항목 경계 상자를 바깥쪽으로 반올림하면 항목 경계 상자의 가장자리가 쿼리 경계 상자의 가장자리에 해당하는 경우 겹치는 쿼리에 몇 가지 추가 항목이 나타날 수 있습니다. 그러나 겹치는 쿼리는 유효한 테이블 항목을 절대 놓치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="199efd35071a0aa576610e8f4fe7005becc87773" translate="yes" xml:space="preserve">
          <source>By default, diacritics are removed from all Latin script characters. This means, for example, that &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot; and &quot;&amp;acirc;&quot; are all considered to be equivalent.</source>
          <target state="translated">기본적으로 분음 부호는 모든 라틴 스크립트 문자에서 제거됩니다. 예를 들어 &quot;A&quot;, &quot;a&quot;, &quot;&amp;Agrave;&quot;, &quot;&amp;agrave;&quot;, &quot;&amp;Acirc;&quot;및 &quot;&amp;acirc;&quot;는 모두 동등한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="bb034dd2f0250c21e84e164917272d1dc5842d40" translate="yes" xml:space="preserve">
          <source>By default, differences in the schema or content of virtual tables are not reported on.</source>
          <target state="translated">기본적으로 가상 테이블의 스키마 또는 내용의 차이는보고되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b77f26d39d106302cf0e476c578f7ebf5e3ef7c7" translate="yes" xml:space="preserve">
          <source>By default, each INSERT statement is its own transaction. But if you surround multiple INSERT statements with &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;...&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; then all the inserts are grouped into a single transaction. The time needed to commit the transaction is amortized over all the enclosed insert statements and so the time per insert statement is greatly reduced.</source>
          <target state="translated">기본적으로 각 INSERT 문은 자체 트랜잭션입니다. 그러나 여러 개의 INSERT 문을 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; ... &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 로 둘러싸면 모든 삽입이 단일 트랜잭션으로 그룹화됩니다. 트랜잭션을 커밋하는 데 필요한 시간은 동봉 된 모든 insert 문에서 상각되므로 insert 문당 시간이 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6a7a241c9fa980ec6fabd179e76034fe7898c1e2" translate="yes" xml:space="preserve">
          <source>By default, each column is between 1 and 10 characters wide, depending on the column header name and the width of the first column of data. Data that is too wide to fit in a column is truncated. Use the &quot;.width&quot; dot-command to adjust column widths, like this:</source>
          <target state="translated">기본적으로 각 열은 열 머리글 이름과 첫 번째 데이터 열의 너비에 따라 1-10 자 사이입니다. 열에 맞지 않는 너무 넓은 데이터는 잘립니다. &quot;.width&quot;도트 명령을 사용하여 다음과 같이 열 너비를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="5e4318cdb175f91c3caf7375a2080f232459374d" translate="yes" xml:space="preserve">
          <source>By default, every row in SQLite has a special column, usually called the &quot;&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt;&quot;, that uniquely identifies that row within the table. However if the phrase &quot;WITHOUT ROWID&quot; is added to the end of a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement, then the special &quot;rowid&quot; column is omitted. There are sometimes space and performance advantages to omitting the rowid.</source>
          <target state="translated">기본적으로 SQLite의 모든 행에는 일반적으로 테이블에서 해당 행을 고유하게 식별 하는 특수한 열 (일반적으로 &quot; &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; &quot;)이 있습니다. 그러나 &quot;WITHOUT ROWID&quot;구가 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문의 끝에 추가 되면 특수 &quot;rowid&quot;열이 생략됩니다. rowid를 생략하면 공간 및 성능 이점이있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6ef17af0abc70adef74ccbccb6e7ada9c1f618f" translate="yes" xml:space="preserve">
          <source>By default, kvtest runs the database I/O measurements all within a single transaction. Use the --multitrans option to run each blob read or write in a separate transaction. The --multitrans option makes SQLite much slower, and uncompetitive with direct disk I/O. This option proves, yet again, that to get the most performance out of SQLite, you should group as much database interaction as possible within a single transaction.</source>
          <target state="translated">기본적으로 kvtest는 단일 트랜잭션 내에서 데이터베이스 I / O 측정을 모두 실행합니다. --multitrans 옵션을 사용하여 각 블롭 읽기 또는 쓰기를 별도의 트랜잭션으로 실행하십시오. --multitrans 옵션은 직접 디스크 I / O와 함께 SQLite를 훨씬 느리게하고 비 경쟁적으로 만듭니다. 이 옵션은 SQLite를 최대한 활용하려면 단일 트랜잭션 내에서 가능한 많은 데이터베이스 상호 작용을 그룹화해야한다는 것을 다시 한 번 입증합니다.</target>
        </trans-unit>
        <trans-unit id="a027e685d0b82e63c37ab615c6c8b1bef894cf6d" translate="yes" xml:space="preserve">
          <source>By default, sqldiff attempts to process all non-virtual tables within the two databases provided to it. If any table appears in one database but not the other, or if any table has a slightly different schema in one database it is an error. The &quot;--table&quot; option may be useful if this causes a problem</source>
          <target state="translated">기본적으로 sqldiff는 제공된 두 데이터베이스 내의 모든 비가 상 테이블을 처리하려고 시도합니다. 한 데이터베이스에는 테이블이 있지만 다른 데이터베이스에는 나타나지 않는 테이블이 있거나 한 데이터베이스에 약간 다른 스키마가있는 테이블은 오류입니다. &quot;--table&quot;옵션이 문제를 일으키는 경우 유용 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="46b22419bd1a4fd00ad28b08bf067b6f9f4f5e90" translate="yes" xml:space="preserve">
          <source>By default, sqlite3 sends query results to standard output. You can change this using the &quot;.output&quot; and &quot;.once&quot; commands. Just put the name of an output file as an argument to .output and all subsequent query results will be written to that file. Or use the .once command instead of .output and output will only be redirected for the single next command before reverting to the console. Use .output with no arguments to begin writing to standard output again. For example:</source>
          <target state="translated">기본적으로 sqlite3은 쿼리 결과를 표준 출력으로 보냅니다. &quot;.output&quot;및 &quot;.once&quot;명령을 사용하여이를 변경할 수 있습니다. 출력 파일의 이름을 .output의 인수로 입력하면 모든 후속 쿼리 결과가 해당 파일에 기록됩니다. 또는 .output 대신 .once 명령을 사용하면 콘솔로 복귀하기 전에 단일 다음 명령에 대해서만 출력이 리디렉션됩니다. 표준 출력에 다시 쓰기 시작하려면 인수없이 .output을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e508a45fb514da22df2b29ba2714c0232eb3c718" translate="yes" xml:space="preserve">
          <source>By default, swarmvtab attempts to limit the number of simultaneously open databases to nine. This parameter allows that limit to be changed. For example, to create a swarmvtab table that may hold up to 30 databases open simultaneously:</source>
          <target state="translated">기본적으로 swarmvtab은 동시에 열려있는 데이터베이스 수를 9 개로 제한하려고합니다. 이 매개 변수를 사용하면 한계를 변경할 수 있습니다. 예를 들어, 최대 30 개의 데이터베이스를 동시에 열 수있는 swarmvtab 테이블을 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="aac34cb1103bf35fa437aa535e48e93e51a7d344" translate="yes" xml:space="preserve">
          <source>By default, the &quot;.expert&quot; command recommends indexes based on the query and database schema alone. This is similar to the way the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; selects indexes for queries if the user has not run the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command on the database to generate data distribution statistics.</source>
          <target state="translated">기본적으로 &quot;.expert&quot;명령은 쿼리 및 데이터베이스 스키마 만 기반으로 인덱스를 권장합니다. 이는 사용자가 데이터 분산 통계를 생성하기 위해 데이터베이스 에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령을 실행하지 않은 경우 &lt;a href=&quot;optoverview&quot;&gt;SQLite 쿼리 플래너&lt;/a&gt; 가 쿼리에 대한 인덱스를 선택 하는 방식과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="79e59781472aaf1cab549c7756351e991a52f37c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface will automatically invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; to reset the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; if necessary. This compile-time option changes that behavior so that &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; will return &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; if it called again after returning anything other than &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt;, &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt;, or &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; unless there was an intervening call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스는 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 자동으로 호출 하여 필요한 경우 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 재설정합니다 . 이 컴파일 타임 옵션은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_reset ()&lt;/a&gt; 에 대한 중간 호출이없는 한 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_step ()&lt;/a&gt; 이 &lt;a href=&quot;rescode#row&quot;&gt;SQLITE_ROW&lt;/a&gt; , &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 또는 &lt;a href=&quot;rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 이외의 것을 반환 한 후 다시 호출하면 sqlite3_step () 이 &lt;a href=&quot;rescode#misuse&quot;&gt;SQLITE_MISUSE&lt;/a&gt; 를 반환 하도록 해당 동작을 변경 합니다 .</target>
        </trans-unit>
        <trans-unit id="b8f030cbd6427054daf45dea55ca6b9a3924a3dd" translate="yes" xml:space="preserve">
          <source>By default, the SQLite core double checks all constraints on each row of the virtual table that it receives. If such a check is redundant, the xBestFilter method can suppress that double-check by setting aConstraintUsage[].omit.</source>
          <target state="translated">기본적으로 SQLite 코어는 수신하는 가상 테이블의 각 행에서 모든 제약 조건을 이중으로 확인합니다. 이러한 검사가 중복되면 xBestFilter 메소드는 aConstraintUsage []. omit를 설정하여 해당 이중 검사를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0f172004db89e74c2b903c6ed15681a8554ce0" translate="yes" xml:space="preserve">
          <source>By default, the output of EXPLAIN QUERY PLAN commands does not include output for any operations performed by trigger programs. This option is used to set or clear (the default) a flag that governs this behavior. The first parameter passed to this operation is an integer - positive to enable output for trigger programs, or zero to disable it, or negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if it is not disabled, 1 if it is.</source>
          <target state="translated">기본적으로 EXPLAIN QUERY PLAN 명령의 출력에는 트리거 프로그램에 의해 수행 된 조작에 대한 출력이 포함되지 않습니다. 이 옵션은이 동작을 제어하는 ​​플래그를 설정하거나 지우는 데 사용됩니다 (기본값). 이 작업에 전달 된 첫 번째 매개 변수는 정수입니다. 트리거 프로그램의 출력을 활성화하려면 양수, 비활성화하려면 0, 설정을 변경하지 않은 경우 음수입니다. 두 번째 매개 변수는 0 또는 1로 기록 된 정수에 대한 포인터입니다. 트리거에 대한 출력이 비활성화되었는지 여부를 나타냅니다. 비활성화되지 않은 경우 0, 비활성화 된 경우 1입니다.</target>
        </trans-unit>
        <trans-unit id="d45ac6e349cce0d243d17d663e9e87155d75add6" translate="yes" xml:space="preserve">
          <source>By default, the porter tokenizer operates as a wrapper around the default tokenizer (unicode61). Or, if one or more extra arguments are added to the &quot;tokenize&quot; option following &quot;porter&quot;, they are treated as a specification for the underlying tokenizer that the porter stemmer uses. For example:</source>
          <target state="translated">기본적으로 포터 토크 나이 저는 기본 토크 나이저 (unicode61)를 감싸는 래퍼로 작동합니다. 또는 &quot;포터&quot;다음에 &quot;토큰 화&quot;옵션에 하나 이상의 추가 인수가 추가되면 포터 스테 머가 사용하는 기본 토크 나이저에 대한 스펙으로 처리됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="923e8b64eceb6502080849392eadafdbb5ce98eb" translate="yes" xml:space="preserve">
          <source>By default, the sessions module streaming interfaces attempt to input and output data in approximately 1 KiB chunks. This operand may be used to set and query the value of this configuration setting. The pointer passed as the second argument must point to a value of type (int). If this value is greater than 0, it is used as the new streaming data chunk size for both input and output. Before returning, the (int) value pointed to by pArg is set to the final value of the streaming interface chunk size.</source>
          <target state="translated">기본적으로 세션 모듈 스트리밍 인터페이스는 약 1 KiB 청크로 데이터를 입력 및 출력하려고 시도합니다. 이 피연산자는이 구성 설정의 값을 설정하고 쿼리하는 데 사용될 수 있습니다. 두 번째 인수로 전달 된 포인터는 유형 (int)의 값을 가리켜 야합니다. 이 값이 0보다 크면 입력 및 출력 모두에 대한 새로운 스트리밍 데이터 청크 크기로 사용됩니다. 반환하기 전에 pArg가 가리키는 (int) 값은 스트리밍 인터페이스 청크 크기의 최종 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed67e473742eb7c111c47a0cfdbbdb68f21a394b" translate="yes" xml:space="preserve">
          <source>By default, the shell is now in &quot;auto-explain&quot; mode. The output of &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; commands is automatically formatted.</source>
          <target state="translated">기본적으로 쉘은 이제 &quot;자동 설명&quot;모드에 있습니다. &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 명령 의 출력 은 자동으로 형식화됩니다.</target>
        </trans-unit>
        <trans-unit id="52d930b9eee7711ba25f4fd9b5cbc893a2bf348f" translate="yes" xml:space="preserve">
          <source>By default, the spellfix1 table returns no more than 20 results. (It might return less than 20 if there were fewer good matches.) You can change the upper bound on the number of returned rows by adding a &quot;top=N&quot; term to the WHERE clause of your query, where N is the new maximum. For example, to see the 5 best matches:</source>
          <target state="translated">기본적으로 spellfix1 테이블은 20 개 이하의 결과를 리턴합니다. 일치하는 항목이 적 으면 20 미만을 반환 할 수 있습니다. 쿼리의 WHERE 절에 &quot;top = N&quot;용어를 추가하여 반환 된 행 수의 상한을 변경할 수 있습니다. 여기서 N은 새로운 최대 값입니다. . 예를 들어 5 개의 가장 일치하는 항목을 보려면</target>
        </trans-unit>
        <trans-unit id="801f0fef23ca30c740bc98f388b5820b01c0a8aa" translate="yes" xml:space="preserve">
          <source>By default, there is a single row in the DBSTAT table for each btree page the database file. Each row provides information about the space utilization of that one page of the database. However, if the hidden column &quot;aggregate&quot; is TRUE, then results are aggregated and there is a single row in the DBSTAT table for each btree in the database, providing information about space utilization across the entire btree.</source>
          <target state="translated">기본적으로 DBSTAT 테이블에는 데이터베이스 파일의 각 btree 페이지에 대한 단일 행이 있습니다. 각 행은 데이터베이스 한 페이지의 공간 활용에 대한 정보를 제공합니다. 그러나 숨겨진 열 &quot;aggregate&quot;가 TRUE이면 결과가 집계되고 DBSTAT 테이블에 데이터베이스의 각 btree에 대한 단일 행이있어 전체 btree의 공간 활용에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa387565dd5968c7d1760a2e2262809354a9a035" translate="yes" xml:space="preserve">
          <source>By enclosing it in double quotes (&quot;). Within a string, any embedded double quote characters may be escaped SQL-style - by adding a second double-quote character.</source>
          <target state="translated">큰 따옴표 ( &quot;)로 묶으면 문자열에 포함 된 큰 따옴표는 두 번째 큰 따옴표 문자를 추가하여 SQL 스타일을 이스케이프 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="84617083eaab12542d0a6d482dc6332adeedf772" translate="yes" xml:space="preserve">
          <source>By explicitly specifying tables using one call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; for each table, or</source>
          <target state="translated">각 테이블에 대해 &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach ()&lt;/a&gt; 를 한 번 호출하여 테이블을 명시 적으로 지정 하거나</target>
        </trans-unit>
        <trans-unit id="7ec7970e0cfef9d2d98bfdb89f93e1b8b4b4b117" translate="yes" xml:space="preserve">
          <source>By invoking the xCheckReservedLock() method of the file-handle opened on the database file, SQLite checks if some other connection holds a</source>
          <target state="translated">데이터베이스 파일에서 열린 파일 핸들의 xCheckReservedLock () 메소드를 호출하여 SQLite는 다른 연결이</target>
        </trans-unit>
        <trans-unit id="e392907538e008d1f980f80b5391101815ed2a70" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, the In the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">모든 동의어를 단일 토큰에 매핑합니다. 이 경우 위 예제에서 토크 나이 저는 입력 &quot;first&quot;및 &quot;1st&quot;에 대해 동일한 토큰을 반환합니다. 사용자가 문서를 삽입 할 때 토큰 &quot;i&quot;, &quot;won&quot;, &quot;first&quot;및 &quot;place&quot;에 대한 색인에 항목이 추가되도록 토큰이 실제로 &quot;first&quot;라고 가정하십시오. 사용자가 '1st + place'를 쿼리하면 토크 나이저가 &quot;1st&quot;를 &quot;1st&quot;로 대체하고 쿼리가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d6c6c3e21f2551827a19fdcc87eccf2596523e84" translate="yes" xml:space="preserve">
          <source>By mapping all synonyms to a single token. In this case, using the above example, this means that the tokenizer returns the same token for inputs &quot;first&quot; and &quot;1st&quot;. Say that token is in fact &quot;first&quot;, so that when the user inserts the document &quot;I won 1st place&quot; entries are added to the index for tokens &quot;i&quot;, &quot;won&quot;, &quot;first&quot; and &quot;place&quot;. If the user then queries for '1st + place', the tokenizer substitutes &quot;first&quot; for &quot;1st&quot; and the query works as expected.</source>
          <target state="translated">모든 동의어를 단일 토큰에 매핑합니다. 이 경우 위의 예를 사용하면 토크 나이저가 입력 &quot;first&quot;및 &quot;1st&quot;에 대해 동일한 토큰을 반환 함을 의미합니다. 토큰이 실제로 &quot;첫 번째&quot;라고 가정하여 사용자가 문서 &quot;I won 1st place&quot;항목을 삽입하면 토큰 &quot;i&quot;, &quot;won&quot;, &quot;first&quot;및 &quot;place&quot;에 대한 색인에 추가됩니다. 사용자가 '1st + place'를 쿼리하면 토크 나이저가 &quot;1st&quot;를 &quot;first&quot;로 대체하고 쿼리가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f19cb00f7026582f508ec895d006b5124a9aeb30" translate="yes" xml:space="preserve">
          <source>By querying the index for all synonyms of each query term separately. In this case, when tokenizing query text, the tokenizer may provide multiple synonyms for a single term within the document. FTS5 then queries the index for each synonym individually. For example, faced with the query:</source>
          <target state="translated">각 검색어의 모든 동의어에 대한 색인을 별도로 조회합니다. 이 경우, 쿼리 텍스트를 토큰화할 때 토크 나이 저는 문서 내의 단일 용어에 대해 여러 동의어를 제공 할 수 있습니다. 그런 다음 FTS5는 각 동의어에 대한 인덱스를 개별적으로 쿼리합니다. 예를 들어 쿼리에 직면했습니다.</target>
        </trans-unit>
        <trans-unit id="55b05786af4043a1be86d71e95ee1411780e7ee4" translate="yes" xml:space="preserve">
          <source>By setting it to an empty string to create a contentless FTS5 table. In this case FTS5 assumes that the original column values are unavailable to it when processing queries. Full-text queries and some auxiliary functions can still be used, but no column values apart from the rowid may be read from the table.</source>
          <target state="translated">컨텐츠가없는 FTS5 테이블을 작성하려면 빈 문자열로 설정하십시오. 이 경우 FTS5는 쿼리를 처리 할 때 원래 열 값을 사용할 수 없다고 가정합니다. 전체 텍스트 쿼리 및 일부 보조 기능을 계속 사용할 수 있지만 rowid 이외의 열 값은 테이블에서 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61a66a14e7dcfe0861d93ec30802747dfb7523a1" translate="yes" xml:space="preserve">
          <source>By setting it to the name of a database object (table, virtual table or view) that may be queried by FTS5 at any time to retrieve the column values. This is known as an &quot;external content&quot; table. In this case all FTS5 functionality may be used, but it is the responsibility of the user to ensure that the contents of the full-text index are consistent with the named database object. If they are not, query results may be unpredictable.</source>
          <target state="translated">컬럼 값을 검색하기 위해 언제든지 FTS5가 조회 할 수있는 데이터베이스 오브젝트 (테이블, 가상 테이블 또는 뷰)의 이름으로 설정합니다. 이것을 &quot;외부 컨텐츠&quot;테이블이라고합니다. 이 경우 모든 FTS5 기능을 사용할 수 있지만 전체 텍스트 인덱스의 내용이 명명 된 데이터베이스 개체와 일치하는지 확인하는 것은 사용자의 책임입니다. 그렇지 않으면 쿼리 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b65e88a6a0b747d6c1e54c4edd9925d09b470f08" translate="yes" xml:space="preserve">
          <source>By specifying that all tables in the database should be monitored for changes using a call to &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach()&lt;/a&gt; with a NULL argument, or</source>
          <target state="translated">NULL 인수 를 사용하여 &lt;a href=&quot;session/sqlite3session_attach&quot;&gt;sqlite3session_attach ()에&lt;/a&gt; 대한 호출을 사용하여 데이터베이스의 모든 테이블에서 변경 사항을 모니터링하도록 지정</target>
        </trans-unit>
        <trans-unit id="63f834f4a2da63acc54bc935f1fd1ad5ded1c97a" translate="yes" xml:space="preserve">
          <source>By the time &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is invoked by wait_for_unlock_notify(), it is possible that the blocking connection that prevented the sqlite3_step() or sqlite3_prepare_v2() call from succeeding has already finished its transaction. In this case, the unlock-notify callback is invoked immediately, before &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; returns. Or, it is possible that the unlock-notify callback is invoked by a second thread after &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is called but before the thread starts waiting to be asynchronously signaled.</source>
          <target state="translated">시간에 의해 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; wait_for_unlock_notify ()에 의해 호출, 블록 접속 즉, sqlite3_step () 또는 sqlite3_prepare_v2 이미 거래를 완료 성공에서 () 호출을 방지하는 것이 가능하다. 이 경우, &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()가&lt;/a&gt; 반환 되기 전에 unlock-notify 콜백이 즉시 호출됩니다 . 또는 &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 가 호출 된 후 스레드가 비동기 적으로 신호되기를 대기하기 전에 두 번째 스레드가 잠금 해제 알림 콜백을 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="294016815718412ee0c20270b6745c8ced5712e1" translate="yes" xml:space="preserve">
          <source>By using its own built-in implementation, SQLite guarantees that the output will be the same on all platforms and in all LOCALEs. This is important for consistency and for testing. It would be problematic if one machine gave and answer of &quot;5.25e+08&quot; and another gave an answer of &quot;5.250e+008&quot;. Both answers are correct, but it is better when SQLite always gives the same answer.</source>
          <target state="translated">SQLite는 자체 내장 구현을 사용하여 모든 플랫폼과 모든 LOCALE에서 출력이 동일하게 보장됩니다. 일관성과 테스트에 중요합니다. 한 시스템에서 &quot;5.25e + 08&quot;을 제공하고 다른 시스템에서 &quot;5.250e + 008&quot;을 제공하면 문제가 될 수 있습니다. 두 답변 모두 정확하지만 SQLite가 항상 동일한 답변을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="478bcd9433faa7931ee1c7c1b62ccda2a8f4f8e8" translate="yes" xml:space="preserve">
          <source>By using standard SQL expressions in the WHERE clause of a SELECT query, a programmer can query for all R*Tree entries that intersect with or are contained within a particular bounding-box. Custom R*Tree queries, using the MATCH operator in the WHERE clause of a SELECT, allow the programmer to query for the set of R*Tree entries that intersect any arbitrary region or shape, not just a box. This capability is useful, for example, in computing the subset of objects in the R*Tree that are visible from a camera positioned in 3-D space.</source>
          <target state="translated">프로그래머는 SELECT 조회의 WHERE 절에서 표준 SQL 표현식을 사용하여 특정 경계 상자와 교차하거나 포함되는 모든 R * Tree 항목을 조회 할 수 있습니다. SELECT의 WHERE 절에서 MATCH 연산자를 사용하여 사용자 지정 R * Tree 쿼리를 사용하면 프로그래머는 상자뿐만 아니라 임의의 영역이나 모양과 교차하는 R * Tree 항목 집합을 쿼리 할 수 ​​있습니다. 이 기능은 예를 들어 3D 공간에 위치한 카메라에서 볼 수있는 R * Tree의 객체 하위 세트를 계산하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89a11056dc1624db725c970738aa5aaf2b86e420" translate="yes" xml:space="preserve">
          <source>Byte offset</source>
          <target state="translated">바이트 오프셋</target>
        </trans-unit>
        <trans-unit id="3552062ee633a28da0a78f6b8da0963926758e2e" translate="yes" xml:space="preserve">
          <source>Byte offset to the start of the page</source>
          <target state="translated">페이지 시작 부분의 바이트 오프셋</target>
        </trans-unit>
        <trans-unit id="40c37d34180ee81abeec6396f466a7bf1d1f2f45" translate="yes" xml:space="preserve">
          <source>Bytecode Engine</source>
          <target state="translated">바이트 코드 엔진</target>
        </trans-unit>
        <trans-unit id="e7d87e87cd071442d28d7e11c0a34595a73b4b95" translate="yes" xml:space="preserve">
          <source>Bytecode and tables_used are &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; built into SQLite that access information about &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Both bytecode and tables_used operate as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. They take a single required argument which is either the text of an SQL statement, or a pointer to an existing prepared statement. The bytecode function returns one row of result for each &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; operation in the prepared statement. The tables_used function returns one row for each persistent btree (either a table or an index) accessed by the prepared statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5fdab92dece79d7629d6d901687613ddc6ab5a" translate="yes" xml:space="preserve">
          <source>Bytes</source>
          <target state="translated">Bytes</target>
        </trans-unit>
        <trans-unit id="6e99d2b1b3cf05d1cb901ea3f769e34d773ba90a" translate="yes" xml:space="preserve">
          <source>Bytes 12-15 of the</source>
          <target state="translated">바이트 12-15</target>
        </trans-unit>
        <trans-unit id="89a9bc1f87191389726b0ed1804032da963a975c" translate="yes" xml:space="preserve">
          <source>Bytes 16-19 of the</source>
          <target state="translated">바이트 16-19</target>
        </trans-unit>
        <trans-unit id="24778eba404891c29eb268fa4b3c469a05e3f5af" translate="yes" xml:space="preserve">
          <source>Bytes 20-23 of the</source>
          <target state="translated">바이트 20-23</target>
        </trans-unit>
        <trans-unit id="5e820fc3c84f6f51bd1f6afe4e8dd983524446cf" translate="yes" xml:space="preserve">
          <source>Bytes 24-27 of the</source>
          <target state="translated">바이트 24-27</target>
        </trans-unit>
        <trans-unit id="eb167d60299b524eb07991d2141957c03c9ee5cd" translate="yes" xml:space="preserve">
          <source>Bytes 8-11 of the</source>
          <target state="translated">바이트 8-11</target>
        </trans-unit>
        <trans-unit id="a3587157a4089ec8301b2d0f784b91a32e9749e3" translate="yes" xml:space="preserve">
          <source>Bytes of unused &quot;reserved&quot; space at the end of each page. Usually 0.</source>
          <target state="translated">각 페이지 끝에 사용되지 않은 &quot;예약 된&quot;공간 바이트. 보통 0입니다.</target>
        </trans-unit>
        <trans-unit id="99c76b931cbafaf267cc3e2ad6a25e46605efcf6" translate="yes" xml:space="preserve">
          <source>Bytes of useful payload on the current page or btree</source>
          <target state="translated">현재 페이지 또는 btree의 유용한 페이로드 바이트</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="4f3cd44d015b24e6fbf168b36aa5120966aaf5ed" translate="yes" xml:space="preserve">
          <source>C API Requirements Document.</source>
          <target state="translated">C API 요구 사항 문서.</target>
        </trans-unit>
        <trans-unit id="e9a1acddb6f4bd40edd805612e996267e826e064" translate="yes" xml:space="preserve">
          <source>C Interface</source>
          <target state="translated">C 인터페이스</target>
        </trans-unit>
        <trans-unit id="d5efbb98716c6e33e7f3412795c630f8a8a66abd" translate="yes" xml:space="preserve">
          <source>C Interface: Session Module</source>
          <target state="translated">C 인터페이스 : 세션 모듈</target>
        </trans-unit>
        <trans-unit id="444516d338383f2d17d8f93aa996b6cd1762c79a" translate="yes" xml:space="preserve">
          <source>C is a great language for writing fast code. C is sometimes described as &quot;portable assembly language&quot;. It enables to developers to code as close to the underlying hardware as possible while still remaining portable across platforms.</source>
          <target state="translated">C는 빠른 코드 작성을위한 훌륭한 언어입니다. C는 때때로 &quot;휴대용 어셈블리 언어&quot;로 설명됩니다. 이를 통해 개발자는 플랫폼간에 이식성을 유지하면서 가능한 한 기본 하드웨어에 최대한 가까이 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58790293552f75d17353d3ee29e85a197a62dcbb" translate="yes" xml:space="preserve">
          <source>C-language Interface Specification for SQLite</source>
          <target state="translated">SQLite에 대한 C 언어 인터페이스 사양</target>
        </trans-unit>
        <trans-unit id="1ac091b19baa70bc10c3d1156fe018d4a8f6ef6b" translate="yes" xml:space="preserve">
          <source>C-style comments are now accepted by the tokenizer.</source>
          <target state="translated">C 스타일 주석은 이제 토크 나이저에 의해 승인됩니다.</target>
        </trans-unit>
        <trans-unit id="d4948b1f21c9b5ee92aa9e005ab2ec94317e417f" translate="yes" xml:space="preserve">
          <source>C-style comments begin with &quot;/*&quot; and extend up to and including the next &quot;*/&quot; character pair or until the end of input, whichever comes first. C-style comments can span multiple lines.</source>
          <target state="translated">C 스타일 주석은 &quot;/ *&quot;로 시작하고 다음 &quot;* /&quot;문자 쌍까지 또는 입력이 끝날 때까지 포함합니다. C 스타일 주석은 여러 줄에 걸쳐있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e693971cd8c5db36eaa639a8f7f4320b5c7557fd" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3</source>
          <target state="translated">SQLite 버전 3의 C / C ++ 인터페이스</target>
        </trans-unit>
        <trans-unit id="b7c9ebb838da580ee5ce0a6b6d3fb9492aadd0cf" translate="yes" xml:space="preserve">
          <source>C/C++ Interface For SQLite Version 3 (old)</source>
          <target state="translated">SQLite 버전 3 용 C / C ++ 인터페이스 (이전)</target>
        </trans-unit>
        <trans-unit id="629369eadf6dbb7e5f1900a3d284a7d0ebdf8449" translate="yes" xml:space="preserve">
          <source>CASCADE</source>
          <target state="translated">CASCADE</target>
        </trans-unit>
        <trans-unit id="55c417bda058d7601349aeb7556e3d8607c77f5d" translate="yes" xml:space="preserve">
          <source>CASE</source>
          <target state="translated">CASE</target>
        </trans-unit>
        <trans-unit id="24e95e83710f86d66debac57b5addb22a9ce7983" translate="yes" xml:space="preserve">
          <source>CASE WHEN x=w1 THEN r1 WHEN x=w2 THEN r2 ELSE r3 END</source>
          <target state="translated">x = w1 일 때 r1 x = w2 일 때 r2 그렇지 않으면 r3 끝</target>
        </trans-unit>
        <trans-unit id="fcb688501c6a701cda488771d9ab7d2ba8fccbb2" translate="yes" xml:space="preserve">
          <source>CASE expression</source>
          <target state="translated">CASE 표현</target>
        </trans-unit>
        <trans-unit id="c688feeff7f51b86a16bfff0e478b5a113fd0c4a" translate="yes" xml:space="preserve">
          <source>CASE x WHEN w1 THEN r1 WHEN w2 THEN r2 ELSE r3 END</source>
          <target state="translated">사례 x 언제 w1 그때 r1 때 w2 그때 r2 다른 r3 끝</target>
        </trans-unit>
        <trans-unit id="274ad8f8387ab7001d3681011456578f35fd9e46" translate="yes" xml:space="preserve">
          <source>CAST</source>
          <target state="translated">CAST</target>
        </trans-unit>
        <trans-unit id="bc9630c4f8bc64a9ad87f06d690b75d5f8954d78" translate="yes" xml:space="preserve">
          <source>CAST expressions</source>
          <target state="translated">CAST 표현식</target>
        </trans-unit>
        <trans-unit id="2bab9f8d26cc3165f0ac936b287a5e9381a51aad" translate="yes" xml:space="preserve">
          <source>CAST operator</source>
          <target state="translated">CAST 연산자</target>
        </trans-unit>
        <trans-unit id="57c58f87e406bfa72b5233a68e16e6ce57b58a9a" translate="yes" xml:space="preserve">
          <source>CHANGESET_CONFLICT is passed as the second argument to the conflict handler while processing an INSERT change if the operation would result in duplicate primary key values.</source>
          <target state="translated">조작으로 인해 기본 키 값이 중복되는 경우 INSERT 변경을 처리하는 동안 CHANGESET_CONFLICT가 충돌 핸들러에 두 번째 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="49279edf04879138e2ca01fe4da87f165bb8a556" translate="yes" xml:space="preserve">
          <source>CHAR</source>
          <target state="translated">CHAR</target>
        </trans-unit>
        <trans-unit id="ec67cd542d6d42f84f8aea6727411112c2a9eee5" translate="yes" xml:space="preserve">
          <source>CHARACTER(20)</source>
          <target state="translated">CHARACTER(20)</target>
        </trans-unit>
        <trans-unit id="d37267cb2995cccac2283009e1ea4f3a6dd37db3" translate="yes" xml:space="preserve">
          <source>CHECK</source>
          <target state="translated">CHECK</target>
        </trans-unit>
        <trans-unit id="7c8e71cdac81d935a110e970f2e16db27f75d5ec" translate="yes" xml:space="preserve">
          <source>CHECK constraint</source>
          <target state="translated">제약 조건 확인</target>
        </trans-unit>
        <trans-unit id="91f48f96fc5990f4b552ae5c63dd0114792c0da9" translate="yes" xml:space="preserve">
          <source>CHECK constraints</source>
          <target state="translated">점검 제한 조건</target>
        </trans-unit>
        <trans-unit id="6c581d4e90f448ac099620dc82b1bf15e3863e36" translate="yes" xml:space="preserve">
          <source>CHECK constraints use conflict resolution algorithms correctly.</source>
          <target state="translated">CHECK 제약 조건은 충돌 해결 알고리즘을 올바르게 사용합니다.</target>
        </trans-unit>
        <trans-unit id="700b401ca52b1bd3071dc838bf11be9cdb19fc5f" translate="yes" xml:space="preserve">
          <source>CLI</source>
          <target state="translated">CLI</target>
        </trans-unit>
        <trans-unit id="eb02003c667c1e9ee2fcede2fd0524e495d8ec1b" translate="yes" xml:space="preserve">
          <source>CLOB</source>
          <target state="translated">CLOB</target>
        </trans-unit>
        <trans-unit id="28248452f38e0300dc7c45ab12fbe5d41f97e047" translate="yes" xml:space="preserve">
          <source>COLLATE</source>
          <target state="translated">COLLATE</target>
        </trans-unit>
        <trans-unit id="093c8ab0d477c98bad008d7426a58810ce1d5c6c" translate="yes" xml:space="preserve">
          <source>COLLATE binary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="114fac2d95aa36c73c87444e3e119061a6c497e8" translate="yes" xml:space="preserve">
          <source>COLLATE operator</source>
          <target state="translated">COLLATE 연산자</target>
        </trans-unit>
        <trans-unit id="d517243e2eae9452e340645d614bbcb6cbc92a5f" translate="yes" xml:space="preserve">
          <source>COLLATE uint</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d59db8880904cdfee22d4bdd9e5cb72c42fae180" translate="yes" xml:space="preserve">
          <source>COLUMN</source>
          <target state="translated">COLUMN</target>
        </trans-unit>
        <trans-unit id="17e4d773881595e83eed7274990576cb3c33d081" translate="yes" xml:space="preserve">
          <source>COMMIT</source>
          <target state="translated">COMMIT</target>
        </trans-unit>
        <trans-unit id="b8bace9ba33552e80165d3ede409bac3b53e9442" translate="yes" xml:space="preserve">
          <source>COMMIT TRANSACTION</source>
          <target state="translated">거래 커밋</target>
        </trans-unit>
        <trans-unit id="5be9cfb9ef50ef7a3f4855f3a3912ced47c9cd37" translate="yes" xml:space="preserve">
          <source>COMMIT;</source>
          <target state="translated">COMMIT;</target>
        </trans-unit>
        <trans-unit id="716a4859cb65ba79cf0a75301f937ee8dd84b958" translate="yes" xml:space="preserve">
          <source>CONFLICT</source>
          <target state="translated">CONFLICT</target>
        </trans-unit>
        <trans-unit id="eb44b374436f71b41c8c59982685ea220ef821e2" translate="yes" xml:space="preserve">
          <source>CONSTRAINT</source>
          <target state="translated">CONSTRAINT</target>
        </trans-unit>
        <trans-unit id="cabc2219177d43a5c1d71e3003445f83b9a7195f" translate="yes" xml:space="preserve">
          <source>CREATE</source>
          <target state="translated">CREATE</target>
        </trans-unit>
        <trans-unit id="4dfe073e739c382b273bdf0f1bdd27e7f10f38af" translate="yes" xml:space="preserve">
          <source>CREATE INDEX</source>
          <target state="translated">색인 만들기</target>
        </trans-unit>
        <trans-unit id="d5c16f75a09033a1e8f65102b202f3992bcbc039" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2a ON t2(a);</source>
          <target state="translated">색인 i2a를 t2 (a)에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="219d80e293971a20fc410c1cb42fe81ee5be3296" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i2b ON t2(b);</source>
          <target state="translated">색인 i2b 작성 t2 (b);</target>
        </trans-unit>
        <trans-unit id="015ef83633db6629be0b04929a85c6e8362366cf" translate="yes" xml:space="preserve">
          <source>CREATE INDEX i3 ON t3(c);</source>
          <target state="translated">색인 i3을 t3 (c)에 작성;</target>
        </trans-unit>
        <trans-unit id="979ae29e43d609d39c91f43b7d2c9c6f0170c84c" translate="yes" xml:space="preserve">
          <source>CREATE TABLE</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="61fe1c0db27d323fd657d34129f0370eddfd6b9e" translate="yes" xml:space="preserve">
          <source>CREATE TABLE ... AS SELECT Statements</source>
          <target state="translated">CREATE TABLE ... AS SELECT 문</target>
        </trans-unit>
        <trans-unit id="fdc5603516a1557309c21e74d5f3a300d7053f48" translate="yes" xml:space="preserve">
          <source>CREATE TABLE AS</source>
          <target state="translated">테이블 만들기</target>
        </trans-unit>
        <trans-unit id="5c1879760c0ac0151021a298b71fc43dd31ae043" translate="yes" xml:space="preserve">
          <source>CREATE TABLE Statement</source>
          <target state="translated">CREATE TABLE 문</target>
        </trans-unit>
        <trans-unit id="ef4e542d71b6fc791055be2754c8bba0c238f3b8" translate="yes" xml:space="preserve">
          <source>CREATE TABLE and DROP TABLE now work correctly as prepared statements.</source>
          <target state="translated">CREATE TABLE 및 DROP TABLE은 이제 준비된 명령문으로 올바르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="6a035b079a1ff283fd14f7d5c5ea363c26b68cda" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">테이블 작성 t1 (a 정수, b 정수, c VARCHAR (100));</target>
        </trans-unit>
        <trans-unit id="4619a9be564e2fbde661edf547e025b44154bc1f" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b PRIMARY KEY);</source>
          <target state="translated">테이블 생성 t1 (a, b 기본 키);</target>
        </trans-unit>
        <trans-unit id="7b5a4e879f5838c381c1aaf9522123d8eb51ef28" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b UNIQUE);</source>
          <target state="translated">테이블 생성 t1 (a, b 고유);</target>
        </trans-unit>
        <trans-unit id="472c250359f0aac3ac59d709bce28e56fc427ab7" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(a, b);</source>
          <target state="translated">테이블 생성 t1 (a, b);</target>
        </trans-unit>
        <trans-unit id="b180c72a56f1e353661ad8a8bf096de1e31921fa" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t1(c1 VARIANT);</source>
          <target state="translated">테이블 생성 t1 (c1 VARIANT);</target>
        </trans-unit>
        <trans-unit id="6c723a031c86a4c7b06f2a3f8d60439c8dcf6107" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t2(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">테이블 작성 t2 (a 정수, b 정수, c VARCHAR (100));</target>
        </trans-unit>
        <trans-unit id="ffb49dd96e70cfeec18ece99b548162395148801" translate="yes" xml:space="preserve">
          <source>CREATE TABLE t3(a INTEGER, b INTEGER, c VARCHAR(100));</source>
          <target state="translated">테이블 작성 t3 (a 정수, b 정수, c VARCHAR (100));</target>
        </trans-unit>
        <trans-unit id="cf6418466d171e86053f358e78bdbbeb775f1f4f" translate="yes" xml:space="preserve">
          <source>CREATE TRIGGER</source>
          <target state="translated">트리거 만들기</target>
        </trans-unit>
        <trans-unit id="4862717c14fde4c95f9fc018bad5f1bcdf240d46" translate="yes" xml:space="preserve">
          <source>CREATE UNIQUE INDEX t1b ON t1(b);</source>
          <target state="translated">t1 (b)에 고유 색인 t1b 작성;</target>
        </trans-unit>
        <trans-unit id="c6d65be0664c12895eed3811d312f2344a61a809" translate="yes" xml:space="preserve">
          <source>CREATE VIEW</source>
          <target state="translated">보기 작성</target>
        </trans-unit>
        <trans-unit id="d37bcac589dd2e6a2d9d1fe15b402952fac86edd" translate="yes" xml:space="preserve">
          <source>CREATE VIRTUAL TABLE</source>
          <target state="translated">가상 테이블 생성</target>
        </trans-unit>
        <trans-unit id="3fed731b971838462d00ae70d200fd38b7750b9e" translate="yes" xml:space="preserve">
          <source>CREATE and DROP</source>
          <target state="translated">작성 및 삭제</target>
        </trans-unit>
        <trans-unit id="7ea4fbcff919d74664df2b3abbe9c64927134ca1" translate="yes" xml:space="preserve">
          <source>CROSS</source>
          <target state="translated">CROSS</target>
        </trans-unit>
        <trans-unit id="23cb1ba2135af54bb7f9dc4ac628c8c16b1274c8" translate="yes" xml:space="preserve">
          <source>CSV export</source>
          <target state="translated">CSV 내보내기</target>
        </trans-unit>
        <trans-unit id="41b55f7f4ea3b51535ca8d9719be622b0aa72549" translate="yes" xml:space="preserve">
          <source>CSV import</source>
          <target state="translated">CSV 가져 오기</target>
        </trans-unit>
        <trans-unit id="17e29dae877981f4c14c3c548258e66edf22daf5" translate="yes" xml:space="preserve">
          <source>CSV output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; now always uses CRNL for the row separator and avoids inserting CR in front of NLs contained in data.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 CSV 출력은 이제 행 분리 자로 항상 CRNL을 사용하고 데이터에 포함 된 NL 앞에 CR을 삽입하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e6303ccf1ceff324ad3a408b48244faf8b681b0a" translate="yes" xml:space="preserve">
          <source>CURRENT</source>
          <target state="translated">CURRENT</target>
        </trans-unit>
        <trans-unit id="988c655ab1a28987e3b7f4aa07b43ec2f252df71" translate="yes" xml:space="preserve">
          <source>CURRENT_DATE</source>
          <target state="translated">CURRENT_DATE</target>
        </trans-unit>
        <trans-unit id="2c91dc4d76138fb01afa917b2a5880a2ce68218e" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME</source>
          <target state="translated">CURRENT_TIME</target>
        </trans-unit>
        <trans-unit id="b12c7ec3f538b492b9b7b22b81788480777716ca" translate="yes" xml:space="preserve">
          <source>CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP added</source>
          <target state="translated">CURRENT_TIME, CURRENT_DATE 및 CURRENT_TIMESTAMP가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5fb7adeaa54144ee5b07100bdd633a9a88f29b3" translate="yes" xml:space="preserve">
          <source>CURRENT_TIMESTAMP</source>
          <target state="translated">CURRENT_TIMESTAMP</target>
        </trans-unit>
        <trans-unit id="65e385d9a3fe24f8571de75d22a480cc4676d324" translate="yes" xml:space="preserve">
          <source>CVE Number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="356e8d51d92a4a7c252e86ea6fe14e667fc3ae1e" translate="yes" xml:space="preserve">
          <source>CVE-2019-19317</source>
          <target state="translated">CVE-2019-19317</target>
        </trans-unit>
        <trans-unit id="99f9264fe966c3479910c5d0ba83460e6e3729ad" translate="yes" xml:space="preserve">
          <source>CVE-2019-19923</source>
          <target state="translated">CVE-2019-19923</target>
        </trans-unit>
        <trans-unit id="eebebbb796152888eb988cbad61ced631a21ff64" translate="yes" xml:space="preserve">
          <source>CVE-2019-19924</source>
          <target state="translated">CVE-2019-19924</target>
        </trans-unit>
        <trans-unit id="9070593189adb897b13efec120fbe18b3b48119d" translate="yes" xml:space="preserve">
          <source>CVE-2019-19925</source>
          <target state="translated">CVE-2019-19925</target>
        </trans-unit>
        <trans-unit id="b944efa961d3a4a65106baa20c05ed67ed3d8528" translate="yes" xml:space="preserve">
          <source>CVE-2019-19926</source>
          <target state="translated">CVE-2019-19926</target>
        </trans-unit>
        <trans-unit id="23620708a776d0f4b23595664d860f1eb18db80f" translate="yes" xml:space="preserve">
          <source>CVE-2019-19959</source>
          <target state="translated">CVE-2019-19959</target>
        </trans-unit>
        <trans-unit id="9c19ca22b3ff09cd11be29de3092bac5ecbb6f72" translate="yes" xml:space="preserve">
          <source>CVE-2019-20218</source>
          <target state="translated">CVE-2019-20218</target>
        </trans-unit>
        <trans-unit id="f84119bb7976cd5a8c8919e495a1ea188c8d01ce" translate="yes" xml:space="preserve">
          <source>CVE-2020-11655</source>
          <target state="translated">CVE-2020-11655</target>
        </trans-unit>
        <trans-unit id="24bf60a79a1bdc939cd96a195c263490e183d008" translate="yes" xml:space="preserve">
          <source>CVE-2020-11656</source>
          <target state="translated">CVE-2020-11656</target>
        </trans-unit>
        <trans-unit id="b3458c87a366a597752314c96918a11badac6df6" translate="yes" xml:space="preserve">
          <source>CVE-2020-13434</source>
          <target state="translated">CVE-2020-13434</target>
        </trans-unit>
        <trans-unit id="0c64280d7ac694f06901161e2e4192059c94030d" translate="yes" xml:space="preserve">
          <source>CVE-2020-13435</source>
          <target state="translated">CVE-2020-13435</target>
        </trans-unit>
        <trans-unit id="d2142032cb8f67d47c0f692a8f43b0da8ba3dbb4" translate="yes" xml:space="preserve">
          <source>CVE-2020-13630</source>
          <target state="translated">CVE-2020-13630</target>
        </trans-unit>
        <trans-unit id="01b180dcf9513183380ef259d2b0841c4e7f77b3" translate="yes" xml:space="preserve">
          <source>CVE-2020-13631</source>
          <target state="translated">CVE-2020-13631</target>
        </trans-unit>
        <trans-unit id="2f01c703b75f4b1f7d0a5171ce82a9de250b7508" translate="yes" xml:space="preserve">
          <source>CVE-2020-13632</source>
          <target state="translated">CVE-2020-13632</target>
        </trans-unit>
        <trans-unit id="5d08b8e084f6c27e8e4b3ed9ca47f1f1232dd879" translate="yes" xml:space="preserve">
          <source>CVE-2020-13871</source>
          <target state="translated">CVE-2020-13871</target>
        </trans-unit>
        <trans-unit id="d794882b16e5e67f67cae72af337733774cdf3d1" translate="yes" xml:space="preserve">
          <source>CVE-2020-15358</source>
          <target state="translated">CVE-2020-15358</target>
        </trans-unit>
        <trans-unit id="e199336a03380b560a1ec76506edbffac71e2c63" translate="yes" xml:space="preserve">
          <source>CVE-2020-6405</source>
          <target state="translated">CVE-2020-6405</target>
        </trans-unit>
        <trans-unit id="e0e462c2ba637997a01ca062b46b08478eaea02c" translate="yes" xml:space="preserve">
          <source>CVE-2020-9327</source>
          <target state="translated">CVE-2020-9327</target>
        </trans-unit>
        <trans-unit id="58cc14935f8aae029bbfb78904497935571ef45e" translate="yes" xml:space="preserve">
          <source>CVEs (&quot;Common Vulnerabilities and Exposures&quot;) are reports of software bugs that might allow a system to be hacked. The idea behind CVEs is sound. They provide a common naming scheme whereby software bugs that might compromise information security can be easily tracked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51c92beb8c02d63e98c12b62c29e821871eee1bb" translate="yes" xml:space="preserve">
          <source>CVEs about SQLite probably do not apply to your use of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e3affda4e192cdf66e451e6d423b53be2042240" translate="yes" xml:space="preserve">
          <source>CVEs are a low-quality source of information about bugs in SQLite that are likely to affect most applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97154728871232f8ec1e18c7f99aae1f66258be4" translate="yes" xml:space="preserve">
          <source>Cache Validation</source>
          <target state="translated">캐시 유효성 검사</target>
        </trans-unit>
        <trans-unit id="243348169a35fc01acf2950edac2a8317e1d5705" translate="yes" xml:space="preserve">
          <source>Cache sharing is enabled and disabled for an entire process. This is a change as of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;version 3.5.0&lt;/a&gt; (2007-09-04). In prior versions of SQLite, sharing was enabled or disabled for each thread separately.</source>
          <target state="translated">전체 프로세스에 대해 캐시 공유가 활성화 및 비활성화됩니다. 이것은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_5_0.html&quot;&gt;버전 3.5.0&lt;/a&gt; (2007-09-04) 에서 변경된 내용 입니다. 이전 버전의 SQLite에서는 공유가 각 스레드에 대해 개별적으로 활성화 또는 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="dfad78f93ed55c3b8305d2de17eb36b19e276c8b" translate="yes" xml:space="preserve">
          <source>Call sqlite3_reset() on the statement handle. Since an SQLITE_LOCKED error may only occur on the first call to sqlite3_step() (it is not possible for one call to sqlite3_step() to return SQLITE_ROW and then the next SQLITE_LOCKED), the statement handle may be reset at this point without affecting the results of the query from the point of view of the caller. If sqlite3_reset() were not called at this point, the next call to sqlite3_step() would return SQLITE_MISUSE.</source>
          <target state="translated">명령문 핸들에서 sqlite3_reset ()을 호출하십시오. SQLITE_LOCKED 오류는 sqlite3_step ()에 대한 첫 번째 호출에서만 발생할 수 있기 때문에 (sqlite3_step ()에 대한 한 번의 호출은 SQLITE_ROW를 리턴 한 후 다음 SQLITE_LOCKED를 리턴 할 수 없음) 결과에 영향을주지 않고이 시점에서 명령문 핸들이 재설정 될 수 있습니다. 발신자의 관점에서 이 시점에서 sqlite3_reset ()이 호출되지 않은 경우 다음 sqlite3_step () 호출은 SQLITE_MISUSE를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e7253d4d62ac064583560f235c4dc54e68e830f1" translate="yes" xml:space="preserve">
          <source>Call sqlite3_step() on the supplied statement handle. If the call returns anything other than SQLITE_LOCKED, then return this value to the caller. Otherwise, continue.</source>
          <target state="translated">제공된 명령문 핸들에서 sqlite3_step ()을 호출하십시오. 호출이 SQLITE_LOCKED 이외의 것을 리턴하면이 값을 호출자에게 리턴하십시오. 그렇지 않으면 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="ac89c336f7b9f31230fa306e89f0a63e33ec5741" translate="yes" xml:space="preserve">
          <source>Call sqlite3rbu_close(X) to destroy the sqlite3rbu object pointer. If sqlite3rbu_step(X) has been called enough times to completely apply the update to the target database, then the RBU database is marked as fully applied. Otherwise, the state of the RBU update application is saved in the state database (or in the RBU database if the name of the state database file in sqlite3rbu_open() is NULL) for later resumption of the update.</source>
          <target state="translated">sqlite3rbu_close (X)를 호출하여 sqlite3rbu 객체 포인터를 제거하십시오. sqlite3rbu_step (X)가 대상 데이터베이스에 업데이트를 완전히 적용하기에 충분한 횟수로 호출 된 경우 RBU 데이터베이스가 완전히 적용됨으로 표시됩니다. 그렇지 않으면 RBU 업데이트 응용 프로그램의 상태는 나중에 업데이트 재개를 위해 상태 데이터베이스 (또는 sqlite3rbu_open ()의 상태 데이터베이스 파일 이름이 NULL 인 경우 RBU 데이터베이스)에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="f4cfaf571c0396d88e7a8a5942129605eebc5000" translate="yes" xml:space="preserve">
          <source>Call the table named by the &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; in a recursive common table expression the &quot;recursive table&quot;. In the &lt;a href=&quot;syntax/recursive-cte&quot;&gt;recursive-cte&lt;/a&gt; bubble diagram above, the recursive table must appear exactly once in the FROM clause of the recursive-select and must not appear anywhere else in either the initial-select or the recursive-select, including subqueries. The initial-select may be a &lt;a href=&quot;lang_select#compound&quot;&gt;compound select&lt;/a&gt;, but it may not include an ORDER BY, LIMIT, or OFFSET. The recursive-select must be a simple select, not a compound. The recursive-select is allowed to include an ORDER BY, LIMIT, and/or OFFSET.</source>
          <target state="translated">재귀 공통 테이블 표현식에서 &lt;a href=&quot;syntax/cte-table-name&quot;&gt;cte-table-name&lt;/a&gt; 으로 명명 된 테이블을 &quot;재귀 테이블&quot;이라고합니다. 위의 &lt;a href=&quot;syntax/recursive-cte&quot;&gt;재귀 cte&lt;/a&gt; 버블 다이어그램에서 재귀 테이블은 재귀 선택의 FROM 절에 정확히 한 번 나타나야하며 서브 쿼리를 포함하여 초기 선택 또는 재귀 선택의 어느 곳에도 나타나서는 안됩니다. 초기 선택은 &lt;a href=&quot;lang_select#compound&quot;&gt;복합 select&lt;/a&gt; 일 수 있지만 ORDER BY, LIMIT 또는 OFFSET을 포함하지 않을 수 있습니다. 재귀 선택은 복합이 아닌 단순한 선택이어야합니다. 재귀 선택에는 ORDER BY, LIMIT 및 / 또는 OFFSET이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42fb639b7313463881ed7d9bae34cc709237f03b" translate="yes" xml:space="preserve">
          <source>Callback</source>
          <target state="translated">Callback</target>
        </trans-unit>
        <trans-unit id="fc3110a84b56463b6ac2be236d2d0ee212bb9db8" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_auto_extension(X) with an entry point X that is already on the list of automatic extensions is a harmless no-op. No entry point will be called more than once for each database connection that is opened.</source>
          <target state="translated">이미 자동 확장 목록에있는 진입 점 X로 sqlite3_auto_extension (X)를 호출하는 것은 무해합니다. 열린 각 데이터베이스 연결에 대해 시작점이 두 번 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdd02e84dcaceaea19448095c3e09a162e5292ae" translate="yes" xml:space="preserve">
          <source>Calling sqlite3_free() with a pointer previously returned by sqlite3_malloc() or sqlite3_realloc() releases that memory so that it might be reused. The sqlite3_free() routine is a no-op if is called with a NULL pointer. Passing a NULL pointer to sqlite3_free() is harmless. After being freed, memory should neither be read nor written. Even reading previously freed memory might result in a segmentation fault or other severe error. Memory corruption, a segmentation fault, or other severe error might result if sqlite3_free() is called with a non-NULL pointer that was not obtained from sqlite3_malloc() or sqlite3_realloc().</source>
          <target state="translated">sqlite3_malloc () 또는 sqlite3_realloc ()에 의해 이전에 리턴 된 포인터로 sqlite3_free ()를 호출하면 해당 메모리가 해제되어 재사용 될 수 있습니다. NULL 포인터로 호출 된 경우 sqlite3_free () 루틴은 작동하지 않습니다. sqlite3_free ()에 NULL 포인터를 전달하는 것은 무해합니다. 해제 된 후에는 메모리를 읽거나 쓰지 않아야합니다. 이전에 해제 된 메모리를 읽더라도 세그먼트 화 오류 또는 기타 심각한 오류가 발생할 수 있습니다. sqlite3_malloc () 또는 sqlite3_realloc ()에서 얻지 못한 NULL이 아닌 포인터로 sqlite3_free ()를 호출하면 메모리 손상, 세그먼트 오류 또는 기타 심각한 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3358427e1a8ed1bea8f5a2ad2f5555efabc90a34" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULL 포인터 또는 열린 얼룩 핸들이 아닌 인수로이 함수를 호출하면 정의되지 않은 동작이 발생합니다. null 포인터를 사용하여이 루틴을 호출하면 ( &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 실패한 호출로 반환되는 ) 무해한 no-op입니다. 그렇지 않으면,이 함수에 유효한 열린 얼룩 핸들이 전달되면 sqlite3_errcode () 및 sqlite3_errmsg () 함수가 리턴 한 값이 리턴되기 전에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="508bbd8f844cc227cec9347e436cbdd9ffc04285" translate="yes" xml:space="preserve">
          <source>Calling this function with an argument that is not a NULL pointer or an open blob handle results in undefined behaviour. Calling this routine with a null pointer (such as would be returned by a failed call to &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;) is a harmless no-op. Otherwise, if this function is passed a valid open blob handle, the values returned by the sqlite3_errcode() and sqlite3_errmsg() functions are set before returning.</source>
          <target state="translated">NULL 포인터 또는 열린 얼룩 핸들이 아닌 인수로이 함수를 호출하면 정의되지 않은 동작이 발생합니다. null 포인터를 사용하여이 루틴을 호출하면 ( &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt; 에 대한 실패한 호출로 반환되는 ) 무해한 no-op입니다. 그렇지 않으면,이 함수에 유효한 열린 얼룩 핸들이 전달되면 sqlite3_errcode () 및 sqlite3_errmsg () 함수가 리턴 한 값이 리턴되기 전에 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="64d7627e8fc4bb3206a4244a29e5baede1745ef4" translate="yes" xml:space="preserve">
          <source>Calling this routine with an argument less than or equal to zero turns off all busy handlers.</source>
          <target state="translated">0보다 작거나 같은 인수로이 루틴을 호출하면 사용중인 모든 핸들러가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="f8f92cf7b8aea43c60bffe0c687691a21c0c3628" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_CONSTRAINT_SUPPORT, X) 형식의 호출 이 지원되며, 여기서 X는 정수입니다. X가 0이면 &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 또는 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드가 &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config ()를&lt;/a&gt; 호출 한 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 제한 조건을 지원하지 않습니다. 받는 호출하는 경우 (기본값)이 구성에 &lt;a href=&quot;vtab#xupdate&quot;&gt;의해 XUpdate&lt;/a&gt; 방법 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CONSTRAINT는&lt;/a&gt; 다음 전체 문이 다시 것처럼 압연 &lt;a href=&quot;lang_conflict&quot;&gt;또는 ABORT는&lt;/a&gt; 관계없이 지정된 실제 ON 충돌 모드, 사용자의 SQL 문의 일부로 지정되었다.</target>
        </trans-unit>
        <trans-unit id="34ad152047e6215f524688d715005c8597525fd4" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블 &lt;/a&gt;&lt;a href=&quot;vtab#xcreate&quot;&gt;구현&lt;/a&gt; 의 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 xCreate 메서드 내에서 &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_DIRECTONLY) 형식의 호출은 해당 가상 테이블이 트리거 및 뷰 내에서 사용되는 것을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="8b0bba808ff71be3f5e68d5dc5e9c1b43f075395" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블 &lt;/a&gt;&lt;a href=&quot;vtab#xcreate&quot;&gt;구현&lt;/a&gt; 의 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 xCreate 메서드 내에서 &lt;a href=&quot;#sqlite3_vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_INNOCUOUS) 형식의 호출은 해당 가상 테이블이 트리거 및 뷰 내에서 사용하기에 안전한 것으로 식별합니다. 개념적으로 SQLITE_VTAB_INNOCUOUS 태그는 가상 테이블이 악의적 인 해커에 의해 제어 되더라도 심각한 해를 끼치 지 않을 수 있음을 의미합니다. 개발자는 꼭 필요한 경우가 아니면 SQLITE_VTAB_INNOCUOUS 플래그 설정을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="9cd59c58ce5ea212cbfa095730fc7d7c0c018f0a" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_CONSTRAINT_SUPPORT,X) are supported, where X is an integer. If X is zero, then the &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; whose &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; or &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method invoked &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; does not support constraints. In this configuration (which is the default) if a call to the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method returns &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt;, then the entire statement is rolled back as if &lt;a href=&quot;../lang_conflict&quot;&gt;OR ABORT&lt;/a&gt; had been specified as part of the users SQL statement, regardless of the actual ON CONFLICT mode specified.</source>
          <target state="translated">&lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_CONSTRAINT_SUPPORT, X) 형식의 호출 이 지원되며, 여기서 X는 정수입니다. X가 0이면 &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; 또는 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메소드가 &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config ()를&lt;/a&gt; 호출 한 &lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 은 제한 조건을 지원하지 않습니다. 받는 호출하는 경우 (기본값)이 구성에 &lt;a href=&quot;../vtab#xupdate&quot;&gt;의해 XUpdate&lt;/a&gt; 방법 반환 &lt;a href=&quot;../rescode#constraint&quot;&gt;SQLITE_CONSTRAINT는&lt;/a&gt; 다음 전체 문이 다시 것처럼 압연 &lt;a href=&quot;../lang_conflict&quot;&gt;또는 ABORT는&lt;/a&gt; 관계없이 지정된 실제 ON 충돌 모드, 사용자의 SQL 문의 일부로 지정되었다.</target>
        </trans-unit>
        <trans-unit id="0d15b922d29010ebd3f4c6c25124e15853e06a0d" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_DIRECTONLY) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation prohibits that virtual table from being used from within triggers and views.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;가상 테이블 &lt;/a&gt;&lt;a href=&quot;../vtab#xcreate&quot;&gt;구현&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 xCreate 메서드 내에서 &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_DIRECTONLY) 형식의 호출은 해당 가상 테이블이 트리거 및 뷰 내에서 사용되는 것을 금지합니다.</target>
        </trans-unit>
        <trans-unit id="015012a4348dd0949483c59bb10d1f9a584347cd" translate="yes" xml:space="preserve">
          <source>Calls of the form &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt;(db,SQLITE_VTAB_INNOCUOUS) from within the the &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; or &lt;a href=&quot;../vtab#xcreate&quot;&gt;xCreate&lt;/a&gt; methods of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt; implmentation identify that virtual table as being safe to use from within triggers and views. Conceptually, the SQLITE_VTAB_INNOCUOUS tag means that the virtual table can do no serious harm even if it is controlled by a malicious hacker. Developers should avoid setting the SQLITE_VTAB_INNOCUOUS flag unless absolutely necessary.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;가상 테이블 &lt;/a&gt;&lt;a href=&quot;../vtab#xcreate&quot;&gt;구현&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 또는 xCreate 메서드 내에서 &lt;a href=&quot;vtab_config&quot;&gt;sqlite3_vtab_config&lt;/a&gt; (db, SQLITE_VTAB_INNOCUOUS) 형식의 호출은 해당 가상 테이블이 트리거 및 뷰 내에서 사용하기에 안전한 것으로 식별합니다. 개념적으로 SQLITE_VTAB_INNOCUOUS 태그는 가상 테이블이 악의적 인 해커에 의해 제어 되더라도 심각한 해를 끼치 지 않을 수 있음을 의미합니다. 개발자는 꼭 필요한 경우가 아니면 SQLITE_VTAB_INNOCUOUS 플래그 설정을 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="86477778aa30209993df2ed08e9c32fc5e63a6fa" translate="yes" xml:space="preserve">
          <source>Calls to sqlite3_db_config() return SQLITE_OK if and only if the call is considered successful.</source>
          <target state="translated">sqlite3_db_config ()에 대한 호출은 호출이 성공한 것으로 간주되는 경우에만 SQLITE_OK를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="98e68b9f843bbc24802b164860be76398c7c74b1" translate="yes" xml:space="preserve">
          <source>Can I use SQLite in my commercial product without paying royalties?</source>
          <target state="translated">로열티를 지불하지 않고 상용 제품에 SQLite를 사용할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a99feeb9b762e6e46c563375f506a5cca89929e5" translate="yes" xml:space="preserve">
          <source>Can multiple applications or multiple instances of the same application access a single database file at the same time?</source>
          <target state="translated">여러 응용 프로그램이나 같은 응용 프로그램의 여러 인스턴스가 단일 데이터베이스 파일에 동시에 액세스 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1d85ae4c67a45ca5f093c8517be6998fccbe1b6b" translate="yes" xml:space="preserve">
          <source>Cancel Automatic Extension Loading</source>
          <target state="translated">자동 확장 로딩 취소</target>
        </trans-unit>
        <trans-unit id="0f1e2a9d130c394f768ce03af8c9cfdba772362c" translate="yes" xml:space="preserve">
          <source>Capture Changes Using Triggers</source>
          <target state="translated">트리거를 사용하여 변경 사항 캡처</target>
        </trans-unit>
        <trans-unit id="8d319a418b8f56b5238017081c3f614d4e2d2c3a" translate="yes" xml:space="preserve">
          <source>Carray($PTR,$N) is a &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; with a single column (named &quot;value&quot;) and zero or more rows. The &quot;value&quot; of each row in the carray() is taken from a C-language array that is $N elements long. $PTR is a pointer to the beginning of the array. In this way, the carray() function provides a convenient mechanism to bind C-language arrays to SQL queries.</source>
          <target state="translated">Carray ($ PTR, $ N)는 단일 열 (이름이 &quot;value&quot;)이고 0 개 이상의 행 이있는 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 입니다. carray ()에서 각 행의 &quot;값&quot;은 $ N 요소 길이의 C 언어 배열에서 가져옵니다. $ PTR은 배열의 시작을 가리키는 포인터입니다. 이런 식으로 carray () 함수는 C 언어 배열을 SQL 쿼리에 바인딩하는 편리한 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8c3b32ddf313031d687668680d0df3a761eedc08" translate="yes" xml:space="preserve">
          <source>Case-folding is only performed for ASCII characters. So while &quot;A&quot; and &quot;a&quot; are considered to be equivalent, &quot;&amp;Atilde;&quot; and &quot;&amp;atilde;&quot; are distinct.</source>
          <target state="translated">대소 문자 접기는 ASCII 문자에 대해서만 수행됩니다. 따라서 &quot;A&quot;와 &quot;a&quot;는 동등한 것으로 간주되지만 &quot;&amp;Atilde;&quot;와 &quot;&amp;atilde;&quot;는 서로 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ddb2cf0a81747a42bb2a318554bfc6f3310b70d2" translate="yes" xml:space="preserve">
          <source>Case-insensitive matching of Unicode characters does not work.</source>
          <target state="translated">대소 문자를 구분하지 않는 유니 코드 문자 일치는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a24bc7f7fc1b1e11b0cb6ad38cd14985ad78efd" translate="yes" xml:space="preserve">
          <source>Cases in which the underlying content table has an explicit INTEGER PRIMARY KEY column are slightly more difficult, as the text values stored in the rbu_control column are slightly different for the FTS index and its underlying content table. For the underlying content table, a character must be included in any rbu_control text values for the explicit IPK, but for the FTS table itself, which has an implicit rowid, it should not. This is inconvenient, but can be solved using a more complicated view, as follows:</source>
          <target state="translated">기본 컨텐츠 테이블에 명시적인 INTEGER PRIMARY KEY 열이있는 경우 rbu_control 컬럼에 저장된 텍스트 값이 FTS 인덱스 및 기본 컨텐츠 테이블과 약간 다르기 때문에 약간 더 어렵습니다. 기본 컨텐츠 테이블의 경우 명시 적 IPK의 rbu_control 텍스트 값에 문자를 포함해야하지만 내재적 인 rowid가있는 FTS 테이블 자체에는 문자를 포함해서는 안됩니다. 이는 불편하지만 다음과 같이 더 복잡한보기를 사용하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d2fbd5980d329d5d6af3be31953582204f59e3e" translate="yes" xml:space="preserve">
          <source>Cases where a query against a WAL-mode database can return &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; include the following:</source>
          <target state="translated">WAL 모드 데이터베이스에 대한 쿼리가 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 를 반환 할 수 있는 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15a2b7aaa72451fad3138411af4836bb6aea25de" translate="yes" xml:space="preserve">
          <source>Cases where the page-sizes of database pInMemory and zFilename are different could be handled better.</source>
          <target state="translated">데이터베이스 pInMemory와 zFilename의 페이지 크기가 다른 경우 더 잘 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="60745aef336b682ec827697b3e47b80c7d7555b3" translate="yes" xml:space="preserve">
          <source>Cast</source>
          <target state="translated">Cast</target>
        </trans-unit>
        <trans-unit id="8e96ef594fff82e127e63864e75e54aa6b53b266" translate="yes" xml:space="preserve">
          <source>Casting a REAL or INTEGER value to NUMERIC is a no-op, even if a real value could be losslessly converted to an integer.</source>
          <target state="translated">실제 값을 무손실로 정수로 변환 할 수 있어도 REAL 또는 INTEGER 값을 NUMERIC에 캐스트하는 것은 아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="383678fdbb040838c4ceb85e8d73bcffcce4db9f" translate="yes" xml:space="preserve">
          <source>Casting a TEXT or BLOB value into NUMERIC yields either an INTEGER or a REAL result. If the input text looks like an integer (there is no decimal point nor exponent) and the value is small enough to fit in a 64-bit signed integer, then the result will be INTEGER. Input text that looks like floating point (there is a decimal point and/or an exponent) and the text describes a value that can be losslessly converted back and forth between IEEE 754 64-bit float and a 51-bit signed integer, then the result is INTEGER. (In the previous sentence, a 51-bit integer is specified since that is one bit less than the length of the mantissa of an IEEE 754 64-bit float and thus provides a 1-bit of margin for the text-to-float conversion operation.) Any text input that describes a value outside the range of a 64-bit signed integer yields a REAL result.</source>
          <target state="translated">TEXT 또는 BLOB 값을 NUMERIC에 캐스트하면 INTEGER 또는 REAL 결과가 생성됩니다. 입력 텍스트가 정수처럼 보이거나 (소수점이나 지수가 없음) 값이 64 비트 부호있는 정수에 맞도록 충분히 작 으면 결과는 INTEGER입니다. 부동 소수점처럼 보이는 입력 텍스트 (소수점 및 / 또는 지수가 있음) 및 텍스트는 IEEE 754 64 비트 부동 소수점과 51 비트 부호있는 정수 사이에서 무손실로 변환 할 수있는 값을 설명합니다. 결과는 정수입니다. (이전 문장에서, 51 비트 정수는 IEEE 754 64 비트 플로트의 가수 길이보다 1 비트 작으므로 텍스트-플로트 변환을위한 1 비트 마진을 제공하므로 51 비트 정수가 지정됩니다. 64 비트 부호있는 정수 범위를 벗어난 값을 설명하는 텍스트 입력은 REAL 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6f9cada34f4e450b6e71343e035a2f6e0689a6ef" translate="yes" xml:space="preserve">
          <source>Casting a value to a type-name with no affinity causes the value to be converted into a BLOB. Casting to a BLOB consists of first casting the value to TEXT in the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection, then interpreting the resulting byte sequence as a BLOB instead of as TEXT.</source>
          <target state="translated">선호도가없는 유형 이름으로 값을 캐스트하면 값이 BLOB로 변환됩니다. BLOB로 캐스트는 먼저 데이터베이스 연결 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 에서 값을 TEXT로 캐스트 한 다음 결과 바이트 시퀀스를 TEXT 대신 BLOB로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="6fddff049ee62a8963c9618826e1a03cc952e4f9" translate="yes" xml:space="preserve">
          <source>Casting an INTEGER or REAL value into TEXT renders the value as if via &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf()&lt;/a&gt; except that the resulting TEXT uses the &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;encoding&lt;/a&gt; of the database connection.</source>
          <target state="translated">INTEGER 또는 REAL 값을 TEXT로 캐스트하면 결과 TEXT가 데이터베이스 연결 의 &lt;a href=&quot;pragma#pragma_encoding&quot;&gt;인코딩&lt;/a&gt; 을 사용하는 것을 제외하고 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_snprintf ()&lt;/a&gt; 를 통해 마치 값이 렌더링 됩니다.</target>
        </trans-unit>
        <trans-unit id="250b5faac42b62665141b9500e3ff0cde556b9c8" translate="yes" xml:space="preserve">
          <source>Casual readers are not expected to understand all of these rules. A key take-away from this section is that the rules for determining when query flatting is safe and when it is unsafe are subtle and complex. There have been multiple bugs over the years caused by over-aggressive query flattening. On the other hand, performance of complex queries and/or queries involving views tends to suffer if query flattening is more conservative.</source>
          <target state="translated">일반 독자는 이러한 규칙을 모두 이해하지 않아도됩니다. 이 섹션에서 중요한 것은 쿼리 플래 팅이 안전한시기와 안전하지 않은시기를 결정하는 규칙이 미묘하고 복잡하다는 것입니다. 지나치게 공격적인 쿼리 병합으로 인해 몇 년 동안 여러 버그가 발생했습니다. 반면에 복잡한 쿼리 및 / 또는 뷰와 관련된 쿼리의 성능은 쿼리 병합이보다 보수적 일 경우 어려움을 겪습니다.</target>
        </trans-unit>
        <trans-unit id="8907a1b62f0f750985eefc9ce844fea83efeb9a9" translate="yes" xml:space="preserve">
          <source>Cause precompiled statements to expire. When an expired statement is executed using sqlite3_step() it will either automatically reprepare itself (if it was originally created using sqlite3_prepare_v2()) or it will fail with SQLITE_SCHEMA.</source>
          <target state="translated">사전 컴파일 된 명령문이 만료되도록합니다. sqlite3_step ()을 사용하여 만기 된 명령문이 실행될 때 자동으로 다시 준비되거나 (sqlite3_prepare_v2 ()를 사용하여 작성된 경우) SQLITE_SCHEMA로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="a305305010fac4c32d5e753f973a3552e1f13215" translate="yes" xml:space="preserve">
          <source>Causes the customer.cust_addr field to be updated for a specific customer entry that has customer.cust_id equal to the $cust_id parameter. Note how the values assigned to the view are made available as field in the special &quot;NEW&quot; table within the trigger body.</source>
          <target state="translated">customer.cust_id가 $ cust_id 매개 변수와 동일한 특정 고객 항목에 대해 customer.cust_addr 필드가 업데이트되도록합니다. 뷰에 할당 된 값이 트리거 본문 내 특수 &quot;NEW&quot;테이블에서 필드로 사용 가능한 방식에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="dbad4a6e3280246beefd6847d2978b258b3988cb" translate="yes" xml:space="preserve">
          <source>Cautions On The Use Of BEFORE triggers</source>
          <target state="translated">BEFORE 트리거 사용시주의 사항</target>
        </trans-unit>
        <trans-unit id="b150cf72e99af84282f28eb7200853b8c0ee4cf4" translate="yes" xml:space="preserve">
          <source>Caveats And Bugs</source>
          <target state="translated">경고와 버그</target>
        </trans-unit>
        <trans-unit id="ff583586588dbe1c7f2b18104da572d7a5f33f25" translate="yes" xml:space="preserve">
          <source>Celebrating the SQLite &quot;</source>
          <target state="translated">SQLite 축하 &quot;</target>
        </trans-unit>
        <trans-unit id="59bd6eed6ef43faee3a8233d127e632eb210e7f2" translate="yes" xml:space="preserve">
          <source>Cell content is stored in the cell content region of the b-tree page. SQLite strives to place cells as far toward the end of the b-tree page as it can, in order to leave space for future growth of the cell pointer array. The area in between the last cell pointer array entry and the beginning of the first cell is the unallocated region.</source>
          <target state="translated">셀 컨텐츠는 b- 트리 페이지의 셀 컨텐츠 영역에 저장됩니다. SQLite는 셀 포인터 배열의 향후 성장을위한 공간을 확보하기 위해 셀을 가능한 한 b- 트리 페이지 끝쪽으로 배치하려고합니다. 마지막 셀 포인터 배열 항목과 첫 번째 셀의 시작 부분 사이의 영역은 할당되지 않은 영역입니다.</target>
        </trans-unit>
        <trans-unit id="3b0cca36895145060f4680c61a83b1cba94677a3" translate="yes" xml:space="preserve">
          <source>Cell format summary</source>
          <target state="translated">셀 형식 요약</target>
        </trans-unit>
        <trans-unit id="7ba571bb64ab9af59eb4c60e06ccece4c22b6946" translate="yes" xml:space="preserve">
          <source>Cell payload</source>
          <target state="translated">셀 페이로드</target>
        </trans-unit>
        <trans-unit id="4467e902ad5ceab8af5cb553065bb45a1d9e0f01" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;cli#arinsup&quot;&gt;--update option&lt;/a&gt; in the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt; so that it skips files that are already in the archive and are unchanged. Add the new --insert option that works like --update used to work.</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령&lt;/a&gt; 에서 &lt;a href=&quot;cli#arinsup&quot;&gt;--update 옵션&lt;/a&gt; 을 변경 하여 아카이브에 이미 있고 변경되지 않은 파일을 건너 뜁니다. 작동하는 데 사용되는 --update와 같은 새 --insert 옵션을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f2cdcfee54f6e63221834526df456ae33f4748c1" translate="yes" xml:space="preserve">
          <source>Change &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; from 100 to 20, for improved performance.</source>
          <target state="translated">성능 향상을 위해 &lt;a href=&quot;compile#default_pcache_initsz&quot;&gt;SQLITE_DEFAULT_PCACHE_INITSZ&lt;/a&gt; 를 100에서 20으로 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="89533c2ad87297c6b1814e96c92819fffab5d853" translate="yes" xml:space="preserve">
          <source>Change both unix and windows &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to report a sector size of 4096 instead of the old default of 512.</source>
          <target state="translated">이전 기본값 인 512 대신 섹터 크기를 4096으로보고하도록 unix 및 windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 모두 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9b62dcab530abf089ef055d542c538c769edd17" translate="yes" xml:space="preserve">
          <source>Change counter</source>
          <target state="translated">카운터 변경</target>
        </trans-unit>
        <trans-unit id="78284963454462cded2891e165a76967ce7ebecf" translate="yes" xml:space="preserve">
          <source>Change in Default Page Size in SQLite Version 3.12.0</source>
          <target state="translated">SQLite 버전 3.12.0에서 기본 페이지 크기 변경</target>
        </trans-unit>
        <trans-unit id="8ef7213e575119b9063a9829bf0081766983433e" translate="yes" xml:space="preserve">
          <source>Change log</source>
          <target state="translated">변경 로그</target>
        </trans-unit>
        <trans-unit id="a9b88ee2ce690ee5c74f615e035bfd14907be3b4" translate="yes" xml:space="preserve">
          <source>Change tclsqlite.c to use the Tcl_Obj interface</source>
          <target state="translated">Tcl_Obj 인터페이스를 사용하도록 tclsqlite.c를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="c9502e13b89a0e998e0002cc9dd2ac28edd6e8ea" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt; source code to avoid calling C-library functions that OpenBSD considers dangerous. (Ex: sprintf).</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬&lt;/a&gt; 소스 코드를 변경하여 OpenBSD가 위험한 것으로 간주하는 C 라이브러리 함수를 호출하지 않도록하십시오. (예 : sprintf).</target>
        </trans-unit>
        <trans-unit id="5d77baa02e54aeb22b238c0441152b1e5304decd" translate="yes" xml:space="preserve">
          <source>Change the &lt;a href=&quot;tempfiles#tempdir&quot;&gt;temporary directory search algorithm&lt;/a&gt; on Unix to allow directories with write and execute permission, but without read permission, to serve as temporary directories. Apply this same standard to the &quot;.&quot; fallback directory.</source>
          <target state="translated">쓰기 및 실행 권한이 있지만 읽기 권한이없는 디렉토리가 임시 디렉토리 역할을 할 수 있도록 Unix 에서 &lt;a href=&quot;tempfiles#tempdir&quot;&gt;임시 디렉토리 검색 알고리즘&lt;/a&gt; 을 변경하십시오 . 이 표준을 &quot;.&quot;에 적용하십시오. 대체 디렉토리.</target>
        </trans-unit>
        <trans-unit id="ddfd791371cc9a6cd54b126954447b1ad9112604" translate="yes" xml:space="preserve">
          <source>Change the &lt;b&gt;sqlite&lt;/b&gt; program so that it can read databases for which it lacks write permission. (It used to refuse all access if it could not write.)</source>
          <target state="translated">쓰기 권한이없는 데이터베이스를 읽을 수 있도록 &lt;b&gt;sqlite&lt;/b&gt; 프로그램을 변경하십시오 . (쓰기가 불가능한 경우 모든 액세스를 거부했습니다.)</target>
        </trans-unit>
        <trans-unit id="cbf993184d73b432fd33a6a4967c4e16c588f384" translate="yes" xml:space="preserve">
          <source>Change the code so that version 2.1.1 databases that were rendered unreadable by the above bug can be read by this version of the library even though the SQLITE_MASTER table is (slightly) corrupted.</source>
          <target state="translated">SQLITE_MASTER 테이블이 (약간) 손상된 경우에도 위의 버그로 읽을 수없는 버전 2.1.1 데이터베이스를이 버전의 라이브러리에서 읽을 수 있도록 코드를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1b2c3ec73b516454d30b27549240c5be169d57e9" translate="yes" xml:space="preserve">
          <source>Change the datatype of SrcList.nSrc from type u8 to type int to work around an issue in the C compiler on AIX.</source>
          <target state="translated">AIX의 C 컴파일러에서 문제를 해결하려면 SrcList.nSrc의 데이터 유형을 u8 유형에서 int 유형으로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="03b6774f351d6b79789eab0049e6b7dfa776c60c" translate="yes" xml:space="preserve">
          <source>Change the format of data records so that records up to 16MB in size can be stored.</source>
          <target state="translated">최대 16MB 크기의 레코드를 저장할 수 있도록 데이터 레코드 형식을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="cb9d727fc495b196f0a9e9dcf746f3b21fc8137d" translate="yes" xml:space="preserve">
          <source>Change the format of indices to allow for better query optimization.</source>
          <target state="translated">더 나은 쿼리 최적화를 위해 인덱스 형식을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5c9b7b0951ce0a0f4a0c1e9e79102e0b6bc620be" translate="yes" xml:space="preserve">
          <source>Change the format of indices to correct a design flaw the originated with version 2.1.0. *** This is an incompatible file format change *** When version 2.6.0 or later of the library attempts to open a database file created by version 2.5.6 or earlier, it will automatically and irreversibly convert the file format. &lt;b&gt;Make backup copies of older database files before opening them with version 2.6.0 of the library.&lt;/b&gt;</source>
          <target state="translated">버전 2.1.0에서 시작된 설계 결함을 정정하려면 색인 형식을 변경하십시오. *** 이것은 호환되지 않는 파일 형식 변경입니다. *** 라이브러리 버전 2.6.0 이상이 버전 2.5.6 이하에서 작성된 데이터베이스 파일을 열려고하면 파일 형식이 자동으로 돌이킬 수 없게 변환됩니다. &lt;b&gt;라이브러리의 버전 2.6.0에서 이전 데이터베이스 파일을 열기 전에 백업 사본을 작성하십시오.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b18ff5a16f7817612045bc810baefbc9f406946f" translate="yes" xml:space="preserve">
          <source>Change the journal mode of database P1 to P3. P3 must be one of the PAGER_JOURNALMODE_XXX values. If changing between the various rollback modes (delete, truncate, persist, off and memory), this is a simple operation. No IO is required.</source>
          <target state="translated">데이터베이스 P1의 저널 모드를 P3으로 변경하십시오. P3은 PAGER_JOURNALMODE_XXX 값 중 하나 여야합니다. 다양한 롤백 모드 (삭제, 자르기, 지속, 끄기 및 메모리)간에 변경하는 경우 간단한 조작입니다. IO가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a5f740ae4d06bae054615ec1ed93d10f35a1f54" translate="yes" xml:space="preserve">
          <source>Change the makefile so that it no longer requires GNUmake extensions</source>
          <target state="translated">더 이상 GNUmake 확장이 필요하지 않도록 makefile을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="1b024f79cb0f34e36e5e78085bb24625608ab395" translate="yes" xml:space="preserve">
          <source>Change the name of new_X to X using: ALTER TABLE new_X RENAME TO X.</source>
          <target state="translated">ALTER TABLE new_X RENAME TO X를 사용하여 new_X의 이름을 X로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0f9e3a306b4bd9af67f4b8c1e8cb9e151f5fea94" translate="yes" xml:space="preserve">
          <source>Change the name of the sanity_check PRAGMA to &lt;b&gt;integrity_check&lt;/b&gt; and make it available in all compiles.</source>
          <target state="translated">sanity_check PRAGMA의 이름을 &lt;b&gt;integrity_check로&lt;/b&gt; 변경하고 모든 컴파일에서 사용 가능하게하십시오.</target>
        </trans-unit>
        <trans-unit id="a87afe8ac8040316feb3c86d9f29d7a0de41424f" translate="yes" xml:space="preserve">
          <source>Change the round() function to return REAL instead of TEXT.</source>
          <target state="translated">TEXT 대신 REAL을 반환하도록 round () 함수를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="4cc900222ca19ab1e3c50fea1f145e841c36bab9" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">&lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블&lt;/a&gt; 의 type, name 및 tbl_name 컬럼 이 손상되고 데이터베이스 연결이 &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; 모드 가 아닌 경우 오류가 발생하도록 스키마 구문 분석기를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="8e16078deadbe9f7e3e1b2c9c9d590cfec88a614" translate="yes" xml:space="preserve">
          <source>Change the schema parser so that it will error out if any of the type, name, and tbl_name columns of the &lt;a href=&quot;schematab&quot;&gt;sqlite_master table&lt;/a&gt; have been corrupted and the database connection is not in &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; mode.</source>
          <target state="translated">&lt;a href=&quot;schematab&quot;&gt;sqlite_master 테이블&lt;/a&gt; 의 유형, 이름 및 tbl_name 열 이 손상되고 데이터베이스 연결이 &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;writable_schema&lt;/a&gt; 모드 가 아닌 경우 오류가 발생하도록 스키마 구문 분석기를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cf246de2a9b8a88c663c6913b8ed3a48191818d" translate="yes" xml:space="preserve">
          <source>Change the table_info pragma so that it returns NULL for the default value if there is no default value</source>
          <target state="translated">table_info pragma가 기본값이없는 경우 기본값으로 NULL을 리턴하도록 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="b05df024c90267a155027a34482c97ed1e176816" translate="yes" xml:space="preserve">
          <source>Change the tclsqlite &quot;eval&quot; method to return a list of results if no callback script is specified.</source>
          <target state="translated">콜백 스크립트가 지정되지 않은 경우 tclsqlite &quot;eval&quot;메소드를 변경하여 결과 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="17fc584f1b3f79a52638c936555356d72a9a526e" translate="yes" xml:space="preserve">
          <source>Change the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to be tolerant of read() system calls that return less then the full number of requested bytes.</source>
          <target state="translated">유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 가 전체 요청 바이트 수보다 적은 값을 리턴하는 read () 시스템 호출을 허용하도록 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="a542a095188ddcc6129238423271833568a2c07f" translate="yes" xml:space="preserve">
          <source>Change the way SUM() handles NULL values in order to comply with the SQL standard</source>
          <target state="translated">SQL 표준을 준수하기 위해 SUM ()이 NULL 값을 처리하는 방식 변경</target>
        </trans-unit>
        <trans-unit id="5b5328bf106285a23dec346b5145893a33e1e8c9" translate="yes" xml:space="preserve">
          <source>Change the xFileControl() methods on all built-in VFSes to return &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; instead of &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; for an unrecognized operation code.</source>
          <target state="translated">에 xFileControl () 메소드를 변경하는 모든 내장 돌아 VFSes &lt;a href=&quot;rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt; 대신 &lt;a href=&quot;rescode#error&quot;&gt;SQLITE_ERROR을&lt;/a&gt; 알 수없는 동작 코드.</target>
        </trans-unit>
        <trans-unit id="eca73e726e881b6d471428b557f6268ef3f59ed9" translate="yes" xml:space="preserve">
          <source>Change to use strncmp() or the equivalent instead of memcmp() when comparing non-zero-terminated strings.</source>
          <target state="translated">0으로 끝나지 않은 문자열을 비교할 때 memcmp () 대신 strncmp () 또는 이와 동등한 항목을 사용하도록 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="5514a8922a61fec2577edc11821f533a39d0a9ca" translate="yes" xml:space="preserve">
          <source>Changed the comparison function so that numbers in exponential notation (ex: 1.234e+05) sort in numerical order.</source>
          <target state="translated">지수 표기법 (예 : 1.234e + 05)의 숫자가 숫자 순서로 정렬되도록 비교 기능을 변경했습니다.</target>
        </trans-unit>
        <trans-unit id="df02ed3983d83060874d040fa7eb3a189bd673c0" translate="yes" xml:space="preserve">
          <source>Changed the default configuration of the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; from 500 slots of 128 bytes each into 125 slots of 512 bytes each.</source>
          <target state="translated">&lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 기&lt;/a&gt; 의 기본 구성이 각각 128 바이트의 500 개 슬롯에서 512 바이트의 125 개 슬롯으로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e34599469a327d2e948bcc9862b0322f2e510f5" translate="yes" xml:space="preserve">
          <source>Changed the defined behavior for the &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST expression&lt;/a&gt; when floating point values greater than +9223372036854775807 are cast into into integers so that the result is the largest possible integer, +9223372036854775807, instead of the smallest possible integer, -9223372036854775808. After this change, CAST(9223372036854775809.0 as INT) yields +9223372036854775807 instead of -9223372036854775808. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; Potentially Incompatible Change!&lt;/b&gt;</source>
          <target state="translated">+9223372036854775807보다 큰 부동 소수점 값이 정수로 캐스트 될 때 &lt;a href=&quot;lang_expr#castexpr&quot;&gt;CAST 표현식에&lt;/a&gt; 대해 정의 된 동작이 변경되어 결과는 가능한 가장 작은 정수 대신 -9223372036854775808이 될 수 있습니다. 이 변경 후 CAST (INT는 9223372036854775809.0)가 -9223372036854775808 대신 +9223372036854775807을 산출합니다. &lt;b&gt;&lt;big&gt;&amp;larr;&lt;/big&gt; 잠재적으로 호환되지 않는 변경!&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8caa23815a1a8b1a9c4e9cdf79d42cbf41197489" translate="yes" xml:space="preserve">
          <source>Changed the print format for floating point values from &quot;%g&quot; to &quot;%.15g&quot;.</source>
          <target state="translated">부동 소수점 값의 인쇄 형식이 &quot;% g&quot;에서 &quot;% .15g&quot;로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="24a6e547edd1d04eb53e9f5fe5f292726e669a13" translate="yes" xml:space="preserve">
          <source>Changed the prototype of the &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension()&lt;/a&gt; interface in a way that is backwards compatible but which might cause warnings in new builds of applications that use that interface.</source>
          <target state="translated">이전 버전과 호환되지만 해당 인터페이스를 사용하는 새로운 응용 프로그램 빌드에서 경고가 발생할 수있는 방식으로 &lt;a href=&quot;c3ref/auto_extension&quot;&gt;sqlite3_auto_extension ()&lt;/a&gt; 인터페이스 의 프로토 타입을 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="f51c4a6bf59ab3184542658dacdac319c7bb7606" translate="yes" xml:space="preserve">
          <source>Changed the signature of the xDlSym method of the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object in a way that is backwards compatible but which might cause compiler warnings.</source>
          <target state="translated">이전 버전과 호환되지만 컴파일러 경고가 발생할 수있는 방식으로 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 xDlSym 메소드의 서명을 변경했습니다 .</target>
        </trans-unit>
        <trans-unit id="09eb09203ab84e8c2e6e475c70c299202b24c3d8" translate="yes" xml:space="preserve">
          <source>Changegroup Handle</source>
          <target state="translated">변경 그룹 핸들</target>
        </trans-unit>
        <trans-unit id="11562ffd183a3f8082c848cac1f5dad1ab2f2843" translate="yes" xml:space="preserve">
          <source>Changes In SQLite Version 3.7.10</source>
          <target state="translated">SQLite 버전 3.7.10의 변경 사항</target>
        </trans-unit>
        <trans-unit id="2995749ac68f24f9806cbd53a3147e4763d74488" translate="yes" xml:space="preserve">
          <source>Changes are made to the database by executing SQL statements. The session object records these changes.</source>
          <target state="translated">SQL 문을 실행하여 데이터베이스를 변경합니다. 세션 개체는 이러한 변경 사항을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="3feb747c2cf9c224527b83786a30acbbf79e8f1b" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for individual rows that have NULL values stored in one or more of their PRIMARY KEY columns.</source>
          <target state="translated">하나 이상의 PRIMARY KEY 열에 NULL 값이 저장된 개별 행에 대한 변경 내용은 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ba7ed905184ce22787b0029a4544681dc28b3db" translate="yes" xml:space="preserve">
          <source>Changes are not recorded for rows that have NULL values stored in one or more of their PRIMARY KEY columns. If such a row is inserted or deleted, no corresponding change is present in the changesets returned by this function. If an existing row with one or more NULL values stored in PRIMARY KEY columns is updated so that all PRIMARY KEY columns are non-NULL, only an INSERT is appears in the changeset. Similarly, if an existing row with non-NULL PRIMARY KEY values is updated so that one or more of its PRIMARY KEY columns are set to NULL, the resulting changeset contains a DELETE change only.</source>
          <target state="translated">하나 이상의 PRIMARY KEY 열에 NULL 값이 저장된 행의 변경 내용은 기록되지 않습니다. 이러한 행을 삽입하거나 삭제하면이 함수가 반환 한 변경 집합에 해당하는 변경 사항이 없습니다. PRIMARY KEY 열에 저장된 하나 이상의 NULL 값이있는 기존 행이 업데이트되어 모든 PRIMARY KEY 열이 NULL이 아닌 경우 INSERT 만 변경 세트에 나타납니다. 마찬가지로, 하나 이상의 PRIMARY KEY 열이 NULL로 설정되도록 NULL이 아닌 PRIMARY KEY 값이있는 기존 행을 업데이트하면 결과 변경 집합에 DELETE 변경 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e50ec4a352fdec5ac39c386ca001416ca1e482" translate="yes" xml:space="preserve">
          <source>Changes can only be recorded for tables that have a PRIMARY KEY explicitly defined as part of their CREATE TABLE statement. It does not matter if the PRIMARY KEY is an &quot;INTEGER PRIMARY KEY&quot; (rowid alias) or not. The PRIMARY KEY may consist of a single column, or may be a composite key.</source>
          <target state="translated">CREATE TABLE 문의 일부로 PRIMARY KEY가 명시 적으로 정의 된 테이블에 대해서만 변경 사항을 기록 할 수 있습니다. PRIMARY KEY가 &quot;INTEGER PRIMARY KEY&quot;(행 별명)인지 여부는 중요하지 않습니다. PRIMARY KEY는 단일 열로 구성되거나 복합 키일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0acee58dba4e45c8d5f0399ec1f0d4976436ff2" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;외래 키 작업의&lt;/a&gt; 일부로 변경 한 내용은 개수에 포함되지만 REPLACE 제약 조건 해결의 일부로 변경 한 내용 은 포함되지 않습니다. INSTEAD OF 트리거에 의해 인터셉트 된 뷰에 대한 변경 사항은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b4615c7abb16118eca044200ca3ffb2d42e109f3" translate="yes" xml:space="preserve">
          <source>Changes made as part of &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; are included in the count, but those made as part of REPLACE constraint resolution are not. Changes to a view that are intercepted by INSTEAD OF triggers are not counted.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업의&lt;/a&gt; 일부로 변경 한 내용은 개수에 포함되지만 REPLACE 제약 조건 해결의 일부로 변경 한 내용 은 포함되지 않습니다. INSTEAD OF 트리거에 의해 인터셉트 된 뷰에 대한 변경 사항은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e424444f79aa5098cffaecbf261fdab95101506" translate="yes" xml:space="preserve">
          <source>Changes made in one database connection are invisible to all other database connections prior to commit.</source>
          <target state="translated">커밋하기 전에 한 데이터베이스 연결에서 변경 한 내용은 다른 모든 데이터베이스 연결에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8bcc1bfedf61a4d6d2302f5aebd841ed0c31154" translate="yes" xml:space="preserve">
          <source>Changes to CREATE VIRTUAL TABLE statements</source>
          <target state="translated">CREATE VIRTUAL TABLE 문 변경</target>
        </trans-unit>
        <trans-unit id="39b78ad4f8a76dbe4baff285b9df3d3da0888670" translate="yes" xml:space="preserve">
          <source>Changes to SELECT statements</source>
          <target state="translated">SELECT 문 변경</target>
        </trans-unit>
        <trans-unit id="220e3088537dbb26a066213f366f942dc49c0e70" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;../lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거에&lt;/a&gt; 의해 인터셉트 된 뷰에 대한 변경 사항 은 계산되지 않습니다. 뷰에서 INSERT, UPDATE 또는 DELETE 문이 실행 된 직후 sqlite3_changes ()에 의해 리턴 된 값은 항상 0입니다. 실제 테이블에 대한 변경 사항 만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="5d6b66157c1ebd92a27f45e6d4f023a3d4bc6e87" translate="yes" xml:space="preserve">
          <source>Changes to a view that are intercepted by &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF triggers&lt;/a&gt; are not counted. The value returned by sqlite3_changes() immediately after an INSERT, UPDATE or DELETE statement run on a view is always zero. Only changes made to real tables are counted.</source>
          <target state="translated">&lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거에&lt;/a&gt; 의해 인터셉트 된 뷰에 대한 변경 사항 은 계산되지 않습니다. 뷰에서 INSERT, UPDATE 또는 DELETE 문이 실행 된 직후 sqlite3_changes ()에 의해 리턴 된 값은 항상 0입니다. 실제 테이블에 대한 변경 사항 만 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3ac2cb6fb5d947302cd716dd294d872e94891de1" translate="yes" xml:space="preserve">
          <source>Changes to comments.</source>
          <target state="translated">주석 변경.</target>
        </trans-unit>
        <trans-unit id="c84397dcd0da39654544ab29ddec3a05373f0685" translate="yes" xml:space="preserve">
          <source>Changes to compile-time options:</source>
          <target state="translated">컴파일 타임 옵션 변경 :</target>
        </trans-unit>
        <trans-unit id="101e26bd8ffca056c8adaec28f53e8804617dcdd" translate="yes" xml:space="preserve">
          <source>Changes to rows that do not already appear in the changegroup are simply copied into it. Or, if both the new changeset and the changegroup contain changes that apply to a single row, the final contents of the changegroup depends on the type of each change, as follows:</source>
          <target state="translated">변경 그룹에 아직 표시되지 않은 행에 대한 변경 내용은 단순히 해당 그룹에 복사됩니다. 또는 새 변경 세트와 변경 그룹에 단일 행에 적용되는 변경 사항이 포함 된 경우 변경 그룹의 최종 내용은 다음과 같이 각 변경 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3fc8393d45e2f151d9e20c436cc969f753e757c8" translate="yes" xml:space="preserve">
          <source>Changes to some test scripts so that they work on Windows in addition to Unix.</source>
          <target state="translated">Unix 외에도 Windows에서 작동하도록 일부 테스트 스크립트 변경</target>
        </trans-unit>
        <trans-unit id="e4c26ff789d743fb895c4925c581702e142ed6c8" translate="yes" xml:space="preserve">
          <source>Changes to support 64-bit architectures.</source>
          <target state="translated">64 비트 아키텍처를 지원하도록 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e15c1197ceca55511517525b0c74a6a5dfd3ac1" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체로 변경</target>
        </trans-unit>
        <trans-unit id="062c3354f76067d89f734b31e5b499c574c81bb7" translate="yes" xml:space="preserve">
          <source>Changes to the &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; to help it work better when compiled using MSVC.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기&lt;/a&gt; 변경 MSVC를 사용하여 컴파일 할 때 더 잘 작동하도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="d0bc6551b6a2c8af14e74911872297e41927e492" translate="yes" xml:space="preserve">
          <source>Changes to the FULL_COLUMN_NAMES pragma to help out the ODBC driver.</source>
          <target state="translated">ODBC 드라이버를 돕기 위해 FULL_COLUMN_NAMES pragma로 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="7e96fb7803c57c4c013f472a7a7b6294655eae95" translate="yes" xml:space="preserve">
          <source>Changes to the OS-layer interface: mutexes must now be recursive.</source>
          <target state="translated">OS- 계층 인터페이스 변경 : 이제 뮤텍스가 재귀 적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="32f6cdea79e8215becbb15cf7bd7e55cdcee90d2" translate="yes" xml:space="preserve">
          <source>Changes within a patchset are ordered in the same way as for changesets generated by the sqlite3session_changeset() function (i.e. all changes for a single table are grouped together, tables appear in the order in which they were attached to the session object).</source>
          <target state="translated">패치 세트 내 변경 사항은 sqlite3session_changeset () 함수에 의해 생성 된 변경 세트와 동일한 방식으로 정렬됩니다 (즉, 단일 테이블에 대한 모든 변경 사항이 함께 그룹화되고 테이블은 세션 객체에 연결된 순서대로 나타납니다).</target>
        </trans-unit>
        <trans-unit id="da04970767ae72464882ac8a4e16564000ecf171" translate="yes" xml:space="preserve">
          <source>Changes within the local changeset are rebased as follows:</source>
          <target state="translated">로컬 변경 세트 내의 변경 사항은 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="3a336eee124955ea62ce9395beedef4d114ca005" translate="yes" xml:space="preserve">
          <source>Changeset Generation</source>
          <target state="translated">체인지 셋 생성</target>
        </trans-unit>
        <trans-unit id="83360005f23e00ab75cb5a31e370b474e7cda3dd" translate="yes" xml:space="preserve">
          <source>Changeset Iterator Handle</source>
          <target state="translated">체인저 셋 반복자 핸들</target>
        </trans-unit>
        <trans-unit id="e80a51a4aaef4428a67700502b5f7dc75dbd4588" translate="yes" xml:space="preserve">
          <source>Changesets may only be applied to databases that contain tables matching the above three criteria as stored in the changeset.</source>
          <target state="translated">변경 집합은 변경 집합에 저장된 위의 세 가지 기준과 일치하는 테이블이 포함 된 데이터베이스에만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac1c3813780e3748f7f89bcb8cde7110310ebb74" translate="yes" xml:space="preserve">
          <source>Changing Filesystems</source>
          <target state="translated">파일 시스템 변경</target>
        </trans-unit>
        <trans-unit id="5f75f4f19ef2482e0ee092a7ab747ab2b4de6353" translate="yes" xml:space="preserve">
          <source>Changing the &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; while other database connections are open.</source>
          <target state="translated">다른 데이터베이스 연결이 열려있는 동안 &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; 변경</target>
        </trans-unit>
        <trans-unit id="9851972ccfb6ddbbe4682022996c0b7f4c61ad78" translate="yes" xml:space="preserve">
          <source>Changing the data_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the data_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the data_store_directory setting writes to the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">data_store_directory 설정 변경은 스레드로부터 안전 &lt;u&gt;하지 않습니다&lt;/u&gt; . 응용 프로그램 내의 다른 스레드가 동시에 SQLite 인터페이스를 실행중인 경우 data_store_directory 설정을 변경하지 마십시오. 그렇게하면 정의되지 않은 동작이 발생합니다. data_store_directory 설정을 변경하면 &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 전역 변수에 기록되며 해당 전역 변수는 뮤텍스에 의해 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="430a2be1381002d87b9b8ff73223fcbf66c5e87f" translate="yes" xml:space="preserve">
          <source>Changing the foreign_keys setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the foreign_keys setting is changed.</source>
          <target state="translated">foreign_keys 설정을 변경하면 설정이 변경되기 전에 준비된 명령문을 포함하여 데이터베이스 연결을 사용하여 준비된 모든 명령문의 실행에 영향을줍니다. foreign_keys 설정이 변경된 후 레거시 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스를 사용하여 준비된 기존 명령문 은 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e64e5108f8dce99580f41bdd628fb1a43e13fc20" translate="yes" xml:space="preserve">
          <source>Changing the recursive_triggers setting affects the execution of all statements prepared using the database connection, including those prepared before the setting was changed. Any existing statements prepared using the legacy &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; interface may fail with an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error after the recursive_triggers setting is changed.</source>
          <target state="translated">recursive_triggers 설정을 변경하면 설정이 변경되기 전에 준비된 명령문을 포함하여 데이터베이스 연결을 사용하여 준비된 모든 명령문의 실행에 영향을줍니다. recursive_triggers 설정이 변경된 후 레거시 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 인터페이스를 사용하여 준비된 기존 명령문 은 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 와 함께 실패 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="859510e9fde4ba7098039dc9d57957c57590e8ad" translate="yes" xml:space="preserve">
          <source>Changing the temp_store_directory setting is &lt;u&gt;not&lt;/u&gt; threadsafe. Never change the temp_store_directory setting if another thread within the application is running any SQLite interface at the same time. Doing so results in undefined behavior. Changing the temp_store_directory setting writes to the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable and that global variable is not protected by a mutex.</source>
          <target state="translated">temp_store_directory 설정 변경은 스레드로부터 안전 &lt;u&gt;하지 않습니다&lt;/u&gt; . 응용 프로그램 내의 다른 스레드가 동시에 SQLite 인터페이스를 실행중인 경우 temp_store_directory 설정을 변경하지 마십시오. 그렇게하면 정의되지 않은 동작이 발생합니다. temp_store_directory 설정을 변경하면 &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 전역 변수에 기록되며 해당 전역 변수는 뮤텍스에 의해 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a3e8791cfca3d884c74337ea57def9c05ece108" translate="yes" xml:space="preserve">
          <source>Changing the value of this variable while a database connection is open can result in a corrupt database.</source>
          <target state="translated">데이터베이스 연결이 열린 상태에서이 변수의 값을 변경하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="cea842266549b8d9e4991a72c7996837bc0ff6f1" translate="yes" xml:space="preserve">
          <source>Characters in the matchinfo format string are processed from left to right. Each character in the format string causes one or more 32-bit unsigned integer values to be added to the returned array. The &quot;values&quot; column in the following table contains the number of integer values appended to the output buffer for each supported format string character. In the formula given,</source>
          <target state="translated">matchinfo 형식 문자열의 문자는 왼쪽에서 오른쪽으로 처리됩니다. 형식 문자열의 각 문자는 하나 이상의 32 비트 부호없는 정수 값이 반환 된 배열에 추가되도록합니다. 다음 표의 &quot;값&quot;열에는 지원되는 각 형식 문자열 문자의 출력 버퍼에 추가 된 정수 값 수가 포함됩니다. 주어진 공식에서</target>
        </trans-unit>
        <trans-unit id="901d44a58ef0c59ab99643a19134ba47c238ad29" translate="yes" xml:space="preserve">
          <source>Chart 1: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">차트 1 : 직접 파일 시스템 읽기와 관련된 SQLite 읽기 대기 시간</target>
        </trans-unit>
        <trans-unit id="27276d4efc029611aba60cde7d26cce5f51fc924" translate="yes" xml:space="preserve">
          <source>Chart 2: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">차트 2 : 직접 파일 시스템 읽기와 관련된 SQLite 읽기 대기 시간</target>
        </trans-unit>
        <trans-unit id="9b63c13706e018a965e9ad083cf8558f0ea7a319" translate="yes" xml:space="preserve">
          <source>Chart 3: SQLite read latency relative to direct filesystem reads.</source>
          <target state="translated">차트 3 : 직접 파일 시스템 읽기와 관련된 SQLite 읽기 대기 시간</target>
        </trans-unit>
        <trans-unit id="d2affd8c541db58f31c69f6910d1f00260d88617" translate="yes" xml:space="preserve">
          <source>Chart 4: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">차트 4 : 직접 파일 시스템 쓰기와 관련된 SQLite 쓰기 대기 시간.</target>
        </trans-unit>
        <trans-unit id="3ac7623b08d5a3f0968ebaaaf80eef331d89a328" translate="yes" xml:space="preserve">
          <source>Chart 5: SQLite write latency relative to direct filesystem writes.</source>
          <target state="translated">차트 5 : 직접 파일 시스템 쓰기와 관련된 SQLite 쓰기 대기 시간.</target>
        </trans-unit>
        <trans-unit id="145b22ca4b4508601bd80ce10219fd8d551a1cef" translate="yes" xml:space="preserve">
          <source>Chastise the body.</source>
          <target state="translated">시체를 쫓아 라.</target>
        </trans-unit>
        <trans-unit id="0018d2d0130bb05c6b042cf37fbaadc3d3c580d7" translate="yes" xml:space="preserve">
          <source>Check local (non foreign key) constraints,</source>
          <target state="translated">로컬 (외래 키가 아닌) 제약 조건을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="b2b621da54eb725e76b59b6aa64ddca11509ebb6" translate="yes" xml:space="preserve">
          <source>Check the cursor P1 to see if it is currently pointing at a NULL row. If it is, then set register P3 to NULL and jump immediately to P2. If P1 is not on a NULL row, then fall through without making any changes.</source>
          <target state="translated">커서 P1을 점검하여 현재 NULL 행을 가리키는 지 확인하십시오. 그렇다면 레지스터 P3을 NULL로 설정하고 즉시 P2로 점프하십시오. P1이 NULL 행에 없으면 변경하지 않고 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="09e577018637d04e97c17b023b39748cce6a0852" translate="yes" xml:space="preserve">
          <source>Check the value in register P3. If it is NULL then &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; using parameter P1, P2, and P4 as if this were a &lt;a href=&quot;opcode#Halt&quot;&gt;Halt&lt;/a&gt; instruction. If the value in register P3 is not NULL, then this routine is a no-op. The P5 parameter should be 1.</source>
          <target state="translated">레지스터 P3의 값을 확인하십시오. 그 후 NULL이면 &lt;a href=&quot;opcode#Halt&quot;&gt;중지&lt;/a&gt; 이것은 마치 P1, P2 및 P4 파라미터 사용 &lt;a href=&quot;opcode#Halt&quot;&gt;정지를&lt;/a&gt; 지시. 레지스터 P3의 값이 NULL이 아닌 경우이 루틴은 작동하지 않습니다. P5 매개 변수는 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="853e2972eec38f585243beee1676c957c81ad890" translate="yes" xml:space="preserve">
          <source>Check to see if the database file has a hot journal. If the file does not have a hot journal, we are done. Return immediately. If there is a hot journal, that journal must be rolled back by the subsequent steps of this algorithm.</source>
          <target state="translated">데이터베이스 파일에 핫 저널이 있는지 확인하십시오. 파일에 핫 저널이 없으면 완료된 것입니다. 즉시 반납하십시오. 핫 저널이있는 경우이 알고리즘의 후속 단계에서 해당 저널을 롤백해야합니다.</target>
        </trans-unit>
        <trans-unit id="a2f036a3bd46936cd9d2c40c2e45e1005b34f3dd" translate="yes" xml:space="preserve">
          <source>Checklist For Choosing The Right Database Engine</source>
          <target state="translated">올바른 데이터베이스 엔진을 선택하기위한 점검 목록</target>
        </trans-unit>
        <trans-unit id="812e4bd3b7c47c7f81d4167d8aab871141a8c91b" translate="yes" xml:space="preserve">
          <source>Checklists</source>
          <target state="translated">Checklists</target>
        </trans-unit>
        <trans-unit id="5cb9afc05957645058216dd6772ded2e46522ec1" translate="yes" xml:space="preserve">
          <source>Checkpoint</source>
          <target state="translated">Checkpoint</target>
        </trans-unit>
        <trans-unit id="6c8f9631542e10f31e77b7a465542d388b6decdb" translate="yes" xml:space="preserve">
          <source>Checkpoint Information and Locks</source>
          <target state="translated">검사 점 정보 및 잠금</target>
        </trans-unit>
        <trans-unit id="2a00fbbeacd66d1129876c4f2a120582b60dcc8f" translate="yes" xml:space="preserve">
          <source>Checkpoint Mode Values</source>
          <target state="translated">검사 점 모드 값</target>
        </trans-unit>
        <trans-unit id="f8b00f7fe2c53994a3c2e16e9fff90f46c54af6d" translate="yes" xml:space="preserve">
          <source>Checkpoint a database</source>
          <target state="translated">데이터베이스 검사 점</target>
        </trans-unit>
        <trans-unit id="37924a2fe97c6ebb27cab5b2e8b0b2d0894bd2b5" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">데이터베이스 판독기 또는 기록기가 완료 될 때까지 기다리지 않고 가능한 많은 프레임을 체크 포인트 한 다음 로그의 모든 프레임이 체크 포인트 된 경우 데이터베이스 파일을 동기화하십시오. 사용 &lt;a href=&quot;#sqlite3_busy_handler&quot;&gt;중인 핸들러 콜백&lt;/a&gt; 은 SQLITE_CHECKPOINT_PASSIVE 모드에서 호출되지 않습니다. 반면에 패시브 모드는 동시 판독기 또는 기록기가있는 경우 검사 점을 완료하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65bebe73feb47e6a7a12e61f091ce204dad0258a" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish, then sync the database file if all frames in the log were checkpointed. The &lt;a href=&quot;busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in the SQLITE_CHECKPOINT_PASSIVE mode. On the other hand, passive mode might leave the checkpoint unfinished if there are concurrent readers or writers.</source>
          <target state="translated">데이터베이스 판독기 또는 기록기가 완료 될 때까지 기다리지 않고 가능한 많은 프레임을 체크 포인트 한 다음 로그의 모든 프레임이 체크 포인트 된 경우 데이터베이스 파일을 동기화하십시오. 사용 &lt;a href=&quot;busy_handler&quot;&gt;중인 핸들러 콜백&lt;/a&gt; 은 SQLITE_CHECKPOINT_PASSIVE 모드에서 호출되지 않습니다. 반면에 패시브 모드는 동시 판독기 또는 기록기가있는 경우 검사 점을 완료하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11999bbd94b14ea8ec845c4fcad50ea24f0a3d45" translate="yes" xml:space="preserve">
          <source>Checkpoint as many frames as possible without waiting for any database readers or writers to finish. Sync the db file if all frames in the log are checkpointed. This mode is the same as calling the &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; C interface. The &lt;a href=&quot;c3ref/busy_handler&quot;&gt;busy-handler callback&lt;/a&gt; is never invoked in this mode.</source>
          <target state="translated">데이터베이스 판독기 또는 기록기가 완료되기를 기다리지 않고 가능한 많은 프레임을 체크 포인트하십시오. 로그의 모든 프레임이 체크 포인트되면 db 파일을 동기화하십시오. 이 모드는 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; C 인터페이스 를 호출하는 것과 같습니다 . &lt;a href=&quot;c3ref/busy_handler&quot;&gt;바쁜 핸들러 콜백은&lt;/a&gt; 이 모드에서 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4db6d205b349663d744b71f2a117e634b9469124" translate="yes" xml:space="preserve">
          <source>Checkpoint database P1. This is a no-op if P1 is not currently in WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART, or TRUNCATE. Write 1 or 0 into mem[P3] if the checkpoint returns SQLITE_BUSY or not, respectively. Write the number of pages in the WAL after the checkpoint into mem[P3+1] and the number of pages in the WAL that have been checkpointed after the checkpoint completes into mem[P3+2]. However on an error, mem[P3+1] and mem[P3+2] are initialized to -1.</source>
          <target state="translated">체크 포인트 데이터베이스 P1. P1이 현재 WAL 모드에 있지 않으면 이것은 작동하지 않습니다. 매개 변수 P2는 SQLITE_CHECKPOINT_PASSIVE, FULL, RESTART 또는 TRUNCATE 중 하나입니다. 검사 점이 각각 SQLITE_BUSY를 반환하는지 여부를 mem [P3]에 1 또는 0을 씁니다. 검사 점 다음에 WAL의 페이지 수를 mem [P3 + 1]에 기록하고 검사 점이 완료된 후 검사 점에 도달 한 WAL의 페이지 수를 mem [P3 + 2]에 기록하십시오. 그러나 오류가 발생하면 mem [P3 + 1] 및 mem [P3 + 2]가 -1로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="c93c7ed9eb6c55536fc1fa5a09dd161c7c872485" translate="yes" xml:space="preserve">
          <source>Checkpoint sequence number</source>
          <target state="translated">검사 점 시퀀스 번호</target>
        </trans-unit>
        <trans-unit id="73420aa2c87505947c6412ba6601937a69b34e0a" translate="yes" xml:space="preserve">
          <source>Checkpointing does require sync operations in order to avoid the possibility of database corruption following a power loss or hard reboot. The WAL must be synced to persistent storage prior to moving content from the WAL into the database and the database file must by synced prior to resetting the WAL. Checkpoint also requires more seeking. The checkpointer makes an effort to do as many sequential page writes to the database as it can (the pages are transferred from WAL to database in ascending order) but even then there will typically be many seek operations interspersed among the page writes. These factors combine to make checkpoints slower than write transactions.</source>
          <target state="translated">체크 포인트는 전원 손실 또는 하드 재부팅으로 인한 데이터베이스 손상의 가능성을 피하기 위해 동기화 작업이 필요합니다. 콘텐츠를 WAL에서 데이터베이스로 이동하기 전에 WAL을 영구 저장소에 동기화해야하며 WAL을 재설정하기 전에 데이터베이스 파일을 동기화해야합니다. 체크 포인트는 더 많은 탐색이 필요합니다. 검사 점은 데이터베이스에 가능한 많은 순차 페이지 쓰기를 수행하기 위해 노력하지만 (페이지가 WAL에서 데이터베이스로 오름차순으로 전송 됨), 그럼에도 불구하고 일반적으로 페이지 쓰기 사이에 많은 찾기 작업이 분산됩니다. 이러한 요소들이 결합되어 체크 포인트가 쓰기 트랜잭션보다 느려집니다.</target>
        </trans-unit>
        <trans-unit id="13a5691b3271955325bfbd27f548fc8c0c82dfae" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">이 메커니즘에 의해 시작된 체크 포인트는 &lt;a href=&quot;#sqlite3_wal_checkpoint_v2&quot;&gt;수동입니다&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ab8c79d054f22aac4eeb01b5ef4d71f862efa21c" translate="yes" xml:space="preserve">
          <source>Checkpoints initiated by this mechanism are &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;PASSIVE&lt;/a&gt;.</source>
          <target state="translated">이 메커니즘에 의해 시작된 체크 포인트는 &lt;a href=&quot;wal_checkpoint_v2&quot;&gt;수동입니다&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="df9b91c031577503e347c145ff1b0094db4452ef" translate="yes" xml:space="preserve">
          <source>Checks if the &quot;fired&quot; flag has been set. If so, the unlock-notify callback has already been invoked. Release the mutex and continue.</source>
          <target state="translated">&quot;fired&quot;플래그가 설정되어 있는지 확인합니다. 그렇다면 잠금 해제 알림 콜백이 이미 호출되었습니다. 뮤텍스를 풀고 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="d8fcd1cd020581d6d23f7d74cd403fc559263ad5" translate="yes" xml:space="preserve">
          <source>Checksum</source>
          <target state="translated">Checksum</target>
        </trans-unit>
        <trans-unit id="c2d50b4086a2009c1329398de62782c1b322789e" translate="yes" xml:space="preserve">
          <source>Checksum of the last frame in the WAL file.</source>
          <target state="translated">WAL 파일에서 마지막 프레임의 체크섬.</target>
        </trans-unit>
        <trans-unit id="36775ac61bbdc09836e15e4ec7e669eae516b3d3" translate="yes" xml:space="preserve">
          <source>Checksum-1: Cumulative checksum up through and including this page</source>
          <target state="translated">체크섬 -1 :이 페이지를 포함하여 누적 체크섬</target>
        </trans-unit>
        <trans-unit id="0f0241436226dd5ad15b784282d744ddcaf53796" translate="yes" xml:space="preserve">
          <source>Checksum-1: First part of a checksum on the first 24 bytes of header</source>
          <target state="translated">체크섬 -1 : 헤더의 첫 24 바이트에 대한 체크섬의 첫 부분</target>
        </trans-unit>
        <trans-unit id="25d65b4024e29fd560da0ace1eb3f77896847390" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second half of the cumulative checksum.</source>
          <target state="translated">체크섬 -2 : 누적 체크섬의 후반.</target>
        </trans-unit>
        <trans-unit id="abcb92542826823bd4a635495c66df0db032424c" translate="yes" xml:space="preserve">
          <source>Checksum-2: Second part of the checksum on the first 24 bytes of header</source>
          <target state="translated">체크섬 -2 : 헤더의 처음 24 바이트에있는 체크섬의 두 번째 부분</target>
        </trans-unit>
        <trans-unit id="f67c2d32dbe70d2749477ec3873f70b148c33e3f" translate="yes" xml:space="preserve">
          <source>Checksumming only works on databases that have a &lt;a href=&quot;fileformat2#resbyte&quot;&gt;reserve bytes&lt;/a&gt; value of exactly 8. The default value for reserve-bytes is 0. Hence, newly created database files will omit the checksum by default. To create a database that includes a checksum, change the reserve-bytes value to 8 by running code similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6fc2f66d5cb19af415e45034e0124b71cc4cce" translate="yes" xml:space="preserve">
          <source>Cherrypick fixes for other obscure problems found since the 3.30.0 release</source>
          <target state="translated">3.30.0 릴리스 이후 발견 된 다른 모호한 문제에 대한 Cherrypick 수정</target>
        </trans-unit>
        <trans-unit id="38f9d9f26118d80f3d659b4ee2e2b654e7c605c0" translate="yes" xml:space="preserve">
          <source>Choose the column names in a compound query from the left-most SELECT instead of the right-most.</source>
          <target state="translated">가장 오른쪽이 아닌 가장 왼쪽의 SELECT에서 복합 쿼리의 열 이름을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="11cfd2c677994d3ba2e81eb3cb8ff4634809c573" translate="yes" xml:space="preserve">
          <source>Choosing good indexes for each loop</source>
          <target state="translated">각 루프에 적합한 인덱스 선택</target>
        </trans-unit>
        <trans-unit id="070374ff80947b819eb8815e8d492bf0a862577e" translate="yes" xml:space="preserve">
          <source>Chronology</source>
          <target state="translated">Chronology</target>
        </trans-unit>
        <trans-unit id="b104217954a3ac451efc2e2bfb3fdea27198ddd0" translate="yes" xml:space="preserve">
          <source>Cksumvfs is a &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt;. When loaded, &quot;cksmvfs&quot; becomes the new default VFS, and it uses the prior default VFS as the next VFS down in the stack. This is normally what you want. However, in complex situations where multiple VFS shims are being loaded, it might be important to ensure that cksumvfs is loaded in the correct order so that it sequences itself into the default VFS Shim stack in the right order.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d697c3a479d4940e72936c6c5796e737d83de121" translate="yes" xml:space="preserve">
          <source>Clean up comments and variable names. Changes to documentation. No functional changes to the code.</source>
          <target state="translated">주석과 변수 이름을 정리하십시오. 설명서 변경. 코드의 기능 변경이 없습니다.</target>
        </trans-unit>
        <trans-unit id="719ea396ad92e01b4757ec2b93bb1e5f270f771d" translate="yes" xml:space="preserve">
          <source>Clear</source>
          <target state="translated">Clear</target>
        </trans-unit>
        <trans-unit id="7fe36a4f7ea83f99a8ac259b32e3aa3e06a3e0ea" translate="yes" xml:space="preserve">
          <source>Clearly, a hardware or operating system fault that introduces incorrect data into the middle of the database file or journal will cause problems. Likewise, if a rogue process opens a database file or journal and writes malformed data into the middle of it, then the database will become corrupt. There is not much that can be done about these kinds of problems so they are given no further attention.</source>
          <target state="translated">데이터베이스 파일이나 저널의 중간에 잘못된 데이터를 초래하는 하드웨어 또는 운영 체제 결함으로 인해 문제가 발생할 수 있습니다. 마찬가지로, 불량 프로세스가 데이터베이스 파일 또는 저널을 열고 조작 된 데이터를 그 중간에 쓰면 데이터베이스가 손상됩니다. 이러한 종류의 문제에 대해서는 할 수있는 일이 많지 않으므로 더 이상주의를 기울이지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="95490bb933b1b789f5f61256736c0ee3697b1303" translate="yes" xml:space="preserve">
          <source>Client applications typically use a generic database interface that allows connections to various SQL database engines. It makes good sense to include SQLite in the mix of supported databases and to statically link the SQLite engine in with the client. That way the client program can be used standalone with an SQLite data file for testing or for demonstrations.</source>
          <target state="translated">클라이언트 응용 프로그램은 일반적으로 다양한 SQL 데이터베이스 엔진에 연결할 수있는 일반 데이터베이스 인터페이스를 사용합니다. 지원되는 데이터베이스의 혼합에 SQLite를 포함시키고 SQLite 엔진을 클라이언트와 정적으로 링크하는 것이 좋습니다. 이렇게하면 테스트 또는 데모를 위해 클라이언트 프로그램을 SQLite 데이터 파일과 함께 독립형으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525256fa1745ebe5497d79cf726d90129b04804e" translate="yes" xml:space="preserve">
          <source>Client/server SQL database engines strive to implement a shared repository of enterprise data. They emphasize scalability, concurrency, centralization, and control. SQLite strives to provide local data storage for individual applications and devices. SQLite emphasizes economy, efficiency, reliability, independence, and simplicity.</source>
          <target state="translated">클라이언트 / 서버 SQL 데이터베이스 엔진은 엔터프라이즈 데이터의 공유 저장소를 구현하려고 노력합니다. 확장 성, 동시성, 중앙 집중화 및 제어를 강조합니다. SQLite는 개별 응용 프로그램 및 장치에 로컬 데이터 저장소를 제공하기 위해 노력하고 있습니다. SQLite는 경제성, 효율성, 신뢰성, 독립성 및 단순성을 강조합니다.</target>
        </trans-unit>
        <trans-unit id="e1dbee15a55011ce9dd54d220174f35b9020dbef" translate="yes" xml:space="preserve">
          <source>Client/server database engines are designed to live inside a lovingly-attended datacenter at the core of the network. SQLite works there too, but SQLite also thrives at the edge of the network, fending for itself while providing fast and reliable data services to applications that would otherwise have dodgy connectivity.</source>
          <target state="translated">클라이언트 / 서버 데이터베이스 엔진은 네트워크의 핵심에있는 사랑스런 데이터 센터 내부에 살도록 설계되었습니다. SQLite도 작동하지만 SQLite는 네트워크의 가장자리에서 번성하여 연결성이 떨어지는 응용 프로그램에 빠르고 안정적인 데이터 서비스를 제공하면서 스스로를 지키고 있습니다.</target>
        </trans-unit>
        <trans-unit id="63b283ce3f8b364e187012832c04f432c579a52d" translate="yes" xml:space="preserve">
          <source>Client/server databases like MySQL, PostgreSQL, SQL Server, Oracle, and others are an important component of modern systems. These systems solve an important problem. But SQLite solves a different problem. Both SQLite and client/server databases have their role. Developers who are comparing SQLite against other SQL database engines need to clearly understand this distinction.</source>
          <target state="translated">MySQL, PostgreSQL, SQL Server, Oracle 등과 같은 클라이언트 / 서버 데이터베이스는 최신 시스템의 중요한 구성 요소입니다. 이 시스템은 중요한 문제를 해결합니다. 그러나 SQLite는 다른 문제를 해결합니다. SQLite 및 클라이언트 / 서버 데이터베이스 모두 역할이 있습니다. SQLite를 다른 SQL 데이터베이스 엔진과 비교하는 개발자는이 차이점을 명확하게 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="bbfa773e5a63a5ea58c9b6207e608ca0120e592a" translate="yes" xml:space="preserve">
          <source>Close</source>
          <target state="translated">Close</target>
        </trans-unit>
        <trans-unit id="d692c2c202249e9e4fe0069f00e6bff039f0c2b5" translate="yes" xml:space="preserve">
          <source>Close A BLOB Handle</source>
          <target state="translated">BLOB 핸들 닫기</target>
        </trans-unit>
        <trans-unit id="2e50e33188cf1bf73dcb5e4643c391e4e29a00af" translate="yes" xml:space="preserve">
          <source>Close a cursor previously opened as P1. If P1 is not currently open, this instruction is a no-op.</source>
          <target state="translated">이전에 P1으로 열린 커서를 닫습니다. P1이 현재 열려 있지 않으면이 명령은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4d537da92d49358e224a4a747dea32342b05b1" translate="yes" xml:space="preserve">
          <source>Close both cursors.</source>
          <target state="translated">두 커서를 모두 닫습니다.</target>
        </trans-unit>
        <trans-unit id="29aaf7cec2af0b1f202abf31695f4cd37d74e8ff" translate="yes" xml:space="preserve">
          <source>Close the cursor.</source>
          <target state="translated">커서를 닫습니다.</target>
        </trans-unit>
        <trans-unit id="f1ceaea1ade786b6daac7b066c7f274b9fd722f8" translate="yes" xml:space="preserve">
          <source>Closing A Database Connection</source>
          <target state="translated">데이터베이스 연결 닫기</target>
        </trans-unit>
        <trans-unit id="e0046ff4ec6b0abe476379971c2a006ff70bf46c" translate="yes" xml:space="preserve">
          <source>Closing a Connection</source>
          <target state="translated">연결 종료</target>
        </trans-unit>
        <trans-unit id="8661917419fb7cc5ef82c55b2e68e555b2266617" translate="yes" xml:space="preserve">
          <source>Closing a connection.</source>
          <target state="translated">연결을 닫는 중입니다.</target>
        </trans-unit>
        <trans-unit id="db1b559a50c46dcb478b73c9953c212ac94e2736" translate="yes" xml:space="preserve">
          <source>Closing a database connection is a simple matter. The open VFS file-handle is closed and in-memory</source>
          <target state="translated">데이터베이스 연결을 닫는 것은 간단합니다. 열린 VFS 파일 핸들이 닫혀 있고 메모리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c60089a30c51b5540b0120bd48683a09f4c83f6" translate="yes" xml:space="preserve">
          <source>Clothe the naked.</source>
          <target state="translated">알몸을 입으십시오.</target>
        </trans-unit>
        <trans-unit id="bb887cae0ad4591660280c949ded3080d0ff24a8" translate="yes" xml:space="preserve">
          <source>Clustered Indexes and the WITHOUT ROWID Optimization</source>
          <target state="translated">클러스터형 인덱스 및 WITHOUT ROWID 최적화</target>
        </trans-unit>
        <trans-unit id="79a91b7b9e81e75043a22ebed1514d4b90a130a5" translate="yes" xml:space="preserve">
          <source>Clustered indexes</source>
          <target state="translated">클러스터형 인덱스</target>
        </trans-unit>
        <trans-unit id="339841482704071d6be66d22a76e8ac915ed405e" translate="yes" xml:space="preserve">
          <source>Co-routines are better than storing the complete result set of the subquery in a transient table because co-routines use less memory. With a co-routine, only a single row of the result needs to be remembered, whereas all rows of the result must be stored for a transient table. Also, because the co-routine does not need to run to completion before the outer query begins its work, the first rows of output can appear much sooner, and if the overall query is aborted, less work is done overall.</source>
          <target state="translated">코 루틴은 메모리를 덜 사용하기 때문에 서브 쿼리의 전체 결과 세트를 임시 테이블에 저장하는 것보다 코 루틴이 좋습니다. 동시 루틴을 사용하면 결과의 단일 행만 기억해야하지만 결과의 모든 행은 임시 테이블에 저장해야합니다. 또한 외부 쿼리가 작업을 시작하기 전에 코 루틴을 완료하기 위해 실행하지 않아도되므로 첫 번째 출력 행이 훨씬 더 빨리 나타날 수 있으며 전체 쿼리가 중단되면 전체적으로 더 적은 작업이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fd74b2a71394e7ee81bb386b6917d0be84ba18b0" translate="yes" xml:space="preserve">
          <source>Code Generator</source>
          <target state="translated">코드 생성기</target>
        </trans-unit>
        <trans-unit id="47dea711cabe6deab879a9b733dd07b05a63631b" translate="yes" xml:space="preserve">
          <source>Code Of Conduct</source>
          <target state="translated">행동 강령</target>
        </trans-unit>
        <trans-unit id="74e1db16aadf744876e02c6a4f106f1aa7afb651" translate="yes" xml:space="preserve">
          <source>Code Of Ethics</source>
          <target state="translated">윤리 강령</target>
        </trans-unit>
        <trans-unit id="ae87810899e1431de7026ce043d8dda320fed1e7" translate="yes" xml:space="preserve">
          <source>Code change inspection</source>
          <target state="translated">코드 변경 검사</target>
        </trans-unit>
        <trans-unit id="b5a54c50fda17aa53c6eedfc8045f9c24c210470" translate="yes" xml:space="preserve">
          <source>Code changes to compile cleanly using OpenWatcom.</source>
          <target state="translated">OpenWatcom을 사용하여 깨끗하게 컴파일되도록 코드 변경.</target>
        </trans-unit>
        <trans-unit id="478104ea503bb6e0eff3a5e3bdba87d5231ae12a" translate="yes" xml:space="preserve">
          <source>Code optimization and refactoring for improved performance.</source>
          <target state="translated">성능 향상을위한 코드 최적화 및 리팩토링.</target>
        </trans-unit>
        <trans-unit id="c2b53cecb4c71a1d486f72dfb3a0761cddc764ad" translate="yes" xml:space="preserve">
          <source>Coincidentally, that same index is useful for locating the team leader of a particular team:</source>
          <target state="translated">우연히도, 동일한 색인이 특정 팀의 팀 리더를 찾는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d5e560637618ccf843afba6188e722395d88af53" translate="yes" xml:space="preserve">
          <source>CollSeq</source>
          <target state="translated">CollSeq</target>
        </trans-unit>
        <trans-unit id="bdc2214c3a09bee2f36f96131835f28a7049fea6" translate="yes" xml:space="preserve">
          <source>Collating functions only matter when comparing string values. Numeric values are always compared numerically, and BLOBs are always compared byte-by-byte using memcmp().</source>
          <target state="translated">조합 함수는 문자열 값을 비교할 때만 중요합니다. 숫자 값은 항상 숫자로 비교되고 BLOB는 항상 memcmp ()를 사용하여 바이트 단위로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d660ea76dd255d7ad9c4922511054c5e967af78f" translate="yes" xml:space="preserve">
          <source>Collating sequences are used for comparing two text strings. The collating sequence does not change the ordering of NULLs, numbers, or BLOBs, only text.</source>
          <target state="translated">조합 순서는 두 개의 텍스트 문자열을 비교하는 데 사용됩니다. 조합 순서는 텍스트의 NULL, 숫자 또는 BLOB 순서를 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1e254a056c86801f8b560ebd071943f8829e763e" translate="yes" xml:space="preserve">
          <source>Collation Needed Callbacks</source>
          <target state="translated">콜 레이션에 필요한 콜백</target>
        </trans-unit>
        <trans-unit id="e0c052d2751435fee70a8eb47de4eb3956e79de1" translate="yes" xml:space="preserve">
          <source>Collectively, the aPgno entries record the database page number stored in all frames of the WAL file. The aPgno[0] entry on the first hash table records the database page number stored in the very first frame in the WAL file. The aPgno[i] entry from the first hash table is the database page number for the i-th frame in the WAL file. The aPgno[k] entry for the second hash table is the database page number for the (k+4062)-th frame in the WAL file. The aPgno[k] entry for the n-th 32768-byte hash table in the shm file (for n&amp;gt;1) holds the database page number stored in the (k+4062+4096*(n-2))-th frame of the WAL file.</source>
          <target state="translated">종합적으로, aPgno 항목은 WAL 파일의 모든 프레임에 저장된 데이터베이스 페이지 번호를 기록합니다. 첫 번째 해시 테이블의 aPgno [0] 항목은 WAL 파일의 첫 번째 프레임에 저장된 데이터베이스 페이지 번호를 기록합니다. 첫 번째 해시 테이블의 aPgno [i] 항목은 WAL 파일의 i 번째 프레임에 대한 데이터베이스 페이지 번호입니다. 두 번째 해시 테이블의 aPgno [k] 항목은 WAL 파일에서 (k + 4062) 번째 프레임의 데이터베이스 페이지 번호입니다. shm 파일의 n 번째 32768 바이트 해시 테이블에 대한 aPgno [k] 항목 (n&amp;gt; 1의 경우)은 (k + 4062 + 4096 * (n-2)) 번째 프레임에 저장된 데이터베이스 페이지 번호를 보유합니다. WAL 파일의</target>
        </trans-unit>
        <trans-unit id="d2925a5d74339b84bdd408d91b33688b6815af58" translate="yes" xml:space="preserve">
          <source>Colloquially, the Robson proof shows that in order to guarantee breakdown-free operation, any memory allocator must use a memory pool of size &lt;b&gt;N&lt;/b&gt; which exceeds the maximum amount of memory ever used &lt;b&gt;M&lt;/b&gt; by a multiplier that depends on &lt;b&gt;n&lt;/b&gt;, the ratio of the largest to the smallest allocation size. In other words, unless all memory allocations are of exactly the same size (&lt;b&gt;n&lt;/b&gt;=1) then the system needs access to more memory than it will ever use at one time. Furthermore, we see that the amount of surplus memory required grows rapidly as the ratio of largest to smallest allocations increases, and so there is strong incentive to keep all allocations as near to the same size as possible.</source>
          <target state="translated">구어체 적으로 Robson 증거는 고장없는 작동을 보장하기 위해 모든 메모리 할당자가 최대 크기의 비율 &lt;b&gt;n에&lt;/b&gt; 의존하는 승수에 의해 &lt;b&gt;M&lt;/b&gt; 을 사용한 최대 메모리 양을 초과하는 &lt;b&gt;N&lt;/b&gt; 크기의 메모리 풀을 사용해야 함을 보여줍니다. 가장 작은 할당 크기. 다시 말해서, 모든 메모리 할당이 정확히 같은 크기 ( &lt;b&gt;n&lt;/b&gt; = 1) 가 아니라면 시스템은 한 번에 사용하는 것보다 더 많은 메모리에 액세스해야합니다. 또한 가장 큰 할당량과 가장 작은 할당량의 비율이 증가함에 따라 필요한 잉여 메모리의 양이 급격히 증가하므로 모든 할당을 가능한 한 동일한 크기에 가깝게 유지해야하는 동기가 있습니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="65ba00e95e60fb8971e699c771908e7c41d91624" translate="yes" xml:space="preserve">
          <source>Column</source>
          <target state="translated">Column</target>
        </trans-unit>
        <trans-unit id="7457b5eaf3d7bfc87797ee1a1767fe0cb49411af" translate="yes" xml:space="preserve">
          <source>Column Contents</source>
          <target state="translated">열 내용</target>
        </trans-unit>
        <trans-unit id="dc9eb343792aa10d2e4b6816e5d06cae705abefb" translate="yes" xml:space="preserve">
          <source>Column Declared Type</source>
          <target state="translated">열 선언 유형</target>
        </trans-unit>
        <trans-unit id="edbb850ee1e2303abaa75179e5da0bca25a8e6e9" translate="yes" xml:space="preserve">
          <source>Column Definitions</source>
          <target state="translated">열 정의</target>
        </trans-unit>
        <trans-unit id="f0e08cc3301877a460436bcf15d46df904fa1c8f" translate="yes" xml:space="preserve">
          <source>Column Name</source>
          <target state="translated">열 이름</target>
        </trans-unit>
        <trans-unit id="cfbfc51b4b3062caab10bcf86299598910467bc8" translate="yes" xml:space="preserve">
          <source>Column Names In A Result Set</source>
          <target state="translated">결과 집합의 열 이름</target>
        </trans-unit>
        <trans-unit id="2a8d5de5174e3943971a2875266b6881264de3bb" translate="yes" xml:space="preserve">
          <source>Column definition</source>
          <target state="translated">열 정의</target>
        </trans-unit>
        <trans-unit id="087b86714eee3da08b0eea49abe7223a80fbe1f7" translate="yes" xml:space="preserve">
          <source>Column filter queries are not available.</source>
          <target state="translated">열 필터 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1fb21b8e379e9449d53a5880fcc60a3256a75dc9" translate="yes" xml:space="preserve">
          <source>Column filter specifications may also be applied to arbitrary expressions enclosed in parenthesis. In this case the column filter applies to all phrases within the expression. Nested column filter operations may only further restrict the subset of columns matched, they can not be used to re-enable filtered columns. For example:</source>
          <target state="translated">열 필터 사양은 괄호로 묶인 임의의 표현식에도 적용될 수 있습니다. 이 경우 열 필터는 표현식 내의 모든 구에 적용됩니다. 중첩 열 필터 작업은 일치하는 열의 하위 집합 만 추가로 제한 할 수 있으며 필터링 된 열을 다시 활성화하는 데 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cf5932e078596670c3be6928bc34be28df50868" translate="yes" xml:space="preserve">
          <source>Column names in UPDATE statements were case sensitive. This mistake has now been fixed.</source>
          <target state="translated">UPDATE 문의 열 이름은 대소 문자를 구분했습니다. 이 실수는 이제 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="c8e2e6347929b3f4a547cbe78f19fbf98ffe174e" translate="yes" xml:space="preserve">
          <source>Column names in the expressions of a DO UPDATE refer to the original unchanged value of the column, before the attempted INSERT. To use the value that would have been inserted had the constraint not failed, add the special &quot;excluded.&quot; table qualifier to the column name.</source>
          <target state="translated">DO UPDATE 표현식의 열 이름은 INSERT를 시도하기 전에 열의 원래 변경되지 않은 값을 참조합니다. 제약 조건이 실패하지 않았을 때 삽입되었을 값을 사용하려면 특수한 &quot;제외&quot;를 추가하십시오. 테이블 규정자를 열 이름에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="032e3b2732306732c32848d470fa8748f95c6026" translate="yes" xml:space="preserve">
          <source>Column zColumn does not exist,</source>
          <target state="translated">zColumn 열이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce5679997a2153bf86b8f374126d7b829b91fac4" translate="yes" xml:space="preserve">
          <source>Column zColumn is part of an index, PRIMARY KEY or UNIQUE constraint and the blob is being opened for read/write access,</source>
          <target state="translated">zColumn 열은 인덱스, PRIMARY KEY 또는 UNIQUE 제약 조건의 일부이며 읽기 / 쓰기 액세스를 위해 Blob이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="e8afcd3f4d854da704b3aef5efd35d7f5bc218f3" translate="yes" xml:space="preserve">
          <source>Column-separator is an optional column separator string. The default is the ASCII tab character \t.</source>
          <target state="translated">열 분리기는 선택적 열 구분자 문자열입니다. 기본값은 ASCII 탭 문자 \ t입니다.</target>
        </trans-unit>
        <trans-unit id="cf723c59b62a173547c39c3d661c4ee7c240bab1" translate="yes" xml:space="preserve">
          <source>Columns</source>
          <target state="translated">Columns</target>
        </trans-unit>
        <trans-unit id="56b17410d6d1be4171831dc03181ac757a05e7fe" translate="yes" xml:space="preserve">
          <source>Columns of type INTEGER PRIMARY KEY are actually used as the primary key in underlying B-Tree representation of the table.</source>
          <target state="translated">INTEGER PRIMARY KEY 유형의 열은 실제로 테이블의 기본 B- 트리 표현에서 기본 키로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c97a82dbca5a469c866fbcfd4a0a433b2a0bbf3" translate="yes" xml:space="preserve">
          <source>ColumnsUsed</source>
          <target state="translated">ColumnsUsed</target>
        </trans-unit>
        <trans-unit id="7dbd619aad6c366ee15f8ec72b738cda247ce874" translate="yes" xml:space="preserve">
          <source>Combine the implementations of LIKE and GLOB into a single pattern-matching subroutine.</source>
          <target state="translated">LIKE 및 GLOB의 구현을 단일 패턴 일치 서브 루틴으로 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="1f542b583ad5e9c038e3b491fcfbca274b74980c" translate="yes" xml:space="preserve">
          <source>Combining all the code for SQLite into one big file makes SQLite easier to deploy &amp;mdash; there is just one file to keep track of. And because all code is in a single translation unit, compilers can do better inter-procedure optimization resulting in machine code that is between 5% and 10% faster.</source>
          <target state="translated">SQLite의 모든 코드를 하나의 큰 파일로 결합하면 SQLite를보다 쉽게 ​​배포 할 수 있습니다. 추적 할 파일은 하나뿐입니다. 또한 모든 코드가 단일 변환 단위로되어 있기 때문에 컴파일러는보다 나은 절차 간 최적화를 수행하여 기계 코드가 5 %에서 10 % 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="833e395a74a9048d3a6708096c9bceb3c4d61ab8" translate="yes" xml:space="preserve">
          <source>Comes with a standalone &lt;a href=&quot;cli&quot;&gt;command-line interface&lt;/a&gt; (CLI) client that can be used to administer SQLite databases.</source>
          <target state="translated">SQLite 데이터베이스를 관리하는 데 사용할 수 있는 독립형 &lt;a href=&quot;cli&quot;&gt;명령 행 인터페이스&lt;/a&gt; (CLI) 클라이언트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="606ffe665dbeafe4183539a3e178cfb9ca0e425d" translate="yes" xml:space="preserve">
          <source>Command Line Shell For SQLite</source>
          <target state="translated">SQLite 용 명령 줄 셸</target>
        </trans-unit>
        <trans-unit id="fce06e20e5f7f74aacccab40b59b75a56c8f7305" translate="yes" xml:space="preserve">
          <source>Comments</source>
          <target state="translated">Comments</target>
        </trans-unit>
        <trans-unit id="0538dff4886a4148d161292cddf7f24f025bd278" translate="yes" xml:space="preserve">
          <source>Comments are not SQL commands, but can occur within the text of SQL queries passed to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; and related interfaces. Comments are treated as whitespace by the parser. Comments can begin anywhere whitespace can be found, including inside expressions that span multiple lines.</source>
          <target state="translated">주석은 SQL 명령이 아니지만 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 및 관련 인터페이스에 전달 된 SQL 쿼리 텍스트 내에서 발생할 수 있습니다 . 주석은 구문 분석기에서 공백으로 처리됩니다. 주석은 여러 줄에 걸쳐있는 내부 표현식을 포함하여 공백이있는 모든 위치에서 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce2337551468efeca0ed2bee143ae11b7529f35e" translate="yes" xml:space="preserve">
          <source>Comments can appear anywhere whitespace can occur, including inside expressions and in the middle of other SQL statements. Comments do not nest.</source>
          <target state="translated">주석은 내부 표현식 및 다른 SQL 문의 중간을 포함하여 공백이 발생할 수있는 모든 위치에 나타날 수 있습니다. 주석이 중첩되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffc61bb49c86bffaff083a2ed5fcbad20841a45a" translate="yes" xml:space="preserve">
          <source>Commit And Rollback Notification Callbacks</source>
          <target state="translated">커밋 및 롤백 알림 콜백</target>
        </trans-unit>
        <trans-unit id="b67528525c7cbe3a2bdfe091a15601f0cfe434dc" translate="yes" xml:space="preserve">
          <source>Commit the transaction started in step 2.</source>
          <target state="translated">2 단계에서 시작한 트랜잭션을 커미트하십시오.</target>
        </trans-unit>
        <trans-unit id="3e921ad8fb3469be1c1aae1e9c542f259ea843f7" translate="yes" xml:space="preserve">
          <source>Commit the transaction started on step 1 above.</source>
          <target state="translated">위의 1 단계에서 시작된 트랜잭션을 커미트하십시오.</target>
        </trans-unit>
        <trans-unit id="dcb41d75c37afedd19b91ddeac8ef4a861184289" translate="yes" xml:space="preserve">
          <source>Committing a</source>
          <target state="translated">커밋</target>
        </trans-unit>
        <trans-unit id="ca50d239d0c5f707752157b74490a4762cc31cc1" translate="yes" xml:space="preserve">
          <source>Committing a Transaction</source>
          <target state="translated">거래 커밋</target>
        </trans-unit>
        <trans-unit id="a6b2b4078078c94d88c10ba671b8570bcd19b64c" translate="yes" xml:space="preserve">
          <source>Committing a multi-file transaction.</source>
          <target state="translated">다중 파일 트랜잭션 커밋</target>
        </trans-unit>
        <trans-unit id="938c8ff92d76193cdabf706c7c9bd4d6322fdb0d" translate="yes" xml:space="preserve">
          <source>Committing a read-write transaction.</source>
          <target state="translated">읽기-쓰기 트랜잭션을 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="7f07598efa7d083be720757f9b4819e013d7faa3" translate="yes" xml:space="preserve">
          <source>Committing a statement transaction.</source>
          <target state="translated">명세서 거래 커밋.</target>
        </trans-unit>
        <trans-unit id="3d0965b4050b33d43b6f8f1d0b90555ef5b6f358" translate="yes" xml:space="preserve">
          <source>Common Table Expressions or CTEs act like temporary &lt;a href=&quot;lang_createview&quot;&gt;views&lt;/a&gt; that exist only for the duration of a single SQL statement. There are two kinds of common table expressions: &quot;ordinary&quot; and &quot;recursive&quot;. Ordinary common table expressions are helpful for making queries easier to understand by factoring subqueries out of the main SQL statement. Recursive common table expressions provide the ability to do hierarchical or recursive queries of trees and graphs, a capability that is not otherwise available in the SQL language.</source>
          <target state="translated">공통 테이블 표현식 또는 CTE 는 단일 SQL 문 기간 동안 만 존재하는 임시 &lt;a href=&quot;lang_createview&quot;&gt;보기&lt;/a&gt; 처럼 작동 합니다. 공통 테이블 표현식에는 &quot;일반&quot;과 &quot;재귀&quot;의 두 가지 종류가 있습니다. 일반 공통 테이블 표현식은 기본 SQL 문에서 서브 쿼리를 인수 화하여 쿼리를 더 쉽게 이해하는 데 도움이됩니다. 재귀 공통 테이블 표현식은 SQL 언어에서 사용할 수없는 기능인 트리 및 그래프의 계층 적 또는 재귀 쿼리를 수행하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d105cf44d3926289e65c1c83d8e37cb23fd049e" translate="yes" xml:space="preserve">
          <source>Compare</source>
          <target state="translated">Compare</target>
        </trans-unit>
        <trans-unit id="61bf40991dc6cf79e005a417dde1c212c92bf988" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles</source>
          <target state="translated">두 스냅 샷 핸들의 연령 비교</target>
        </trans-unit>
        <trans-unit id="c69b8e330786eb35150cb1cdb917926c81985161" translate="yes" xml:space="preserve">
          <source>Compare the ages of two snapshot handles.</source>
          <target state="translated">두 스냅 샷 핸들의 연령을 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="b7893f36396a39c33c9b065563149f1fc3b7de3a" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)&amp;lt;reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5 store the result of comparison (0 or 1 or NULL) into register P2.</source>
          <target state="translated">레지스터 P1과 P3의 값을 비교하십시오. reg (P3) &amp;lt;reg (P1)이면 주소 P2로 이동하십시오. 또는 SQLITE_STOREP2 플래그가 P5 저장소에 설정된 경우 비교 결과 (0 또는 1 또는 NULL)를 레지스터 P2에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="64f72da6a28852747af852811f0159350ec037fd" translate="yes" xml:space="preserve">
          <source>Compare the values in register P1 and P3. If reg(P3)==reg(P1) then jump to address P2. Or if the SQLITE_STOREP2 flag is set in P5, then store the result of comparison in register P2.</source>
          <target state="translated">레지스터 P1과 P3의 값을 비교하십시오. reg (P3) == reg (P1)이면 주소 P2로 이동하십시오. 또는 SQLITE_STOREP2 플래그가 P5에 설정된 경우 비교 결과를 레지스터 P2에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="716736d76052378cdb4fa2fb220c0af66c296429" translate="yes" xml:space="preserve">
          <source>Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this vector &quot;A&quot;) and in reg(P2)..reg(P2+P3-1) (&quot;B&quot;). Save the result of the comparison for use by the next &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; instruct.</source>
          <target state="translated">reg (P1) .. reg (P1 + P3-1) (이 벡터를 &quot;A&quot;라고 함)와 reg (P2) .. reg (P2 + P3-1) ( &quot;B&quot;)의 레지스터 벡터 두 개를 비교합니다. 다음 &lt;a href=&quot;opcode#Jump&quot;&gt;점프&lt;/a&gt; 명령 에서 사용할 비교 결과를 저장하십시오 .</target>
        </trans-unit>
        <trans-unit id="83d5898be3634e470654cbd85b9deec85a9c9f73" translate="yes" xml:space="preserve">
          <source>Comparison affinity rules</source>
          <target state="translated">선호도 규칙 비교</target>
        </trans-unit>
        <trans-unit id="134badaaa974d64bb5437d6b34d1293f7d86554c" translate="yes" xml:space="preserve">
          <source>Comparison expressions</source>
          <target state="translated">비교 표현</target>
        </trans-unit>
        <trans-unit id="8f31c13dc4b4da5bf8cbe8bac8ef033f779731d8" translate="yes" xml:space="preserve">
          <source>Comparison with fts4</source>
          <target state="translated">fts4와 비교</target>
        </trans-unit>
        <trans-unit id="5d60c7dd62fdcf4abcc61a6a7d335b7117968b4d" translate="yes" xml:space="preserve">
          <source>Compatibility</source>
          <target state="translated">Compatibility</target>
        </trans-unit>
        <trans-unit id="7637a56b8025cf4632b2ae465571d61372b6d40e" translate="yes" xml:space="preserve">
          <source>Compatibility node: Prior to SQLite version 3.28.0 (2019-04-16) only the --update option was supported but that option worked like --insert in that it always reinserted every file regardless of whether or not it had changed.</source>
          <target state="translated">호환성 노드 : SQLite 버전 3.28.0 (2019-04-16) 이전에는 --update 옵션 만 지원되었지만 변경 여부에 관계없이 모든 파일을 항상 다시 삽입한다는 점에서 --insert와 비슷하게 작동했습니다.</target>
        </trans-unit>
        <trans-unit id="633ffa201e66fd459288742adf70c255cf4ddcdc" translate="yes" xml:space="preserve">
          <source>Compile SQLite in an as-delivered configuration, without any special telemetry or debugging options.</source>
          <target state="translated">특별한 원격 측정 또는 디버깅 옵션없이 제공된 구성으로 SQLite를 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="4435f0088179f3879b5ae857aab9a8517a3bf84a" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA = 0&lt;/a&gt; 컴파일 시간 옵션을 사용하여 SQLite를 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="47c942ddb7cb0b2c2a634cd495a4fe44be7c77ab" translate="yes" xml:space="preserve">
          <source>Compile SQLite using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA=0&lt;/a&gt; compile-time option. This make SQLite distrust application-defined functions inside of the schema by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a5b8e5cc0e47f26d2d005f2486e0f5c2a2c206c" translate="yes" xml:space="preserve">
          <source>Compile fts</source>
          <target state="translated">fts 컴파일</target>
        </trans-unit>
        <trans-unit id="107e25274d1b787330bb17ec68cf503455bc4672" translate="yes" xml:space="preserve">
          <source>Compile the SQLite library with the either the compile-time options &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=1&lt;/a&gt; or &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES=2&lt;/a&gt;. Support for 8+3 filenames is not included in SQLite by default because it does introduce some overhead. The overhead is tiny, but even so, we do not want to burden the billions of SQLite applications that do not need 8+3 filename support.</source>
          <target state="translated">컴파일 시간 옵션 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 1&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES = 2&lt;/a&gt; 중 하나를 사용하여 SQLite 라이브러리를 컴파일하십시오 . 8 + 3 파일 이름에 대한 지원은 약간의 오버 헤드를 유발하므로 기본적으로 SQLite에 포함되지 않습니다. 오버 헤드는 작지만 8 + 3 파일 이름 지원이 필요하지 않은 수십억 개의 SQLite 응용 프로그램에 부담을주고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c8149cd52fe785ecf8f59126442a4f04b3761167" translate="yes" xml:space="preserve">
          <source>Compile-Time Authorization Callbacks</source>
          <target state="translated">컴파일 타임 인증 콜백</target>
        </trans-unit>
        <trans-unit id="5ce286997996977a2b237b29a86f8db1efc35204" translate="yes" xml:space="preserve">
          <source>Compile-Time Library Version Numbers</source>
          <target state="translated">컴파일 타임 라이브러리 버전 번호</target>
        </trans-unit>
        <trans-unit id="ab7d35e46c49beab638f326c5a28b5f3ad2b8c85" translate="yes" xml:space="preserve">
          <source>Compile-time Options</source>
          <target state="translated">컴파일 타임 옵션</target>
        </trans-unit>
        <trans-unit id="1453f0519dea087605be7dc19703a1f478ff0ab3" translate="yes" xml:space="preserve">
          <source>Compile-time options OS_UNIX, OS_WIN, OS_OS2, OS_OTHER, and TEMP_STORE have been renamed to include an &quot;SQLITE_&quot; prefix in order to help avoid namespace collisions with application software. The new names of these options are respectively: SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER, and &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt;.</source>
          <target state="translated">컴파일 시간 옵션 OS_UNIX, OS_WIN, OS_OS2, OS_OTHER 및 TEMP_STORE의 이름이 &quot;SQLITE_&quot;접두사를 포함하도록 변경되어 응용 프로그램 소프트웨어와 네임 스페이스 충돌이 발생하지 않도록합니다. 이러한 옵션의 새 이름은 각각 SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, SQLITE_OS_OTHER 및 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b67395ae5988ac5f1079e7140abc23ed771501d4" translate="yes" xml:space="preserve">
          <source>Compile-time options to SQLite are controlled by C-preprocessor macros. SQLite version 3.6.0 changes the names of some of these macros so that all C-preprocessor macros that are specific to SQLite begin with the &quot;SQLITE_&quot; prefix. This is done to reduce the risk of name collisions with other software modules.</source>
          <target state="translated">SQLite에 대한 컴파일 시간 옵션은 C-preprocessor 매크로에 의해 제어됩니다. SQLite 버전 3.6.0은 이러한 매크로 중 일부의 이름을 변경하여 SQLite와 관련된 모든 C 전 처리기 매크로가 &quot;SQLITE_&quot;접두사로 시작되도록합니다. 이것은 다른 소프트웨어 모듈과 이름 충돌의 위험을 줄이기 위해 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="7bfb67af50943c68cc8db4a086f448c070c20b10" translate="yes" xml:space="preserve">
          <source>Compiling An SQL Statement</source>
          <target state="translated">SQL 문 컴파일</target>
        </trans-unit>
        <trans-unit id="5aad775a4fde57c9a7d789da7ebb4f28bacbccb3" translate="yes" xml:space="preserve">
          <source>Compiling Loadable Extensions</source>
          <target state="translated">로드 가능한 확장 컴파일</target>
        </trans-unit>
        <trans-unit id="17dae604367670c84a2179095a23e948fe606538" translate="yes" xml:space="preserve">
          <source>Compiling the CLI</source>
          <target state="translated">CLI 컴파일</target>
        </trans-unit>
        <trans-unit id="42bc083c37979291f51503e346021e5adf7ef736" translate="yes" xml:space="preserve">
          <source>Compiling the TCL interface</source>
          <target state="translated">TCL 인터페이스 컴파일</target>
        </trans-unit>
        <trans-unit id="f6b7336de511d34be1007604b55dc1686fbabd26" translate="yes" xml:space="preserve">
          <source>Compiling with GCC and -Os results in a binary that is slightly less than 500KB in size. (Update 2018-07-07: Due to the addition of new features such as &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; and &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;, the library footprint is now slightly larger than 500KB.)</source>
          <target state="translated">GCC 및 -Os로 컴파일하면 크기가 500KB보다 약간 작은 이진 파일이 생성됩니다. (업데이트 2018-07-07 : &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt; 및 &lt;a href=&quot;windowfunctions&quot;&gt;창 기능&lt;/a&gt; 과 같은 새로운 기능이 추가 되었기 때문에 라이브러리 공간이 500KB보다 약간 큽니다.)</target>
        </trans-unit>
        <trans-unit id="016600cc08f9b09c5ede26e00051860d386d3258" translate="yes" xml:space="preserve">
          <source>Completely disable all mutexing for use in single-threaded applications.</source>
          <target state="translated">단일 스레드 응용 프로그램에서 사용할 수 있도록 모든 뮤텍스를 완전히 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="92cab31e763f04f0a9379d06fa22ebdf435b210d" translate="yes" xml:space="preserve">
          <source>Completion = 100% * (pagecount() - remaining()) / pagecount()</source>
          <target state="translated">완료 = 100 % * (pagecount ()-나머지 ()) / pagecount ()</target>
        </trans-unit>
        <trans-unit id="0e8198cb08e14211a17b2113a2bd05ad2475de6d" translate="yes" xml:space="preserve">
          <source>Complex SQL queries that compile down to large &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;준비된&lt;/a&gt; 큰 문장으로 컴파일하는 복잡한 SQL 쿼리 .</target>
        </trans-unit>
        <trans-unit id="2a71a43f0af5e946760833a731194bc756332728" translate="yes" xml:space="preserve">
          <source>Component tables must not be declared WITHOUT ROWID, and must all have the same schema, but may have different names within their databases. In this context, &quot;the same schema&quot; means that:</source>
          <target state="translated">구성 요소 테이블은 ROWID없이 선언되어서는 안되며 모두 동일한 스키마를 가져야하지만 데이터베이스 내에서 이름이 다를 수 있습니다. 이 문맥에서 &quot;동일한 스키마&quot;는 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="73fefbebc7ea5875c1b1def30f50ddaec200fca3" translate="yes" xml:space="preserve">
          <source>Compound SELECT Statements</source>
          <target state="translated">복합 SELECT 문</target>
        </trans-unit>
        <trans-unit id="fc1dbf04d5c2c01646f4f6f5a41a610a2c9e6452" translate="yes" xml:space="preserve">
          <source>Compound SELECT statements joined by UNION, EXCEPT, or INTERSECT</source>
          <target state="translated">UNION, EXCEPT 또는 INTERSECT로 결합 된 복합 SELECT 문</target>
        </trans-unit>
        <trans-unit id="b777b90633cd6198da59fc74556aaf318e15c82b" translate="yes" xml:space="preserve">
          <source>Compound Select Statements</source>
          <target state="translated">복합 선택문</target>
        </trans-unit>
        <trans-unit id="41afde278d24cef38341e9c639a6f290a66a33e9" translate="yes" xml:space="preserve">
          <source>Compound select</source>
          <target state="translated">복합 선택</target>
        </trans-unit>
        <trans-unit id="e99b67d469ceb0e0903f3fdb83544c4883bac6aa" translate="yes" xml:space="preserve">
          <source>Compressed FTS4 content</source>
          <target state="translated">압축 된 FTS4 내용</target>
        </trans-unit>
        <trans-unit id="d750266cb42e04add18c2049e2c2458292889a29" translate="yes" xml:space="preserve">
          <source>Compute all columns for the current row of the result.</source>
          <target state="translated">결과의 현재 행에 대한 모든 열을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="83c78585de25cd96c1c2ab80c2c2412af55dbfdf" translate="yes" xml:space="preserve">
          <source>Compute the Mandelbrot set</source>
          <target state="translated">만델 브로트 세트 계산</target>
        </trans-unit>
        <trans-unit id="b448f9527d237644e1fc4a194d188e6a4b4d1334" translate="yes" xml:space="preserve">
          <source>Compute the current date.</source>
          <target state="translated">현재 날짜를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="41873a1f5500f4b614234079571f3016e43ab82f" translate="yes" xml:space="preserve">
          <source>Compute the current unix timestamp.</source>
          <target state="translated">현재 유닉스 타임 스탬프를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e04bc35c7b102a71d56a8c32d3bd5fac01970545" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466, and compensate for your local timezone.</source>
          <target state="translated">유닉스 타임 스탬프 1092941466이 주어진 날짜와 시간을 계산하고 현지 시간대를 보상하십시오.</target>
        </trans-unit>
        <trans-unit id="a79ce5022e7222955180721f104a747e76cc865d" translate="yes" xml:space="preserve">
          <source>Compute the date and time given a unix timestamp 1092941466.</source>
          <target state="translated">유닉스 타임 스탬프 1092941466이 주어진 날짜와 시간을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="876432c3d5981b5bb35c00fb0bc71a0643cea495" translate="yes" xml:space="preserve">
          <source>Compute the date of the first Tuesday in October for the current year.</source>
          <target state="translated">현재 연도의 10 월 첫 번째 화요일 날짜를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="85e08c9c66c5c14d3d7f7fdaf91b03031363b7fc" translate="yes" xml:space="preserve">
          <source>Compute the hash value: h = P * 383</source>
          <target state="translated">해시 값을 계산합니다. h = P * 383</target>
        </trans-unit>
        <trans-unit id="7548a41024e6603fd25f9fadf45476eb046bf623" translate="yes" xml:space="preserve">
          <source>Compute the last day of the current month.</source>
          <target state="translated">현재 달의 마지막 날을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1c0a0d1208aea03d34c1fcb88dbad15854e8464f" translate="yes" xml:space="preserve">
          <source>Compute the number of days since the signing of the US Declaration of Independence.</source>
          <target state="translated">미국 독립 선언서에 서명 한 후 일 수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="5d82004a2aadc6ec6baebba8982b8bfbd8ed18a8" translate="yes" xml:space="preserve">
          <source>Compute the number of seconds since a particular moment in 2004:</source>
          <target state="translated">2004 년 특정 시점 이후의 시간 (초)을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="9240e490f170f5bfe9b5ac2684f082567e717920" translate="yes" xml:space="preserve">
          <source>Compute the remainder after integer register P2 is divided by register P1 and store the result in register P3. If the value in register P1 is zero the result is NULL. If either operand is NULL, the result is NULL.</source>
          <target state="translated">정수 레지스터 P2를 레지스터 P1로 나눈 후 나머지를 계산하고 결과를 레지스터 P3에 저장합니다. 레지스터 P1의 값이 0이면 결과는 NULL입니다. 피연산자 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="f47380023b575b27550d43814811cc725e477ad2" translate="yes" xml:space="preserve">
          <source>Compute the time since the unix epoch in seconds (like strftime('%s','now') except includes fractional part):</source>
          <target state="translated">유닉스 시대 이후 초 단위로 시간을 계산하십시오 (분수 부분을 포함하지 않는 strftime ( '% s', 'now')).</target>
        </trans-unit>
        <trans-unit id="e144db42c7fe7841a847f92a642087b247050e3f" translate="yes" xml:space="preserve">
          <source>Compute the transitive closure of a set.</source>
          <target state="translated">세트의 전이 폐쇄를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6ad79ab6353b1eee8ebbc085e10d17c4fcfb024f" translate="yes" xml:space="preserve">
          <source>Concat</source>
          <target state="translated">Concat</target>
        </trans-unit>
        <trans-unit id="bbae6853fb6e0fd40e4ce00a77adbb0072630198" translate="yes" xml:space="preserve">
          <source>Concatenate Two Changeset Objects</source>
          <target state="translated">두 개의 Changeset 객체 연결</target>
        </trans-unit>
        <trans-unit id="dbcb0f9023d09dcdfc6e54ecf5de70332ecf46a5" translate="yes" xml:space="preserve">
          <source>Conceptually, the wal-index is shared memory, though the current VFS implementations use a memory-mapped file for operating-system portability. The memory-mapped file is in the same directory as the database and has the same name as the database with a &quot;&lt;code&gt;-shm&lt;/code&gt;&quot; suffix appended. Because the wal-index is shared memory, SQLite does not support &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=WAL&lt;/a&gt; on a network filesystem when clients are on different machines, as all clients of the database must be able to share the same memory.</source>
          <target state="translated">현재 VFS 구현에서는 운영 체제 이식성을 위해 메모리 매핑 된 파일을 사용하지만 개념적으로 wal-index는 공유 메모리입니다. 메모리 매핑 된 파일은 데이터베이스와 동일한 디렉토리에 있으며 접미사 가 &quot; &lt;code&gt;-shm&lt;/code&gt; &quot;인 데이터베이스와 이름이 같습니다 . wal-index는 공유 메모리이므로 데이터베이스의 모든 클라이언트가 동일한 메모리를 공유 할 수 있어야하기 때문에 클라이언트가 다른 시스템에있을 때 SQLite는 네트워크 파일 시스템에서 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = WAL&lt;/a&gt; 을 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="49b7441ed47d615d68b5fa69e66989fb88012252" translate="yes" xml:space="preserve">
          <source>Conceptually, there is just a single DELETE-mode lock. The DELETE-mode lock for a single database connection can be in exactly one of the following states:</source>
          <target state="translated">개념적으로 단일 삭제 모드 잠금이 있습니다. 단일 데이터베이스 연결에 대한 DELETE 모드 잠금은 다음 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7a3f4c2c7a172166630a7d362c10fe1d0fc91c29" translate="yes" xml:space="preserve">
          <source>Concurrent Use By Multiple Processes</source>
          <target state="translated">여러 프로세스에 의한 동시 사용</target>
        </trans-unit>
        <trans-unit id="eef82957c155636f622355147508a53bea076447" translate="yes" xml:space="preserve">
          <source>Configurable edit distances</source>
          <target state="translated">구성 가능한 편집 거리</target>
        </trans-unit>
        <trans-unit id="b8577c99aaca7f628cb921ee68fce4bf962909c4" translate="yes" xml:space="preserve">
          <source>Configuration Options</source>
          <target state="translated">구성 옵션</target>
        </trans-unit>
        <trans-unit id="e6080fcd15996fc8da790077d2f333df934dd233" translate="yes" xml:space="preserve">
          <source>Configuration continues to use the SQLITE_DBCONFIG_LOOKASIDE or SQLITE_CONFIG_LOOKASIDE configuration options, as described above, with parameters &quot;sz&quot; and &quot;cnt&quot;. The total heap space used for lookaside continues to be sz*cnt bytes. But the space is allocated between the small-slot lookaside and big-slot lookaside, with preference given to small-slot lookaside. The total number of slots will usually exceed &quot;cnt&quot;, since &quot;sz&quot; is typically much larger than the small-slot size of 128 bytes.</source>
          <target state="translated">구성은 위에서 설명한대로 매개 변수 &quot;sz&quot;및 &quot;cnt&quot;와 함께 SQLITE_DBCONFIG_LOOKASIDE 또는 SQLITE_CONFIG_LOOKASIDE 구성 옵션을 계속 사용합니다. lookaside에 사용되는 총 힙 공간은 계속해서 sz * cnt 바이트입니다. 그러나 공간은 작은 슬롯 lookaside와 big-slot lookaside 사이에 할당되며, small-slot lookaside가 선호됩니다. &quot;sz&quot;는 일반적으로 128 바이트의 작은 슬롯 크기보다 훨씬 크기 때문에 총 슬롯 수는 일반적으로 &quot;cnt&quot;를 초과합니다.</target>
        </trans-unit>
        <trans-unit id="5d3a088dea7acb9fc65cbb6e86dc351c6aa1d47c" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object</source>
          <target state="translated">체인지 셋 리바 저 객체 구성</target>
        </trans-unit>
        <trans-unit id="c2e506c363291ec2edbc4c00e46f58bf68ba2d4e" translate="yes" xml:space="preserve">
          <source>Configure a changeset rebaser object.</source>
          <target state="translated">체인지 셋 리바 저 객체를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="1cfd39d93ce243f8209e2cb0fd6a72bd5199a441" translate="yes" xml:space="preserve">
          <source>Configure an auto-checkpoint</source>
          <target state="translated">자동 검사 점 구성</target>
        </trans-unit>
        <trans-unit id="5cda84f2fffb92ec6200fae3e17f21d369027339" translate="yes" xml:space="preserve">
          <source>Configure database connections</source>
          <target state="translated">데이터베이스 연결 구성</target>
        </trans-unit>
        <trans-unit id="9104fdd73ba3ec2b0c456f6d3cca5876e340e73f" translate="yes" xml:space="preserve">
          <source>Configure global parameters</source>
          <target state="translated">글로벌 매개 변수 구성</target>
        </trans-unit>
        <trans-unit id="fffa5ae7207c4ce72ae9a5c16488369d68b30ee7" translate="yes" xml:space="preserve">
          <source>Configure the changeset rebaser object to rebase changesets according to the conflict resolutions described by buffer pRebase (size nRebase bytes), which must have been obtained from a previous call to sqlite3changeset_apply_v2().</source>
          <target state="translated">sqlite3changeset_apply_v2 ()에 대한 이전 호출에서 얻은 버퍼 pRebase (크기 nRebase 바이트)에 설명 된 충돌 해결에 따라 변경 세트를 리베이스하도록 변경 세트 리저 저 오브젝트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="037fffb22a00fbc77fceb8bfd136c7237a83b229" translate="yes" xml:space="preserve">
          <source>Configuring Memory-Mapped I/O</source>
          <target state="translated">메모리 매핑 된 I / O 구성</target>
        </trans-unit>
        <trans-unit id="9d3bc7d832ae044f63c47a2f9e7fae292f78d77f" translate="yes" xml:space="preserve">
          <source>Configuring The SQLite Library</source>
          <target state="translated">SQLite 라이브러리 구성</target>
        </trans-unit>
        <trans-unit id="3479acef100487d6ec8205ddc884e90381568fa7" translate="yes" xml:space="preserve">
          <source>Configuring an ON UPDATE or ON DELETE action does not mean that the foreign key constraint does not need to be satisfied. For example, if an &quot;ON DELETE SET DEFAULT&quot; action is configured, but there is no row in the parent table that corresponds to the default values of the child key columns, deleting a parent key while dependent child keys exist still causes a foreign key violation. For example:</source>
          <target state="translated">ON UPDATE 또는 ON DELETE 작업을 구성한다고해서 외래 키 제약 조건을 만족할 필요는 없습니다. 예를 들어, &quot;ON DELETE SET DEFAULT&quot;조치가 구성되어 있지만 상위 테이블에 하위 키 열의 기본값에 해당하는 행이없는 경우 종속 하위 키가 존재하는 동안 상위 키를 삭제하면 여전히 외부 키가 발생합니다. 위반. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="377ada5c437e4e8ecbb86b359c764c7d510c3e88" translate="yes" xml:space="preserve">
          <source>Conflict Resolution Algorithms</source>
          <target state="translated">갈등 해결 알고리즘</target>
        </trans-unit>
        <trans-unit id="8975355354bcb513bcd2981e89b88a2159127a86" translate="yes" xml:space="preserve">
          <source>Conflict resolution modes</source>
          <target state="translated">충돌 해결 모드</target>
        </trans-unit>
        <trans-unit id="9658bf354692dbe100fe5694b8f321b7b117d4a0" translate="yes" xml:space="preserve">
          <source>Conflict-algorithm must be one of the SQLite conflict algorithms for the INSERT statement:</source>
          <target state="translated">충돌 알고리즘은 INSERT 문에 대한 SQLite 충돌 알고리즘 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="af76481a91ddbca2a009d9ab58cd9c8e2ed5ef31" translate="yes" xml:space="preserve">
          <source>Connections hold an exclusive lock when change in between WAL mode and any of the various rollback-modes. Connections might also attempt to obtain an EXCLUSIVE lock when they disconnect from WAL mode. If a connection is able to obtain an EXCLUSIVE lock, that means it is the only connection to the database and so it may attempt to checkpoint and then delete the WAL-index and WAL files.</source>
          <target state="translated">연결은 WAL 모드와 다양한 롤백 모드 사이에서 변경 될 때 독점 잠금을 유지합니다. 연결이 WAL 모드에서 연결을 끊을 때 독점 잠금을 얻으려고 시도 할 수도 있습니다. 연결이 독점 잠금을 확보 할 수있는 경우 이는 데이터베이스에 대한 유일한 연결이므로 검사 점을 시도한 다음 WAL 색인 및 WAL 파일을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec1d9b262374bdba4b3ad5a6350b6ef2fd31b30" translate="yes" xml:space="preserve">
          <source>Consider a different database with &quot;CREATE TABLE big(json JSON)&quot;. To see a complete line-by-line decomposition of the data:</source>
          <target state="translated">&quot;CREATE TABLE big (json JSON)&quot;이있는 다른 데이터베이스를 고려하십시오. 데이터의 완전한 라인 별 분해를 보려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="89d5e40d39c9d5acb3a34ddf23480e47ca55947d" translate="yes" xml:space="preserve">
          <source>Consider a slightly different scenario:</source>
          <target state="translated">약간 다른 시나리오를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c5d0d6c9988bc87a91e1eceb2b1190187ebda45c" translate="yes" xml:space="preserve">
          <source>Consider a table (shown below) intended to store a vocabulary of words together with a count of the number of occurrences of each word in some text corpus:</source>
          <target state="translated">일부 단어 모음에서 각 단어의 발생 횟수와 함께 단어의 어휘를 저장하기위한 표 (아래 그림 참조)를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8ec68a1b2150a873bc929bf5c86810425d54b691" translate="yes" xml:space="preserve">
          <source>Consider a table such as the following:</source>
          <target state="translated">다음과 같은 테이블을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="163f9a2c7a0b11befe42d8af38ac3f4e6b7bc949" translate="yes" xml:space="preserve">
          <source>Consider a table that describes the members of an organization as well as the chain-of-command within that organization:</source>
          <target state="translated">조직의 구성원과 해당 조직 내의 명령 체인을 설명하는 표를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="4d89aaebca400a1430435ad2d544ef0799645f0e" translate="yes" xml:space="preserve">
          <source>Consider an example. Suppose you are trying to insert a string value into a database table where the string value was obtained from user input. Suppose the string to be inserted is stored in a variable named zString. The code to do the insertion might look like this:</source>
          <target state="translated">예를 고려하십시오. 문자열 값을 사용자 입력에서 얻은 데이터베이스 테이블에 문자열 값을 삽입하려고한다고 가정하십시오. 삽입 할 문자열이 zString이라는 변수에 저장되었다고 가정하십시오. 삽입을 수행하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="968f255a5a54f60fb698955e4fcb28ea4353bc5f" translate="yes" xml:space="preserve">
          <source>Consider explicit collate clauses when matching WHERE constraints to indices in the query optimizer. Ticket #2391</source>
          <target state="translated">쿼리 최적화 프로그램에서 WHERE 제약 조건을 인덱스와 일치시킬 때 명시 적 대조 절을 고려하십시오. 티켓 # 2391</target>
        </trans-unit>
        <trans-unit id="444e122b76db00a9b4c3d12c64b80faed572e3e1" translate="yes" xml:space="preserve">
          <source>Consider how this query works. The initial-select runs first and returns a single row with a single column &quot;1&quot;. This one row is added to the queue. In step 2a, that one row is extracted from the queue and added to &quot;cnt&quot;. Then the recursive-select is run in accordance with step 2c generating a single new row with value &quot;2&quot; to add to the queue. The queue still has one row, so step 2 repeats. The &quot;2&quot; row is extracted and added to the recursive table by steps 2a and 2b. Then the row containing 2 is used as if it were the complete content of the recursive table and the recursive-select is run again, resulting in a row with value &quot;3&quot; being added to the queue. This repeats 999999 times until finally at step 2a the only value on the queue is a row containing 1000000. That row is extracted and added to the recursive table. But this time, the WHERE clause causes the recursive-select to return no rows, so the queue remains empty and the recursion stops.</source>
          <target state="translated">이 쿼리의 작동 방식을 고려하십시오. 초기 선택은 먼저 실행되고 단일 열 &quot;1&quot;을 가진 단일 행을 반환합니다. 이 한 행이 대기열에 추가됩니다. 단계 2a에서, 하나의 행이 큐로부터 추출되어 &quot;cnt&quot;에 추가된다. 그런 다음, 단계 2c에 따라 재귀 선택이 실행되어 &quot;2&quot;값을 갖는 단일의 새로운 행이 큐에 추가된다. 대기열에는 여전히 하나의 행이 있으므로 2 단계가 반복됩니다. &quot;2&quot;행이 추출되어 단계 2a 및 2b에 의해 재귀 테이블에 추가된다. 그런 다음 2를 포함하는 행은 재귀 테이블의 전체 내용 인 것처럼 사용되며 재귀 선택이 다시 실행되어 값이 &quot;3&quot;인 행이 큐에 추가됩니다. 마지막으로 2a 단계에서 큐의 유일한 값은 1000000을 포함하는 행입니다.해당 행이 추출되어 재귀 테이블에 추가됩니다. 그러나 이번에는 WHERE 절로 인해 재귀 선택이 행을 반환하지 않으므로 큐가 비어 있고 재귀가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="f8fa74d8815f89442ddf62f70a180b631fe1665c" translate="yes" xml:space="preserve">
          <source>Consider querying this table to find the number of occurrences of the word &quot;xyzzy&quot;.:</source>
          <target state="translated">단어 &quot;xyzzy&quot;의 발생 횟수를 찾으려면이 테이블을 쿼리하십시오. :</target>
        </trans-unit>
        <trans-unit id="8e332dd9034fe99b489d4794d57d3e6f28bfd9ef" translate="yes" xml:space="preserve">
          <source>Consider the following SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e890ad26c51af96d02d41774ffeaa333b700b830" translate="yes" xml:space="preserve">
          <source>Consider the following two command sequences:</source>
          <target state="translated">다음 두 명령 순서를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="38f2ce12e9214d8cde3ab5b6d1808e89b342965a" translate="yes" xml:space="preserve">
          <source>Consider using the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to limit the scope of SQL that will be processed. For example, an application that does not need to change the database schema might add an sqlite3_set_authorizer() callback that causes any CREATE or DROP statement to fail.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 처리 할 SQL 범위를 제한하십시오. 예를 들어, 데이터베이스 스키마를 변경할 필요가없는 응용 프로그램은 sqlite3_set_authorizer () 콜백을 추가하여 CREATE 또는 DROP 문이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f881ec6e1c51116405b7bd7506d06d9368faea1" translate="yes" xml:space="preserve">
          <source>Consider what would happen if disk sector writes are interrupted by a power loss. If an application writes two or three bytes in the middle of some file, the operating system will implement this by first reading the entire sector containing those bytes, making the change to the sector in memory, then writing the entire sector back to the disk. If a power loss occurs during the writeback and the sector was not completely written, then on the next read after reboot, error correcting codes in the sector will probably detect irreparable damage and the disk controller will read out the sector as all zeros or all ones. Thus values will have changed outside of the range of the two or three bytes that were written at the application level - a violation of the powersafe overwrite property.</source>
          <target state="translated">전원 손실로 인해 디스크 섹터 쓰기가 중단되면 어떻게 될지 고려하십시오. 응용 프로그램이 일부 파일 중간에 2 바이트 또는 3 바이트를 쓰면 운영 체제는 먼저 해당 바이트가 포함 된 전체 섹터를 읽고 메모리의 섹터를 변경 한 다음 전체 섹터를 디스크에 다시 써서이를 구현합니다. 다시 쓰기 도중 전원 손실이 발생하고 섹터가 완전히 기록되지 않은 경우 재부팅 후 다음에 읽을 때 섹터의 오류 수정 코드는 복구 할 수없는 손상을 감지하고 디스크 컨트롤러는 섹터를 모두 0 또는 모두 1로 읽습니다. . 따라서 값은 응용 프로그램 수준에서 작성된 2 바이트 또는 3 바이트 범위를 벗어나서 변경됩니다 (powersafe 덮어 쓰기 속성 위반).</target>
        </trans-unit>
        <trans-unit id="454478261b68992469d64496e9cfb5f053cfbed3" translate="yes" xml:space="preserve">
          <source>Console the sorrowing.</source>
          <target state="translated">슬픔을 콘솔.</target>
        </trans-unit>
        <trans-unit id="c51c1399ff5b435aa7c4c51efe988981e74f0189" translate="yes" xml:space="preserve">
          <source>Constant value 0.</source>
          <target state="translated">상수 값 0</target>
        </trans-unit>
        <trans-unit id="f14defda3a0615f9817e1062360bb6f9e7654bb6" translate="yes" xml:space="preserve">
          <source>Constant value 1. This field is omitted for any term-offset list associated with column 0.</source>
          <target state="translated">상수 값 1.이 필드는 열 0과 관련된 모든 용어 오프셋 목록에 대해 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="f7d639ba9c48f5467c4d1a8f0152a2dc90222051" translate="yes" xml:space="preserve">
          <source>Constants Defining Special Destructor Behavior</source>
          <target state="translated">특수 소멸자 동작을 정의하는 상수</target>
        </trans-unit>
        <trans-unit id="af7e74633bc458147e8d5da16df8562d003b392e" translate="yes" xml:space="preserve">
          <source>Constants Passed To The Conflict Handler</source>
          <target state="translated">충돌 처리기에 전달 된 상수</target>
        </trans-unit>
        <trans-unit id="aa0aeb15b7dcd6d473c7d1bf166a40ca61fee668" translate="yes" xml:space="preserve">
          <source>Constants Returned By The Conflict Handler</source>
          <target state="translated">충돌 처리기에서 반환하는 상수</target>
        </trans-unit>
        <trans-unit id="6337f09e95dde3b3b58675d8b6f0257adf22ba40" translate="yes" xml:space="preserve">
          <source>Constants:</source>
          <target state="translated">Constants:</target>
        </trans-unit>
        <trans-unit id="f37e46006a1745cf96ebe1f73c1de5744dcf1d1d" translate="yes" xml:space="preserve">
          <source>Constraint Conflict Resolution in SQLite</source>
          <target state="translated">SQLite의 제약 조건 충돌 해결</target>
        </trans-unit>
        <trans-unit id="6889aa68d48cec7c8c38bf28801d4701520ff0dc" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a878fca8a43e71d4ec596dfa4ec029c0c81a75d0" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a2c5628cdcd91822efac04edcb216499727358f" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1cdc0adde4d7b415af1d0d33bde5ec5e8f55638" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d43a93e241e64f205e9be40e6849d360ecb314d2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06e9fffe66b7ccd965b3d8281c4189b6873e699b" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e898f79bdd10cd47ee3054a83ab75f61437a7aa4" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08db86cfe6351f2012dbf46992a9fa7d1631a5e2" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;sqlite3changegroup_new&quot;&gt;sqlite3changegroup_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38014e350b2ec610dc63ea6835bc8bf20566c178" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;sqlite3session_create&quot;&gt;sqlite3session_create ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f94c6d14960e90153f9e56ef05e080f43ace38fd" translate="yes" xml:space="preserve">
          <source>Constructor: &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;str_new&quot;&gt;sqlite3_str_new ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3617dc14ae8be730219fa2aabd32aaa900ccfc3a" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2da4ffc9b2e344254d3be3ef8d1b5463c6c55d3" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b84725656dbaa01e32202bf862175e15f3aa743" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open16()&lt;/a&gt;, &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; , &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63842448f26d096823a3c51f076ae6fb704d1709" translate="yes" xml:space="preserve">
          <source>Constructors: &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt;</source>
          <target state="translated">생성자 : &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e8adbf806de9adae308cb1a722a2834efb03d01" translate="yes" xml:space="preserve">
          <source>Contains the actual data inserted into the FTS5 table. This shadow table is not present for &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless&lt;/a&gt; or &lt;a href=&quot;fts5#external_content_tables&quot;&gt;external content&lt;/a&gt; FTS5 tables.</source>
          <target state="translated">FTS5 테이블에 삽입 된 실제 데이터를 포함합니다. 이 그림자 테이블에 존재하지 않는 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는&lt;/a&gt; 또는 &lt;a href=&quot;fts5#external_content_tables&quot;&gt;외부 콘텐츠&lt;/a&gt; FTS5 테이블.</target>
        </trans-unit>
        <trans-unit id="6773795897579cbc7647c6d1ac1d4b8bc25387d4" translate="yes" xml:space="preserve">
          <source>Contains the size of each column of each row in the virtual table in tokens. This shadow table is not present if the &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot; option&lt;/a&gt; is set to 0.</source>
          <target state="translated">가상 테이블에있는 각 행의 각 열 크기를 토큰으로 포함합니다. &lt;a href=&quot;fts5#the_columnsize_option&quot;&gt;&quot;columnsize&quot;옵션&lt;/a&gt; 이 0으로 설정된 경우이 새도우 테이블이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c6336221afe18ddc0e53b18acd141d3c916c6884" translate="yes" xml:space="preserve">
          <source>Contains the text of the term for this row.</source>
          <target state="translated">이 행에 대한 용어 텍스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8149ba57ba940e5c3672ef00fa60ad0d2afcb776" translate="yes" xml:space="preserve">
          <source>Contains the values of persistent configuration parameters.</source>
          <target state="translated">지속적 구성 매개 변수의 값을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="17ad25c1af7990d50b53a9e2d46ba0f493597884" translate="yes" xml:space="preserve">
          <source>Content Size</source>
          <target state="translated">내용 크기</target>
        </trans-unit>
        <trans-unit id="311a2e63246045d0ca04704e25eb8fe09678745a" translate="yes" xml:space="preserve">
          <source>Content can be accessed and updated using concise SQL queries instead of lengthy and error-prone procedural routines.</source>
          <target state="translated">길고 오류가 발생하기 쉬운 절차 적 루틴 대신 간결한 SQL 쿼리를 사용하여 컨텐츠에 액세스하고 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e6a597c2b0fe05466617946d21001a0e849ccf" translate="yes" xml:space="preserve">
          <source>Content can be updated continuously and atomically so that little or no work is lost in a power failure or crash.</source>
          <target state="translated">정전이나 충돌시 작업이 거의 또는 전혀 손실되지 않도록 컨텐츠를 지속적으로 원자 적으로 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a0ca8d8e7e6987ce002e1b9cc19498346916cd0" translate="yes" xml:space="preserve">
          <source>Content stored in an SQLite database is more likely to be recoverable decades in the future, long after all traces of the original application have been lost. Data lives longer than code.</source>
          <target state="translated">SQLite 데이터베이스에 저장된 콘텐츠는 원본 응용 프로그램의 모든 흔적을 잃어버린 후에도 향후 수십 년 동안 복구 가능성이 높습니다. 코드보다 데이터 수명이 깁니다.</target>
        </trans-unit>
        <trans-unit id="2d4a0281b46f5532a617239a67837a43f539390e" translate="yes" xml:space="preserve">
          <source>Contentless FTS4 tables also support SELECT statements. However, it is an error to attempt to retrieve the value of any table column other than the docid column. The auxiliary function matchinfo() may be used, but snippet() and offsets() may not. For example:</source>
          <target state="translated">콘텐츠가없는 FTS4 테이블은 SELECT 문도 지원합니다. 그러나 docid 열 이외의 테이블 열 값을 검색하려고하면 오류가 발생합니다. 보조 함수 matchinfo ()를 사용할 수 있지만 snippet () 및 offsets ()는 사용할 수 없습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="466e0c80c6a0ee6d90e9a1cf84c5c7f81c6af7ec" translate="yes" xml:space="preserve">
          <source>Contentless FTS5 tables do not support UPDATE or DELETE statements, or INSERT statements that do not supply a non-NULL value for the rowid field. Contentless tables do not support REPLACE conflict handling. REPLACE and INSERT OR REPLACE statements are treated as regular INSERT statements. Rows may be deleted from a contentless table using an &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete command&lt;/a&gt;.</source>
          <target state="translated">컨텐츠가없는 FTS5 테이블은 UPDATE 또는 DELETE 문 또는 rowid 필드에 NULL이 아닌 값을 제공하지 않는 INSERT 문을 지원하지 않습니다. 컨텐츠가없는 테이블은 REPLACE 충돌 처리를 지원하지 않습니다. REPLACE 및 INSERT 또는 REPLACE 문은 일반 INSERT 문으로 처리됩니다. &lt;a href=&quot;fts5#the_delete_command&quot;&gt;FTS5 delete 명령을&lt;/a&gt; 사용하여 contentless 테이블에서 행을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="450f660f2dc175257d82b71bd1a3662299271f61" translate="yes" xml:space="preserve">
          <source>Contentless fts4 tables</source>
          <target state="translated">무 콘텐츠 fts4 테이블</target>
        </trans-unit>
        <trans-unit id="f5cbdf6bfb51439be085b5c6b7460a7c91eabc3c" translate="yes" xml:space="preserve">
          <source>Contents</source>
          <target state="translated">Contents</target>
        </trans-unit>
        <trans-unit id="38c62e79a8a690e9f86401a7b90826fac3d70fe4" translate="yes" xml:space="preserve">
          <source>Continuing enhancements and improvements to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3에 대한&lt;/a&gt; 지속적인 개선 및 개선 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
