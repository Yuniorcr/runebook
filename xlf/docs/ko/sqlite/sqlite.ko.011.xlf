<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">또는 아마도 응용 프로그램은 가장 최근의 checkinTime을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">아니면 이거:</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">또는 데이터베이스를 더욱 안전하게 보호하고 SQLite가 데이터베이스에 전원 안전 덮어 쓰기가 없다고 가정하도록하려면</target>
        </trans-unit>
        <trans-unit id="cb4a4efee56406c1c1e484f479dafaa1ce0d3fdd" translate="yes" xml:space="preserve">
          <source>Or using &lt;a href=&quot;cli#fileio&quot;&gt;file I/O functions&lt;/a&gt;, you can extract elements of the ZIP archive:</source>
          <target state="translated">또는 &lt;a href=&quot;cli#fileio&quot;&gt;파일 I / O 기능&lt;/a&gt; 을 사용하여 ZIP 아카이브의 요소를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">또는 SQLite 쉘 도구에서 ( &lt;a href=&quot;cli#fileio&quot;&gt;readfile ()&lt;/a&gt; 함수는 파일 시스템에서 파일 내용을 읽고이를 블롭으로 리턴합니다).</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">또는 zTab 인수가 NULL이면 데이터베이스의 모든 테이블에 대한 변경 사항이 기록됩니다. 이 호출 후 추가 테이블이 데이터베이스에 추가되면 ( &quot;CREATE TABLE&quot;문을 실행하여) 새 테이블에 대한 변경 사항도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">또는 큰 따옴표로 묶인 문자열 리터럴이 기본적으로 비활성화되어 있지만 일부 히스토리 데이터베이스 연결에 대해 선택적으로 활성화해야하는 경우, 세 번째 매개 변수가 0에서 1로 변경된 경우를 제외하고는 위에 표시된 것과 동일한 C 코드를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">또는 sqlite3.c가 다른 빌드 시스템을 사용하여 컴파일되는 경우 SQLITE_ENABLE_FTS5 전 처리기 기호를 정의하여 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">또는 REINDEX에 첨부 된 인수가 특정 데이터베이스 테이블을 식별하면 데이터베이스 테이블에 첨부 된 모든 인덱스가 재 빌드됩니다. 특정 데이터베이스 인덱스를 식별하면 해당 인덱스 만 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">또는 테이블이 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless 테이블&lt;/a&gt; 인 경우 다음이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">또는 autoconf 빌드 시스템을 사용하는 경우 --enable-session 옵션을 configure 스크립트에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">또는 여러 프레젠테이션을 동일한 문서에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">또는 다음을 사용하여 동일한 내용을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">또는 규모가 작은 순서대로 하나의 특정 계정 ($ xyz)에 대한 모든 변경 사항을 나열하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">매우 큰 테이블에서 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX의&lt;/a&gt; 성능이 크게 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">일반적인 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">일반적인 SQL 문은 자유 형식이며 여러 줄로 분산 될 수 있으며 어디에서나 공백과 주석을 가질 수 있습니다. 도트 명령이 더 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">일반적인 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">거래 시작 전 페이지의 원본 콘텐츠</target>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">다른 문제</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">다른 SQL 데이터베이스 엔진은 데이터를 큰 파일 모음으로 저장하는 경향이 있습니다. 종종 이러한 파일은 데이터베이스 엔진 자체 만 액세스 할 수있는 표준 위치에 있습니다. 이로 인해 데이터가 더 안전 해지지 만 액세스하기가 더 어려워집니다. 일부 SQL 데이터베이스 엔진은 디스크에 직접 쓰고 파일 시스템을 우회하는 옵션을 제공합니다. 이는 추가 성능을 제공하지만 설치 및 유지 관리가 상당히 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">다른 더 복잡한 확장에 따라 하위 폴더에서 찾을 수 있습니다 &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;내선 /&lt;/a&gt; 내선 / 기타 / 이외.</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">&lt;a href=&quot;compile#threadsafe&quot;&gt;-O&lt;/a&gt; 대신 -O3 사용 또는 -DSQLITE_THREADSAFE = 0 사용 및 / 또는 다른 &lt;a href=&quot;compile#rcmd&quot;&gt;권장 컴파일 시간 옵션&lt;/a&gt; 과 같은 다른 컴파일 시간 옵션 은 SQLite가 직접 파일 시스템 읽기에 비해 훨씬 빠르게 실행하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">다른 데이터베이스 엔진은 일단 실행하면 훌륭하게 실행될 수 있습니다. 그러나 초기 설치 및 구성을 수행하는 것은 종종 위협적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">비용 표의 다른 항목은 특정 문자를 변환합니다. 특정 변환 비용은 기본 비용보다 낮아야합니다. 그렇지 않으면 기본 비용이 우선하며 특정 변환은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="translated">다른 예 :</target>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">다른 실험용 메모리 할당자는 향후 SQLite 릴리스에 추가 될 수 있습니다. 이들을 memsys7, memsys8 등이라고 부를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">다른 중요한 버그 수정</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">sqlite3_rtree_query_info 구조의 다른 정보 필드는 원하는 경우 xQueryFunc 콜백에서 사용할 수 있습니다. iRowid 필드는 고려중인 요소의 rowid (R * Tree에서 3-11 개의 열 중 첫 번째)입니다. iRowid는 잎에만 유효합니다. eParentWithin 및 rParentScore 값은 현재 행의 포함 서브 트리에서 eWithin 및 rScore 값의 사본입니다. anQueue 필드는 각 레벨에서 우선 순위 큐에있는 현재 요소 수를 알려주는 mxLevel + 1 부호없는 정수의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">다른 종류의 제약 조건이 사용될 수 있지만 작동하지만 다른 제약 조건은 각 행에 대해 개별적으로 검사되며 최적화되지 않습니다 (최소한 초기에는 아님). 모든 제약 조건 검사는 최적화 발생 여부에 관계없이 완전히 자동입니다. 이 글 머리 기호에 언급 된 최적화는 성능 고려 사항 일뿐입니다. 쿼리 최적화 여부에 관계없이 동일한 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">기타 사소한 버그 수정 및 설명서 향상</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">기타 사소한 버그 수정 및 설명서 향상.</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">기타 사소한 버그 수정 및 성능 향상</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">기타 사소한 버그 수정 및 성능 최적화</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">버전 3.3의 첫 번째 안정적인 릴리스를 준비하는 기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">기타 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">기타 사소한 변경 및 개선.</target>
        </trans-unit>
        <trans-unit id="251ead6fb529a54fa107bbdc4f76c0af651e9179" translate="yes" xml:space="preserve">
          <source>Other minor compiler-warning fixes and whatnot.</source>
          <target state="translated">기타 사소한 컴파일러 경고 수정 및 기타.</target>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">기타 사소한 문서 및 makefile 변경 및 버그 수정</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; 코드 의 품질을 향상시키기위한 기타 미세 조정 .</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">기타 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">기타 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">루프 언 롤링과 같은 기타 기타 개선 사항.</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">성능 향상 및 메모리 사용량 감소를위한 기타 기타 마이크로 최적화.</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">기타 기타 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">기타 기타 성능 향상</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">친숙한 다른 데이터베이스 엔진은 일단 실행하면 훌륭하게 실행됩니다. 그러나 초기 설치 및 구성은 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62a6e61f5dec5bfc458e9cb92c78c02e716a2af" translate="yes" xml:space="preserve">
          <source>Other output modes include &quot;html&quot;, &quot;json&quot;, and &quot;tcl&quot;. Try these yourself to see what they do.</source>
          <target state="translated">다른 출력 모드에는 &quot;html&quot;, &quot;json&quot;및 &quot;tcl&quot;이 있습니다. 그들이 무엇을하는지 직접 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">화석과 Git에 관한 다른 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">다른 성능 향상. 약 &lt;a href=&quot;cpu&quot;&gt;6.5 % 적은 CPU주기를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">다른 성능 최적화 :</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">다른 프로그래밍 언어는 때때로 &quot;C만큼 빠르다&quot;고 주장합니다. 그러나 다른 언어는 범용 프로그래밍에서 C보다 빠르다고 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="400864fb9a5435081d0153c603d26034407232fd" translate="yes" xml:space="preserve">
          <source>Other relation database engines also implement UPDATE-FROM, but because the construct is not part of the SQL standards, each product implements UPDATE-FROM differently. The SQLite implementation strives to be compatible with PostgreSQL. The SQL Server and MySQL implementations of the same idea work a little differently.</source>
          <target state="translated">다른 관계 데이터베이스 엔진도 UPDATE-FROM을 구현하지만 구성이 SQL 표준의 일부가 아니기 때문에 각 제품은 UPDATE-FROM을 다르게 구현합니다. SQLite 구현은 PostgreSQL과 호환되도록 노력합니다. 동일한 아이디어의 SQL Server 및 MySQL 구현은 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">다른 유사한 트리 표시 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">기타 작은 버그 수정 및 최적화</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">다른 시스템은 때때로 SQLite에서 ALWAYS (X) 또는 NEVER (X)를 사용하는 것과 유사한 방식으로 assert (X)를 사용합니다. 개발자는 &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;X가 항상 참이라고 완전히 믿지 않는다는 암묵적 인정&lt;/a&gt; 으로 assert (X)를 추가 합니다.. 우리는 assert (X)의 사용이 잘못되었고 C에서 assert (X)를 사용할 수있는 의도와 목적을 위반한다고 생각합니다. assert (X)는 실수로부터 보호하기 위해 사용되는 안전망 또는 상단 로프로 간주되어서는 안됩니다. 심층 방어에는 assert (X)도 적합하지 않습니다. 프로그래머가 추론을 할 때 ALWAYS (X) 또는 NEVER (X) 매크로 또는 이와 유사한 것을 사용해야합니다. 틀리다. ALWAYS (X) 또는 NEVER (X)를 따르는 코드는 테스트되지 않았으므로 검사를 통해 쉽게 확인할 수있는 &quot;return&quot;문과 같이 매우 단순해야합니다.</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">그렇지 않으면 표현식에 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">그렇지 않으면 오류가 발생하지 않으면 &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; 는 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">그렇지 않으면 오류가 발생하지 않으면 &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; 는 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">그렇지 않으면, ORDER BY 표현식이 컬럼이거나 컬럼 인 표현식의 별명 인 경우, 컬럼의 기본 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">그렇지 않으면 ORDER BY 표현식이 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 를 사용하여 데이터 정렬 시퀀스에 지정된 표현식의 별명 인 경우 별명 지정된 표현식에 지정된 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">그렇지 않으면 ORDER BY 표현식이 다른 표현식 인 경우 평가되고 리턴 된 값이 출력 행을 정렬하는 데 사용됩니다. SELECT 문이 단순 SELECT 인 경우 ORDER BY는 임의의 표현식을 포함 할 수 있습니다. 그러나 SELECT가 복합 SELECT 인 경우 출력 컬럼의 별명이 아닌 ORDER BY 표현식은 출력 컬럼으로 사용되는 표현식과 정확히 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">그렇지 않으면 선호도가 적용되지 않고 두 피연산자가 그대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">그렇지 않으면 r [P2]는 r [P1]과 r [P3]의 합으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">그렇지 않으면 BINARY 조합 기능이 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">그렇지 않으면 선호도는 NUMERIC입니다.</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">그렇지 않으면이 필드에 삽입 된 값은 일반 파일의 파일 내용 또는 기호 링크의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">그렇지 않으면이 API는 P1이 P2보다 오래된 스냅 샷을 참조하면 음수 값을 리턴하고, 두 핸들이 동일한 데이터베이스 스냅 샷을 참조하면 0, P1이 P2보다 새로운 스냅 샷이면 양수 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">우리의 목표는 오늘날 SQLite에 저장하는 콘텐츠를 손자에게 쉽게 액세스 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">메모리 부족 (OOM) 오류 조건은 SQLITE_NOMEM 오류 코드 및 실패한 할당에 의해 요청 된 메모리 바이트 수를 나타내는 메시지와 함께 오류 로깅 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">메모리 부족 테스트</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">비정상적인 재귀 쿼리 예제</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">출력 변경</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">index_info pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">index_list pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">index_xinfo pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 &quot;.dump&quot;명령에서 무한대를 1e999로 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">작은 정렬이 완료 될 때마다 그리고 테이블 스캔이 완료되기 훨씬 전에 출력 행을 애플리케이션으로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">데이터베이스 t1.db를 업데이트하는 데 사용되는 경우 해당 컨텐츠가 데이터베이스 t2.db의 컨텐츠와 동일하도록 패치하는 RBU 데이터베이스를 작성하는 SQL 스크립트를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">100 개가 넘는 별도의 소스 파일이 &quot;sqlite3.c&quot;라는 하나의 큰 C 코드 파일로 연결되고 &quot;아말감 화&quot;라고합니다. 통합에는 응용 프로그램에 SQLite를 포함시키는 데 필요한 모든 것이 포함됩니다. 합병 파일의 길이는 220,000 줄 이상이고 크기는 7.5MB 이상입니다 (2018-11-24 기준).</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">오버플로 페이지</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">가상 테이블에 대한 함수 과부하</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Zulu 또는 현지 시간을 얻기위한 호출과 같은 다른 운영 체제 인터페이스를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">개요 서류</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">이미 존재하는 경우 덮어 쓰시겠습니까?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">원본 데이터베이스와 관련된 핫 저널도 삭제하지 않고 다른 데이터베이스 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">다른 저널 파일로 저널 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P (비용 : 7.71)</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1은 일반 테이블 또는 가상 테이블 일 수 있습니다. 가상 테이블에 사용할 별도의 OP_VRowid opcode가 있었지만이 opcode는 이제 두 테이블 유형 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1은 서브 프로그램에 대한 인수로 사용되는 값의 배열에서 첫 번째 메모리 셀을 포함하는 메모리 셀의 주소를 포함합니다. P2는 하위 프로그램이 RAISE () 함수를 사용하여 IGNORE 예외를 발생시키는 경우 이동할 주소를 포함합니다. 레지스터 P3에는 런타임시 서브 vdbe에 필요한 메모리를 할당하는 데 사용되는이 (상위) VM의 메모리 셀 주소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1은 함수에 대한 각 인수가 컴파일 타임에 일정하다고 결정되었는지 여부를 나타내는 32 비트 비트 마스크입니다. 첫 번째 인수가 상수이면 P1의 비트 0이 설정됩니다. sqlite3_set_auxdata () API를 사용하여 사용자 함수 인수와 연관된 메타 데이터가 다음에이 opcode를 호출 할 때까지 안전하게 유지 될 수 있는지 여부를 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1은 부울 플래그입니다. true로 설정되고 xUpdate 호출이 성공하면 sqlite3_last_insert_rowid ()에 의해 리턴 된 값이 방금 삽입 된 행의 rowid 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1은 &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen을&lt;/a&gt; 사용하여 열린 커서 입니다. P2는 필터링 된 결과 집합이 비어있는 경우 이동할 주소입니다.</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1은이 VM의 루트 프레임에있는 레지스터입니다 (이 명령이 하위 프로그램 내에서 실행되는 경우 루트 프레임은 현재 프레임과 다릅니다). 레지스터 P1의 값을 현재 값의 최대 값과 레지스터 P2의 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1은 분류기 커서입니다. 시퀀스 카운터가 현재 0이면 P2로 이동합니다. 점프 여부와 관계없이 시퀀스 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1은 분류기 커서입니다. 이 명령어는 레지스터 P3에있는 레코드 Blob의 접두사와 분류기 커서가 현재 가리키는 항목의 접두사를 비교합니다. r [P3]의 첫 번째 P4 필드와 분류기 레코드 만 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1은 열린 인덱스 커서이고 P3은 해당 테이블의 커서입니다. 이 opcode는 P3 테이블 커서를 P1의 현재 행에 해당하는 행으로 지연 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1은 SQL 테이블 btree에서 열린 커서의 인덱스입니다 (정수 키 포함). 레지스터 P3에 정수가 없거나 P1에 rowid P3이있는 레코드가없는 경우 즉시 P2로 이동하십시오. 또는 P2가 0이면 SQLITE_CORRUPT 오류를 발생시킵니다. P1에 rowid P3의 레코드가 포함되어 있으면 커서가 해당 레코드를 가리키고 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1은 SQL 테이블 btree에서 열린 커서의 인덱스입니다 (정수 키 포함). P3은 정수 rowid입니다. P1에 rowid P3의 레코드가 없으면 즉시 P2로 이동하십시오. 또는 P2가 0이면 SQLITE_CORRUPT 오류를 발생시킵니다. P1에 rowid P3의 레코드가 포함되어 있으면 커서가 해당 레코드를 가리키고 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1은 트랜잭션이 시작된 데이터베이스 파일의 색인입니다. 인덱스 0은 기본 데이터베이스 파일이고 인덱스 1은 임시 테이블에 사용되는 파일입니다. 연결된 데이터베이스에는 2 개 이상의 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1은 잠금을 획득 한 데이터베이스의 sqlite3.aDb []에있는 데이터베이스의 색인입니다. P3 == 0이면 판독 잠금을 얻거나 P3 == 1이면 기록 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1은 집계 또는 창 함수의 누산기 인 메모리 위치입니다. 집계에 대한 종료 자 함수를 실행하고 결과를 P1에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1은 sqlite3_exec (), sqlite3_reset () 또는 sqlite3_finalize ()에 의해 반환되는 결과 코드입니다. 정상적인 정지의 경우 SQLITE_OK (0)이어야합니다. 오류의 경우 다른 값이 될 수 있습니다. P1! = 0이면 P2는 현재 트랜잭션을 롤백할지 여부를 결정합니다. P2 == OE_Fail 인 경우 롤백하지 마십시오. P2 == OE_Rollback 인 경우 롤백을 수행하십시오. P2 == OE_Abort 인 경우 VDBE를 실행하는 동안 발생한 모든 변경 사항을 취소하지만 트랜잭션을 롤백하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1은 유효한 b- 트리 커서 여야합니다. P2는 0 또는 1의 부울 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1은 의사 테이블이 아니어야합니다. 여러 행이있는 실제 테이블이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2는 잠글 테이블의 루트 페이지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2는 데이터베이스 P1의 가상 테이블 이름을 보유하는 레지스터입니다. 해당 테이블의 xCreate 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2는 sqlite_offset () 함수에 대한 인수의 열 번호입니다. 이 opcode는 P2 자체를 사용하지 않지만 P2 값은 코드 생성기에서 사용됩니다. 이 opcode의 P1, P2 및 P3 피연산자는 &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; 의 피연산자와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2는 단계 함수가 취하는 인수 수이고 P4는이 함수의 FuncDef에 대한 포인터입니다. 이 opcode에서는 P2 인수를 사용하지 않습니다. 다양한 수의 인수를 취할 수있는 기능을 명확하게하는 것만 있습니다. P4 인수는 단계 함수가 이전에 호출되지 않은 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2는 임시 테이블의 열 수입니다. 커서는 P4 == 0 인 경우 BTree 테이블을 가리키고 P4가 0이 아닌 경우 BTree 인덱스를 가리 킵니다. P4가 NULL이 아닌 경우 인덱스의 키 형식을 정의하는 KeyInfo 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A'&amp;rarr; BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B'&amp;rarr; 텍스트</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C'&amp;rarr; 숫자</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D'&amp;rarr; 정수</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E'&amp;rarr; 실제</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3 = P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3은 의사 테이블에 의해 저장 될 레코드의 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4에는 잠긴 테이블 이름에 대한 포인터가 있습니다. 잠금을 확보 할 수없는 경우에만 오류 메시지를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4는 비교를위한 조합 순서 및 정렬 순서를 정의하는 KeyInfo 구조입니다. 순열은 레지스터에만 적용됩니다. KeyInfo 요소는 순차적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4는 64 비트 부동 소수점 값에 대한 포인터입니다. 이 값을 레지스터 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4는 64 비트 정수 값에 대한 포인터입니다. 이 값을 레지스터 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4는 CollSeq 객체에 대한 포인터입니다. 사용자 함수에 대한 다음 호출 또는 집계가 sqlite3GetFuncCollSeq ()를 호출하면이 조합 순서가 리턴됩니다. 내장 min (), max () 및 nullif () 함수에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. P1은 커서 번호입니다. 이 opcode는 가상 테이블에 대한 커서를 열고 해당 커서를 P1에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. 이 opcode는 해당 xRename 메소드를 호출합니다. 레지스터 P1의 값은 zName 인수로 xRename 메소드에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. 이 opcode는 해당 xUpdate 메소드를 호출합니다. P2 값은 P3에서 시작하여 xUpdate 호출로 전달되는 연속 메모리 셀입니다. 레지스터 (P3 + P2-1)의 값은 xUpdate에 전달 된 argv 배열의 p2 번째 요소에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4는 트리거 프로그램이 포함 된 VM에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4는 P2 자 길이의 문자열입니다. 문자열의 N 번째 문자는 해당 범위의 N 번째 메모리 셀에 사용해야하는 열 선호도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4는 항상 P4_ADVANCE 유형입니다. 함수 포인터는 sqlite3BtreeNext ()를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4는 항상 P4_ADVANCE 유형입니다. 함수 포인터는 sqlite3BtreePrevious ()를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4는 NULL이거나 모듈의 xBestIndex 메소드에 의해 생성 된 문자열입니다. P4 문자열의 해석은 모듈 구현에 맡겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4는 데이터베이스 P1의 가상 테이블 이름입니다. 해당 테이블의 xDestroy 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4는 sqlite3_vtab 구조에 대한 포인터 일 수 있습니다. 그렇다면 해당 테이블에 대한 xBegin 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4는 P2 자 길이의 문자열 일 수 있습니다. 문자열의 N 번째 문자는 인덱스 키의 N 번째 필드에 사용해야하는 열 선호도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4는 P3 테이블의 각 열에 대해 하나의 항목을 포함하는 정수 배열 (P4_INTARRAY 유형) 일 수 있습니다. 배열 항목 a (i)가 0이 아닌 경우 커서 P3에서 열 a (i) -1을 읽는 것은 지연된 탐색을 수행 한 다음 P1에서 열 i를 읽는 것과 같습니다. 이 정보는 P3에 저장되며 P3에 대한 읽기를 P1로 리디렉션하는 데 사용되므로 커서 P3을 찾아서 읽을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4는 P1 바이트 길이의 데이터 Blob을 가리 킵니다. 이 얼룩을 레지스터 P2에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4는 널 종료 UTF-8 문자열을 가리 킵니다. 이 opcode는 처음으로 실행되기 전에 &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode 로 변환됩니다 . 이 변환 중에 문자열 P4의 길이가 계산되어 P1 매개 변수로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5는 P4 문자열을 수정하는 0에서 4 사이의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5는 삽입 또는 업데이트시 제한 조건 실패시 적용 할 오류 조치 (OE_Replace, OE_Fail, OE_Ignore 등)입니다.</target>
        </trans-unit>
        <trans-unit id="b092db6b7249be33e50e9f2a75c65696bf56d25e" translate="yes" xml:space="preserve">
          <source>P5 ought to be set on every call to this opcode. However, there are places in the code generator will release registers before their are used, under the (valid) assumption that the registers will not be reallocated for some other purpose before they are used and hence are safe to release.</source>
          <target state="translated">이 opcode를 호출 할 때마다 P5를 설정해야합니다. 그러나 코드 생성기에는 레지스터가 사용되기 전에 다른 목적으로 재 할당되지 않으므로 릴리스하기에 안전하다는 (유효한) 가정하에 레지스터를 사용하기 전에 레지스터를 해제 할 수있는 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Adobe의 휴대용 문서 형식</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">POSIX 잠금 스타일. 이것은 기본 잠금 스타일이며 다른 (Mac OS X 이외) 유닉스에서 사용되는 스타일입니다. fcntl () 시스템 호출을 사용하여 잠금을 확보하고 해제합니다.</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-Microsoft PowerPoint 프레젠테이션</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">PRAGMA 문</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMA application_id</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA auto_vacuum</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">PRAGMA automatic_index</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMA busy_timeout</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">PRAGMA cache_size</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMA checkpoint_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA collation_list</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">PRAGMA 명령 구문</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">PRAGMA compile_options</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">PRAGMA data_store_directory</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">PRAGMA data_version</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">PRAGMA database_list</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA default_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA defer_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">PRAGMA 인코딩</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA foreign_key_list</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA foreign_keys</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA freelist_count</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA full_column_names</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync = ON;</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">PRAGMA 기능</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">PRAGMA function_list</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">PRAGMA 기능</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA ignore_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA incremental_vacuum</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA index_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">PRAGMA index_list</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">PRAGMA integrity_check</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check가 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; 오류를 찾지 못했습니다 . FOREIGN KEY 제약 조건에서 오류를 찾으 려면 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fed086b5dc8e5ae4d059caf4aa86921613ca6bce" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check는 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; 오류를 찾지 못합니다 . &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령을 사용하여 FOREIGN KEY 제약 조건에서 오류를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">PRAGMA journal_mode</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">PRAGMA journal_size_limit</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">PRAGMA legacy_file_format</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">PRAGMA locking_mode</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">PRAGMA module_list</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA 최적화</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMA page_count</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">PRAGMA page_size</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA parser_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA 동기식 = FULL;</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">PRAGMA temp_store_directory = ''</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">결과를 반환하고 부작용이없는 PRAGMA는 일반 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에서 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 로 액세스 할 수 있습니다 . 참여하는 각 PRAGMA에 대해 해당 테이블 반환 함수의 이름은 7 자리 &quot;pragma_&quot;로 PRAGMA와 동일합니다. PRAGMA 인수 및 스키마 (있는 경우)는 테이블 반환 함수에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">기본 키 제약</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">페이지 1 및 예상 페이지 크기</target>
        </trans-unit>
        <trans-unit id="626d2e810cbdab389ce5499e79846105d079da1c" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot;. This b-tree is known as the &quot;schema table&quot; since it stores the complete database schema. The structure of the sqlite_schema table is as if it had been created using the following SQL:</source>
          <target state="translated">데이터베이스 파일의 페이지 1은 &quot; &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; &quot; 라는 특수 테이블을 보유하는 테이블 b- 트리의 루트 페이지입니다 . 이 b- 트리는 전체 데이터베이스 스키마를 저장하므로 &quot;스키마 테이블&quot;이라고합니다. sqlite_schema 테이블의 구조는 다음 SQL을 사용하여 생성 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">데이터베이스 파일의 1 페이지는 완전한 데이터베이스 스키마를 저장하는 &quot;sqlite_master&quot;(또는 TEMP 데이터베이스의 경우 &quot;sqlite_temp_master&quot;)라는 특수 테이블을 보유하는 테이블 b- 트리의 루트 페이지입니다. sqlite_master 테이블의 구조는 다음 SQL을 사용하여 작성된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">페이지 캐시</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">페이지 캐시 알고리즘</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">페이지 캐시 구성</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">범용 메모리 할당 자로 오버 플로우되는 페이지 캐시 메모리 할당.</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">페이지 번호</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">첫 번째 오버 플로우 페이지의 페이지 번호</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">좌익의 페이지 수</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">첫 번째 프리리스트 트렁크 페이지의 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">페이지 캐시 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">호출기 및 btree 하위 시스템이 제거되었습니다. 이들은 &quot;SQLus&quot;라는 후속 SQL Server 라이브러리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">호출기 서브 시스템이 추가되었지만 아직 사용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">페이지는 최대 페이지 수는 2,147,483,646 (2, 1로 시작하는 번호가 &lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). 최소 크기 SQLite 데이터베이스는 단일 512 바이트 페이지입니다. 최대 크기 데이터베이스는 페이지 당 65536 바이트 또는 140,737,488,224,256 바이트 (약 140 테라 바이트)에서 2147483646 페이지입니다. 일반적으로 SQLite는 자체 내부 크기 제한에 도달하기 전에 기본 파일 시스템 또는 디스크 하드웨어의 최대 파일 크기 제한에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="a6bf70b89378b1b3ed63fb1aa677ec02aea17bdf" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 4294967294 (2&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 281,474,976,579,584 bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">페이지는 최대 페이지 번호 4294967294 (2, 1로 시작하는 번호가 &lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). 최소 크기 SQLite 데이터베이스는 단일 512 바이트 페이지입니다. 데이터베이스의 최대 크기는 페이지 당 65536 바이트 또는 281,474,976,579,584 바이트 (약 281 테라 바이트)의 2147483646 페이지입니다. 일반적으로 SQLite는 자체 내부 크기 제한에 도달하기 훨씬 전에 기본 파일 시스템 또는 디스크 하드웨어의 최대 파일 크기 제한에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">매개 변수 P4는 테이블 구조를 가리 키거나 NULL 일 수 있습니다. NULL이 아닌 경우 성공적인 삽입 후 update-hook (sqlite3.xUpdateCallback)이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">zDb 매개 변수는 데이터베이스를 포함하는 파일 이름이 아니라 데이터베이스의 기호 이름입니다. 접속 된 데이터베이스의 경우, 이는 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 나타나는 이름입니다 . 기본 데이터베이스 파일의 경우 데이터베이스 이름은 &quot;main&quot;입니다. TEMP 테이블의 경우 데이터베이스 이름은 &quot;temp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">zDb 매개 변수는 데이터베이스를 포함하는 파일 이름이 아니라 데이터베이스의 기호 이름입니다. 접속 된 데이터베이스의 경우, 이는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 나타나는 이름입니다 . 기본 데이터베이스 파일의 경우 데이터베이스 이름은 &quot;main&quot;입니다. TEMP 테이블의 경우 데이터베이스 이름은 &quot;temp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">매개 변수는 이름을 지정하거나 이름을 지정할 수 없습니다. 명명되지 않은 매개 변수는 단일 물음표 ( &quot;?&quot;)입니다. 명명 된 매개 변수는 &quot;?&quot; 바로 뒤에 숫자 (예 : &quot;? 15&quot;또는 &quot;? 123&quot;) 또는 &quot;$&quot;, &quot;:&quot;또는 &quot;@&quot;문자 중 하나 다음에 영숫자 이름 (예 : &quot;$ var1&quot;, &quot;: xyz &quot;,&quot;@bingo &quot;).</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()를&lt;/a&gt; 사용하여 값이 지정되지 않은 매개 변수는 NULL로 처리됩니다. &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 인터페이스는 동등한 숫자 인덱스로 상징적 파라미터 명을 변환하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">부모 키와 자식 키는 동일한 카디널리티를 가져야합니다. SQLite에서 하위 키 열 (이 경우 songartist 및 songalbum)이 NULL이면 상위 테이블의 해당 행에 대한 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">부모 테이블</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">열 이름 주위의 괄호는 무시됩니다. 따라서 X와 YZ가 열 이름 인 경우 (X)와 (YZ)도 열 이름으로 간주되며 해당 열의 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">괄호는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">일반적인 방법으로 연산자 우선 순위를 수정하기 위해 괄호를 사용하여 표현식을 그룹화 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">외래 키를 구문 분석합니다 (구현하지는 않음).</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">파서는 자동 스택 오버플로를 감지하고보고합니다.</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">모호성 파싱</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">부분 인덱스로 인해 UPDATE OR REPLACE에서 어설 션 오류가 발생합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이후 부분 인덱스가 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">인덱스 별 부분 정렬</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED를&lt;/a&gt; 사용하여 뮤텍스 사용을 부분적으로 또는 완전히 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">! =, IS, IS NOT, NOT NULL 및 IS NULL 제한 조건에 대한 &lt;a href=&quot;vtab#xbestindex&quot;&gt;정보&lt;/a&gt; 를 가상 테이블 의 xBestIndex 메소드에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">포인터가 정수 또는 BLOB 인 것처럼 포인터를 전달하는 것은 쉽고 효과적이며 응용 프로그램 구성 요소가 서로 친숙한 환경에서 잘 작동합니다. 그러나 포인터를 정수 및 BLOB로 전달하면 악의적 인 SQL 텍스트가 잘못된 포인터를 생성하여 장난을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">이 기능에 0을 전달하면 세션이 비활성화됩니다. 0보다 큰 값을 전달하면 활성화됩니다. 0보다 작은 값을 전달하는 것은 작동하지 않으며 세션의 현재 상태를 쿼리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">패치 릴리스는 문제에 따라 릴리스 체크리스트가 있거나 없을 수 있습니다. 이것은 프로젝트 리더의 판단입니다.</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Christian Werner의 패치로 ODBC 호환성을 개선하고 round () 함수의 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">테이블 b- 트리 데이터 또는 인덱스 b- 트리 키 중 하나 인 페이로드는 항상 &quot;레코드 형식&quot;입니다. 레코드 형식은 테이블 또는 인덱스의 열에 해당하는 일련의 값을 정의합니다. 레코드 형식은 열 수, 각 열의 데이터 유형 및 각 열의 내용을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">보류중인 명령문은 더 이상 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK을&lt;/a&gt; 차단하지 않습니다 . 대신, ROLLBACK 이후에 다음에 액세스 할 때 보류중인 명령문은 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">사람들은 종종 SQLite가 다른 사람들처럼 &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; 버전 제어 시스템을 사용하지 않는 이유를 궁금해 합니다. 이 기사는 그 질문에 대한 답변을 시도합니다. 또한 &lt;a href=&quot;#getthecode&quot;&gt;섹션 3&lt;/a&gt; 에서이 기사는 Git 사용자에게 SQLite 소스 코드에 쉽게 액세스 할 수있는 방법에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">SQL을 이해하는 사람들은 &lt;a href=&quot;cli&quot;&gt;sqlite3 명령 줄 셸&lt;/a&gt; (또는 다양한 타사 SQLite 액세스 프로그램)을 사용하여 큰 데이터 집합을 분석 할 수 있습니다. 원시 데이터는 CSV 파일에서 가져올 수 있으며, 그 데이터를 슬라이스하고 잘라서 무수한 요약 보고서를 생성 할 수 있습니다. 보다 복잡한 분석은 Tcl 또는 Python (둘 다 SQLite 내장으로 제공됨) 또는 R 또는 다른 언어로 작성된 간단한 스크립트를 사용하여 쉽게 사용할 수있는 어댑터를 사용하여 수행 할 수 있습니다. 웹 사이트 로그 분석, 스포츠 통계 분석, 프로그래밍 메트릭 편집 및 실험 결과 분석이 가능합니다. 많은 생물 정보학 연구자들이 이런 식으로 SQLite를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">P1 데이터베이스에서 증분 진공 절차의 단일 단계를 수행하십시오. 진공이 완료되면 지침 P2로 이동하십시오. 그렇지 않으면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">필요한 외래 키 작업을 수행하고</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">두 번이 아닌 단일 번으로 일부 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">성능 관련 가정</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">성능을 향상시킬 수 있도록 크기가 감소 &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt; , &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; , &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt; , &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE을&lt;/a&gt; , &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt; , &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt; 및 &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt; . 이 모든 옵션을 함께 사용하면 성능이 약 3.5 % 향상되고 크기가 3.0 % 감소합니다.</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">메모리 매핑 된 I / O로 성능이 항상 향상되는 것은 아닙니다. 실제로 메모리 매핑 된 I / O를 사용하여 성능이 저하되는 테스트 사례를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">성능 향상 : 가변 길이 정수를 해석하고 렌더링하는 데 사용되는 내부 루틴을 리엔지니어링하십시오.</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬의&lt;/a&gt; 성능 향상 생성 파서</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">VDBE, 특히 OP_Column opcode에 대한 성능 향상.</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">파서의 성능 향상</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">ORDER BY 및 CREATE INDEX에서 사용하는 분류기의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">일부 경우 COUNT (*)의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">디스크 I / O 감소를 통한 성능 향상 :</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">B-Tree 레이어의 트리 밸런싱 로직 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">성능 향상</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">성능 향상 : 상수 하위 표현식이 루프에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">성능 개선 : 여러 OP_Column opcode를 발행하는 대신 OP_Column의 결과가 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">성능 향상 : OP_IdxDelete opcode는 압축 해제 된 레코드를 사용하므로 삭제 된 각 인덱스 레코드마다 OP_MakeRecord opcode 호출이 하나 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">&quot;count (*)&quot;쿼리의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; , &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check의&lt;/a&gt; 성능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum의&lt;/a&gt; 성능 향상 , 특히 사용 가능한 페이지 수가 사용 가능 목록의 단일 트렁크 페이지에 적합한 것보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">LEMON 생성 파서의 성능 향상</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">파서, 호출기 및 WHERE 절 코드 생성기의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">쿼리 최적화 프로그램의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">성능 향상 라이브러리가 훨씬 빨라졌습니다.</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">성능 측정은 단일 컴파일러 (gcc 5.4.0), 최적화 설정 (-Os) 및 단일 플랫폼 (x64의 Ubuntu 16.04 LTS)에서 수행됩니다. 다른 컴파일러와 프로세서의 성능은 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">단일 SQLite 사용자로부터 특정 사용 사례를 대상으로하는 성능 최적화 Valgrind로 측정 한대로 CPU 작동 수를 12 % 줄였습니다. 실제로 실제 성능 향상은 작업 부하에 따라 달라질 수 있습니다. 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX를&lt;/a&gt; 사용하여 개발주기 후반에도 성능 문제를 해결할 수있어 비용이 많이 드는 재 설계, 재 작성 및 재검사 노력을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">cachegrind를 사용하여 speedtest1을 실행하고 &quot;I refs&quot;출력을 관찰하여 성능을 측정했습니다.</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">SQLite의 일반적인 작업 부하를 모방하려는 &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; 유틸리티 프로그램을 사용하여 성능을 측정했습니다 . 테스트 실행 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">아마도 SQL92에서 다음 명령문을 참조하고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">FROM 절없이 SELECT 문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">순열 제목 색인</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">지속적인로드 가능한 확장</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">구문 및 NEAR 쿼리는 행 내 여러 열에 걸쳐 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">구문 쿼리</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">구문 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">문구 및 NEAR 그룹은 &lt;b&gt;암시 적 AND 연산자&lt;/b&gt; 로 연결될 수도 있습니다 . 간단히하기 위해 위의 BNF 문법에는 표시되지 않습니다. 기본적으로 공백으로 만 분리 된 모든 구문 또는 NEAR 그룹 (지정된 열과 일치하는 것으로 제한되는 것을 포함)은 각 쌍의 구문 또는 NEAR 그룹간에 암시 적 AND 연산자가있는 것처럼 처리됩니다. 암시 적 AND 연산자는 괄호로 묶은 식 뒤에 또는 앞에 삽입되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">구문 및 NEAR 그룹은 &lt;b&gt;부울 연산자를&lt;/b&gt; 사용하여 표현식으로 배열 될 수 있습니다 . 우선 순위가 가장 높은 그룹 (가장 엄격한 그룹)에서 가장 낮은 그룹 (가장 낮은 그룹)까지 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">다양한 루프의 중첩 순서 따기</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">중첩 순서를 선택하는 것이 일반적으로 더 어려운 문제입니다. 조인의 중첩 순서가 설정되면 일반적으로 각 루프에 대한 인덱스 선택이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">데이터베이스 페이지 고정 (읽기)</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Windows에서 바이러스 스캐너로 더 잘 재생</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">포인터가에서 반환 된 사실에 특히주의하십시오 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; 에 대한 후속 호출에 의해 무효화 될 수 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">포인터가에서 반환 된 사실에 특히주의하십시오 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; 에 대한 후속 호출에 의해 무효화 될 수 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">malloc ()이 실패한 경우 발생하는 메모리 누수를 연결하십시오. malloc ()이 작동하는 한 메모리 누수가없는 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">포인터 전달 인터페이스</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">포인터 누출</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">포인터 맵 또는 ptrmap 페이지는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 모드 작업을 보다 효율적으로 수행 할 수 있도록 데이터베이스에 추가 된 페이지 입니다. 데이터베이스의 다른 페이지 유형에는 일반적으로 부모에서 자식으로의 포인터가 있습니다. 예를 들어, 내부 b- 트리 페이지에는 하위 b- 트리 페이지에 대한 포인터가 포함되고 오버플로 체인에는 체인의 이전 링크에서 이후 링크까지의 포인터가 있습니다. ptrmap 페이지에는 하위에서 상위로 반대 방향으로 연결 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">포인터 타입</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">포인터 유형은 정적 문자열이며 다른 함수에서 전달 된 매개 변수가 아닌 SQLite API 호출에 직접 포함 된 문자열 리터럴이어야합니다. 정수 값을 포인터 유형으로 사용하는 것을 고려했지만 정적 문자열은 훨씬 더 큰 이름 공간을 제공하여 관련없는 확장간에 우발적 인 유형 이름 충돌 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; 의해 생성 된 포인터 값 은 순수 SQL로 읽을 수 없습니다. 따라서 SQL이 포인터 값을 유출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">포인터 값은 중간 연산자 나 함수없이 생산자에서 소비자에게 직접 전달되어야합니다. 포인터 값을 변환하면 포인터가 삭제되고 값이 일반 SQL NULL로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()로&lt;/a&gt; 읽은 포인터 값 은 순수 SQL로 생성 할 수 없습니다. 따라서 SQL에서 포인터를 위조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">포인터는 정수 또는 BLOB와 같은 다른 SQL 데이터 유형으로 인코딩하여 교환 해서는 &lt;u&gt;안됩니다&lt;/u&gt; . 대신 보안 포인터 전달을 용이하게하도록 설계된 인터페이스 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">SQLite를 새로운 운영 체제로 포팅</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">btree에 새 항목을 추가하기 위해 btree 끝에 커서 P1을 놓습니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">I / O를 완전히 피할 수 있기를 바랍니다. 가능한 한 오랫동안 TEMP 파일과 연관된 I / O를 연기하십시오.</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">전력 안전 덮어 쓰기</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">프라 그마 목록</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">SQLite가 지원하는 Pragma 문</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">이름이있다하는 pragma &lt;s&gt;을 통해 당했다&lt;/s&gt; 되지 않습니다. 사용하지 마십시오. 역사적 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">그리스도의 사랑 안에서 원수들을 위해기도하십시오.</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">그리스도의 사랑 이상을 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">접두사 인덱스는 두 가지 경우에 &lt;a href=&quot;fts3#termprefix&quot;&gt;접두사 쿼리&lt;/a&gt; 를 최적화하는 데 사용될 수 있습니다 . 쿼리의 접두사가 N 바이트 인 경우 &quot;prefix = N&quot;으로 만든 접두사 인덱스는 최상의 최적화를 제공합니다. 또는 &quot;prefix = N&quot;색인을 사용할 수없는 경우 &quot;prefix = N + 1&quot;색인을 대신 사용할 수 있습니다. &quot;prefix = N + 1&quot;인덱스를 사용하는 것은 &quot;prefix = N&quot;인덱스보다 효율적이지 않지만 접두어 인덱스가없는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">접두사 쿼리</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">FTS3의 접두사 검색이 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">깃발 준비</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">준비된 명세서 객체</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">준비된 명령문 스캔 상태</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">준비된 명령문 스캔 상태 Opcode</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">준비된 진술서 상태</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">값을 지정된 너비로 확장하려면 필요한만큼 숫자 대체에 &quot;0&quot;문자를 추가하십시오. 너비 필드가 생략되면이 플래그는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">&quot; &lt;code&gt;file:&lt;/code&gt; &quot;체계를 앞에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">방금 추출한 단일 행이 재귀 테이블의 유일한 행인 것으로 가정하고 모든 결과를 큐에 추가하여 재귀 선택을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">대규모 트랜잭션에서 저널 파일 오버 플로우를 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">기본 결과 코드 기호 이름은 &quot;SQLITE_XXXXXX&quot;형식이며 여기서 XXXXXX는 대문자 알파벳 순서입니다. 확장 결과 코드 이름은 &quot;SQLITE_XXXXXX_YYYYYYY&quot;형식이며 여기서 XXXXXX 부분은 해당 기본 결과 코드이고 YYYYYYY는 결과 코드를 추가로 분류하는 확장입니다.</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">기본 및 확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">오류가 발생하면 문제가되는 SQL 문을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이전에 SQLite는 최상의 쿼리 계획을 검색 할 때 항상 &quot;가장 가까운 이웃&quot;또는 &quot;NN&quot;휴리스틱을 사용했습니다. NN 휴리스틱은 그래프의 단일 순회를 수행하여 항상 다음 단계로 가장 저렴한 아크를 선택합니다. NN 휴리스틱은 대부분의 경우 놀랍도록 잘 작동합니다. 그리고 NN은 빠르기 때문에 SQLite는 대규모 64 웨이 조인에 대한 좋은 계획을 신속하게 찾을 수 있습니다. 반대로,보다 광범위한 검색을 수행하는 다른 SQL 데이터베이스 엔진은 조인의 테이블 수가 10 또는 15를 초과 할 때 멈춤 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">SQLite 3.20.0 (2017-08-01) 이전에는 모든 날짜 / 시간 함수가 항상 비 결정적인 것으로 간주되었습니다. 인수에 따라 날짜 / 시간 함수가 결정적이고 때로는 결정적이지 않은 기능이 3.20.0 릴리스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">SQLite 3.7.15 (2012-12-12) 이전에는 FROM 절의 하위 쿼리가 외부 쿼리로 병합되거나 외부 쿼리가 시작되기 전에 하위 쿼리가 완료 될 때까지 하위 쿼리가 실행됩니다. 임시 테이블에 저장된 다음 외부 쿼리에 임시 테이블이 사용됩니다. 최신 버전의 SQLite에는 공동 루틴을 사용하여 하위 쿼리를 구현하는 세 번째 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;버전 3.11.0&lt;/a&gt; (2016-02-15) 이전에 fts3_tokenzer ()에 대한 인수는 리터럴 문자열 또는 BLOB 일 수 있습니다. &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수를 바인딩&lt;/a&gt; 할 필요는 없습니다 . 그러나 이로 인해 SQL 삽입시 보안 문제가 발생할 수 있습니다. 따라서 레거시 동작은 이제 기본적으로 비활성화되어 있습니다. 그러나 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0) 를 호출하여 실제로 필요한 응용 프로그램에서 이전 버전과의 호환성을 위해 이전 레거시 동작을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; (2009-08-10) 이전에는 가상 테이블 메커니즘이 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 자체 데이터베이스 스키마 사본을 유지 한다고 가정합니다 . 따라서 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 사용 가능한 데이터베이스에서 가상 테이블 메커니즘을 사용할 수 없습니다 . &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 경우 인터페이스는 오류를 반환 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 활성화됩니다. 이 제한은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; 부터 완화 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11) 이전에는 재귀 트리거가 지원되지 않았습니다. SQLite의 동작은 항상이 pragma가 OFF로 설정된 것처럼 작동했습니다. 재귀 트리거에 대한 지원은 버전 3.6.18에서 추가되었지만 호환성을 위해 기본적으로 기본적으로 해제되어 있습니다. 이후 버전의 SQLite에서는 기본적으로 재귀 트리거가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11) 이전에는 트리거가 재귀 적이 지 않았 으므로이 한계는 의미가 없었습니다. 버전 3.6.18부터 재귀 트리거가 지원되었지만 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; 문을 사용하여 명시 적으로 활성화해야했습니다 . 를 시작으로 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2009-09-11), 재귀 트리거는 기본적으로 활성화되어 있지만, 수동으로 사용하지 않도록 설정할 수 있습니다 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA의 RECURSIVE_TRIGGERS을&lt;/a&gt; . SQLITE_MAX_TRIGGER_DEPTH는 재귀 트리거가 활성화 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">SQLite 버전 3.17.0 이전에는 세션 확장이 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID&lt;/a&gt; 테이블이 아닌 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서만 작동했습니다 . 3.17.0부터 rowid 및 WITHOUT ROWID 테이블이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">SQLite 버전 3.3.14 이전에는 모든 경우에 512 바이트의 섹터 크기가 가정되었습니다. 이것을 변경하는 컴파일 타임 옵션이 있었지만 코드는 더 큰 값으로 테스트되지 않았습니다. 512 바이트 섹터 가정은 최근까지 모든 디스크 드라이브가 512 바이트 섹터를 내부적으로 사용했기 때문에 합리적으로 보였다. 그러나 최근 디스크의 섹터 크기를 4096 바이트로 늘리려는 시도가있었습니다. 또한 플래시 메모리의 섹터 크기는 일반적으로 512 바이트보다 큽니다. 이러한 이유로 3.3.14로 시작하는 SQLite 버전에는 OS 파일 계층에 기본 파일 시스템을 조사하여 실제 섹터 크기를 찾는 방법이 있습니다. 현재 구현 된 (버전 3.5.0)이 방법은 여전히 ​​하드 코딩 된 512 바이트 값을 반환합니다. Unix 또는 Windows에서 실제 섹터 크기를 검색하는 표준 방법이 없기 때문입니다.그러나이 방법은 임베디드 디바이스 제조업체가 자신의 필요에 따라 조정할 수 있습니다. 그리고 향후 Unix 및 Windows에서보다 의미있는 구현을 작성할 가능성을 열어 놓았습니다.</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.7.10 이전의 Windows OS 인터페이스 계층은 SQLite에서 사용하는 UTF-8 인코딩과 특정 Windows 설치에서 사용되는 파일 이름 인코딩간에 파일 이름을 변환 할 때 시스템 malloc () 및 free ()를 직접 호출했습니다. 메모리 할당 오류가 감지되었지만 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 대신 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 또는 SQLITE_IOERR &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;로보고되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.7.10 이전의 Windows OS 인터페이스 계층은 SQLite에서 사용하는 UTF-8 인코딩과 특정 Windows 설치에서 사용되는 파일 이름 인코딩간에 파일 이름을 변환 할 때 시스템 malloc () 및 free ()를 직접 호출했습니다. 메모리 할당 오류가 감지되었지만 &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 대신 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 또는 SQLITE_IOERR &lt;a href=&quot;../rescode#nomem&quot;&gt;로보고되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">SQLite 버전 3.8.2 (2013-12-06) 이전에는 +9223372036854775807.0보다 큰 REAL 값을 정수로 캐스트하면 가장 음의 정수인 -9223372036854775808이 발생했습니다. 이 동작은 동등한 캐스트를 수행 할 때 x86 / x64 하드웨어의 동작을 에뮬레이션하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">SQLite 소스 트리에 체크인 할 때마다 개발자는 일반적으로 약 248.5 천 개의 테스트 사례로 구성된 Tcl 테스트의 하위 집합 ( &quot;매우 빠른&quot;)을 실행합니다. 매우 빠른 테스트에는 이상, 퍼지 및 흡수 테스트 이외의 대부분의 테스트가 포함됩니다. 매우 빠른 테스트의 기본 개념은 대부분의 오류를 포착하기에 충분하지만 몇 시간이 아니라 몇 분만에 실행될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">데이터베이스 파일을 변경하기 전에 SQLite는 먼저 별도의 롤백 저널 파일을 작성하고 롤백 저널에 변경 될 데이터베이스 페이지의 원래 컨텐츠를 씁니다. 롤백 저널의 기본 개념은 데이터베이스를 원래 상태로 복원하는 데 필요한 모든 정보를 포함한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">데이터베이스 파일 자체를 변경하기 전에 데이터베이스 파일에 대한 독점 잠금을 얻어야합니다. 독점 잠금을 얻는 것은 실제로 두 단계 프로세스입니다. 첫 번째 SQLite는 &quot;보류중인&quot;잠금을 얻습니다. 그런 다음 보류중인 잠금을 독점 잠금으로 에스컬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">버전 3.26.0 (2018-12-01) 이전에 이름이 바뀐 테이블에 대한 FOREIGN KEY 참조는 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt; 또는 다른 말로 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 이 적용된 경우에만 편집 되었습니다. 으로 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA의 foreign_keys = OFF는&lt;/a&gt; 외부 키가 (이하 &quot;라고하는 테이블 때, FOREIGN KEY 제약 조건이 변경되지 않을 것이다 &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;부모 테이블&lt;/a&gt; &quot;)로 변경되었습니다. 버전 3.26.0부터는 &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt; 설정을 사용 하지 않는 한 테이블 이름을 바꿀 때 FOREIGN KEY 제약 조건이 항상 변환됩니다 . 다음 표는 차이점을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 함수는 sqlite3_release_memory () 호출과 동일한 스레드에서 모든 데이터베이스 연결에서 메모리를 회수하려고 시도했습니다. 버전 3.5.0부터 sqlite3_release_memory () 함수는 모든 스레드의 모든 데이터베이스 연결에서 메모리를 회수하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 는 단일 스레드 내의 모든 데이터베이스 연결에 대한 힙 메모리 사용량의 상한을 설정했습니다. 각 스레드에는 자체 힙 제한이있을 수 있습니다. 버전 3.5.0부터 전체 프로세스에 대한 단일 힙 한계가 있습니다. 이것은 더 제한적인 것처럼 보이지만 (많은 사용자와 달리 한 가지 제한) 실제로는 대부분의 사용자가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; API는 단일 스레드 내의 모든 연결에 대해 공유 캐시 기능을 사용 및 사용 안함으로 설정했습니다. sqlite3_enable_shared_cache () 루틴이 호출 된 동일한 스레드입니다. 공유 캐시를 사용하는 데이터베이스 연결은 열린 동일한 스레드에서 실행되도록 제한되었습니다. 버전 3.5.0부터 sqlite3_enable_shared_cache ()는 프로세스 내의 모든 스레드에있는 모든 데이터베이스 연결에 적용됩니다. 이제 별도의 스레드에서 실행되는 데이터베이스 연결이 캐시를 공유 할 수 있습니다. 공유 캐시를 사용하는 데이터베이스 연결은 한 스레드에서 다른 스레드로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">프로세스 A는 이제 데이터베이스에 쓰려고합니다. 그러나 프로세스 B가 프로세스 A가 데이터베이스 파일을 읽은 후 데이터베이스 파일을 수정했기 때문에 프로세스 A의 데이터베이스 컨텐츠보기가 더 이상 사용되지 않습니다. 따라서 프로세스 A는 SQLITE_BUSY_SNAPSHOT 오류를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">프로세스 A는 데이터베이스에서 읽기 트랜잭션을 시작하고 하나 이상의 SELECT 문을 수행합니다. 프로세스 A는 트랜잭션을 열린 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">프로세스 B는 데이터베이스를 업데이트하여 프로세스 A가 이전에 읽은 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">group_concat () SQL 함수를 제품화하고 공식적으로 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">PGO (프로필 안내 최적화)는 SQLite에서 도움이되지 않습니다. PGO는 이진이 약 1 % 더 크고 약 0.33 % 더 느립니다.</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">프로파일 링은 대부분의 시스템 및 대부분의 환경에서 SQLite가 디스크 I / O를 수행하는 데 대부분의 시간을 소비한다는 것을 나타냅니다. 디스크 I / O의 양을 줄이기 위해 할 수있는 일은 SQLite의 성능에 큰 긍정적 인 영향을 줄 것입니다. 이 섹션에서는 원자 커밋을 유지하면서 디스크 I / O의 양을 최소로 줄이기 위해 SQLite에서 사용하는 일부 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">프로그래머는 이전 글 머리표에서 설명한 두 가지 예외를 사용하지 않도록주의해야합니다. 우리는 그것들이 존재하기 때문에 오래되고 잘못 구성된 SQL 문이 올바르게 실행되도록 강조합니다. 이후 버전의 SQLite는 위의 예외에서 다루는 잘못된 형식의 문장을 받아들이지 않고 오류를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">프로그래머는 JOIN, INNER JOIN, NATURAL JOIN 또는 &quot;,&quot;조인 대신 CROSS JOIN 연산자를 사용하여 SQLite가 조인에 특정 루프 중첩 순서를 사용하도록 할 수 있습니다. CROSS JOIN은 이론적으로는 정식 적이지만 SQLite는 CROSS JOIN에서 테이블을 다시 정렬하지 않도록 선택합니다. 따라서 CROSS JOIN의 왼쪽 테이블은 항상 오른쪽 테이블을 기준으로 외부 루프에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">로드 가능한 확장 프로그램 프로그래밍</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">프로그램은 첫 번째 opcode로이 opcode의 단일 인스턴스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7b85e7edf23f7121981c9a7f81acf2f88e25d897" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 태그하지 않는 트리거, 뷰, CHECK 제약 조건, DEFAULT 절, 표현의 인덱스 부분 인덱스, 또는 생성 된 컬럼 내부 SQL 기능의 사용을 금지 &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="836cdbe091f8e6d2e0a3bc0953580f5b61d80d1b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 태그하지 않는 트리거, 뷰, CHECK 제약 조건, DEFAULT 절, 표현의 인덱스 부분 인덱스, 또는 생성 된 컬럼 내부 SQL 기능의 사용을 금지 &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4131fb0c74864c2b5168b32ce6c60e9b911d245" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">가상 테이블에 &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; 태그가 지정되지 않은 경우 트리거 또는 뷰 내에서 가상 테이블 사용을 금지합니다 .</target>
        </trans-unit>
        <trans-unit id="0dd1398efbb71440f12c0472c04e04e100c1dd4b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">가상 테이블에 &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; 태그가 지정되지 않은 경우 트리거 또는 뷰 내에서 가상 테이블 사용을 금지합니다 .</target>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check에 &lt;/a&gt;&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA 기능&lt;/a&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">커서 P1에 P4의 Expr을 만족시키는 행만 리턴해야한다는 힌트를 제공하십시오. P4 표현식의 TK_REGISTER 용어는 현재 레지스터에 보유 된 값을 나타냅니다. P4 표현식의 TK_COLUMN 용어는 커서 P1이 가리키는 b- 트리의 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">sqlite_master 테이블에 CREATE TABLE AS 문이 포함 된 경우 적절한 오류 메시지를 제공하십시오. 이전에는 어설 션 오류 또는 널 포인터 역 참조가 발생했습니다. GDAL 프로젝트에서 OSSFuzz가 발견 한 문제점. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; 플래그를 제공하고 이를 사용 하여 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장에&lt;/a&gt; 의한 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리&lt;/a&gt; 오용 을 제한 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">제공 &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; SQL 기능을하는 수익률로 컴파일 할 때 기록을 보유 값 X의 시작 부분에 데이터베이스 파일에 바이트 오프셋 &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6abc71c7c814cc2d05ebc22239e7790b1f15e917" translate="yes" xml:space="preserve">
          <source>Provide the ability to tag &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; with new properties &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;.</source>
          <target state="translated">새 속성 &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY로 &lt;/a&gt;&lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 에 태그를 지정하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 대한 SQL 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil 버전 제어 시스템&lt;/a&gt; 에서 단일 체크인으로 모든 파일에 대한 정보를 제공합니다 . 이 가상 테이블은 SQLite 프로젝트의 일부가 아니지만 가상 테이블 사용 방법의 예를 제공하고 SQLite 소스의 버전 제어를 돕는 데 사용되기 때문에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">데이터베이스 파일에서 각 페이지의 목적 및 사용에 대한 정보를 제공합니다. &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; 유틸리티 프로그램 의 구현에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">의사 난수 생성기</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmap 페이지는 데이터베이스 헤더의 오프셋 52에서 0이 아닌 가장 큰 루트 b- 트리 페이지 값을 가진 데이터베이스 파일에 있어야합니다. 가장 큰 루트 b- 트리 페이지 값이 0이면 데이터베이스에 ptrmap 페이지가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="b7a7b9c96916fe33cad00dfc0a31cbc73811f7fc" translate="yes" xml:space="preserve">
          <source>PureFunc</source>
          <target state="translated">PureFunc</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">더티 페이지 퍼지</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">다음 &quot;물건&quot;을 스택으로 밀어 넣고 밀어 넣을 다음 &quot;물건&quot;이 있는지 여부에 따라 P2로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">모든 식별자 이름을 큰 따옴표 안에 넣습니다. 이것은 식별자 이름을 이스케이프하는 공식 SQL 방법입니다.</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="translated">식별자 이름을 [...] 안에 넣으십시오. 이것은 표준 SQL은 아니지만 SQL Server가 수행하는 방식이므로 많은 프로그래머가이 기술을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">&quot; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &quot;행 바로 뒤에 매크로 &quot; &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; &quot;을 한 줄에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">하나님 께 희망을 두십시오.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">품질 관리</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">SQLite의 품질 보증은 컴파일러 경고 또는 기타 정적 코드 분석 도구가 아닌 &lt;a href=&quot;testing#coverage&quot;&gt;전체 범위 테스트를&lt;/a&gt; 사용하여 수행됩니다 . 다시 말해, 우리는 SQLite가 단순히 문체 적 제약을 만족시키는 것이 아니라 정답을 얻는다는 것을 확인합니다. 대부분의 SQLite 코드 기반은 순전히 테스트에 전념합니다. SQLite 테스트 스위트는 수만 건의 개별 테스트 사례를 실행하며 이러한 테스트 사례 중 다수는 매개 변수화되어 수십억 개의 SQL 문과 관련된 수억 건의 테스트가 실행되고 모든 릴리스 전에 정확성을 평가합니다. 개발자는 코드 범위 도구를 사용하여 코드를 통한 모든 경로가 테스트되었는지 확인합니다. SQLite에서 버그가 발견 될 때마다 버그를 나타 내기 위해 새로운 테스트 사례가 작성되므로 나중에 버그를 발견 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">품질 관리 문서는 읽을 수없는 전문 용어로 가득 찬 바인더로 확장되는 경향이 있습니다. 이 문서는 간결하고 유용하여 해당 패턴을 깨기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">WHERE 절에 베어 geopoly_overlap () 또는 geopoly_within () 함수가 포함 된 쿼리 (및 DELETE 및 UPDATE 문)는 기본 R * Tree 데이터 구조를 사용하여 행의 서브 세트 만 검사하면되는 빠른 검색을 수행합니다. 탁자. 검사 할 행 수는 물론 $ query_polygon의 크기에 따라 다릅니다. 큰 $ query_polygons는 일반적으로 작은 것보다 더 많은 행을보아야합니다.</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">그래프에 대한 쿼리</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">지오 폴리 테이블의 rowid에 대한 쿼리는 행 수가 많은 테이블의 경우에도 매우 빠릅니다. 그러나 보조 데이터 열은 인덱스가 아니므로 보조 데이터 열에 대한 쿼리에는 전체 테이블 스캔이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">&quot;SELECT max (x), y FROM table&quot;형식의 쿼리는 최대 x 값이 포함 된 동일한 행에서 y 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">인수가 인덱스의 가장 왼쪽 열인 단일 MIN () 또는 MAX () 집계 함수를 포함하는 쿼리는 전체 테이블을 스캔하지 않고 단일 인덱스 조회를 수행하여 충족 될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">하위 쿼리가 포함 된 쿼리는 때때로 하위 쿼리를 개별적으로 평가하고 결과를 임시 테이블에 저장 한 다음 임시 테이블의 내용을 사용하여 외부 쿼리를 평가해야합니다. 이것을 하위 쿼리를 &quot;구체화&quot;한다고합니다. SQLite의 쿼리 최적화 프로그램은 구체화를 피하려고 시도하지만 때로는 쉽게 피할 수 없습니다. 구체화에 의해 작성된 임시 테이블은 각각 ​​별도의 임시 파일에 저장되며 쿼리가 완료되면 자동으로 삭제됩니다. 이러한 임시 테이블의 크기는 물론 하위 쿼리의 구체화에있는 데이터의 양에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">ORDER BY 및 LIMIT를 사용하는 쿼리는 이제 LIMIT 아래에 들어갈 수없는 행을 계산하지 않습니다. 이는 특히 제한이없는 출력 행 수에 비해 LIMIT가 작은 경우 ORDER BY LIMIT 쿼리의 성능을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">SQLite가 이해하는 쿼리 언어</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">쿼리 플래너</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">쿼리 계획</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">쿼리 진행 콜백</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">준비된 명령문에 대한 EXPLAIN 설정 조회</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">플래 튼 쿼리</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">쿼리 병합은 뷰의 각 사용이 하위 쿼리로 변환 될 때 뷰가 사용될 때 중요한 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">현재 행 내에서 구문 일치 iIdx의 세부 사항을 쿼리하십시오. 구문 검색은 0부터 시작하여 번호가 매겨 지므로 iIdx 인수는 0보다 크거나 같아야하며 xInstCount ()가 출력 한 값보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">쿼리 최적화 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">쿼리 최적화 기능 개선 :</target>
        </trans-unit>
        <trans-unit id="65d2f2329c994ccea3b5e213a1d1b909c0f33338" translate="yes" xml:space="preserve">
          <source>Query or change a limit on the &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; setting. This is approximate number of rows examined in each index by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. If the argument</source>
          <target state="translated">&lt;a href=&quot;lang_analyze#approx&quot;&gt;대략적인 ANALYZE&lt;/a&gt; 설정 에 대한 제한을 쿼리하거나 변경 합니다. 이것은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령으로 각 인덱스에서 검사 한 대략적인 행 수입니다 . 인수가</target>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">count-changes 플래그를 조회하거나 변경하십시오. 일반적으로 count-changes 플래그가 설정되지 않은 경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문은 데이터를 리턴하지 않습니다. count-changes가 설정되면 이러한 각 명령은 하나의 정수 값 (명령으로 삽입, 수정 또는 삭제 된 행 수)으로 구성된 단일 데이터 행을 리턴합니다. 반환 된 변경 수에는 트리거에 의해 수행 된 삽입, 수정 또는 삭제, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업에&lt;/a&gt; 의해 자동으로 수행 된 변경 또는 &lt;a href=&quot;lang_upsert&quot;&gt;upsert로&lt;/a&gt; 인한 업데이트가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">empty-result-callbacks 플래그를 조회하거나 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">full_column_names 플래그를 조회하거나 변경하십시오. &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; 플래그 와 함께이 플래그는 SQLite가 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 열에 이름을 지정하는 방법을 결정합니다 . 결과 열은 다음 규칙을 순서대로 적용하여 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업을 위한 fullfsync 플래그를 쿼리하거나 변경합니다 . 이 플래그가 설정되면 F_FULLFSYNC를 지원하는 시스템에서 검사 점 작업 중에 F_FULLFSYNC 동기화 방법이 사용됩니다. checkpoint_fullfsync 플래그의 기본값은 해제입니다. Mac OS-X 만 F_FULLFSYNC를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">fullfsync 플래그를 조회하거나 변경하십시오. 이 플래그는 F_FULLFSYNC 동기화 방법이이를 지원하는 시스템에서 사용되는지 여부를 결정합니다. fullfsync 플래그의 기본값은 해제입니다. Mac OS X 만 F_FULLFSYNC를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">단일 데이터베이스에서 메모리 매핑 된 I / O를 위해 설정된 최대 바이트 수를 쿼리하거나 변경하십시오. 첫 번째 형식 (인수없이)은 현재 제한을 쿼리합니다. 두 번째 형식 (숫자 인수 포함)은 지정된 데이터베이스 또는 선택적 데이터베이스 이름이 생략 된 경우 모든 데이터베이스에 대한 한계를 설정합니다. 두 번째 양식에서 데이터베이스 이름이 생략되면, 설정된 한계는 후속 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문에 의해 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 추가되는 모든 데이터베이스의 기본 한계가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b3761ba731b4ca68bda2cd1e8fe9ffa86d5d2f0" translate="yes" xml:space="preserve">
          <source>Query or change the secure-delete setting. When secure_delete is on, SQLite overwrites deleted content with zeros. The default setting for secure_delete is determined by the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option and is normally off. The off setting for secure_delete improves performance by reducing the number of CPU cycles and the amount of disk I/O. Applications that wish to avoid leaving forensic traces after content is deleted or updated should enable the secure_delete pragma prior to performing the delete or update, or else run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; after the delete or update.</source>
          <target state="translated">보안 삭제 설정을 조회하거나 변경하십시오. secure_delete가 설정되면 SQLite는 삭제 된 내용을 0으로 덮어 씁니다. secure_delete의 기본 설정은 &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; 컴파일 타임 옵션에 의해 결정되며 일반적으로 해제되어 있습니다. secure_delete의 꺼짐 설정은 CPU주기 수와 디스크 I / O 양을 줄임으로써 성능을 향상시킵니다. 컨텐츠를 삭제하거나 업데이트 한 후 포렌식 추적을 남기지 않으려는 애플리케이션은 삭제 또는 업데이트를 수행하기 전에 secure_delete pragma를 활성화하거나 삭제 또는 업데이트 후에 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="de56ca3e30c1c074a1fd98f6d3fdce5680f699b3" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;&lt;b&gt;temp_store&lt;/b&gt;&quot; parameter. When temp_store is DEFAULT (0), the compile-time C preprocessor macro &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; is used to determine where temporary tables and indices are stored. When temp_store is MEMORY (2) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are kept in as if they were pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; memory. When temp_store is FILE (1) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are stored in a file. The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma can be used to specify the directory containing temporary files when &lt;b&gt;FILE&lt;/b&gt; is specified. When the temp_store setting is changed, all existing temporary tables, indices, triggers, and views are immediately deleted.</source>
          <target state="translated">&quot; &lt;b&gt;temp_store&lt;/b&gt; &quot;매개 변수 의 설정을 조회하거나 변경하십시오 . temp_store가 DEFAULT (0) 인 경우 컴파일 타임 C 프리 프로세서 매크로 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 를 사용하여 임시 테이블 및 인덱스가 저장되는 위치를 결정합니다. temp_store가 MEMORY (2) 인 경우 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스는 순수한 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 메모리 인 것처럼 유지됩니다 . temp_store가 FILE (1) 인 경우 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스는 파일에 저장됩니다. &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma는 경우 임시 파일을 포함하는 디렉토리를 지정하는 데 사용할 수있는 &lt;b&gt;파일을&lt;/b&gt; 지정합니다. temp_store 설정이 변경되면 기존의 모든 임시 테이블, 인덱스, 트리거 및 뷰가 즉시 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb005d9ab4e0804f12c87dee002073b411d274d" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;synchronous&quot; flag. The first (query) form will return the synchronous setting as an integer. The second form changes the synchronous setting. The meanings of the various synchronous settings are as follows:</source>
          <target state="translated">&quot;동기&quot;플래그 설정을 조회하거나 변경하십시오. 첫 번째 (쿼리) 형식은 동기 설정을 정수로 반환합니다. 두 번째 형식은 동기 설정을 변경합니다. 다양한 동기 설정의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dcfcd54b0505cd09f50244da9bbd756766eef81" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;busy timeout&lt;/a&gt;. This pragma is an alternative to the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; C-language interface which is made available as a pragma for use with language bindings that do not provide direct access to &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;통화 중 시간 초과&lt;/a&gt; 설정을 쿼리하거나 변경합니다 . 이 pragma는 대안입니다 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 에 직접 액세스 제공하지 않는 언어 바인딩과 함께 사용할 수있는 프라 그마로 사용할 수 있습니다 C 언어 인터페이스 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6f0cf05490ce574881ff5675cbd192d91cf992" translate="yes" xml:space="preserve">
          <source>Query or change the short-column-names flag. This flag affects the way SQLite names columns of data returned by &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. See the &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma for full details.</source>
          <target state="translated">short-column-names 플래그를 조회하거나 변경하십시오. 이 플래그는 SQLite가 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에서 반환 한 데이터 열의 이름을 지정하는 방식에 영향을줍니다 . 자세한 내용은 &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c472dc3fc7ff36d8acee51946b1687ac08bd59fe" translate="yes" xml:space="preserve">
          <source>Query or change the suggested maximum number of database disk pages that SQLite will hold in memory at once per open database file. Whether or not this suggestion is honored is at the discretion of the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;Application Defined Page Cache&lt;/a&gt;. The default page cache that is built into SQLite honors the request, however alternative application-defined page cache implementations may choose to interpret the suggested cache size in different ways or to ignore it all together. The default suggested cache size is -2000, which means the cache size is limited to 2048000 bytes of memory. The default suggested cache size can be altered using the &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; compile-time options. The TEMP database has a default suggested cache size of 0 pages.</source>
          <target state="translated">SQLite가 열린 데이터베이스 파일 당 한 번에 메모리에 보유 할 제안 된 최대 데이터베이스 디스크 페이지 수를 조회하거나 변경하십시오. 이 제안이 적용되는지 여부는 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;응용 프로그램 정의 페이지 캐시&lt;/a&gt; 의 재량에 따릅니다 . SQLite에 기본 제공되는 기본 페이지 캐시는 요청을 받아들이지 만 대체 응용 프로그램 정의 페이지 캐시 구현은 제안 된 캐시 크기를 다른 방식으로 해석하거나 함께 무시하도록 선택할 수 있습니다. 기본 제안 된 캐시 크기는 -2000이며, 이는 캐시 크기가 2048000 바이트의 메모리로 제한됨을 의미합니다. 기본 제안 된 캐시 크기는 &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; 컴파일 시간 옵션을 사용하여 변경할 수 있습니다. TEMP 데이터베이스의 기본 제안 된 캐시 크기는 0 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="38317b0c0d1df51bd83790ce312ba13da0c5ed05" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable, which windows operating-system interface backends use to determine where to store database files specified using a relative pathname.</source>
          <target state="translated">Windows 운영 체제 인터페이스 백엔드가 상대 경로 이름을 사용하여 지정된 데이터베이스 파일을 저장할 위치를 결정하는 데 사용 하는 &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 글로벌 변수 의 값을 조회하거나 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="f61590ed5a58a97ecca18f3fbb40bf0ae63fb037" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) limit for the current database connection. This limit sets an upper bound on the number of auxiliary threads that a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is allowed to launch to assist with a query. The default limit is 0 unless it is changed using the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option. When the limit is zero, that means no auxiliary threads will be launched.</source>
          <target state="translated">현재 데이터베이스 연결 에 대한 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; , ...) 한계 값을 쿼리하거나 변경하십시오 . 이 한계는 쿼리를 지원하기 위해 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 실행할 수있는 보조 스레드 수의 상한을 설정 합니다. &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; 컴파일 타임 옵션을 사용하여 변경하지 않는 한 기본 한계는 0 입니다. 한계가 0이면 보조 스레드가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ad35fae3f5b98f4ef0cd9485074046877d96539" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable, which many operating-system interface backends use to determine where to store &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices.</source>
          <target state="translated">많은 운영 체제 인터페이스 백엔드가 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스 를 저장할 위치를 결정하는 데 사용 하는 &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 글로벌 변수 의 값을 쿼리하거나 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5866fac6602f3e40c19df259ea318d2b63caf2bd" translate="yes" xml:space="preserve">
          <source>Query or set the auto-vacuum status in the database.</source>
          <target state="translated">데이터베이스에서 자동 진공 상태를 조회하거나 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cc5d0ecc46bacf93e04d7b7978224221ecdf262" translate="yes" xml:space="preserve">
          <source>Query or set the maximum number of pages in the database file. Both forms of the pragma return the maximum page count. The second form attempts to modify the maximum page count. The maximum page count cannot be reduced below the current database size.</source>
          <target state="translated">데이터베이스 파일의 최대 페이지 수를 쿼리하거나 설정하십시오. pragma의 두 가지 형식 모두 최대 페이지 수를 반환합니다. 두 번째 양식은 최대 페이지 수 수정을 시도합니다. 최대 페이지 수는 현재 데이터베이스 크기 아래로 줄어들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b4e54fcf1e120591a5a6535bff6e2b69b86d7df" translate="yes" xml:space="preserve">
          <source>Query or set the page size of the database. The page size must be a power of two between 512 and 65536 inclusive.</source>
          <target state="translated">데이터베이스의 페이지 크기를 쿼리하거나 설정하십시오. 페이지 크기는 512에서 65536 사이의 2의 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="627a1950bccb0926f06969a3db2d136c3cabdca5" translate="yes" xml:space="preserve">
          <source>Query planner checklist</source>
          <target state="translated">쿼리 플래너 체크리스트</target>
        </trans-unit>
        <trans-unit id="e93c39912e396551e04ed9b46c1ea823e2d8b3bb" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - automatic transient indices are created when doing so reduces the estimated query time.</source>
          <target state="translated">쿼리 플래너 향상-자동 임시 색인이 작성되면 예상 쿼리 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="15e2bd2467aae946e711f6cc5ade007f83eb3c87" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - the ORDER BY becomes a no-op if the query also contains a GROUP BY clause that forces the correct output order.</source>
          <target state="translated">쿼리 플래너 향상-쿼리에 올바른 출력 순서를 강제하는 GROUP BY 절이 포함되어 있으면 ORDER BY가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26786d5880615e168b7819292d8f2bd689ef42b3" translate="yes" xml:space="preserve">
          <source>Query planner enhancement: Use the transitive property of constraints to move constraints into the outer loops of a join whenever possible, thereby reducing the amount of work that needs to occur in inner loops.</source>
          <target state="translated">쿼리 플래너 향상 : 제한 조건의 전이 특성을 사용하여 가능할 때마다 제한 조건을 결합의 외부 루프로 이동하여 내부 루프에서 발생해야하는 작업량을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="736e85cef8966360d93b45933c07771905d6a0b9" translate="yes" xml:space="preserve">
          <source>Query planner enhancements.</source>
          <target state="translated">쿼리 플래너 향상</target>
        </trans-unit>
        <trans-unit id="c7e16cd25b99db12dc36d4eb42e08d056acec1b1" translate="yes" xml:space="preserve">
          <source>Query planner enhancements:</source>
          <target state="translated">쿼리 플래너 향상 :</target>
        </trans-unit>
        <trans-unit id="666ab0644bcf7abdf389c79c890bad61c7c7fec2" translate="yes" xml:space="preserve">
          <source>Query planner improvements:</source>
          <target state="translated">쿼리 플래너 개선 :</target>
        </trans-unit>
        <trans-unit id="b2b452d242e61d8f7480bffaae127bf001921fa3" translate="yes" xml:space="preserve">
          <source>Query planner stability guarantee</source>
          <target state="translated">쿼리 플래너 안정성 보장</target>
        </trans-unit>
        <trans-unit id="ca5891ff28346fccc5150a605b02b68689910ebb" translate="yes" xml:space="preserve">
          <source>Query planners are what make SQL database engines so amazingly useful and powerful. (This is true of all SQL database engines, not just SQLite.) The query planner frees the programmer from the chore of selecting a particular query plan, and thereby allows the programmer to focus more mental energy on higher-level application issues and on providing more value to the end user. For simple queries where the choice of query plan is obvious, this is convenient but not hugely important. But as applications and schemas and queries grow more complex, a clever query planner can greatly speed and simplify the work of application development. There is amazing power in being about to tell the database engine what content is desired, and then let the database engine figure out the best way to retrieve that content.</source>
          <target state="translated">쿼리 플래너는 SQL 데이터베이스 엔진을 매우 유용하고 강력하게 만드는 요소입니다. (이는 SQLite뿐만 아니라 모든 SQL 데이터베이스 엔진에도 적용됩니다.) 쿼리 플래너는 프로그래머가 특정 쿼리 계획을 선택해야하는 번거 로움을 없애고 프로그래머가 더 높은 수준의 응용 프로그램 문제 및 제공에 정신적 에너지를 집중할 수 있도록합니다. 최종 사용자에게 더 많은 가치. 쿼리 계획의 선택이 명백한 간단한 쿼리의 경우 편리하지만 크게 중요하지는 않습니다. 그러나 응용 프로그램과 스키마 및 쿼리가 더욱 복잡 해짐에 따라 영리한 쿼리 플래너는 응용 프로그램 개발 작업을 크게 가속화하고 단순화 할 수 있습니다. 데이터베이스 엔진에 원하는 컨텐츠를 알려주고 데이터베이스 엔진이 해당 컨텐츠를 검색하는 가장 좋은 방법을 찾도록하는 놀라운 힘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee854629ae78a2199bdb56da8e286e6006b5d8d" translate="yes" xml:space="preserve">
          <source>Query results are returned as a list of column values. If a query requests 2 columns and there are 3 rows matching the query, then the returned list will contain 6 elements. For example:</source>
          <target state="translated">쿼리 결과는 열 값 목록으로 반환됩니다. 쿼리가 2 개의 열을 요청하고 쿼리와 일치하는 3 개의 행이 있으면 반환 된 목록에 6 개의 요소가 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cb7820ab431080267a59361b01e9af99b0f2f7" translate="yes" xml:space="preserve">
          <source>Query, set, or clear READ UNCOMMITTED isolation. The default isolation level for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except between connections that share a common page and schema cache. Cache sharing is enabled using the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API. Cache sharing is disabled by default.</source>
          <target state="translated">커밋되지 않은 읽기 격리를 쿼리, 설정 또는 지 웁니다. SQLite의 기본 격리 수준은 SERIALIZABLE입니다. 모든 프로세스 또는 스레드는 커밋되지 않은 읽기 격리를 선택할 수 있지만 공통 페이지와 스키마 캐시를 공유하는 연결을 제외하고는 SERIALIZABLE이 계속 사용됩니다. 캐시 공유는 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; API를 사용하여 활성화 됩니다. 캐시 공유는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0366bdd9a4ae5e944fbf6092ddc8900d9aeaaed5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; capability.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱싱&lt;/a&gt; 기능을 쿼리, 설정 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="14ccb18dde2fc34367c93b804727ccf1143765e5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 의 적용을 쿼리, 설정 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="160bfb7a8121ce10fe672d852b6ba0dcf536c5e1" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the recursive trigger capability.</source>
          <target state="translated">재귀 트리거 기능을 쿼리, 설정 또는 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="bf0ed56a136cbe5ffad095931c71813d09f0273f" translate="yes" xml:space="preserve">
          <source>Questions and confusion quickly arose on the &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about the purpose behind these new interfaces, why they were introduced, and what problem they solve. This essay attempts to answer those questions and clear up the confusion.</source>
          <target state="translated">이러한 새로운 인터페이스의 목적, 도입 된 이유 및 해결되는 문제 에 대한 &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;메일 링리스트&lt;/a&gt; 에서 질문과 혼란이 빠르게 일어났습니다 . 이 에세이는 이러한 질문에 답하고 혼란을 해결하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6fb0e0d11a03f78b5ecb2f7f8b42ef10b6e101e0" translate="yes" xml:space="preserve">
          <source>Questions like these (and countless others) can be answered without having to uncompress or extract any content.</source>
          <target state="translated">내용을 압축 해제하거나 추출 할 필요없이 이러한 질문 (및 수많은 다른 질문)에 답변 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09a7d1d2da3256534f8a2a26b3d747dbae8b2a14" translate="yes" xml:space="preserve">
          <source>Quirks, Caveats, and Gotchas In SQLite</source>
          <target state="translated">SQLite의 Quirks, Caveats 및 Gotchas</target>
        </trans-unit>
        <trans-unit id="9432058147a91a2c4afeff95adc17f4930b4c6b9" translate="yes" xml:space="preserve">
          <source>R (cost: 3.56)</source>
          <target state="translated">R (비용 : 3.56)</target>
        </trans-unit>
        <trans-unit id="37abd4d23bc413fb5db77feee86f46ad0b861e2d" translate="yes" xml:space="preserve">
          <source>R*Tree Module</source>
          <target state="translated">R * 트리 모듈</target>
        </trans-unit>
        <trans-unit id="43ea99300f03323c6239855a57c58f91be6c0d63" translate="yes" xml:space="preserve">
          <source>R-N1 (cost: 7.03)</source>
          <target state="translated">R-N1 (비용 : 7.03)</target>
        </trans-unit>
        <trans-unit id="00f923142bbc27eb285a9f64b857d908b86719d8" translate="yes" xml:space="preserve">
          <source>R-N1-C (cost: 13.43)</source>
          <target state="translated">R-N1-C (비용 : 13.43)</target>
        </trans-unit>
        <trans-unit id="f743ed80cd4af3e3dd6aaa0242ee69bf26b480c0" translate="yes" xml:space="preserve">
          <source>R-N1-N2 (cost: 12.55)</source>
          <target state="translated">R-N1-N2 (비용 : 12.55)</target>
        </trans-unit>
        <trans-unit id="12fc721fdde87226fb7f977e95887d024b7fef9e" translate="yes" xml:space="preserve">
          <source>R-N1-P (cost: 14.74)</source>
          <target state="translated">R-N1-P (비용 : 14.74)</target>
        </trans-unit>
        <trans-unit id="fab85d63ca52ab34a7d0d4d635cb4434f4c73c7c" translate="yes" xml:space="preserve">
          <source>R-N2 (cost: 9.08)</source>
          <target state="translated">R-N2 (비용 : 9.08)</target>
        </trans-unit>
        <trans-unit id="2a3b1ad1ab0d9afa5d157dd5a7723841765c8a20" translate="yes" xml:space="preserve">
          <source>R-N2-S (cost: 15.08)</source>
          <target state="translated">R-N2-S (비용 : 15.08)</target>
        </trans-unit>
        <trans-unit id="181200f18a6abb830d9a1e4da77cb05da7c0b226" translate="yes" xml:space="preserve">
          <source>R-P {cost: 11.27}</source>
          <target state="translated">RP {비용 : 11.27}</target>
        </trans-unit>
        <trans-unit id="a39f8b032fb6773009f23cdf1fc4a43dca07ca75" translate="yes" xml:space="preserve">
          <source>R-tree indexes</source>
          <target state="translated">R- 트리 인덱스</target>
        </trans-unit>
        <trans-unit id="27625665a48434a97da2f59bce85a61c08c57d13" translate="yes" xml:space="preserve">
          <source>RAISE</source>
          <target state="translated">RAISE</target>
        </trans-unit>
        <trans-unit id="eab70b41d287161d06757b3c91f16b40700edd9b" translate="yes" xml:space="preserve">
          <source>RAISE function</source>
          <target state="translated">인상 기능</target>
        </trans-unit>
        <trans-unit id="578e6dad8d99e7211a3086f6ebcd1836a6b2b2b0" translate="yes" xml:space="preserve">
          <source>RANGE</source>
          <target state="translated">RANGE</target>
        </trans-unit>
        <trans-unit id="ddd7e61302a8592bafc0bc44fda92b4c46585957" translate="yes" xml:space="preserve">
          <source>RANGE frames</source>
          <target state="translated">범위 프레임</target>
        </trans-unit>
        <trans-unit id="3314a11c461e2d3c3169c9709d07e23cec14a354" translate="yes" xml:space="preserve">
          <source>RANGE n PRECEDING</source>
          <target state="translated">범위 n 선행</target>
        </trans-unit>
        <trans-unit id="f4c206eeb5c6f3b744195c276954fdb473ea9623" translate="yes" xml:space="preserve">
          <source>RBU Database Contents</source>
          <target state="translated">RBU 데이터베이스 내용</target>
        </trans-unit>
        <trans-unit id="712d8aa663fc4fe498c4350eb3d107a2e61b11c3" translate="yes" xml:space="preserve">
          <source>RBU Database Tables</source>
          <target state="translated">RBU 데이터베이스 테이블</target>
        </trans-unit>
        <trans-unit id="07201c49e16cf7ee53c14561a1009692319b08f1" translate="yes" xml:space="preserve">
          <source>RBU Extension</source>
          <target state="translated">RBU 확장</target>
        </trans-unit>
        <trans-unit id="e78ae84baf56b93a5fa01e9dafad71c1200f7218" translate="yes" xml:space="preserve">
          <source>RBU FTS3/4 Tables</source>
          <target state="translated">RBU FTS3 / 4 테이블</target>
        </trans-unit>
        <trans-unit id="462b7e20bcfb4a1c16aa1cac30ebb2f5b6113539" translate="yes" xml:space="preserve">
          <source>RBU Update</source>
          <target state="translated">RBU 업데이트</target>
        </trans-unit>
        <trans-unit id="fa41f4d5c464fe94904b941d3fdd9fd06f70c8d7" translate="yes" xml:space="preserve">
          <source>RBU Vacuum</source>
          <target state="translated">RBU 진공</target>
        </trans-unit>
        <trans-unit id="29b65cd1a0583c71c8f08f136996230310e8af2c" translate="yes" xml:space="preserve">
          <source>RBU Vacuum applications all implement some variation of the following procedure:</source>
          <target state="translated">RBU 진공 애플리케이션은 모두 다음 절차의 일부 변형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5f247eac406d30bce84777c8b0ea049a1e0cac26" translate="yes" xml:space="preserve">
          <source>RBU operations may be suspended and then later resumed, perhaps with intervening power outages and/or system resets. For an RBU update, the original database content remains visible to all database readers until the entire update has been applied - even if the update is suspended and then later resumed.</source>
          <target state="translated">RBU 작업이 일시 중단 된 다음 나중에 중단 될 수 있습니다 (중간 정전 및 / 또는 시스템 재설정). RBU 업데이트의 경우 업데이트가 일시 중지 된 후 나중에 다시 시작 되더라도 전체 업데이트가 적용될 때까지 원본 데이터베이스 내용이 모든 데이터베이스 판독기에 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="51d4c96a1d92222b7d93c52475b51db8766c79b8" translate="yes" xml:space="preserve">
          <source>RBU updates cannot be applied to any tables that contain a column named &quot;rbu_control&quot;.</source>
          <target state="translated">&quot;rbu_control&quot;이라는 열이 포함 된 테이블에는 RBU 업데이트를 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="d2c4a8bcf4efc09f908cb4e40d7d6f381c3c3ef0" translate="yes" xml:space="preserve">
          <source>RECURSIVE</source>
          <target state="translated">RECURSIVE</target>
        </trans-unit>
        <trans-unit id="d4730753022e62db3135b00e0df88859d25187e8" translate="yes" xml:space="preserve">
          <source>REFERENCES</source>
          <target state="translated">REFERENCES</target>
        </trans-unit>
        <trans-unit id="2347c845abd05fb0d1bae0ab927335b643793946" translate="yes" xml:space="preserve">
          <source>REGEXP</source>
          <target state="translated">REGEXP</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="f73b278fdabab028fe5f65c62197e4b5634529e5" translate="yes" xml:space="preserve">
          <source>RELEASE</source>
          <target state="translated">RELEASE</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">릴리즈 포인트</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="a464c34da3d7dbc3eb6ade113363a4f1b48466a0" translate="yes" xml:space="preserve">
          <source>RENAME COLUMN</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="eb5450aba42e33754272b8b32dc01c695827c179" translate="yes" xml:space="preserve">
          <source>REPLACE INTO</source>
          <target state="translated">로 교체</target>
        </trans-unit>
        <trans-unit id="044eabc2191e6bd2b8395304f84a790584ab5cd3" translate="yes" xml:space="preserve">
          <source>RESERVED</source>
          <target state="translated">RESERVED</target>
        </trans-unit>
        <trans-unit id="69ed002a9f57d1ba3022c561c2f3bb595bf68418" translate="yes" xml:space="preserve">
          <source>RESTART</source>
          <target state="translated">RESTART</target>
        </trans-unit>
        <trans-unit id="99e2cdb8b048ca3999469c35242023f92980f5e6" translate="yes" xml:space="preserve">
          <source>RESTRICT</source>
          <target state="translated">RESTRICT</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="1b38c7ab7be8eb4066bc5bd507af4275ed737be5" translate="yes" xml:space="preserve">
          <source>ROLLBACK TRANSACTION</source>
          <target state="translated">롤백 거래</target>
        </trans-unit>
        <trans-unit id="fee8f3fde6222d1d587520ccdcc8bdc883934e5b" translate="yes" xml:space="preserve">
          <source>ROW</source>
          <target state="translated">ROW</target>
        </trans-unit>
        <trans-unit id="27bcbad0c7dc6e890992a45957c32cb63b180961" translate="yes" xml:space="preserve">
          <source>ROWID</source>
          <target state="translated">ROWID</target>
        </trans-unit>
        <trans-unit id="1066d5101585674b0bf2bb2a7f36e54bd28ffb0c" translate="yes" xml:space="preserve">
          <source>ROWIDs and the INTEGER PRIMARY KEY</source>
          <target state="translated">ROWID 및 정수 기본 키</target>
        </trans-unit>
        <trans-unit id="35c47b79dc3cdab698d2bf71b053c1b257f8db73" translate="yes" xml:space="preserve">
          <source>ROWS</source>
          <target state="translated">ROWS</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="912333c4ddec40db71424e4b21120e0065cfde78" translate="yes" xml:space="preserve">
          <source>RTRIM collating function</source>
          <target state="translated">RTRIM 조합 기능</target>
        </trans-unit>
        <trans-unit id="d4ccca8588cab0a99233c6cf71400747dcf81d92" translate="yes" xml:space="preserve">
          <source>RTRIM is like BINARY except that extra spaces at the end of either string do not change the result. In other words, strings will compare equal to one another as long as they differ only in the number of spaces at the end.</source>
          <target state="translated">RTRIM은 BINARY와 비슷하지만 문자열 끝에 여분의 공백이 있으면 결과가 변경되지 않습니다. 다시 말해서, 문자열은 끝에 공백 수가 다른 한 문자열과 서로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="73bc329996a4b61f272d21a8ef8e13d37b2f5bf8" translate="yes" xml:space="preserve">
          <source>Raising the number of open databases may improve performance in some scenarios.</source>
          <target state="translated">열린 데이터베이스 수를 늘리면 일부 시나리오에서 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62e76ddc1a4a4c5a8b50ba8345b20a992c2b937" translate="yes" xml:space="preserve">
          <source>Range query optimization</source>
          <target state="translated">범위 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="415026844c74bb5d00489173b1d5e1a90b70bfca" translate="yes" xml:space="preserve">
          <source>Raw (possibly compressed) data associated with zip file entry (a blob).</source>
          <target state="translated">zip 파일 항목 (blob)과 관련된 원시 (압축 가능) 데이터</target>
        </trans-unit>
        <trans-unit id="3685a628a8d194c36e92956d9b368621a3c4f89e" translate="yes" xml:space="preserve">
          <source>Reactivated the VACUUM command that reclaims unused disk space in a database file.</source>
          <target state="translated">데이터베이스 파일에서 사용되지 않은 디스크 공간을 회수하는 VACUUM 명령을 재 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="7bf4a534bd19935da933046f9a9ff7be5b6a7965" translate="yes" xml:space="preserve">
          <source>Read Data From A BLOB Incrementally</source>
          <target state="translated">BLOB에서 증 분식으로 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="4817ee387eb1c80d362458e295a1ce28b034e185" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the SQLITE_MASTER table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">WHERE 절 P4와 일치하는 데이터베이스 P1의 SQLITE_MASTER 테이블에서 모든 항목을 읽고 구문 분석하십시오. P4가 NULL 포인터이면 P1에 대한 전체 스키마가 재분석됩니다.</target>
        </trans-unit>
        <trans-unit id="427a567a06032b13c88b02d33d153fca76063c5d" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the schema table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">WHERE 절 P4와 일치하는 데이터베이스 P1의 스키마 테이블에서 모든 항목을 읽고 구문 분석합니다. P4가 NULL 포인터이면 P1의 전체 스키마가 다시 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="06b6a6259408a05057f38693264034af5b800655" translate="yes" xml:space="preserve">
          <source>Read and/or write the content of a comma-separated value (CSV) file</source>
          <target state="translated">CSV (쉼표로 구분 된 값) 파일의 내용을 읽거나 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="37ad8caf62966373ce6c4e8d0b90dbca553a6d76" translate="yes" xml:space="preserve">
          <source>Read cookie number P3 from database P1 and write it into register P2. P3==1 is the schema version. P3==2 is the database format. P3==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">데이터베이스 P1에서 쿠키 번호 P3을 읽고 레지스터 P2에 씁니다. P3 == 1은 스키마 버전입니다. P3 == 2는 데이터베이스 형식입니다. P3 == 3은 권장 된 호출기 캐시 크기 등입니다. P1 == 0은 기본 데이터베이스 파일이고 P1 == 1은 임시 테이블을 저장하는 데 사용되는 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="e71f89bd0ef9b4251c544f6970cc91848cb5836e" translate="yes" xml:space="preserve">
          <source>Read the journal file and roll back the changes.</source>
          <target state="translated">저널 파일을 읽고 변경 사항을 롤백하십시오.</target>
        </trans-unit>
        <trans-unit id="6d88c31d2b81845a511df588f6a77f45dfc3be73" translate="yes" xml:space="preserve">
          <source>Read the sqlite_stat1 table for database P1 and load the content of that table into the internal index hash table. This will cause the analysis to be used when preparing all subsequent queries.</source>
          <target state="translated">데이터베이스 P1에 대한 sqlite_stat1 테이블을 읽고 해당 테이블의 컨텐츠를 내부 인덱스 해시 테이블에로드하십시오. 이로 인해 모든 후속 쿼리를 준비 할 때 분석이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e44b30ba60fce1cc60703c777be280cb42ce89f" translate="yes" xml:space="preserve">
          <source>Read transactions versus write transactions</source>
          <target state="translated">읽기 트랜잭션과 쓰기 트랜잭션</target>
        </trans-unit>
        <trans-unit id="c8e239ec9521392219205446c1db66f47cb14a6f" translate="yes" xml:space="preserve">
          <source>Read-mark name</source>
          <target state="translated">읽기 마크 이름</target>
        </trans-unit>
        <trans-unit id="e722ca5fefcf08950d7578b4ed97dfff47cf060e" translate="yes" xml:space="preserve">
          <source>Read-mark offset</source>
          <target state="translated">읽기 마크 오프셋</target>
        </trans-unit>
        <trans-unit id="54ac153bd485005c1470e6c415d25c56cea6db82" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the</source>
          <target state="translated">커밋되지 않은 읽기 모드는 데이터베이스 테이블에 쓰는 데 필요한 잠금에 영향을 미치지 않습니다 (즉, 커밋되지 않은 읽기 연결은 여전히 ​​쓰기 잠금을 얻어야하므로 데이터베이스 쓰기가 여전히 차단되거나 차단 될 수 있음). 또한 커밋되지 않은 읽기 모드는</target>
        </trans-unit>
        <trans-unit id="0f2ef9917dd28993c09e6d3368ecafd38ec21fd3" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; locks required by the rules enumerated below (see section &quot;Schema (sqlite_schema) Level Locking&quot;).</source>
          <target state="translated">커밋되지 않은 읽기 모드는 데이터베이스 테이블에 쓰는 데 필요한 잠금에 영향을 미치지 않습니다 (즉, 커밋되지 않은 읽기 연결은 여전히 ​​쓰기 잠금을 획득해야하므로 데이터베이스 쓰기는 여전히 차단되거나 차단 될 수 있습니다). 또한 커밋되지 않은 읽기 모드는 아래 열거 된 규칙에 필요한 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 잠금 에 영향을주지 않습니다 ( &quot;스키마 (sqlite_schema) 수준 잠금&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="3be7f0a767b2f2348fac25e36a455df9d59b0aa8" translate="yes" xml:space="preserve">
          <source>ReadCookie</source>
          <target state="translated">ReadCookie</target>
        </trans-unit>
        <trans-unit id="31f3f980bf6aafbf0b6a01d8c93e178b55b84057" translate="yes" xml:space="preserve">
          <source>Readers can also interpret this document as a primer on the world-view of the SQLite Founder, to help them better understand &quot;where he is coming from&quot;.</source>
          <target state="translated">독자는이 문서를 SQLite Founder의 세계관에서 입문서로 해석하여 &quot;어디에서 왔는지&quot;를 더 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8a4ca543f39205e57cdf686189d6cb9f899366" translate="yes" xml:space="preserve">
          <source>Reading Data</source>
          <target state="translated">데이터 읽기</target>
        </trans-unit>
        <trans-unit id="d6ac804a10ccff7c120f27eba34a8d2846e4c951" translate="yes" xml:space="preserve">
          <source>Reading Database Data</source>
          <target state="translated">데이터베이스 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="5e3252839a95733cfd147953cc0469ba8c3ee82b" translate="yes" xml:space="preserve">
          <source>Reading and writing from an SQLite database is often faster than reading and writing individual files from disk. See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt;.</source>
          <target state="translated">디스크에서 개별 파일을 읽고 쓰는 것보다 SQLite 데이터베이스에서 읽고 쓰는 것이 더 빠릅니다. 참조 &lt;a href=&quot;fasterthanfs&quot;&gt;빠른 파일 시스템보다 35 %&lt;/a&gt; 와 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;외부에 BLOB 대 내부&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="629464bd60f83394a3a117af1490178a3f7649b8" translate="yes" xml:space="preserve">
          <source>Reading is about an order of magnitude faster than writing, for all systems and for both SQLite and direct-to-disk I/O.</source>
          <target state="translated">읽기는 모든 시스템과 SQLite 및 디스크 직접 I / O 모두 쓰기보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8e16e5b2c446aea3b142d9320755f82932fc2cdf" translate="yes" xml:space="preserve">
          <source>Real</source>
          <target state="translated">Real</target>
        </trans-unit>
        <trans-unit id="51b9846d84b8915556858261f582bc9dc0399f32" translate="yes" xml:space="preserve">
          <source>RealAffinity</source>
          <target state="translated">RealAffinity</target>
        </trans-unit>
        <trans-unit id="316d0580c3ad15b3966bd98be1d84957c1e60292" translate="yes" xml:space="preserve">
          <source>Realign the memory allocation subsystem so that it never calls malloc() at all but instead satisfies all memory requests using a fixed-size memory buffer assigned to SQLite at startup.</source>
          <target state="translated">메모리 할당 서브 시스템을 다시 정렬하여 malloc ()을 전혀 호출하지 않고 시작시 SQLite에 지정된 고정 크기 메모리 버퍼를 사용하여 모든 메모리 요청을 충족 시키십시오.</target>
        </trans-unit>
        <trans-unit id="2d8e19244acdc1fed3e593bd66d86fe928aee4c4" translate="yes" xml:space="preserve">
          <source>Really means</source>
          <target state="translated">정말 의미</target>
        </trans-unit>
        <trans-unit id="9da9cf4099ea26b56238081e57a06dfa3fa584c9" translate="yes" xml:space="preserve">
          <source>Rebase a changeset</source>
          <target state="translated">체인지 셋 리베이스</target>
        </trans-unit>
        <trans-unit id="f4699eec6b4e510d56bd2c8d9d97198adba02986" translate="yes" xml:space="preserve">
          <source>Rebasing changesets</source>
          <target state="translated">기초 변경 모음</target>
        </trans-unit>
        <trans-unit id="2ef8fffd38b336e3ddd055d82551d4885c779b2a" translate="yes" xml:space="preserve">
          <source>Recall that by default SQLite assumes that sector writes are linear but not atomic. A linear write starts at one end of the sector and changes information byte by byte until it gets to the other end of the sector. If a power loss occurs in the middle of a linear write then part of the sector might be modified while the other end is unchanged. In an atomic sector write, either the entire sector is overwritten or else nothing in the sector is changed.</source>
          <target state="translated">기본적으로 SQLite는 섹터 쓰기가 선형이지만 원자는 아니라고 가정합니다. 선형 쓰기는 섹터의 한쪽 끝에서 시작하여 섹터의 다른 쪽 끝에 도달 할 때까지 바이트 단위로 정보를 변경합니다. 선형 쓰기 도중에 전력 손실이 발생하면 섹터의 일부가 수정되고 다른 쪽 끝은 변경되지 않을 수 있습니다. 원자 섹터 쓰기에서 전체 섹터를 덮어 쓰거나 섹터의 아무 것도 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a00f50656a9b34825cf831a680edaba10510fe56" translate="yes" xml:space="preserve">
          <source>Recall the query template discussed above where there was a single loop that searched through every record of the table. In a join we have basically the same thing except that there are nested loops. For example, to join two tables, the query template might look something like this:</source>
          <target state="translated">테이블의 모든 레코드를 검색하는 단일 루프가있는 위에서 설명한 쿼리 템플릿을 상기하십시오. 결합에서 우리는 중첩 루프가 있다는 것을 제외하고는 기본적으로 같은 것을 가지고 있습니다. 예를 들어 두 테이블을 조인하기 위해 쿼리 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86809186276b082875677dfb8773e34c548fc873" translate="yes" xml:space="preserve">
          <source>Recent versions of SQLite (&lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;version 3.5.4&lt;/a&gt; 2007-12-14) and later) will do this rewrite automatically if an index exists on the column ex2.b.</source>
          <target state="translated">ex2.b 열에 인덱스가있는 경우 최신 버전의 SQLite ( &lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;버전 3.5.4&lt;/a&gt; 2007-12-14) 이상에서 자동으로 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3bc92f0a6532d70c3844508e07c71adfd5cc6f39" translate="yes" xml:space="preserve">
          <source>Recently, folks have begun to use the word &quot;serverless&quot; to mean something subtly different from its intended meaning in this document. Here are two possible definitions of &quot;serverless&quot;:</source>
          <target state="translated">최근에 사람들은이 문서에서 의도 된 의미와 미묘하게 다른 것을 의미하기 위해 &quot;서버리스&quot;라는 단어를 사용하기 시작했습니다. &quot;서버리스&quot;에 대한 두 가지 가능한 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6aff9d1c0cd44324ba9f0bf36546b5e1f8429f77" translate="yes" xml:space="preserve">
          <source>Recognize TRUE and FALSE as constants. (For compatibility, if there exist columns named &quot;true&quot; or &quot;false&quot;, then the identifiers refer to the columns rather than Boolean constants.)</source>
          <target state="translated">TRUE 및 FALSE를 상수로 인식하십시오. 호환성을 위해 &quot;true&quot;또는 &quot;false&quot;라는 열이 있으면 식별자는 부울 상수가 아닌 열을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="179015156dce938e7897002183aef5320bee7f01" translate="yes" xml:space="preserve">
          <source>Recognize always that evil is your own doing, and to impute it to yourself.</source>
          <target state="translated">악은 자신이하는 일임을 항상 인식하고 그것을 자신에게 전가 시키십시오.</target>
        </trans-unit>
        <trans-unit id="29b5caee3338c6458807b234105f74058b4d7a0e" translate="yes" xml:space="preserve">
          <source>Recognize and use the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter in &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; 에서 &lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt; query 매개 변수를 인식하고 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb32b6d7f8df5da26a0dcd937f77f995164cb71d" translate="yes" xml:space="preserve">
          <source>Recommended practice is to omit any extra tokens in the rtree specification. Let each argument to &quot;rtree&quot; be a single ordinary label that is the name of the corresponding column, and omit all other tokens from the argument list.</source>
          <target state="translated">권장되는 방법은 rtree 사양에서 추가 토큰을 생략하는 것입니다. &quot;rtree&quot;에 대한 각 인수를 해당 열의 이름 인 단일 일반 레이블로하고 인수 목록에서 다른 모든 토큰을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="c16e180b0bdec1403e839436f75c49abbd9e4f92" translate="yes" xml:space="preserve">
          <source>Recommended storage formats are formats which, in the opinion of the preservationists at the Library of Congress, maximizes the chance of survival and continued accessibility of digital content. When selecting recommended storage formats, the following criteria are considered (quoting from the LOC website):</source>
          <target state="translated">권장 저장 형식은 의회 도서관의 보존 론자들의 견해에 따라 디지털 컨텐츠의 생존 가능성과 지속적인 접근성을 최대화하는 형식입니다. 권장 스토리지 형식을 선택할 때 다음 기준이 고려됩니다 (LOC 웹 사이트에서 인용).</target>
        </trans-unit>
        <trans-unit id="5592531a18661eb883b5bed3c568528bf424614f" translate="yes" xml:space="preserve">
          <source>Reconfigure the memory allocation subsystem to use a memory allocator other the malloc() implementation from the standard library.</source>
          <target state="translated">표준 라이브러리에서 malloc () 구현 이외의 메모리 할당자를 사용하도록 메모리 할당 서브 시스템을 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8ba4782c1f2f1755a1c2a5a0d315ff7ac146d397" translate="yes" xml:space="preserve">
          <source>Record A Database Snapshot</source>
          <target state="translated">데이터베이스 스냅 샷 기록</target>
        </trans-unit>
        <trans-unit id="8234a19b9512ea840c0ba24f55af66169cacecab" translate="yes" xml:space="preserve">
          <source>Record format</source>
          <target state="translated">기록 형식</target>
        </trans-unit>
        <trans-unit id="10c3664b2112d9f16bd331cd75392554bbbcdf62" translate="yes" xml:space="preserve">
          <source>Records may be removed from an existing zip archive by deleting the corresponding rows. For example, to remove file &quot;m.txt&quot; from zip archive &quot;test.zip&quot; using the virtual table created above:</source>
          <target state="translated">해당 행을 삭제하여 기존 zip 아카이브에서 레코드를 제거 할 수 있습니다. 예를 들어, 위에서 만든 가상 테이블을 사용하여 zip 아카이브 &quot;test.zip&quot;에서 &quot;m.txt&quot;파일을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9d25bfb94d2fc125544295d666182c0dd2c985e3" translate="yes" xml:space="preserve">
          <source>Recover snapshots from a wal file</source>
          <target state="translated">wal 파일에서 스냅 샷 복구</target>
        </trans-unit>
        <trans-unit id="a5ee4bb9875041e97087fa0bc2157c001344d43d" translate="yes" xml:space="preserve">
          <source>Recovery is run by the first thread to connect to a WAL-mode database. Recovery restores the WAL-index so that it accurately describes the WAL file. If there is no WAL file present when the first thread connects to the database, there is nothing to recover, but the recovery process still runs to initialize the WAL-index.</source>
          <target state="translated">복구는 WAL 모드 데이터베이스에 연결하기 위해 첫 번째 스레드에서 실행됩니다. 복구는 WAL 파일을 정확하게 설명하도록 WAL 색인을 복원합니다. 첫 번째 스레드가 데이터베이스에 연결할 때 WAL 파일이 없으면 복구 할 것이 없지만 복구 프로세스는 여전히 WAL 색인을 초기화하기 위해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb50e77cc812505c4eff76e2425d38fe88e897da" translate="yes" xml:space="preserve">
          <source>Recovery is the process of rebuilding the WAL-index so that it is synchronized with the WAL.</source>
          <target state="translated">복구는 WAL과 동기화되도록 WAL 인덱스를 다시 작성하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="126c442522e8176d581a74aac3e674f456801a72" translate="yes" xml:space="preserve">
          <source>Recovery works by doing a single pass over the WAL, from beginning to end. The checksums are verified on each frame of the WAL as it is read. The scan stops at the end of the file or at the first invalid checksum. The &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; field is set to the index of the last valid commit frame in WAL. Since WAL frame numbers are indexed starting with 1, mxFrame is also the number of valid frames in the WAL. A &quot;commit frame&quot; is a frame that has a non-zero value in bytes 4 through 7 of the frame header. Since the recovery procedure has no way of knowing how many frames of the WAL might have previously been copied back into the database, it initializes the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; value to zero.</source>
          <target state="translated">복구는 처음부터 끝까지 WAL을 통해 단일 패스를 수행하여 작동합니다. 체크섬은 WAL을 읽을 때 각 프레임에서 확인됩니다. 스캔은 파일 끝 또는 첫 번째 유효하지 않은 체크섬에서 중지됩니다. &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame의&lt;/a&gt; 필드 WAL에 유효한 커밋 최종 프레임의 인덱스로 설정된다. WAL 프레임 번호는 1부터 시작하여 인덱싱되므로 mxFrame도 WAL의 유효한 프레임 수입니다. &quot;커밋 프레임&quot;은 프레임 헤더의 바이트 4에서 7까지 0이 아닌 값을 갖는 프레임입니다. 복구 프로시 저는 이전에 데이터베이스에 다시 복사 된 WAL의 프레임 수를 알 수있는 방법이 없으므로 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; 값을 0으로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="3d82c021f8a8434797b007430def5edf49be84c3" translate="yes" xml:space="preserve">
          <source>Recursive Common Table Expressions</source>
          <target state="translated">재귀 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="7c623be56f37d78f01c1c7d914b54e7a24680aab" translate="yes" xml:space="preserve">
          <source>Recursive Query Examples</source>
          <target state="translated">재귀 쿼리 예제</target>
        </trans-unit>
        <trans-unit id="8f08fb34ad6f2633ad710e95a13cbec5c283657b" translate="yes" xml:space="preserve">
          <source>Recursive query</source>
          <target state="translated">재귀 쿼리</target>
        </trans-unit>
        <trans-unit id="c73052a6762ac25c0cb1d9b0bebcfc3a9bcec8a1" translate="yes" xml:space="preserve">
          <source>Recursive triggers can be enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; 문을 사용하여 재귀 트리거를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="142c98a709e57d4d546600faca999a5bf35abdaa" translate="yes" xml:space="preserve">
          <source>Redesign the OS interface layer. See &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; for details. *** Potentially incompatible change ***</source>
          <target state="translated">OS 인터페이스 계층을 재 설계하십시오. 자세한 내용은 &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; 을 참조하십시오. *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="7d081723177fd4e3a870ace0d58c302ef456d798" translate="yes" xml:space="preserve">
          <source>Reduce the &lt;a href=&quot;limits&quot;&gt;limits&lt;/a&gt; that SQLite imposes on inputs. This can help prevent denial of service attacks and other kinds of mischief that can occur as a result of unusually large inputs. You can do this either at compile-time using -DSQLITE_MAX_... options, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface. Most applications can reduce limits dramatically without impacting functionality. The table below provides some suggestions, though exact values will vary depending on the application:</source>
          <target state="translated">SQLite가 입력에 부과 하는 &lt;a href=&quot;limits&quot;&gt;한계&lt;/a&gt; 를 줄 입니다. 이를 통해 비정상적으로 큰 입력으로 인해 발생할 수있는 서비스 거부 공격 및 기타 종류의 장난을 방지 할 수 있습니다. -DSQLITE_MAX _... 옵션을 사용하여 컴파일 타임에 또는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 인터페이스를 사용하여 런타임에이를 수행 할 수 있습니다 . 대부분의 응용 프로그램은 기능에 영향을 미치지 않고 한계를 크게 줄일 수 있습니다. 아래 표는 몇 가지 제안을 제공하지만 정확한 값은 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="818c7c2bc91785e19d03eddcb38dd27df259ccaf" translate="yes" xml:space="preserve">
          <source>Reduce the amount of heap memory used, especially by TRIGGERs.</source>
          <target state="translated">특히 TRIGGER에서 사용되는 힙 메모리의 양을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="eef61fea62e3c60ebd3be2d6739fac06ddb5ab7f" translate="yes" xml:space="preserve">
          <source>Reduce the amount of memory needed to hold the schema.</source>
          <target state="translated">스키마를 보유하는 데 필요한 메모리 양을 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="46eb8cc3e58b2e58eac841d7bad510287fbae8b0" translate="yes" xml:space="preserve">
          <source>Reduce the amount of stack space used</source>
          <target state="translated">사용 된 스택 공간의 양을 줄입니다</target>
        </trans-unit>
        <trans-unit id="2a4594bb7a13597e42630528fe396b294272a9f2" translate="yes" xml:space="preserve">
          <source>Reduce the number of memcpy() operations involved in balancing a b-tree, for 3.2% overall performance boost.</source>
          <target state="translated">b- 트리 균형 조정과 관련된 memcpy () 작업 수를 줄여 전체 성능을 3.2 % 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="15563f82edab75e0e9a9533c5985511dfd901167" translate="yes" xml:space="preserve">
          <source>Reduce the size and increase the speed of various modules, especially the virtual machine.</source>
          <target state="translated">다양한 모듈, 특히 가상 머신의 크기를 줄이고 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="f355d2ddba29d09803b074513416794452b26fe2" translate="yes" xml:space="preserve">
          <source>Reenable the xCurrentTime and xGetLastError methods in the built-in unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; as long as &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt; is not defined.</source>
          <target state="translated">의 xCurrentTime 및 xGetLastError 방법을 다시 활성화 내장 된 유닉스 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; 긴만큼 &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED가&lt;/a&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f79991a5be2e57d9f5c8d975047a7ce1e99e2e69" translate="yes" xml:space="preserve">
          <source>Refactor parts of the code in order to make the code footprint smaller. The code is now also a little bit faster.</source>
          <target state="translated">코드 풋 프린트를 더 작게 만들기 위해 코드의 일부를 리팩터링하십시오. 코드는 이제 조금 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="731a046a349bd8b2ec56f17167cd9586697efc8d" translate="yes" xml:space="preserve">
          <source>Refactor the implementation of PRAGMA statements to improve parsing performance.</source>
          <target state="translated">구문 분석 성능을 향상시키기 위해 PRAGMA 문의 구현을 리팩터링하십시오.</target>
        </trans-unit>
        <trans-unit id="e01090e00d57212fc38896c2384f678dca5a4d12" translate="yes" xml:space="preserve">
          <source>Refactor the internal representation of SQL expressions so that they use less memory on embedded platforms.</source>
          <target state="translated">임베디드 플랫폼에서 더 적은 메모리를 사용하도록 SQL 표현식의 내부 표현을 리 팩터하십시오.</target>
        </trans-unit>
        <trans-unit id="f207a8a558acb07f31589303df5e596105913ffb" translate="yes" xml:space="preserve">
          <source>Refactored the pager module.</source>
          <target state="translated">호출기 모듈을 리팩토링했습니다.</target>
        </trans-unit>
        <trans-unit id="226346556688fb9ee0c75ecc678574e3685f1eba" translate="yes" xml:space="preserve">
          <source>Refer to comments in the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt; sqlite3async.h header file&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt;sqlite3async.h 헤더 파일의&lt;/a&gt; 주석을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="aaa837aee763755888a50c44b690c5b28c724c42" translate="yes" xml:space="preserve">
          <source>Refer to section</source>
          <target state="translated">섹션을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="4604acc1b8f76983f5d1c6cf4dd45f3755df9f62" translate="yes" xml:space="preserve">
          <source>Refer to the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for more details regarding the relationship between the full-text index and its component b-trees.</source>
          <target state="translated">전체 텍스트 인덱스와 구성 요소 b- 트리 간의 관계에 대한 자세한 내용 은 &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 자동 병합 옵션&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c53a88bcf3d728c764909fd53351fd558c74013" translate="yes" xml:space="preserve">
          <source>Refer to the sqlite3_changegroup documentation below for details.</source>
          <target state="translated">자세한 내용은 아래 sqlite3_changegroup 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96203fca2f22f72728b0d96559374bef790492f7" translate="yes" xml:space="preserve">
          <source>Refer to wikipedia for &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;more information regarding BM25&lt;/a&gt; and its variants.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;BM25&lt;/a&gt; 및 그 변형 에 대한 자세한 내용은 Wikipedia를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="ed24ba4d4b3deaa5349f31379e8793cc898888c5" translate="yes" xml:space="preserve">
          <source>References to the table within CHECK constraints in the original CREATE TABLE statement.</source>
          <target state="translated">원래 CREATE TABLE 문의 CHECK 제한 조건 내의 테이블에 대한 참조</target>
        </trans-unit>
        <trans-unit id="f196200e5cee3f63f8cb5af84d2656fca6403f9b" translate="yes" xml:space="preserve">
          <source>References to the table within the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 내 테이블에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="9ee14d3156938bfc006a2f0c8ed355d9ca151ab6" translate="yes" xml:space="preserve">
          <source>References to the table within the bodies of triggers and views.</source>
          <target state="translated">트리거 및 뷰 본문 내 테이블에 대한 참조</target>
        </trans-unit>
        <trans-unit id="906a77daf0ffffc997c9b5822b41dc5c11c3a7b9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;분석 -stmt &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;업데이트- stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;업데이트 -stmt 제한 &lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;진공 -stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91c7fe4cacb331d9cfb44eb087944db8da3afcbf" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-constraint&quot;&gt;열 제한 조건 &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;유형 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d8aed8c6ef717e51cf55fa5d410506ec56f1af1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd54af792928e125a7c3d661324a97a3ce29b673" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="071f7537398d675e45a2fdaeb7bd26af44546b4d" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="282f6190a1e00fb7ff7db1945ee84f7660a92c19" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21742ff977fd9e5a8403d3239f8a93202fb0f39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;열 이름 목록 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;색인 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f805e85c41e9b3e30cafd3a842789358c3b6f12" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c69d978973c2b2241d5e4e82a79030c6aad5250" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2fd61f6a02e283a2e59272b7eb020a882319466" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;순서 용어 &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="667fd9a2ec0f33043daaaa5159b9ecc1f39e7b33" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8472bb382411c88450e331d7c59babdb2e746659" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;순서 지정 용어 &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77d3b028f4d456c29b115c3c1f35daadd6ff1624" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f8ccd3795f8b71bf70343d3fadc3ac179cc9d91" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a74b1ac9b009442b86c0a0250e3450f6dd245c7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="093e3a3349236fc2dfd7410c161635443356bb67" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#conflict-clause&quot;&gt;충돌 절 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75b80513956bb1581ff56ceefb5d202b11f453b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d11da2b5af692e996d5a48b32dfe86b2041eb8fa" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d0820e324079711069f47384d996edb389c3588" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20cbc57031b425ef7fc75a576696f91fe9b3d951" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93149806f66b1921c7517b514d80a3b282666f6b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bd75a2c3ba3eeca6c41d3a9318cbfdbb49e88c0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af58968390f59e5f5b4c323addb3e01a57ee6c1e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32f96f5ec0fb2907e9e4e032ea0ae81ddc82a1a3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dbf0458189780b769224889b3056c63b7e1f84" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59c40f8bbdab8cad4f5af93d93f71d7dbf30aa93" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b9919027e05781036111a8daacdadf3c525fde5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0773bdc1abf8efee6c1c60cecf9ee9685433dab7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;order-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24422bef8d6810e38018f045129e207f3e959155" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85f3810be175c469cf369360e14b9b2e5e01ac51" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70abaefe9f99828256cfd758a3afb7aa4c216e61" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c999a62fb82e126ba176715636e35111bb542d88" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;join-operator &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ad3c1f9f2a404dc774db57c85b8cec60718ee04" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="442eba43f59acab4d01a4fc91704194929768abd" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be27274cd4dccea52cefd3991def25081da71262" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참고 문헌 : &lt;a href=&quot;#signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a57a4e147f3de189d6e7e73c4c51f52022e0bd82" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38492d751f295bea065fa71e3925fb3ad037a1e2" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;분석 -stmt &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;업데이트- stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;업데이트 -stmt 제한 &lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;진공 -stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="650835c724bb2a86f89f84e9bbd3b780c13b6c9b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-constraint&quot;&gt;열 제한 조건 &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;유형 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="794b40cf8cd20637c83761e0684d3f4a5ca08040" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa218b2013469fb9882536f9cece6e55484d18b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5321f3c79df9e1ae13dc45785cee7ab2db6ce76c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d04da558e7b275ed093eaddcfd1b8fc7d2f8e276" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0efb77e2ca9ef9f00e4b6a166106c03c563ce0be" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4f6089017390e83489b6d24ed571adac8331d80" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1113daac28cbd063c08079443895f5566fdb33e5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3451b0f3b2b5af6b8d8b5aaefde1b19828f7a6c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;순서 용어 &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bba4382f55d6ffe66c81fa9289d49182e1355fcb" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b632fa679cae46b9a02f325553f2a2a7613b116" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;순서 지정 용어 &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d31ae5a462b6f054075ad5596a58eef1283d37" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1445ac57fe2b5334ccb8353e30f33be3e0e94b22" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91e02a407b8ce1872e126aedfe89133ac0d4f641" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8df9ea1d38fc83cf8d4c226cc463aaf1077b0c6f" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;conflict-clause&quot;&gt;충돌 절 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b098cacd25ca6e0fe7a4f6cbe7dc7b7acf41b7b8" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f46943158a8d7768ec74ac4bca397f3d7466cc" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f4dcceccfec99df86cc955c80ee8cdbaf49960" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f363ba239b93df7e224622a52457e08203ac21" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1460387ec8f592a739d62fe04e5527e471ea1d0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="192d6846ace3aa19cd52dd4ee585f12a733bb1e7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9283f303c0dddff0aeb96fe77630b3f0f7f1cd0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="885613b30bdc3bb4e3fc4bfce7226fd3a4194313" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5bbd33495175a536a093475520310921d8e80cb9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ac7994da54203d91b06af47c53b1f26548090ed" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5211947595082a78c56fd9fbfa97e9aa9db46e39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ef3d4989ffca292fb408e36d6c80a0be05d38e3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;order-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f754738e511b595c21699d1599455b2ad77e7ea" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10dff942ab951e8379beded21b97716b5a9470ac" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aead43f0300958c1d62f97ac7d9dbb7744c5f973" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4a21a32ca632c80e791992375d683d3cb2b152e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;join-operator &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eab2c400e1da9841def91aa5e9939c315ac03195" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ba25d3b7bd9b22c410033510c17375ba8fbc355" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1911821b127dd809d42d87c2ae5a010deb04e3f1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참고 문헌 : &lt;a href=&quot;signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4105cc2bca5aa3561ea07c37d7a688f2cefa3733" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fee8a9d70903bab5247e1644ccd6676a4cf76b15" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the instrumented memory allocator is used, SQLite keeps track of how much memory is currently checked out. There are hundreds of test scripts used for testing SQLite. At the end of each script, all objects are destroyed and a test is made to ensure that all memory has been freed. This is how memory leaks are detected. Notice that memory leak detection is in force at all times, during test builds and during production builds. Whenever one of the developers runs any individual test script, memory leak detection is active. Hence memory leaks that do arise during development are quickly detected and fixed.</source>
          <target state="translated">인스트루먼트 된 메모리 할당 자의 사용 여부에 관계없이 SQLite는 현재 체크 아웃 된 메모리 양을 추적합니다. SQLite 테스트에 사용되는 수백 가지 테스트 스크립트가 있습니다. 각 스크립트의 끝에서 모든 오브젝트가 삭제되고 모든 메모리가 해제되었는지 테스트합니다. 메모리 누수가 감지되는 방식입니다. 테스트 빌드 중 및 프로덕션 빌드 중 항상 메모리 누수 감지가 적용됩니다. 개발자 중 한 명이 개별 테스트 스크립트를 실행할 때마다 메모리 누수 감지가 활성화됩니다. 따라서 개발 중에 발생하는 메모리 누수가 신속하게 감지되고 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae990d665eb1948d09faab80d8ea36e2fb369696" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">한도 변경 여부에 관계없이 &lt;a href=&quot;#sqlite3_limit&quot;&gt; sqlite3_limit ()&lt;/a&gt; 인터페이스는 한계의 이전 값을 리턴합니다. 따라서 한계를 변경하지 않고 현재 한계 값을 찾으려면 세 번째 매개 변수를 -1로 설정하여이 인터페이스를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="475dd8379b7144ac8a6fe852e876196470fc7208" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">한도 변경 여부에 관계없이 &lt;a href=&quot;limit&quot;&gt; sqlite3_limit ()&lt;/a&gt; 인터페이스는 한계의 이전 값을 리턴합니다. 따라서 한계를 변경하지 않고 현재 한계 값을 찾으려면 세 번째 매개 변수를 -1로 설정하여이 인터페이스를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e9e73aedbb554e1304705d3de0f39389c534343e" translate="yes" xml:space="preserve">
          <source>Regions for custom R*Tree queries are defined by R*Tree geometry callbacks implemented by the application and registered with SQLite via a call to one of the following two APIs:</source>
          <target state="translated">사용자 지정 R * Tree 쿼리의 리전은 응용 프로그램에서 구현하고 다음 두 API 중 하나에 대한 호출을 통해 SQLite에 등록 된 R * Tree 지오메트리 콜백에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="16168729e57b855923c7a71a802959676ea3a2be" translate="yes" xml:space="preserve">
          <source>Register A Callback To Handle SQLITE_BUSY Errors</source>
          <target state="translated">SQLITE_BUSY 오류를 처리하기위한 콜백 등록</target>
        </trans-unit>
        <trans-unit id="d7ada71741a5c5efe7fce5b9acb6e7cf75421e75" translate="yes" xml:space="preserve">
          <source>Register A Virtual Table Implementation</source>
          <target state="translated">가상 테이블 구현 등록</target>
        </trans-unit>
        <trans-unit id="958187253e4e67d26cfc6c57d03a7d486067c5db" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the content of register P1 is initially greater than zero, then decrement the value in register P1. If it is non-zero (negative or positive) and then also jump to P2. If register P1 is initially zero, leave it unchanged and fall through.</source>
          <target state="translated">레지스터 P1은 정수를 포함해야합니다. 레지스터 P1의 내용이 처음에 0보다 크면 레지스터 P1의 값을 줄입니다. 0이 아닌 경우 (음수 또는 양수) P2로 이동합니다. 레지스터 P1이 처음에 0이면 변경하지 않고 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="6fc7ce61728bc6135a810d1467e955ec5c18cca5" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the value of register P1 is 1 or greater, subtract P3 from the value in P1 and jump to P2.</source>
          <target state="translated">레지스터 P1은 정수를 포함해야합니다. 레지스터 P1의 값이 1 이상이면 P1의 값에서 P3을 빼고 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d06710a36a9775573764357fb20e740182e291de" translate="yes" xml:space="preserve">
          <source>Register P1 must hold an integer. Decrement the value in P1 and jump to P2 if the new value is exactly zero.</source>
          <target state="translated">레지스터 P1은 정수를 보유해야합니다. 새 값이 정확히 0이면 P1의 값을 줄이고 P2로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e5b942ab2eff4aada4b58db13bc65435ed431f02" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the index P1. Data for the entry is nil.</source>
          <target state="translated">레지스터 P2에는 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어를 사용하여 작성된 SQL 인덱스 키가 있습니다. 이 opcode는 해당 키를 인덱스 P1에 씁니다. 항목에 대한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="01732db42505a803a66049796c8bf94fe2cae34d" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the sorter P1. Data for the entry is nil.</source>
          <target state="translated">레지스터 P2에는 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어를 사용하여 작성된 SQL 인덱스 키가 있습니다. 이 opcode는 해당 키를 분류기 P1에 씁니다. 항목에 대한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d2ffa8c9852450209f632158a1e7073fb3dfaaa" translate="yes" xml:space="preserve">
          <source>Register P3 is assumed to hold a 64-bit integer value. If register P1 contains a RowSet object and that RowSet object contains the value held in P3, jump to register P2. Otherwise, insert the integer in P3 into the RowSet and continue on to the next opcode.</source>
          <target state="translated">레지스터 P3은 64 비트 정수 값을 보유한다고 가정합니다. 레지스터 P1에 RowSet 객체가 포함되어 있고 해당 RowSet 객체에 P3에 보유 된 값이 포함되어 있으면 레지스터 P2로 이동합니다. 그렇지 않으면 P3의 정수를 RowSet에 삽입하고 다음 opcode로 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb45c70cacf149749ff353ab480989cee1443045" translate="yes" xml:space="preserve">
          <source>Register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">레지스터 P3은 압축 해제 된 레코드를 형성하는 첫 번째 P4 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="6b0d004c3926bf5b1daf83fe67dbd02805bbbe04" translate="yes" xml:space="preserve">
          <source>Register any required virtual table modules with the database handle returned by sqlite3rbu_db(X) (where argument X is the sqlite3rbu pointer returned from sqlite3rbu_open()). Also, if required, register the rbu_delta() SQL function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">sqlite3rbu_db (X)에 의해 리턴 된 데이터베이스 핸들로 필수 가상 테이블 모듈을 등록하십시오 (여기서 X는 sqlite3rbu_open ()에서 리턴 된 sqlite3rbu 포인터 임). 또한 필요한 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 ()를&lt;/a&gt; 사용하여 rbu_delta () SQL 함수를 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b1ab59684ecdfa6e23d462a92936dce3e5d8ac7" translate="yes" xml:space="preserve">
          <source>Register the asynchronous IO VFS with SQLite by calling the sqlite3async_initialize() function.</source>
          <target state="translated">sqlite3async_initialize () 함수를 호출하여 SQLite에 비동기 IO VFS를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="89422a050ade616c86455a9e2dd6f33cb03ad894" translate="yes" xml:space="preserve">
          <source>Register your &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure using one of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 인터페이스 중 하나를 사용 하여 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조를 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="27c9b460c397ef5be790575add8647f1cec36dca" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">등록 된 sqlite3_vfs 객체는 pNext 포인터로 구성된 링크 된 목록에 유지됩니다. &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister는 ()&lt;/a&gt; 인터페이스는 스레드 안전 방식으로이 목록을 관리 할 수 있습니다. &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 인터페이스 목록을 검색한다. 응용 프로그램 코드 나 VFS 구현 모두 pNext 포인터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="de4afbb05497a501a0da1ff3e255c9bea23038bf" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">등록 된 sqlite3_vfs 객체는 pNext 포인터로 구성된 링크 된 목록에 유지됩니다. &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 와 &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister는 ()&lt;/a&gt; 인터페이스는 스레드 안전 방식으로이 목록을 관리 할 수 있습니다. &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 인터페이스 목록을 검색한다. 응용 프로그램 코드 나 VFS 구현 모두 pNext 포인터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9a5c1b8d7536fe55fb50a507d2ffb4e2ef3d6e66" translate="yes" xml:space="preserve">
          <source>Registering a NULL function disables the callback.</source>
          <target state="translated">NULL 함수를 등록하면 콜백이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5b14172bb50385ea604b908cd56b4ced0181ef" translate="yes" xml:space="preserve">
          <source>Registering a new FTS tokenizer is similar to registering a new virtual table module with SQLite. The user passes a pointer to a structure containing pointers to various callback functions that make up the implementation of the new tokenizer type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called &quot;sqlite3_tokenizer_module&quot;.</source>
          <target state="translated">새로운 FTS 토크 나이저를 등록하는 것은 SQLite에 새로운 가상 테이블 모듈을 등록하는 것과 유사합니다. 사용자는 새로운 토크 나이저 유형의 구현을 구성하는 다양한 콜백 함수에 대한 포인터를 포함하는 구조에 포인터를 전달합니다. 토크 나이저의 경우 (fts3_tokenizer.h에 정의 된) 구조를 &quot;sqlite3_tokenizer_module&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b0c19399b5563dfe1fd2d9520239e189e1da88bf" translate="yes" xml:space="preserve">
          <source>Registers are numbered beginning with 0. Most opcodes refer to at least one register.</source>
          <target state="translated">레지스터는 0부터 시작하여 번호가 매겨집니다. 대부분의 opcode는 하나 이상의 레지스터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3416ca847c2f3fcac36ca80a6aa453bda2a4a879" translate="yes" xml:space="preserve">
          <source>Regression tests</source>
          <target state="translated">회귀 테스트</target>
        </trans-unit>
        <trans-unit id="d3a13cdc6fea5f8b0f17f86149a799a401cfa954" translate="yes" xml:space="preserve">
          <source>Reimplemented the memory allocation subsystem and made it replaceable at compile-time.</source>
          <target state="translated">메모리 할당 서브 시스템을 다시 구현하고 컴파일 타임에 교체 할 수있게했습니다.</target>
        </trans-unit>
        <trans-unit id="7c51b2c09a7ac00c32d5f5b60d5cc13c023b651f" translate="yes" xml:space="preserve">
          <source>Reinstate performance improvements that were added in &lt;a href=&quot;#version_3_3_14&quot;&gt;Version 3.3.14&lt;/a&gt; but regressed in &lt;a href=&quot;#version_3_3_15&quot;&gt;Version 3.3.15&lt;/a&gt;.</source>
          <target state="translated">에 추가 된 분석 재개 성능 개선 &lt;a href=&quot;#version_3_3_14&quot;&gt;버전 3.3.14&lt;/a&gt; 에 있지만 회귀 &lt;a href=&quot;#version_3_3_15&quot;&gt;버전 3.3.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3011dfada1ebc527f6c1a610c58b9f9d0286fe3f" translate="yes" xml:space="preserve">
          <source>Related to C-API requirements:</source>
          <target state="translated">C-API 요구 사항 관련 :</target>
        </trans-unit>
        <trans-unit id="4e090a454ee61aaf3f58e28631cff8999e93331b" translate="yes" xml:space="preserve">
          <source>Related to SQL requirements:</source>
          <target state="translated">SQL 요구 사항 관련 :</target>
        </trans-unit>
        <trans-unit id="3eb999525849eac11552ac3098daf2b69f5321b3" translate="yes" xml:space="preserve">
          <source>Related to file-format requirements:</source>
          <target state="translated">파일 형식 요구 사항과 관련 :</target>
        </trans-unit>
        <trans-unit id="8f24d23adbf6898f82e865e9f816b7bd6e3ba106" translate="yes" xml:space="preserve">
          <source>Relational database engines act as bandwidth-reducing data filters. So it is best to keep the database engine and the data on the same physical device so that the high-bandwidth engine-to-disk link does not have to traverse the network, only the lower-bandwidth application-to-engine link.</source>
          <target state="translated">관계형 데이터베이스 엔진은 대역폭 감소 데이터 필터 역할을합니다. 따라서 데이터베이스 엔진과 데이터를 동일한 물리적 장치에 유지하여 고 대역폭 엔진 대 디스크 링크가 네트워크를 통과 할 필요가없고 저 대역폭 응용 프로그램 대 엔진 링크 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="720fa9e6ba7dd17be077bf0b4c2393be699b32bc" translate="yes" xml:space="preserve">
          <source>Relationship to Other Documents</source>
          <target state="translated">다른 문서와의 관계</target>
        </trans-unit>
        <trans-unit id="910fe0ebb846d769acb1f768f3b350b52b7c87fa" translate="yes" xml:space="preserve">
          <source>Relax the SQL statement length restriction in the CLI so that the &quot;.dump&quot; output of databases with very large BLOBs and strings can be played back to recreate the database.</source>
          <target state="translated">BLOB 및 문자열이 매우 큰 데이터베이스의 &quot;.dump&quot;출력을 재생하여 데이터베이스를 다시 만들 수 있도록 CLI에서 SQL 문 길이 제한을 완화하십시오.</target>
        </trans-unit>
        <trans-unit id="d41f56cea1ac933d25c57aebc6522e2b6c58eb87" translate="yes" xml:space="preserve">
          <source>Release</source>
          <target state="translated">Release</target>
        </trans-unit>
        <trans-unit id="3f453891a8b048016ad785ded9267d527fc4c217" translate="yes" xml:space="preserve">
          <source>Release History</source>
          <target state="translated">출시 역사</target>
        </trans-unit>
        <trans-unit id="b5d6e335495f80d39d703350d3e97ffdb93dd6dd" translate="yes" xml:space="preserve">
          <source>Release History Of SQLite</source>
          <target state="translated">SQLite의 출시 역사</target>
        </trans-unit>
        <trans-unit id="059948eaf49ab1f91af7a1724f1325548609c407" translate="yes" xml:space="preserve">
          <source>Release registers from service. Any content that was in the the registers is unreliable after this opcode completes.</source>
          <target state="translated">서비스에서 레지스터를 해제합니다. 이 opcode가 완료된 후에는 레지스터에 있던 모든 콘텐츠를 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f91d8788ccb8580c59f2957385adedb96f9eebdb" translate="yes" xml:space="preserve">
          <source>Release testing proceeds by &lt;a href=&quot;testing#cklist&quot;&gt;checklist&lt;/a&gt;. The current status and complete change history for each checklist is stored in a separate SQLite database file. These files are not version controlled, but separate copies are maintained on private backup servers.</source>
          <target state="translated">&lt;a href=&quot;testing#cklist&quot;&gt;체크리스트&lt;/a&gt; 로 릴리스 테스트 진행 . 각 점검 목록의 현재 상태 및 전체 변경 내역은 별도의 SQLite 데이터베이스 파일에 저장됩니다. 이러한 파일은 버전이 제어되지 않지만 개인 백업 서버에서 별도의 사본이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d39cd2c52497ee84030ad057906e4ab9e12677f2" translate="yes" xml:space="preserve">
          <source>ReleaseReg</source>
          <target state="translated">ReleaseReg</target>
        </trans-unit>
        <trans-unit id="68bd446f9608234bde9262049ecc13307a217604" translate="yes" xml:space="preserve">
          <source>Releases the mutex.</source>
          <target state="translated">뮤텍스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="093e4161a9fbb2d3df1b7e1618ac6472d6ffad88" translate="yes" xml:space="preserve">
          <source>Releasing a register clears the Mem.pScopyFrom pointer. That means that if the content of the released register was set using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, a change to the value of the source register for the &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; will no longer generate an assertion fault in sqlite3VdbeMemAboutToChange().</source>
          <target state="translated">레지스터를 해제하면 Mem.pScopyFrom 포인터가 지워집니다. 즉, 그 방출 된 레지스터의 콘텐츠를 사용하여 설정 되었다면 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCOPY&lt;/a&gt; 상기의 소스 레지스터의 값의 변경 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCOPY를&lt;/a&gt; 더 sqlite3VdbeMemAboutToChange 어설 오류를 발생시키지 것이다 ().</target>
        </trans-unit>
        <trans-unit id="9e7fb42133185287484ac33cdd16d16a32e9573a" translate="yes" xml:space="preserve">
          <source>Relieve the poor.</source>
          <target state="translated">가난한 사람들을 구하십시오.</target>
        </trans-unit>
        <trans-unit id="c129618e6f09666fc71019f6f11ca49c584723bd" translate="yes" xml:space="preserve">
          <source>Relinquish the shared lock on the database file obtained in step 1.</source>
          <target state="translated">1 단계에서 얻은 데이터베이스 파일에서 공유 잠금을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="c20a1017faea096d3f06199fd35a9c0037bfb227" translate="yes" xml:space="preserve">
          <source>Remainder</source>
          <target state="translated">Remainder</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="f818b7fc01e1b4eb78ea0d60ac974d5efb37d086" translate="yes" xml:space="preserve">
          <source>Remember that every table (except sqlite_master) and every named index has an entry in the sqlite_master table. Since we are creating a new index, we have to add a new entry to sqlite_master. This is handled by instructions 3 through 15. Adding an entry to sqlite_master works just like any other INSERT statement so we will not say any more about it here. In this example, we want to focus on populating the new index with valid data, which happens on instructions 16 through 23.</source>
          <target state="translated">모든 테이블 (sqlite_master 제외)과 모든 명명 된 인덱스에는 sqlite_master 테이블에 항목이 있습니다. 새로운 인덱스를 생성하고 있기 때문에 sqlite_master에 새로운 엔트리를 추가해야합니다. sqlite_master에 항목을 추가하면 다른 INSERT 문과 동일하게 작동하므로 여기서 더 이상 언급하지 않습니다. 이 예에서는 명령 16에서 23까지 발생하는 유효한 데이터로 새 인덱스를 채우는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="69897e6a01044562fef92617e584bcaf82e348ea" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">opcode의 이름과 의미는 종종 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. 당신은 공부하는 경우에 따라서 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; SQLite는의 출력을, 당신은 실행 한 SQLite는 버전이 문서의 버전 (또는 vdbe.c 소스 코드) 것을 대응을 참조해야합니다 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; . 그렇지 않으면 opcode에 대한 설명이 정확하지 않을 수 있습니다. 이 문서는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;2019-10-10&lt;/a&gt; 날짜의 SQLite 버전 3.30.1 체크인 18db032d058f1 에서 파생 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f553d13a1a4a6a005164fe968cc587aaf66e9b40" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="translated">opcode의 이름과 의미는 SQLite의 한 릴리스에서 다음 릴리스로 변경되는 경우가 많습니다. 당신은 공부하는 경우에 따라서 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; SQLite는의 출력을, 당신은 실행 한 SQLite는 버전이 문서의 버전 (또는 vdbe.c 소스 코드)에 that 대응을 참조한다 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; . 그렇지 않으면 opcode의 설명이 정확하지 않을 수 있습니다. 이 문서는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;2020-08-14&lt;/a&gt; 날짜의 SQLite 버전 3.33.0 체크인 fca8dc8b578f2 에서 파생 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6eb5f044eeebb740c044069cc0a1760dfcfed869" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_master WHERE tbl_name='X'.</source>
          <target state="translated">표 X와 관련된 모든 인덱스, 트리거 및보기의 형식을 기억하십시오.이 정보는 아래 8 단계에서 필요합니다. 이를 수행하는 한 가지 방법은 다음과 같은 조회를 실행하는 것입니다. SELECT type, sql FROM sqlite_master WHERE tbl_name = 'X'.</target>
        </trans-unit>
        <trans-unit id="96ba241fe10cc7a94246b3ba48e08be55ea73559" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_schema WHERE tbl_name='X'.</source>
          <target state="translated">테이블 X와 연관된 모든 인덱스, 트리거 및보기의 형식을 기억하십시오.이 정보는 아래 8 단계에서 필요합니다. 이를 수행하는 한 가지 방법은 SELECT type, sql FROM sqlite_schema WHERE tbl_name = 'X'와 같은 쿼리를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7697dd70c220c16d6cd40cffcf6ebbe938ec6d8c" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">기억하십시오 : VDBE opcode는 SQLite에 대한 인터페이스 정의의 일부 가 &lt;u&gt;아닙니다&lt;/u&gt; . opcode의 수와 이름 및 의미는 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. 아래 표에 표시된 opcode는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;2019-10-10&lt;/a&gt; 날짜의 SQLite 버전 3.30.1 체크인 18db032d058f1에 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="0cf1bdb8435fa5c7b1a229b2efb579581c575742" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="translated">기억하세요 : VDBE opcode는 SQLite에 대한 인터페이스 정의의 일부 가 &lt;u&gt;아닙니다&lt;/u&gt; . opcode의 수와 그 이름과 의미는 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. 아래 표에 표시된 opcode는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;2020-08-14&lt;/a&gt; 날짜의 SQLite 버전 3.33.0 체크인 fca8dc8b578f2에 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="ad8914d260e2d26c0f65a1244263c5ebd74ffa40" translate="yes" xml:space="preserve">
          <source>Removals occurs sequentially from left to right. Changes caused by prior removals can affect the path search for subsequent arguments.</source>
          <target state="translated">제거는 왼쪽에서 오른쪽으로 순차적으로 발생합니다. 이전 제거로 인한 변경은 후속 인수의 경로 검색에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="911efbaa270338e46274d0437cfd895711d3b921" translate="yes" xml:space="preserve">
          <source>Remove Unnecessary Virtual Table Implementations</source>
          <target state="translated">불필요한 가상 테이블 구현 제거</target>
        </trans-unit>
        <trans-unit id="e2ba27377e47e450dcae92850eed494633ee561a" translate="yes" xml:space="preserve">
          <source>Remove a call to rand_s() in the Windows VFS since it was causing problems in Firefox on some older laptops.</source>
          <target state="translated">일부 구형 랩톱에서는 Firefox에서 문제를 일으켰으므로 Windows VFS에서 rand_s ()에 대한 호출을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="de2c1add2fd3544da9609574c31dec164859c5a6" translate="yes" xml:space="preserve">
          <source>Remove a surplus semicolon that was causing problems for older versions of MSVC.</source>
          <target state="translated">이전 버전의 MSVC에서 문제를 일으킨 잉여 세미콜론을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d1a5392ba748cb8c4dacc7b44e730fc30161dbb4" translate="yes" xml:space="preserve">
          <source>Remove all instances of sprintf() from the code</source>
          <target state="translated">코드에서 sprintf ()의 모든 인스턴스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a7347e37ad5bb38746524ddb0e6ffca369e7fc25" translate="yes" xml:space="preserve">
          <source>Remove all uses of umask() in the unix VFS.</source>
          <target state="translated">유닉스 VFS에서 umask () 사용을 모두 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e9a7875d6c4fd8a037f45ad1e5ae66d9676a5804" translate="yes" xml:space="preserve">
          <source>Remove cruft from the APIs.</source>
          <target state="translated">API에서 cruft를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1b6d6e3634ac9d3666b932168ce6ff89f16adfc2" translate="yes" xml:space="preserve">
          <source>Remove limits on the magnitude of precision and width value in the format specifiers of the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of string rendering routines.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 문자열 렌더링 루틴 패밀리의 형식 지정자에서 정밀도 및 너비 값의 크기에 대한 제한을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="232f2fe0e5dd49ef4b04602d08b8943e14a7d142" translate="yes" xml:space="preserve">
          <source>Remove some C++ style comments from btree.c so that it will compile using compilers other than gcc.</source>
          <target state="translated">btree.c에서 일부 C ++ 스타일 주석을 제거하여 gcc 이외의 컴파일러를 사용하여 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="f2e07b9153ec780a2a1b29629bb1d3f64a20239f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL variable that was introduced in the previous version.</source>
          <target state="translated">이전 버전에서 도입 된 &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL 변수를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b21568b3fad30533d945c9f60e6bb04786d29af" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the index named P4 in database P1. This is called after an index is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">데이터베이스 P1에서 이름이 P4 인 인덱스를 설명하는 내부 (메모리 내) 데이터 구조를 제거하십시오. 스키마의 내부 표현을 디스크에있는 것과 일관되게 유지하기 위해 디스크에서 색인을 삭제 ( &lt;a href=&quot;opcode#Destroy&quot;&gt;파괴&lt;/a&gt; opcode 사용) 한 후에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="36574b14e4fba42639d51b715dd56510bbbe9bbe" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the table named P4 in database P1. This is called after a table is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">데이터베이스 P1에서 이름이 P4 인 테이블을 설명하는 내부 (메모리 내) 데이터 구조를 제거하십시오. 디스크에서 테이블을 삭제 한 후에 호출됩니다 ( &lt;a href=&quot;opcode#Destroy&quot;&gt;파괴를&lt;/a&gt; 사용하여).스키마의 내부 표현을 디스크에있는 것과 일관되게 유지하기 위해 opcode 됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ee755d70dfde8b6acc7bc963a2c09e0d856e3d" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the trigger named P4 in database P1. This is called after a trigger is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">데이터베이스 P1에서 이름이 P4 인 트리거를 설명하는 내부 (메모리 내) 데이터 구조를 제거하십시오. 디스크의 내용과 일치하도록 스키마의 내부 표현을 유지하기 위해 디스크에서 트리거가 삭제 된 후 ( &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode 사용) 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="4bdb98bb814d00a40fac7a5bc5a53816ed8a4fe3" translate="yes" xml:space="preserve">
          <source>Remove the limit (formerly 100) on the number of terms in the WHERE clause</source>
          <target state="translated">WHERE 절의 용어 수에 대한 한계 (이전 100)를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6c2cfa3751933f72373c8446091ad7cbfc829e90" translate="yes" xml:space="preserve">
          <source>Remove the rarely-used &quot;scratch&quot; memory allocator. Replace it with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt; configuration setting that gives SQLite a hint that large memory allocations should be avoided when possible.</source>
          <target state="translated">거의 사용하지 않는 &quot;스크래치&quot;메모리 할당자를 제거하십시오. 로 교체 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt;SQLite에 가능한 많은 메모리 할당을 피해야한다는 힌트를 제공 구성 설정으로 십시오.</target>
        </trans-unit>
        <trans-unit id="f76d7af1679885a7bfe9d24b6ffde8997604493f" translate="yes" xml:space="preserve">
          <source>Remove the restriction on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; and &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;. Virtual tables and shared cache can now be used at the same time.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에 대한 제한을 제거하십시오 . 가상 테이블과 공유 캐시를 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f161850d96f27ed56876982a84f7c1b8a07321a" translate="yes" xml:space="preserve">
          <source>Remove the use of strcasecmp() from the shell</source>
          <target state="translated">쉘에서 strcasecmp () 사용을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b82adca5a3d606350246be926940c7079f564580" translate="yes" xml:space="preserve">
          <source>Removed a few variables that were not being used. Etc.</source>
          <target state="translated">사용되지 않은 몇 가지 변수를 제거했습니다. 기타.</target>
        </trans-unit>
        <trans-unit id="ce23c20d6612496d01f2695dbdf3e159dffac5f1" translate="yes" xml:space="preserve">
          <source>Removed all instances of sprintf() and strcpy() from the core library.</source>
          <target state="translated">코어 라이브러리에서 sprintf () 및 strcpy ()의 모든 인스턴스를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="1cae4989947b35c7db5ba36e62fdeec64147115e" translate="yes" xml:space="preserve">
          <source>Removed encode.c file (containing unused routines) from the version 3.0 source tree.</source>
          <target state="translated">버전 3.0 소스 트리에서 encode.c 파일 (사용되지 않은 루틴 포함)을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="57859e1d20dcbe4d104c0ddc713636157aa93b7b" translate="yes" xml:space="preserve">
          <source>Removed some unused &quot;#include</source>
          <target state="translated">사용하지 않는 일부 &quot;#include를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="8d2a9960e30e515570aed5ad791fda0cf2ff5231" translate="yes" xml:space="preserve">
          <source>Removed support for &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;, replacing it with the much more capable &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 지원을 제거 하여 훨씬 더 유능한 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3으로 대체&lt;/a&gt; 옵션으로 .</target>
        </trans-unit>
        <trans-unit id="65be623270aae4b13c60984d581079005860c71c" translate="yes" xml:space="preserve">
          <source>Removed support for an ON CONFLICT clause on CREATE INDEX - it never worked correctly so this should not present any backward compatibility problems.</source>
          <target state="translated">CREATE INDEX에서 ON CONFLICT 절에 대한 지원이 제거되었습니다. 제대로 작동하지 않으므로 이전 버전과의 호환성 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba2329a69fcada7cfc55496da4a2c7aa1027255b" translate="yes" xml:space="preserve">
          <source>Removed support for the Oracle8 outer join syntax.</source>
          <target state="translated">Oracle8 외부 조인 구문에 대한 지원이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="29a877d4bc4a615404fe28f15ef25cea333f3dfb" translate="yes" xml:space="preserve">
          <source>Removed the experimental sqlite_open_aux_file(). Its function is subsumed in the new ATTACH command.</source>
          <target state="translated">실험적인 sqlite_open_aux_file ()을 제거했습니다. 이 기능은 새로운 ATTACH 명령에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d84a5c2bd6c237fcc154859882d3b6c252699015" translate="yes" xml:space="preserve">
          <source>Removed the vestigal SQLITE_PROTOCOL error.</source>
          <target state="translated">vestigal SQLITE_PROTOCOL 오류를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="eace5c7b4ff6a4702d4283d3160c8d68a2dcede9" translate="yes" xml:space="preserve">
          <source>Rename column</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="23dbd5b69dca406be177f26a10ac454eda104e75" translate="yes" xml:space="preserve">
          <source>Rename new into old</source>
          <target state="translated">새로운 이름을 오래된 것으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="5bd4049b4d784a22b055fc8e5f3c3684061c5d9c" translate="yes" xml:space="preserve">
          <source>Rename old table</source>
          <target state="translated">이전 테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c9a739b6bb3de7aee85aef1cd51db485f31caf22" translate="yes" xml:space="preserve">
          <source>Rename table</source>
          <target state="translated">테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="a6f163085aea45df98f42b1c1ebd60597433d37a" translate="yes" xml:space="preserve">
          <source>Rename the &lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt; compile-time option to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; to better reflect the implications of using it.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt; 컴파일 타임 옵션의 이름 을 &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; 로 바꾸어 사용의 의미를 더 잘 반영하십시오.</target>
        </trans-unit>
        <trans-unit id="be5b8fd29874b31a75967598563d2c598ed8c802" translate="yes" xml:space="preserve">
          <source>Render expressions of the form &quot;x IN (?)&quot; (with a single value in the list on the right-hand side of the IN operator) as if they where &quot;x==?&quot;, Similarly optimize &quot;x NOT IN (?)&quot;</source>
          <target state="translated">마치 &quot;x ==?&quot;인 것처럼 &quot;x IN (?)&quot;형식 (IN 연산자의 오른쪽에있는 목록에 단일 값이있는)의 식을 렌더링합니다. 마찬가지로 &quot;x NOT IN (? ) &quot;</target>
        </trans-unit>
        <trans-unit id="88333a43b7fd427d0516f0a5d5107e5f54e545df" translate="yes" xml:space="preserve">
          <source>ReopenIdx</source>
          <target state="translated">ReopenIdx</target>
        </trans-unit>
        <trans-unit id="7c28d43c9fc88003b6477ed308834ef4aec930a4" translate="yes" xml:space="preserve">
          <source>Reorganize the Unix interface in os_unix.c</source>
          <target state="translated">os_unix.c에서 유닉스 인터페이스 재구성</target>
        </trans-unit>
        <trans-unit id="4b096fbd5cf8040410b520d0087755f15a4e4623" translate="yes" xml:space="preserve">
          <source>Repeatedly switching an SQLite database in and out of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command in between switches, in one process or thread, can cause another process or thread that has the database file open to miss the fact that the database has changed. That second process or thread might then try to modify the database using a stale cache and cause database corruption.</source>
          <target state="translated">하나의 프로세스 또는 스레드 에서 SQLite 데이터베이스를 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 안팎으로 반복적으로 전환하고 스위치간에 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 실행 하면 데이터베이스 파일이 열려있는 다른 프로세스 또는 스레드가 데이터베이스가 변경되었다는 사실을 놓칠 수 있습니다. 그런 다음 두 번째 프로세스 또는 스레드가 오래된 캐시를 사용하여 데이터베이스를 수정하려고 시도하여 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d1902d969043d4f5ff76c612c66edc344a58a0" translate="yes" xml:space="preserve">
          <source>Replace the built-in mutex subsystem with an alternative implementation.</source>
          <target state="translated">내장 mutex 서브 시스템을 대체 구현으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="6fd04b040e5c22cd85b1871575a876977a443534" translate="yes" xml:space="preserve">
          <source>Replace the interface to the file system with an alternative design. In other words, override all of the system calls that SQLite makes in order to talk to the disk with a completely different set of system calls.</source>
          <target state="translated">대체 설계로 파일 시스템에 대한 인터페이스를 교체하십시오. 다시 말해, 완전히 다른 시스템 호출 세트로 디스크와 통신하기 위해 SQLite가 만드는 모든 시스템 호출을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="8a67a8b071dbf97af58f9f8fc030dc4129a982a5" translate="yes" xml:space="preserve">
          <source>Report an error if an ORDER BY or GROUP BY expression is constant.</source>
          <target state="translated">ORDER BY 또는 GROUP BY 표현식이 상수 인 경우 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="5382d03ec82f0e424f0e2bcd884c37beaa553f16" translate="yes" xml:space="preserve">
          <source>Report rollback recovery in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; as SQLITE_NOTICE_RECOVER_ROLLBACK. Change the error log code for WAL recover from SQLITE_OK to SQLITE_NOTICE_RECOVER_WAL.</source>
          <target state="translated">&lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에서 롤백 복구 를 SQLITE_NOTICE_RECOVER_ROLLBACK으로보고하십시오. WAL 복구에 대한 오류 로그 코드를 SQLITE_OK에서 SQLITE_NOTICE_RECOVER_WAL로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2a209e68ce6d7ef5cbfce6e23fd387511ef2796d" translate="yes" xml:space="preserve">
          <source>Report the name of specific &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraints that fail.</source>
          <target state="translated">실패한 특정 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; 제약 조건 의 이름을보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b12d49166f15edffd3aeb0179e7e1787f48ce27" translate="yes" xml:space="preserve">
          <source>Report the risky uses of &lt;a href=&quot;howtocorrupt#unlink&quot;&gt;unlinked database files&lt;/a&gt; and &lt;a href=&quot;howtocorrupt#alias&quot;&gt;database filename aliasing&lt;/a&gt; as SQLITE_WARNING messages in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howtocorrupt#unlink&quot;&gt;연결되지 않은 데이터베이스 파일&lt;/a&gt; 과 &lt;a href=&quot;howtocorrupt#alias&quot;&gt;데이터베이스 파일 이름 별칭&lt;/a&gt; 의 위험한 사용을 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에 SQLITE_WARNING 메시지로보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="a328f2c4ddffb4f007ee170c822e792cbe7ac2bd" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than or equal to the key value. If there are no records less than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">커서 P1을 키 값보다 작거나 같은 가장 큰 항목을 가리 키도록 위치를 조정하십시오. 키보다 작거나 같은 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="3135b4b4b6f2ab789efbcd1b22f24612c3f91745" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than the key value. If there are no records less than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">커서 P1이 키 값보다 작은 최대 항목을 가리 키도록 위치를 조정하십시오. 키보다 작은 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0ecdc43c68575ffe0f6b403b40297cdd23849385" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than or equal to the key value. If there are no records greater than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">키 P보다 크거나 같은 가장 작은 항목을 가리 키도록 커서 P1을 재배치하십시오. 키보다 크거나 같은 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="12d5076757ddc1b93a63854acae2fbdea1746c5f" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than the key value. If there are no records greater than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">커서 P1이 키 값보다 큰 가장 작은 항목을 가리 키도록 위치를 조정하십시오. 키보다 큰 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="c029db81bd8f30ac7ba33c5eb9c17a5ae29866f1" translate="yes" xml:space="preserve">
          <source>Represent a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt; as an SQL table. Works for both reading and writing. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to implement the ability to read and write ZIP Archives.</source>
          <target state="translated">대표 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP 아카이브&lt;/a&gt; SQL 테이블 등을. 읽기와 쓰기 모두에 효과적입니다. ZIP 아카이브를 읽고 쓰는 기능을 구현하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bf10d00bc3da2452de6c68f43ec52e620c1a7872" translate="yes" xml:space="preserve">
          <source>Representation is the essence of computer programming.</source>
          <target state="translated">대표는 컴퓨터 프로그래밍의 본질입니다.</target>
        </trans-unit>
        <trans-unit id="1d9b3293e88caaa716c1a885e5b50e65b2bb3b2a" translate="yes" xml:space="preserve">
          <source>Represents the global variables of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCL Interpreter&lt;/a&gt; as an SQL table. Used as part of the SQLite test suite.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCL 인터프리터&lt;/a&gt; 의 글로벌 변수를 SQL 테이블로 나타냅니다. SQLite 테스트 스위트의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26bf60fed3744bb0049608ff95380b842c473a6" translate="yes" xml:space="preserve">
          <source>Requested</source>
          <target state="translated">Requested</target>
        </trans-unit>
        <trans-unit id="dbbf6c568082dd9fe7decc89c41aaaa504df8ded" translate="yes" xml:space="preserve">
          <source>Requirement H35050 (section</source>
          <target state="translated">요구 사항 H35050 (섹션</target>
        </trans-unit>
        <trans-unit id="4e1bcb3ced4612d53be234208553c503d16c2746" translate="yes" xml:space="preserve">
          <source>Requirements describing how a</source>
          <target state="translated">방법을 설명하는 요구 사항</target>
        </trans-unit>
        <trans-unit id="5472f074118e0fcc2fcc663b98dfc71e267df752" translate="yes" xml:space="preserve">
          <source>Requirements describing step 1 of the above procedure in detail:</source>
          <target state="translated">위 절차의 1 단계를 자세히 설명하는 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="fad7011bc39debdd3199704eacbe43fe1a48d858" translate="yes" xml:space="preserve">
          <source>Requirements describing step 2 of the above procedure in detail:</source>
          <target state="translated">위 절차의 2 단계를 자세히 설명하는 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="ab69e2e210c3221f1002ef2901289208f13aedb6" translate="yes" xml:space="preserve">
          <source>Reseed the PRNG used by &lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness(N,P)&lt;/a&gt; when invoked with N==0. Automatically reseed after a fork() on unix.</source>
          <target state="translated">N == 0으로 호출 될 때 &lt;a href=&quot;c3ref/randomness&quot;&gt;sqlite3_randomness (N, P)&lt;/a&gt; 가 사용하는 PRNG를 다시 시드합니다 . 유닉스에서 fork () 후에 자동으로 시드됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e763c273cb61a6c809688658e09f482db6fd97" translate="yes" xml:space="preserve">
          <source>Reserved for expansion. Must be zero.</source>
          <target state="translated">확장을 위해 예약되어 있습니다. 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bdef1e2b8be9e399f5c04bd0ec5acae3a91dd527" translate="yes" xml:space="preserve">
          <source>Reserved for internal use. These serial type codes will never appear in a well-formed database file, but they might be used in transient and temporary database files that SQLite sometimes generates for its own use. The meanings of these codes can shift from one release of SQLite to the next.</source>
          <target state="translated">내부 용으로 예약되어 있습니다. 이러한 직렬 유형 코드는 올바른 형식의 데이터베이스 파일에는 나타나지 않지만 SQLite가 자체 사용을 위해 생성하는 임시 및 임시 데이터베이스 파일에 사용될 수 있습니다. 이 코드의 의미는 SQLite의 한 릴리스에서 다음 릴리스로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d95494e07a6a9549bcea26b9d9f2fbf0deb1f69a" translate="yes" xml:space="preserve">
          <source>Reset A Prepared Statement Object</source>
          <target state="translated">준비된 명령문 오브젝트 재설정</target>
        </trans-unit>
        <trans-unit id="42eeaddac57cdadd9740ee6589dcc8b8aa539cc7" translate="yes" xml:space="preserve">
          <source>Reset All Bindings On A Prepared Statement</source>
          <target state="translated">준비된 명령문에서 모든 바인딩 재설정</target>
        </trans-unit>
        <trans-unit id="73a14bd471f06173f0ae50ee3cde4ad48b429415" translate="yes" xml:space="preserve">
          <source>Reset Automatic Extension Loading</source>
          <target state="translated">자동 확장 로딩 재설정</target>
        </trans-unit>
        <trans-unit id="d231fc4b421923d9a11bf7f97e65d2ae7f9cc9e2" translate="yes" xml:space="preserve">
          <source>Reset the prepared statement using &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; then go back to step 2. Do this zero or more times.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 사용하여 준비된 명령문을 재설정 한 후 2 단계로 돌아가십시오.이 작업을 0 회 이상 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4aad4c041b74b702ce26a865f63f85ffe199c836" translate="yes" xml:space="preserve">
          <source>Reset the prepared statement using &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; then go back to step 2. Do this zero or more times.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 사용하여 준비된 명령문을 재설정 한 후 2 단계로 돌아가십시오.이 작업을 0 회 이상 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a7137bfc27ede1ca9f1af3f7e483a7eb322a0523" translate="yes" xml:space="preserve">
          <source>ResetCount</source>
          <target state="translated">ResetCount</target>
        </trans-unit>
        <trans-unit id="f1a133448e9585fc018f3189dd7da48a9267fed6" translate="yes" xml:space="preserve">
          <source>ResetSorter</source>
          <target state="translated">ResetSorter</target>
        </trans-unit>
        <trans-unit id="945b8e3ad364a69485faa4a76d7e132dd6eb776f" translate="yes" xml:space="preserve">
          <source>Resolve race conditions when checking for a hot rollback journal.</source>
          <target state="translated">핫 롤백 저널을 확인할 때 경쟁 조건을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="5980fff15e0cb7f78dfb31d796946d8c4ea53b2a" translate="yes" xml:space="preserve">
          <source>Resource leak occurs when system resources are allocated and never freed. The most troublesome resource leaks in many applications are memory leaks - when memory is allocated using malloc() but never released using free(). But other kinds of resources can also be leaked: file descriptors, threads, mutexes, etc.</source>
          <target state="translated">시스템 리소스가 할당되고 해제되지 않은 경우 리소스 누수가 발생합니다. 많은 응용 프로그램에서 가장 번거로운 리소스 누수는 메모리 누수입니다. 메모리가 malloc ()을 사용하여 할당되었지만 free ()를 사용하여 해제되지 않은 경우입니다. 그러나 파일 디스크립터, 스레드, 뮤텍스 등과 같은 다른 종류의 리소스도 유출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cf16d9f970c04b17bfbf07788233ea17da985b8" translate="yes" xml:space="preserve">
          <source>Respect your seniors.</source>
          <target state="translated">선배를 존중하십시오.</target>
        </trans-unit>
        <trans-unit id="36680a4fee4b4b12262233214b4d26d022e2913e" translate="yes" xml:space="preserve">
          <source>Response To Errors Within A Transaction</source>
          <target state="translated">트랜잭션 내의 오류에 대한 응답</target>
        </trans-unit>
        <trans-unit id="5281acaf6bbb53755186ba2d2a2fba2f7232ed6e" translate="yes" xml:space="preserve">
          <source>Restore an undocumented side-effect of &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt;: force the database schema to be parsed if the database has not been previously accessed.</source>
          <target state="translated">문서화되지 않은 &lt;a href=&quot;pragma#pragma_cache_size&quot;&gt;PRAGMA cache_size&lt;/a&gt; 의 부작용을 복원 하십시오. 데이터베이스에 이전에 액세스하지 않은 경우 데이터베이스 스키마를 강제로 구문 분석하십시오.</target>
        </trans-unit>
        <trans-unit id="b706b9ba0c1e711b7875e7113121fd353ad1852e" translate="yes" xml:space="preserve">
          <source>Restrictions on DELETE Statements Within CREATE TRIGGER</source>
          <target state="translated">CREATE TRIGGER 내의 DELETE 문에 대한 제한 사항</target>
        </trans-unit>
        <trans-unit id="875031e1d8e2572c1b24b3afdc50c9a49e0b9d7d" translate="yes" xml:space="preserve">
          <source>Restrictions on UPDATE Statements Within CREATE TRIGGER</source>
          <target state="translated">CREATE TRIGGER 내의 UPDATE 문에 대한 제한 사항</target>
        </trans-unit>
        <trans-unit id="ff019e14c84d8867c98c53fb70f92255f6b869ca" translate="yes" xml:space="preserve">
          <source>Restrictions on the use of the same database connection by multiple threads have been dropped. It is now safe for multiple threads to use the same database connection at the same time.</source>
          <target state="translated">여러 스레드에 의한 동일한 데이터베이스 연결 사용에 대한 제한이 제거되었습니다. 이제 여러 스레드가 동일한 데이터베이스 연결을 동시에 사용하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="6c8b458fad0c69cdd74423c6f0cc7b1b2e72a5ac" translate="yes" xml:space="preserve">
          <source>Restrictions:</source>
          <target state="translated">Restrictions:</target>
        </trans-unit>
        <trans-unit id="9a855ef1e2ec958e943cbb0b24ca2484c61e478e" translate="yes" xml:space="preserve">
          <source>Result Codes</source>
          <target state="translated">결과 코드</target>
        </trans-unit>
        <trans-unit id="0e3a9c5b62f2be2064d3d964a9ef961f37a03948" translate="yes" xml:space="preserve">
          <source>Result Values From A Query</source>
          <target state="translated">쿼리의 결과 값</target>
        </trans-unit>
        <trans-unit id="dfc96e3519c40d27f3c2644dc81030f7c29138f4" translate="yes" xml:space="preserve">
          <source>Result and Error Codes</source>
          <target state="translated">결과 및 오류 코드</target>
        </trans-unit>
        <trans-unit id="89eab80a0f57b89fc1d59b20daa9700bb11c99e2" translate="yes" xml:space="preserve">
          <source>Result codes are signed 32-bit integers. The least significant 8 bits of the result code define a broad category and are called the &quot;primary result code&quot;. More significant bits provide more detailed information about the error and are called the &quot;extended result code&quot;</source>
          <target state="translated">결과 코드는 부호있는 32 비트 정수입니다. 결과 코드의 최하위 8 비트는 광범위한 범주를 정의하며 &quot;기본 결과 코드&quot;라고합니다. 더 중요한 비트는 오류에 대한 자세한 정보를 제공하며 &quot;확장 결과 코드&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="c2808243a5f85cbf0e581d25fba318891e44a157" translate="yes" xml:space="preserve">
          <source>Result is 0</source>
          <target state="translated">결과는 0입니다</target>
        </trans-unit>
        <trans-unit id="f5137efe83e1f4f972bd21e9f5483c9a64e0f0c5" translate="yes" xml:space="preserve">
          <source>Result is 0.0</source>
          <target state="translated">결과는 0.0</target>
        </trans-unit>
        <trans-unit id="b89c0dd7e80cf6dc04cdf2f4114d5f7686649ad2" translate="yes" xml:space="preserve">
          <source>Result is a NULL pointer</source>
          <target state="translated">결과는 NULL 포인터입니다</target>
        </trans-unit>
        <trans-unit id="bb79836494b7bb22f459b2b5efde6e40d43592a9" translate="yes" xml:space="preserve">
          <source>Result of</source>
          <target state="translated">에 의한 결과</target>
        </trans-unit>
        <trans-unit id="d4839ae333123eee753804cbdd44c1d300d284d9" translate="yes" xml:space="preserve">
          <source>ResultRow</source>
          <target state="translated">ResultRow</target>
        </trans-unit>
        <trans-unit id="a287530275c06ebcffc105b76d23550142d99bfa" translate="yes" xml:space="preserve">
          <source>Resulting Affinity</source>
          <target state="translated">결과 친화력</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="3ccfcce95184dd63b688eab71bd3c81c72b77f02" translate="yes" xml:space="preserve">
          <source>Retrieve the mutex for a database connection</source>
          <target state="translated">데이터베이스 연결을위한 뮤텍스 검색</target>
        </trans-unit>
        <trans-unit id="d1327c9133feffd8b254491a96ec4b023b23972e" translate="yes" xml:space="preserve">
          <source>Retrieving Statement SQL</source>
          <target state="translated">명령문 SQL 검색</target>
        </trans-unit>
        <trans-unit id="24f096b221f9534bcad007f2b5a32b490950b5b5" translate="yes" xml:space="preserve">
          <source>Return</source>
          <target state="translated">Return</target>
        </trans-unit>
        <trans-unit id="8cfd6fed2b7cd44c8a1d3921d26de3c89f4137b3" translate="yes" xml:space="preserve">
          <source>Return The Filename For A Database Connection</source>
          <target state="translated">데이터베이스 연결을위한 파일 이름 반환</target>
        </trans-unit>
        <trans-unit id="7605e4b76df0d8f628e31f2c3d6b09f231afd493" translate="yes" xml:space="preserve">
          <source>Return The Size Of An Open BLOB</source>
          <target state="translated">열린 BLOB의 크기를 반환</target>
        </trans-unit>
        <trans-unit id="c9f1f370dffb3244fd4b3f1019f574b9dc8457e3" translate="yes" xml:space="preserve">
          <source>Return a copy of the context pointer the extension function was registered with.</source>
          <target state="translated">확장 기능이 등록 된 컨텍스트 포인터의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="93dccbad6817a6ba3dfcee99a530964d929f8d05" translate="yes" xml:space="preserve">
          <source>Return a list of the collating sequences defined for the current database connection.</source>
          <target state="translated">현재 데이터베이스 연결에 대해 정의 된 조합 순서 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="ec015fb41d4bd004d23530229dd71ae3b421e7d4" translate="yes" xml:space="preserve">
          <source>Return non-zero if no changes to attached tables have been recorded by the session object passed as the first argument. Otherwise, if one or more changes have been recorded, return zero.</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 객체가 연결된 테이블에 대한 변경 내용을 기록하지 않은 경우 0이 아닌 값을 반환합니다. 그렇지 않으면, 하나 이상의 변경 사항이 기록되면 0을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5ead7de85983004ad9e89b05aa0ee43d6082138a" translate="yes" xml:space="preserve">
          <source>Return the current library version. For example, &quot;3.23.0&quot;.</source>
          <target state="translated">현재 라이브러리 버전을 반환합니다. 예를 들어 &quot;3.23.0&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="dbd49e766da7f825bdf2533d1e3226b6f95e33bc" translate="yes" xml:space="preserve">
          <source>Return the index of an SQL parameter given its name. The index value returned is suitable for use as the second parameter to &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;. A zero is returned if no matching parameter is found. The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">이름이 지정된 SQL 매개 변수의 색인을 리턴하십시오. 리턴 된 인덱스 값은 &lt;a href=&quot;#sqlite3_bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 의 두 번째 매개 변수로 사용하기에 적합합니다 . 일치하는 매개 변수가 없으면 0이 리턴됩니다. &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()을&lt;/a&gt; 사용하여 원래 명령문이 UTF-16 텍스트에서 준비된 경우에도 매개 변수 이름은 UTF-8로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="2c62ca55a6eb071e2311659bf9101fad7a84b4c2" translate="yes" xml:space="preserve">
          <source>Return the index of an SQL parameter given its name. The index value returned is suitable for use as the second parameter to &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt;. A zero is returned if no matching parameter is found. The parameter name must be given in UTF-8 even if the original statement was prepared from UTF-16 text using &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt;.</source>
          <target state="translated">이름이 지정된 SQL 매개 변수의 색인을 리턴하십시오. 리턴 된 인덱스 값은 &lt;a href=&quot;bind_blob&quot;&gt;sqlite3_bind ()&lt;/a&gt; 의 두 번째 매개 변수로 사용하기에 적합합니다 . 일치하는 매개 변수가 없으면 0이 리턴됩니다. &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()을&lt;/a&gt; 사용하여 원래 명령문이 UTF-16 텍스트에서 준비된 경우에도 매개 변수 이름은 UTF-8로 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="584c92020b0d55b58f3f81d597d44ac23857b3c2" translate="yes" xml:space="preserve">
          <source>Return the number of columns in the result set returned by the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. If this routine returns 0, that means the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; returns no data (for example an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;). However, just because this routine returns a positive number does not mean that one or more rows of data will be returned. A SELECT statement will always have a positive sqlite3_column_count() but depending on the WHERE clause constraints and the table content, it might return no rows.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문에서&lt;/a&gt; 반환 한 결과 집합의 열 수를 반환 합니다 . 이 루틴이 0을 리턴하면 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 데이터를 리턴하지 않음 을 의미합니다 (예 : &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; ). 그러나이 루틴이 양수를 리턴한다고해서 하나 이상의 데이터 행이 리턴되는 것은 아닙니다. SELECT 문은 항상 양의 sqlite3_column_count ()를 갖지만 WHERE 절 제약 조건과 테이블 내용에 따라 행이 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd4b7ebd0d4bc3eb6dc2bacaec6a197ca72e7bb6" translate="yes" xml:space="preserve">
          <source>Return the number of columns in the result set returned by the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. If this routine returns 0, that means the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; returns no data (for example an &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt;). However, just because this routine returns a positive number does not mean that one or more rows of data will be returned. A SELECT statement will always have a positive sqlite3_column_count() but depending on the WHERE clause constraints and the table content, it might return no rows.</source>
          <target state="translated">&lt;a href=&quot;stmt&quot;&gt;준비된 문에서&lt;/a&gt; 반환 한 결과 집합의 열 수를 반환 합니다 . 이 루틴이 0을 리턴하면 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 데이터를 리턴하지 않음 을 의미합니다 (예 : &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; ). 그러나이 루틴이 양수를 리턴한다고해서 하나 이상의 데이터 행이 리턴되는 것은 아닙니다. SELECT 문은 항상 양의 sqlite3_column_count ()를 갖지만 WHERE 절 제약 조건과 테이블 내용에 따라 행이 반환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de727986678206475b96540f2a1152c40c49d3b" translate="yes" xml:space="preserve">
          <source>Return the number of columns in the table.</source>
          <target state="translated">테이블의 열 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d1cd495449afb57ef3da16f47fbc65dd6c523ace" translate="yes" xml:space="preserve">
          <source>Return the number of unused pages in the database file.</source>
          <target state="translated">데이터베이스 파일에서 사용되지 않은 페이지 수를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="8c163d25aa7dcbb9e16b180d8ca3ed1a460aadfe" translate="yes" xml:space="preserve">
          <source>Return the total number of pages in the database file.</source>
          <target state="translated">데이터베이스 파일의 총 페이지 수를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="e6817d6cc2bed36a402d87f11d84b6e70c19349f" translate="yes" xml:space="preserve">
          <source>Return to step 1.</source>
          <target state="translated">1 단계로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="301afaadee702695e353e82ef8166c71bd172ca0" translate="yes" xml:space="preserve">
          <source>Returned data is examined using the other &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column_***()&lt;/a&gt; functions, all of which take a column number as their second parameter. Columns are zero-indexed from left to right. Note that this is different to parameters, which are indexed starting at one.</source>
          <target state="translated">반환 된 데이터는 다른 &lt;a href=&quot;c3ref/column_blob&quot;&gt;sqlite3_column _ *** ()&lt;/a&gt; 함수를 사용하여 검사되며 , 모든 함수는 열 번호를 두 번째 매개 변수로 사용합니다. 열은 왼쪽에서 오른쪽으로 인덱스가 0입니다. 이것은 하나에서 시작하여 색인되는 매개 변수와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e2686f150761965c2291e810c360b7fa256b9b14" translate="yes" xml:space="preserve">
          <source>Returns the current auxiliary data pointer for the fts5 extension function. See the xSetAuxdata() method for details.</source>
          <target state="translated">fts5 확장 함수에 대한 현재 보조 데이터 포인터를 반환합니다. 자세한 내용은 xSetAuxdata () 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40e9493f49c23a1617d0140f566ea77677b29eee" translate="yes" xml:space="preserve">
          <source>Returns the number of phrases in the current query expression.</source>
          <target state="translated">현재 쿼리 식의 구 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="be702afb99b8632ee8e2604b50399188ce2f63a5" translate="yes" xml:space="preserve">
          <source>Returns the number of tokens in phrase iPhrase of the query. Phrases are numbered starting from zero.</source>
          <target state="translated">쿼리의 구문 iPhrase에서 토큰 수를 리턴합니다. 문구는 0부터 시작하여 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="06e94d483c081225383a8d23a9a41849fed86ddd" translate="yes" xml:space="preserve">
          <source>Returns the rowid of the current row.</source>
          <target state="translated">현재 행의 rowid를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a70356c7dab00d066cc0b9588b657a85c397860" translate="yes" xml:space="preserve">
          <source>Returns the size in bytes of the BLOB accessible via the successfully opened &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; in its only argument. The incremental blob I/O routines can only read or overwriting existing blob content; they cannot change the size of a blob.</source>
          <target state="translated">성공적으로 열린 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 통해 액세스 할 수있는 BLOB 의 유일한 크기를 유일한 인수 로 바이트 단위로 반환합니다 . 증분 Blob I / O 루틴은 기존 Blob 내용 만 읽거나 덮어 쓸 수 있습니다. 블롭의 크기를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="599569e983878c20896f54d37ab3a35746f19b22" translate="yes" xml:space="preserve">
          <source>Returns the size in bytes of the BLOB accessible via the successfully opened &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; in its only argument. The incremental blob I/O routines can only read or overwriting existing blob content; they cannot change the size of a blob.</source>
          <target state="translated">성공적으로 열린 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 을 통해 액세스 할 수있는 BLOB 의 유일한 크기를 유일한 인수 로 바이트 단위로 반환합니다 . 증분 Blob I / O 루틴은 기존 Blob 내용 만 읽거나 덮어 쓸 수 있습니다. 블롭의 크기를 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5b189bd099508cad3195b5e809b7ca754b2316a7" translate="yes" xml:space="preserve">
          <source>Reuse the same materialization of a VIEW if that VIEW appears more than once in the same query.</source>
          <target state="translated">VIEW가 동일한 조회에서 두 번 이상 나타나면 VIEW의 동일한 구체화를 재사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e9dba232902ad2cdf131d289fa36492215873a60" translate="yes" xml:space="preserve">
          <source>Revert the data layout for an internal-use-only SQLite data structure. Applications that use SQLite should never reference internal SQLite data structures, but some do anyhow, and a change to one such data structure in 3.30.0 broke a popular and widely-deployed application. Reverting that change in SQLite, at least temporarily, gives developers of misbehaving applications time to fix their code.</source>
          <target state="translated">내부 전용 SQLite 데이터 구조의 데이터 레이아웃을 되돌립니다. SQLite를 사용하는 응용 프로그램은 내부 SQLite 데이터 구조를 참조해서는 안되지만 일부는 어쨌든 그렇게하고 3.30.0에서 그러한 데이터 구조를 변경하면 널리 배포 된 인기있는 응용 프로그램이 손상되었습니다. SQLite의 변경 사항을 적어도 일시적으로 되 돌리면 오작동하는 응용 프로그램 개발자에게 코드를 수정할 시간이 주어집니다.</target>
        </trans-unit>
        <trans-unit id="21f3a80b6e641cca270aef35408901e3786a82cd" translate="yes" xml:space="preserve">
          <source>Review Of The Benefits Of Using SQLite</source>
          <target state="translated">SQLite 사용의 이점 검토</target>
        </trans-unit>
        <trans-unit id="f7b6a25352179a1f3189248fb96fded90238ace0" translate="yes" xml:space="preserve">
          <source>Rewind</source>
          <target state="translated">Rewind</target>
        </trans-unit>
        <trans-unit id="eaf91a14e663bb5d218036023136ebf691041d14" translate="yes" xml:space="preserve">
          <source>Rework the optimizer so that it is able to make better use of indices</source>
          <target state="translated">인덱스를 더 잘 사용할 수 있도록 옵티 마이저를 재 작업하십시오.</target>
        </trans-unit>
        <trans-unit id="f0930a436e4d74c82cfb78eb81395a416496e73e" translate="yes" xml:space="preserve">
          <source>Rewrote &lt;b&gt;sqlite_complete()&lt;/b&gt; to make it faster.</source>
          <target state="translated">재 작성 &lt;b&gt;sqlite_complete는 ()&lt;/b&gt; 빨리를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="177e581868a420a9a991c07923089379283259e8" translate="yes" xml:space="preserve">
          <source>Right operand</source>
          <target state="translated">오른쪽 피연산자</target>
        </trans-unit>
        <trans-unit id="cf7f0b80736632d1a0202143607e39733be27371" translate="yes" xml:space="preserve">
          <source>Rigidly-typed database will convert the string '123' into an integer 123 and the integer 456 into a string '456' prior to doing the insert.</source>
          <target state="translated">엄밀한 형식의 데이터베이스는 삽입을 수행하기 전에 문자열 '123'을 정수 123으로, 정수 456을 문자열 '456'으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7459e37223bfc6b3c00ee42d9161ec2418f1c663" translate="yes" xml:space="preserve">
          <source>Rob Pike, in his</source>
          <target state="translated">그의 롭 파이크</target>
        </trans-unit>
        <trans-unit id="df0e3d7053ce53830f4865debd9baae261171b5b" translate="yes" xml:space="preserve">
          <source>Robson proof</source>
          <target state="translated">롭슨 증거</target>
        </trans-unit>
        <trans-unit id="c510da2e2e36b071c192210abf28d33eb451770b" translate="yes" xml:space="preserve">
          <source>Robson proves the following result:</source>
          <target state="translated">Robson은 다음 결과를 증명합니다.</target>
        </trans-unit>
        <trans-unit id="987cf59644c2119f71011556846f9f84d9761132" translate="yes" xml:space="preserve">
          <source>Robson's proof is constructive. He provides an algorithm for computing a sequence of allocation and deallocation operations that will lead to an allocation failure due to memory fragmentation if available memory is as much as one byte less than &lt;b&gt;N&lt;/b&gt;. And, Robson shows that a power-of-two first-fit memory allocator (such as implemented by &lt;a href=&quot;malloc#memsys5&quot;&gt;memsys5&lt;/a&gt;) will never fail a memory allocation provided that available memory is &lt;b&gt;N&lt;/b&gt; or more bytes.</source>
          <target state="translated">롭슨의 증거는 건설적입니다. 사용 가능한 메모리가 &lt;b&gt;N&lt;/b&gt; 보다 1 바이트 적은 경우 메모리 조각화로 인해 할당 실패로 이어질 일련의 할당 및 할당 취소 작업을 계산하는 알고리즘을 제공합니다 . 그리고 Robson은 사용 가능한 메모리가 &lt;b&gt;N&lt;/b&gt; 바이트 &lt;a href=&quot;malloc#memsys5&quot;&gt;이상인 경우 memsys5에&lt;/a&gt; 의해 구현 된 것과 같이 2의 제 1 적합 메모리 할당 자가 메모리 할당에 실패하지 &lt;b&gt;않음을 보여&lt;/b&gt; 줍니다.</target>
        </trans-unit>
        <trans-unit id="f28daee2c0f5b7710d2e3058da131e8e57520725" translate="yes" xml:space="preserve">
          <source>Rollback</source>
          <target state="translated">Rollback</target>
        </trans-unit>
        <trans-unit id="26b57a6c01526c32d5ab103341fc9e268271b128" translate="yes" xml:space="preserve">
          <source>Rollback Journal Header Format</source>
          <target state="translated">롤백 저널 헤더 형식</target>
        </trans-unit>
        <trans-unit id="0a7921e13556b51423199554a47039f1e1b141ba" translate="yes" xml:space="preserve">
          <source>Rollback Journal Page Record Format</source>
          <target state="translated">롤백 저널 페이지 레코드 형식</target>
        </trans-unit>
        <trans-unit id="839beb5f6f7483c68790e1c2cc37d0adc947ccac" translate="yes" xml:space="preserve">
          <source>Rollback journal</source>
          <target state="translated">롤백 저널</target>
        </trans-unit>
        <trans-unit id="f99c35fc97a4fbc462cfd8e94b67f39e4f03c16c" translate="yes" xml:space="preserve">
          <source>Rollback journal creation and deletion is also changed by the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;. The default journaling mode is DELETE, which is the default behavior of deleting the rollback journal file at the end of each transaction, as described above. The PERSIST journal mode foregoes the deletion of the journal file and instead overwrites the rollback journal header with zeros, which prevents other processes from rolling back the journal and thus has the same effect as deleting the journal file, though without the expense of actually removing the file from disk. In other words, journal mode PERSIST exhibits the same behavior as is seen in EXCLUSIVE locking mode. The OFF journal mode causes SQLite to omit the rollback journal, completely. In other words, no rollback journal is ever written if journal mode is set to OFF. The OFF journal mode disables the atomic commit and rollback capabilities of SQLite. The ROLLBACK command is not available when OFF journal mode is set. And if a crash or power loss occurs in the middle of a transaction that uses the OFF journal mode, no recovery is possible and the database file will likely go corrupt. The MEMORY journal mode causes the rollback journal to be stored in memory rather than on disk. The ROLLBACK command still works when the journal mode is MEMORY, but because no file exists on disks for recovery, a crash or power loss in the middle of a transaction that uses the MEMORY journal mode will likely result in a corrupt database.</source>
          <target state="translated">롤백 저널 작성 및 삭제도 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma에&lt;/a&gt; 의해 변경됩니다.. The default journaling mode is DELETE, which is the default behavior of deleting the rollback journal file at the end of each transaction, as described above. The PERSIST journal mode foregoes the deletion of the journal file and instead overwrites the rollback journal header with zeros, which prevents other processes from rolling back the journal and thus has the same effect as deleting the journal file, though without the expense of actually removing the file from disk. In other words, journal mode PERSIST exhibits the same behavior as is seen in EXCLUSIVE locking mode. The OFF journal mode causes SQLite to omit the rollback journal, completely. In other words, no rollback journal is ever written if journal mode is set to OFF. The OFF journal mode disables the atomic commit and rollback capabilities of SQLite. The ROLLBACK command is not available when OFF journal mode is set. And if a crash or power loss occurs in the middle of a transaction that uses the OFF journal mode, no recovery is possible and the database file will likely go corrupt. The MEMORY journal mode causes the rollback journal to be stored in memory rather than on disk. The ROLLBACK command still works when the journal mode is MEMORY, but because no file exists on disks for recovery, a crash or power loss in the middle of a transaction that uses the MEMORY journal mode will likely result in a corrupt database.</target>
        </trans-unit>
        <trans-unit id="65a856b62996757744b492724ee633b3cf56f87d" translate="yes" xml:space="preserve">
          <source>Rollback journal format</source>
          <target state="translated">롤백 저널 형식</target>
        </trans-unit>
        <trans-unit id="43d4ddd3c52786e9369d22ff2e61bd75eb1a4b4c" translate="yes" xml:space="preserve">
          <source>Rollback journals</source>
          <target state="translated">롤백 저널</target>
        </trans-unit>
        <trans-unit id="990192f4b62347879f2bc9b1914d6ccaff12f406" translate="yes" xml:space="preserve">
          <source>Rolling back a read-write transaction.</source>
          <target state="translated">읽기-쓰기 트랜잭션 롤백</target>
        </trans-unit>
        <trans-unit id="dc0f4d79ee6251d4a6ad0143bcbc0f35d1d2cf8e" translate="yes" xml:space="preserve">
          <source>Rolling back a statement transaction.</source>
          <target state="translated">명령문 트랜잭션을 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="338d5de4f22ea0bdf1d50d31eb34ee9d86b5b6c0" translate="yes" xml:space="preserve">
          <source>Routine maintenance releases of SQLite contain feature enhancements, performance enhancements, and/or fixes for non-critical issues. The version number for major releases are of the form &quot;3.N.0&quot; for some integer N. See the &lt;a href=&quot;versionnumbers&quot;&gt;version numbering conventions&lt;/a&gt; document for details.</source>
          <target state="translated">SQLite의 정기 유지 관리 릴리스에는 기능 향상, 성능 향상 및 중요하지 않은 문제에 대한 수정 사항이 포함되어 있습니다. 주요 릴리스의 버전 번호는 정수 N의 경우 &quot;3.N.0&quot;형식입니다. 자세한 내용은 &lt;a href=&quot;versionnumbers&quot;&gt;버전 번호 지정 규칙&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c582eecb413f71a3d238ca0bf059eebcad0aa19" translate="yes" xml:space="preserve">
          <source>Row Values</source>
          <target state="translated">행 값</target>
        </trans-unit>
        <trans-unit id="df652e925c5bd95b87a27543e5c35b40ab6f3b69" translate="yes" xml:space="preserve">
          <source>Row iRow is not present in the table,</source>
          <target state="translated">테이블에 행 iRow가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0bf47f4c7bbd729d98bef7a1b273dd0f54949969" translate="yes" xml:space="preserve">
          <source>Row values</source>
          <target state="translated">행 값</target>
        </trans-unit>
        <trans-unit id="1fb3b4ebab2ed27f77159d92a50f86467848d12a" translate="yes" xml:space="preserve">
          <source>Row values can also be used in the SET clause of an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. The LHS must be a list of column names. The RHS can be any row value. For example:</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문의 SET 절에서 행 값을 사용할 수도 있습니다 . LHS는 열 이름 목록이어야합니다. RHS는 모든 행 값이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f57a9e0829ebfb652d1a08f6606a4fdc646ad2ad" translate="yes" xml:space="preserve">
          <source>Row values were added to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14). Attempts to use row values in prior versions of SQLite will generate syntax errors.</source>
          <target state="translated">행 값이 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;버전 3.15.0&lt;/a&gt; (2016-10-14)에 추가되었습니다 . 이전 버전의 SQLite에서 행 값을 사용하려고하면 구문 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="12387d5182c8418d6ad512be3ea3618c001c0372" translate="yes" xml:space="preserve">
          <source>RowData</source>
          <target state="translated">RowData</target>
        </trans-unit>
        <trans-unit id="6a24981b8c9cf14045ca47563061580bfe81bf43" translate="yes" xml:space="preserve">
          <source>RowSetAdd</source>
          <target state="translated">RowSetAdd</target>
        </trans-unit>
        <trans-unit id="6bdf376cf730a3a0cf57d25f10cb07277289c1cd" translate="yes" xml:space="preserve">
          <source>RowSetRead</source>
          <target state="translated">RowSetRead</target>
        </trans-unit>
        <trans-unit id="b02724ebf8c33dc42582298663a77520ef7885ff" translate="yes" xml:space="preserve">
          <source>RowSetTest</source>
          <target state="translated">RowSetTest</target>
        </trans-unit>
        <trans-unit id="0543a4e41c6bb41386f39180441f23d42a6810f1" translate="yes" xml:space="preserve">
          <source>Rowid</source>
          <target state="translated">Rowid</target>
        </trans-unit>
        <trans-unit id="1b6cabf4c9edc4d52a090bd82fb7c381399fc11f" translate="yes" xml:space="preserve">
          <source>Rowid Tables</source>
          <target state="translated">Rowid 테이블</target>
        </trans-unit>
        <trans-unit id="ae07e577a2c8ff5df89cdb23d73b02059973e24d" translate="yes" xml:space="preserve">
          <source>Rowid tables are distinguished by the fact that they all have a unique, non-NULL, signed 64-bit integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; that is used as the access key for the data in the underlying &lt;a href=&quot;fileformat2#btree&quot;&gt;B-tree&lt;/a&gt; storage engine.</source>
          <target state="translated">Rowid 테이블은 모두 기본 &lt;a href=&quot;fileformat2#btree&quot;&gt;B- 트리&lt;/a&gt; 스토리지 엔진 의 데이터에 대한 액세스 키로 사용되는 NULL이 아닌 고유 한 부호없는 64 비트 정수 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 가지고 있다는 사실로 구별됩니다 .</target>
        </trans-unit>
        <trans-unit id="d27e62434c0ce96633784772a686c27f243cac85" translate="yes" xml:space="preserve">
          <source>Rowid values may be modified using an UPDATE statement in the same way as any other column value can, either using one of the built-in aliases (&quot;rowid&quot;, &quot;oid&quot; or &quot;_rowid_&quot;) or by using an alias created by an integer primary key. Similarly, an INSERT statement may provide a value to use as the rowid for each row inserted. Unlike normal SQLite columns, an integer primary key or rowid column must contain integer values. Integer primary key or rowid columns are not able to hold floating point values, strings, BLOBs, or NULLs.</source>
          <target state="translated">내장 된 별명 중 하나 ( &quot;rowid&quot;, &quot;oid&quot;또는 &quot;_rowid_&quot;)를 사용하거나 다른 방법으로 작성된 별명을 사용하여 다른 열 값과 동일한 방식으로 UPDATE 문을 사용하여 Rowid 값을 수정할 수 있습니다. 정수 기본 키. 마찬가지로, INSERT 문은 삽입 된 각 행의 rowid로 사용할 값을 제공 할 수 있습니다. 일반 SQLite 열과 달리 정수 기본 키 또는 rowid 열에는 정수 값이 포함되어야합니다. 정수 기본 키 또는 rowid 열은 부동 소수점 값, 문자열, BLOB 또는 NULL을 보유 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="edcb9421250841f78107dd4609c8bba109afac4c" translate="yes" xml:space="preserve">
          <source>Rows are first sorted based on the results of evaluating the left-most expression in the ORDER BY list, then ties are broken by evaluating the second left-most expression and so on. The order in which two rows for which all ORDER BY expressions evaluate to equal values are returned is undefined. Each ORDER BY expression may be optionally followed by one of the keywords ASC (smaller values are returned first) or DESC (larger values are returned first). If neither ASC or DESC are specified, rows are sorted in ascending (smaller values first) order by default.</source>
          <target state="translated">ORDER BY 목록에서 가장 왼쪽에있는 표현식을 평가 한 결과에 따라 행이 먼저 정렬 된 다음 가장 왼쪽에있는 두 번째 표현식 등을 평가하여 연결이 끊어집니다. 모든 ORDER BY 표현식이 동일한 값으로 평가되는 두 개의 행이 리턴되는 순서는 정의되지 않습니다. 각 ORDER BY 표현식 뒤에는 키워드 ASC (작은 값이 먼저 리턴 됨) 또는 DESC (큰 값이 먼저 리턴 됨) 중 하나가 올 수 있습니다. ASC 또는 DESC를 지정하지 않으면 기본적으로 행이 오름차순 (작은 값부터)으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="ac40e048a509794571456d3aeb85ea91e2d43403" translate="yes" xml:space="preserve">
          <source>Rows within the changeset and changegroup are identified by the values in their PRIMARY KEY columns. A change in the changeset is considered to apply to the same row as a change already present in the changegroup if the two rows have the same primary key.</source>
          <target state="translated">변경 세트 및 변경 그룹 내의 행은 PRIMARY KEY 열의 값으로 식별됩니다. 두 행에 동일한 기본 키가있는 경우 변경 세트의 변경은 변경 그룹에 이미 존재하는 변경과 동일한 행에 적용되는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="37c3356624a30d8a5326d4fe795d20ac5cb27bda" translate="yes" xml:space="preserve">
          <source>Rtree shadow tables</source>
          <target state="translated">Rtree 섀도우 테이블</target>
        </trans-unit>
        <trans-unit id="8955c3464100454cbfbaed12a7670fe9af2f00d8" translate="yes" xml:space="preserve">
          <source>Rule Used To Determine Affinity</source>
          <target state="translated">선호도를 결정하는 데 사용되는 규칙</target>
        </trans-unit>
        <trans-unit id="dc703024fe690f5cbdaba3100ad90ec563a534fc" translate="yes" xml:space="preserve">
          <source>Rules for determining column affinity</source>
          <target state="translated">열 선호도 결정 규칙</target>
        </trans-unit>
        <trans-unit id="1532a9d89988293141b3ab96625565d783ed6f47" translate="yes" xml:space="preserve">
          <source>Rules for determining column affinity in VIEWs</source>
          <target state="translated">VIEW에서 열 선호도를 결정하기위한 규칙</target>
        </trans-unit>
        <trans-unit id="f0bd573f68f048cb6c4cd7d9146020d890e31e4c" translate="yes" xml:space="preserve">
          <source>Rules of Programming</source>
          <target state="translated">프로그래밍 규칙</target>
        </trans-unit>
        <trans-unit id="f48eda60ef0a367697eace9099533e43243e0fec" translate="yes" xml:space="preserve">
          <source>Run &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; on tables that might benefit. On by default. See below for additional information.</source>
          <target state="translated">이점이있는 테이블에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행하십시오 . 기본적으로 켜져 있습니다. 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="86c5bae00a746104e50c27daa834a283ef103b19" translate="yes" xml:space="preserve">
          <source>Run &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; on the database as the first SQL statement after opening the database files and prior to running any other SQL statements. Reject and refuse to process any database file containing errors.</source>
          <target state="translated">실행 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 또는 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 데이터베이스 파일과 이전에 다른 SQL 문을 실행하기를 여는 후 첫 번째 SQL 문으로 데이터베이스에. 오류가 포함 된 데이터베이스 파일 처리를 거부하고 거부합니다.</target>
        </trans-unit>
        <trans-unit id="e1e6804c74fa4cb630c4c910d52bc257ca7871ae" translate="yes" xml:space="preserve">
          <source>Run &lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; to determine the current schema version number. This number will be needed for step 6 below.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_schema_version&quot;&gt;PRAGMA schema_version&lt;/a&gt; 을 실행 하여 현재 스키마 버전 번호를 판별하십시오. 이 번호는 아래 6 단계에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="200c67ee1788ce66b0156066057d60b2800be9ca" translate="yes" xml:space="preserve">
          <source>Run a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; command that specifies the new module in the USING clause.</source>
          <target state="translated">USING 절에서 새 모듈을 지정 하는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 명령을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a3d1debd094b27fe5b0bae8dd45d281db7a6a84" translate="yes" xml:space="preserve">
          <source>Run an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement to change the definition of table X in the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master table&lt;/a&gt;: UPDATE sqlite_master SET sql=... WHERE type='table' AND name='X';</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 하여 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master 테이블&lt;/a&gt; 에서 테이블 X의 정의를 변경하십시오 . UPDATE sqlite_master SET sql = ... WHERE type = 'table'AND name = 'X';</target>
        </trans-unit>
        <trans-unit id="3178c793117edca1387c2bebcee2677fe3c82d7d" translate="yes" xml:space="preserve">
          <source>Run an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement to change the definition of table X in the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt;: UPDATE sqlite_schema SET sql=... WHERE type='table' AND name='X';</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 하여 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블&lt;/a&gt; 에서 테이블 X의 정의를 변경 합니다 . UPDATE sqlite_schema SET sql = ... WHERE type = 'table'AND name = 'X';</target>
        </trans-unit>
        <trans-unit id="3a2559e302efc761aaf10b478651c8b31dfe1012" translate="yes" xml:space="preserve">
          <source>Run the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; statement on each database connection as soon as it is opened.</source>
          <target state="translated">각 데이터베이스 연결이 열리 자마자 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema = OFF&lt;/a&gt; 문을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2b88d9cfd5c748ad04f60bce488dec8e98edf34" translate="yes" xml:space="preserve">
          <source>Run the SQL by calling &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; one or more times.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 한 번 이상 호출하여 SQL을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e0ab3906001915da29683dab9551528912f1cd6" translate="yes" xml:space="preserve">
          <source>Run the SQL by calling &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; one or more times.</source>
          <target state="translated">&lt;a href=&quot;step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 한 번 이상 호출하여 SQL을 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="fd50f1892f2119fb1ad0f811c960cce443863519" translate="yes" xml:space="preserve">
          <source>Run the SQL statement or statements specified in the P4 string.</source>
          <target state="translated">P4 문자열에 지정된 SQL 문을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="1cb2c35ec40d1b73d4831c1e50ed059ce44c8496" translate="yes" xml:space="preserve">
          <source>Run the initial-select and add the results to a queue.</source>
          <target state="translated">초기 선택을 실행하고 결과를 대기열에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a404918f75e1c621a9e51e540dea6b35ddf73cd9" translate="yes" xml:space="preserve">
          <source>Run-Time Library Compilation Options Diagnostics</source>
          <target state="translated">런타임 라이브러리 컴파일 옵션 진단</target>
        </trans-unit>
        <trans-unit id="b3a1ab24d28a4516dc6367fed9cebd2e03e59a70" translate="yes" xml:space="preserve">
          <source>Run-Time Library Version Numbers</source>
          <target state="translated">런타임 라이브러리 버전 번호</target>
        </trans-unit>
        <trans-unit id="c7d825a0077f1e132da3c45873d064ccb730776f" translate="yes" xml:space="preserve">
          <source>Run-Time Limit Categories</source>
          <target state="translated">런타임 제한 범주</target>
        </trans-unit>
        <trans-unit id="356784f229022f3f4fa8dbfbe3bb3898d9ac8202" translate="yes" xml:space="preserve">
          <source>Run-Time Loadable Extensions</source>
          <target state="translated">런타임로드 가능한 확장</target>
        </trans-unit>
        <trans-unit id="4574000a6e96e607432e6012acf5a8e676d5db3e" translate="yes" xml:space="preserve">
          <source>Run-time Limits</source>
          <target state="translated">런타임 제한</target>
        </trans-unit>
        <trans-unit id="eeb5d4ca03faaf77fd6c152793d1bcca81acfa48" translate="yes" xml:space="preserve">
          <source>Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources. An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet. The internal databases can be given the large, default limits. Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack. Developers might also want to use the &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to further control untrusted SQL. The size of the database created by an untrusted script can be contained using the &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;.</source>
          <target state="translated">런타임 제한은 자체 내부 데이터베이스와 신뢰할 수없는 외부 소스로 제어되는 데이터베이스를 모두 관리하는 응용 프로그램에서 사용하기위한 것입니다. 예제 애플리케이션은 인터넷에서 다운로드 한 JavaScript 애플리케이션에 의해 제어되는 히스토리 및 별도의 데이터베이스를 저장하기위한 자체 데이터베이스가있는 웹 브라우저 일 수 있습니다. 내부 데이터베이스에는 큰 기본 제한이 주어질 수 있습니다. 외부 소스에 의해 관리되는 데이터베이스에는 서비스 거부 공격을 방지하기 위해 훨씬 작은 한계가 제공 될 수 있습니다. 개발자는 &lt;a href=&quot;#sqlite3_set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 신뢰할 수없는 SQL을 추가로 제어 할 수도 있습니다 . 신뢰할 수없는 스크립트로 작성된 데이터베이스의 크기는 &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA를&lt;/a&gt; 사용하여 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69f368380570607f69cdc2eb535f9228296eec7f" translate="yes" xml:space="preserve">
          <source>Run-time limits are intended for use in applications that manage both their own internal database and also databases that are controlled by untrusted external sources. An example application might be a web browser that has its own databases for storing history and separate databases controlled by JavaScript applications downloaded off the Internet. The internal databases can be given the large, default limits. Databases managed by external sources can be given much smaller limits designed to prevent a denial of service attack. Developers might also want to use the &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface to further control untrusted SQL. The size of the database created by an untrusted script can be contained using the &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt;.</source>
          <target state="translated">런타임 제한은 자체 내부 데이터베이스와 신뢰할 수없는 외부 소스로 제어되는 데이터베이스를 모두 관리하는 응용 프로그램에서 사용하기위한 것입니다. 예제 애플리케이션은 인터넷에서 다운로드 한 JavaScript 애플리케이션에 의해 제어되는 히스토리 및 별도의 데이터베이스를 저장하기위한 자체 데이터베이스가있는 웹 브라우저 일 수 있습니다. 내부 데이터베이스에는 큰 기본 제한이 주어질 수 있습니다. 외부 소스에 의해 관리되는 데이터베이스에는 서비스 거부 공격을 방지하기 위해 훨씬 작은 한계가 제공 될 수 있습니다. 개발자는 &lt;a href=&quot;set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; 인터페이스를 사용하여 신뢰할 수없는 SQL을 추가로 제어 할 수도 있습니다 . 신뢰할 수없는 스크립트로 작성된 데이터베이스의 크기는 &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA를&lt;/a&gt; 사용하여 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8b1baa820be21fdd8b0b7b82bbf5713240efffc1" translate="yes" xml:space="preserve">
          <source>Running &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; on the repository database immediately fixed the performance problem. However, we want Fossil to be robust and to always work quickly regardless of whether or not its repository has been analyzed. For this reason, the query was modified to use the CROSS JOIN operator instead of the plain JOIN operator. SQLite will not reorder the tables of a CROSS JOIN. This is a long-standing feature of SQLite that is specifically designed to allow knowledgeable programmers to enforce a particular loop nesting order. Once the join was changed to CROSS JOIN (the addition of a single keyword) the NGQP was forced to choose the faster algorithm-1 regardless of whether or not statistical information had been gathered using ANALYZE.</source>
          <target state="translated">저장소 데이터베이스 에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 를 실행 하면 즉시 성능 문제가 해결되었습니다. 그러나 우리는 Fossil이 강력하고 저장소의 분석 여부에 관계없이 항상 신속하게 작동하기를 원합니다. 이러한 이유로 일반 JOIN 연산자 대신 CROSS JOIN 연산자를 사용하도록 쿼리가 수정되었습니다. SQLite는 CROSS JOIN의 테이블을 재정렬하지 않습니다. 이는 지식이 풍부한 프로그래머가 특정 루프 중첩 순서를 적용 할 수 있도록 특별히 설계된 SQLite의 오랜 기능입니다. 조인이 CROSS JOIN (단일 키워드 추가)으로 변경되면 NGQP는 ANALYZE를 사용하여 통계 정보를 수집했는지 여부에 관계없이 더 빠른 알고리즘 -1을 선택해야했습니다.</target>
        </trans-unit>
        <trans-unit id="c0156e598611c35d199fc02e32088579684f7ef3" translate="yes" xml:space="preserve">
          <source>Running the query above in an SQLite &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; results in the following output:</source>
          <target state="translated">SQLite &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 위의 쿼리를 실행하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ba49486643979e995184b4c3697b2dacd80d9d7e" translate="yes" xml:space="preserve">
          <source>Rust needs a mechanism to recover gracefully from OOM errors.</source>
          <target state="translated">Rust는 OOM 오류에서 정상적으로 복구 할 수있는 메커니즘이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="821895ed234e7e857359d37f1a8ce18a5ba49790" translate="yes" xml:space="preserve">
          <source>Rust needs to demonstrate that it can be used to create general-purpose libraries that are callable from all other programming languages.</source>
          <target state="translated">Rust는 다른 모든 프로그래밍 언어에서 호출 할 수있는 범용 라이브러리를 작성하는 데 사용할 수 있음을 입증해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d6747d87a00df42214e38b7f79e4baafc98172e" translate="yes" xml:space="preserve">
          <source>Rust needs to demonstrate that it can do the kinds of work that C does in SQLite without a significant speed penalty.</source>
          <target state="translated">Rust는 상당한 속도 저하없이 C가 SQLite에서 수행하는 작업을 수행 할 수 있음을 입증해야합니다.</target>
        </trans-unit>
        <trans-unit id="e41f901a143fa76074dca8510c0ac303842f7088" translate="yes" xml:space="preserve">
          <source>Rust needs to demonstrate that it can produce object code that works on obscure embedded devices, including devices that lack an operating system.</source>
          <target state="translated">Rust는 운영 체제가없는 장치를 포함하여 모호한 내장 장치에서 작동하는 객체 코드를 생성 할 수 있음을 입증해야합니다.</target>
        </trans-unit>
        <trans-unit id="686367ae98c0afb62856b39caa6f9e26523bbf7e" translate="yes" xml:space="preserve">
          <source>Rust needs to mature a little more, stop changing so fast, and move further toward being old and boring.</source>
          <target state="translated">녹은 조금 더 성숙해 져야하고, 그렇게 빨리 변화하는 것을 멈추고, 늙고 지루한쪽으로 나아가 야합니다.</target>
        </trans-unit>
        <trans-unit id="5b3359351a99b6e0447edba9c109d666a0f77ba3" translate="yes" xml:space="preserve">
          <source>Rust needs to pick up the necessary tooling that enables one to do 100% branch coverage testing of the compiled binaries.</source>
          <target state="translated">Rust는 컴파일 된 바이너리에 대해 100 % 지점 커버리지 테스트를 수행 할 수있는 필요한 툴링을 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c5e7d070ec0ab017535260be8b2a8640c2f6758" translate="yes" xml:space="preserve">
          <source>SAVEPOINT</source>
          <target state="translated">SAVEPOINT</target>
        </trans-unit>
        <trans-unit id="d3dfe14898bacd6618223172971922e8e3d2ecb6" translate="yes" xml:space="preserve">
          <source>SAVEPOINTs are a method of creating transactions, similar to &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;, except that the SAVEPOINT and RELEASE commands are named and may be nested.</source>
          <target state="translated">SAVEPOINT는 SAVEPOINT 및 RELEASE 명령의 이름이 지정되고 중첩 될 수 있다는 점을 제외하고 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 및 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 와 유사한 트랜잭션을 작성하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="ccaa4ad4b0473eec188ee304a3074e15c5bcaa64" translate="yes" xml:space="preserve">
          <source>SCHEMA</source>
          <target state="translated">SCHEMA</target>
        </trans-unit>
        <trans-unit id="e9ac0c81cd1a5814654384dec1db5914e6e8ffbc" translate="yes" xml:space="preserve">
          <source>SCopy</source>
          <target state="translated">SCopy</target>
        </trans-unit>
        <trans-unit id="a4942c26d0735947d8a22a2fbe2735a12e381808" translate="yes" xml:space="preserve">
          <source>SELECT</source>
          <target state="translated">SELECT</target>
        </trans-unit>
        <trans-unit id="c17e1164d6d4adc4580e6b98257217851026edd8" translate="yes" xml:space="preserve">
          <source>SELECT (julianday('now') - 2440587.5)*86400.0;</source>
          <target state="translated">SELECT (julianday ( 'now')-2440587.5) * 86400.0;</target>
        </trans-unit>
        <trans-unit id="ace1632c3b65e122022c070637db478435903efa" translate="yes" xml:space="preserve">
          <source>SELECT * FROM</source>
          <target state="translated">선택 * FROM</target>
        </trans-unit>
        <trans-unit id="7fc906f5fcd66134603adcc3c2dc2b0816332390" translate="yes" xml:space="preserve">
          <source>SELECT c1 + 1, c1 FROM t1;</source>
          <target state="translated">선택 c1 + 1, c1 FROM t1;</target>
        </trans-unit>
        <trans-unit id="2999be47286974f6ded094d67d14496e0d48cb72" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=0 AND b&amp;lt;1000;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 0 및 b &amp;lt;1000;</target>
        </trans-unit>
        <trans-unit id="cb3cf4c41dcd4864297008c0568d0aaeadbbb0ab" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=0 AND b&amp;lt;100;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 0 및 b &amp;lt;100;</target>
        </trans-unit>
        <trans-unit id="1dfef29b2f96087115ab4f1998ca9d5d5bc4915e" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=100 AND b&amp;lt;1100;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 100 및 b &amp;lt;1100;</target>
        </trans-unit>
        <trans-unit id="5e0dc45bc122e351ed4d69503b46acbb65f6c888" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=100 AND b&amp;lt;200;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 100 및 b &amp;lt;200;</target>
        </trans-unit>
        <trans-unit id="f27f7b75fc95c522aa8587a73f83be80a625a4f4" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=200 AND b&amp;lt;300;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2에서 b&amp;gt; = 200 및 b &amp;lt;300;</target>
        </trans-unit>
        <trans-unit id="3ad9d76e2e287888d3d567bad1917d7f27249045" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=499700 AND b&amp;lt;499800;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 499700 및 b &amp;lt;499800;</target>
        </trans-unit>
        <trans-unit id="a8b99d0b9f3f7b566b4cb2376958eda3cd361877" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=499800 AND b&amp;lt;499900;</source>
          <target state="translated">b&amp;gt; = 499800 및 b &amp;lt;499900에서 t2로부터 FROM 수 (*), 평균 (b);</target>
        </trans-unit>
        <trans-unit id="8f0f694a032e9c2882a6e0a92488949ed710bcdc" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=499900 AND b&amp;lt;500000;</source>
          <target state="translated">b&amp;gt; = 499900 및 b &amp;lt;500000 인 경우 t2로부터 선택 카운트 (*), 평균 (b);</target>
        </trans-unit>
        <trans-unit id="f9659f905cc64490bfff8c9e612827be3f2df375" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=9800 AND b&amp;lt;10800;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 9800 및 b &amp;lt;10800;</target>
        </trans-unit>
        <trans-unit id="85e718b18603ccafa1d233381c9e3d90643535fd" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE b&amp;gt;=9900 AND b&amp;lt;10900;</source>
          <target state="translated">선택 카운트 (*), 평균 (b) t2로부터 b&amp;gt; = 9900 및 b &amp;lt;10900;</target>
        </trans-unit>
        <trans-unit id="7a6ea45477d45946853b47b82ca873a24747c3a3" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE c LIKE '%ninety nine%';</source>
          <target state="translated">셀렉트 카운트 (*), 평균 (b) t % 어디서나 '% ninety nine %';</target>
        </trans-unit>
        <trans-unit id="6d56ea8dbd183589162deadede0ab1219f305259" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE c LIKE '%one hundred%';</source>
          <target state="translated">선택 횟수 (*), 평균 (b) t2에서 '% 100 %'와 같음;</target>
        </trans-unit>
        <trans-unit id="fcff3003f487f0bde8b5bcf5f79e9f2c24518345" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE c LIKE '%one%';</source>
          <target state="translated">'% one %'과 (와) 같은 위치에서 개수 선택 (*), 평균 (b);</target>
        </trans-unit>
        <trans-unit id="24e94427c6c52789402be213f45b0a481633937a" translate="yes" xml:space="preserve">
          <source>SELECT count(*), avg(b) FROM t2 WHERE c LIKE '%two%';</source>
          <target state="translated">'% two %'와 같은 위치에서 t2에서 선택 횟수 (*), 평균 (b);</target>
        </trans-unit>
        <trans-unit id="4e6e9af529f0dc227b4081d3367ad22be0573c6b" translate="yes" xml:space="preserve">
          <source>SELECT date('now');</source>
          <target state="translated">날짜 선택 ( '지금');</target>
        </trans-unit>
        <trans-unit id="cd79208fc843d46be1ad9c028a2f9411c1f57c41" translate="yes" xml:space="preserve">
          <source>SELECT date('now','start of month','+1 month','-1 day');</source>
          <target state="translated">날짜 선택 ( '지금', '달의 시작', '+ 1 개월', '-1 일');</target>
        </trans-unit>
        <trans-unit id="6496f2b9c47706fb49050676e4652b53964c3b4b" translate="yes" xml:space="preserve">
          <source>SELECT date('now','start of year','+9 months','weekday 2');</source>
          <target state="translated">날짜 선택 ( '지금', '년의 시작', '+ 9 개월', '주중 2');</target>
        </trans-unit>
        <trans-unit id="23e299a69ad4fca3c21e2e03be7f6e587b5a96a2" translate="yes" xml:space="preserve">
          <source>SELECT datetime(1092941466, 'unixepoch');</source>
          <target state="translated">날짜 시간 선택 (1092941466, 'unixepoch');</target>
        </trans-unit>
        <trans-unit id="de550f272d3560a8724923b25c4e2e5d4efc58a3" translate="yes" xml:space="preserve">
          <source>SELECT datetime(1092941466, 'unixepoch', 'localtime');</source>
          <target state="translated">날짜 선택 (1092941466, 'unixepoch', 'localtime');</target>
        </trans-unit>
        <trans-unit id="2efcc4c53fa85dbf3d5a71e72dc87768bfffb650" translate="yes" xml:space="preserve">
          <source>SELECT employee_name, login, host FROM users WHERE employee_name IS NULL;</source>
          <target state="translated">employee_name 선택, 로그인, 호스트 FROM 사용자 WHERE employee_name이 NULL 인 경우;</target>
        </trans-unit>
        <trans-unit id="b6ab5268ca47f8f58b818fb00a419ab36ae61d4d" translate="yes" xml:space="preserve">
          <source>SELECT employee_name, login, host FROM users WHERE login LIKE 'd%';</source>
          <target state="translated">'d %'와 같은 로그인 위치에서 employee_name, 로그인, 호스트 FROM 사용자를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a86637e2fc1412d1ac0214351f7993756549f75d" translate="yes" xml:space="preserve">
          <source>SELECT julianday('now') - julianday('1776-07-04');</source>
          <target state="translated">SELECT julianday ( 'now')-julianday ( '1776-07-04');</target>
        </trans-unit>
        <trans-unit id="86ba56c82fa49458f395b63db321f6aed2955e6a" translate="yes" xml:space="preserve">
          <source>SELECT min() or max() of an indexed column with no WHERE or GROUP BY clause is handled as a special case which avoids a complete table scan.</source>
          <target state="translated">WHERE 또는 GROUP BY 절이없는 인덱싱 된 열의 SELECT min () 또는 max ()는 전체 테이블 스캔을 피하는 특수한 경우로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="1e373546903c6b72eb60c90f573f5eeeb6b0c8c9" translate="yes" xml:space="preserve">
          <source>SELECT rowid, * FROM table WHERE ...</source>
          <target state="translated">SELECT rowid, * FROM table WHERE ...</target>
        </trans-unit>
        <trans-unit id="385a2d13e433dad6795e05b0c5ddc3896353a06c" translate="yes" xml:space="preserve">
          <source>SELECT statements may be optionally preceded by a single &lt;a href=&quot;lang_with&quot;&gt;WITH clause&lt;/a&gt; that defines one or more &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; for use within the SELECT statement.</source>
          <target state="translated">SELECT 문 앞에는 선택적으로 SELECT 문 내에서 사용할 하나 이상의 &lt;a href=&quot;lang_with&quot;&gt;공통 테이블 식&lt;/a&gt; 을 정의 하는 단일 &lt;a href=&quot;lang_with&quot;&gt;WITH 절이&lt;/a&gt; 있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e1985f3ceac18ba608b336dfd7af533ced4235a" translate="yes" xml:space="preserve">
          <source>SELECT strftime('%s','now') - strftime('%s','2004-01-01 02:34:56');</source>
          <target state="translated">SELECT strftime ( '% s', 'now')-strftime ( '% s', '2004-01-01 02:34:56');</target>
        </trans-unit>
        <trans-unit id="51366b15fc11b1c4d4847c3b1795c2166721efda" translate="yes" xml:space="preserve">
          <source>SELECT strftime('%s','now');</source>
          <target state="translated">SELECT strftime ( '% s', 'now');</target>
        </trans-unit>
        <trans-unit id="55c5d81017a30edf1e47ba1b78c377a5e5ebfd50" translate="yes" xml:space="preserve">
          <source>SET</source>
          <target state="translated">SET</target>
        </trans-unit>
        <trans-unit id="518f5cfdf48141888cf66ad84de38117c5c999ce" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 06d77b42a3e70609f8d4bbb97caf53652f1082cb</source>
          <target state="translated">sqlite3.c의 SHA1 : 06d77b42a3e70609f8d4bbb97caf53652f1082cb</target>
        </trans-unit>
        <trans-unit id="c786fbb8e25e29f64e0fad37105265a660092ca5" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 0a54d76566728c2ba96292a49b138e4f69a7c391</source>
          <target state="translated">sqlite3.c의 SHA1 : 0a54d76566728c2ba96292a49b138e4f69a7c391</target>
        </trans-unit>
        <trans-unit id="582e08978c06e03dfaace3d436497e9b5759969e" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 0a56693a3c24aa3217098afab1b6fecccdedfd23</source>
          <target state="translated">sqlite3.c의 SHA1 : 0a56693a3c24aa3217098afab1b6fecccdedfd23</target>
        </trans-unit>
        <trans-unit id="1b3ec7a1154ed8987d278b19d32eb16e0a306951" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 0b34f0de356a3f21b9dfc761f3b7821b6353c570</source>
          <target state="translated">sqlite3.c의 SHA1 : 0b34f0de356a3f21b9dfc761f3b7821b6353c570</target>
        </trans-unit>
        <trans-unit id="acad88d127e69645c5d1ffb1d2e29927340cde27" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 1398ba8e4043550a533cdd0834bfdad1c9eab0f4</source>
          <target state="translated">sqlite3.c의 SHA1 : 1398ba8e4043550a533cdd0834bfdad1c9eab0f4</target>
        </trans-unit>
        <trans-unit id="b0720fa8994f834c1ccc1130600e65404a5be38a" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 1c4013876f50bbaa3e6f0f98e0147c76287684c1</source>
          <target state="translated">sqlite3.c의 SHA1 : 1c4013876f50bbaa3e6f0f98e0147c76287684c1</target>
        </trans-unit>
        <trans-unit id="c04d4f8df2f9af01183c30089c62d89bab0e2a8a" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 234a3275d03a287434ace3ccdf1afb208e6b0e92</source>
          <target state="translated">sqlite3.c의 SHA1 : 234a3275d03a287434ace3ccdf1afb208e6b0e92</target>
        </trans-unit>
        <trans-unit id="767db67b1c513ac84b85c1f6fcd80d32ce9d285c" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 246987605d0503c700a08b9ee99a6b5d67454aab</source>
          <target state="translated">sqlite3.c의 SHA1 : 246987605d0503c700a08b9ee99a6b5d67454aab</target>
        </trans-unit>
        <trans-unit id="70e44500d0c2648bd27e158fc4ce8e9a4a6e1522" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 2b413611f5e3e3b6ef5f618f2a9209cdf25cbcff&quot;</source>
          <target state="translated">sqlite3.c에 대한 SHA1 : 2b413611f5e3e3b6ef5f618f2a9209cdf25cbcff &quot;</target>
        </trans-unit>
        <trans-unit id="71de8abb82b7878aaa553b522b438e9f5729631e" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 2bebdc3f24911c0d12b6d6c0123c3f84d6946b08</source>
          <target state="translated">sqlite3.c의 SHA1 : 2bebdc3f24911c0d12b6d6c0123c3f84d6946b08</target>
        </trans-unit>
        <trans-unit id="bdd600d56d190ad6d894f13eda4ffd2a77b8e6f6" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 2d25bd1a73dc40f538f3a81c28e6efa5999bdf0c</source>
          <target state="translated">sqlite3.c의 SHA1 : 2d25bd1a73dc40f538f3a81c28e6efa5999bdf0c</target>
        </trans-unit>
        <trans-unit id="6887a0b2f1eb85f34da0136a7076626afde1f252" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 310a1faeb9332a3cd8d1f53b4a2e055abf537bdc</source>
          <target state="translated">sqlite3.c의 SHA1 : 310a1faeb9332a3cd8d1f53b4a2e055abf537bdc</target>
        </trans-unit>
        <trans-unit id="3af993c76c84360931106330b9e8969403eec600" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 33987fb50dcc09f1429a653d6b47672f5a96f19e</source>
          <target state="translated">sqlite3.c의 SHA1 : 33987fb50dcc09f1429a653d6b47672f5a96f19e</target>
        </trans-unit>
        <trans-unit id="6a31a799bcb9b1d757ab30369d6ba6d116a007c4" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 354f6223490b30fd5320b4066b1535e4ce33988d</source>
          <target state="translated">sqlite3.c의 SHA1 : 354f6223490b30fd5320b4066b1535e4ce33988d</target>
        </trans-unit>
        <trans-unit id="3d1ef1541c967d1f504f941d0e16cdce31ee05ef" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 3ad2f5ba3a4a3e3e51a1dac9fda9224b359f0261</source>
          <target state="translated">sqlite3.c의 SHA1 : 3ad2f5ba3a4a3e3e51a1dac9fda9224b359f0261</target>
        </trans-unit>
        <trans-unit id="0d6a754c40727c27d5463d1dd8ab6857b9ff0a59" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 3be71d99121fe5b17f057011025bcf84e7cc6c84</source>
          <target state="translated">sqlite3.c의 SHA1 : 3be71d99121fe5b17f057011025bcf84e7cc6c84</target>
        </trans-unit>
        <trans-unit id="fa76c46545d3e20c60eb65844d8bffe4dc7a1eb5" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 3da832fd2af36eaedb05d61a8f4c2bb9f3d54265</source>
          <target state="translated">sqlite3.c의 SHA1 : 3da832fd2af36eaedb05d61a8f4c2bb9f3d54265</target>
        </trans-unit>
        <trans-unit id="75f4f34d52eecd331ff100b18afbd1169109d8ef" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 4685ca86c2ea0649ed9f59a500013e90b3fe6d03</source>
          <target state="translated">sqlite3.c의 SHA1 : 4685ca86c2ea0649ed9f59a500013e90b3fe6d03</target>
        </trans-unit>
        <trans-unit id="7166837cb0c4bf6e30dcfb57bd9019214b288f83" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 49f1c3ae347e1327b5aaa6c7f76126bdf09c6f42</source>
          <target state="translated">sqlite3.c의 SHA1 : 49f1c3ae347e1327b5aaa6c7f76126bdf09c6f42</target>
        </trans-unit>
        <trans-unit id="a8e497bc0ec594d11ee3fd5837a41e693c16c97d" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 56dcf5e931a9e1fa12fc2d600cd91d3bf9b639cd</source>
          <target state="translated">sqlite3.c의 SHA1 : 56dcf5e931a9e1fa12fc2d600cd91d3bf9b639cd</target>
        </trans-unit>
        <trans-unit id="4beaec4785359c5c1d02da232f931ef314ffdac9" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 5741f47d1bc38aa0a8c38f09e60a5fe0031f272d</source>
          <target state="translated">sqlite3.c의 SHA1 : 5741f47d1bc38aa0a8c38f09e60a5fe0031f272d</target>
        </trans-unit>
        <trans-unit id="8d35f9edd3f83726e689ec0f705cc8fa4717a16c" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 57e2104a0f7b3f528e7f6b7a8e553e2357ccd2e1</source>
          <target state="translated">sqlite3.c의 SHA1 : 57e2104a0f7b3f528e7f6b7a8e553e2357ccd2e1</target>
        </trans-unit>
        <trans-unit id="410083614e771f176a404019b04a041685ce3d6c" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 5bbe79e206ae5ffeeca760dbd0d66862228db551</source>
          <target state="translated">sqlite3.c의 SHA1 : 5bbe79e206ae5ffeeca760dbd0d66862228db551</target>
        </trans-unit>
        <trans-unit id="1bb66a0884e0412bc391f35259006ea05b86e695" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 5e6d1873a32d82c2cf8581f143649940cac8ae49</source>
          <target state="translated">sqlite3.c의 SHA1 : 5e6d1873a32d82c2cf8581f143649940cac8ae49</target>
        </trans-unit>
        <trans-unit id="859f6cb198ada543711017163183ec4b77ae3ad9" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 5fdf596b29bb426001f28b488ff356ae14d5a5a6</source>
          <target state="translated">sqlite3.c의 SHA1 : 5fdf596b29bb426001f28b488ff356ae14d5a5a6</target>
        </trans-unit>
        <trans-unit id="d3bdde58846b63d9ccf8b24441c5f430679e93f3" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 62aaecaacab3a4bf4a8fe4aec1cfdc1571fe9a44</source>
          <target state="translated">sqlite3.c의 SHA1 : 62aaecaacab3a4bf4a8fe4aec1cfdc1571fe9a44</target>
        </trans-unit>
        <trans-unit id="f32ae58f427b54138bb21b54a816ac6a5ec1c39c" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 638abb77965332c956dbbd2c8e4248e84da4eb63</source>
          <target state="translated">sqlite3.c의 SHA1 : 638abb77965332c956dbbd2c8e4248e84da4eb63</target>
        </trans-unit>
        <trans-unit id="0bc1f03a5413f24c720865eca6937b0a7e918f4d" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 6422c7d69866f5ea3db0968f67ee596e7114544e</source>
          <target state="translated">sqlite3.c의 SHA1 : 6422c7d69866f5ea3db0968f67ee596e7114544e</target>
        </trans-unit>
        <trans-unit id="1a5da3913e19c6f3908408c38d05473d3d867c44" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 6497cbbaad47220bd41e2e4216c54706e7ae95d4</source>
          <target state="translated">sqlite3.c의 SHA1 : 6497cbbaad47220bd41e2e4216c54706e7ae95d4</target>
        </trans-unit>
        <trans-unit id="818f5e4cfc4a59279d5d21c8c9b2fe41a10eeaeb" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 6cf0c7b46975a87a0dc3fba69c229a7de61b0c21</source>
          <target state="translated">sqlite3.c의 SHA1 : 6cf0c7b46975a87a0dc3fba69c229a7de61b0c21</target>
        </trans-unit>
        <trans-unit id="e6e189f8d4cfc8021b3704bf738ba9e42e8aceb5" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 719f6891abcd9c459b5460b191d731cd12a3643e</source>
          <target state="translated">sqlite3.c의 SHA1 : 719f6891abcd9c459b5460b191d731cd12a3643e</target>
        </trans-unit>
        <trans-unit id="ddd8ffc475f78dbc5f0efc68d120ac4fc70ddf5b" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 72c64f05cd9babb9c0f9b3c82536d83be7804b1c</source>
          <target state="translated">sqlite3.c의 SHA1 : 72c64f05cd9babb9c0f9b3c82536d83be7804b1c</target>
        </trans-unit>
        <trans-unit id="39b7fd693dba957b0b4918d2b630a700c5be14d5" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 7308ab891ca1b2ebc596025cfe4dc36f1ee89cf6</source>
          <target state="translated">sqlite3.c의 SHA1 : 7308ab891ca1b2ebc596025cfe4dc36f1ee89cf6</target>
        </trans-unit>
        <trans-unit id="6d42fa3f7aba6b4e5bcd15d8238b1eced8f961fe" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 74ee38c8c6fd175ec85a47276dfcefe8a262827a</source>
          <target state="translated">sqlite3.c의 SHA1 : 74ee38c8c6fd175ec85a47276dfcefe8a262827a</target>
        </trans-unit>
        <trans-unit id="c368f52ba7e32e065858628302cac0dd2b6ad137" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 7a91ceceac9bcf47ceb8219126276e5518f7ff5a</source>
          <target state="translated">sqlite3.c의 SHA1 : 7a91ceceac9bcf47ceb8219126276e5518f7ff5a</target>
        </trans-unit>
        <trans-unit id="996f5c490d0b82431625d6b80aab1e07e7f255e7" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 7bc194957238c61b1a47f301270286be5bc5208c</source>
          <target state="translated">sqlite3.c의 SHA1 : 7bc194957238c61b1a47f301270286be5bc5208c</target>
        </trans-unit>
        <trans-unit id="3f32ad5c909e08d36dd20e6e6e7458af3cb1be73" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 806577fd524dd5f3bfd8d4d27392ed2752bc9701</source>
          <target state="translated">sqlite3.c의 SHA1 : 806577fd524dd5f3bfd8d4d27392ed2752bc9701</target>
        </trans-unit>
        <trans-unit id="0b396500e7864bb3e4aac438254daf2b01f1c081" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 85ce79948116aa9a087ec345c9d2ce2c1d3cd8af</source>
          <target state="translated">sqlite3.c의 SHA1 : 85ce79948116aa9a087ec345c9d2ce2c1d3cd8af</target>
        </trans-unit>
        <trans-unit id="7258bcc4aaad7a2657eb9ff9b46ab60ba9c99351" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 85e4e1c08c7df28ef61bb9759a0d466e0eefbaa2</source>
          <target state="translated">sqlite3.c의 SHA1 : 85e4e1c08c7df28ef61bb9759a0d466e0eefbaa2</target>
        </trans-unit>
        <trans-unit id="6d77759be8c09e9fb3d7902076419e25e662aa43" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 91aea4cc722371d58aae3d22e94d2a4165276905</source>
          <target state="translated">sqlite3.c의 SHA1 : 91aea4cc722371d58aae3d22e94d2a4165276905</target>
        </trans-unit>
        <trans-unit id="f4ffe2d211b87cfcf88a29e5674bdec0656a9728" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 98a07da78f71b0275e8d9c510486877adc31dbee</source>
          <target state="translated">sqlite3.c의 SHA1 : 98a07da78f71b0275e8d9c510486877adc31dbee</target>
        </trans-unit>
        <trans-unit id="46ba6354bd2a2740a64d3728e536ac7063e1f472" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 990004ef2d0eec6a339e4caa562423897fe02bf0</source>
          <target state="translated">sqlite3.c의 SHA1 : 990004ef2d0eec6a339e4caa562423897fe02bf0</target>
        </trans-unit>
        <trans-unit id="fc96475f0b9e67ff00eba2c22eef8cc410b495ee" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 99906bf63e6cef63d6f3d7f8526ac4a70e76559e</source>
          <target state="translated">sqlite3.c의 SHA1 : 99906bf63e6cef63d6f3d7f8526ac4a70e76559e</target>
        </trans-unit>
        <trans-unit id="4d0cd2bf95f6978fffeca11029e4d1ef8b4afb65" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: 9b9171b1e6ce7a980e6b714e9c0d9112657ad552</source>
          <target state="translated">sqlite3.c의 SHA1 : 9b9171b1e6ce7a980e6b714e9c0d9112657ad552</target>
        </trans-unit>
        <trans-unit id="a10ae896e189719dc56a65016206f185de862b46" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: b0c22e5f15f5ba2afd017ecd990ea507918afe1c</source>
          <target state="translated">sqlite3.c의 SHA1 : b0c22e5f15f5ba2afd017ecd990ea507918afe1c</target>
        </trans-unit>
        <trans-unit id="4b361cc61c990822bb873c524ae8ce2fdbbeb270" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: b2a68d5783f48dba6a8cb50d8bf69b238c5ec53a</source>
          <target state="translated">sqlite3.c의 SHA1 : b2a68d5783f48dba6a8cb50d8bf69b238c5ec53a</target>
        </trans-unit>
        <trans-unit id="2416214d167dc41992cec17f405eeb42ff097c23" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: b7347f4b4c2a840e6ba12040093d606bd16ea21e</source>
          <target state="translated">sqlite3.c의 SHA1 : b7347f4b4c2a840e6ba12040093d606bd16ea21e</target>
        </trans-unit>
        <trans-unit id="ad16dfaeb2316bf717084ee2af678c49414f0b8d" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: b81bfa27d3e09caf3251475863b1ce6dd9f6ab66</source>
          <target state="translated">sqlite3.c의 SHA1 : b81bfa27d3e09caf3251475863b1ce6dd9f6ab66</target>
        </trans-unit>
        <trans-unit id="1566e5dc1d0051d266fd1f427e6272e65e279ee4" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: b92ca988ebb6df02ac0c8f866dbf3256740408ac</source>
          <target state="translated">sqlite3.c의 SHA1 : b92ca988ebb6df02ac0c8f866dbf3256740408ac</target>
        </trans-unit>
        <trans-unit id="0df77a88b3c87ed0eec1fc932224743c04eda4cc" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: bbbaa68061e925bd4d7d18d7e1270935c5f7e39a</source>
          <target state="translated">sqlite3.c의 SHA1 : bbbaa68061e925bd4d7d18d7e1270935c5f7e39a</target>
        </trans-unit>
        <trans-unit id="c9e2bf9aad1740793ada5dbd85fe7a1256aac287" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: bcc4a1989db45e7f223191f2d0f66c1c28946383</source>
          <target state="translated">sqlite3.c의 SHA1 : bcc4a1989db45e7f223191f2d0f66c1c28946383</target>
        </trans-unit>
        <trans-unit id="fca7479e7e07e07f2e1e507e54ecd6462624a1da" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: becd16877f4f9b281b91c97e106089497d71bb47</source>
          <target state="translated">sqlite3.c의 SHA1 : becd16877f4f9b281b91c97e106089497d71bb47</target>
        </trans-unit>
        <trans-unit id="26d0affa54207b5f590c8c2db718cc2660562e21" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: bfcd74a655636b592c5dba6d0d5729c0f8e3b4de</source>
          <target state="translated">sqlite3.c의 SHA1 : bfcd74a655636b592c5dba6d0d5729c0f8e3b4de</target>
        </trans-unit>
        <trans-unit id="71b144036be9da2733cb64b777ab83d7e8e1a1e8" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: c03e47e152ddb9c342b84ffb39448bf4a2bd4288</source>
          <target state="translated">sqlite3.c의 SHA1 : c03e47e152ddb9c342b84ffb39448bf4a2bd4288</target>
        </trans-unit>
        <trans-unit id="6ab80f5df98ab03c72f1935c1f11bc95bd384d3b" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: cba2be96d27cb51978cd4a200397a4ad178986eb</source>
          <target state="translated">sqlite3.c의 SHA1 : cba2be96d27cb51978cd4a200397a4ad178986eb</target>
        </trans-unit>
        <trans-unit id="0241d0ced88e44b26d919326871585a5dd2d13bf" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: cc7d708bb073c44102a59ed63ce6142da1f174d1</source>
          <target state="translated">sqlite3.c의 SHA1 : cc7d708bb073c44102a59ed63ce6142da1f174d1</target>
        </trans-unit>
        <trans-unit id="4e54dcac32c259186c523dbd1678a28e6c1f4444" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: d460d7eda3a9dccd291aed2a9fda868b9b120a10</source>
          <target state="translated">sqlite3.c의 SHA1 : d460d7eda3a9dccd291aed2a9fda868b9b120a10</target>
        </trans-unit>
        <trans-unit id="45065d85b7318ef037cfcd44ebb0aa51e2bee4d6" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: d466b54789dff4fb0238b9232e74896deaefab94</source>
          <target state="translated">sqlite3.c의 SHA1 : d466b54789dff4fb0238b9232e74896deaefab94</target>
        </trans-unit>
        <trans-unit id="ae3690edfaf6cfe5df238b3d8b6d1da514deb412" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: d47594b8a02f6cf58e91fb673e96cb1b397aace0</source>
          <target state="translated">sqlite3.c의 SHA1 : d47594b8a02f6cf58e91fb673e96cb1b397aace0</target>
        </trans-unit>
        <trans-unit id="1a28ea0ad67e88ccfe518c60c39b7eac220e9a53" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: d494e8d81607f0515d4f386156fb0fd86d5ba7df</source>
          <target state="translated">sqlite3.c의 SHA1 : d494e8d81607f0515d4f386156fb0fd86d5ba7df</target>
        </trans-unit>
        <trans-unit id="57fd2927e6073a46440079cb985f6dda60adb269" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: d545b24892278272ce4e40e0567d69c8babf12ea</source>
          <target state="translated">sqlite3.c의 SHA1 : d545b24892278272ce4e40e0567d69c8babf12ea</target>
        </trans-unit>
        <trans-unit id="fbf14c64a116f9d81076e606fd05e2b9e00a7dfa" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: d5cd1535053a50aa8633725e3595740b33709ac5</source>
          <target state="translated">sqlite3.c의 SHA1 : d5cd1535053a50aa8633725e3595740b33709ac5</target>
        </trans-unit>
        <trans-unit id="0878d22b88f118d4c4621a47bd15dfb8407b1dbb" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: de5a5898ebd3a3477d4652db143746d008b24c83</source>
          <target state="translated">sqlite3.c의 SHA1 : de5a5898ebd3a3477d4652db143746d008b24c83</target>
        </trans-unit>
        <trans-unit id="98f1948bc0a2a9b55a02309589ceafbf5db375b6" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: df01436c5fcfe72d1a95bc172158219796e1a90b</source>
          <target state="translated">sqlite3.c의 SHA1 : df01436c5fcfe72d1a95bc172158219796e1a90b</target>
        </trans-unit>
        <trans-unit id="b696860d87b82d2ace962c98e3d96ca85389fd29" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: e2920fb885569d14197c9b7958e6f1db573ee669</source>
          <target state="translated">sqlite3.c의 SHA1 : e2920fb885569d14197c9b7958e6f1db573ee669</target>
        </trans-unit>
        <trans-unit id="d77bc7005f2cfc118bb0361e395515b39a886c49" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: e7c26a7be3e431dd06898f8d262c4ef240c07366</source>
          <target state="translated">sqlite3.c의 SHA1 : e7c26a7be3e431dd06898f8d262c4ef240c07366</target>
        </trans-unit>
        <trans-unit id="835017d95017bca96fb8ff3d8010b4c6b2ae9855" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: ebb18593350779850e3e1a930eb84a70fca8c1d1</source>
          <target state="translated">sqlite3.c의 SHA1 : ebb18593350779850e3e1a930eb84a70fca8c1d1</target>
        </trans-unit>
        <trans-unit id="c35a1037cb539e650335ba3ac01789e12e572ac8" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: f38df08547efae0ff4343da607b723f588bbd66b</source>
          <target state="translated">sqlite3.c에 대한 SHA1 : f38df08547efae0ff4343da607b723f588bbd66b</target>
        </trans-unit>
        <trans-unit id="18eaf3d91c3e9b8de3a9cf53f358eab89891a619" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: f7088b19d97cd7a1c805ee95c696abd54f01de4f</source>
          <target state="translated">sqlite3.c의 SHA1 : f7088b19d97cd7a1c805ee95c696abd54f01de4f</target>
        </trans-unit>
        <trans-unit id="d290d4943ae2b192150564857f2615419a317b56" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: fba106f8f6493c66eeed08a2dfff0907de54ae76</source>
          <target state="translated">sqlite3.c의 SHA1 : fba106f8f6493c66eeed08a2dfff0907de54ae76</target>
        </trans-unit>
        <trans-unit id="f23d574d108505bf068a61cc6d7582e502767ce9" translate="yes" xml:space="preserve">
          <source>SHA1 for sqlite3.c: ff0a771d6252545740ba9685e312b0e3bb6a641b</source>
          <target state="translated">sqlite3.c의 SHA1 : ff0a771d6252545740ba9685e312b0e3bb6a641b</target>
        </trans-unit>
        <trans-unit id="169f4deb0246d3570158bad20200688c21e0709f" translate="yes" xml:space="preserve">
          <source>SHA3-256 for sqlite3.c: 0d384704e1c66026228336d1e91771d295bf688c9c44c7a44f25a4c16c26ab3c</source>
          <target state="translated">sqlite3.c의 경우 SHA3-256 : 0d384704e1c66026228336d1e91771d295bf688c9c44c7a44f25a4c16c26ab3c</target>
        </trans-unit>
        <trans-unit id="2b101fda084199c51aee62e3c51a9003fda7a22c" translate="yes" xml:space="preserve">
          <source>SHA3-256 for sqlite3.c: 11c14992660d5ac713ea8bea48dc5e6123f26bc8d3075fe5585d1a217d090233</source>
          <target state="translated">sqlite3.c에 대한 SHA3-256 : 11c14992660d5ac713ea8bea48dc5e6123f26bc8d3075fe5585d1a217d090233</target>
        </trans-unit>
        <trans-unit id="e5f3840c98559993cdf639c9feff229a04c4bd24" translate="yes" xml:space="preserve">
          <source>SHA3-256 for sqlite3.c: 1b2302e7a54cc99c84ff699a299f61f069a28e1ed090b89e4430ca80ae2aab06</source>
          <target state="translated">sqlite3.c의 경우 SHA3-256 : 1b2302e7a54cc99c84ff699a299f61f069a28e1ed090b89e4430ca80ae2aab06</target>
        </trans-unit>
        <trans-unit id="ef8b5ac0b53a71c99448aafe2dbfb42a453d8b10" translate="yes" xml:space="preserve">
          <source>SHA3-256 for sqlite3.c: 1be0c457869c1f7eba58c3b5097b9ec307a15be338308bee8e5be8570bcf5d1e</source>
          <target state="translated">sqlite3.c 용 SHA3-256 : 1be0c457869c1f7eba58c3b5097b9ec307a15be338308bee8e5be8570bcf5d1e</target>
        </trans-unit>
        <trans-unit id="0abb78c3f0e36a9205b92202782996041e3e8be5" translate="yes" xml:space="preserve">
          <source>SHA3-256 for sqlite3.c: 1dbae33bff261f979d0042338f72c9e734b11a80720fb32498bae9150cc576e7</source>
          <target state="translated">sqlite3.c의 SHA3-256 : 1dbae33bff261f979d0042338f72c9e734b11a80720fb32498bae9150cc576e7</target>
        </trans-unit>
        <trans-unit id="1caf10c723e38c0b3b04cfc26d18911dcf5c7f6f" translate="yes" xml:space="preserve">
          <source>SHA3-256 for sqlite3.c: 206df47ebc49cd1710ac0dd716ce5de5854826536993f4feab7a49d136b85069</source>
          <target state="translated">sqlite3.c에 대한 SHA3-256 : 206df47ebc49cd1710ac0dd716ce5de5854826536993f4feab7a49d136b85069</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
