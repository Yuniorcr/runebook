<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="cc11826689203b888f22525a7551a5472c324526" translate="yes" xml:space="preserve">
          <source>OVER</source>
          <target state="translated">OVER</target>
        </trans-unit>
        <trans-unit id="829a2c0005fc7d37eb660c0d5cde206b5192f790" translate="yes" xml:space="preserve">
          <source>Obey in all things the commands of those whom God has placed in authority over you even though they (which God forbid) should act otherwise, mindful of the Lord's precept, &quot;Do what they say, but not what they do.&quot;</source>
          <target state="translated">비록 그들이 (하나님이 금지 한) 그들이 &quot;그들의 말을하라.</target>
        </trans-unit>
        <trans-unit id="a21a5206c75e38db5a2f38df79e6283758ee658a" translate="yes" xml:space="preserve">
          <source>Object-Oriented Design</source>
          <target state="translated">객체 지향 디자인</target>
        </trans-unit>
        <trans-unit id="898a9f4f224c827df0fb00ecec65822c23a3936e" translate="yes" xml:space="preserve">
          <source>Object-Oriented is a design pattern, not a programming language. You can do object-oriented programming in any language you want, including assembly language. Some languages (ex: C++ or Java) make object-oriented easier. But you can still do object-oriented programming in languages like C.</source>
          <target state="translated">객체 지향은 프로그래밍 언어가 아닌 디자인 패턴입니다. 어셈블리 언어를 포함하여 원하는 언어로 객체 지향 프로그래밍을 수행 할 수 있습니다. 일부 언어 (예 : C ++ 또는 Java)는 객체 지향을 더 쉽게 만듭니다. 그러나 C와 같은 언어로 여전히 객체 지향 프로그래밍을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e6159d8c90870c6430155592639731dac8033a3" translate="yes" xml:space="preserve">
          <source>Object-oriented is not the only valid design pattern. Many programmers have been taught to think purely in terms of objects. And, to be fair, objects are often a good way to decompose a problem. But objects are not the only way, and are not always the best way to decompose a problem. Sometimes good old procedural code is easier to write, easier to maintain and understand, and faster than object-oriented code.</source>
          <target state="translated">객체 지향 만이 유효한 디자인 패턴은 아닙니다. 많은 프로그래머들이 객체에 대해서만 순수하게 생각하도록 배웠습니다. 그리고 공정하게 말하면, 물체는 종종 문제를 분해하는 좋은 방법입니다. 그러나 객체가 유일한 방법은 아니며 항상 문제를 분해하는 가장 좋은 방법은 아닙니다. 때로는 좋은 오래된 절차 코드가 작성하기 쉽고 유지 관리 및 이해하기 쉽고 객체 지향 코드보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ea838bb1557d80ce2bdbf51816fc7a1525503976" translate="yes" xml:space="preserve">
          <source>Objects:</source>
          <target state="translated">Objects:</target>
        </trans-unit>
        <trans-unit id="3a36347e6c9b66b32ae45cd886e8708db38d062b" translate="yes" xml:space="preserve">
          <source>Obscure bug fix on triggers (&lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt;).</source>
          <target state="translated">트리거의 버그 수정 ( &lt;a href=&quot;http://www.sqlite.org/src/info/efc02f9779&quot;&gt;[efc02f9779]&lt;/a&gt; )이 모호 합니다.</target>
        </trans-unit>
        <trans-unit id="06705e47733fa2d26527ca5b13fe92c1b7ca1944" translate="yes" xml:space="preserve">
          <source>Obsolete Documents</source>
          <target state="translated">사용되지 않는 문서</target>
        </trans-unit>
        <trans-unit id="adcd55329b6153adb94eaf8a12d01ba2bc7cea95" translate="yes" xml:space="preserve">
          <source>Obtain A Composite Changeset From A Changegroup</source>
          <target state="translated">변경 그룹에서 복합 변경 집합 가져 오기</target>
        </trans-unit>
        <trans-unit id="f036e380a093cadb7b7384e4b591b8c75c1ba145" translate="yes" xml:space="preserve">
          <source>Obtain Aggregate Function Context</source>
          <target state="translated">집계 함수 컨텍스트 확보</target>
        </trans-unit>
        <trans-unit id="e79fb280b93973e6bfe3f8e79ba72b5b038ba1fa" translate="yes" xml:space="preserve">
          <source>Obtain Conflicting Row Values From A Changeset Iterator</source>
          <target state="translated">변경 세트 반복자에서 충돌하는 행 값 가져 오기</target>
        </trans-unit>
        <trans-unit id="d4c8c29e25fb3ccc649578fec3be2c67a658b123" translate="yes" xml:space="preserve">
          <source>Obtain The Current Operation From A Changeset Iterator</source>
          <target state="translated">Changeset Iterator에서 현재 작업 가져 오기</target>
        </trans-unit>
        <trans-unit id="7ada95f817f8fc624dbadc0c0f495b244a8d38b3" translate="yes" xml:space="preserve">
          <source>Obtain The Primary Key Definition Of A Table</source>
          <target state="translated">테이블의 기본 키 정의 얻기</target>
        </trans-unit>
        <trans-unit id="2f0f8596ef7c82c2d68f88fe0c2c42b22b20b24e" translate="yes" xml:space="preserve">
          <source>Obtain Values For URI Parameters</source>
          <target state="translated">URI 매개 변수 값 얻기</target>
        </trans-unit>
        <trans-unit id="e719cf57b48331ec73c3d09816f240ac71d990d4" translate="yes" xml:space="preserve">
          <source>Obtain a PENDING lock and then an EXCLUSIVE lock on the database file. If other processes still have SHARED locks, the writer might have to wait until those SHARED locks clear before it is able to obtain an EXCLUSIVE lock.</source>
          <target state="translated">데이터베이스 파일에서 PENDING 잠금과 EXCLUSIVE 잠금을 확보하십시오. 다른 프로세스에 여전히 SHARED 잠금이있는 경우 기록기는 해당 SHARED 잠금이 지워질 때까지 기다려야 독점 잠금을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4c184719398e2fd529d288f83e902aa72fdd7b4" translate="yes" xml:space="preserve">
          <source>Obtain a buffer containing a changeset (or patchset) representing the current contents of the changegroup. If the inputs to the changegroup were themselves changesets, the output is a changeset. Or, if the inputs were patchsets, the output is also a patchset.</source>
          <target state="translated">변경 그룹의 현재 내용을 나타내는 변경 세트 (또는 패치 세트)를 포함하는 버퍼를 얻습니다. 변경 그룹에 대한 입력이 변경 세트 인 경우 출력은 변경 세트입니다. 또는 입력이 패치 세트 인 경우 출력도 패치 세트입니다.</target>
        </trans-unit>
        <trans-unit id="0ad736b5bee2570f5cbf619854f8b97d9b6134d1" translate="yes" xml:space="preserve">
          <source>Obtain a changeset containing changes to the tables attached to the session object passed as the first argument. If successful, set *ppChangeset to point to a buffer containing the changeset and *pnChangeset to the size of the changeset in bytes before returning SQLITE_OK. If an error occurs, set both *ppChangeset and *pnChangeset to zero and return an SQLite error code.</source>
          <target state="translated">첫 번째 인수로 전달 된 세션 오브젝트에 첨부 된 테이블에 대한 변경 사항이 포함 된 변경 사항 세트를 확보하십시오. 성공하면 SQLITE_OK를 리턴하기 전에 변경 세트를 포함하는 버퍼를 가리키고 * pnChangeset을 변경 세트의 크기를 바이트 단위로 가리 키도록 * ppChangeset을 설정하십시오. 오류가 발생하면 * ppChangeset 및 * pnChangeset을 모두 0으로 설정하고 SQLite 오류 코드를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="4304c4d08f4f900e2ab1ec29540131e8bf87ae39" translate="yes" xml:space="preserve">
          <source>Obtain a lock on a particular table. This instruction is only used when the shared-cache feature is enabled.</source>
          <target state="translated">특정 테이블에 대한 잠금을 확보하십시오. 이 명령어는 공유 캐시 기능이 활성화 된 경우에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35cc8c81bb0ab78babd3f65cb1b473a29bd69034" translate="yes" xml:space="preserve">
          <source>Obtain an EXCLUSIVE lock on the database file and make sure all memory changes have been written to the database file using the algorithm of steps 1-3 above.</source>
          <target state="translated">데이터베이스 파일에 대한 독점 잠금을 확보하고 위의 1-3 단계 알고리즘을 사용하여 모든 메모리 변경 사항이 데이터베이스 파일에 기록되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="edc981514ab58076de28ce864d46ccc2641ec1d0" translate="yes" xml:space="preserve">
          <source>Obtain new.* Values From A Changeset Iterator</source>
          <target state="translated">Changeset Iterator에서 새 값을 얻습니다. *</target>
        </trans-unit>
        <trans-unit id="c31b9f4e355939157fe39f17fcb0e54282736c63" translate="yes" xml:space="preserve">
          <source>Obtain old.* Values From A Changeset Iterator</source>
          <target state="translated">구하십시오. * Changeset Iterator에서 값</target>
        </trans-unit>
        <trans-unit id="d399842fa2ae120f608cae0543637da5b44e2b8c" translate="yes" xml:space="preserve">
          <source>Obtain the latest SQLite code from fossil.</source>
          <target state="translated">화석에서 최신 SQLite 코드를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9ed23644c9e9a46df1cd037be0519be726230e11" translate="yes" xml:space="preserve">
          <source>Obtaining SQL Values</source>
          <target state="translated">SQL 값 얻기</target>
        </trans-unit>
        <trans-unit id="ffe740a4611067b4b4dd0b5b7a28183003203956" translate="yes" xml:space="preserve">
          <source>Obtaining the</source>
          <target state="translated">획득</target>
        </trans-unit>
        <trans-unit id="a8fbf19c89308087d70d289986f946de344868c9" translate="yes" xml:space="preserve">
          <source>Obtains the mutex.</source>
          <target state="translated">뮤텍스를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="974debb0f023f79fb3eec2db47da68008b639181" translate="yes" xml:space="preserve">
          <source>Occasionally, a serious problem is found and a small &quot;patch&quot; release must be made against a regular maintenance release. Patch are distinct from maintenance releases in that the number of lines of code changed from the previous release is very small. Every effort is made to avoid patch releases by making sure that maintenance releases are bug free.</source>
          <target state="translated">때때로 심각한 문제가 발견되고 정기적 인 유지 보수 릴리스에 대해 작은 &quot;패치&quot;릴리스를 작성해야합니다. 패치는 이전 릴리스에서 변경된 코드 줄 수가 매우 작다는 점에서 유지 보수 릴리스와 다릅니다. 유지 보수 릴리스에 버그가 없는지 확인하여 패치 릴리스를 피하기 위해 모든 노력을 기울입니다.</target>
        </trans-unit>
        <trans-unit id="10b7fae72f94602297b15a7cf850a8e1ee7b4b31" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_master&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">물론 ANALYZE는 데이터베이스에 많은 양의 컨텐츠가있는 경우에만 효과적으로 작동합니다. 많은 양의 데이터를 축적 할 것으로 예상되는 새 데이터베이스를 작성할 때 &quot;ANALYZE sqlite_master&quot;명령을 실행하여 SQLITE_STAT1 테이블을 작성한 후 SQLITE_STAT1 테이블 (일반 INSERT 문을 사용하여)을 사용자의 일반적인 데이터베이스를 설명하는 컨텐츠로 미리 채울 수 있습니다. 응용 프로그램-랩에서 잘 구성된 템플릿 데이터베이스에서 ANALYZE를 실행 한 후 추출한 콘텐츠 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d4796f0a34c568634b9634297a83ac77168e0e1" translate="yes" xml:space="preserve">
          <source>Of course, ANALYZE only works effectively if you have a significant amount of content in your database in the first place. When creating a new database that you expect to accumulate a lot of data, you can run the command &quot;ANALYZE sqlite_schema&quot; to create the SQLITE_STAT1 table, then prepopulate the SQLITE_STAT1 table (using ordinary INSERT statements) with content that describes a typical database for your application - perhaps content that you extracted after running ANALYZE on a well-populated template database in the lab.</source>
          <target state="translated">물론 ANALYZE는 처음에 데이터베이스에 많은 양의 콘텐츠가있는 경우에만 효과적으로 작동합니다. 많은 데이터를 축적 할 것으로 예상되는 새 데이터베이스를 만들 때 &quot;ANALYZE sqlite_schema&quot;명령을 실행하여 SQLITE_STAT1 테이블을 만든 다음 일반 INSERT 문을 사용하여 SQLITE_STAT1 테이블을 일반 데이터베이스를 설명하는 콘텐츠로 미리 채울 수 있습니다. 응용 프로그램-랩에서 잘 채워진 템플릿 데이터베이스에서 ANALYZE를 실행 한 후 추출한 콘텐츠 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79c23fc170f4a6f6a03298037f6a0ed97740fe0f" translate="yes" xml:space="preserve">
          <source>Of course, an error may occur while attempting any of the 4 steps enumerated above. If this happens, then the</source>
          <target state="translated">물론 위에 열거 된 4 단계 중 하나를 시도하는 동안 오류가 발생할 수 있습니다. 이런 일이 발생하면</target>
        </trans-unit>
        <trans-unit id="4144a21a0e5e7b5ef89db325c2463b409501b64d" translate="yes" xml:space="preserve">
          <source>Of course, an ordinary SQLite table will also do a query against its integer primary key efficiently, so the previous is no big deal. The real reason for using an R*Tree is so that you can efficiently do inequality queries against the coordinate ranges. To find all elements of the index that are contained within the vicinity of Charlotte, North Carolina, one might do:</source>
          <target state="translated">물론 일반적인 SQLite 테이블은 정수 기본 키에 대해 효율적으로 쿼리를 수행하므로 이전은 중요하지 않습니다. R * Tree를 사용하는 실제 이유는 좌표 범위에 대해 불평등 쿼리를 효율적으로 수행 할 수 있기 때문입니다. 노스 캐롤라이나 주 샬럿 부근에 포함 된 지수의 모든 요소를 ​​찾으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ad9000f84241cbe168fcf9edea5a309a2f41cf64" translate="yes" xml:space="preserve">
          <source>Of course, it is also possible that it does exist following system recovery.</source>
          <target state="translated">물론, 시스템 복구 후에 존재할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a79fe7e88cf76ed8c1ab2e6617de9596ed474d8" translate="yes" xml:space="preserve">
          <source>Of course, it is usually not possible to atomically apply all the changes required by a</source>
          <target state="translated">물론 일반적으로 필요한 모든 변경 사항을 원자 적으로 적용하는 것은 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="03e6ead3b1dad229ee29b568087a8cd4aada1c2d" translate="yes" xml:space="preserve">
          <source>Of course, not every language fits neatly into one of the above catagories. This applies to both SQL database engines and more familiar imperative programming languages. Javascript is famous for using a hybrid execution model, where the code is initially compiled into a tree of objects, but might be further translating (using just-in-time compilation) down into more efficient bytecode or machine code, as a means of boosting performance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8a4fe5b2fe5db1f855a348ab89c3de5aa545089" translate="yes" xml:space="preserve">
          <source>Of course, one wants to eventually transfer all the transactions that are appended in the WAL file back into the original database. Moving the WAL file transactions back into the database is called a &quot;</source>
          <target state="translated">물론 WAL 파일에 추가 된 모든 트랜잭션을 원래 데이터베이스로 다시 전송하려고합니다. WAL 파일 트랜잭션을 데이터베이스로 다시 이동하는 것을 &quot;</target>
        </trans-unit>
        <trans-unit id="a8d7cb464eb0b5300b1a2a71635654f684270965" translate="yes" xml:space="preserve">
          <source>Of course, ordering the output of a query by rowid is seldom useful. Usually one wants to order the output by some other column.</source>
          <target state="translated">물론 rowid로 쿼리 출력을 정렬하는 것은 거의 유용하지 않습니다. 일반적으로 다른 열로 출력을 정렬하려고합니다.</target>
        </trans-unit>
        <trans-unit id="178df5e8851c3ac34f7dcea098e85da7dbfe235b" translate="yes" xml:space="preserve">
          <source>Of course, substitute the desired index and imposter table names in place of the &quot;t1bc&quot; and &quot;t2&quot; shown in the example. The &quot;.imposter&quot; command reads the schema of the &quot;t1bc&quot; index, uses that information to construct a compatible CREATE TABLE statement for the imposter table, then makes all the necessary calls to create the transient imposter table automatically.</source>
          <target state="translated">물론 예제에 표시된 &quot;t1bc&quot;및 &quot;t2&quot;대신 원하는 인덱스 및 임 포스터 테이블 이름을 대체하십시오. &quot;.imposter&quot;명령은 &quot;t1bc&quot;인덱스의 스키마를 읽고 해당 정보를 사용하여 임 포스터 테이블에 대해 호환 가능한 CREATE TABLE 문을 구성한 다음 임시 임 포스터 테이블을 자동으로 작성하는 데 필요한 모든 호출을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="116444cf2f220a0caf732f16ffb5a2f69fd9321c" translate="yes" xml:space="preserve">
          <source>Of course, the two queries above are not entirely equivalent. For example the LIKE query matches rows that contain terms such as &quot;linuxophobe&quot; or &quot;EnterpriseLinux&quot; (as it happens, the Enron E-Mail Dataset does not actually contain any such terms), whereas the MATCH query on the FTS3 table selects only those rows that contain &quot;linux&quot; as a discrete token. Both searches are case-insensitive. The FTS3 table consumes around 2006 MB on disk compared to just 1453 MB for the ordinary table. Using the same hardware configuration used to perform the SELECT queries above, the FTS3 table took just under 31 minutes to populate, versus 25 for the ordinary table.</source>
          <target state="translated">물론 위의 두 쿼리는 완전히 동일하지 않습니다. 예를 들어 LIKE 쿼리는 &quot;linuxophobe&quot;또는 &quot;EnterpriseLinux&quot;와 같은 용어가 포함 된 행과 일치하지만 (Enron 전자 메일 데이터 세트에는 실제로 그러한 용어가 포함되지 않음) FTS3 테이블의 MATCH 쿼리는 해당 용어 만 선택합니다. &quot;linux&quot;를 개별 토큰으로 포함하는 행. 두 검색은 대소 문자를 구분하지 않습니다. FTS3 테이블은 일반 테이블의 경우 1453MB에 비해 디스크에서 약 2006MB를 사용합니다. 위의 SELECT 쿼리를 수행하는 데 사용 된 것과 동일한 하드웨어 구성을 사용하여 FTS3 테이블을 채우는 데 31 분이 채 걸리지 않았습니다 (일반 테이블의 경우 25 분).</target>
        </trans-unit>
        <trans-unit id="68b0ebb94fca52bc2076d132ead5c0f0cef17ce0" translate="yes" xml:space="preserve">
          <source>Of course, users would prefer code that is both robust in normal use and resistant to malicious attack. The SQLite developers are dedicated to providing that. The purpose of this section is merely to point out that doing both at the same time is hard.</source>
          <target state="translated">물론 사용자는 정상적인 사용시 강력하고 악의적 인 공격에 강한 코드를 선호합니다. SQLite 개발자는이를 제공하는 데 전념하고 있습니다. 이 섹션의 목적은 두 가지를 동시에 수행하는 것이 어렵다는 점을 지적하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6778acfecc08483f487870a27c4e0b19bb8701d" translate="yes" xml:space="preserve">
          <source>Of course, your mileage may vary depending on hardware, filesystem, and operating system. Double-check these figures on target hardware before committing to a particular design.</source>
          <target state="translated">물론, 마일리지는 하드웨어, 파일 시스템 및 운영 체제에 따라 다를 수 있습니다. 특정 설계를 수행하기 전에 대상 하드웨어에서이 수치를 다시 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="315230e941921effe51cc9ebfa05403b855f0476" translate="yes" xml:space="preserve">
          <source>Of these changes, only 1a and 2a through 2c are incompatibilities in any formal sense. But users who have previously made custom modifications to the SQLite source (for example to add a custom OS layer for embedded hardware) might find that these changes have a larger impact. On the other hand, an important goal of these changes is to make it much easier to customize SQLite for use on different operating systems.</source>
          <target state="translated">이러한 변경 중 1a 및 2a-2c 만 공식적인 의미에서 비 호환성입니다. 그러나 이전에 SQLite 소스를 사용자 지정하여 수정 한 사용자 (예 : 임베디드 하드웨어에 대한 사용자 지정 OS 계층 추가)는 이러한 변경이 더 큰 영향을 줄 수 있습니다. 한편, 이러한 변경의 중요한 목표는 다른 운영 체제에서 사용하기 위해 SQLite를 훨씬 쉽게 사용자 정의 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e3de5ab0ca4c69dbf00e86d2558843e8d806bb49" translate="yes" xml:space="preserve">
          <source>Off</source>
          <target state="translated">Off</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="58190317f4f075103c701ab1719a5146c7d71c8f" translate="yes" xml:space="preserve">
          <source>OffsetLimit</source>
          <target state="translated">OffsetLimit</target>
        </trans-unit>
        <trans-unit id="1ab3ac50fee719ce4797840a2df9f8c5ee707c03" translate="yes" xml:space="preserve">
          <source>Older versions of SQLite could not read a WAL-mode database that was read-only. In other words, write access was required in order to read a WAL-mode database. This constraint was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;version 3.22.0&lt;/a&gt; (2018-01-22).</source>
          <target state="translated">이전 버전의 SQLite는 읽기 전용 인 WAL 모드 데이터베이스를 읽을 수 없습니다. 즉, WAL 모드 데이터베이스를 읽으려면 쓰기 액세스가 필요했습니다. 이 제약은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_22_0.html&quot;&gt;버전 3.22.0&lt;/a&gt; (2018-01-22) 부터 완화되었습니다 .</target>
        </trans-unit>
        <trans-unit id="28b3eeca1402aeadaf4db2bf8f6d2403ee957bf0" translate="yes" xml:space="preserve">
          <source>Older versions of firebird omits all NULLs from SELECT DISTINCT and from UNION.</source>
          <target state="translated">이전 버전의 파이어 버드는 SELECT DISTINCT 및 UNION에서 모든 NULL을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="8bfe5e60a5daf11fac21979e5a4fa9643a76bc3b" translate="yes" xml:space="preserve">
          <source>Omit all use of &quot;awk&quot; in the makefiles, to make building easier for MSVC users.</source>
          <target state="translated">MSVC 사용자가 쉽게 빌드 할 수 있도록 makefile에서 &quot;awk&quot;를 모두 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="bf4d0857bd27f59258be5d9b1e12776a9ff94992" translate="yes" xml:space="preserve">
          <source>Omitted parameters take on default values. STEP defaults to 1. END defaults to 9223372036854775807. START defaults to 0.</source>
          <target state="translated">생략 된 매개 변수는 기본값을 사용합니다. STEP의 기본값은 1입니다. END의 기본값은 9223372036854775807입니다. START의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="e0049a66519cae71159800bb77a35007bc2d76d3" translate="yes" xml:space="preserve">
          <source>On</source>
          <target state="translated">On</target>
        </trans-unit>
        <trans-unit id="0e46092ad025ac57fb1677f1d311680029cda2c1" translate="yes" xml:space="preserve">
          <source>On Android, we are told, there are many services that will blindly run arbitrary SQL that is passed to them by untrustworthy apps that have been downloaded from dodgy corners of the internet. Android services are suppose to be more guarded about running SQL from unvetted sources. This author does not have any specific examples to the contrary, but he has heard rumors that they exist. Even if all Android services are more careful and properly vet all the SQL they run, it would be difficult to audit them all in order to verify that they are safe. Hence, security-minded people are keen to ensure that no exploits are possible by passing arbitrary SQL text.</source>
          <target state="translated">안드로이드에는 인터넷의 복잡한 구석에서 다운로드 한 신뢰할 수없는 앱에 의해 전달되는 임의의 SQL을 맹목적으로 실행하는 많은 서비스가 있다고 들었습니다. 안드로이드 서비스는 검증되지 않은 소스에서 SQL을 실행하는 것에 대해 더욱 조심해야합니다. 이 저자는 그와 반대되는 구체적인 사례는 없지만, 존재한다는 소문을 들었습니다. 모든 Android 서비스가 더 조심스럽고 실행중인 모든 SQL을 제대로 검사하더라도 안전한지 확인하기 위해 모두 감사하는 것은 어려울 것입니다. 따라서 보안을 염두에 둔 사람들은 임의의 SQL 텍스트를 전달하여 악용 할 수 없도록주의를 기울입니다.</target>
        </trans-unit>
        <trans-unit id="26c3af907230190631617dbb8e5acb92e9854301" translate="yes" xml:space="preserve">
          <source>On Linux and other unix systems you will need to enter something like:</source>
          <target state="translated">Linux 및 기타 유닉스 시스템에서는 다음과 같이 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="1273deeaf4de08300113723f337bae0ec716c243" translate="yes" xml:space="preserve">
          <source>On Win32, do not return an error when attempting to delete a file that does not exist.</source>
          <target state="translated">Win32에서는 존재하지 않는 파일을 삭제하려고 할 때 오류를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b2b2f36a4fafa25d031c2e6870c72d35c487959e" translate="yes" xml:space="preserve">
          <source>On Windows systems, folders are searched in the following order:</source>
          <target state="translated">Windows 시스템에서 폴더는 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="9d83a99bbbc3869a446954149b390c5195af03a3" translate="yes" xml:space="preserve">
          <source>On Windows with MSVC, use nmake with the Makefile.msc:</source>
          <target state="translated">MSVC가있는 Windows의 경우 Makefile.msc와 함께 nmake를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e51bd18dd2b65a7e346c37ac44c1031b3f3942d7" translate="yes" xml:space="preserve">
          <source>On Windows, enter:</source>
          <target state="translated">Windows에서 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="aacb79e6ea038d7e3cda09880e0781239b1e3933" translate="yes" xml:space="preserve">
          <source>On a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;, the WAL is first flushed to persistent storage using the xSync method of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS&lt;/a&gt;. Then valid content of the WAL is transferred into the database file. Finally, the database is flushed to persistent storage using another xSync method call. The xSync operations serve as write barriers - all writes launched before the xSync must complete before any write that launches after the xSync begins.</source>
          <target state="translated">(A)에 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 의 WAL 먼저의 xSync 방법하여 영구 저장소에 플러시 &lt;a href=&quot;c3ref/io_methods&quot;&gt;VFS를&lt;/a&gt; . 그런 다음 WAL의 유효한 내용이 데이터베이스 파일로 전송됩니다. 마지막으로 데이터베이스는 다른 xSync 메서드 호출을 사용하여 영구 저장소로 플러시됩니다. xSync 작업은 쓰기 장벽 역할을합니다. xSync가 시작된 후 쓰기가 시작되기 전에 xSync가 시작되기 전에 시작된 모든 쓰기가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="ea7fd316bd0a1ed7abbfd63a2c9be9dcb14966c5" translate="yes" xml:space="preserve">
          <source>On a DISTINCT query that uses an index, try to skip ahead to the next distinct entry using the index rather than stepping through rows, when an appropriate index is available.</source>
          <target state="translated">인덱스를 사용하는 DISTINCT 쿼리에서 적절한 인덱스를 사용할 수있는 경우 행을 단계별로 실행하지 않고 인덱스를 사용하여 다음 고유 항목으로 건너 뛰십시오.</target>
        </trans-unit>
        <trans-unit id="439b4340c2826997b9311dbcdfa182caed0bc968" translate="yes" xml:space="preserve">
          <source>On a traditional spinning disk, a sector is the minimum unit of transfer in both directions, both reading and writing. On flash memory, however, the minimum size of a read is typically much smaller than a minimum write. SQLite is only concerned with the minimum write amount and so for the purposes of this article, when we say &quot;sector&quot; we mean the minimum amount of data that can be written to mass storage in a single go.</source>
          <target state="translated">기존의 회전 디스크에서 섹터는 읽기와 쓰기 모두 양방향의 최소 전송 단위입니다. 그러나 플래시 메모리에서 읽기의 최소 크기는 일반적으로 최소 쓰기보다 훨씬 작습니다. SQLite는 최소 쓰기 양에만 관심이 있으므로이 기사에서는 &quot;섹터&quot;라고 할 때 대용량 저장소에 한 번에 쓸 수있는 최소 데이터 양을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4d25766d7605da89f0dc45ce4758796da7aaedb1" translate="yes" xml:space="preserve">
          <source>On an &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, if the ROWID or INTEGER PRIMARY KEY column is not explicitly given a value, then it will be filled automatically with an unused integer, usually one more than the largest ROWID currently in use. This is true regardless of whether or not the AUTOINCREMENT keyword is used.</source>
          <target state="translated">온 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; ROWID를 또는 INTEGER PRIMARY KEY 열이 명시 적으로 값을 지정하지 않은 경우, 다음은 일반적으로 한 번 더 현재 사용에서 가장 큰 ROWID보다, 사용되지 않는 정수 자동으로 채워집니다. AUTOINCREMENT 키워드 사용 여부에 관계없이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ebef8439735d14eb6033471fd2e7d318b20febc6" translate="yes" xml:space="preserve">
          <source>On an UPSERT when the order of constraint checks is rearranged, ensure that the affinity transformations on the inserted content occur before any of the constraint checks. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e&lt;/a&gt;.</source>
          <target state="translated">제한 조건 점검 순서가 재 배열 될 때 UPSERT에서, 제한 조건 점검 전에 삽입 된 컨텐츠에 대한 선호도 변환이 발생하는지 확인하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/79cad5e4b2e219dd197242e9e&quot;&gt;79cad5e4b2e219dd197242e9e에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="0a7e67fba14e6027ea80edde2148e2473e22f15f" translate="yes" xml:space="preserve">
          <source>On each call to undo::undo or undo::redo, the undo/redo module automatically invokes methods status_refresh and reload_all in all toplevel namespaces. These methods should be defined to reconstruct the display or otherwise update the state of the program based on the undone/redone changes to the database.</source>
          <target state="translated">undo :: undo 또는 undo :: redo를 호출 할 때마다 undo / redo 모듈은 모든 최상위 네임 스페이스에서 status_refresh 및 reload_all 메소드를 자동으로 호출합니다. 이러한 메소드는 데이터베이스의 실행 취소 / 다시 실행 변경에 따라 표시를 재구성하거나 프로그램 상태를 업데이트하도록 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="51efe73d5459fecda0ebf237f9f8f384ca5daf31" translate="yes" xml:space="preserve">
          <source>On embedded systems with synchronous filesystems, TRUNCATE results in slower behavior than PERSIST. The commit operation is the same speed. But subsequent transactions are slower following a TRUNCATE because it is faster to overwrite existing content than to append to the end of a file. New journal file entries will always be appended following a TRUNCATE but will usually overwrite with PERSIST.</source>
          <target state="translated">동기 파일 시스템이있는 임베디드 시스템에서 TRUNCATE는 PERSIST보다 동작이 느립니다. 커밋 작업은 동일한 속도입니다. 그러나 후속 트랜잭션은 파일 끝에 추가하는 것보다 기존 내용을 덮어 쓰는 것이 더 빠르기 때문에 TRUNCATE 이후에 더 느립니다. 새 저널 파일 항목은 항상 TRUNCATE 뒤에 추가되지만 일반적으로 PERSIST로 겹쳐 씁니다.</target>
        </trans-unit>
        <trans-unit id="cff1aa0bee9c89492d085449129eae77e72bb5fa" translate="yes" xml:space="preserve">
          <source>On most systems, the malloc() system call returns a buffer that is aligned to an 8-byte boundary. But on some systems (ex: windows) malloc() returns 4-byte aligned pointer. This compile-time option must be used on systems that return 4-byte aligned pointers from malloc().</source>
          <target state="translated">대부분의 시스템에서 malloc () 시스템 호출은 8 바이트 경계에 정렬 된 버퍼를 리턴합니다. 그러나 일부 시스템 (예 : windows)에서 malloc ()은 4 바이트 정렬 포인터를 반환합니다. 이 컴파일 타임 옵션은 malloc ()에서 4 바이트 정렬 포인터를 리턴하는 시스템에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="87f5be0e7a33503458f9f1fc5e662122708d06fc" translate="yes" xml:space="preserve">
          <source>On newer versions of SQLite, a WAL-mode database on read-only media, or a WAL-mode database that lacks write permission, can still be read as long as one or more of the following conditions are met:</source>
          <target state="translated">최신 버전의 SQLite에서는 다음 조건 중 하나 이상이 충족되는 한 읽기 전용 미디어의 WAL 모드 데이터베이스 또는 쓰기 권한이없는 WAL 모드 데이터베이스를 계속 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3b32dd2c0c0446522505f738b73e43600ba9ad" translate="yes" xml:space="preserve">
          <source>On startup, the &lt;b&gt;sqlite3&lt;/b&gt; program will show a brief banner message then prompt you to enter SQL. Type in SQL statements (terminated by a semicolon), press &quot;Enter&quot; and the SQL will be executed.</source>
          <target state="translated">시작시 &lt;b&gt;sqlite3&lt;/b&gt; 프로그램에 간단한 배너 메시지가 표시되고 SQL을 입력하라는 메시지가 표시됩니다. 세미콜론으로 끝나는 SQL 문을 입력하고 &quot;Enter&quot;를 누르면 SQL이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a6133c9cbc7fd01002e1fd8f131c7ef4a48f7b82" translate="yes" xml:space="preserve">
          <source>On startup, the application first decides which version it wants to display. Since the versionId will naturally increase in time and one would normally want to see the latest version, an appropriate query might be:</source>
          <target state="translated">시작시 응용 프로그램은 먼저 표시 할 버전을 결정합니다. versionId는 자연스럽게 시간이 증가하고 일반적으로 최신 버전을보고 싶어하므로 적절한 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d2a06dc722811f829dbda8827b08f5f0b5f36ae8" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">성공하면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴되고 새 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 이 * ppBlob에 저장됩니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴되고 오류 코드가 SQLITE_MISUSE가 아닌 경우 * ppBlob은 NULL로 설정됩니다. 즉, API를 잘못 사용하지 않으면 이 함수가 반환 된 후 * ppBlob에서 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 를 호출하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="749e0ca8bebcf0ea981a3b5d51013a9a74a29d29" translate="yes" xml:space="preserve">
          <source>On success, &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; is returned and the new &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; is stored in *ppBlob. Otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned and, unless the error code is SQLITE_MISUSE, *ppBlob is set to NULL. This means that, provided the API is not misused, it is always safe to call &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt; on *ppBlob after this function it returns.</source>
          <target state="translated">성공하면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 가 리턴되고 새 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 이 * ppBlob에 저장됩니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 리턴되고 오류 코드가 SQLITE_MISUSE가 아닌 경우 * ppBlob은 NULL로 설정됩니다. 즉, API를 잘못 사용하지 않으면 이 함수가 반환 된 후 * ppBlob에서 &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close ()&lt;/a&gt; 를 호출하는 것이 항상 안전 합니다.</target>
        </trans-unit>
        <trans-unit id="65eaebdd334ea618570d91e4458e0eb1b208375f" translate="yes" xml:space="preserve">
          <source>On success, &lt;b&gt;sqlite_compile&lt;/b&gt; returns SQLITE_OK. Otherwise and error code is returned.</source>
          <target state="translated">성공하면 &lt;b&gt;sqlite_compile&lt;/b&gt; 은 SQLITE_OK를 반환합니다. 그렇지 않으면 오류 코드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e9b1d8e369d082b964c508c283e64eea1e0560c" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_blob_read ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e81bdc76837634caa6cec9a7812e38a822384af4" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_read() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_blob_read ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="00223380eeb8684c87e10d42630c25143e83fb7d" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">성공하면 sqlite3_blob_write ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다. SQLITE_MISUSE가 리턴되지 않으면이 함수는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 를 통해 액세스 가능한 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오류 코드 및 메시지를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="e1d8319a0f054e12945ffdcd496271dbacaf81a2" translate="yes" xml:space="preserve">
          <source>On success, sqlite3_blob_write() returns SQLITE_OK. Otherwise, an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; or an &lt;a href=&quot;rescode#extrc&quot;&gt;extended error code&lt;/a&gt; is returned. Unless SQLITE_MISUSE is returned, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">성공하면 sqlite3_blob_write ()는 SQLITE_OK를 반환합니다. 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 가 반환됩니다. SQLITE_MISUSE가 리턴되지 않으면이 함수는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 를 통해 액세스 가능한 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오류 코드 및 메시지를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8609e89a9e3f181cc9bf01d1a6238ab2d0959ed4" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_prepare () 루틴 제품군은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다 . 그렇지 않으면 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e16251e40927c67fe655d2518e028082c6fa9b3" translate="yes" xml:space="preserve">
          <source>On success, the sqlite3_prepare() family of routines return &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;; otherwise an &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt; is returned.</source>
          <target state="translated">성공하면 sqlite3_prepare () 루틴 제품군은 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 합니다 . 그렇지 않으면 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79e4255a03a365ba20cd0884b8ee349e3d935179" translate="yes" xml:space="preserve">
          <source>On the Mac, you can set this pragma:</source>
          <target state="translated">Mac에서이 pragma를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69a450284be9205b76c2e066c35f545c5c025beb" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able control database access with more precision, allowing for finer grain locking and better concurrency.</source>
          <target state="translated">반면에 서버를 사용하는 데이터베이스 엔진은 클라이언트 응용 프로그램의 버그로부터 더 나은 보호 기능을 제공 할 수 있습니다. 클라이언트의 스트레이 포인터는 서버의 메모리를 손상시킬 수 없습니다. 또한 서버는 단일 영구 프로세스이므로보다 정밀하게 데이터베이스 액세스를 제어 할 수 있으므로보다 세밀한 잠금 및 동시성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="84736c128a35123ea022380e6a3900484bf1a802" translate="yes" xml:space="preserve">
          <source>On the other hand, a database engine that uses a server can provide better protection from bugs in the client application - stray pointers in a client cannot corrupt memory on the server. And because a server is a single persistent process, it is able to control database access with more precision, allowing for finer-grained locking and better concurrency.</source>
          <target state="translated">반면에 서버를 사용하는 데이터베이스 엔진은 클라이언트 응용 프로그램의 버그로부터 더 나은 보호 기능을 제공 할 수 있습니다. 클라이언트의 스트레이 포인터는 서버의 메모리를 손상시킬 수 없습니다. 또한 서버는 단일 영구 프로세스이기 때문에 데이터베이스 액세스를보다 정밀하게 제어 할 수 있으므로 세밀한 잠금과 동시성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="71cbc82c664fd1caf1a677d0c65b18293805a90f" translate="yes" xml:space="preserve">
          <source>On the other hand, an RBU Vacuum uses more CPU than a regular SQLite VACUUM - in one test as much as five times as much. For this reason, an RBU Vacuum is often significantly slower than an SQLite VACUUM under the same conditions.</source>
          <target state="translated">반면에 RBU Vacuum은 일반 SQLite VACUUM보다 많은 CPU를 사용합니다. 한 번의 테스트에서 최대 5 배나 많은 양입니다. 이러한 이유로 RBU 진공은 종종 동일한 조건에서 SQLite VACUUM보다 상당히 느립니다.</target>
        </trans-unit>
        <trans-unit id="2ec9b50cf6f067a94359ec578926c021dba81fa8" translate="yes" xml:space="preserve">
          <source>On the other hand, dropping tables is not a very common operation so if SQLite takes a little longer, that is not seen as a big problem.</source>
          <target state="translated">반면에 테이블을 삭제하는 것은 일반적인 작업이 아니므로 SQLite가 조금 더 오래 걸리더라도 큰 문제는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b75edbc4ccb51b3a0effc26ec943821968d21e88" translate="yes" xml:space="preserve">
          <source>On the other hand, if the result of the subquery must be scanned multiple times (because, for example, it is just one table in a join) then it is better to use a transient table to remember the entire result of the subquery, in order to avoid computing the subquery more than once.</source>
          <target state="translated">반면에 하위 쿼리의 결과를 여러 번 스캔해야하는 경우 (예를 들어, 조인에서 하나의 테이블 일 뿐이므로) 임시 쿼리를 사용하여 하위 쿼리의 전체 결과를 기억하는 것이 좋습니다. 하위 쿼리를 두 번 이상 계산하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="4cb26bb6bd2845585001f514df8ac5e23d3a9784" translate="yes" xml:space="preserve">
          <source>On the other hand, read performance deteriorates as the WAL file grows in size since each reader must check the WAL file for the content and the time needed to check the WAL file is proportional to the size of the WAL file. The wal-index helps find content in the WAL file much faster, but performance still falls off with increasing WAL file size. Hence, to maintain good read performance it is important to keep the WAL file size down by running checkpoints at regular intervals.</source>
          <target state="translated">반면, 각 판독기는 WAL 파일의 내용을 확인해야하고 WAL 파일을 확인하는 데 필요한 시간이 WAL 파일의 크기에 비례하기 때문에 WAL 파일의 크기가 커지면 읽기 성능이 저하됩니다. wal-index는 WAL 파일의 내용을 훨씬 빠르게 찾을 수 있도록 도와 주지만 WAL 파일 크기가 커지면 성능이 저하됩니다. 따라서 좋은 읽기 성능을 유지하려면 정기적으로 검사 점을 실행하여 WAL 파일 크기를 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="9a0c49cb1cedb27f90f5b843b5321b6c2675c041" translate="yes" xml:space="preserve">
          <source>On the stack display, most entries are shown with a prefix that tells the datatype of that stack entry. Integers begin with &quot;&lt;code&gt;i:&lt;/code&gt;&quot;. Floating point values begin with &quot;&lt;code&gt;r:&lt;/code&gt;&quot;. (The &quot;r&quot; stands for &quot;real-number&quot;.) Strings begin with either &quot;&lt;code&gt;s:&lt;/code&gt;&quot;, &quot;&lt;code&gt;t:&lt;/code&gt;&quot;, &quot;&lt;code&gt;e:&lt;/code&gt;&quot; or &quot;&lt;code&gt;z:&lt;/code&gt;&quot;. The difference among the string prefixes is caused by how their memory is allocated. The z: strings are stored in memory obtained from &lt;b&gt;malloc()&lt;/b&gt;. The t: strings are statically allocated. The e: strings are ephemeral. All other strings have the s: prefix. This doesn't make any difference to you, the observer, but it is vitally important to the VDBE since the z: strings need to be passed to &lt;b&gt;free()&lt;/b&gt; when they are popped to avoid a memory leak. Note that only the first 10 characters of string values are displayed and that binary values (such as the result of the MakeRecord instruction) are treated as strings. The only other datatype that can be stored on the VDBE stack is a NULL, which is display without prefix as simply &quot;&lt;code&gt;NULL&lt;/code&gt;&quot;. If an integer has been placed on the stack as both an integer and a string, its prefix is &quot;&lt;code&gt;si:&lt;/code&gt;&quot;.</source>
          <target state="translated">스택 디스플레이에서 대부분의 항목은 해당 스택 항목의 데이터 유형을 알려주는 접두사와 함께 표시됩니다. 정수는 &quot; &lt;code&gt;i:&lt;/code&gt; &quot;로 시작합니다 . 부동 소수점 값은 &quot; &lt;code&gt;r:&lt;/code&gt; &quot;로 시작합니다 . &quot;r&quot;은 &quot;실수&quot;를 나타냅니다. 문자열은 &quot; &lt;code&gt;s:&lt;/code&gt; &quot;, &quot; &lt;code&gt;t:&lt;/code&gt; &quot;, &quot; &lt;code&gt;e:&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;z:&lt;/code&gt; &quot;로 시작합니다. 문자열 접두사 간의 차이점은 메모리 할당 방법에 따라 발생합니다. z : 문자열은 &lt;b&gt;malloc ()&lt;/b&gt; 에서 얻은 메모리에 저장됩니다 . t : 문자열은 정적으로 할당됩니다. e : 문자열은 일시적입니다. 다른 모든 문자열에는 s : 접두사가 있습니다. 이것은 관찰자, 당신에게 아무런 영향을 미치지 않습니다z : 문자열을 전달해야하므로 VDBE에 매우 중요합니다.&lt;b&gt;&lt;/b&gt;메모리 누수를 피하기 위해 튀어 나오면 &lt;b&gt;free ()&lt;/b&gt; . 문자열 값의 처음 10 자만 표시되고 이진 값 (예 : MakeRecord 명령의 결과)은 문자열로 처리됩니다. VDBE 스택에 저장할 수있는 유일한 다른 데이터 형식은 NULL이며 접두사없이 단순히 &quot; &lt;code&gt;NULL&lt;/code&gt; &quot; 로 표시 됩니다 . 정수가 정수와 문자열로 스택에 배치 된 경우 접두어는 &quot; &lt;code&gt;si:&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e3336bd71adcf37ccf53527f3a1cc4855eac8894" translate="yes" xml:space="preserve">
          <source>On unix systems (or on Windows using cygwin or mingw+msys) the command typically looks something like this:</source>
          <target state="translated">유닉스 시스템 (또는 cygwin 또는 mingw + msys를 사용하는 Windows)에서 명령은 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="287d1cbba1056569ceaf042e45ed9558181651a7" translate="yes" xml:space="preserve">
          <source>On unix, if a symlink to a database file is opened, then the corresponding journal files are based on the actual filename, not the symlink name.</source>
          <target state="translated">유닉스에서 데이터베이스 파일에 대한 심볼릭 링크가 열리면 해당 저널 파일은 심볼릭 링크 이름이 아닌 실제 파일 이름을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="6c70d0e29a89e83eef274cc81c5528ba689d997c" translate="yes" xml:space="preserve">
          <source>On unix-like systems, directories are searched in the following order:</source>
          <target state="translated">유닉스 계열 시스템에서 디렉토리는 다음 순서로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="db7db60b91e81d2d39614db0d3144dc3caa85aa5" translate="yes" xml:space="preserve">
          <source>On windows only, convert all &quot;&lt;code&gt;\&lt;/code&gt;&quot; characters into &quot;&lt;code&gt;/&lt;/code&gt;&quot;.</source>
          <target state="translated">Windows에서만 모든 &quot; &lt;code&gt;\&lt;/code&gt; &quot;문자를 &quot; &lt;code&gt;/&lt;/code&gt; &quot; 로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa996bed689bb081c327fe76624367885c13654f" translate="yes" xml:space="preserve">
          <source>On windows only, if the filename begins with a drive letter, prepend a single &quot;&lt;code&gt;/&lt;/code&gt;&quot; character.</source>
          <target state="translated">Windows에서만 파일 이름이 드라이브 문자로 시작하는 경우 단일 &quot; &lt;code&gt;/&lt;/code&gt; &quot;문자 앞에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9c768782ea8653d485fb3b7f5aba21cb2ca7bf3" translate="yes" xml:space="preserve">
          <source>Once</source>
          <target state="translated">Once</target>
        </trans-unit>
        <trans-unit id="87f26aaf5f6994f877b899775d955216fa5722f5" translate="yes" xml:space="preserve">
          <source>Once a</source>
          <target state="translated">한 번</target>
        </trans-unit>
        <trans-unit id="8464198c181050b3c7b7af3b57436c91d71a13de" translate="yes" xml:space="preserve">
          <source>Once a VFS has been registered, it should never be modified. If a change in behavior is required, a new VFS should be registered. The application could, perhaps, use &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; to locate the old VFS, make a copy of the old VFS into a new &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object, make the desired modifications to the new VFS, unregister the old VFS, then register the new VFS in its place. Existing database connections would continue to use the old VFS even after it is unregistered, but new database connections would use the new VFS.</source>
          <target state="translated">VFS가 등록되면 절대 수정해서는 안됩니다. 동작 변경이 필요한 경우 새 VFS를 등록해야합니다. 응용 프로그램은 아마도 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 를 사용 하여 이전 VFS를 찾고, 이전 VFS를 새로운 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 로 복사 하고, 새로운 VFS를 원하는대로 수정하고, 기존 VFS를 등록 취소 한 다음, 새로운 VFS를 등록 할 수 있습니다. 장소. 기존 데이터베이스 연결은 등록을 해제 한 후에도 이전 VFS를 계속 사용하지만 새 데이터베이스 연결은 새 VFS를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55b2eace4f6d572184649196769be324d9ec08aa" translate="yes" xml:space="preserve">
          <source>Once a connection obtains a table lock, it is not released until the current transaction (read or write) is concluded.</source>
          <target state="translated">연결이 테이블 잠금을 확보하면 현재 트랜잭션 (읽기 또는 쓰기)이 완료 될 때까지 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5e4e9f1432dcf3c9b2a4412dec01ffd3ea3a631b" translate="yes" xml:space="preserve">
          <source>Once a process obtains an exclusive lock, it is permitted to write to the database file. It then proceeds to read the original content of pages out of the rollback journal and write that content back to where it came from in the database file. Recall that the header of the rollback journal records the original size of the database file prior to the start of the aborted transaction. SQLite uses this information to truncate the database file back to its original size in cases where the incomplete transaction caused the database to grow. At the end of this step, the database should be the same size and contain the same information as it did before the start of the aborted transaction.</source>
          <target state="translated">프로세스가 독점 잠금을 확보하면 데이터베이스 파일에 쓸 수 있습니다. 그런 다음 롤백 저널에서 페이지의 원래 컨텐츠를 읽고 해당 컨텐츠를 데이터베이스 파일의 원래 위치로 다시 씁니다. 롤백 저널의 헤더는 중단 된 트랜잭션이 시작되기 전에 데이터베이스 파일의 원래 크기를 기록합니다. SQLite는이 정보를 사용하여 불완전한 트랜잭션으로 인해 데이터베이스가 커지는 경우 데이터베이스 파일을 원래 크기로 다시 자릅니다. 이 단계의 끝에서 데이터베이스는 크기가 같아야하며 중단 된 트랜잭션이 시작되기 전과 동일한 정보를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="b42ea281b3fc7c07c016d5e3f2cf18291c599ca4" translate="yes" xml:space="preserve">
          <source>Once a table has been attached to a session object, the session object records the primary key values of all new rows inserted into the table. It also records the original primary key and other column values of any deleted or updated rows. For each unique primary key value, data is only recorded once - the first time a row with said primary key is inserted, updated or deleted in the lifetime of the session.</source>
          <target state="translated">테이블이 세션 개체에 연결되면 세션 개체는 테이블에 삽입 된 모든 새 행의 기본 키 값을 기록합니다. 또한 삭제되거나 업데이트 된 행의 원래 기본 키 및 기타 열 값을 기록합니다. 각각의 고유 한 기본 키 값에 대해 데이터는 한 번만 기록됩니다. 세션의 수명 동안 해당 기본 키가있는 행이 처음으로 삽입, 업데이트 또는 삭제 된 경우.</target>
        </trans-unit>
        <trans-unit id="9c0b7ad6ff995bbd9fed309a9d73615d47bfa0e5" translate="yes" xml:space="preserve">
          <source>Once a transaction has been opened, reading data from a database connection is a simple operation. Using the xRead() method of the file-handle open on the database file, the required database file pages are read one at a time. SQLite never reads partial pages and always uses a single call to xRead() for each required page.</source>
          <target state="translated">트랜잭션이 열리면 데이터베이스 연결에서 데이터를 읽는 것은 간단한 작업입니다. 데이터베이스 파일에서 열린 파일 핸들의 xRead () 메소드를 사용하여 필요한 데이터베이스 파일 페이지를 한 번에 하나씩 읽습니다. SQLite는 부분 페이지를 읽지 않으며 항상 필요한 각 페이지마다 xRead ()에 대한 단일 호출을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="511dc23c3f8ad619f86fc49e5ac60cacc5f4cbfc" translate="yes" xml:space="preserve">
          <source>Once a virtual table has been created, it can be used like any other table with the exceptions noted above and imposed by specific virtual table implementations. A virtual table is destroyed using the ordinary &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; syntax.</source>
          <target state="translated">가상 테이블이 작성되면 위에서 언급 한 특정 가상 테이블 구현에 의해 부과되는 예외를 제외하고 다른 테이블과 같이 사용할 수 있습니다. 가상 테이블은 일반적인 &lt;a href=&quot;lang_droptable&quot;&gt;DROP TABLE&lt;/a&gt; 구문을 사용하여 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="c3f695a7b377f8d655c6f7bd1deb78c481aa015e" translate="yes" xml:space="preserve">
          <source>Once again, practical implementations will likely subclass this structure to add additional private fields.</source>
          <target state="translated">다시 한 번, 실제 구현은이 구조를 서브 클래 싱하여 추가 개인 필드를 추가 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="44317a76e0c4f1b6b3d16db84fa92562885dc8a9" translate="yes" xml:space="preserve">
          <source>Once again, the SQL statements generate identical bytecode and thus do exactly the same job in exactly the same way. But the second form is made easier for humans to read by grouping the query parameters together into a single row value rather than scattering them across the WHERE clause.</source>
          <target state="translated">다시 한 번, SQL 문은 동일한 바이트 코드를 생성하므로 정확히 동일한 방식으로 동일한 작업을 수행합니다. 그러나 두 번째 형식은 쿼리 매개 변수를 WHERE 절 전체에 분산시키지 않고 단일 행 값으로 그룹화하여 사람이 쉽게 읽을 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="d645ca4d6b0e5bfa41d1d0e06bb9cd91ff636156" translate="yes" xml:space="preserve">
          <source>Once all rollback journal files have been flushed to disk, it is safe to begin updating database files. We have to obtain an exclusive lock on all database files before writing the changes. After all the changes are written, it is important to flush the changes to disk so that they will be preserved in the event of a power failure or operating system crash.</source>
          <target state="translated">모든 롤백 저널 파일이 디스크로 플러시되면 데이터베이스 파일 업데이트를 시작하는 것이 안전합니다. 변경 사항을 작성하기 전에 모든 데이터베이스 파일에 대한 독점 잠금을 얻어야합니다. 모든 변경 사항을 기록한 후에는 정전 또는 운영 체제 충돌시 변경 사항이 유지되도록 변경 사항을 디스크로 플러시해야합니다.</target>
        </trans-unit>
        <trans-unit id="73fcb528effe6301ec78591adf7629a8ed98b913" translate="yes" xml:space="preserve">
          <source>Once an SQLite database is open, it can be controlled using methods of the</source>
          <target state="translated">SQLite 데이터베이스가 열리면 데이터베이스의 메소드를 사용하여 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1676ac6920d27f0701cc052fe7ff5982a44cea9d" translate="yes" xml:space="preserve">
          <source>Once an encoding has been set for a database, it cannot be changed.</source>
          <target state="translated">데이터베이스에 대한 인코딩이 설정되면 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1f61d0c0dc743205cfd592b973902a4df3bd2139" translate="yes" xml:space="preserve">
          <source>Once an exclusive lock is held, we know that no other processes are reading from the database file and it is safe to write changes into the database file. Usually those changes only go as far as the operating systems disk cache and do not make it all the way to mass storage.</source>
          <target state="translated">배타적 잠금이 유지되면 데이터베이스 파일에서 다른 프로세스를 읽고 있지 않으므로 변경 내용을 데이터베이스 파일에 쓰는 것이 안전합니다. 일반적으로 이러한 변경 사항은 운영 체제 디스크 캐시까지만 적용되며 대용량 저장 장치를 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d6da848ac7743477288c842a221e398489c8a06" translate="yes" xml:space="preserve">
          <source>Once any conversions have taken place, and neither value is NULL, the values are compared. If both values are blobs then memcmp() is used to determine the results of the comparison. If both values are text, then the appropriate collating function specified in P4 is used to do the comparison. If P4 is not specified then memcmp() is used to compare text string. If both values are numeric, then a numeric comparison is used. If the two values are of different types, then numbers are considered less than strings and strings are considered less than blobs.</source>
          <target state="translated">변환이 수행되고 값이 NULL이 아닌 경우 값이 비교됩니다. 두 값이 모두 얼룩이면 memcmp ()를 사용하여 비교 결과를 결정합니다. 두 값이 모두 텍스트 인 경우 P4에 지정된 적절한 조합 기능을 사용하여 비교합니다. P4를 지정하지 않으면 memcmp ()를 사용하여 텍스트 문자열을 비교합니다. 두 값이 모두 숫자이면 숫자 비교가 사용됩니다. 두 값의 유형이 다른 경우 숫자는 문자열보다 작은 것으로 간주되고 문자열은 얼룩보다 작은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4b170c45b3f098d917697616ac86ca3f213bd255" translate="yes" xml:space="preserve">
          <source>Once everything is ready, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check in the changes. This creates circle (4) in the diagram above.</source>
          <target state="translated">모든 준비가 완료되면 &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;명령을 실행하여 변경 사항을 체크인하십시오. 위의 다이어그램에서 원 (4)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="89efbd20c0a9cf3f9851965660941121b8a57cbc" translate="yes" xml:space="preserve">
          <source>Once one is comfortable with the concept of storing each slide separately, it is a small step to support versioning of the presentation. Consider the following schema:</source>
          <target state="translated">각 슬라이드를 개별적으로 저장한다는 개념에 익숙해지면 프레젠테이션 버전 관리를 지원하는 작은 단계입니다. 다음 스키마를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="05be8dd08c1c90f1df285706af044dc836d0d98a" translate="yes" xml:space="preserve">
          <source>Once populated, there are three ways to execute a full-text query against the contents of an FTS5 table:</source>
          <target state="translated">채워지면 FTS5 테이블의 내용에 대해 전체 텍스트 쿼리를 실행하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7dc51406db9bf51bbe6620c6512b34c3f0e8f5e" translate="yes" xml:space="preserve">
          <source>Once the dirty page being purged is writable, it is simply written into the database file.</source>
          <target state="translated">제거중인 더티 페이지를 쓸 수 있으면 데이터베이스 파일에 간단히 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="821430ef05c1ab204de759a3df24102ae4261d90" translate="yes" xml:space="preserve">
          <source>Once the input data from the FROM clause has been filtered by the WHERE clause expression (if any), the set of result rows for the simple SELECT are calculated. Exactly how this is done depends on whether the simple SELECT is an aggregate or non-aggregate query, and whether or not a GROUP BY clause was specified.</source>
          <target state="translated">FROM 절의 입력 데이터가 WHERE 절 표현식 (있는 경우)에 의해 필터링되면 단순 SELECT에 대한 결과 행 세트가 계산됩니다. 정확히 수행되는 방법은 단순 SELECT가 집계 쿼리인지 집계되지 않은 쿼리인지, GROUP BY 절이 지정되었는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="79336569e93b2e9d0a83cc5e0a929d5ce48d2824" translate="yes" xml:space="preserve">
          <source>Once the project repository is created, create an open checkout of the project by moving to the directory where you want to keep all of the project source code and typing:</source>
          <target state="translated">프로젝트 저장소가 작성되면 모든 프로젝트 소스 코드를 유지하려는 디렉토리로 이동하고 다음을 입력하여 프로젝트의 열린 체크 아웃을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c4e9c9ce3f592c90096798d4d198a8b0474086e9" translate="yes" xml:space="preserve">
          <source>Once the spellfix1 extension is loaded, an instance of the spellfix1 virtual table is created like this:</source>
          <target state="translated">spellfix1 확장이로드되면 spellfix1 가상 테이블의 인스턴스가 다음과 같이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8513b43854c13df7657753be614db748baf13f7a" translate="yes" xml:space="preserve">
          <source>Once the test program is generated, it is run with no arguments to perform the tests. Progress information as well as error diagnostics appear on standard output. (Alternative output arrangements can be made using a compile-time option for embedded devices that lack a standard output channel.) The program returns zero if there are no errors and non-zero if any problems were detected.</source>
          <target state="translated">테스트 프로그램이 생성되면 테스트를 수행하기 위해 인수없이 실행됩니다. 오류 진단뿐만 아니라 진행 정보도 표준 출력에 나타납니다. (표준 출력 채널이없는 내장형 장치에 대해 컴파일 타임 옵션을 사용하여 대체 출력 배열을 만들 수 있습니다.) 오류가 없으면 프로그램은 0을 반환하고 문제가 발견되면 0이 아닌 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd0d76b14cf548de7ba347b074f1a4d3fbd73686" translate="yes" xml:space="preserve">
          <source>Once the virtual table is created, it can be queried as follows:</source>
          <target state="translated">가상 테이블이 생성되면 다음과 같이 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="1f76d0dc14ccffaabe0506021b655e9b2d8e3d76" translate="yes" xml:space="preserve">
          <source>Once you locate a specific version, click on the hyperlink for that version to see the &quot;Check-in Information Page&quot;. Then click on either the &quot;Tarball&quot; link or the &quot;ZIP archive&quot; link to download the complete source tree.</source>
          <target state="translated">특정 버전을 찾으면 해당 버전의 하이퍼 링크를 클릭하여 &quot;체크인 정보 페이지&quot;를 확인하십시오. 그런 다음 &quot;Tarball&quot;링크 또는 &quot;ZIP archive&quot;링크를 클릭하여 전체 소스 트리를 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5d89aa77c530c282e22378ce0f5d708e01a8b4fb" translate="yes" xml:space="preserve">
          <source>One approach to this query is to use the fruit='Orange' term of the WHERE clause to find all rows dealing with oranges, then filter those rows by rejecting any that are from states other than California. This process is shown by &lt;a href=&quot;#fig7&quot;&gt;figure 7&lt;/a&gt; above. This is a perfectly reasonable approach in most cases. Yes, the database engine did have to do an extra binary search for the Florida orange row that was later rejected, so it was not as efficient as we might hope, though for many applications it is efficient enough.</source>
          <target state="translated">이 쿼리에 대한 한 가지 접근 방식은 WHERE 절의 fruit = 'Orange'용어를 사용하여 오렌지를 처리하는 모든 행을 찾은 다음 캘리포니아 이외의 주에서 온 행을 거부하여 해당 행을 필터링하는 것입니다. 이 프로세스는 위의 &lt;a href=&quot;#fig7&quot;&gt;그림 7에&lt;/a&gt; 표시되어 있습니다. 이것은 대부분의 경우 완벽하게 합리적인 접근 방식입니다. 예, 데이터베이스 엔진은 나중에 거부 된 Florida 주황색 행에 대해 추가 이진 검색을 수행해야했기 때문에 많은 응용 프로그램에서 충분히 효율적이기는하지만 원하는만큼 효율적이지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="83e48e323326e14265bd89807dc478da45112a98" translate="yes" xml:space="preserve">
          <source>One can also provide comma-separated arguments to the module following the module name:</source>
          <target state="translated">모듈 이름 뒤에 쉼표로 구분 된 인수를 모듈에 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c99a07ebdfa971a90b20da9b4561b5f49cd6023c" translate="yes" xml:space="preserve">
          <source>One can also set the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; into automatic EXPLAIN QUERY PLAN mode using the &quot;.eqp on&quot; command:</source>
          <target state="translated">&quot;.eqp on&quot;명령을 사용하여 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 를 자동 EXPLAIN QUERY PLAN 모드로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="efbb187108974c009f143234a98d6989ff9c9ac6" translate="yes" xml:space="preserve">
          <source>One can also think of savepoints as &quot;marks&quot; in the transaction timeline. In this view, the SAVEPOINT command creates a new mark, the ROLLBACK TO command rewinds the timeline back to a point just after the named mark, and the RELEASE command erases marks from the timeline without actually making any changes to the database.</source>
          <target state="translated">또한 트랜잭션 타임 라인에서 저장 점을 &quot;표시&quot;로 생각할 수 있습니다. 이 뷰에서 SAVEPOINT 명령은 새 마크를 만들고 ROLLBACK TO 명령은 타임 라인을 명명 된 마크 바로 다음 지점으로 되 감고 RELEASE 명령은 실제로 데이터베이스를 변경하지 않고 타임 라인에서 마크를 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="3d55d95e5af6d3d744fa5a934dc2cc27683084a3" translate="yes" xml:space="preserve">
          <source>One can explicitly change out of WAL mode using a pragma such as this:</source>
          <target state="translated">다음과 같은 pragma를 사용하여 WAL 모드를 명시 적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5812082b2084545c8ed5d26ce266777d4a58efe5" translate="yes" xml:space="preserve">
          <source>One can see how the OR-by-UNION technique could also be leveraged to use multiple indices on queries where the WHERE clause has terms connected by AND, by using an intersect operator in place of union. Many SQL database engines will do just that. But the performance gain over using just a single index is slight and so SQLite does not implement that technique at this time. However, a future version SQLite might be enhanced to support AND-by-INTERSECT.</source>
          <target state="translated">조합 대신 교차 연산자를 사용하여 WHERE 절에 AND로 연결된 용어가있는 쿼리에서 여러 인덱스를 사용하기 위해 OR-by-UNION 기술을 어떻게 활용할 수 있는지 알 수 있습니다. 많은 SQL 데이터베이스 엔진이 그렇게 할 것입니다. 그러나 단일 인덱스 만 사용하면 성능이 약간 향상되므로 SQLite는 현재이 기술을 구현하지 않습니다. 그러나 향후 버전 SQLite는 AND-by-INTERSECT를 지원하도록 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18266c8f1da4ccb3784663f1422488207a89b45d" translate="yes" xml:space="preserve">
          <source>One cannot create a trigger on a virtual table.</source>
          <target state="translated">가상 테이블에서 트리거를 작성할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="08c14fea12c1a91b86b4eb3020bc8d201daa13d9" translate="yes" xml:space="preserve">
          <source>One cannot create additional indices on a virtual table. (Virtual tables can have indices but that must be built into the virtual table implementation. Indices cannot be added separately using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statements.)</source>
          <target state="translated">가상 테이블에서 추가 인덱스를 만들 수 없습니다. (가상 테이블에는 인덱스가있을 수 있지만 가상 테이블 구현에 내장되어야합니다. 인덱스는 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; 문을 사용하여 별도로 추가 할 수 없습니다 .)</target>
        </trans-unit>
        <trans-unit id="d3b50c178c087fb42ad06f0aba999c85b1ef895b" translate="yes" xml:space="preserve">
          <source>One cannot easily view, change, or extract the content of an OpenDocument presentation using generic tools. The only reasonable way to view or edit an OpenDocument document is to open it up using an application that is specifically designed to read or write OpenDocument (read: LibreOffice or one of its cousins). The situation could be worse. One can extract and view individual images (say) from a presentation using just the &quot;zip&quot; archiver tool. But it is not reasonable try to extract the text from a slide. Remember that all content is stored in a single &quot;context.xml&quot; file. That file is XML, so it is a text file. But it is not a text file that can be managed with an ordinary text editor. For the example presentation above, the content.xml file consist of exactly two lines. The first line of the file is just:</source>
          <target state="translated">일반 도구를 사용하여 OpenDocument 프레젠테이션의 내용을 쉽게 보거나 변경 또는 추출 할 수 없습니다. OpenDocument 문서를 보거나 편집하는 유일한 방법은 OpenDocument를 읽거나 쓰도록 특별히 설계된 응용 프로그램을 사용하여 문서를 여는 것입니다 (읽기 : LibreOffice 또는 그 사촌 중 하나). 상황이 더 나빠질 수 있습니다. &quot;zip&quot;아카이버 도구 만 사용하여 프리젠 테이션에서 개별 이미지를 추출하고 볼 수 있습니다. 그러나 슬라이드에서 텍스트를 추출하는 것은 합리적이지 않습니다. 모든 컨텐츠는 단일 &quot;context.xml&quot;파일에 저장됩니다. 이 파일은 XML이므로 텍스트 파일입니다. 그러나 일반 텍스트 편집기로 관리 할 수있는 텍스트 파일이 아닙니다. 위의 예제 프레젠테이션에서 content.xml 파일은 정확히 두 줄로 구성됩니다. 파일의 첫 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b60832325e280604faf68cf7c5149fd06825525" translate="yes" xml:space="preserve">
          <source>One cannot run &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; commands against a virtual table.</source>
          <target state="translated">가상 테이블에 대해 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE ... ADD COLUMN&lt;/a&gt; 명령을 실행할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="8229271a498b58a8b73749061ba175879d5bffff" translate="yes" xml:space="preserve">
          <source>One difference between Next and ListRead is their idea of a &quot;thing&quot;. The &quot;things&quot; for the Next instruction are records in a database file. &quot;Things&quot; for ListRead are integer keys in a list. Another difference is whether to jump or fall through if there is no next &quot;thing&quot;. In this case, Next falls through, and ListRead jumps. Later on, we will see other looping instructions (NextIdx and SortNext) that operate using the same principle.</source>
          <target state="translated">Next와 ListRead의 한 가지 차이점은 &quot;사물&quot;에 대한 아이디어입니다. 다음 명령어의 &quot;사물&quot;은 데이터베이스 파일의 레코드입니다. ListRead의 &quot;사물&quot;은 목록의 정수 키입니다. 또 다른 차이점은 다음 &quot;사물&quot;이없는 경우 점프하거나 넘어 지는지 여부입니다. 이 경우 다음이 넘어 가서 ListRead가 점프합니다. 나중에 동일한 원리로 작동하는 다른 루핑 명령어 (NextIdx 및 SortNext)가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0e2add845dd3757fedbc712aca0fdd2b6ebca768" translate="yes" xml:space="preserve">
          <source>One example of this occurred circa 2013-08-30 on the canonical repository for the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt;. In that event, file descriptor 2 (standard error) was being erroneously closed (by &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt;, we suspect) prior to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; so that the file descriptor used for the repository database file was 2. Later, an application bug caused an assert() statement to emit an error message by invoking write(2,...). But since file descriptor 2 was now connected to a database file, the error message overwrote part of the database. To guard against this kind of problem, SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;version 3.8.1&lt;/a&gt; (2013-10-17) and later refuse to use low-numbered file descriptors for database files. (See &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; for additional information.)</source>
          <target state="translated">이것의 한 예는 2013-08-30 경에 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil DVCS&lt;/a&gt; 의 표준 저장소에서 발생했습니다 . 이 경우, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 이전에 파일 설명자 2 (표준 오류)가 잘못 닫혔으며 ( &lt;a href=&quot;http://www.stunnel.org/&quot;&gt;stunnel&lt;/a&gt; 에 의해 의심 됨) 리포지토리 데이터베이스 파일에 사용 된 파일 설명자가 2였습니다. 나중에 응용 프로그램 버그로 인해 assert ( ) 문은 write (2, ...)를 호출하여 오류 메시지를 표시합니다. 그러나 파일 설명자 2가 이제 데이터베이스 파일에 연결되었으므로 오류 메시지가 데이터베이스의 일부를 덮어 썼습니다. 이러한 종류의 문제를 방지하기 위해 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_1.html&quot;&gt;버전 3.8.1&lt;/a&gt; (2013-10-17) 이상은 데이터베이스 파일에 낮은 번호의 파일 설명자를 사용하지 않습니다. ( &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 참조 추가 정보가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="f155185b09ba1b186403646b80d41d02e18f29b2" translate="yes" xml:space="preserve">
          <source>One exception to the typelessness of SQLite is a column whose type is INTEGER PRIMARY KEY. (And you must use &quot;INTEGER&quot; not &quot;INT&quot;. A column of type INT PRIMARY KEY is typeless just like any other.) INTEGER PRIMARY KEY columns must contain a 32-bit signed integer. Any attempt to insert non-integer data will result in an error.</source>
          <target state="translated">SQLite의 typelessness에 대한 한 가지 예외는 유형이 INTEGER PRIMARY KEY 인 열입니다. &quot;INT&quot;가 아닌 &quot;INTEGER&quot;를 사용해야합니다. INT PRIMARY KEY 유형의 열은 다른 방식과 마찬가지로 유형이 없습니다. INTEGER PRIMARY KEY 열은 32 비트 부호있는 정수를 포함해야합니다. 정수가 아닌 데이터를 삽입하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c476dc0c19b1ad151c922c972d11950866ac1040" translate="yes" xml:space="preserve">
          <source>One fuzzing researcher of particular note is &lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt;, currently (as this paragraph is written on 2019-12-21) at &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich&lt;/a&gt;. Most fuzzers only look for assertion faults, crashes, undefined behavior (UB), or other easily detected anomalies. Dr. Rigger's fuzzers, on the other hand, are able to find cases where SQLite computes an incorrect answer. Rigger has found &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;many such cases&lt;/a&gt;. Most of these finds are fairly obscure corner cases involving type conversions and affinity transformations, and a good number of the finds are against unreleased features. Nevertheless, his finds are still important as they are real bugs, and the SQLite developers are grateful to be able to identify and fix the underlying problems. Rigger's work is currently unpublished. When it is released, it could be as influential as Zalewski's invention of AFL and profile-guided fuzzing.</source>
          <target state="translated">특히 주목할만한 한 명의 퍼징 연구원은 현재 &lt;a href=&quot;https://ethz.ch/en.html&quot;&gt;ETH Zurich의 &lt;/a&gt;&lt;a href=&quot;https://www.manuelrigger.at/&quot;&gt;Manuel Rigger&lt;/a&gt; 입니다 (이 단락은 2019-12-21에 작성 됨) . 대부분의 퍼 저는 어설 션 오류, 충돌, 정의되지 않은 동작 (UB) 또는 기타 쉽게 감지되는 이상 항목 만 찾습니다. 반면에 Dr. Rigger의 퍼 저는 SQLite가 오답을 계산하는 경우를 찾을 수 있습니다. Rigger는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?y=t&amp;amp;u=mrigger&amp;amp;n=all&quot;&gt;이러한 사례를 많이&lt;/a&gt; 발견 했습니다.. 이러한 발견의 대부분은 유형 변환 및 선호도 변환과 관련된 상당히 모호한 코너 케이스이며 많은 발견이 릴리스되지 않은 기능에 대한 것입니다. 그럼에도 불구하고 그의 발견은 실제 버그이기 때문에 여전히 중요하며 SQLite 개발자는 근본적인 문제를 식별하고 수정할 수 있다는 것에 감사합니다. Rigger의 작업은 현재 게시되지 않았습니다. 출시되면 Zalewski의 AFL 발명 및 프로필 안내 퍼징만큼 영향력이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6bf8910e6414d0165fef0d30b0886bc0f8d4329" translate="yes" xml:space="preserve">
          <source>One implication of the above is that if a change is made and then unmade within a single session (for example if a row is inserted and then deleted again), the sessions module does not report any change at all. Or if a row is updated multiple times within the same session, all updates are coalesced into a single update within any changeset or patchset blob.</source>
          <target state="translated">위의 한 가지 의미는 단일 세션 내에서 변경이 이루어진 후 (예 : 행을 삽입 한 후 다시 삭제하는 경우) 세션 모듈이 변경을 전혀보고하지 않는다는 것입니다. 또는 동일한 세션 내에서 행이 여러 번 업데이트되는 경우 모든 업데이트는 변경 집합 또는 패치 세트 Blob 내에서 단일 업데이트로 통합됩니다.</target>
        </trans-unit>
        <trans-unit id="fc9f38831587103a404686b12cd389ecfbf1fe12" translate="yes" xml:space="preserve">
          <source>One might argue that it is ok, in this era of multi-gigabyte desktops, to read the entire document into memory. But it is not ok. For one, the amount of memory used far exceeds the (compressed) file size on disk. So a 50MB presentation might take 200MB or more RAM. That still is not a problem if one only edits a single document at a time. But when working on a talk, this author will typically have 10 or 15 different presentations up all at the same time (to facilitate copy/paste of slides from past presentation) and so gigabytes of memory are required. Add in an open web browser or two and a few other desktop apps, and suddenly the disk is whirling and the machine is swapping. And even having just a single document is a problem when working on an inexpensive Chromebook retrofitted with Ubuntu. Using less memory is always better.</source>
          <target state="translated">오늘날 멀티 기가 바이트 데스크톱 시대에 전체 문서를 메모리로 읽는 것이 좋다고 주장 할 수 있습니다. 그러나 괜찮습니다. 하나의 경우, 사용 된 메모리 양이 디스크의 (압축 된) 파일 크기를 훨씬 초과합니다. 따라서 50MB 프레젠테이션에는 200MB 이상의 RAM이 필요할 수 있습니다. 한 번에 하나의 문서 만 편집해도 문제가되지 않습니다. 그러나 대화를 할 때이 저자는 일반적으로 동시에 10 개 또는 15 개의 서로 다른 프레젠테이션을 갖습니다 (과거의 프레젠테이션에서 슬라이드 복사 / 붙여 넣기를 용이하게하기 위해). 따라서 기가 바이트의 메모리가 필요합니다. 열린 웹 브라우저 또는 두 개 이상의 다른 데스크탑 앱에 추가하면 갑자기 디스크가 빙글 빙글 돌리고 머신이 스와핑됩니다. 그리고 우분투로 개조 된 저렴한 크롬 북 작업을 할 때 하나의 문서 만 있으면 문제가됩니다. 적은 메모리를 사용하는 것이 항상 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f44cc341ba0d29ec39fe1d9113cc5db69afebdc7" translate="yes" xml:space="preserve">
          <source>One might want to provide other &lt;a href=&quot;compile&quot;&gt;compile-time options&lt;/a&gt; such as &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; or &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; for full-text search, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; for the R*Tree search engine extension, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; to include &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt;, or &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; for the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. In order to see extra commentary in &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; listings, add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; option. On unix systems, add -DHAVE_USLEEP=1 if the host machine supports the usleep() system call. Add -DHAVE_READLINE and the -lreadline and -lncurses libraries to get command-line editing support. One might also want to specify some compiler optimization switches. (The precompiled CLI available for download from the SQLite website uses &quot;-Os&quot;.) There are countless possible variations here. A command to compile a full-featured shell might look something like this:</source>
          <target state="translated">하나는 다른 제공 할 수 있습니다 &lt;a href=&quot;compile&quot;&gt;컴파일 시간 옵션&lt;/a&gt; 과 같은 &lt;a href=&quot;compile#enable_fts4&quot;&gt;-DSQLITE_ENABLE_FTS4&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; 전체 텍스트 검색, &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; 는 R * 트리 검색 엔진 연장, &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1을&lt;/a&gt; 포함하는 &lt;a href=&quot;json1&quot;&gt;JSON SQL 함수&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;-DSQLITE_ENABLE_DBSTAT_VTAB을&lt;/a&gt; 에 대한 &lt;a href=&quot;dbstat&quot;&gt;가상 테이블 dbstat와&lt;/a&gt; . &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 리스팅 에서 추가 주석을 보려면 &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS를&lt;/a&gt; 추가하십시오 .선택권. 유닉스 시스템에서, 호스트 시스템이 usleep () 시스템 호출을 지원하면 -DHAVE_USLEEP = 1을 추가하십시오. 명령 행 편집 지원을 받으려면 -DHAVE_READLINE 및 -lreadline 및 -lncurses 라이브러리를 추가하십시오. 컴파일러 최적화 스위치를 지정할 수도 있습니다. SQLite 웹 사이트에서 다운로드 할 수있는 사전 컴파일 된 CLI는 &quot;-Os&quot;를 사용합니다. 여기에는 수많은 변형이 있습니다. 모든 기능을 갖춘 쉘을 컴파일하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a02d032d7380123e8a5e72e863e1054c5bd48cb" translate="yes" xml:space="preserve">
          <source>One minor downside of splitting content into smaller pieces is that compression does not work as well on shorter texts and so the size of the document might increase. But as the bulk of the document space is used to store images, a small reduction in the compression efficiency of the text content will hardly be noticeable, and is a small price to pay for an improved user experience.</source>
          <target state="translated">내용을 작은 조각으로 나누는 것의 단점은 압축이 짧은 텍스트에서는 잘 작동하지 않아 문서 크기가 커질 수 있다는 것입니다. 그러나 대부분의 문서 공간이 이미지를 저장하는 데 사용되므로 텍스트 내용의 압축 효율이 약간 떨어지지 만 사용자 환경을 개선하기 위해 적은 비용이 듭니다.</target>
        </trans-unit>
        <trans-unit id="b297ff44d76535e06e20e05a05458aba9a18af0a" translate="yes" xml:space="preserve">
          <source>One of the 10 decimal digit ASCII characters, or</source>
          <target state="translated">10 진수 10 진수 ASCII 문자 중 하나 또는</target>
        </trans-unit>
        <trans-unit id="67403b0cb5390fcf0c705699aeb495a2edb6d96b" translate="yes" xml:space="preserve">
          <source>One of the 52 upper and lower case ASCII characters, or</source>
          <target state="translated">52 개의 대문자 및 소문자 ASCII 문자 중 하나 또는</target>
        </trans-unit>
        <trans-unit id="cff101187bdbe5720613db95b3564ea1057f17a1" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;different&quot;&gt;distinctive features&lt;/a&gt; of SQLite is that a database consists of a single disk file. This simplifies the use of SQLite since moving or backing up a database is a simple as copying a single file. It also makes SQLite appropriate for use as an &lt;a href=&quot;whentouse#appfileformat&quot;&gt;application file format&lt;/a&gt;. But while a complete database is held in a single disk file, SQLite does make use of many temporary files during the course of processing a database.</source>
          <target state="translated">SQLite의 &lt;a href=&quot;different&quot;&gt;특징&lt;/a&gt; 중 하나는 데이터베이스가 단일 디스크 파일로 구성되어 있다는 것입니다. 데이터베이스 이동 또는 백업은 단일 파일을 복사하는 것만 큼 간단하기 때문에 SQLite 사용을 단순화합니다. 또한 SQLite를 &lt;a href=&quot;whentouse#appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용하기에 적합하게 만듭니다 . 그러나 완전한 데이터베이스가 단일 디스크 파일로 유지되는 동안 SQLite는 데이터베이스 처리 과정에서 많은 임시 파일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e5c91de459561e96de8f3e9e77eaa61509cd18a7" translate="yes" xml:space="preserve">
          <source>One of the ALL or DISTINCT keywords may follow the SELECT keyword in a simple SELECT statement. If the simple SELECT is a SELECT ALL, then the entire set of result rows are returned by the SELECT. If neither ALL or DISTINCT are present, then the behavior is as if ALL were specified. If the simple SELECT is a SELECT DISTINCT, then duplicate rows are removed from the set of result rows before it is returned. For the purposes of detecting duplicate rows, two NULL values are considered to be equal. The &lt;a href=&quot;datatype3#colrules&quot;&gt;usual rules&lt;/a&gt; apply for selecting a collation sequence to compare text values.</source>
          <target state="translated">ALL 또는 DISTINCT 키워드 중 하나가 간단한 SELECT 문에서 SELECT 키워드 뒤에 올 수 있습니다. 단순 SELECT가 SELECT ALL이면 전체 결과 행 세트가 SELECT에 의해 리턴됩니다. ALL 또는 DISTINCT가 없으면 ALL이 지정된 것처럼 동작합니다. 단순 SELECT가 SELECT DISTINCT이면 중복 행이 리턴되기 전에 결과 행 세트에서 제거됩니다. 중복 행을 감지하기 위해 두 개의 NULL 값이 동일한 것으로 간주됩니다. &lt;a href=&quot;datatype3#colrules&quot;&gt;일반적인 규칙은&lt;/a&gt; 텍스트 값을 비교하는 정렬 순서를 선택 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="148ba6e1c7e039de60e4599c768cf9921948e4c8" translate="yes" xml:space="preserve">
          <source>One of the advantages of hosting code generator tools as part of the project is that the tools can be optimized to serve specific needs of the overall project. Lemon has benefited from this effect. Over the years, the Lemon parser generator has been extended and enhanced to provide new capabilities and improved performance to SQLite. A few of the specific enhancements to Lemon that are specifically designed for use by SQLite include:</source>
          <target state="translated">프로젝트의 일부로 코드 생성기 도구를 호스팅 할 때의 장점 중 하나는 전체 프로젝트의 특정 요구에 맞게 도구를 최적화 할 수 있다는 것입니다. 레몬은이 효과로부터 이익을 얻었습니다. 수년에 걸쳐 레몬 파서 생성기는 SQLite에 새로운 기능과 향상된 성능을 제공하도록 확장 및 향상되었습니다. SQLite에서 사용하도록 특별히 설계된 레몬의 몇 가지 향상된 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66a50c77336f3c9a6df53cb2e7363aee5a52fbbd" translate="yes" xml:space="preserve">
          <source>One of the interesting features of the VFS interface is that SQLite can support multiple VFSes at the same time. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; has to choose a single VFS for its use when the connection is first opened using &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;. But if a process contains multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; each can choose a different VFS. VFSes can be added at run-time using the &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; interface.</source>
          <target state="translated">VFS 인터페이스의 흥미로운 기능 중 하나는 SQLite가 여러 VFS를 동시에 지원할 수 있다는 것입니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 사용하여 연결을 처음 열 때 사용할 단일 VFS를 선택해야합니다 . 그러나 프로세스에 여러 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결이&lt;/a&gt; 포함 된 경우 각각 다른 VFS를 선택할 수 있습니다. &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 인터페이스를 사용하여 VFS를 런타임에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1c2a440e7d12be65f7ff95454bfa77307c4b02e" translate="yes" xml:space="preserve">
          <source>One of the many reports that Fossil makes available is a timeline of changes to a single branch showing all merges in and out of that branch. See &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; for a typical example of such a report. Generating such a report normally takes just a few milliseconds. But after upgrading to the NGQP we noticed that this one report was taking closer to 10 seconds for the trunk of the repository.</source>
          <target state="translated">Fossil이 제공하는 많은 보고서 중 하나는 단일 지점에 대한 변경 일정으로 해당 지점의 모든 병합을 보여줍니다. 이러한 보고서의 일반적인 예는 &lt;a href=&quot;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&quot;&gt;http://www.sqlite.org/src/timeline?nd&amp;amp;n=200&amp;amp;r=trunk&lt;/a&gt; 를 참조 하십시오 . 이러한 보고서를 생성하는 데 일반적으로 몇 밀리 초가 걸립니다. 그러나 NGQP로 업그레이드 한 후이 보고서가 리포지토리 트렁크에서 10 초에 근접한 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="16f929fd09cef7d1acb11b165614f8e6f651a35f" translate="yes" xml:space="preserve">
          <source>One of the things that SQLite does to ensure that transactions are atomic across system crashes and power failures is to write all changes into the rollback journal file prior to changing the database. The TCL test harness contains an alternative &lt;a href=&quot;vfs&quot;&gt;OS backend&lt;/a&gt; implementation that helps to verify this is occurring correctly. The &quot;journal-test VFS&quot; monitors all disk I/O traffic between the database file and rollback journal, checking to make sure that nothing is written into the database file which has not first been written and synced to the rollback journal. If any discrepancies are found, an assertion fault is raised.</source>
          <target state="translated">SQLite가 시스템 충돌 및 전원 장애에 걸쳐 트랜잭션을 원자 적으로 유지하기 위해 수행하는 작업 중 하나는 데이터베이스를 변경하기 전에 모든 변경 사항을 롤백 저널 파일에 기록하는 것입니다. TCL 테스트 하네스에는 올바르게 작동하는지 확인하는 데 도움 이되는 대체 &lt;a href=&quot;vfs&quot;&gt;OS 백엔드&lt;/a&gt; 구현이 포함되어 있습니다 . &quot;journal-test VFS&quot;는 데이터베이스 파일과 롤백 저널 사이의 모든 디스크 I / O 트래픽을 모니터하여 롤백 저널에 처음 기록되고 동기화되지 않은 데이터베이스 파일에 아무것도 기록되지 않았는지 확인합니다. 불일치가 발견되면 어설 션 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8702bf42f5b52e2937e5261eb8fe5e53cb025817" translate="yes" xml:space="preserve">
          <source>One or more indexes of the table are currently unanalyzed &lt;em&gt;or&lt;/em&gt; the number of rows in the table has increased by 25 times or more since the last time ANALYZE was run.</source>
          <target state="translated">ANALYZE가 마지막으로 실행 된 이후로 테이블의 하나 이상의 인덱스가 현재 분석되지 &lt;em&gt;않았거나&lt;/em&gt; 테이블 의 행 수가 25 배 이상 증가했습니다.</target>
        </trans-unit>
        <trans-unit id="c07477cd0e5dcf04189629377d839b6d5b58ba89" translate="yes" xml:space="preserve">
          <source>One or more transactions must have been written to the current wal file since it was created on disk (by any connection). This means that a snapshot cannot be taken on a wal mode database with no wal file immediately after it is first opened. At least one transaction must be written to it first.</source>
          <target state="translated">하나 이상의 트랜잭션이 디스크에 작성되었으므로 현재 wal 파일에 연결되어 있어야합니다. 즉, wal 파일을 처음 연 직후에는 wal 파일이없는 wal 모드 데이터베이스에서 스냅 샷을 작성할 수 없습니다. 먼저 하나 이상의 트랜잭션을 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b839504f0d97f30339eb42940d7178a50aed3e9b" translate="yes" xml:space="preserve">
          <source>One solution is to add an SQL foreign key constraint to the database schema to enforce the relationship between the</source>
          <target state="translated">한 가지 해결책은 데이터베이스 스키마에 SQL 외래 키 제약 조건을 추가하여</target>
        </trans-unit>
        <trans-unit id="9e9e9e6d05419e1f1b802f612d5f17adfe32fb1a" translate="yes" xml:space="preserve">
          <source>One solution to this problem is to change SQLite to do an exhaustive search for the best path. But an exhaustive search requires time proportional to K! (where K is the number of tables in the join) and so when you get beyond a 10-way join, the time to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; becomes very large.</source>
          <target state="translated">이 문제에 대한 한 가지 해결책은 SQLite를 변경하여 최상의 경로를 철저히 검색하는 것입니다. 그러나 철저한 검색에는 K에 비례하는 시간이 필요합니다! (여기서 K는 조인의 테이블 수) 10- 조인 조인을 넘어 서면 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 를 실행하는 시간 이 매우 커집니다.</target>
        </trans-unit>
        <trans-unit id="3ea27e906845c470414940dc542a3a724c62dba9" translate="yes" xml:space="preserve">
          <source>One technique for avoiding a full table scan is to do lookups by rowid (or by the equivalent &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt;). To lookup the price of peaches, one would query for the entry with a rowid of 4:</source>
          <target state="translated">전체 테이블 스캔을 피하는 한 가지 기술은 rowid (또는 동등한 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; ) 별로 검색하는 것 입니다. 복숭아의 가격을 조회하기 위해 rowid가 4 인 항목을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="9d59b48161b2263d40d4491d1bb939a7b7f92e6e" translate="yes" xml:space="preserve">
          <source>One user of both Git and Fossil &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;writes in HN&lt;/a&gt;:</source>
          <target state="translated">Git과 Fossil의 한 사용자가 &lt;a href=&quot;https://news.ycombinator.com/item?id=16806955&quot;&gt;HN으로 작성합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="75f64ba853c8246c4f074dd74725d9448e0221f8" translate="yes" xml:space="preserve">
          <source>One verification technique used on SQLite is to run an entire test suite twice, once with optimizations left on and a second time with optimizations turned off, and verify that the same output is obtained both times. This shows that the optimizations do not introduce errors.</source>
          <target state="translated">SQLite에서 사용되는 한 가지 검증 기술은 전체 테스트 스위트를 두 번 실행하는 것입니다. 한 번 최적화를 설정 한 상태에서 한 번, 최적화를 해제 한 상태로 두 번째로 실행하면 두 번 모두 동일한 출력을 얻을 수 있습니다. 이는 최적화에 오류가 발생하지 않음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1193850e31c2f1f6fdd8ba5f6d6a21ba1025f991" translate="yes" xml:space="preserve">
          <source>One very simple scheme might be to count the number of instances of the users search terms in each result document. Those documents that contain many instances of the terms are considered more relevant than those with a small number of instances of each term. In an FTS application, the number of term instances in each result could be determined by counting the number of integers in the return value of the &lt;a href=&quot;fts3#offsets&quot;&gt;offsets&lt;/a&gt; function. The following example shows a query that could be used to obtain the ten most relevant results for a query entered by the user:</source>
          <target state="translated">매우 간단한 방법 중 하나는 각 결과 문서에서 사용자 검색어의 인스턴스 수를 계산하는 것입니다. 용어가 많이 포함 된 문서는 각 용어가 적은 수의 문서보다 관련성이 높은 것으로 간주됩니다. FTS 응용 프로그램에서 각 결과의 항 인스턴스 수는 &lt;a href=&quot;fts3#offsets&quot;&gt;오프셋&lt;/a&gt; 함수 의 반환 값에있는 정수 수를 계산하여 확인할 수 있습니다 . 다음 예는 사용자가 입력 한 쿼리에 대해 10 개의 가장 관련성이 높은 결과를 얻는 데 사용할 수있는 쿼리를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="ef8241368a545dcfd4804f314c3279bd316a6040" translate="yes" xml:space="preserve">
          <source>One way around this problem is to check the extended error code returned by an sqlite3_step() call. If there is a blocking connection, then the extended error code is set to SQLITE_LOCKED_SHAREDCACHE. Otherwise, in the special &quot;DROP TABLE/INDEX&quot; case, the extended error code is just SQLITE_LOCKED.</source>
          <target state="translated">이 문제를 해결하는 한 가지 방법은 sqlite3_step () 호출에 의해 반환 된 확장 오류 코드를 확인하는 것입니다. 블로킹 연결이 있으면 확장 오류 코드가 SQLITE_LOCKED_SHAREDCACHE로 설정됩니다. 그렇지 않으면 특수한 &quot;DROP TABLE / INDEX&quot;경우 확장 오류 코드는 SQLITE_LOCKED입니다.</target>
        </trans-unit>
        <trans-unit id="acee115381c0c09c4f7ee9640610c7e8117858b5" translate="yes" xml:space="preserve">
          <source>One way to compute FindFrame(P,M) would be to scan the aPgno array starting with the M-th entry and working backwards towards the beginning and return J where aPgno[J]==P. Such an algorithm would work, and it would be faster than searching the whole WAL file for the latest frame with page number P. But the search can be made much faster still by using the aHash structure.</source>
          <target state="translated">FindFrame (P, M)을 계산하는 한 가지 방법은 M 번째 항목부터 시작하여 뒤로 시작하여 aPgno [J] == P 인 J를 반환하는 aPgno 배열을 스캔하는 것입니다. 이러한 알고리즘은 작동하며 페이지 번호가 P 인 최신 프레임을 전체 WAL 파일을 검색하는 것보다 빠릅니다. 그러나 aHash 구조를 사용하면 훨씬 빠르게 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43ce70174605b98e2611ee3fa62c55d5c3b3d847" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_master table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">임 포스터 테이블을 작성하는 한 가지 방법은 sqlite_master 테이블을 직접 편집하여 테이블을 설명하는 새 행을 삽입하는 것입니다. 예를 들어, 스키마가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="84cd9c4bdeae83b60aa9ede1d4ab69d156255724" translate="yes" xml:space="preserve">
          <source>One way to create an imposter table is to directly edit the sqlite_schema table to insert a new row that describes the table. For example, suppose the schema is like this:</source>
          <target state="translated">임 포스터 테이블을 만드는 한 가지 방법은 sqlite_schema 테이블을 직접 편집하여 테이블을 설명하는 새 행을 삽입하는 것입니다. 예를 들어 스키마가 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="5371a62fb713016b88bf9cbe1ee3e53f088627a9" translate="yes" xml:space="preserve">
          <source>One way to use sqlite3 in a shell script is to use &quot;echo&quot; or &quot;cat&quot; to generate a sequence of commands in a file, then invoke sqlite3 while redirecting input from the generated command file. This works fine and is appropriate in many circumstances. But as an added convenience, sqlite3 allows a single SQL command to be entered on the command line as a second argument after the database name. When the sqlite3 program is launched with two arguments, the second argument is passed to the SQLite library for processing, the query results are printed on standard output in list mode, and the program exits. This mechanism is designed to make sqlite3 easy to use in conjunction with programs like &quot;awk&quot;. For example:</source>
          <target state="translated">쉘 스크립트에서 sqlite3를 사용하는 한 가지 방법은 &quot;echo&quot;또는 &quot;cat&quot;을 사용하여 파일에서 일련의 명령을 생성 한 다음 생성 된 명령 파일에서 입력을 재지 정하는 동안 sqlite3을 호출하는 것입니다. 이것은 잘 작동하며 많은 상황에서 적합합니다. 그러나 편의상 sqlite3을 사용하면 데이터베이스 이름 다음에 두 번째 인수로 명령 행에 단일 SQL 명령을 입력 할 수 있습니다. sqlite3 프로그램이 두 개의 인수로 시작되면 두 번째 인수는 처리를 위해 SQLite 라이브러리로 전달되고 쿼리 결과는 표준 출력에 목록 모드로 인쇄되고 프로그램이 종료됩니다. 이 메커니즘은 &quot;awk&quot;와 같은 프로그램과 함께 sqlite3를 쉽게 사용할 수 있도록 설계되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c9f164cc934fc44dc3087a408a43d581d45a004f" translate="yes" xml:space="preserve">
          <source>One would get the same answer without the use of the R*Tree index using the following simpler query:</source>
          <target state="translated">다음과 같은 간단한 쿼리를 사용하여 R * Tree 인덱스를 사용하지 않고도 동일한 대답을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17f5a4fe2f5c62ecd81776d246b8c0c725190c25" translate="yes" xml:space="preserve">
          <source>One-Step Query Execution Interface</source>
          <target state="translated">원스텝 쿼리 실행 인터페이스</target>
        </trans-unit>
        <trans-unit id="aa3d3adac784c0d74a31276058a965e9e8ca9895" translate="yes" xml:space="preserve">
          <source>Online Backup API</source>
          <target state="translated">온라인 백업 API</target>
        </trans-unit>
        <trans-unit id="84ecd14ddbadabe468f63832d803f2392f405f33" translate="yes" xml:space="preserve">
          <source>Online Backup API.</source>
          <target state="translated">온라인 백업 API.</target>
        </trans-unit>
        <trans-unit id="df4435ab96f572a5ddc0d0575dab3a2326c426c1" translate="yes" xml:space="preserve">
          <source>Online Backup Object</source>
          <target state="translated">온라인 백업 개체</target>
        </trans-unit>
        <trans-unit id="cf333df0d0137378797eeac3fd91be937936f09b" translate="yes" xml:space="preserve">
          <source>Only CPU cycle counts are being measured here. CPU cycle counts are a good proxy for energy consumption, but do not necessary correlate well with real-world timings. Time spent doing I/O is not reflected in the CPU cycle counts, and I/O time predominates in many SQLite usage scenarios.</source>
          <target state="translated">여기서는 CPU주기 수만 측정됩니다. CPU 사이클 수는 에너지 소비를위한 좋은 프록시이지만 실제 타이밍과는 상관이 없습니다. I / O를 수행하는 데 소요 된 시간은 CPU주기 수에 반영되지 않으며 많은 SQLite 사용 시나리오에서 I / O 시간이 우세합니다.</target>
        </trans-unit>
        <trans-unit id="d5604491374c9f17a80675ca75c6861a336b77e6" translate="yes" xml:space="preserve">
          <source>Only a single authorizer can be in place on a database connection at a time. Each call to sqlite3_set_authorizer overrides the previous call. Disable the authorizer by installing a NULL callback. The authorizer is disabled by default.</source>
          <target state="translated">한 번에 하나의 권한 부여 자만 데이터베이스 연결에 배치 할 수 있습니다. sqlite3_set_authorizer에 대한 각 호출은 이전 호출을 대체합니다. NULL 콜백을 설치하여 권한 부여기를 비활성화하십시오. 인증 기는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="478d5d49691bd8c6240a1fe276d18045c9e67957" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 당 한 번에 하나의 진행률 처리기 만 정의 할 수 있습니다 . 새로운 진행 처리기를 설정하면 이전 처리기가 취소됩니다. 매개 변수 X를 NULL로 설정하면 진행률 처리기가 비활성화됩니다. N을 1보다 작은 값으로 설정하면 진행률 처리기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="94e56a9c57047e711c69e819b360a3dd7e101263" translate="yes" xml:space="preserve">
          <source>Only a single progress handler may be defined at one time per &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt;; setting a new progress handler cancels the old one. Setting parameter X to NULL disables the progress handler. The progress handler is also disabled by setting N to a value less than 1.</source>
          <target state="translated">&lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 당 한 번에 하나의 진행률 처리기 만 정의 할 수 있습니다 . 새로운 진행 처리기를 설정하면 이전 처리기가 취소됩니다. 매개 변수 X를 NULL로 설정하면 진행률 처리기가 비활성화됩니다. N을 1보다 작은 값으로 설정하면 진행률 처리기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7036e4ebe3282d4cd750dee2b265f33019cf27cb" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;../lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 문으로 직접 작성된 변경 사항 만 고려됩니다. &lt;a href=&quot;../lang_createtrigger&quot;&gt;트리거&lt;/a&gt; , &lt;a href=&quot;../foreignkeys#fk_actions&quot;&gt;외래 키 조치&lt;/a&gt; 또는 &lt;a href=&quot;../lang_replace&quot;&gt;REPLACE&lt;/a&gt; 제한 조건 분석으로 인한 보조 변경 사항 은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c27ab9dbf00600e9d93b4dae249b72bd85740109" translate="yes" xml:space="preserve">
          <source>Only changes made directly by the INSERT, UPDATE or DELETE statement are considered - auxiliary changes caused by &lt;a href=&quot;lang_createtrigger&quot;&gt;triggers&lt;/a&gt;, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt; or &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; constraint resolution are not counted.</source>
          <target state="translated">INSERT, UPDATE 또는 DELETE 문으로 직접 작성된 변경 사항 만 고려됩니다. &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거&lt;/a&gt; , &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 조치&lt;/a&gt; 또는 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 제한 조건 분석으로 인한 보조 변경 사항 은 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ca2d95ecc0496343a0233bd681510ca318c6946" translate="yes" xml:space="preserve">
          <source>Only columns a and b of the index would be usable. The d column would not be usable because column c is not constrained and there can be no gaps in the set of columns that usable by the index.</source>
          <target state="translated">인덱스의 열 a와 b 만 사용할 수 있습니다. c 열이 제한되지 않고 인덱스에서 사용할 수있는 열 집합에 간격이 없어 d 열을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="05736f4fee6c4c67dfd5428743f05e710b55053c" translate="yes" xml:space="preserve">
          <source>Only columns a, b, and c of the index would be usable. The d column would not be usable because it occurs to the right of c and c is constrained only by inequalities.</source>
          <target state="translated">인덱스의 열 a, b 및 c 만 사용할 수 있습니다. d 열은 c의 오른쪽에서 발생하고 c는 부등식으로 만 제한되므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6822d83fba844c52182b6e2b1305124432ab29b8" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;master journal&lt;/a&gt; files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">둘 이상의 연결된 데이터베이스가 모두 수정되고 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되어 있지 않고 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; 가 OFF, MEMORY 또는 WAL로 설정되어 있지 않은 경우 에만 &lt;a href=&quot;tempfiles#masterjrnl&quot;&gt;마스터 저널&lt;/a&gt; 파일을 작성 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d1635246b5aeaad6de58e92e5095276c845c10a" translate="yes" xml:space="preserve">
          <source>Only create &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;statement journal&lt;/a&gt; files when their size exceeds a threshold. Otherwise the journal is held in memory and no I/O occurs. The threshold can be configured at compile-time using &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; or at start-time using &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL&lt;/a&gt;).</source>
          <target state="translated">크기가 임계 값을 초과 할 경우 에만 &lt;a href=&quot;tempfiles#stmtjrnl&quot;&gt;명령문 저널&lt;/a&gt; 파일을 작성하십시오 . 그렇지 않으면 저널이 메모리에 유지되고 I / O가 발생하지 않습니다. 임계 값은 사용 컴파일시에 구성 될 수 &lt;a href=&quot;compile#stmtjrnl_spill&quot;&gt;SQLITE_STMTJRNL_SPILL&lt;/a&gt; 사용 또는 시동시에이 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigstmtjrnlspill&quot;&gt;SQLITE_CONFIG_STMTJRNL_SPILL을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="04951ae9e91c50e633618b0424f4870112bf6e2c" translate="yes" xml:space="preserve">
          <source>Only create master journal files if two or more attached databases are all modified, do not have &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; set to OFF, and do not have the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; set to OFF, MEMORY, or WAL.</source>
          <target state="translated">둘 이상의 연결된 데이터베이스가 모두 수정되고 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 OFF로 설정되지 않았으며 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; 가 OFF, MEMORY 또는 WAL로 설정 되지 않은 경우에만 마스터 저널 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="610003d6616c61d3e569880b1cf6337a8bfaac43" translate="yes" xml:space="preserve">
          <source>Only rows of the table for which the WHERE clause evaluates to true are included in the index. If the WHERE clause expression evaluates to NULL or to false for some rows of the table, then those rows are omitted from the index.</source>
          <target state="translated">WHERE 절이 true로 평가되는 테이블의 행만 인덱스에 포함됩니다. WHERE 절 표현식이 테이블의 일부 행에 대해 NULL 또는 false로 평가되면 해당 행이 색인에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="255e530c466468dcdf3e2dbc7217cf60c632c517" translate="yes" xml:space="preserve">
          <source>Only terms of the vocabulary with a matching langid are searched. Hence, the same table can contain entries from multiple languages and only the requested language will be used. The default langid is 0.</source>
          <target state="translated">langid가 일치하는 단어의 용어 만 검색합니다. 따라서 동일한 테이블에 여러 언어의 항목이 포함될 수 있으며 요청 된 언어 만 사용됩니다. 기본 langid는 0입니다.</target>
        </trans-unit>
        <trans-unit id="2ece13f71abf0bca8da38ece8f95957b023f2f28" translate="yes" xml:space="preserve">
          <source>Only the &quot;ll&quot; length modifier ever makes a difference for SQLite. And it only makes a difference when using the C-language interfaces.</source>
          <target state="translated">&quot;ll&quot;길이 수정 자만 SQLite에 차이를 만듭니다. 그리고 C 언어 인터페이스를 사용할 때만 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="85148a6237828ed28c44695045ab73ff06e6fcad" translate="yes" xml:space="preserve">
          <source>Only the RENAME TABLE, ADD COLUMN, and RENAME COLUMN variants of the ALTER TABLE command are supported. Other kinds of ALTER TABLE operations such as DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT, and so forth are omitted.</source>
          <target state="translated">ALTER TABLE 명령의 RENAME TABLE, ADD COLUMN 및 RENAME COLUMN 변형 만 지원됩니다. DROP COLUMN, ALTER COLUMN, ADD CONSTRAINT 등과 같은 다른 종류의 ALTER TABLE 연산은 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="718ea1282b5847e8c3e9e8f8d5345c6ee50c38cc" translate="yes" xml:space="preserve">
          <source>Only the implicit version of the AND operator is supported. Specifying the string &quot;AND&quot; as part of a standard query syntax query is interpreted as a term query for the set of documents containing the term &quot;and&quot;.</source>
          <target state="translated">AND 연산자의 암시 적 버전 만 지원됩니다. 표준 쿼리 구문 쿼리의 일부로 문자열 &quot;AND&quot;를 지정하면 &quot;and&quot;라는 용어가 포함 된 문서 집합에 대한 용어 쿼리로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="1eda18e73564838ddd329dd3f15abb7d2f114fbe" translate="yes" xml:space="preserve">
          <source>Only the three core routines described in section 1.0 are required to use SQLite. But there are many other functions that provide useful interfaces. These extended routines are as follows:</source>
          <target state="translated">섹션 1.0에 설명 된 세 가지 핵심 루틴 만 SQLite를 사용해야합니다. 그러나 유용한 인터페이스를 제공하는 다른 많은 기능이 있습니다. 이러한 확장 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97073c710caef6e8b97ed50f7242027a83850af5" translate="yes" xml:space="preserve">
          <source>Only unsigned integers are recognized. Plus and minus signs are ignored. Decimal points and exponential notation are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ddd9d23f19b01af8d3915a7bfd11c89aef2d1d4" translate="yes" xml:space="preserve">
          <source>Only use indexes-on-expressions to optimize ORDER BY or GROUP BY if the COLLATE is correct. Ticket &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</source>
          <target state="translated">COLLATE가 올 바르면 ORDER BY 또는 GROUP BY를 최적화하기 위해 인덱스 온 표현식 만 사용하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/e20dd54ab0e4383&quot;&gt;e20dd54ab0e4383&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c74dd7ced7cd4ea8002b3c96a9b1ecdff66b1e59" translate="yes" xml:space="preserve">
          <source>Opcode Name</source>
          <target state="translated">오피 코드 이름</target>
        </trans-unit>
        <trans-unit id="1682c59856887894432baf4bb39e98c21d42d731" translate="yes" xml:space="preserve">
          <source>Opcode definitions</source>
          <target state="translated">오피 코드 정의</target>
        </trans-unit>
        <trans-unit id="313411b9bd1b97b8fcd666d91d350cb8e6bed0d1" translate="yes" xml:space="preserve">
          <source>Open A BLOB For Incremental I/O</source>
          <target state="translated">증분 I / O를위한 BLOB 열기</target>
        </trans-unit>
        <trans-unit id="beb2e15e058a69d62502daa1bdfb1095abeb86de" translate="yes" xml:space="preserve">
          <source>Open a cursor into the table to be queried.</source>
          <target state="translated">쿼리 할 테이블로 커서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="7e8e851c144078264ee423ec854e116a3d7fdff4" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 that points to the same ephemeral table as cursor P2. The P2 cursor must have been opened by a prior &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode. Only ephemeral cursors may be duplicated.</source>
          <target state="translated">커서 P2와 동일한 임시 테이블을 가리키는 새 커서 P1을여십시오. P2 커서는 이전 &lt;a href=&quot;opcode#OpenEphemeral&quot;&gt;OpenEphemeral&lt;/a&gt; opcode에 의해 열려 있어야합니다 . 임시 커서 만 복제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57454cf77dc40f8ad1e1086dd9c199e6c88ed771" translate="yes" xml:space="preserve">
          <source>Open a new cursor P1 to a transient table. The cursor is always opened read/write even if the main database is read-only. The ephemeral table is deleted automatically when the cursor is closed.</source>
          <target state="translated">새 커서 P1을 임시 테이블로여십시오. 기본 데이터베이스가 읽기 전용 인 경우에도 커서는 항상 읽기 / 쓰기로 열립니다. 임시 테이블은 커서를 닫으면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="545bc19bf66be6511144aed187f1840c5a4278d1" translate="yes" xml:space="preserve">
          <source>Open a new cursor that points to a fake table that contains a single row of data. The content of that one row is the content of memory register P2. In other words, cursor P1 becomes an alias for the MEM_Blob content contained in register P2.</source>
          <target state="translated">단일 데이터 행이 포함 된 가짜 테이블을 가리키는 새 커서를 엽니 다. 그 1 행의 내용은 메모리 레지스터 P2의 내용이다. 즉, 커서 P1은 레지스터 P2에 포함 된 MEM_Blob 내용의 별칭이됩니다.</target>
        </trans-unit>
        <trans-unit id="135ddb8c48350a0a78c4aa223b6b8ae16522c7fd" translate="yes" xml:space="preserve">
          <source>Open a read-only cursor for the database table whose root page is P2 in a database file. The database file is determined by P3. P3==0 means the main database, P3==1 means the database used for temporary tables, and P3&amp;gt;1 means used the corresponding attached database. Give the new cursor an identifier of P1. The P1 values need not be contiguous but all P1 values should be small integers. It is an error for P1 to be negative.</source>
          <target state="translated">데이터베이스 파일에서 루트 페이지가 P2 인 데이터베이스 테이블에 대한 읽기 전용 커서를여십시오. 데이터베이스 파일은 P3에 의해 결정됩니다. P3 == 0은 기본 데이터베이스를 의미하고 P3 == 1은 임시 테이블에 사용 된 데이터베이스를 의미하고 P3&amp;gt; 1은 해당하는 연결된 데이터베이스를 의미합니다. 새 커서에 P1의 식별자를 제공하십시오. P1 값은 연속적 일 필요는 없지만 모든 P1 값은 작은 정수 여야합니다. P1이 음수 인 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="84089bd01646e44fd57253086466eec04ccae47a" translate="yes" xml:space="preserve">
          <source>Open a read/write cursor named P1 on the table or index whose root page is P2 (or whose root page is held in register P2 if the OPFLAG_P2ISREG bit is set in P5 - see below).</source>
          <target state="translated">루트 페이지가 P2이거나 OPFLAG_P2ISREG 비트가 P5에 설정된 경우 루트 페이지가 레지스터 P2에 보유 된 테이블 또는 인덱스에서 이름이 P1 인 읽기 / 쓰기 커서를 엽니 다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="4063448157b3ab2686e1495793b9571ba748ea89" translate="yes" xml:space="preserve">
          <source>Open an RBU handle using the sqlite3rbu_open(T,A,S) function.</source>
          <target state="translated">sqlite3rbu_open (T, A, S) 함수를 사용하여 RBU 핸들을여십시오.</target>
        </trans-unit>
        <trans-unit id="596a83fa51ee88b7bacaba491d0bd9269153f384" translate="yes" xml:space="preserve">
          <source>Open database connections using the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces, as normal. Ordinary database files (without a checksum) will operate normally. Databases with checksums will return an SQLITE_IOERR_DATA error if a page is encountered that contains an invalid checksum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6423cf77a906b294f7ccb82649c19b9b21d337a4" translate="yes" xml:space="preserve">
          <source>Open file &quot;/home/fred/data.db&quot;. Use the special VFS &quot;unix-dotfile&quot; that uses dot-files in place of posix advisory locking.</source>
          <target state="translated">&quot;/home/fred/data.db&quot;파일을여십시오. posix 권고 잠금 대신 도트 파일을 사용하는 특수 VFS &quot;unix-dotfile&quot;을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d23dfc68fcbe2b64c96946a59f2391f88d879ada" translate="yes" xml:space="preserve">
          <source>Open file &quot;data.db&quot; in the current directory for read-only access. Regardless of whether or not shared-cache mode is enabled by default, use a private cache.</source>
          <target state="translated">읽기 전용 액세스를 위해 현재 디렉토리에서 &quot;data.db&quot;파일을여십시오. 공유 캐시 모드가 기본적으로 사용되는지 여부에 관계없이 개인 캐시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="32023375b26a0776fe1660f78af585c47d78b01e" translate="yes" xml:space="preserve">
          <source>Open the database file &quot;/home/fred/data.db&quot;.</source>
          <target state="translated">데이터베이스 파일 &quot;/home/fred/data.db&quot;를여십시오.</target>
        </trans-unit>
        <trans-unit id="b140126e4bb0c579baba79fa4b78910264cad628" translate="yes" xml:space="preserve">
          <source>Open the database file and obtain a SHARED lock. If the SHARED lock cannot be obtained, fail immediately and return SQLITE_BUSY.</source>
          <target state="translated">데이터베이스 파일을 열고 SHARED 잠금을 확보하십시오. SHARED 잠금을 확보 할 수 없으면 즉시 실패하고 SQLITE_BUSY를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="1fdbee3b0460b37f393d93c476774730b651cdaf" translate="yes" xml:space="preserve">
          <source>Open the file &quot;data.db&quot; in the current directory.</source>
          <target state="translated">현재 디렉토리에서 &quot;data.db&quot;파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="e305cdc0a6e58d2992d00df36114935a966f06eb" translate="yes" xml:space="preserve">
          <source>Open two cursors, one to each of the two tables being queried.</source>
          <target state="translated">쿼리중인 두 테이블 각각에 하나씩 두 개의 커서를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="db8828ea77768020acda7b34e1bdcfb01f4a650b" translate="yes" xml:space="preserve">
          <source>Open, release or rollback the savepoint named by parameter P4, depending on the value of P1. To open a new savepoint set P1==0 (SAVEPOINT_BEGIN). To release (commit) an existing savepoint set P1==1 (SAVEPOINT_RELEASE). To rollback an existing savepoint set P1==2 (SAVEPOINT_ROLLBACK).</source>
          <target state="translated">P1 값에 따라 매개 변수 P4로 명명 된 저장 점을 열거 나 해제하거나 롤백하십시오. 새 저장 점을 열려면 P1 == 0 (SAVEPOINT_BEGIN)을 설정하십시오. 기존 저장 점을 해제 (커밋)하려면 P1 == 1 (SAVEPOINT_RELEASE)을 설정하십시오. 기존 저장 점을 롤백하려면 P1 == 2 (SAVEPOINT_ROLLBACK)를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="e54c6e14fb4a075fa699ffdaaaf395ff313982e8" translate="yes" xml:space="preserve">
          <source>OpenAutoindex</source>
          <target state="translated">OpenAutoindex</target>
        </trans-unit>
        <trans-unit id="4102c59c0ab3f6e830e46718de359a59f628ee07" translate="yes" xml:space="preserve">
          <source>OpenDup</source>
          <target state="translated">OpenDup</target>
        </trans-unit>
        <trans-unit id="ad5bdfbe38582d74f4e2d987d0014c4a061fc0bc" translate="yes" xml:space="preserve">
          <source>OpenEphemeral</source>
          <target state="translated">OpenEphemeral</target>
        </trans-unit>
        <trans-unit id="4a5d4d0e6cf7c26b571b8ed8b7d9e91f5a55707c" translate="yes" xml:space="preserve">
          <source>OpenPseudo</source>
          <target state="translated">OpenPseudo</target>
        </trans-unit>
        <trans-unit id="321f145cb1e3470cc293ca452256220e4b476cbf" translate="yes" xml:space="preserve">
          <source>OpenRead</source>
          <target state="translated">OpenRead</target>
        </trans-unit>
        <trans-unit id="3894e594709a936290c9439b10b580db3b56e3b5" translate="yes" xml:space="preserve">
          <source>OpenWrite</source>
          <target state="translated">OpenWrite</target>
        </trans-unit>
        <trans-unit id="10f17177db5db183ce11fbbf98483043f8f93d13" translate="yes" xml:space="preserve">
          <source>Openclose callback</source>
          <target state="translated">오픈 클로즈 콜백</target>
        </trans-unit>
        <trans-unit id="f1ba5b2c8dba45952ee1dd4e3e5587becf1e4832" translate="yes" xml:space="preserve">
          <source>Opening A New Database Connection</source>
          <target state="translated">새로운 데이터베이스 연결 열기</target>
        </trans-unit>
        <trans-unit id="8bea067fa84f98eb8cb08b76d377cd2759d84a48" translate="yes" xml:space="preserve">
          <source>Opening a New Connection</source>
          <target state="translated">새로운 연결 열기</target>
        </trans-unit>
        <trans-unit id="0fcdc2f790b5b05c0b11e1b00c614a1147af7a65" translate="yes" xml:space="preserve">
          <source>Opening a Read-Only Transaction</source>
          <target state="translated">읽기 전용 트랜잭션 열기</target>
        </trans-unit>
        <trans-unit id="8c328ea219e123938753dd011cc218695e36770e" translate="yes" xml:space="preserve">
          <source>Opening a connection.</source>
          <target state="translated">연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="0a848c1fa6f5b691a8b43871dbf9920b32a63f8f" translate="yes" xml:space="preserve">
          <source>Opening a new database connection is a two-step process:</source>
          <target state="translated">새 데이터베이스 연결을 여는 것은 두 단계 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="60a2e026abe5554a6164ccf369d3bdb712d462a6" translate="yes" xml:space="preserve">
          <source>Opening a read-only transaction.</source>
          <target state="translated">읽기 전용 트랜잭션을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d0a97ec8f1b3b761b48ba3f0b5793b7b063cf28e" translate="yes" xml:space="preserve">
          <source>Opening a read-write transaction.</source>
          <target state="translated">읽기-쓰기 트랜잭션을 여는 중입니다.</target>
        </trans-unit>
        <trans-unit id="5bef4a855a587c7ae88d0d6e7fbc4f0cf1d92d9c" translate="yes" xml:space="preserve">
          <source>Opening a statement transaction.</source>
          <target state="translated">명세서 거래를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="5f6fc2590106eab5d853e4838b574315ff3651ac" translate="yes" xml:space="preserve">
          <source>Operand P1 must be 0x7fffffff and P2 must positive.</source>
          <target state="translated">피연산자 P1은 0x7fffffff이고 P2는 양수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d0e687b079fb70f2208d1f8d2c75d64d74925496" translate="yes" xml:space="preserve">
          <source>Operator</source>
          <target state="translated">Operator</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="653e79b2411d60c991c837c40648dc99da326979" translate="yes" xml:space="preserve">
          <source>Optimization: When doing an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; on a table with &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;, do not update the expression indexes if they do not refer to any of the columns of the table being updated.</source>
          <target state="translated">최적화 : &lt;a href=&quot;expridx&quot;&gt;expressions에 인덱스가&lt;/a&gt; 있는 테이블 에서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 를 수행 할 때 업데이트 되는 테이블 의 컬럼을 참조하지 않는 경우 표현식 인덱스를 업데이트하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a794f9704b3031ad0771d79793775c086e03f157" translate="yes" xml:space="preserve">
          <source>Optimizations to the sqlite_mprintf() routine.</source>
          <target state="translated">sqlite_mprintf () 루틴에 대한 최적화.</target>
        </trans-unit>
        <trans-unit id="088089a3961fc329e20285999528f0da0604b13a" translate="yes" xml:space="preserve">
          <source>Optimize the &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#length&quot;&gt;length()&lt;/a&gt; SQL functions so that they avoid unnecessary reading of database content from disk.</source>
          <target state="translated">디스크에서 데이터베이스 내용을 불필요하게 읽지 않도록 &lt;a href=&quot;lang_corefunc#typeof&quot;&gt;typeof ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#length&quot;&gt;length ()&lt;/a&gt; SQL 함수를 최적화하십시오 .</target>
        </trans-unit>
        <trans-unit id="89ea4f0e94546aba0e6576de32f5af050f08375b" translate="yes" xml:space="preserve">
          <source>Optimizer does a better job of using indices to satisfy ORDER BY clauses that sort on the integer primary key</source>
          <target state="translated">옵티마이 저는 정수 기본 키를 기준으로 정렬하는 ORDER BY 절을 만족시키기 위해 인덱스를 더 잘 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d859dd72c637fafc6319ca0f4f6cb8c1fd01736f" translate="yes" xml:space="preserve">
          <source>Optimizer enhancement: &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; are automatically re-compiled when a binding on the RHS of a LIKE operator changes or when any range constraint changes under &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;.</source>
          <target state="translated">최적화 개선 : LIKE 연산자의 RHS에 대한 바인딩이 변경되거나 &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 에서 범위 제한이 변경 될 때 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 자동으로 다시 컴파일됩니다 .</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="6120d3ea8f989e319fa4157b88a6894abd99ea8b" translate="yes" xml:space="preserve">
          <source>Option 1:</source>
          <target state="translated">옵션 1:</target>
        </trans-unit>
        <trans-unit id="787636b9cef675727f97423a49f2d6e8aeb5b354" translate="yes" xml:space="preserve">
          <source>Option 2:</source>
          <target state="translated">옵션 2 :</target>
        </trans-unit>
        <trans-unit id="620a38bc45cce1e89bad8abed95cee233ec74ca8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY Clauses</source>
          <target state="translated">선택적 LIMIT 및 ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="4a8101f15dc88fa6899984a679049286645dada8" translate="yes" xml:space="preserve">
          <source>Optional LIMIT and ORDER BY clauses</source>
          <target state="translated">선택적 LIMIT 및 ORDER BY 절</target>
        </trans-unit>
        <trans-unit id="147fccad2acf5d54cf4c9bd90959d2b685bb12a8" translate="yes" xml:space="preserve">
          <source>Optional READ UNCOMMITTED isolation (instead of the default isolation level of SERIALIZABLE) and table level locking when database connections share a common cache.</source>
          <target state="translated">데이터베이스 연결이 공통 캐시를 공유 할 때 선택적 COMM UNCOMMITTED 격리 (기본 격리 수준 인 SERIALIZABLE 대신) 및 테이블 수준 잠금.</target>
        </trans-unit>
        <trans-unit id="99e39e3c25d749e303cfb0392ac6108be81a9ed0" translate="yes" xml:space="preserve">
          <source>Optionally, a &lt;a href=&quot;gencol&quot;&gt;generated column&lt;/a&gt; constraint.</source>
          <target state="translated">선택적으로 &lt;a href=&quot;gencol&quot;&gt;생성 된 열&lt;/a&gt; 제약 조건입니다.</target>
        </trans-unit>
        <trans-unit id="f3c4d258c19e0b0e32f1a0047f810a58bf67a8d7" translate="yes" xml:space="preserve">
          <source>Optionally, a PRIMARY KEY for the table. Both single column and composite (multiple column) primary keys are supported.</source>
          <target state="translated">선택적으로 테이블의 기본 키입니다. 단일 열과 복합 (다중 열) 기본 키가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="afb65b09ecb1abf655b3870806d0d663e9055759" translate="yes" xml:space="preserve">
          <source>Options understood by the &lt;b&gt;sqlite3&lt;/b&gt; command include:</source>
          <target state="translated">&lt;b&gt;sqlite3&lt;/b&gt; 명령으로 이해되는 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="1a5a89789f35d1adc160640f07b04eccb062e675" translate="yes" xml:space="preserve">
          <source>Or consider these identical queries:</source>
          <target state="translated">또는 다음과 동일한 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="16127303ea06cc226e15f6d081becfc0853f54f2" translate="yes" xml:space="preserve">
          <source>Or go the other way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa8e4bd6460fbb4edd20d4ab7cc84cb756c25fa7" translate="yes" xml:space="preserve">
          <source>Or on Windows with MSVC:</source>
          <target state="translated">또는 MSVC가있는 Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="65cc0e4d32009c846d3d67b851864fc0e2100eac" translate="yes" xml:space="preserve">
          <source>Or optimization</source>
          <target state="translated">또는 최적화</target>
        </trans-unit>
        <trans-unit id="fbfd8b5435e1bb1225c27564f4e61467d6052b3a" translate="yes" xml:space="preserve">
          <source>Or perhaps the application would rather use the most recent checkinTime:</source>
          <target state="translated">또는 아마도 응용 프로그램은 가장 최근의 checkinTime을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2a55f1def49ba2cf28edd04aebe0ae914d6adc01" translate="yes" xml:space="preserve">
          <source>Or this:</source>
          <target state="translated">아니면 이거:</target>
        </trans-unit>
        <trans-unit id="4adffe1f4f67467b27dd86bae1fcc140644a1e80" translate="yes" xml:space="preserve">
          <source>Or to be extra safe with a database and to force SQLite to assume the database lacks powersafe overwrite, open it using</source>
          <target state="translated">또는 데이터베이스를 더욱 안전하게 보호하고 SQLite가 데이터베이스에 전원 안전 덮어 쓰기가 없다고 가정하도록하려면</target>
        </trans-unit>
        <trans-unit id="cb4a4efee56406c1c1e484f479dafaa1ce0d3fdd" translate="yes" xml:space="preserve">
          <source>Or using &lt;a href=&quot;cli#fileio&quot;&gt;file I/O functions&lt;/a&gt;, you can extract elements of the ZIP archive:</source>
          <target state="translated">또는 &lt;a href=&quot;cli#fileio&quot;&gt;파일 I / O 기능&lt;/a&gt; 을 사용하여 ZIP 아카이브의 요소를 추출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb6e4abd1b3ea2eadafe45050288632422b5468" translate="yes" xml:space="preserve">
          <source>Or,</source>
          <target state="translated">Or,</target>
        </trans-unit>
        <trans-unit id="66d567cd524d8ab999d4e199670d77fab66ce1bc" translate="yes" xml:space="preserve">
          <source>Or, from the SQLite shell tool (the &lt;a href=&quot;cli#fileio&quot;&gt;readfile()&lt;/a&gt; function reads the contents of a file from the file-system and returns it as a blob):</source>
          <target state="translated">또는 SQLite 쉘 도구에서 ( &lt;a href=&quot;cli#fileio&quot;&gt;readfile ()&lt;/a&gt; 함수는 파일 시스템에서 파일 내용을 읽고이를 블롭으로 리턴합니다).</target>
        </trans-unit>
        <trans-unit id="5555ca89e43c2c41b68ce29dd846f696f04f9021" translate="yes" xml:space="preserve">
          <source>Or, if argument zTab is NULL, then changes are recorded for all tables in the database. If additional tables are added to the database (by executing &quot;CREATE TABLE&quot; statements) after this call is made, changes for the new tables are also recorded.</source>
          <target state="translated">또는 zTab 인수가 NULL이면 데이터베이스의 모든 테이블에 대한 변경 사항이 기록됩니다. 이 호출 후 추가 테이블이 데이터베이스에 추가되면 ( &quot;CREATE TABLE&quot;문을 실행하여) 새 테이블에 대한 변경 사항도 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="0aca97133f8a0b1812de40afe8dc2efdb01e49c8" translate="yes" xml:space="preserve">
          <source>Or, if double-quoted string literals are disabled by default, but need to be selectively enabled for some historical database connections, that can be done using the same C-code as shown above except with the third parameter changed from 0 to 1.</source>
          <target state="translated">또는 큰 따옴표로 묶인 문자열 리터럴이 기본적으로 비활성화되어 있지만 일부 히스토리 데이터베이스 연결에 대해 선택적으로 활성화해야하는 경우, 세 번째 매개 변수가 0에서 1로 변경된 경우를 제외하고는 위에 표시된 것과 동일한 C 코드를 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="322edc10740abf86eb6c1728491b5451dec39f1d" translate="yes" xml:space="preserve">
          <source>Or, if sqlite3.c is compiled using some other build system, by arranging for the SQLITE_ENABLE_FTS5 pre-processor symbol to be defined.</source>
          <target state="translated">또는 sqlite3.c가 다른 빌드 시스템을 사용하여 컴파일되는 경우 SQLITE_ENABLE_FTS5 전 처리기 기호를 정의하여 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="658f77f8eef94489e4209dc1e50f66504ceb72eb" translate="yes" xml:space="preserve">
          <source>Or, if the argument attached to the REINDEX identifies a specific database table, then all indices attached to the database table are rebuilt. If it identifies a specific database index, then just that index is recreated.</source>
          <target state="translated">또는 REINDEX에 첨부 된 인수가 특정 데이터베이스 테이블을 식별하면 데이터베이스 테이블에 첨부 된 모든 인덱스가 재 빌드됩니다. 특정 데이터베이스 인덱스를 식별하면 해당 인덱스 만 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="60a5aae7483ffe81235af01c0cffa5d4ff23cd22" translate="yes" xml:space="preserve">
          <source>Or, if the table is also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, then the following apply:</source>
          <target state="translated">또는 테이블이 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless 테이블&lt;/a&gt; 인 경우 다음이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="aa1077574bb502a8689f667cb965b8e30b1c1e85" translate="yes" xml:space="preserve">
          <source>Or, if using the autoconf build system, pass the --enable-session option to the configure script.</source>
          <target state="translated">또는 autoconf 빌드 시스템을 사용하는 경우 --enable-session 옵션을 configure 스크립트에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="0ff802a22b003329b02ab696a2c315faad2a0e85" translate="yes" xml:space="preserve">
          <source>Or, multiple presentations could be stored within the same document.</source>
          <target state="translated">또는 여러 프레젠테이션을 동일한 문서에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d354f2e196d0e9cdbbdd8e5133631fe7bd7c69f7" translate="yes" xml:space="preserve">
          <source>Or, the same content can be read using:</source>
          <target state="translated">또는 다음을 사용하여 동일한 내용을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7aee41fb363d46e588ad49a1b5591b283e863a6" translate="yes" xml:space="preserve">
          <source>Or, to list all changes to one particular account ($xyz) in order of decreasing magnitude, one can write:</source>
          <target state="translated">또는 규모가 작은 순서대로 하나의 특정 계정 ($ xyz)에 대한 모든 변경 사항을 나열하려면 다음과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1681e612a2025087b703fdf1f8f617e506b053" translate="yes" xml:space="preserve">
          <source>Oracle</source>
          <target state="translated">Oracle</target>
        </trans-unit>
        <trans-unit id="6e8727d6e68eed5d20f3fa889a8e8b2bd24438db" translate="yes" xml:space="preserve">
          <source>Orders of magnitude performance improvement for &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; on very large tables.</source>
          <target state="translated">매우 큰 테이블에서 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX의&lt;/a&gt; 성능이 크게 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce3fb54d989f83f97843b164388df9c55d52716" translate="yes" xml:space="preserve">
          <source>Ordinary Common Table Expressions</source>
          <target state="translated">일반적인 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="628b6d597a836775d3c57cc85ac20362e62df83f" translate="yes" xml:space="preserve">
          <source>Ordinary SQL statements are free-form, and can be spread across multiple lines, and can have whitespace and comments anywhere. Dot-commands are more restrictive:</source>
          <target state="translated">일반적인 SQL 문은 자유 형식이며 여러 줄로 분산 될 수 있으며 어디에서나 공백과 주석을 가질 수 있습니다. 도트 명령이 더 제한적입니다.</target>
        </trans-unit>
        <trans-unit id="410efca163172750b4e7d07d3df715195f75df04" translate="yes" xml:space="preserve">
          <source>Ordinary common table expressions</source>
          <target state="translated">일반적인 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="d3bfeb484e7ad7fe55b8281bb0d45da13e3151eb" translate="yes" xml:space="preserve">
          <source>Original content of the page prior to the start of the transaction</source>
          <target state="translated">거래 시작 전 페이지의 원본 콘텐츠</target>
        </trans-unit>
        <trans-unit id="53583b5aa5fa79b35a37fe615fa3d9b1eece6568" translate="yes" xml:space="preserve">
          <source>Other C-libraries that process complex structured inputs will routinely be asked to deal with unvetted inputs from untrusted sources. Libraries like libjpeg, or libzip, or OpenSSL are handed input streams that come directly from potentially hostile agents.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="220b92a9851d65e3f5763bc585c592d7a14215e7" translate="yes" xml:space="preserve">
          <source>Other Issues</source>
          <target state="translated">다른 문제</target>
        </trans-unit>
        <trans-unit id="286c105cf7e1fc8242c5f069e4037b0e5e35102f" translate="yes" xml:space="preserve">
          <source>Other SQL database engines tend to store data as a large collection of files. Often these files are in a standard location that only the database engine itself can access. This makes the data more secure, but also makes it harder to access. Some SQL database engines provide the option of writing directly to disk and bypassing the filesystem all together. This provides added performance, but at the cost of considerable setup and maintenance complexity.</source>
          <target state="translated">다른 SQL 데이터베이스 엔진은 데이터를 큰 파일 모음으로 저장하는 경향이 있습니다. 종종 이러한 파일은 데이터베이스 엔진 자체 만 액세스 할 수있는 표준 위치에 있습니다. 이로 인해 데이터가 더 안전 해지지 만 액세스하기가 더 어려워집니다. 일부 SQL 데이터베이스 엔진은 디스크에 직접 쓰고 파일 시스템을 우회하는 옵션을 제공합니다. 이는 추가 성능을 제공하지만 설치 및 유지 관리가 상당히 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="5210f14e159e526b00e7b67ae5e00a7489e472f8" translate="yes" xml:space="preserve">
          <source>Other and more complex extensions can be found in subfolders under &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;ext/&lt;/a&gt; other than ext/misc/.</source>
          <target state="translated">다른 더 복잡한 확장에 따라 하위 폴더에서 찾을 수 있습니다 &lt;a href=&quot;https://www.sqlite.org/src/file/ext&quot;&gt;내선 /&lt;/a&gt; 내선 / 기타 / 이외.</target>
        </trans-unit>
        <trans-unit id="a5885d7d219a9dd314e80ea53c10a7870f48702f" translate="yes" xml:space="preserve">
          <source>Other compile-time options such as using -O3 instead of -Os or using &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; and/or some of the other &lt;a href=&quot;compile#rcmd&quot;&gt;recommended compile-time options&lt;/a&gt; might help SQLite to run even faster relative to direct filesystem reads.</source>
          <target state="translated">&lt;a href=&quot;compile#threadsafe&quot;&gt;-O&lt;/a&gt; 대신 -O3 사용 또는 -DSQLITE_THREADSAFE = 0 사용 및 / 또는 다른 &lt;a href=&quot;compile#rcmd&quot;&gt;권장 컴파일 시간 옵션&lt;/a&gt; 과 같은 다른 컴파일 시간 옵션 은 SQLite가 직접 파일 시스템 읽기에 비해 훨씬 빠르게 실행하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a8c532629b4cb41be7b1e40786ac6ad241781e" translate="yes" xml:space="preserve">
          <source>Other database engines may run great once you get them going. But doing the initial installation and configuration can often be intimidating.</source>
          <target state="translated">다른 데이터베이스 엔진은 일단 실행하면 훌륭하게 실행될 수 있습니다. 그러나 초기 설치 및 구성을 수행하는 것은 종종 위협적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d3a3415efe071d534d2ab15cd7fe976055daeb3" translate="yes" xml:space="preserve">
          <source>Other entries in the cost table specific transforms for particular characters. The cost of specific transforms should be less than the default costs, or else the default costs will take precedence and the specific transforms will never be used.</source>
          <target state="translated">비용 표의 다른 항목은 특정 문자를 변환합니다. 특정 변환 비용은 기본 비용보다 낮아야합니다. 그렇지 않으면 기본 비용이 우선하며 특정 변환은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ac3c9882a4b70189ad1bfa57e91f5a096b4d423" translate="yes" xml:space="preserve">
          <source>Other examples:</source>
          <target state="translated">다른 예 :</target>
        </trans-unit>
        <trans-unit id="cae24656c6711756dea7bb8cd35f3afb8c810eb8" translate="yes" xml:space="preserve">
          <source>Other experimental memory allocators might be added in future releases of SQLite. One may anticipate that these will be called memsys7, memsys8, and so forth.</source>
          <target state="translated">다른 실험용 메모리 할당자는 향후 SQLite 릴리스에 추가 될 수 있습니다. 이들을 memsys7, memsys8 등이라고 부를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10c1a85e8f6e1ba9ad67291c0e509d27f0146a7c" translate="yes" xml:space="preserve">
          <source>Other important bug fixes</source>
          <target state="translated">다른 중요한 버그 수정</target>
        </trans-unit>
        <trans-unit id="eafff73d48037ade49167d838ce6e1b6a891fb16" translate="yes" xml:space="preserve">
          <source>Other information fields of the sqlite3_rtree_query_info structure are available for use by the xQueryFunc callback, if desired. The iRowid field is the rowid (the first of the 3 to 11 columns in the R*Tree) for the element being considered. iRowid is only valid for leaves. The eParentWithin and rParentScore values are copies of the eWithin and rScore values from the containing subtree of the current row. The anQueue field is an array of mxLevel+1 unsigned integers that tell the current number of elements in the priority queue at each level.</source>
          <target state="translated">sqlite3_rtree_query_info 구조의 다른 정보 필드는 원하는 경우 xQueryFunc 콜백에서 사용할 수 있습니다. iRowid 필드는 고려중인 요소의 rowid (R * Tree에서 3-11 개의 열 중 첫 번째)입니다. iRowid는 잎에만 유효합니다. eParentWithin 및 rParentScore 값은 현재 행의 포함 서브 트리에서 eWithin 및 rScore 값의 사본입니다. anQueue 필드는 각 레벨에서 우선 순위 큐에있는 현재 요소 수를 알려주는 mxLevel + 1 부호없는 정수의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ac116740090073aa7d395dd931c8587b7e5ed819" translate="yes" xml:space="preserve">
          <source>Other kinds of constraints may be used and will work, but other constraints will be checked individually for each row and will not be optimized (at least not initially). All constraint checking is completely automatic regardless of whether or not optimization occurs. The optimization referred to in this bullet point is a performance consideration only. The same result is obtained regardless of whether or not the query is optimized.</source>
          <target state="translated">다른 종류의 제약 조건이 사용될 수 있지만 작동하지만 다른 제약 조건은 각 행에 대해 개별적으로 검사되며 최적화되지 않습니다 (최소한 초기에는 아님). 모든 제약 조건 검사는 최적화 발생 여부에 관계없이 완전히 자동입니다. 이 글 머리 기호에 언급 된 최적화는 성능 고려 사항 일뿐입니다. 쿼리 최적화 여부에 관계없이 동일한 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="aea1c45528f91c41cd64bff7bc4b9fe5c5d9e390" translate="yes" xml:space="preserve">
          <source>Other languages like Java, Perl, Python, and TCL typically translate the program source text into bytecode. This bytecode is then run through an interpreter that reads the bytecode and carries out the desired operations. SQLite uses this bytecode approach. If you preceed any SQL statement with the &quot;&lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;&quot; keyword in SQLite, it will show you the bytecode that is generated rather than run the bytecode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808f70785d1ef92ea5c6148eaa9481e6d0e14aa1" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="254b17e4c2182837b7ef0fdd5b3824e226f2c5a8" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2e591c11c09005f92f16a4e53401bee7662b02" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d410006003e6c96fa23b1a96739384d30f239" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;constlist&quot;&gt;Constants&lt;/a&gt; and &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;constlist&quot;&gt;상수&lt;/a&gt; 및 &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0c16f3fd55dac69e3748a6c043c6447d6ab575" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt; and &lt;a href=&quot;../rescode&quot;&gt;Result Codes&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; 및 &lt;a href=&quot;../rescode&quot;&gt;결과 코드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce8676972cf44ad111328d5252187ad79820f8b7" translate="yes" xml:space="preserve">
          <source>Other lists: &lt;a href=&quot;objlist&quot;&gt;Objects&lt;/a&gt; and &lt;a href=&quot;funclist&quot;&gt;Functions&lt;/a&gt;.</source>
          <target state="translated">다른 목록 : &lt;a href=&quot;objlist&quot;&gt;객체&lt;/a&gt; 및 &lt;a href=&quot;funclist&quot;&gt;함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05129b6c75ff832aa70dbb2deb9f7c3bddb6dc" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes</source>
          <target state="translated">기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="d4fc03a4fb1eb22ede8954ef99eea86a034ae6d2" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements</source>
          <target state="translated">기타 사소한 버그 수정 및 설명서 향상</target>
        </trans-unit>
        <trans-unit id="890b3d475caba8d5bd7557f9c475d8af3c752a15" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and documentation enhancements.</source>
          <target state="translated">기타 사소한 버그 수정 및 설명서 향상.</target>
        </trans-unit>
        <trans-unit id="aa1b8c87b3d167a75e9df291742b29d3051fb50c" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance enhancements.</source>
          <target state="translated">기타 사소한 버그 수정 및 성능 향상</target>
        </trans-unit>
        <trans-unit id="0fa68e95547b847335553befa0f2cb7b67624587" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes and performance optimizations.</source>
          <target state="translated">기타 사소한 버그 수정 및 성능 최적화</target>
        </trans-unit>
        <trans-unit id="1057a4540e5ed3386909678e9ca548cf6300a507" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes in preparation for the first stable release of version 3.3</source>
          <target state="translated">버전 3.3의 첫 번째 안정적인 릴리스를 준비하는 기타 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="f58ff693cc659b1eb66fa3445ac112f3a975e0d7" translate="yes" xml:space="preserve">
          <source>Other minor bug fixes.</source>
          <target state="translated">기타 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="3d1e22329a4cb1219246e265a7a252a723c9d5fa" translate="yes" xml:space="preserve">
          <source>Other minor changes and enhancements.</source>
          <target state="translated">기타 사소한 변경 및 개선.</target>
        </trans-unit>
        <trans-unit id="251ead6fb529a54fa107bbdc4f76c0af651e9179" translate="yes" xml:space="preserve">
          <source>Other minor compiler-warning fixes and whatnot.</source>
          <target state="translated">기타 사소한 컴파일러 경고 수정 및 기타.</target>
        </trans-unit>
        <trans-unit id="deee6da4efcaf54f2a7bee650d4c13bb508dfa45" translate="yes" xml:space="preserve">
          <source>Other minor documentation and makefile changes and bug fixes.</source>
          <target state="translated">기타 사소한 문서 및 makefile 변경 및 버그 수정</target>
        </trans-unit>
        <trans-unit id="031aa8e8c99846cb30787089a75b424566d207ca" translate="yes" xml:space="preserve">
          <source>Other minor tweaks to improve the quality of &lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; code.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;VDBE&lt;/a&gt; 코드 의 품질을 향상시키기위한 기타 미세 조정 .</target>
        </trans-unit>
        <trans-unit id="8b05e7277715773ceabf87f5e50fad5de6b24dd9" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes</source>
          <target state="translated">기타 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="5d73e7d5d87f0b601b3cbf8f19cc97602a0f29c4" translate="yes" xml:space="preserve">
          <source>Other miscellaneous bug fixes.</source>
          <target state="translated">기타 기타 버그 수정</target>
        </trans-unit>
        <trans-unit id="4b8124041770cac5d89ae555b4ac03153c37ffc1" translate="yes" xml:space="preserve">
          <source>Other miscellaneous enhancements such as loop unrolling.</source>
          <target state="translated">루프 언 롤링과 같은 기타 기타 개선 사항.</target>
        </trans-unit>
        <trans-unit id="6f62eac50d6703d3917c9f2154f9f77dce98abcd" translate="yes" xml:space="preserve">
          <source>Other miscellaneous micro-optimizations for improved performance and reduced memory usage.</source>
          <target state="translated">성능 향상 및 메모리 사용량 감소를위한 기타 기타 마이크로 최적화.</target>
        </trans-unit>
        <trans-unit id="26485a453cc99f6d07c9ad5f2979b799b10596af" translate="yes" xml:space="preserve">
          <source>Other miscellaneous minor bug fixes.</source>
          <target state="translated">기타 기타 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="583fac43540a1c8647f7a52c63c6d87ee3c57112" translate="yes" xml:space="preserve">
          <source>Other miscellaneous performance enhancements.</source>
          <target state="translated">기타 기타 성능 향상</target>
        </trans-unit>
        <trans-unit id="d5335cc4f60749bd941dc9764ef3c6855a7a176b" translate="yes" xml:space="preserve">
          <source>Other more familiar database engines run great once you get them going. But doing the initial installation and configuration can be intimidatingly complex.</source>
          <target state="translated">친숙한 다른 데이터베이스 엔진은 일단 실행하면 훌륭하게 실행됩니다. 그러나 초기 설치 및 구성은 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62a6e61f5dec5bfc458e9cb92c78c02e716a2af" translate="yes" xml:space="preserve">
          <source>Other output modes include &quot;html&quot;, &quot;json&quot;, and &quot;tcl&quot;. Try these yourself to see what they do.</source>
          <target state="translated">다른 출력 모드에는 &quot;html&quot;, &quot;json&quot;및 &quot;tcl&quot;이 있습니다. 그들이 무엇을하는지 직접 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="453575f6d5ccd906017a354a3747a73c275dcbf4" translate="yes" xml:space="preserve">
          <source>Other pages that talk about Fossil and Git include:</source>
          <target state="translated">화석과 Git에 관한 다른 페이지는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1691c79ed589685ad615d8d10ce5d4a24f7887ad" translate="yes" xml:space="preserve">
          <source>Other performance improvements. Uses about &lt;a href=&quot;cpu&quot;&gt;6.5% fewer CPU cycles&lt;/a&gt;.</source>
          <target state="translated">다른 성능 향상. 약 &lt;a href=&quot;cpu&quot;&gt;6.5 % 적은 CPU주기를 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="53a9f15c17fc6f690db9ec48e6c595c7787f86a9" translate="yes" xml:space="preserve">
          <source>Other performance optimizations:</source>
          <target state="translated">다른 성능 최적화 :</target>
        </trans-unit>
        <trans-unit id="a62bf7250068b9b0c4a25d2045a53dbb9795b912" translate="yes" xml:space="preserve">
          <source>Other programming languages sometimes claim to be &quot;as fast as C&quot;. But no other language claims to be faster than C for general-purpose programming, because none are.</source>
          <target state="translated">다른 프로그래밍 언어는 때때로 &quot;C만큼 빠르다&quot;고 주장합니다. 그러나 다른 언어는 범용 프로그래밍에서 C보다 빠르다고 주장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="400864fb9a5435081d0153c603d26034407232fd" translate="yes" xml:space="preserve">
          <source>Other relation database engines also implement UPDATE-FROM, but because the construct is not part of the SQL standards, each product implements UPDATE-FROM differently. The SQLite implementation strives to be compatible with PostgreSQL. The SQL Server and MySQL implementations of the same idea work a little differently.</source>
          <target state="translated">다른 관계 데이터베이스 엔진도 UPDATE-FROM을 구현하지만 구성이 SQL 표준의 일부가 아니기 때문에 각 제품은 UPDATE-FROM을 다르게 구현합니다. SQLite 구현은 PostgreSQL과 호환되도록 노력합니다. 동일한 아이디어의 SQL Server 및 MySQL 구현은 약간 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b724fba24bcbd81609e47345dfce9dfa38bb53b6" translate="yes" xml:space="preserve">
          <source>Other similar tree-display routines include:</source>
          <target state="translated">다른 유사한 트리 표시 루틴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="eb0b09bd0abc9cbcebf776931eb89745e9f2f6c6" translate="yes" xml:space="preserve">
          <source>Other small bug fixes and optimizations.</source>
          <target state="translated">기타 작은 버그 수정 및 최적화</target>
        </trans-unit>
        <trans-unit id="ce257a3574985ec3c0e88eff4d14f53603f86d62" translate="yes" xml:space="preserve">
          <source>Other systems sometimes use assert(X) in a way that is similar to the use of ALWAYS(X) or NEVER(X) in SQLite. Developers will add an assert(X) as a &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;tacit acknowledgement that they do not fully believe that X is always true&lt;/a&gt;. We believe that this use of assert(X) is wrong and violates the intent and purpose of having assert(X) available in C in the first place. An assert(X) should not be seen as a safety-net or top-rope used to guard against mistakes. Nor is assert(X) appropriate for defense-in-depth. An ALWAYS(X) or NEVER(X) macro, or something similar, should be used in those cases because ALWAYS(X) or NEVER(X) will be followed by code to actually deal with the problem when the programmers reasoning turns out to be wrong. Since the code that follows ALWAYS(X) or NEVER(X) is untested, it should be something very simple, like a &quot;return&quot; statement, that is easily verified by inspection.</source>
          <target state="translated">다른 시스템은 때때로 SQLite에서 ALWAYS (X) 또는 NEVER (X)를 사용하는 것과 유사한 방식으로 assert (X)를 사용합니다. 개발자는 &lt;a href=&quot;https://blog.regehr.org/archives/1576&quot;&gt;X가 항상 참이라고 완전히 믿지 않는다는 암묵적 인정&lt;/a&gt; 으로 assert (X)를 추가 합니다.. 우리는 assert (X)의 사용이 잘못되었고 C에서 assert (X)를 사용할 수있는 의도와 목적을 위반한다고 생각합니다. assert (X)는 실수로부터 보호하기 위해 사용되는 안전망 또는 상단 로프로 간주되어서는 안됩니다. 심층 방어에는 assert (X)도 적합하지 않습니다. 프로그래머가 추론을 할 때 ALWAYS (X) 또는 NEVER (X) 매크로 또는 이와 유사한 것을 사용해야합니다. 틀리다. ALWAYS (X) 또는 NEVER (X)를 따르는 코드는 테스트되지 않았으므로 검사를 통해 쉽게 확인할 수있는 &quot;return&quot;문과 같이 매우 단순해야합니다.</target>
        </trans-unit>
        <trans-unit id="34d2c9c7d77d063050411b9cf0d5ad05916eb325" translate="yes" xml:space="preserve">
          <source>Otherwise, an expression has no affinity.</source>
          <target state="translated">그렇지 않으면 표현식에 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6917a7f5da3062b0cb87b819a1b98dde64d2060e" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">그렇지 않으면 오류가 발생하지 않으면 &lt;a href=&quot;#sqlite3_db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; 는 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63ffff1a975b81be129a4faecffea464b53159fd" translate="yes" xml:space="preserve">
          <source>Otherwise, if no error occurs, &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; returns SQLITE_OK.</source>
          <target state="translated">그렇지 않으면 오류가 발생하지 않으면 &lt;a href=&quot;db_cacheflush&quot;&gt;sqlite3_db_cacheflush ()&lt;/a&gt; 는 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f4554128dd35917d0080717168dbd2c249f00b56" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is a column or an alias of an expression that is a column, then the default collation sequence for the column is used.</source>
          <target state="translated">그렇지 않으면, ORDER BY 표현식이 컬럼이거나 컬럼 인 표현식의 별명 인 경우, 컬럼의 기본 조합 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e53078a08397e14f15e969e1f704be9f2cd8b70" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is an alias to an expression that has been assigned a collation sequence using the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;, then the collation sequence assigned to the aliased expression is used.</source>
          <target state="translated">그렇지 않으면 ORDER BY 표현식이 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 를 사용하여 데이터 정렬 시퀀스에 지정된 표현식의 별명 인 경우 별명 지정된 표현식에 지정된 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16e19790e123dd698bb68d8acfc3c250ddf0f26c" translate="yes" xml:space="preserve">
          <source>Otherwise, if the ORDER BY expression is any other expression, it is evaluated and the returned value used to order the output rows. If the SELECT statement is a simple SELECT, then an ORDER BY may contain any arbitrary expressions. However, if the SELECT is a compound SELECT, then ORDER BY expressions that are not aliases to output columns must be exactly the same as an expression used as an output column.</source>
          <target state="translated">그렇지 않으면 ORDER BY 표현식이 다른 표현식 인 경우 평가되고 리턴 된 값이 출력 행을 정렬하는 데 사용됩니다. SELECT 문이 단순 SELECT 인 경우 ORDER BY는 임의의 표현식을 포함 할 수 있습니다. 그러나 SELECT가 복합 SELECT 인 경우 출력 컬럼의 별명이 아닌 ORDER BY 표현식은 출력 컬럼으로 사용되는 표현식과 정확히 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="74d7943e809a432b89e323d15537e7de75d402f8" translate="yes" xml:space="preserve">
          <source>Otherwise, no affinity is applied and both operands are compared as is.</source>
          <target state="translated">그렇지 않으면 선호도가 적용되지 않고 두 피연산자가 그대로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="ace2ae60f4f3efb9070beb6a2fed407ad7cd8e65" translate="yes" xml:space="preserve">
          <source>Otherwise, r[P2] is set to the sum of r[P1] and r[P3].</source>
          <target state="translated">그렇지 않으면 r [P2]는 r [P1]과 r [P3]의 합으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d8794c47ac5fbe000cffe629c489a9791ed713" translate="yes" xml:space="preserve">
          <source>Otherwise, the &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; collation sequence is used.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;datatype3#collation&quot;&gt;BINARY&lt;/a&gt; 데이터 정렬 시퀀스가 ​​사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35b896906bdef712969f9e7297c680f9a2e53cd3" translate="yes" xml:space="preserve">
          <source>Otherwise, the BINARY collating function is used for comparison.</source>
          <target state="translated">그렇지 않으면 BINARY 조합 기능이 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="638ab872140702484af1c059aebc57de13dbd98b" translate="yes" xml:space="preserve">
          <source>Otherwise, the affinity is NUMERIC.</source>
          <target state="translated">그렇지 않으면 선호도는 NUMERIC입니다.</target>
        </trans-unit>
        <trans-unit id="cfc6f8803bf4c712ac864728c4305aa6942d9a6a" translate="yes" xml:space="preserve">
          <source>Otherwise, the value inserted into this field is the file contents for a regular file, or the target of a symbolic link.</source>
          <target state="translated">그렇지 않으면이 필드에 삽입 된 값은 일반 파일의 파일 내용 또는 기호 링크의 대상입니다.</target>
        </trans-unit>
        <trans-unit id="cb91e52cc1b3ca8f3f684e2966f8d4c11f3cb0b5" translate="yes" xml:space="preserve">
          <source>Otherwise, this API returns a negative value if P1 refers to an older snapshot than P2, zero if the two handles refer to the same database snapshot, and a positive value if P1 is a newer snapshot than P2.</source>
          <target state="translated">그렇지 않으면이 API는 P1이 P2보다 오래된 스냅 샷을 참조하면 음수 값을 리턴하고, 두 핸들이 동일한 데이터베이스 스냅 샷을 참조하면 0, P1이 P2보다 새로운 스냅 샷이면 양수 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="afebc4d098577eaf408f5312d05f2e55f910ee39" translate="yes" xml:space="preserve">
          <source>Our goal is to make the content you store in SQLite today as easily accessible to your grandchildren as it is to you.</source>
          <target state="translated">우리의 목표는 오늘날 SQLite에 저장하는 콘텐츠를 손자에게 쉽게 액세스 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3edd7f9a4b0d8d87dc9885a06cb59a66ad8766a5" translate="yes" xml:space="preserve">
          <source>Out of memory (OOM) error conditions generate error logging events with the SQLITE_NOMEM error code and a message that says how many bytes of memory were requested by the failed allocation.</source>
          <target state="translated">메모리 부족 (OOM) 오류 조건은 SQLITE_NOMEM 오류 코드 및 실패한 할당에 의해 요청 된 메모리 바이트 수를 나타내는 메시지와 함께 오류 로깅 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3eb43b3eb70e7d12a47e5820876f3c296dc05bc2" translate="yes" xml:space="preserve">
          <source>Out-of-memory tests</source>
          <target state="translated">메모리 부족 테스트</target>
        </trans-unit>
        <trans-unit id="c1bf191f6ccc359ad8a3c05c295f7fe8cef84ae3" translate="yes" xml:space="preserve">
          <source>Outlandish Recursive Query Examples</source>
          <target state="translated">비정상적인 재귀 쿼리 예제</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="1bd1112bbbb687e4d808e79cb404cc3ec423a23a" translate="yes" xml:space="preserve">
          <source>Output Change</source>
          <target state="translated">출력 변경</target>
        </trans-unit>
        <trans-unit id="0c51e370c031f37870509dc46422ce61ca6e1f16" translate="yes" xml:space="preserve">
          <source>Output columns from the index_info pragma are as follows:</source>
          <target state="translated">index_info pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8383ea0f1fb51fe84444b17104e0dd18b8f3f3b4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_list pragma are as follows:</source>
          <target state="translated">index_list pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc6e58f2bacd5891df7b631d05c18328e75e62f4" translate="yes" xml:space="preserve">
          <source>Output columns from the index_xinfo pragma are as follows:</source>
          <target state="translated">index_xinfo pragma의 출력 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1088854d972e4ceb1796db8756ad3486790779d" translate="yes" xml:space="preserve">
          <source>Output infinity as 1e999 in the &quot;.dump&quot; command of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 &quot;.dump&quot;명령에서 무한대를 1e999로 출력하십시오 .</target>
        </trans-unit>
        <trans-unit id="17e008cf652984308f7573376fc6932528a013cf" translate="yes" xml:space="preserve">
          <source>Output rows can be returned to the application as each small sort completes, and well before the table scan is complete.</source>
          <target state="translated">작은 정렬이 완료 될 때마다 그리고 테이블 스캔이 완료되기 훨씬 전에 출력 행을 애플리케이션으로 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b785807667b898e4c7f09b3ee44afccba51a9945" translate="yes" xml:space="preserve">
          <source>Outputs an SQL script to create an RBU database which, if used to update database t1.db, patches it so that its contents are identical to that of database t2.db.</source>
          <target state="translated">데이터베이스 t1.db를 업데이트하는 데 사용되는 경우 해당 컨텐츠가 데이터베이스 t2.db의 컨텐츠와 동일하도록 패치하는 RBU 데이터베이스를 작성하는 SQL 스크립트를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="25a352aa2e3e3671bf4d083fdd886df3d305e826" translate="yes" xml:space="preserve">
          <source>Over 100 separate source files are concatenated into a single large files of C-code named &quot;sqlite3.c&quot; and called &quot;the amalgamation&quot;. The amalgamation contains everything an application needs to embed SQLite. The amalgamation file is more than 220,000 lines long and over 7.5 megabytes in size (as of 2018-11-24).</source>
          <target state="translated">100 개가 넘는 별도의 소스 파일이 &quot;sqlite3.c&quot;라는 하나의 큰 C 코드 파일로 연결되고 &quot;아말감 화&quot;라고합니다. 통합에는 응용 프로그램에 SQLite를 포함시키는 데 필요한 모든 것이 포함됩니다. 합병 파일의 길이는 220,000 줄 이상이고 크기는 7.5MB 이상입니다 (2018-11-24 기준).</target>
        </trans-unit>
        <trans-unit id="6f2a6be035cf5a02d68b5e9127156e17d6b333b6" translate="yes" xml:space="preserve">
          <source>Overflow page</source>
          <target state="translated">오버플로 페이지</target>
        </trans-unit>
        <trans-unit id="26c78f2170e31758038f3bb0a52b3d4d222f938f" translate="yes" xml:space="preserve">
          <source>Overload A Function For A Virtual Table</source>
          <target state="translated">가상 테이블에 대한 함수 과부하</target>
        </trans-unit>
        <trans-unit id="007c99e63ddccff493d60c3cf9732ab7365f22fb" translate="yes" xml:space="preserve">
          <source>Override other operating system interfaces such as calls to obtain Zulu or local time.</source>
          <target state="translated">Zulu 또는 현지 시간을 얻기위한 호출과 같은 다른 운영 체제 인터페이스를 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="46880b89366d47b3659d0ee6bf4c167da19b6968" translate="yes" xml:space="preserve">
          <source>Overview Documents</source>
          <target state="translated">개요 서류</target>
        </trans-unit>
        <trans-unit id="04e78b5fd19361d42f0880283437d8302448583e" translate="yes" xml:space="preserve">
          <source>Overwrite if already exists?</source>
          <target state="translated">이미 존재하는 경우 덮어 쓰시겠습니까?</target>
        </trans-unit>
        <trans-unit id="9ada09a735411e9de190da46810d6bab2f578abd" translate="yes" xml:space="preserve">
          <source>Overwriting a database file with another without also deleting any hot journal associated with the original database.</source>
          <target state="translated">원본 데이터베이스와 관련된 핫 저널도 삭제하지 않고 다른 데이터베이스 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="bcfd518ec9aac14be70cb40d43cadb15da01978e" translate="yes" xml:space="preserve">
          <source>Overwritting a journal file with a different journal file.</source>
          <target state="translated">다른 저널 파일로 저널 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="f6202fa6f9727ecd28cda41b586c4f17db3f9662" translate="yes" xml:space="preserve">
          <source>P (cost: 7.71)</source>
          <target state="translated">P (비용 : 7.71)</target>
        </trans-unit>
        <trans-unit id="80d8eec7d81f7a0324484c1ac454ead7da895c4f" translate="yes" xml:space="preserve">
          <source>P1 can be either an ordinary table or a virtual table. There used to be a separate OP_VRowid opcode for use with virtual tables, but this one opcode now works for both table types.</source>
          <target state="translated">P1은 일반 테이블 또는 가상 테이블 일 수 있습니다. 가상 테이블에 사용할 별도의 OP_VRowid opcode가 있었지만이 opcode는 이제 두 테이블 유형 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="84bf22352f6da5dd236d64694b38dd6696254f42" translate="yes" xml:space="preserve">
          <source>P1 contains the address of the memory cell that contains the first memory cell in an array of values used as arguments to the sub-program. P2 contains the address to jump to if the sub-program throws an IGNORE exception using the RAISE() function. Register P3 contains the address of a memory cell in this (the parent) VM that is used to allocate the memory required by the sub-vdbe at runtime.</source>
          <target state="translated">P1은 서브 프로그램에 대한 인수로 사용되는 값의 배열에서 첫 번째 메모리 셀을 포함하는 메모리 셀의 주소를 포함합니다. P2는 하위 프로그램이 RAISE () 함수를 사용하여 IGNORE 예외를 발생시키는 경우 이동할 주소를 포함합니다. 레지스터 P3에는 런타임시 서브 vdbe에 필요한 메모리를 할당하는 데 사용되는이 (상위) VM의 메모리 셀 주소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb7c16489d0b290a1227473f0d5f4da2b7691cc" translate="yes" xml:space="preserve">
          <source>P1 is a 32-bit bitmask indicating whether or not each argument to the function was determined to be constant at compile time. If the first argument was constant then bit 0 of P1 is set. This is used to determine whether meta data associated with a user function argument using the sqlite3_set_auxdata() API may be safely retained until the next invocation of this opcode.</source>
          <target state="translated">P1은 함수에 대한 각 인수가 컴파일 타임에 일정하다고 결정되었는지 여부를 나타내는 32 비트 비트 마스크입니다. 첫 번째 인수가 상수이면 P1의 비트 0이 설정됩니다. sqlite3_set_auxdata () API를 사용하여 사용자 함수 인수와 연관된 메타 데이터가 다음에이 opcode를 호출 할 때까지 안전하게 유지 될 수 있는지 여부를 판별하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ce2db3e033bf07aaa2aac0e6df082aac39175194" translate="yes" xml:space="preserve">
          <source>P1 is a boolean flag. If it is set to true and the xUpdate call is successful, then the value returned by sqlite3_last_insert_rowid() is set to the value of the rowid for the row just inserted.</source>
          <target state="translated">P1은 부울 플래그입니다. true로 설정되고 xUpdate 호출이 성공하면 sqlite3_last_insert_rowid ()에 의해 리턴 된 값이 방금 삽입 된 행의 rowid 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3846ffb469791c7c875a7d6e64699955c09eb4" translate="yes" xml:space="preserve">
          <source>P1 is a cursor opened using &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen&lt;/a&gt;. P2 is an address to jump to if the filtered result set is empty.</source>
          <target state="translated">P1은 &lt;a href=&quot;opcode#VOpen&quot;&gt;VOpen을&lt;/a&gt; 사용하여 열린 커서 입니다. P2는 필터링 된 결과 집합이 비어있는 경우 이동할 주소입니다.</target>
        </trans-unit>
        <trans-unit id="99e16bb5285cdf74213efcd911112d0254cc888f" translate="yes" xml:space="preserve">
          <source>P1 is a register in the root frame of this VM (the root frame is different from the current frame if this instruction is being executed within a sub-program). Set the value of register P1 to the maximum of its current value and the value in register P2.</source>
          <target state="translated">P1은이 VM의 루트 프레임에있는 레지스터입니다 (이 명령이 하위 프로그램 내에서 실행되는 경우 루트 프레임은 현재 프레임과 다릅니다). 레지스터 P1의 값을 현재 값의 최대 값과 레지스터 P2의 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="17a3ab4e084c4ae225f4e64b76426d06344fe074" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. If the sequence counter is currently zero, jump to P2. Regardless of whether or not the jump is taken, increment the the sequence value.</source>
          <target state="translated">P1은 분류기 커서입니다. 시퀀스 카운터가 현재 0이면 P2로 이동합니다. 점프 여부와 관계없이 시퀀스 값을 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="f9ac2a8e79b4d0f70e9cfe08c3c644453f11b20b" translate="yes" xml:space="preserve">
          <source>P1 is a sorter cursor. This instruction compares a prefix of the record blob in register P3 against a prefix of the entry that the sorter cursor currently points to. Only the first P4 fields of r[P3] and the sorter record are compared.</source>
          <target state="translated">P1은 분류기 커서입니다. 이 명령어는 레지스터 P3에있는 레코드 Blob의 접두사와 분류기 커서가 현재 가리키는 항목의 접두사를 비교합니다. r [P3]의 첫 번째 P4 필드와 분류기 레코드 만 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="d14bcdd4246c685563dd290988090774223c445f" translate="yes" xml:space="preserve">
          <source>P1 is an open index cursor and P3 is a cursor on the corresponding table. This opcode does a deferred seek of the P3 table cursor to the row that corresponds to the current row of P1.</source>
          <target state="translated">P1은 열린 인덱스 커서이고 P3은 해당 테이블의 커서입니다. 이 opcode는 P3 테이블 커서를 P1의 현재 행에 해당하는 행으로 지연 탐색합니다.</target>
        </trans-unit>
        <trans-unit id="86c484d0a40d444e4dc0b4d443a06296772d4391" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). If register P3 does not contain an integer or if P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1은 SQL 테이블 btree에서 열린 커서의 인덱스입니다 (정수 키 포함). 레지스터 P3에 정수가 없거나 P1에 rowid P3이있는 레코드가없는 경우 즉시 P2로 이동하십시오. 또는 P2가 0이면 SQLITE_CORRUPT 오류를 발생시킵니다. P1에 rowid P3의 레코드가 포함되어 있으면 커서가 해당 레코드를 가리키고 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="be17250db9325023bb6814cabfbf543abfa5ba67" translate="yes" xml:space="preserve">
          <source>P1 is the index of a cursor open on an SQL table btree (with integer keys). P3 is an integer rowid. If P1 does not contain a record with rowid P3 then jump immediately to P2. Or, if P2 is 0, raise an SQLITE_CORRUPT error. If P1 does contain a record with rowid P3 then leave the cursor pointing at that record and fall through to the next instruction.</source>
          <target state="translated">P1은 SQL 테이블 btree에서 열린 커서의 인덱스입니다 (정수 키 포함). P3은 정수 rowid입니다. P1에 rowid P3의 레코드가 없으면 즉시 P2로 이동하십시오. 또는 P2가 0이면 SQLITE_CORRUPT 오류를 발생시킵니다. P1에 rowid P3의 레코드가 포함되어 있으면 커서가 해당 레코드를 가리키고 다음 명령으로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="35a6c564ff4d581152e9a1f876d9eb72d2af48f4" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database file on which the transaction is started. Index 0 is the main database file and index 1 is the file used for temporary tables. Indices of 2 or more are used for attached databases.</source>
          <target state="translated">P1은 트랜잭션이 시작된 데이터베이스 파일의 색인입니다. 인덱스 0은 기본 데이터베이스 파일이고 인덱스 1은 임시 테이블에 사용되는 파일입니다. 연결된 데이터베이스에는 2 개 이상의 인덱스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b9198f15e439eca54714083fc1fc6d108cc42915" translate="yes" xml:space="preserve">
          <source>P1 is the index of the database in sqlite3.aDb[] of the database on which the lock is acquired. A readlock is obtained if P3==0 or a write lock if P3==1.</source>
          <target state="translated">P1은 잠금을 획득 한 데이터베이스의 sqlite3.aDb []에있는 데이터베이스의 색인입니다. P3 == 0이면 판독 잠금을 얻거나 P3 == 1이면 기록 잠금을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1fcd6d3417638283143894ac28a56d5766856870" translate="yes" xml:space="preserve">
          <source>P1 is the memory location that is the accumulator for an aggregate or window function. Execute the finalizer function for an aggregate and store the result in P1.</source>
          <target state="translated">P1은 집계 또는 창 함수의 누산기 인 메모리 위치입니다. 집계에 대한 종료 자 함수를 실행하고 결과를 P1에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="9564a9171b616f080f45aeeeeb50a759cf2543a9" translate="yes" xml:space="preserve">
          <source>P1 is the result code returned by sqlite3_exec(), sqlite3_reset(), or sqlite3_finalize(). For a normal halt, this should be SQLITE_OK (0). For errors, it can be some other value. If P1!=0 then P2 will determine whether or not to rollback the current transaction. Do not rollback if P2==OE_Fail. Do the rollback if P2==OE_Rollback. If P2==OE_Abort, then back out all changes that have occurred during this execution of the VDBE, but do not rollback the transaction.</source>
          <target state="translated">P1은 sqlite3_exec (), sqlite3_reset () 또는 sqlite3_finalize ()에 의해 반환되는 결과 코드입니다. 정상적인 정지의 경우 SQLITE_OK (0)이어야합니다. 오류의 경우 다른 값이 될 수 있습니다. P1! = 0이면 P2는 현재 트랜잭션을 롤백할지 여부를 결정합니다. P2 == OE_Fail 인 경우 롤백하지 마십시오. P2 == OE_Rollback 인 경우 롤백을 수행하십시오. P2 == OE_Abort 인 경우 VDBE를 실행하는 동안 발생한 모든 변경 사항을 취소하지만 트랜잭션을 롤백하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="05f5c83f3b169019c8e82a0eaf11fb45a16518b4" translate="yes" xml:space="preserve">
          <source>P1 must be a valid b-tree cursor. P2 must be a boolean value, either 0 or 1.</source>
          <target state="translated">P1은 유효한 b- 트리 커서 여야합니다. P2는 0 또는 1의 부울 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="05f600aab9b18602c22139c66a31c7458bbfad3f" translate="yes" xml:space="preserve">
          <source>P1 must not be pseudo-table. It has to be a real table with multiple rows.</source>
          <target state="translated">P1은 의사 테이블이 아니어야합니다. 여러 행이있는 실제 테이블이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f93c0802a39924cff1b00e9015e9aa33f54938f7" translate="yes" xml:space="preserve">
          <source>P2 contains the root-page of the table to lock.</source>
          <target state="translated">P2는 잠글 테이블의 루트 페이지를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9ce77455e05f3264d5bb123f4f714e82dd11c666" translate="yes" xml:space="preserve">
          <source>P2 is a register that holds the name of a virtual table in database P1. Call the xCreate method for that table.</source>
          <target state="translated">P2는 데이터베이스 P1의 가상 테이블 이름을 보유하는 레지스터입니다. 해당 테이블의 xCreate 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="be0d49dbe18b5a0cf012a9f8a24be16667dd4219" translate="yes" xml:space="preserve">
          <source>P2 is the column number for the argument to the sqlite_offset() function. This opcode does not use P2 itself, but the P2 value is used by the code generator. The P1, P2, and P3 operands to this opcode are the same as for &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt;.</source>
          <target state="translated">P2는 sqlite_offset () 함수에 대한 인수의 열 번호입니다. 이 opcode는 P2 자체를 사용하지 않지만 P2 값은 코드 생성기에서 사용됩니다. 이 opcode의 P1, P2 및 P3 피연산자는 &lt;a href=&quot;opcode#Column&quot;&gt;Column&lt;/a&gt; 의 피연산자와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="b9b9294fefdd80f907d449f8b026a50941891877" translate="yes" xml:space="preserve">
          <source>P2 is the number of arguments that the step function takes and P4 is a pointer to the FuncDef for this function. The P2 argument is not used by this opcode. It is only there to disambiguate functions that can take varying numbers of arguments. The P4 argument is only needed for the case where the step function was not previously called.</source>
          <target state="translated">P2는 단계 함수가 취하는 인수 수이고 P4는이 함수의 FuncDef에 대한 포인터입니다. 이 opcode에서는 P2 인수를 사용하지 않습니다. 다양한 수의 인수를 취할 수있는 기능을 명확하게하는 것만 있습니다. P4 인수는 단계 함수가 이전에 호출되지 않은 경우에만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3bd7cc65ffe04a6cbb96320f3dfb05bef13a6003" translate="yes" xml:space="preserve">
          <source>P2 is the number of columns in the ephemeral table. The cursor points to a BTree table if P4==0 and to a BTree index if P4 is not 0. If P4 is not NULL, it points to a KeyInfo structure that defines the format of keys in the index.</source>
          <target state="translated">P2는 임시 테이블의 열 수입니다. 커서는 P4 == 0 인 경우 BTree 테이블을 가리키고 P4가 0이 아닌 경우 BTree 인덱스를 가리 킵니다. P4가 NULL이 아닌 경우 인덱스의 키 형식을 정의하는 KeyInfo 구조를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d43bd5b8560de02b50e24570db7ff928128725ba" translate="yes" xml:space="preserve">
          <source>P2=='A' &amp;rarr; BLOB</source>
          <target state="translated">P2 == 'A'&amp;rarr; BLOB</target>
        </trans-unit>
        <trans-unit id="549df038ddec37fc17c85e7dccfd3d0f7eac490b" translate="yes" xml:space="preserve">
          <source>P2=='B' &amp;rarr; TEXT</source>
          <target state="translated">P2 == 'B'&amp;rarr; 텍스트</target>
        </trans-unit>
        <trans-unit id="3eb880697f1f955293bf5968bad5752ba9e6c36d" translate="yes" xml:space="preserve">
          <source>P2=='C' &amp;rarr; NUMERIC</source>
          <target state="translated">P2 == 'C'&amp;rarr; 숫자</target>
        </trans-unit>
        <trans-unit id="11082965a2f3470ce5a9187e0cfe05f51096d4b9" translate="yes" xml:space="preserve">
          <source>P2=='D' &amp;rarr; INTEGER</source>
          <target state="translated">P2 == 'D'&amp;rarr; 정수</target>
        </trans-unit>
        <trans-unit id="8d3f310a6285b7cb02844a9cd70fd245db85edd2" translate="yes" xml:space="preserve">
          <source>P2=='E' &amp;rarr; REAL</source>
          <target state="translated">P2 == 'E'&amp;rarr; 실제</target>
        </trans-unit>
        <trans-unit id="12d088ae7e89df349fe37f3d37cf8b1ca4c09b3a" translate="yes" xml:space="preserve">
          <source>P3 = P2 || P1</source>
          <target state="translated">P3 = P2 || P1</target>
        </trans-unit>
        <trans-unit id="3a22c873357ee7f56f10d2e038f148e48353f460" translate="yes" xml:space="preserve">
          <source>P3 is the number of fields in the records that will be stored by the pseudo-table.</source>
          <target state="translated">P3은 의사 테이블에 의해 저장 될 레코드의 필드 수입니다.</target>
        </trans-unit>
        <trans-unit id="fa5df0db7433454e4380316b1e3b9bfe2adbea6f" translate="yes" xml:space="preserve">
          <source>P4 contains a pointer to the name of the table being locked. This is only used to generate an error message if the lock cannot be obtained.</source>
          <target state="translated">P4에는 잠긴 테이블 이름에 대한 포인터가 있습니다. 잠금을 확보 할 수없는 경우에만 오류 메시지를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f5b2dbcd76db7494d70506eccc181bd880869ce" translate="yes" xml:space="preserve">
          <source>P4 is a KeyInfo structure that defines collating sequences and sort orders for the comparison. The permutation applies to registers only. The KeyInfo elements are used sequentially.</source>
          <target state="translated">P4는 비교를위한 조합 순서 및 정렬 순서를 정의하는 KeyInfo 구조입니다. 순열은 레지스터에만 적용됩니다. KeyInfo 요소는 순차적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e63a14f434c9d816b03aebb21b25ccfa99f1b42" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit floating point value. Write that value into register P2.</source>
          <target state="translated">P4는 64 비트 부동 소수점 값에 대한 포인터입니다. 이 값을 레지스터 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="006b4d737b2fe81d322403675fc01054f9eaddfd" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a 64-bit integer value. Write that value into register P2.</source>
          <target state="translated">P4는 64 비트 정수 값에 대한 포인터입니다. 이 값을 레지스터 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="93432616419a7361a72b061b65e02339a1738910" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a CollSeq object. If the next call to a user function or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will be returned. This is used by the built-in min(), max() and nullif() functions.</source>
          <target state="translated">P4는 CollSeq 객체에 대한 포인터입니다. 사용자 함수에 대한 다음 호출 또는 집계가 sqlite3GetFuncCollSeq ()를 호출하면이 조합 순서가 리턴됩니다. 내장 min (), max () 및 nullif () 함수에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d80240e61957d32e7437d69346afb9ca3c15eca9" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. P1 is a cursor number. This opcode opens a cursor to the virtual table and stores that cursor in P1.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. P1은 커서 번호입니다. 이 opcode는 가상 테이블에 대한 커서를 열고 해당 커서를 P1에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="0dbffabc54d98d6801900e6ab537de5e2bcdd805" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xRename method. The value in register P1 is passed as the zName argument to the xRename method.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. 이 opcode는 해당 xRename 메소드를 호출합니다. 레지스터 P1의 값은 zName 인수로 xRename 메소드에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8c184e85a48a476ce012fdb53452bec6f0cb31bc" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to a virtual table object, an sqlite3_vtab structure. This opcode invokes the corresponding xUpdate method. P2 values are contiguous memory cells starting at P3 to pass to the xUpdate invocation. The value in register (P3+P2-1) corresponds to the p2th element of the argv array passed to xUpdate.</source>
          <target state="translated">P4는 sqlite3_vtab 구조 인 가상 테이블 오브젝트에 대한 포인터입니다. 이 opcode는 해당 xUpdate 메소드를 호출합니다. P2 값은 P3에서 시작하여 xUpdate 호출로 전달되는 연속 메모리 셀입니다. 레지스터 (P3 + P2-1)의 값은 xUpdate에 전달 된 argv 배열의 p2 번째 요소에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ad1bbf355e84d3c7a49f4b2d106cdd6317b07ee3" translate="yes" xml:space="preserve">
          <source>P4 is a pointer to the VM containing the trigger program.</source>
          <target state="translated">P4는 트리거 프로그램이 포함 된 VM에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="f47594ef27452803fbd06eb33f15569fa2ff24ae" translate="yes" xml:space="preserve">
          <source>P4 is a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th memory cell in the range.</source>
          <target state="translated">P4는 P2 자 길이의 문자열입니다. 문자열의 N 번째 문자는 해당 범위의 N 번째 메모리 셀에 사용해야하는 열 선호도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="990f075b203cf5ad046ffef4a8c3f52f5d8e8021" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreeNext().</source>
          <target state="translated">P4는 항상 P4_ADVANCE 유형입니다. 함수 포인터는 sqlite3BtreeNext ()를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="33ef9db58085779c3fa7810a9ac7b841027b65e6" translate="yes" xml:space="preserve">
          <source>P4 is always of type P4_ADVANCE. The function pointer points to sqlite3BtreePrevious().</source>
          <target state="translated">P4는 항상 P4_ADVANCE 유형입니다. 함수 포인터는 sqlite3BtreePrevious ()를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="d1b9c8ecf53ced9f246c4b6e555cd6111c1ca23e" translate="yes" xml:space="preserve">
          <source>P4 is either NULL or a string that was generated by the xBestIndex method of the module. The interpretation of the P4 string is left to the module implementation.</source>
          <target state="translated">P4는 NULL이거나 모듈의 xBestIndex 메소드에 의해 생성 된 문자열입니다. P4 문자열의 해석은 모듈 구현에 맡겨져 있습니다.</target>
        </trans-unit>
        <trans-unit id="c28c1dcafe0312975199fcb1fcfbb17e24dd7d0c" translate="yes" xml:space="preserve">
          <source>P4 is the name of a virtual table in database P1. Call the xDestroy method of that table.</source>
          <target state="translated">P4는 데이터베이스 P1의 가상 테이블 이름입니다. 해당 테이블의 xDestroy 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="b1c200e3bc2517ade0a0775a576b9a6ce0d06b98" translate="yes" xml:space="preserve">
          <source>P4 may be a pointer to an sqlite3_vtab structure. If so, call the xBegin method for that table.</source>
          <target state="translated">P4는 sqlite3_vtab 구조에 대한 포인터 일 수 있습니다. 그렇다면 해당 테이블에 대한 xBegin 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="946a7239230e3ec0a9c66885447aaf26ad8bc930" translate="yes" xml:space="preserve">
          <source>P4 may be a string that is P2 characters long. The N-th character of the string indicates the column affinity that should be used for the N-th field of the index key.</source>
          <target state="translated">P4는 P2 자 길이의 문자열 일 수 있습니다. 문자열의 N 번째 문자는 인덱스 키의 N 번째 필드에 사용해야하는 열 선호도를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="69adfac261137322671a1ca5cef4f8a650bcfbae" translate="yes" xml:space="preserve">
          <source>P4 may be an array of integers (type P4_INTARRAY) containing one entry for each column in the P3 table. If array entry a(i) is non-zero, then reading column a(i)-1 from cursor P3 is equivalent to performing the deferred seek and then reading column i from P1. This information is stored in P3 and used to redirect reads against P3 over to P1, thus possibly avoiding the need to seek and read cursor P3.</source>
          <target state="translated">P4는 P3 테이블의 각 열에 대해 하나의 항목을 포함하는 정수 배열 (P4_INTARRAY 유형) 일 수 있습니다. 배열 항목 a (i)가 0이 아닌 경우 커서 P3에서 열 a (i) -1을 읽는 것은 지연된 탐색을 수행 한 다음 P1에서 열 i를 읽는 것과 같습니다. 이 정보는 P3에 저장되며 P3에 대한 읽기를 P1로 리디렉션하는 데 사용되므로 커서 P3을 찾아서 읽을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b3aae431e84b9e296011557b13fc95c59d8a3fe" translate="yes" xml:space="preserve">
          <source>P4 points to a blob of data P1 bytes long. Store this blob in register P2.</source>
          <target state="translated">P4는 P1 바이트 길이의 데이터 Blob을 가리 킵니다. 이 얼룩을 레지스터 P2에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="5f1f77c01d77787acda0ee06f04f3dd3dab581c9" translate="yes" xml:space="preserve">
          <source>P4 points to a nul terminated UTF-8 string. This opcode is transformed into a &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode before it is executed for the first time. During this transformation, the length of string P4 is computed and stored as the P1 parameter.</source>
          <target state="translated">P4는 널 종료 UTF-8 문자열을 가리 킵니다. 이 opcode는 처음으로 실행되기 전에 &lt;a href=&quot;opcode#String&quot;&gt;String&lt;/a&gt; opcode 로 변환됩니다 . 이 변환 중에 문자열 P4의 길이가 계산되어 P1 매개 변수로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8ae2d7e0dfc4268ff56cfc9e2e47a67fc1ddaf" translate="yes" xml:space="preserve">
          <source>P5 is a value between 0 and 4, inclusive, that modifies the P4 string.</source>
          <target state="translated">P5는 P4 문자열을 수정하는 0에서 4 사이의 값입니다.</target>
        </trans-unit>
        <trans-unit id="e03c8fcb835da321a7966f8a1cfc9fb80046f7b0" translate="yes" xml:space="preserve">
          <source>P5 is the error actions (OE_Replace, OE_Fail, OE_Ignore, etc) to apply in the case of a constraint failure on an insert or update.</source>
          <target state="translated">P5는 삽입 또는 업데이트시 제한 조건 실패시 적용 할 오류 조치 (OE_Replace, OE_Fail, OE_Ignore 등)입니다.</target>
        </trans-unit>
        <trans-unit id="b092db6b7249be33e50e9f2a75c65696bf56d25e" translate="yes" xml:space="preserve">
          <source>P5 ought to be set on every call to this opcode. However, there are places in the code generator will release registers before their are used, under the (valid) assumption that the registers will not be reallocated for some other purpose before they are used and hence are safe to release.</source>
          <target state="translated">이 opcode를 호출 할 때마다 P5를 설정해야합니다. 그러나 코드 생성기에는 레지스터가 사용되기 전에 다른 목적으로 재 할당되지 않으므로 릴리스하기에 안전하다는 (유효한) 가정하에 레지스터를 사용하기 전에 레지스터를 해제 할 수있는 위치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d23183b7ef6b3cfee6722e9cab664f9eba24c080" translate="yes" xml:space="preserve">
          <source>PARTITION</source>
          <target state="translated">PARTITION</target>
        </trans-unit>
        <trans-unit id="7c423f3264effc4f744de4e6255ff034137bcc1e" translate="yes" xml:space="preserve">
          <source>PASSIVE</source>
          <target state="translated">PASSIVE</target>
        </trans-unit>
        <trans-unit id="418f304013689ba52fc7c27eebb7dcb9d2ced563" translate="yes" xml:space="preserve">
          <source>PDF - Portable Document Format from Adobe</source>
          <target state="translated">PDF-Adobe의 휴대용 문서 형식</target>
        </trans-unit>
        <trans-unit id="0a7b38b716933a39c0bca66f229cd6d52f0c1271" translate="yes" xml:space="preserve">
          <source>PENDING</source>
          <target state="translated">PENDING</target>
        </trans-unit>
        <trans-unit id="5a61e634ec49d3919b83a13434809a009040ffa1" translate="yes" xml:space="preserve">
          <source>PLAN</source>
          <target state="translated">PLAN</target>
        </trans-unit>
        <trans-unit id="4b01f0d6c5bf45bcaa85e117787de16b76894b18" translate="yes" xml:space="preserve">
          <source>POSIX locking style. This is the default locking style and the style used by other (non Mac OS X) Unixes. Locks are obtained and released using the fcntl() system call.</source>
          <target state="translated">POSIX 잠금 스타일. 이것은 기본 잠금 스타일이며 다른 (Mac OS X 이외) 유닉스에서 사용되는 스타일입니다. fcntl () 시스템 호출을 사용하여 잠금을 확보하고 해제합니다.</target>
        </trans-unit>
        <trans-unit id="304e41f1b7440f605b6d901a3f56679fe5127675" translate="yes" xml:space="preserve">
          <source>PPT - Microsoft PowerPoint presentations</source>
          <target state="translated">PPT-Microsoft PowerPoint 프레젠테이션</target>
        </trans-unit>
        <trans-unit id="eb3b3e1144fc0ba039acb3375dbf811550aeb6d8" translate="yes" xml:space="preserve">
          <source>PRAGMA</source>
          <target state="translated">PRAGMA</target>
        </trans-unit>
        <trans-unit id="2031386335ef51b174ad3b83ba1c813522943aeb" translate="yes" xml:space="preserve">
          <source>PRAGMA Statements</source>
          <target state="translated">PRAGMA 문</target>
        </trans-unit>
        <trans-unit id="dd8e7015522cfd4dcf823317fdfa144e1ffa8793" translate="yes" xml:space="preserve">
          <source>PRAGMA application_id</source>
          <target state="translated">PRAGMA application_id</target>
        </trans-unit>
        <trans-unit id="4272fe5aa2578d44c85ef586cbdb481255d6ef40" translate="yes" xml:space="preserve">
          <source>PRAGMA auto_vacuum</source>
          <target state="translated">PRAGMA auto_vacuum</target>
        </trans-unit>
        <trans-unit id="ecdb75c7d78bb2d218243fd805db4a0952130227" translate="yes" xml:space="preserve">
          <source>PRAGMA automatic_index</source>
          <target state="translated">PRAGMA automatic_index</target>
        </trans-unit>
        <trans-unit id="06f21794e50e9014cbc68dddc08b0afe728a2339" translate="yes" xml:space="preserve">
          <source>PRAGMA busy_timeout</source>
          <target state="translated">PRAGMA busy_timeout</target>
        </trans-unit>
        <trans-unit id="0079a2a1c563d3a80935f663efd9c2f3f214bd31" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_size</source>
          <target state="translated">PRAGMA cache_size</target>
        </trans-unit>
        <trans-unit id="53830be86cc01d9861a99c96b4baf9389520d439" translate="yes" xml:space="preserve">
          <source>PRAGMA cache_spill</source>
          <target state="translated">PRAGMA cache_spill</target>
        </trans-unit>
        <trans-unit id="c62c55dc2230d9ef14955c77928155e6ec4c7ae3" translate="yes" xml:space="preserve">
          <source>PRAGMA case_sensitive_like</source>
          <target state="translated">PRAGMA case_sensitive_like</target>
        </trans-unit>
        <trans-unit id="629aac38c33c9e2128ff55cc2623e94247525dd5" translate="yes" xml:space="preserve">
          <source>PRAGMA cell_size_check</source>
          <target state="translated">PRAGMA cell_size_check</target>
        </trans-unit>
        <trans-unit id="f7a6fea31875d2709fc8636382fa71e3e405a8bd" translate="yes" xml:space="preserve">
          <source>PRAGMA checkpoint_fullfsync</source>
          <target state="translated">PRAGMA checkpoint_fullfsync</target>
        </trans-unit>
        <trans-unit id="c3bb771e91f755dbbaf486313dfb86863abb68c6" translate="yes" xml:space="preserve">
          <source>PRAGMA collation_list</source>
          <target state="translated">PRAGMA collation_list</target>
        </trans-unit>
        <trans-unit id="03029df867e6189d3cb8be071de311b5adc094ca" translate="yes" xml:space="preserve">
          <source>PRAGMA command syntax</source>
          <target state="translated">PRAGMA 명령 구문</target>
        </trans-unit>
        <trans-unit id="41b472d1fbef46bb9f050319914604b6fc2ba68d" translate="yes" xml:space="preserve">
          <source>PRAGMA compile_options</source>
          <target state="translated">PRAGMA compile_options</target>
        </trans-unit>
        <trans-unit id="c654b246f7037e0f8929e3e045a813d87f20921d" translate="yes" xml:space="preserve">
          <source>PRAGMA count_changes</source>
          <target state="translated">PRAGMA count_changes</target>
        </trans-unit>
        <trans-unit id="e558ad585b01cc3a4aa52bb53490182d9eacc4e8" translate="yes" xml:space="preserve">
          <source>PRAGMA data_store_directory</source>
          <target state="translated">PRAGMA data_store_directory</target>
        </trans-unit>
        <trans-unit id="9a7e5a694b84807a56ec0b72b64b9c9c84d92f92" translate="yes" xml:space="preserve">
          <source>PRAGMA data_version</source>
          <target state="translated">PRAGMA data_version</target>
        </trans-unit>
        <trans-unit id="71f193736d432d273c489df59218224a1bd26bb0" translate="yes" xml:space="preserve">
          <source>PRAGMA database_list</source>
          <target state="translated">PRAGMA database_list</target>
        </trans-unit>
        <trans-unit id="d2b0abac3ff561286d0f244f1229dbe0d7c413ba" translate="yes" xml:space="preserve">
          <source>PRAGMA default_cache_size</source>
          <target state="translated">PRAGMA default_cache_size</target>
        </trans-unit>
        <trans-unit id="baa9b0985d524aa3c28f49ac66dec16e57647a96" translate="yes" xml:space="preserve">
          <source>PRAGMA defer_foreign_keys</source>
          <target state="translated">PRAGMA defer_foreign_keys</target>
        </trans-unit>
        <trans-unit id="5a13b54115c31e192bafba5863e3b69f614ae8e0" translate="yes" xml:space="preserve">
          <source>PRAGMA empty_result_callbacks</source>
          <target state="translated">PRAGMA empty_result_callbacks</target>
        </trans-unit>
        <trans-unit id="464f0c2fc86d3a8263fffd42239b50d53989d1da" translate="yes" xml:space="preserve">
          <source>PRAGMA encoding</source>
          <target state="translated">PRAGMA 인코딩</target>
        </trans-unit>
        <trans-unit id="5a35e091ec7521a831d067bdc90ecb017a359b26" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_check</source>
          <target state="translated">PRAGMA foreign_key_check</target>
        </trans-unit>
        <trans-unit id="4f9cabaf50d87f897238e4cfca01cbf9a956476a" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_key_list</source>
          <target state="translated">PRAGMA foreign_key_list</target>
        </trans-unit>
        <trans-unit id="c26430dedacc940c37179bc2ab043a40726e60aa" translate="yes" xml:space="preserve">
          <source>PRAGMA foreign_keys</source>
          <target state="translated">PRAGMA foreign_keys</target>
        </trans-unit>
        <trans-unit id="f6f4d8a618687004328fc80c2fe129e8548fb446" translate="yes" xml:space="preserve">
          <source>PRAGMA freelist_count</source>
          <target state="translated">PRAGMA freelist_count</target>
        </trans-unit>
        <trans-unit id="a1a0446b52b0c9481ab686d03b259ad5f54f8cce" translate="yes" xml:space="preserve">
          <source>PRAGMA full_column_names</source>
          <target state="translated">PRAGMA full_column_names</target>
        </trans-unit>
        <trans-unit id="19952a9490a74b7cefcba8ae3ffcd4c6cd36c908" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync</source>
          <target state="translated">PRAGMA fullfsync</target>
        </trans-unit>
        <trans-unit id="9b4ca9a487733d7c417ae8784f57aa1ed11b34f0" translate="yes" xml:space="preserve">
          <source>PRAGMA fullfsync=ON;</source>
          <target state="translated">PRAGMA fullfsync = ON;</target>
        </trans-unit>
        <trans-unit id="327858b59b9cfef735d94d93f6b85bcef5690111" translate="yes" xml:space="preserve">
          <source>PRAGMA function</source>
          <target state="translated">PRAGMA 기능</target>
        </trans-unit>
        <trans-unit id="2a0bacb7b9cc513abddcbbe743f428bab68dfa8c" translate="yes" xml:space="preserve">
          <source>PRAGMA function_list</source>
          <target state="translated">PRAGMA function_list</target>
        </trans-unit>
        <trans-unit id="e837cb07b592292e4ed84f750d66cb314f82a9c5" translate="yes" xml:space="preserve">
          <source>PRAGMA functions</source>
          <target state="translated">PRAGMA 기능</target>
        </trans-unit>
        <trans-unit id="f7e42e33fd73efd0a92d36f4ff6b3819913f9bc4" translate="yes" xml:space="preserve">
          <source>PRAGMA ignore_check_constraints</source>
          <target state="translated">PRAGMA ignore_check_constraints</target>
        </trans-unit>
        <trans-unit id="cd58bb64e6b2a173c5b581b0cb503c85da1dbd24" translate="yes" xml:space="preserve">
          <source>PRAGMA incremental_vacuum</source>
          <target state="translated">PRAGMA incremental_vacuum</target>
        </trans-unit>
        <trans-unit id="652aaaf1f9e0a84122b69d9954ec064ee9d02a48" translate="yes" xml:space="preserve">
          <source>PRAGMA index_info</source>
          <target state="translated">PRAGMA index_info</target>
        </trans-unit>
        <trans-unit id="125af8cf007c5ae9f4a12bfd4e392de5088aeebd" translate="yes" xml:space="preserve">
          <source>PRAGMA index_list</source>
          <target state="translated">PRAGMA index_list</target>
        </trans-unit>
        <trans-unit id="2da953925bb8a4bec48afa57978cfa755a68b864" translate="yes" xml:space="preserve">
          <source>PRAGMA index_xinfo</source>
          <target state="translated">PRAGMA index_xinfo</target>
        </trans-unit>
        <trans-unit id="a0a681b89ba9014d636bfe01c90f033d409952e9" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check</source>
          <target state="translated">PRAGMA integrity_check</target>
        </trans-unit>
        <trans-unit id="47cd2260e4aae51e91f7618b4491c7a57dbd31aa" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command for to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check가 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; 오류를 찾지 못했습니다 . FOREIGN KEY 제약 조건에서 오류를 찾으 려면 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fed086b5dc8e5ae4d059caf4aa86921613ca6bce" translate="yes" xml:space="preserve">
          <source>PRAGMA integrity_check does not find &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; errors. Use the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command to find errors in FOREIGN KEY constraints.</source>
          <target state="translated">PRAGMA integrity_check는 &lt;a href=&quot;foreignkeys&quot;&gt;FOREIGN KEY&lt;/a&gt; 오류를 찾지 못합니다 . &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령을 사용하여 FOREIGN KEY 제약 조건에서 오류를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0e40c9bb92f26ef5f07d9f3367463e8597505eee" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_mode</source>
          <target state="translated">PRAGMA journal_mode</target>
        </trans-unit>
        <trans-unit id="0dc7949f2c37427da3286461ab0d99c192b23454" translate="yes" xml:space="preserve">
          <source>PRAGMA journal_size_limit</source>
          <target state="translated">PRAGMA journal_size_limit</target>
        </trans-unit>
        <trans-unit id="1d1d61ff55f21546bb199472fc5fb09c63e7801f" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_alter_table</source>
          <target state="translated">PRAGMA legacy_alter_table</target>
        </trans-unit>
        <trans-unit id="1d7e28dc08cc03a9bb08dd39291f00ea3a00d6ce" translate="yes" xml:space="preserve">
          <source>PRAGMA legacy_file_format</source>
          <target state="translated">PRAGMA legacy_file_format</target>
        </trans-unit>
        <trans-unit id="e05eb926ae67395e18a7ff48872e6bf6de93826e" translate="yes" xml:space="preserve">
          <source>PRAGMA locking_mode</source>
          <target state="translated">PRAGMA locking_mode</target>
        </trans-unit>
        <trans-unit id="a71f8b9f21a1c76ece9dc64397bce57f203e4519" translate="yes" xml:space="preserve">
          <source>PRAGMA max_page_count</source>
          <target state="translated">PRAGMA max_page_count</target>
        </trans-unit>
        <trans-unit id="3aba9ed125640a69838f81731ba34ebdf094d76a" translate="yes" xml:space="preserve">
          <source>PRAGMA mmap_size</source>
          <target state="translated">PRAGMA mmap_size</target>
        </trans-unit>
        <trans-unit id="c29ccc2a4945dfe06f8af7b8b574f07e8a513dc7" translate="yes" xml:space="preserve">
          <source>PRAGMA module_list</source>
          <target state="translated">PRAGMA module_list</target>
        </trans-unit>
        <trans-unit id="ed5cd9ca526909b51a8497a39931b7a730a4b534" translate="yes" xml:space="preserve">
          <source>PRAGMA optimize</source>
          <target state="translated">PRAGMA 최적화</target>
        </trans-unit>
        <trans-unit id="9618d59586d55b1fe7cf6403a08d5878deeff0b2" translate="yes" xml:space="preserve">
          <source>PRAGMA page_count</source>
          <target state="translated">PRAGMA page_count</target>
        </trans-unit>
        <trans-unit id="73b1778335144273f1b55bbda71292b3236c2f7c" translate="yes" xml:space="preserve">
          <source>PRAGMA page_size</source>
          <target state="translated">PRAGMA page_size</target>
        </trans-unit>
        <trans-unit id="0c33d6f9f55335baef42453f3966f2ae2790fe21" translate="yes" xml:space="preserve">
          <source>PRAGMA parser_trace</source>
          <target state="translated">PRAGMA parser_trace</target>
        </trans-unit>
        <trans-unit id="987c5140e9a3de6520e0e9a5de928a2bd5f2af7c" translate="yes" xml:space="preserve">
          <source>PRAGMA synchronous=FULL;</source>
          <target state="translated">PRAGMA 동기식 = FULL;</target>
        </trans-unit>
        <trans-unit id="c40b0db1ea40d45cf9c01804a3ada577b8b752ae" translate="yes" xml:space="preserve">
          <source>PRAGMA temp_store_directory = ''</source>
          <target state="translated">PRAGMA temp_store_directory = ''</target>
        </trans-unit>
        <trans-unit id="0662bf3087347b5b0ecf25fecad0c21f9bfb340d" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_addoptrace</source>
          <target state="translated">PRAGMA vdbe_addoptrace</target>
        </trans-unit>
        <trans-unit id="ed607acfa6bacfc2bc133e1d2e829c3c31c8a51c" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_debug</source>
          <target state="translated">PRAGMA vdbe_debug</target>
        </trans-unit>
        <trans-unit id="f5251eb4d3acd0707857877ee684d1bef0e741e2" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_listing</source>
          <target state="translated">PRAGMA vdbe_listing</target>
        </trans-unit>
        <trans-unit id="319d369f27e5d322702e5eca965b605f26e48c8b" translate="yes" xml:space="preserve">
          <source>PRAGMA vdbe_trace</source>
          <target state="translated">PRAGMA vdbe_trace</target>
        </trans-unit>
        <trans-unit id="f0a71878598fa251896a1bb5f07402743f02c1c6" translate="yes" xml:space="preserve">
          <source>PRAGMAs that return results and that have no side-effects can be accessed from ordinary &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements as &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt;. For each participating PRAGMA, the corresponding table-valued function has the same name as the PRAGMA with a 7-character &quot;pragma_&quot; prefix. The PRAGMA argument and schema, if any, are passed as arguments to the table-valued function.</source>
          <target state="translated">결과를 반환하고 부작용이없는 PRAGMA는 일반 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에서 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 로 액세스 할 수 있습니다 . 참여하는 각 PRAGMA에 대해 해당 테이블 반환 함수의 이름은 7 자리 &quot;pragma_&quot;로 PRAGMA와 동일합니다. PRAGMA 인수 및 스키마 (있는 경우)는 테이블 반환 함수에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e246fc197bcab96dcc71246fd51e046d154a6b" translate="yes" xml:space="preserve">
          <source>PRECEDING</source>
          <target state="translated">PRECEDING</target>
        </trans-unit>
        <trans-unit id="ed15de08f42371953d12d6c433f3d7a83e50d659" translate="yes" xml:space="preserve">
          <source>PRIMARY</source>
          <target state="translated">PRIMARY</target>
        </trans-unit>
        <trans-unit id="5d81ed20f739b911f425c9e71391691185dad6d3" translate="yes" xml:space="preserve">
          <source>PRIMARY KEY constraint</source>
          <target state="translated">기본 키 제약</target>
        </trans-unit>
        <trans-unit id="fcdd367db6d48a1ca9ffb0132d54992dd930544d" translate="yes" xml:space="preserve">
          <source>Page 1 and the Expected Page Size</source>
          <target state="translated">페이지 1 및 예상 페이지 크기</target>
        </trans-unit>
        <trans-unit id="626d2e810cbdab389ce5499e79846105d079da1c" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;&lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt;&quot;. This b-tree is known as the &quot;schema table&quot; since it stores the complete database schema. The structure of the sqlite_schema table is as if it had been created using the following SQL:</source>
          <target state="translated">데이터베이스 파일의 페이지 1은 &quot; &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; &quot; 라는 특수 테이블을 보유하는 테이블 b- 트리의 루트 페이지입니다 . 이 b- 트리는 전체 데이터베이스 스키마를 저장하므로 &quot;스키마 테이블&quot;이라고합니다. sqlite_schema 테이블의 구조는 다음 SQL을 사용하여 생성 된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e0da1c304b873d5c4bfe7eb2116e8b2b93162178" translate="yes" xml:space="preserve">
          <source>Page 1 of a database file is the root page of a table b-tree that holds a special table named &quot;sqlite_master&quot; (or &quot;sqlite_temp_master&quot; in the case of a TEMP database) which stores the complete database schema. The structure of the sqlite_master table is as if it had been created using the following SQL:</source>
          <target state="translated">데이터베이스 파일의 1 페이지는 완전한 데이터베이스 스키마를 저장하는 &quot;sqlite_master&quot;(또는 TEMP 데이터베이스의 경우 &quot;sqlite_temp_master&quot;)라는 특수 테이블을 보유하는 테이블 b- 트리의 루트 페이지입니다. sqlite_master 테이블의 구조는 다음 SQL을 사용하여 작성된 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb98169c72c2e0218852294c4088a714e55ae813" translate="yes" xml:space="preserve">
          <source>Page Cache</source>
          <target state="translated">페이지 캐시</target>
        </trans-unit>
        <trans-unit id="111e3d8b941451e6256ee0ce1fa5b2560f773697" translate="yes" xml:space="preserve">
          <source>Page Cache Algorithms</source>
          <target state="translated">페이지 캐시 알고리즘</target>
        </trans-unit>
        <trans-unit id="51e73b0787f74035c32eccb9bca14aa82436008b" translate="yes" xml:space="preserve">
          <source>Page Cache Configuration</source>
          <target state="translated">페이지 캐시 구성</target>
        </trans-unit>
        <trans-unit id="91dcdd907d00efb6c274aa541e77d89ded5b848c" translate="yes" xml:space="preserve">
          <source>Page cache memory allocations that overflow into the general-purpose memory allocator.</source>
          <target state="translated">범용 메모리 할당 자로 오버 플로우되는 페이지 캐시 메모리 할당.</target>
        </trans-unit>
        <trans-unit id="8b08ca42225d56c2d889ece253767100d76e7c2a" translate="yes" xml:space="preserve">
          <source>Page number</source>
          <target state="translated">페이지 번호</target>
        </trans-unit>
        <trans-unit id="ad392683af791420db4e7324c20464059ce3492a" translate="yes" xml:space="preserve">
          <source>Page number of first overflow page</source>
          <target state="translated">첫 번째 오버 플로우 페이지의 페이지 번호</target>
        </trans-unit>
        <trans-unit id="6e528c19af566e5c19716241accd44732b15c3f1" translate="yes" xml:space="preserve">
          <source>Page number of left child</source>
          <target state="translated">좌익의 페이지 수</target>
        </trans-unit>
        <trans-unit id="1d20e1ca269b0f7a9ac2bdd34ee817b875d0828b" translate="yes" xml:space="preserve">
          <source>Page number of the first freelist trunk page.</source>
          <target state="translated">첫 번째 프리리스트 트렁크 페이지의 페이지 번호입니다.</target>
        </trans-unit>
        <trans-unit id="2f6078feea4fe70e006a40f0bbe8960bf8454aee" translate="yes" xml:space="preserve">
          <source>Pagecache memory allocator</source>
          <target state="translated">페이지 캐시 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="7a89afd5ef39a4cff0b861ab314756ac6e516da0" translate="yes" xml:space="preserve">
          <source>Pagecount</source>
          <target state="translated">Pagecount</target>
        </trans-unit>
        <trans-unit id="2a084ba7d77808cea5a5f8f9c1ab34ab55b7585a" translate="yes" xml:space="preserve">
          <source>Pager and btree subsystems removed. These will be used in a follow-on SQL server library named &quot;SQLus&quot;.</source>
          <target state="translated">호출기 및 btree 하위 시스템이 제거되었습니다. 이들은 &quot;SQLus&quot;라는 후속 SQL Server 라이브러리에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d03660f900d198f933a03da740944dbf17018900" translate="yes" xml:space="preserve">
          <source>Pager subsystem added but not yet used.</source>
          <target state="translated">호출기 서브 시스템이 추가되었지만 아직 사용되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="70384aa891f4780133eb9e575d0bd72469e20f4e" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 2147483646 (2&lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 140,737,488,224,256 bytes (about 140 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">페이지는 최대 페이지 수는 2,147,483,646 (2, 1로 시작하는 번호가 &lt;sup&gt;&lt;small&gt;31&lt;/small&gt;&lt;/sup&gt; - 2). 최소 크기 SQLite 데이터베이스는 단일 512 바이트 페이지입니다. 최대 크기 데이터베이스는 페이지 당 65536 바이트 또는 140,737,488,224,256 바이트 (약 140 테라 바이트)에서 2147483646 페이지입니다. 일반적으로 SQLite는 자체 내부 크기 제한에 도달하기 전에 기본 파일 시스템 또는 디스크 하드웨어의 최대 파일 크기 제한에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="a6bf70b89378b1b3ed63fb1aa677ec02aea17bdf" translate="yes" xml:space="preserve">
          <source>Pages are numbered beginning with 1. The maximum page number is 4294967294 (2&lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). The minimum size SQLite database is a single 512-byte page. The maximum size database would be 2147483646 pages at 65536 bytes per page or 281,474,976,579,584 bytes (about 281 terabytes). Usually SQLite will hit the maximum file size limit of the underlying filesystem or disk hardware long before it hits its own internal size limit.</source>
          <target state="translated">페이지는 최대 페이지 번호 4294967294 (2, 1로 시작하는 번호가 &lt;sup&gt;&lt;small&gt;32&lt;/small&gt;&lt;/sup&gt; - 2). 최소 크기 SQLite 데이터베이스는 단일 512 바이트 페이지입니다. 데이터베이스의 최대 크기는 페이지 당 65536 바이트 또는 281,474,976,579,584 바이트 (약 281 테라 바이트)의 2147483646 페이지입니다. 일반적으로 SQLite는 자체 내부 크기 제한에 도달하기 훨씬 전에 기본 파일 시스템 또는 디스크 하드웨어의 최대 파일 크기 제한에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="0f332eeefd007bb0043ccb46738196508c6a602b" translate="yes" xml:space="preserve">
          <source>Param</source>
          <target state="translated">Param</target>
        </trans-unit>
        <trans-unit id="f699f295e5ae4ac633cfa18437fed38d028b3fdb" translate="yes" xml:space="preserve">
          <source>Parameter</source>
          <target state="translated">Parameter</target>
        </trans-unit>
        <trans-unit id="8b81f4321a39e53a61cf8fbe1b4d654902c2cd89" translate="yes" xml:space="preserve">
          <source>Parameter P4 may point to a Table structure, or may be NULL. If it is not NULL, then the update-hook (sqlite3.xUpdateCallback) is invoked following a successful insert.</source>
          <target state="translated">매개 변수 P4는 테이블 구조를 가리 키거나 NULL 일 수 있습니다. NULL이 아닌 경우 성공적인 삽입 후 update-hook (sqlite3.xUpdateCallback)이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a5652d036064588f8b6a1cd35001bca04abb6577" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">zDb 매개 변수는 데이터베이스를 포함하는 파일 이름이 아니라 데이터베이스의 기호 이름입니다. 접속 된 데이터베이스의 경우, 이는 &lt;a href=&quot;../lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 나타나는 이름입니다 . 기본 데이터베이스 파일의 경우 데이터베이스 이름은 &quot;main&quot;입니다. TEMP 테이블의 경우 데이터베이스 이름은 &quot;temp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="6b3dbfca494676dd202b93efd1413416a69fb138" translate="yes" xml:space="preserve">
          <source>Parameter zDb is not the filename that contains the database, but rather the symbolic name of the database. For attached databases, this is the name that appears after the AS keyword in the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statement. For the main database file, the database name is &quot;main&quot;. For TEMP tables, the database name is &quot;temp&quot;.</source>
          <target state="translated">zDb 매개 변수는 데이터베이스를 포함하는 파일 이름이 아니라 데이터베이스의 기호 이름입니다. 접속 된 데이터베이스의 경우, 이는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 AS 키워드 뒤에 나타나는 이름입니다 . 기본 데이터베이스 파일의 경우 데이터베이스 이름은 &quot;main&quot;입니다. TEMP 테이블의 경우 데이터베이스 이름은 &quot;temp&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="799e97b7e20fea27a8af5b85f72a1e45ff70f20e" translate="yes" xml:space="preserve">
          <source>Parameters can be either named or unnamed. An unnamed parameter is a single question mark (&quot;?&quot;). Named parameters are a &quot;?&quot; followed immediately by a number (ex: &quot;?15&quot; or &quot;?123&quot;) or one of the characters &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; followed by an alphanumeric name (ex: &quot;$var1&quot;, &quot;:xyz&quot;, &quot;@bingo&quot;).</source>
          <target state="translated">매개 변수는 이름을 지정하거나 이름을 지정할 수 없습니다. 명명되지 않은 매개 변수는 단일 물음표 ( &quot;?&quot;)입니다. 명명 된 매개 변수는 &quot;?&quot; 바로 뒤에 숫자 (예 : &quot;? 15&quot;또는 &quot;? 123&quot;) 또는 &quot;$&quot;, &quot;:&quot;또는 &quot;@&quot;문자 중 하나 다음에 영숫자 이름 (예 : &quot;$ var1&quot;, &quot;: xyz &quot;,&quot;@bingo &quot;).</target>
        </trans-unit>
        <trans-unit id="8cba5f18115ee2b196f01cd67b537bb6b53bf7ec" translate="yes" xml:space="preserve">
          <source>Parameters that are not assigned values using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind()&lt;/a&gt; are treated as NULL. The &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index()&lt;/a&gt; interface can be used to translate a symbolic parameter name into its equivalent numeric index.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind ()를&lt;/a&gt; 사용하여 값이 지정되지 않은 매개 변수는 NULL로 처리됩니다. &lt;a href=&quot;c3ref/bind_parameter_index&quot;&gt;sqlite3_bind_parameter_index ()&lt;/a&gt; 인터페이스는 동등한 숫자 인덱스로 상징적 파라미터 명을 변환하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4de5d1891af8779fc1d212b882aca704731f9909" translate="yes" xml:space="preserve">
          <source>Parent and child keys must have the same cardinality. In SQLite, if any of the child key columns (in this case songartist and songalbum) are NULL, then there is no requirement for a corresponding row in the parent table.</source>
          <target state="translated">부모 키와 자식 키는 동일한 카디널리티를 가져야합니다. SQLite에서 하위 키 열 (이 경우 songartist 및 songalbum)이 NULL이면 상위 테이블의 해당 행에 대한 요구 사항이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f4093b4053e6e304b33edcd1e545c7ac44407405" translate="yes" xml:space="preserve">
          <source>Parent table</source>
          <target state="translated">부모 테이블</target>
        </trans-unit>
        <trans-unit id="4e28259727cc9bea774f5aa837a0a46e7e8f6e3d" translate="yes" xml:space="preserve">
          <source>Parentheses around the column name are ignored. Hence if X and Y.Z are column names, then (X) and (Y.Z) are also considered column names and have the affinity of the corresponding columns.</source>
          <target state="translated">열 이름 주위의 괄호는 무시됩니다. 따라서 X와 YZ가 열 이름 인 경우 (X)와 (YZ)도 열 이름으로 간주되며 해당 열의 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e9b3806832484c8806fbc046fab28912aa2aa64c" translate="yes" xml:space="preserve">
          <source>Parenthesis are not supported.</source>
          <target state="translated">괄호는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75d39bc816f04be94a422f23dd0120a1ebf6cf81" translate="yes" xml:space="preserve">
          <source>Parenthesis may be used to group expressions in order to modify operator precedence in the usual ways. For example:</source>
          <target state="translated">일반적인 방법으로 연산자 우선 순위를 수정하기 위해 괄호를 사용하여 표현식을 그룹화 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a5d92895b79471a4a9fa3ce0a6ffdf64945a6880" translate="yes" xml:space="preserve">
          <source>Parse (but do not implement) foreign keys.</source>
          <target state="translated">외래 키를 구문 분석합니다 (구현하지는 않음).</target>
        </trans-unit>
        <trans-unit id="c98796aa2add46f2617d36d2c94c638a1c0df012" translate="yes" xml:space="preserve">
          <source>ParseSchema</source>
          <target state="translated">ParseSchema</target>
        </trans-unit>
        <trans-unit id="1b3cf5033ed01a4fcbff3f2957e66cfe44af45a9" translate="yes" xml:space="preserve">
          <source>Parser</source>
          <target state="translated">Parser</target>
        </trans-unit>
        <trans-unit id="e5dde1d1ec704f9acd81aeb949908d6d48dedf9c" translate="yes" xml:space="preserve">
          <source>Parser detects and reports automaton stack overflow.</source>
          <target state="translated">파서는 자동 스택 오버플로를 감지하고보고합니다.</target>
        </trans-unit>
        <trans-unit id="de7186ac205c0a4d05d1b7e13d0477c901e264d5" translate="yes" xml:space="preserve">
          <source>Parsing Ambiguity</source>
          <target state="translated">모호성 파싱</target>
        </trans-unit>
        <trans-unit id="6893b79566df0f4ab433d9b0d800d95d1637ec25" translate="yes" xml:space="preserve">
          <source>Partial Indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="b83a6d7f720f864139ebf6cd22707c1309f4af67" translate="yes" xml:space="preserve">
          <source>Partial index causes assertion fault on UPDATE OR REPLACE. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</source>
          <target state="translated">부분 인덱스로 인해 UPDATE OR REPLACE에서 어설 션 오류가 발생합니다. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/2ea3e9fe63&quot;&gt;2ea3e9fe63&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92e7c6c4dccd56837450920de775aa91130dc6eb" translate="yes" xml:space="preserve">
          <source>Partial indexes</source>
          <target state="translated">부분 인덱스</target>
        </trans-unit>
        <trans-unit id="a6b00209f988aae401d1637e4d3a48cf480b87b9" translate="yes" xml:space="preserve">
          <source>Partial indexes have been supported in SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이후 부분 인덱스가 지원되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2c653f2abbb32f0888ba48000a6d19c0a678be3c" translate="yes" xml:space="preserve">
          <source>Partial sorting by index</source>
          <target state="translated">인덱스 별 부분 정렬</target>
        </trans-unit>
        <trans-unit id="8e7b279371a7a0621eac24aac6019fdbd06fb946" translate="yes" xml:space="preserve">
          <source>Partially or fully disable the use of mutexes using &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt;, &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; , &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED를&lt;/a&gt; 사용하여 뮤텍스 사용을 부분적으로 또는 완전히 비활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="322d75c78f20c6c69dad6d4668258bee1cff55cf" translate="yes" xml:space="preserve">
          <source>Pass information about !=, IS, IS NOT, NOT NULL, and IS NULL constraints into the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex&lt;/a&gt; method of virtual tables.</source>
          <target state="translated">! =, IS, IS NOT, NOT NULL 및 IS NULL 제한 조건에 대한 &lt;a href=&quot;vtab#xbestindex&quot;&gt;정보&lt;/a&gt; 를 가상 테이블 의 xBestIndex 메소드에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="87139427c07163b54b934cac2e589a5477f5abd2" translate="yes" xml:space="preserve">
          <source>Passing around pointers as if they were integers or BLOBs is easy, effective, and works well in an environment where the application components are all friendly toward one another. However, passing pointers as integers and BLOBs allows hostile SQL text to forge invalid pointers that can carry out mischief.</source>
          <target state="translated">포인터가 정수 또는 BLOB 인 것처럼 포인터를 전달하는 것은 쉽고 효과적이며 응용 프로그램 구성 요소가 서로 친숙한 환경에서 잘 작동합니다. 그러나 포인터를 정수 및 BLOB로 전달하면 악의적 인 SQL 텍스트가 잘못된 포인터를 생성하여 장난을 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3138de58b357feeff45cc3442a6fef1e07764789" translate="yes" xml:space="preserve">
          <source>Passing zero to this function disables the session. Passing a value greater than zero enables it. Passing a value less than zero is a no-op, and may be used to query the current state of the session.</source>
          <target state="translated">이 기능에 0을 전달하면 세션이 비활성화됩니다. 0보다 큰 값을 전달하면 활성화됩니다. 0보다 작은 값을 전달하는 것은 작동하지 않으며 세션의 현재 상태를 쿼리하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="590be09d7533f1bdecea251bf8fa20c21692381c" translate="yes" xml:space="preserve">
          <source>Patch releases may or may not have a release checklist, depending on the issue. This is a judgement call by the project leader.</source>
          <target state="translated">패치 릴리스는 문제에 따라 릴리스 체크리스트가 있거나 없을 수 있습니다. 이것은 프로젝트 리더의 판단입니다.</target>
        </trans-unit>
        <trans-unit id="6943c09e1bab506ed4d4e77bf277765f2ba43e9d" translate="yes" xml:space="preserve">
          <source>Patches from Christian Werner to improve ODBC compatibility and to fix a bug in the round() function.</source>
          <target state="translated">Christian Werner의 패치로 ODBC 호환성을 개선하고 round () 함수의 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="2e7fec23d54bbd8979f0f75ea726578cd4ba06c0" translate="yes" xml:space="preserve">
          <source>Pay close attention to the last sentence in the previous paragraph:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c30415eacc6a59446974b716eff56cf28219815d" translate="yes" xml:space="preserve">
          <source>Payload</source>
          <target state="translated">Payload</target>
        </trans-unit>
        <trans-unit id="2cd642b895a9277d90f1edb51ac2e97d29897374" translate="yes" xml:space="preserve">
          <source>Payload, either table b-tree data or index b-tree keys, is always in the &quot;record format&quot;. The record format defines a sequence of values corresponding to columns in a table or index. The record format specifies the number of columns, the datatype of each column, and the content of each column.</source>
          <target state="translated">테이블 b- 트리 데이터 또는 인덱스 b- 트리 키 중 하나 인 페이로드는 항상 &quot;레코드 형식&quot;입니다. 레코드 형식은 테이블 또는 인덱스의 열에 해당하는 일련의 값을 정의합니다. 레코드 형식은 열 수, 각 열의 데이터 유형 및 각 열의 내용을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e74a4343f3025ea9dd8df608f45f6bce992f0d7e" translate="yes" xml:space="preserve">
          <source>Pending statements no longer block &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. Instead, the pending statement will return SQLITE_ABORT upon next access after the ROLLBACK.</source>
          <target state="translated">보류중인 명령문은 더 이상 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK을&lt;/a&gt; 차단하지 않습니다 . 대신, ROLLBACK 이후에 다음에 액세스 할 때 보류중인 명령문은 SQLITE_ABORT를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4737507de6ca940161ab97310c9c1d96280bacd6" translate="yes" xml:space="preserve">
          <source>People often wonder why SQLite does not use the &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; version control system like everybody else. This article attempts to answer that question. Also, in &lt;a href=&quot;#getthecode&quot;&gt;section 3&lt;/a&gt;, this article provides hints to Git users about how they can easily access the SQLite source code.</source>
          <target state="translated">사람들은 종종 SQLite가 다른 사람들처럼 &lt;a href=&quot;https://git-scm.org&quot;&gt;Git&lt;/a&gt; 버전 제어 시스템을 사용하지 않는 이유를 궁금해 합니다. 이 기사는 그 질문에 대한 답변을 시도합니다. 또한 &lt;a href=&quot;#getthecode&quot;&gt;섹션 3&lt;/a&gt; 에서이 기사는 Git 사용자에게 SQLite 소스 코드에 쉽게 액세스 할 수있는 방법에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a859905b933e3207fdf46d957c4ccc640fdf48ae" translate="yes" xml:space="preserve">
          <source>People who understand SQL can employ the &lt;a href=&quot;cli&quot;&gt;sqlite3 command-line shell&lt;/a&gt; (or various third-party SQLite access programs) to analyze large datasets. Raw data can be imported from CSV files, then that data can be sliced and diced to generate a myriad of summary reports. More complex analysis can be done using simple scripts written in Tcl or Python (both of which come with SQLite built-in) or in R or other languages using readily available adaptors. Possible uses include website log analysis, sports statistics analysis, compilation of programming metrics, and analysis of experimental results. Many bioinformatics researchers use SQLite in this way.</source>
          <target state="translated">SQL을 이해하는 사람들은 &lt;a href=&quot;cli&quot;&gt;sqlite3 명령 줄 셸&lt;/a&gt; (또는 다양한 타사 SQLite 액세스 프로그램)을 사용하여 큰 데이터 집합을 분석 할 수 있습니다. 원시 데이터는 CSV 파일에서 가져올 수 있으며, 그 데이터를 슬라이스하고 잘라서 무수한 요약 보고서를 생성 할 수 있습니다. 보다 복잡한 분석은 Tcl 또는 Python (둘 다 SQLite 내장으로 제공됨) 또는 R 또는 다른 언어로 작성된 간단한 스크립트를 사용하여 쉽게 사용할 수있는 어댑터를 사용하여 수행 할 수 있습니다. 웹 사이트 로그 분석, 스포츠 통계 분석, 프로그래밍 메트릭 편집 및 실험 결과 분석이 가능합니다. 많은 생물 정보학 연구자들이 이런 식으로 SQLite를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="deda64204144c5cb8a53d34e5d28a353e9faf513" translate="yes" xml:space="preserve">
          <source>Perform a single step of the incremental vacuum procedure on the P1 database. If the vacuum has finished, jump to instruction P2. Otherwise, fall through to the next instruction.</source>
          <target state="translated">P1 데이터베이스에서 증분 진공 절차의 단일 단계를 수행하십시오. 진공이 완료되면 지침 P2로 이동하십시오. 그렇지 않으면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="54eef71ea08bf2a0291b4730516048fec290cbbf" translate="yes" xml:space="preserve">
          <source>Perform any required foreign key actions,</source>
          <target state="translated">필요한 외래 키 작업을 수행하고</target>
        </trans-unit>
        <trans-unit id="94e7748396990532238f46b792b6a833a4e68178" translate="yes" xml:space="preserve">
          <source>Perform some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; operations in a single pass instead of in two passes.</source>
          <target state="translated">두 번이 아닌 단일 번으로 일부 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 작업을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="0b4045b439e29414aaf2009ad15f476795f21a79" translate="yes" xml:space="preserve">
          <source>Performance Related Assumptions</source>
          <target state="translated">성능 관련 가정</target>
        </trans-unit>
        <trans-unit id="5539b01935cddeb466afb8949c00cacfd4174474" translate="yes" xml:space="preserve">
          <source>Performance can be improved and the size reduced by enabling &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt;, &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS=0&lt;/a&gt;, &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS=1&lt;/a&gt;, &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt;, &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH=0&lt;/a&gt;, &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE&lt;/a&gt;, &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt;, &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt;, &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt;, and &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt;. All these options together result in about a 3.5% performance increase and a 3.0% size reduction.</source>
          <target state="translated">성능을 향상시킬 수 있도록 크기가 감소 &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_memstatus&quot;&gt;-DSQLITE_DEFAULT_MEMSTATUS = 0&lt;/a&gt; , &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;-DSQLITE_DEFAULT_WAL_SYNCHRONOUS = 1&lt;/a&gt; , &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;-DSQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; , &lt;a href=&quot;limits#max_expr_depth&quot;&gt;-DSQLITE_MAX_EXPR_DEPTH = 0&lt;/a&gt; , &lt;a href=&quot;compile#omit_decltype&quot;&gt;-DSQLITE_OMIT_DECLTYPE을&lt;/a&gt; , &lt;a href=&quot;compile#omit_deprecated&quot;&gt;-DSQLITE_OMIT_DEPRECATED&lt;/a&gt; , &lt;a href=&quot;compile#omit_progress_callback&quot;&gt;-DSQLITE_OMIT_PROGRESS_CALLBACK&lt;/a&gt; , &lt;a href=&quot;compile#omit_shared_cache&quot;&gt;-DSQLITE_OMIT_SHARED_CACHE&lt;/a&gt; 및 &lt;a href=&quot;compile#use_alloca&quot;&gt;-DSQLITE_USE_ALLOCA&lt;/a&gt; . 이 모든 옵션을 함께 사용하면 성능이 약 3.5 % 향상되고 크기가 3.0 % 감소합니다.</target>
        </trans-unit>
        <trans-unit id="1860a0dfdb81986d4ea2f6eb535ec453b85d5fe2" translate="yes" xml:space="preserve">
          <source>Performance does not always increase with memory-mapped I/O. In fact, it is possible to construct test cases where performance is reduced by the use of memory-mapped I/O.</source>
          <target state="translated">메모리 매핑 된 I / O로 성능이 항상 향상되는 것은 아닙니다. 실제로 메모리 매핑 된 I / O를 사용하여 성능이 저하되는 테스트 사례를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61bd66ed39fd686f0ca14a86562254f51520b57c" translate="yes" xml:space="preserve">
          <source>Performance enhancement: Reengineer the internal routines used to interpret and render variable-length integers.</source>
          <target state="translated">성능 향상 : 가변 길이 정수를 해석하고 렌더링하는 데 사용되는 내부 루틴을 리엔지니어링하십시오.</target>
        </trans-unit>
        <trans-unit id="cea233e3b9eddbf52457c8a5a182ae23ce06f170" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the &lt;a href=&quot;lemon&quot;&gt;Lemon&lt;/a&gt;-generated parser</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬의&lt;/a&gt; 성능 향상 생성 파서</target>
        </trans-unit>
        <trans-unit id="c2ed78164f58cda3689de3af94b6683e701f4012" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the VDBE, especially to the OP_Column opcode.</source>
          <target state="translated">VDBE, 특히 OP_Column opcode에 대한 성능 향상.</target>
        </trans-unit>
        <trans-unit id="3e83f7e02f169f16c4ce4c1bf1daf1d4f6a2d0dd" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the parser.</source>
          <target state="translated">파서의 성능 향상</target>
        </trans-unit>
        <trans-unit id="1553d9684987d03c293eb61361d1bad6eb661140" translate="yes" xml:space="preserve">
          <source>Performance enhancements in the sorter used by ORDER BY and CREATE INDEX.</source>
          <target state="translated">ORDER BY 및 CREATE INDEX에서 사용하는 분류기의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="d07c917b16f3c5d3172eade92a68d5375afe8a41" translate="yes" xml:space="preserve">
          <source>Performance enhancements on some corner cases of COUNT(*).</source>
          <target state="translated">일부 경우 COUNT (*)의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="2136335adf2e68388f67bd194f29e528095a22d7" translate="yes" xml:space="preserve">
          <source>Performance enhancements through reductions in disk I/O:</source>
          <target state="translated">디스크 I / O 감소를 통한 성능 향상 :</target>
        </trans-unit>
        <trans-unit id="f10f9c4b246cd76bbc82d16d809b97086003c9dc" translate="yes" xml:space="preserve">
          <source>Performance enhancements to tree balancing logic in the B-Tree layer.</source>
          <target state="translated">B-Tree 레이어의 트리 밸런싱 로직 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="c1957e5fe4e4a95d607424db9c544dbfb2c9f147" translate="yes" xml:space="preserve">
          <source>Performance enhancements.</source>
          <target state="translated">성능 향상</target>
        </trans-unit>
        <trans-unit id="fd543174849447437d626cec826158c9d3d9aa89" translate="yes" xml:space="preserve">
          <source>Performance improvement: Constant subexpressions are factored out of loops.</source>
          <target state="translated">성능 향상 : 상수 하위 표현식이 루프에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="6267206177784b60f0b03bc62ec213be82afcde6" translate="yes" xml:space="preserve">
          <source>Performance improvement: Results of OP_Column are reused rather than issuing multiple OP_Column opcodes.</source>
          <target state="translated">성능 개선 : 여러 OP_Column opcode를 발행하는 대신 OP_Column의 결과가 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="865a67eeabea312b0a75ae22ab67eb186cfe013a" translate="yes" xml:space="preserve">
          <source>Performance improvement: The OP_IdxDelete opcode uses unpacked records, obviating the need for one OP_MakeRecord opcode call for each index record deleted.</source>
          <target state="translated">성능 향상 : OP_IdxDelete opcode는 압축 해제 된 레코드를 사용하므로 삭제 된 각 인덱스 레코드마다 OP_MakeRecord opcode 호출이 하나 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78e2db7e7f2b2267a1830af4b4a2ed0ba33c683b" translate="yes" xml:space="preserve">
          <source>Performance improvements for &quot;count(*)&quot; queries.</source>
          <target state="translated">&quot;count (*)&quot;쿼리의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="6efb6a4d8f17dc824c346d05f15cd7b2b88dcf5d" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt;, &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;, &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; , &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; , &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check의&lt;/a&gt; 성능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c7ba2d57a08f2fc705e0114aa7d1ce0a8358e340" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum&lt;/a&gt;, especially in cases where the number of free pages is greater than what will fit on a single trunk page of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;PRAGMA incremental_vacuum의&lt;/a&gt; 성능 향상 , 특히 사용 가능한 페이지 수가 사용 가능 목록의 단일 트렁크 페이지에 적합한 것보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="ca9c11fd98f734889e089bb0e89c4f23dda7fe58" translate="yes" xml:space="preserve">
          <source>Performance improvements in the LEMON-generated parser.</source>
          <target state="translated">LEMON 생성 파서의 성능 향상</target>
        </trans-unit>
        <trans-unit id="a14e5b6d4c4866ac4384c7883a92dffe274c0fdc" translate="yes" xml:space="preserve">
          <source>Performance improvements in the parser, pager, and WHERE clause code generator.</source>
          <target state="translated">파서, 호출기 및 WHERE 절 코드 생성기의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="4775771a833741ba344ee91f202aad2d4ccd4444" translate="yes" xml:space="preserve">
          <source>Performance improvements in the query optimizer.</source>
          <target state="translated">쿼리 최적화 프로그램의 성능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="db2c756a058cad6c443215c62bd837d8ebcd7c86" translate="yes" xml:space="preserve">
          <source>Performance improvements. The library is now much faster.</source>
          <target state="translated">성능 향상 라이브러리가 훨씬 빨라졌습니다.</target>
        </trans-unit>
        <trans-unit id="7776d02639084ffcec06b8eee5d8080752868819" translate="yes" xml:space="preserve">
          <source>Performance measurements are done with a single compiler (gcc 5.4.0), optimization setting (-Os), and on a single platform (Ubuntu 16.04 LTS on x64). The performance of other compilers and processors may vary.</source>
          <target state="translated">성능 측정은 단일 컴파일러 (gcc 5.4.0), 최적화 설정 (-Os) 및 단일 플랫폼 (x64의 Ubuntu 16.04 LTS)에서 수행됩니다. 다른 컴파일러와 프로세서의 성능은 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4313721e53c3870801c269d394561df5830ac670" translate="yes" xml:space="preserve">
          <source>Performance optimizations targeting a specific use case from a single high-profile user of SQLite. A 12% reduction in the number of CPU operations is achieved (as measured by Valgrind). Actual performance improvements in practice may vary depending on workload. Changes include:</source>
          <target state="translated">단일 SQLite 사용자로부터 특정 사용 사례를 대상으로하는 성능 최적화 Valgrind로 측정 한대로 CPU 작동 수를 12 % 줄였습니다. 실제로 실제 성능 향상은 작업 부하에 따라 달라질 수 있습니다. 변경 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aafc19be49f715a88d989d3b462949b02cf65924" translate="yes" xml:space="preserve">
          <source>Performance problems can often be resolved, even late in the development cycle, using &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, avoiding costly redesign, rewrite, and retest efforts.</source>
          <target state="translated">&lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX를&lt;/a&gt; 사용하여 개발주기 후반에도 성능 문제를 해결할 수있어 비용이 많이 드는 재 설계, 재 작성 및 재검사 노력을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80d748ed593bda4d15f97528a4a48c139940ad2c" translate="yes" xml:space="preserve">
          <source>Performance was measured by running speedtest1 using cachegrind and observing the &quot;I refs&quot; output.</source>
          <target state="translated">cachegrind를 사용하여 speedtest1을 실행하고 &quot;I refs&quot;출력을 관찰하여 성능을 측정했습니다.</target>
        </trans-unit>
        <trans-unit id="fd932d13fa7bed8f3a51946f0c1cded4ce734cc8" translate="yes" xml:space="preserve">
          <source>Performance was measured using the &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; utility program, which attempts to mimic a typical workload for SQLite. Options to the test runs are:</source>
          <target state="translated">SQLite의 일반적인 작업 부하를 모방하려는 &lt;a href=&quot;https://sqlite.org/src/file/test/speedtest1.c&quot;&gt;speedtest1.c&lt;/a&gt; 유틸리티 프로그램을 사용하여 성능을 측정했습니다 . 테스트 실행 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="306df6900907956d3250e5c6b9116143f3e59d56" translate="yes" xml:space="preserve">
          <source>Perhaps you are referring to the following statement from SQL92:</source>
          <target state="translated">아마도 SQL92에서 다음 명령문을 참조하고있을 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc174949d4e077b47c1979929b03d9b696ed5987" translate="yes" xml:space="preserve">
          <source>Permit SELECT statements without a FROM clause.</source>
          <target state="translated">FROM 절없이 SELECT 문을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6cbfe59727ef5993727b847bb5705e98e92cb339" translate="yes" xml:space="preserve">
          <source>Permutation</source>
          <target state="translated">Permutation</target>
        </trans-unit>
        <trans-unit id="4fce736ea498cc616300b0a192c1d1da1b783f4c" translate="yes" xml:space="preserve">
          <source>Permuted Title Index</source>
          <target state="translated">순열 제목 색인</target>
        </trans-unit>
        <trans-unit id="d33cf936053187794d74699260279a0a85c60b95" translate="yes" xml:space="preserve">
          <source>Persistent loadable extensions</source>
          <target state="translated">지속적인로드 가능한 확장</target>
        </trans-unit>
        <trans-unit id="cda60e78224642430ac8ecc50f20cf5762fbe57b" translate="yes" xml:space="preserve">
          <source>Phrase and NEAR queries may not span multiple columns within a row.</source>
          <target state="translated">구문 및 NEAR 쿼리는 행 내 여러 열에 걸쳐 있지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8867fcbca825b3aa1d7306421a378db86e201e5f" translate="yes" xml:space="preserve">
          <source>Phrase queries</source>
          <target state="translated">구문 쿼리</target>
        </trans-unit>
        <trans-unit id="a363180d8d104ea58876b6a7416ecc65d37a83bd" translate="yes" xml:space="preserve">
          <source>Phrase queries are not available.</source>
          <target state="translated">구문 쿼리를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c2d36c2214269a55cf08fe15db0efb7f6b50dc52" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may also be connected by &lt;b&gt;implicit AND operators&lt;/b&gt;. For simplicity, these are not shown in the BNF grammar above. Essentially, any sequence of phrases or NEAR groups (including those restricted to matching specified columns) separated only by whitespace are handled as if there were an implicit AND operator between each pair of phrases or NEAR groups. Implicit AND operators are never inserted after or before an expression enclosed in parenthesis. For example:</source>
          <target state="translated">문구 및 NEAR 그룹은 &lt;b&gt;암시 적 AND 연산자&lt;/b&gt; 로 연결될 수도 있습니다 . 간단히하기 위해 위의 BNF 문법에는 표시되지 않습니다. 기본적으로 공백으로 만 분리 된 모든 구문 또는 NEAR 그룹 (지정된 열과 일치하는 것으로 제한되는 것을 포함)은 각 쌍의 구문 또는 NEAR 그룹간에 암시 적 AND 연산자가있는 것처럼 처리됩니다. 암시 적 AND 연산자는 괄호로 묶은 식 뒤에 또는 앞에 삽입되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c324bfc69bd8b1bd8095017021f5a91e3ea40b2c" translate="yes" xml:space="preserve">
          <source>Phrases and NEAR groups may be arranged into expressions using &lt;b&gt;boolean operators&lt;/b&gt;. In order of precedence, from highest (tightest grouping) to lowest (loosest grouping), the operators are:</source>
          <target state="translated">구문 및 NEAR 그룹은 &lt;b&gt;부울 연산자를&lt;/b&gt; 사용하여 표현식으로 배열 될 수 있습니다 . 우선 순위가 가장 높은 그룹 (가장 엄격한 그룹)에서 가장 낮은 그룹 (가장 낮은 그룹)까지 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ae7ce4ac376e04456d5e49b6ed2413b1a3d558b" translate="yes" xml:space="preserve">
          <source>Picking the nested order of the various loops</source>
          <target state="translated">다양한 루프의 중첩 순서 따기</target>
        </trans-unit>
        <trans-unit id="e6557cb061d60a980305721118e117b8668196a9" translate="yes" xml:space="preserve">
          <source>Picking the nesting order is generally the more challenging problem. Once the nesting order of the join is established, the choice of indexes for each loop is normally obvious.</source>
          <target state="translated">중첩 순서를 선택하는 것이 일반적으로 더 어려운 문제입니다. 조인의 중첩 순서가 설정되면 일반적으로 각 루프에 대한 인덱스 선택이 분명합니다.</target>
        </trans-unit>
        <trans-unit id="48838d5eebf4e016bae8e0582e9b79166631f842" translate="yes" xml:space="preserve">
          <source>Pinning (reading) a database page.</source>
          <target state="translated">데이터베이스 페이지 고정 (읽기)</target>
        </trans-unit>
        <trans-unit id="e786fb34d40222929b9ef3bd84afa78c0fc799e8" translate="yes" xml:space="preserve">
          <source>Plays better with virus scanners on Windows</source>
          <target state="translated">Windows에서 바이러스 스캐너로 더 잘 재생</target>
        </trans-unit>
        <trans-unit id="0ba6acad031749dfc1ea19f37cf3cf3ba6821875" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">포인터가에서 반환 된 사실에 특히주의하십시오 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; 에 대한 후속 호출에 의해 무효화 될 수 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;#sqlite3_value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae91e82ac5caaf87714c26921fb437ec0209ebd" translate="yes" xml:space="preserve">
          <source>Please pay particular attention to the fact that the pointer returned from &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt; can be invalidated by a subsequent call to &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16()&lt;/a&gt;, &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text()&lt;/a&gt;, or &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16()&lt;/a&gt;.</source>
          <target state="translated">포인터가에서 반환 된 사실에 특히주의하십시오 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_blob ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; 에 대한 후속 호출에 의해 무효화 될 수 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_bytes16 ()&lt;/a&gt; , &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text ()&lt;/a&gt; , 또는 &lt;a href=&quot;value_blob&quot;&gt;sqlite3_value_text16 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82e80b8ed5a5ef5a7f7f84502fd344efe74ab819" translate="yes" xml:space="preserve">
          <source>Plug some memory leaks that use to occur if malloc() failed. We have been and continue to be memory leak free as long as malloc() works.</source>
          <target state="translated">malloc ()이 실패한 경우 발생하는 메모리 누수를 연결하십시오. malloc ()이 작동하는 한 메모리 누수가없는 상태입니다.</target>
        </trans-unit>
        <trans-unit id="9885c5aa124b354814a6a44123b3e909495fe046" translate="yes" xml:space="preserve">
          <source>Pointer Passing Interfaces</source>
          <target state="translated">포인터 전달 인터페이스</target>
        </trans-unit>
        <trans-unit id="59e3eae717dea15b934265a0c37302cf590a5714" translate="yes" xml:space="preserve">
          <source>Pointer leak</source>
          <target state="translated">포인터 누출</target>
        </trans-unit>
        <trans-unit id="893d8abe3b1d2dc513b4dcba9c2db9ee48da24a6" translate="yes" xml:space="preserve">
          <source>Pointer map or ptrmap pages are extra pages inserted into the database to make the operation of &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; modes more efficient. Other page types in the database typically have pointers from parent to child. For example, an interior b-tree page contains pointers to its child b-tree pages and an overflow chain has a pointer from earlier to later links in the chain. A ptrmap page contains linkage information going in the opposite direction, from child to parent.</source>
          <target state="translated">포인터 맵 또는 ptrmap 페이지는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 모드 작업을 보다 효율적으로 수행 할 수 있도록 데이터베이스에 추가 된 페이지 입니다. 데이터베이스의 다른 페이지 유형에는 일반적으로 부모에서 자식으로의 포인터가 있습니다. 예를 들어, 내부 b- 트리 페이지에는 하위 b- 트리 페이지에 대한 포인터가 포함되고 오버플로 체인에는 체인의 이전 링크에서 이후 링크까지의 포인터가 있습니다. ptrmap 페이지에는 하위에서 상위로 반대 방향으로 연결 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9fb370b0a40e2e2f19446936bcadb07206247ac" translate="yes" xml:space="preserve">
          <source>Pointer types</source>
          <target state="translated">포인터 타입</target>
        </trans-unit>
        <trans-unit id="1091e0ac6927998f6cf6d184bfe2c9b9dcea6870" translate="yes" xml:space="preserve">
          <source>Pointer types are static strings, which ideally should be string literals embedded directly in the SQLite API call, not parameters passed in from other functions. Consideration was given to using integer values as the pointer type, but static strings provides a much larger name space which reduces the chance of accidental type-name collisions between unrelated extensions.</source>
          <target state="translated">포인터 유형은 정적 문자열이며 다른 함수에서 전달 된 매개 변수가 아닌 SQLite API 호출에 직접 포함 된 문자열 리터럴이어야합니다. 정수 값을 포인터 유형으로 사용하는 것을 고려했지만 정적 문자열은 훨씬 더 큰 이름 공간을 제공하여 관련없는 확장간에 우발적 인 유형 이름 충돌 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="3b1d288532e92abf21814dda987180d6353e6315" translate="yes" xml:space="preserve">
          <source>Pointer values generated by &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; cannot be read by pure SQL. Hence, it is not possible for SQL to leak the value of pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()에&lt;/a&gt; 의해 생성 된 포인터 값 은 순수 SQL로 읽을 수 없습니다. 따라서 SQL이 포인터 값을 유출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="362edd7f45230e1071baa348e5b8aa0beef2dc87" translate="yes" xml:space="preserve">
          <source>Pointer values must flow directly from their producer into their consumer, with no intermediate operators or functions. Any transformation of a pointer value destroys the pointer and transforms the value into an ordinary SQL NULL.</source>
          <target state="translated">포인터 값은 중간 연산자 나 함수없이 생산자에서 소비자에게 직접 전달되어야합니다. 포인터 값을 변환하면 포인터가 삭제되고 값이 일반 SQL NULL로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d40a766f8bf600e29b3ebb06afc3c66d8eb2275c" translate="yes" xml:space="preserve">
          <source>Pointer values read by &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt; cannot be generated by pure SQL. Hence, it is not possible for SQL to forge pointers.</source>
          <target state="translated">&lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()로&lt;/a&gt; 읽은 포인터 값 은 순수 SQL로 생성 할 수 없습니다. 따라서 SQL에서 포인터를 위조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="074017050c52f59774a49045cefb3a8e55469503" translate="yes" xml:space="preserve">
          <source>Pointers should &lt;u&gt;never&lt;/u&gt; be exchanged by encoding them as some other SQL datatype, such as integers or BLOBs. Instead, use the interfaces designed to facilitate secure pointer passing: &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt;, and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">포인터는 정수 또는 BLOB와 같은 다른 SQL 데이터 유형으로 인코딩하여 교환 해서는 &lt;u&gt;안됩니다&lt;/u&gt; . 대신 보안 포인터 전달을 용이하게하도록 설계된 인터페이스 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3758fcfa626c0aaafd8e85f7ec0b94d37eb1b41f" translate="yes" xml:space="preserve">
          <source>Porting SQLite To New Operating Systems</source>
          <target state="translated">SQLite를 새로운 운영 체제로 포팅</target>
        </trans-unit>
        <trans-unit id="492619cf72b9410d05b5a1fac306af0804a5c47b" translate="yes" xml:space="preserve">
          <source>Position cursor P1 at the end of the btree for the purpose of appending a new entry onto the btree.</source>
          <target state="translated">btree에 새 항목을 추가하기 위해 btree 끝에 커서 P1을 놓습니다.</target>
        </trans-unit>
        <trans-unit id="24fd6c2d1150de6a47543209150ff4c2a2d3104f" translate="yes" xml:space="preserve">
          <source>PostgreSQL</source>
          <target state="translated">PostgreSQL</target>
        </trans-unit>
        <trans-unit id="a6c78fee1df30606dfc4f598f623eca0d1354255" translate="yes" xml:space="preserve">
          <source>PostgreSQL:</source>
          <target state="translated">PostgreSQL:</target>
        </trans-unit>
        <trans-unit id="957feaeb06e5a65656c3283c9c7193ebcf008b45" translate="yes" xml:space="preserve">
          <source>Postpone I/O associated with TEMP files for as long as possible, with the hope that the I/O can ultimately be avoided completely.</source>
          <target state="translated">I / O를 완전히 피할 수 있기를 바랍니다. 가능한 한 오랫동안 TEMP 파일과 연관된 I / O를 연기하십시오.</target>
        </trans-unit>
        <trans-unit id="1bdd037a51c3dae4c27aa3b443867933947439ca" translate="yes" xml:space="preserve">
          <source>Powersafe Overwrite</source>
          <target state="translated">전력 안전 덮어 쓰기</target>
        </trans-unit>
        <trans-unit id="10329807f69720bd141eb1a12685730b2cfaf4cd" translate="yes" xml:space="preserve">
          <source>Pragma list</source>
          <target state="translated">프라 그마 목록</target>
        </trans-unit>
        <trans-unit id="c984aa3372c91f167c3b8d4c0c9f9715c82d4221" translate="yes" xml:space="preserve">
          <source>Pragma statements supported by SQLite</source>
          <target state="translated">SQLite가 지원하는 Pragma 문</target>
        </trans-unit>
        <trans-unit id="4a80a5f45da767ce7271bd5ac307890ba0ff78a6" translate="yes" xml:space="preserve">
          <source>Pragmas whose names are &lt;s&gt;struck through&lt;/s&gt; are deprecated. Do not use them. They exist for historical compatibility.</source>
          <target state="translated">이름이있다하는 pragma &lt;s&gt;을 통해 당했다&lt;/s&gt; 되지 않습니다. 사용하지 마십시오. 역사적 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="36fd60583248a73e8dcb8aeb3b04450519f9ddea" translate="yes" xml:space="preserve">
          <source>Pray for your enemies in the love of Christ.</source>
          <target state="translated">그리스도의 사랑 안에서 원수들을 위해기도하십시오.</target>
        </trans-unit>
        <trans-unit id="1d437b581e9dcd72eb07665e29677b9a7ea18988" translate="yes" xml:space="preserve">
          <source>Prefer nothing more than the love of Christ.</source>
          <target state="translated">그리스도의 사랑 이상을 선호하십시오.</target>
        </trans-unit>
        <trans-unit id="6b85b242b16c8eaf303d30b62e8918e8c764ab9e" translate="yes" xml:space="preserve">
          <source>Prefix indexes may be used to optimize &lt;a href=&quot;fts3#termprefix&quot;&gt;prefix queries&lt;/a&gt; in two cases. If the query is for a prefix of N bytes, then a prefix index created with &quot;prefix=N&quot; provides the best optimization. Or, if no &quot;prefix=N&quot; index is available, a &quot;prefix=N+1&quot; index may be used instead. Using a &quot;prefix=N+1&quot; index is less efficient than a &quot;prefix=N&quot; index, but is better than no prefix index at all.</source>
          <target state="translated">접두사 인덱스는 두 가지 경우에 &lt;a href=&quot;fts3#termprefix&quot;&gt;접두사 쿼리&lt;/a&gt; 를 최적화하는 데 사용될 수 있습니다 . 쿼리의 접두사가 N 바이트 인 경우 &quot;prefix = N&quot;으로 만든 접두사 인덱스는 최상의 최적화를 제공합니다. 또는 &quot;prefix = N&quot;색인을 사용할 수없는 경우 &quot;prefix = N + 1&quot;색인을 대신 사용할 수 있습니다. &quot;prefix = N + 1&quot;인덱스를 사용하는 것은 &quot;prefix = N&quot;인덱스보다 효율적이지 않지만 접두어 인덱스가없는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="f58acbef3b4f1545b36db43fdb7aa3248226ddc3" translate="yes" xml:space="preserve">
          <source>Prefix query</source>
          <target state="translated">접두사 쿼리</target>
        </trans-unit>
        <trans-unit id="d876a9e47626f4666efcfc69bdf4c50fcc426b9e" translate="yes" xml:space="preserve">
          <source>Prefix search in FTS3 is much more efficient.</source>
          <target state="translated">FTS3의 접두사 검색이 훨씬 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="f3d20f83dbeeb1d79306958dea533c43146bb29c" translate="yes" xml:space="preserve">
          <source>Prepare Flags</source>
          <target state="translated">깃발 준비</target>
        </trans-unit>
        <trans-unit id="d5f65540d8f04f5669bf0a7783fb7256d5f3309f" translate="yes" xml:space="preserve">
          <source>Prepared Statement Object</source>
          <target state="translated">준비된 명세서 객체</target>
        </trans-unit>
        <trans-unit id="d84580c0a3c076e6a6095c0d8c0427ccdaa13d1e" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status</source>
          <target state="translated">준비된 명령문 스캔 상태</target>
        </trans-unit>
        <trans-unit id="1037ef270384cfd9be096004017447826d2cb2f5" translate="yes" xml:space="preserve">
          <source>Prepared Statement Scan Status Opcodes</source>
          <target state="translated">준비된 명령문 스캔 상태 Opcode</target>
        </trans-unit>
        <trans-unit id="2f5da103100b3440f26c60eb3e05807f62717d70" translate="yes" xml:space="preserve">
          <source>Prepared Statement Status</source>
          <target state="translated">준비된 진술서 상태</target>
        </trans-unit>
        <trans-unit id="213d6f218c41a8dc480fb564c77564038e40e839" translate="yes" xml:space="preserve">
          <source>Prepend as many &quot;0&quot; characters to numeric substitutions as necessary to expand the value out to the specified width. If the width field is omitted, then this flag is a no-op.</source>
          <target state="translated">값을 지정된 너비로 확장하려면 필요한만큼 숫자 대체에 &quot;0&quot;문자를 추가하십시오. 너비 필드가 생략되면이 플래그는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="07ea5425dab39a1ce6090bfaba72b208d8a2bb32" translate="yes" xml:space="preserve">
          <source>Prepend the &quot;&lt;code&gt;file:&lt;/code&gt;&quot; scheme.</source>
          <target state="translated">&quot; &lt;code&gt;file:&lt;/code&gt; &quot;체계를 앞에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b5b2c6aa0c741177b3341a9cac682f0503cc7181" translate="yes" xml:space="preserve">
          <source>Pretend that the single row just extracted is the only row in the recursive table and run the recursive-select, adding all results to the queue.</source>
          <target state="translated">방금 추출한 단일 행이 재귀 테이블의 유일한 행인 것으로 가정하고 모든 결과를 큐에 추가하여 재귀 선택을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="e96fea52df5eb0d7ea088eb0523f5fd6be20645f" translate="yes" xml:space="preserve">
          <source>Prev</source>
          <target state="translated">Prev</target>
        </trans-unit>
        <trans-unit id="d011a785f80d4ac2978260fd4baeb9a488339607" translate="yes" xml:space="preserve">
          <source>Prevent journal file overflows on huge transactions.</source>
          <target state="translated">대규모 트랜잭션에서 저널 파일 오버 플로우를 방지하십시오.</target>
        </trans-unit>
        <trans-unit id="15aff2aaf0be53526cd90b44a8f7faa67462af63" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/docsrc&quot;&gt;https://www.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb559fe38e423e3bb19de0649fe3fd5b6b237723" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/sqllogictest&quot;&gt;https://www.sqlite.org/sqllogictest&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40da77fe99b4c2e0002b4b5a88b9bdf5b5ffd788" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/src&quot;&gt;https://www.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72c44b5ab0d08449343e1c11f7db59a0baee6a06" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/th3&quot;&gt;https://www.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="284d8db03255f327420e4917415f7de011fcda53" translate="yes" xml:space="preserve">
          <source>Primary location: &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</source>
          <target state="translated">기본 위치 : &lt;a href=&quot;https://www.sqlite.org/th3private&quot;&gt;https://www.sqlite.org/th3private&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="12c6ce30d8dde9c30a0548e43a1a65f2399c3ac8" translate="yes" xml:space="preserve">
          <source>Primary result code symbolic names are of the form &quot;SQLITE_XXXXXX&quot; where XXXXXX is a sequence of uppercase alphabetic characters. Extended result code names are of the form &quot;SQLITE_XXXXXX_YYYYYYY&quot; where the XXXXXX part is the corresponding primary result code and the YYYYYYY is an extension that further classifies the result code.</source>
          <target state="translated">기본 결과 코드 기호 이름은 &quot;SQLITE_XXXXXX&quot;형식이며 여기서 XXXXXX는 대문자 알파벳 순서입니다. 확장 결과 코드 이름은 &quot;SQLITE_XXXXXX_YYYYYYY&quot;형식이며 여기서 XXXXXX 부분은 해당 기본 결과 코드이고 YYYYYYY는 결과 코드를 추가로 분류하는 확장입니다.</target>
        </trans-unit>
        <trans-unit id="4fda803b9a957798a3e6c9099105e126c5e73e36" translate="yes" xml:space="preserve">
          <source>Primary versus extended result codes</source>
          <target state="translated">기본 및 확장 결과 코드</target>
        </trans-unit>
        <trans-unit id="3b2d52029dad08f51a816bff4a2b1ace042995a8" translate="yes" xml:space="preserve">
          <source>Print the offending SQL statement when an error occurs.</source>
          <target state="translated">오류가 발생하면 문제가되는 SQL 문을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="93863d358af110c5080e64cc1cfc5d8749e0490f" translate="yes" xml:space="preserve">
          <source>Prior to &lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;version 3.8.0&lt;/a&gt; (2013-08-26), SQLite always used the &quot;Nearest Neighbor&quot; or &quot;NN&quot; heuristic when searching for the best query plan. The NN heuristic makes a single traversal of the graph, always choosing the lowest-cost arc as the next step. The NN heuristic works surprisingly well in most cases. And NN is fast, so that SQLite is able to quickly find good plans for even large 64-way joins. In contrast, other SQL database engines that do more extensive searching tend to bog down when the number of tables in a join goes above 10 or 15.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_8_0.html&quot;&gt;버전 3.8.0&lt;/a&gt; (2013-08-26) 이전에 SQLite는 최상의 쿼리 계획을 검색 할 때 항상 &quot;가장 가까운 이웃&quot;또는 &quot;NN&quot;휴리스틱을 사용했습니다. NN 휴리스틱은 그래프의 단일 순회를 수행하여 항상 다음 단계로 가장 저렴한 아크를 선택합니다. NN 휴리스틱은 대부분의 경우 놀랍도록 잘 작동합니다. 그리고 NN은 빠르기 때문에 SQLite는 대규모 64 웨이 조인에 대한 좋은 계획을 신속하게 찾을 수 있습니다. 반대로,보다 광범위한 검색을 수행하는 다른 SQL 데이터베이스 엔진은 조인의 테이블 수가 10 또는 15를 초과 할 때 멈춤 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbead769cfd094dac2d1d702814135203e88038" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.20.0 (2017-08-01) all date/time functions were always considered non-deterministic. The ability for date/time functions to be deterministic sometimes and non-deterministic at other times, depending on their arguments, was added for the 3.20.0 release.</source>
          <target state="translated">SQLite 3.20.0 (2017-08-01) 이전에는 모든 날짜 / 시간 함수가 항상 비 결정적인 것으로 간주되었습니다. 인수에 따라 날짜 / 시간 함수가 결정적이고 때로는 결정적이지 않은 기능이 3.20.0 릴리스에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="6c7f8cc84bc5292827563b13ba75248881d97140" translate="yes" xml:space="preserve">
          <source>Prior to SQLite 3.7.15 (2012-12-12), a subquery in the FROM clause would be either flattened into the outer query, or else the subquery would be run to completion before the outer query started, the result set from the subquery would be stored in a transient table, and then the transient table would be used in the outer query. Newer versions of SQLite have a third option, which is to implement the subquery using a co-routine.</source>
          <target state="translated">SQLite 3.7.15 (2012-12-12) 이전에는 FROM 절의 하위 쿼리가 외부 쿼리로 병합되거나 외부 쿼리가 시작되기 전에 하위 쿼리가 완료 될 때까지 하위 쿼리가 실행됩니다. 임시 테이블에 저장된 다음 외부 쿼리에 임시 테이블이 사용됩니다. 최신 버전의 SQLite에는 공동 루틴을 사용하여 하위 쿼리를 구현하는 세 번째 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a720aafd2afa8c2c385472fc2e648bd2ccdf321e" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the arguments to fts3_tokenzer() could be literal strings or BLOBs. They did not have to be &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt;. But that could lead to security problems in the event of an SQL injection. Hence, the legacy behavior is now disabled by default. But the old legacy behavior can be enabled, for backwards compatibility in applications that really need it, by calling &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0).</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;버전 3.11.0&lt;/a&gt; (2016-02-15) 이전에 fts3_tokenzer ()에 대한 인수는 리터럴 문자열 또는 BLOB 일 수 있습니다. &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수를 바인딩&lt;/a&gt; 할 필요는 없습니다 . 그러나 이로 인해 SQL 삽입시 보안 문제가 발생할 수 있습니다. 따라서 레거시 동작은 이제 기본적으로 비활성화되어 있습니다. 그러나 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0) 를 호출하여 실제로 필요한 응용 프로그램에서 이전 버전과의 호환성을 위해 이전 레거시 동작을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51d8edb11a84377ed9b294770763b3964473b7ee" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10), the virtual table mechanism assumes that each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; kept its own copy of the database schema. Hence, the virtual table mechanism could not be used in a database that has &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; enabled. The &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; interface would return an error if &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; is enabled. That restriction was relaxed beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; (2009-08-10) 이전에는 가상 테이블 메커니즘이 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 자체 데이터베이스 스키마 사본을 유지 한다고 가정합니다 . 따라서 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 사용 가능한 데이터베이스에서 가상 테이블 메커니즘을 사용할 수 없습니다 . &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 경우 인터페이스는 오류를 반환 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드가&lt;/a&gt; 활성화됩니다. 이 제한은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; 부터 완화 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="33d0fd70a8f55e9f98c0c7adf04301e981d0c322" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), recursive triggers were not supported. The behavior of SQLite was always as if this pragma was set to OFF. Support for recursive triggers was added in version 3.6.18 but was initially turned OFF by default, for compatibility. Recursive triggers may be turned on by default in future versions of SQLite.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11) 이전에는 재귀 트리거가 지원되지 않았습니다. SQLite의 동작은 항상이 pragma가 OFF로 설정된 것처럼 작동했습니다. 재귀 트리거에 대한 지원은 버전 3.6.18에서 추가되었지만 호환성을 위해 기본적으로 기본적으로 해제되어 있습니다. 이후 버전의 SQLite에서는 기본적으로 재귀 트리거가 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28758e140ed243892fd7015e84c9739d352fdbe" translate="yes" xml:space="preserve">
          <source>Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;version 3.6.18&lt;/a&gt; (2009-09-11), triggers were not recursive and so this limit was meaningless. Beginning with version 3.6.18, recursive triggers were supported but had to be explicitly enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement. Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2009-09-11), recursive triggers are enabled by default but can be manually disabled using &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt;. The SQLITE_MAX_TRIGGER_DEPTH is only meaningful if recursive triggers are enabled.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_18.html&quot;&gt;버전 3.6.18&lt;/a&gt; (2009-09-11) 이전에는 트리거가 재귀 적이 지 않았 으므로이 한계는 의미가 없었습니다. 버전 3.6.18부터 재귀 트리거가 지원되었지만 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; 문을 사용하여 명시 적으로 활성화해야했습니다 . 를 시작으로 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2009-09-11), 재귀 트리거는 기본적으로 활성화되어 있지만, 수동으로 사용하지 않도록 설정할 수 있습니다 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA의 RECURSIVE_TRIGGERS을&lt;/a&gt; . SQLITE_MAX_TRIGGER_DEPTH는 재귀 트리거가 활성화 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="534f30ad3bfba01b49cf3bf01218d9cf22140413" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.17.0, the session extension only worked with &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;, not &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables. As of 3.17.0, both rowid and WITHOUT ROWID tables are supported.</source>
          <target state="translated">SQLite 버전 3.17.0 이전에는 세션 확장이 &lt;a href=&quot;withoutrowid&quot;&gt;ROWID&lt;/a&gt; 테이블이 아닌 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 에서만 작동했습니다 . 3.17.0부터 rowid 및 WITHOUT ROWID 테이블이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca3ddf5fd526ae6f9a1aaa722828cf40f2bf92a" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.3.14, a sector size of 512 bytes was assumed in all cases. There was a compile-time option to change this but the code had never been tested with a larger value. The 512 byte sector assumption seemed reasonable since until very recently all disk drives used a 512 byte sector internally. However, there has recently been a push to increase the sector size of disks to 4096 bytes. Also the sector size for flash memory is usually larger than 512 bytes. For these reasons, versions of SQLite beginning with 3.3.14 have a method in the OS interface layer that interrogates the underlying filesystem to find the true sector size. As currently implemented (version 3.5.0) this method still returns a hard-coded value of 512 bytes, since there is no standard way of discovering the true sector size on either Unix or Windows. But the method is available for embedded device manufacturers to tweak according to their own needs. And we have left open the possibility of filling in a more meaningful implementation on Unix and Windows in the future.</source>
          <target state="translated">SQLite 버전 3.3.14 이전에는 모든 경우에 512 바이트의 섹터 크기가 가정되었습니다. 이것을 변경하는 컴파일 타임 옵션이 있었지만 코드는 더 큰 값으로 테스트되지 않았습니다. 512 바이트 섹터 가정은 최근까지 모든 디스크 드라이브가 512 바이트 섹터를 내부적으로 사용했기 때문에 합리적으로 보였다. 그러나 최근 디스크의 섹터 크기를 4096 바이트로 늘리려는 시도가있었습니다. 또한 플래시 메모리의 섹터 크기는 일반적으로 512 바이트보다 큽니다. 이러한 이유로 3.3.14로 시작하는 SQLite 버전에는 OS 파일 계층에 기본 파일 시스템을 조사하여 실제 섹터 크기를 찾는 방법이 있습니다. 현재 구현 된 (버전 3.5.0)이 방법은 여전히 ​​하드 코딩 된 512 바이트 값을 반환합니다. Unix 또는 Windows에서 실제 섹터 크기를 검색하는 표준 방법이 없기 때문입니다.그러나이 방법은 임베디드 디바이스 제조업체가 자신의 필요에 따라 조정할 수 있습니다. 그리고 향후 Unix 및 Windows에서보다 의미있는 구현을 작성할 가능성을 열어 놓았습니다.</target>
        </trans-unit>
        <trans-unit id="d9c2ee7b5aac6da179c8f578b8285aa5c54f4524" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.7.10 이전의 Windows OS 인터페이스 계층은 SQLite에서 사용하는 UTF-8 인코딩과 특정 Windows 설치에서 사용되는 파일 이름 인코딩간에 파일 이름을 변환 할 때 시스템 malloc () 및 free ()를 직접 호출했습니다. 메모리 할당 오류가 감지되었지만 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 대신 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 또는 SQLITE_IOERR &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;로보고되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91089ffc77affdb7ae59f739dbaf9014a293f340" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.7.10, the Windows OS interface layer called the system malloc() and free() directly when converting filenames between the UTF-8 encoding used by SQLite and whatever filename encoding is used by the particular Windows installation. Memory allocation errors were detected, but they were reported back as &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; or &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_IOERR&lt;/a&gt; rather than &lt;a href=&quot;../rescode#nomem&quot;&gt;SQLITE_NOMEM&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.7.10 이전의 Windows OS 인터페이스 계층은 SQLite에서 사용하는 UTF-8 인코딩과 특정 Windows 설치에서 사용되는 파일 이름 인코딩간에 파일 이름을 변환 할 때 시스템 malloc () 및 free ()를 직접 호출했습니다. 메모리 할당 오류가 감지되었지만 &lt;a href=&quot;../rescode#ioerr&quot;&gt;SQLITE_NOMEM&lt;/a&gt; 대신 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt; 또는 SQLITE_IOERR &lt;a href=&quot;../rescode#nomem&quot;&gt;로보고되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4f00bebae92fba462c0a2ff1a68401159dfc1bce" translate="yes" xml:space="preserve">
          <source>Prior to SQLite version 3.8.2 (2013-12-06), casting a REAL value greater than +9223372036854775807.0 into an integer resulted in the most negative integer, -9223372036854775808. This behavior was meant to emulate the behavior of x86/x64 hardware when doing the equivalent cast.</source>
          <target state="translated">SQLite 버전 3.8.2 (2013-12-06) 이전에는 +9223372036854775807.0보다 큰 REAL 값을 정수로 캐스트하면 가장 음의 정수인 -9223372036854775808이 발생했습니다. 이 동작은 동등한 캐스트를 수행 할 때 x86 / x64 하드웨어의 동작을 에뮬레이션하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a1634472b77cd282aba3425a6cf5a2a4d268772c" translate="yes" xml:space="preserve">
          <source>Prior to each check-in to the SQLite source tree, developers typically run a subset (called &quot;veryquick&quot;) of the Tcl tests consisting of about 248.5 thousand test cases. The veryquick tests include most tests other than the anomaly, fuzz, and soak tests. The idea behind the veryquick tests are that they are sufficient to catch most errors, but also run in only a few minutes instead of a few hours.</source>
          <target state="translated">SQLite 소스 트리에 체크인 할 때마다 개발자는 일반적으로 약 248.5 천 개의 테스트 사례로 구성된 Tcl 테스트의 하위 집합 ( &quot;매우 빠른&quot;)을 실행합니다. 매우 빠른 테스트에는 이상, 퍼지 및 흡수 테스트 이외의 대부분의 테스트가 포함됩니다. 매우 빠른 테스트의 기본 개념은 대부분의 오류를 포착하기에 충분하지만 몇 시간이 아니라 몇 분만에 실행될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce5fd27df1123f4d155915fc1d5725287e09a7ea" translate="yes" xml:space="preserve">
          <source>Prior to making any changes to the database file, SQLite first creates a separate rollback journal file and writes into the rollback journal the original content of the database pages that are to be altered. The idea behind the rollback journal is that it contains all information needed to restore the database back to its original state.</source>
          <target state="translated">데이터베이스 파일을 변경하기 전에 SQLite는 먼저 별도의 롤백 저널 파일을 작성하고 롤백 저널에 변경 될 데이터베이스 페이지의 원래 컨텐츠를 씁니다. 롤백 저널의 기본 개념은 데이터베이스를 원래 상태로 복원하는 데 필요한 모든 정보를 포함한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e201518d0d186ad7cdf7483565006fe761fd040" translate="yes" xml:space="preserve">
          <source>Prior to making changes to the database file itself, we must obtain an exclusive lock on the database file. Obtaining an exclusive lock is really a two-step process. First SQLite obtains a &quot;pending&quot; lock. Then it escalates the pending lock to an exclusive lock.</source>
          <target state="translated">데이터베이스 파일 자체를 변경하기 전에 데이터베이스 파일에 대한 독점 잠금을 얻어야합니다. 독점 잠금을 얻는 것은 실제로 두 단계 프로세스입니다. 첫 번째 SQLite는 &quot;보류중인&quot;잠금을 얻습니다. 그런 다음 보류중인 잠금을 독점 잠금으로 에스컬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="3f85c53dbe23e0808bcb91d75d8ad07e4c7bc69c" translate="yes" xml:space="preserve">
          <source>Prior to version 3.26.0 (2018-12-01), FOREIGN KEY references to a table that is renamed were only edited if the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt;, or in other words if &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; were begin enforced. With &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=OFF&lt;/a&gt;, FOREIGN KEY constraints would not be changed when the table that the foreign key referred to (the &quot;&lt;a href=&quot;foreignkeys#parentchild&quot;&gt;parent table&lt;/a&gt;&quot;) was renamed. Beginning with version 3.26.0, FOREIGN KEY constraints are always converted when a table is renamed, unless the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; setting is engaged. The following table summaries the difference:</source>
          <target state="translated">버전 3.26.0 (2018-12-01) 이전에 이름이 바뀐 테이블에 대한 FOREIGN KEY 참조는 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON&lt;/a&gt; 또는 다른 말로 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 이 적용된 경우에만 편집 되었습니다. 으로 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA의 foreign_keys = OFF는&lt;/a&gt; 외부 키가 (이하 &quot;라고하는 테이블 때, FOREIGN KEY 제약 조건이 변경되지 않을 것이다 &lt;a href=&quot;foreignkeys#parentchild&quot;&gt;부모 테이블&lt;/a&gt; &quot;)로 변경되었습니다. 버전 3.26.0부터는 &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt; 설정을 사용 하지 않는 한 테이블 이름을 바꿀 때 FOREIGN KEY 제약 조건이 항상 변환됩니다 . 다음 표는 차이점을 요약 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5f15493198f102fc11171baf7abf0e0dbb2b1e4b" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory()&lt;/a&gt; function would try to reclaim memory from all database connections in the same thread as the sqlite3_release_memory() call. Beginning with version 3.5.0, the sqlite3_release_memory() function will attempt to reclaim memory from all database connections in all threads.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/release_memory&quot;&gt;sqlite3_release_memory ()&lt;/a&gt; 함수는 sqlite3_release_memory () 호출과 동일한 스레드에서 모든 데이터베이스 연결에서 메모리를 회수하려고 시도했습니다. 버전 3.5.0부터 sqlite3_release_memory () 함수는 모든 스레드의 모든 데이터베이스 연결에서 메모리를 회수하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="4167592bfe9ab2523a8fde6561d95f830a107410" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0 the &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt; set an upper bound on heap memory usage for all database connections within a single thread. Each thread could have its own heap limit. Beginning in version 3.5.0, there is a single heap limit for the entire process. This seems more restrictive (one limit as opposed to many) but in practice it is what most users want.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; 는 단일 스레드 내의 모든 데이터베이스 연결에 대한 힙 메모리 사용량의 상한을 설정했습니다. 각 스레드에는 자체 힙 제한이있을 수 있습니다. 버전 3.5.0부터 전체 프로세스에 대한 단일 힙 한계가 있습니다. 이것은 더 제한적인 것처럼 보이지만 (많은 사용자와 달리 한 가지 제한) 실제로는 대부분의 사용자가 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fc681e809e94e340265ecee10f223e6915cced6a" translate="yes" xml:space="preserve">
          <source>Prior to version 3.5.0, the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API would enable and disable the shared cache feature for all connections within a single thread - the same thread from which the sqlite3_enable_shared_cache() routine was called. Database connections that used the shared cache were restricted to running in the same thread in which they were opened. Beginning with version 3.5.0, the sqlite3_enable_shared_cache() applies to all database connections in all threads within the process. Now database connections running in separate threads can share a cache. And database connections that use shared cache can migrate from one thread to another.</source>
          <target state="translated">버전 3.5.0 이전에 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; API는 단일 스레드 내의 모든 연결에 대해 공유 캐시 기능을 사용 및 사용 안함으로 설정했습니다. sqlite3_enable_shared_cache () 루틴이 호출 된 동일한 스레드입니다. 공유 캐시를 사용하는 데이터베이스 연결은 열린 동일한 스레드에서 실행되도록 제한되었습니다. 버전 3.5.0부터 sqlite3_enable_shared_cache ()는 프로세스 내의 모든 스레드에있는 모든 데이터베이스 연결에 적용됩니다. 이제 별도의 스레드에서 실행되는 데이터베이스 연결이 캐시를 공유 할 수 있습니다. 공유 캐시를 사용하는 데이터베이스 연결은 한 스레드에서 다른 스레드로 마이그레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d828632471991da7903c0c2be934633680ad57e8" translate="yes" xml:space="preserve">
          <source>Process A now tries to write to the database. But process A's view of the database content is now obsolete because process B has modified the database file after process A read from it. Hence process A gets an SQLITE_BUSY_SNAPSHOT error.</source>
          <target state="translated">프로세스 A는 이제 데이터베이스에 쓰려고합니다. 그러나 프로세스 B가 프로세스 A가 데이터베이스 파일을 읽은 후 데이터베이스 파일을 수정했기 때문에 프로세스 A의 데이터베이스 컨텐츠보기가 더 이상 사용되지 않습니다. 따라서 프로세스 A는 SQLITE_BUSY_SNAPSHOT 오류를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="6588c47b29127d1f98a87c238369e743b0e77d94" translate="yes" xml:space="preserve">
          <source>Process A starts a read transaction on the database and does one or more SELECT statement. Process A keeps the transaction open.</source>
          <target state="translated">프로세스 A는 데이터베이스에서 읽기 트랜잭션을 시작하고 하나 이상의 SELECT 문을 수행합니다. 프로세스 A는 트랜잭션을 열린 상태로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="7e082f5417cd4ab89e9c56b231bce953e66b35a9" translate="yes" xml:space="preserve">
          <source>Process B updates the database, changing values previous read by process A.</source>
          <target state="translated">프로세스 B는 데이터베이스를 업데이트하여 프로세스 A가 이전에 읽은 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="ee0914d299e6e7430a22ed0faafffc12d302d567" translate="yes" xml:space="preserve">
          <source>Productize and officially support the group_concat() SQL function.</source>
          <target state="translated">group_concat () SQL 함수를 제품화하고 공식적으로 지원하십시오.</target>
        </trans-unit>
        <trans-unit id="9257f2cbe973bd89967c512a0ab4ef3a71be8dcc" translate="yes" xml:space="preserve">
          <source>Profile guided optimization (PGO) is not helpful with SQLite. PGO results in binaries that are about 1% larger and about 0.33% slower.</source>
          <target state="translated">PGO (프로필 안내 최적화)는 SQLite에서 도움이되지 않습니다. PGO는 이진이 약 1 % 더 크고 약 0.33 % 더 느립니다.</target>
        </trans-unit>
        <trans-unit id="b46994e8cc3c2683acbfd969c84c88b83b02d9c0" translate="yes" xml:space="preserve">
          <source>Profiling indicates that for most systems and in most circumstances SQLite spends most of its time doing disk I/O. It follows then that anything we can do to reduce the amount of disk I/O will likely have a large positive impact on the performance of SQLite. This section describes some of the techniques used by SQLite to try to reduce the amount of disk I/O to a minimum while still preserving atomic commit.</source>
          <target state="translated">프로파일 링은 대부분의 시스템 및 대부분의 환경에서 SQLite가 디스크 I / O를 수행하는 데 대부분의 시간을 소비한다는 것을 나타냅니다. 디스크 I / O의 양을 줄이기 위해 할 수있는 일은 SQLite의 성능에 큰 긍정적 인 영향을 줄 것입니다. 이 섹션에서는 원자 커밋을 유지하면서 디스크 I / O의 양을 최소로 줄이기 위해 SQLite에서 사용하는 일부 기술에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="9d68007b0763cb230f9034ec96f52b39d03ad630" translate="yes" xml:space="preserve">
          <source>Program</source>
          <target state="translated">Program</target>
        </trans-unit>
        <trans-unit id="6bc5295aed74aa8af8bf9a74f722f2706e580d3c" translate="yes" xml:space="preserve">
          <source>Programmers are cautioned not to use the two exceptions described in the previous bullets. We emphasize that they exist only so that old and ill-formed SQL statements will run correctly. Future versions of SQLite might raise errors instead of accepting the malformed statements covered by the exceptions above.</source>
          <target state="translated">프로그래머는 이전 글 머리표에서 설명한 두 가지 예외를 사용하지 않도록주의해야합니다. 우리는 그것들이 존재하기 때문에 오래되고 잘못 구성된 SQL 문이 올바르게 실행되도록 강조합니다. 이후 버전의 SQLite는 위의 예외에서 다루는 잘못된 형식의 문장을 받아들이지 않고 오류를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="442f2f1b223aedc9d27d672e9d91f49a3b27fb5b" translate="yes" xml:space="preserve">
          <source>Programmers can force SQLite to use a particular loop nesting order for a join by using the CROSS JOIN operator instead of just JOIN, INNER JOIN, NATURAL JOIN, or a &quot;,&quot; join. Though CROSS JOINs are commutative in theory, SQLite chooses to never reorder the tables in a CROSS JOIN. Hence, the left table of a CROSS JOIN will always be in an outer loop relative to the right table.</source>
          <target state="translated">프로그래머는 JOIN, INNER JOIN, NATURAL JOIN 또는 &quot;,&quot;조인 대신 CROSS JOIN 연산자를 사용하여 SQLite가 조인에 특정 루프 중첩 순서를 사용하도록 할 수 있습니다. CROSS JOIN은 이론적으로는 정식 적이지만 SQLite는 CROSS JOIN에서 테이블을 다시 정렬하지 않도록 선택합니다. 따라서 CROSS JOIN의 왼쪽 테이블은 항상 오른쪽 테이블을 기준으로 외부 루프에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="9ecd00ed19c9aa2f215c5b5e8453037ffd17fc89" translate="yes" xml:space="preserve">
          <source>Programming Interfaces</source>
          <target state="translated">프로그래밍 인터페이스</target>
        </trans-unit>
        <trans-unit id="1c8b4bfbf1e2ec54cc62ffa3332992d5ae9a4350" translate="yes" xml:space="preserve">
          <source>Programming Loadable Extensions</source>
          <target state="translated">로드 가능한 확장 프로그램 프로그래밍</target>
        </trans-unit>
        <trans-unit id="19ca1fa808a68639f1670f7213bf267471fdbd20" translate="yes" xml:space="preserve">
          <source>Programs contain a single instance of this opcode as the very first opcode.</source>
          <target state="translated">프로그램은 첫 번째 opcode로이 opcode의 단일 인스턴스를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="7b85e7edf23f7121981c9a7f81acf2f88e25d897" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 태그하지 않는 트리거, 뷰, CHECK 제약 조건, DEFAULT 절, 표현의 인덱스 부분 인덱스, 또는 생성 된 컬럼 내부 SQL 기능의 사용을 금지 &lt;a href=&quot;#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="836cdbe091f8e6d2e0a3bc0953580f5b61d80d1b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of SQL functions inside triggers, views, CHECK constraints, DEFAULT clauses, expression indexes, partial indexes, or generated columns unless those functions are tagged with &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 태그하지 않는 트리거, 뷰, CHECK 제약 조건, DEFAULT 절, 표현의 인덱스 부분 인덱스, 또는 생성 된 컬럼 내부 SQL 기능의 사용을 금지 &lt;a href=&quot;c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4131fb0c74864c2b5168b32ce6c60e9b911d245" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">가상 테이블에 &lt;a href=&quot;#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; 태그가 지정되지 않은 경우 트리거 또는 뷰 내에서 가상 테이블 사용을 금지합니다 .</target>
        </trans-unit>
        <trans-unit id="0dd1398efbb71440f12c0472c04e04e100c1dd4b" translate="yes" xml:space="preserve">
          <source>Prohibit the use of virtual tables inside of triggers or views unless those virtual tables are tagged with &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt;.</source>
          <target state="translated">가상 테이블에 &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; 태그가 지정되지 않은 경우 트리거 또는 뷰 내에서 가상 테이블 사용을 금지합니다 .</target>
        </trans-unit>
        <trans-unit id="1b341d69d9619d4d85640d6150737c146812b7c0" translate="yes" xml:space="preserve">
          <source>Provide &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt; for &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt;, &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt;, and &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; , &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check에 &lt;/a&gt;&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA 기능&lt;/a&gt; 을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a4632572329984193ba91894b49406924b5a89d" translate="yes" xml:space="preserve">
          <source>Provide a hint to cursor P1 that it only needs to return rows that satisfy the Expr in P4. TK_REGISTER terms in the P4 expression refer to values currently held in registers. TK_COLUMN terms in the P4 expression refer to columns in the b-tree to which cursor P1 is pointing.</source>
          <target state="translated">커서 P1에 P4의 Expr을 만족시키는 행만 리턴해야한다는 힌트를 제공하십시오. P4 표현식의 TK_REGISTER 용어는 현재 레지스터에 보유 된 값을 나타냅니다. P4 표현식의 TK_COLUMN 용어는 커서 P1이 가리키는 b- 트리의 열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="054ee0d871e7b20122b3ff23a8374fbfb871d9ca" translate="yes" xml:space="preserve">
          <source>Provide an appropriate error message when the sqlite_master table contains a CREATE TABLE AS statement. Formerly this caused either an assertion fault or null pointer dereference. Problem found by OSSFuzz on the GDAL project. Check-in &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</source>
          <target state="translated">sqlite_master 테이블에 CREATE TABLE AS 문이 포함 된 경우 적절한 오류 메시지를 제공하십시오. 이전에는 어설 션 오류 또는 널 포인터 역 참조가 발생했습니다. GDAL 프로젝트에서 OSSFuzz가 발견 한 문제점. 체크인 &lt;a href=&quot;https://www.sqlite.org/src/info/d75e67654aa96&quot;&gt;d75e67654aa96&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c2fd3e74c8200bf8ab45d458d069a0c702c0cd7" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; flag for &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and use it to limit &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory&lt;/a&gt; misuse by &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;, and the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3 ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparepersistent&quot;&gt;SQLITE_PREPARE_PERSISTENT&lt;/a&gt; 플래그를 제공하고 이를 사용 하여 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장에&lt;/a&gt; 의한 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리&lt;/a&gt; 오용 을 제한 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0788f21345510b44c97d1a7ea9db2e84d27c5ed1" translate="yes" xml:space="preserve">
          <source>Provide the &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset(X)&lt;/a&gt; SQL function that returns the byte offset into the database file to the beginning of the record holding value X, when compiling with &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt;.</source>
          <target state="translated">제공 &lt;a href=&quot;lang_corefunc#sqlite_offset&quot;&gt;sqlite_offset (X)&lt;/a&gt; SQL 기능을하는 수익률로 컴파일 할 때 기록을 보유 값 X의 시작 부분에 데이터베이스 파일에 바이트 오프셋 &lt;a href=&quot;compile#enable_offset_sql_func&quot;&gt;-DSQLITE_ENABLE_OFFSET_SQL_FUNC&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6abc71c7c814cc2d05ebc22239e7790b1f15e917" translate="yes" xml:space="preserve">
          <source>Provide the ability to tag &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; with new properties &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt;.</source>
          <target state="translated">새 속성 &lt;a href=&quot;c3ref/c_deterministic#sqliteinnocuous&quot;&gt;SQLITE_INNOCUOUS&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY로 &lt;/a&gt;&lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 에 태그를 지정하는 기능을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="fcb01e4e57cfae253305eca2f9007587c22f7fb2" translate="yes" xml:space="preserve">
          <source>Provides SQL access to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 대한 SQL 액세스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="c78b408cda5c2c489b9c5ef105dac2382d881e16" translate="yes" xml:space="preserve">
          <source>Provides information about all files in a single check-in in the &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil version control system&lt;/a&gt;. This virtual table is not part of the SQLite project but is included because it provides an example of how to use virtual tables and because it is used to help version control the SQLite sources.</source>
          <target state="translated">&lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil 버전 제어 시스템&lt;/a&gt; 에서 단일 체크인으로 모든 파일에 대한 정보를 제공합니다 . 이 가상 테이블은 SQLite 프로젝트의 일부가 아니지만 가상 테이블 사용 방법의 예를 제공하고 SQLite 소스의 버전 제어를 돕는 데 사용되기 때문에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3126f48ce2a68ae1473f8364444a7e563e9968c3" translate="yes" xml:space="preserve">
          <source>Provides information about the purpose and use of each page in a database file. Used in the implementation of the &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; utility program.</source>
          <target state="translated">데이터베이스 파일에서 각 페이지의 목적 및 사용에 대한 정보를 제공합니다. &lt;a href=&quot;sqlanalyze&quot;&gt;sqlite3_analyzer&lt;/a&gt; 유틸리티 프로그램 의 구현에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfec143c19b8a7da8ef2986bfdff976c6539b3dc" translate="yes" xml:space="preserve">
          <source>Pseudo-Random Number Generator</source>
          <target state="translated">의사 난수 생성기</target>
        </trans-unit>
        <trans-unit id="52a406d334528b19ea259feaeb009e7160aeac5f" translate="yes" xml:space="preserve">
          <source>Ptrmap pages must exist in any database file which has a non-zero largest root b-tree page value at offset 52 in the database header. If the largest root b-tree page value is zero, then the database must not contain ptrmap pages.</source>
          <target state="translated">Ptrmap 페이지는 데이터베이스 헤더의 오프셋 52에서 0이 아닌 가장 큰 루트 b- 트리 페이지 값을 가진 데이터베이스 파일에 있어야합니다. 가장 큰 루트 b- 트리 페이지 값이 0이면 데이터베이스에 ptrmap 페이지가 포함되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fe35e9945539e89cd05f704b37cf341406598782" translate="yes" xml:space="preserve">
          <source>Punctuation characters like &quot;,&quot; or &quot;==&quot; or &quot;;&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a7b9c96916fe33cad00dfc0a31cbc73811f7fc" translate="yes" xml:space="preserve">
          <source>PureFunc</source>
          <target state="translated">PureFunc</target>
        </trans-unit>
        <trans-unit id="73f66c4bb296f02b5e558e94e1ebb8671640db19" translate="yes" xml:space="preserve">
          <source>Purging a Dirty Page</source>
          <target state="translated">더티 페이지 퍼지</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="865ca2a73367e4e56f98cc35dd0cc7fe25f8e129" translate="yes" xml:space="preserve">
          <source>Push the next &quot;thing&quot; onto the stack and fall through OR jump to P2, depending on whether or not there is a next &quot;thing&quot; to push.</source>
          <target state="translated">다음 &quot;물건&quot;을 스택으로 밀어 넣고 밀어 넣을 다음 &quot;물건&quot;이 있는지 여부에 따라 P2로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="0555ed5711adce7afcbd2d3235114460d585953d" translate="yes" xml:space="preserve">
          <source>Put all identifier names inside double-quotes. This is the official SQL way to escape identifier names.</source>
          <target state="translated">모든 식별자 이름을 큰 따옴표 안에 넣습니다. 이것은 식별자 이름을 이스케이프하는 공식 SQL 방법입니다.</target>
        </trans-unit>
        <trans-unit id="73eb67d0cb954e65c543496b0577de68b482cb5a" translate="yes" xml:space="preserve">
          <source>Put identifier names inside [...]. This is not standard SQL, but it is what SQL Server does and so lots of programmers use this technique.</source>
          <target state="translated">식별자 이름을 [...] 안에 넣으십시오. 이것은 표준 SQL은 아니지만 SQL Server가 수행하는 방식이므로 많은 프로그래머가이 기술을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e8b5818c3fdaa2a399fa24163289f33ef9912b79" translate="yes" xml:space="preserve">
          <source>Put the macro &quot;&lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt;&quot; on a line by itself right after the &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; line.</source>
          <target state="translated">&quot; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &quot;행 바로 뒤에 매크로 &quot; &lt;code&gt;SQLITE_EXTENSION_INIT1&lt;/code&gt; &quot;을 한 줄에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="36dc5ec2a56fbc19dcd1aa69b72dba8e93123b26" translate="yes" xml:space="preserve">
          <source>Put your hope in God.</source>
          <target state="translated">하나님 께 희망을 두십시오.</target>
        </trans-unit>
        <trans-unit id="c3156e00d3c2588c639e0d3cf6821258b05761c7" translate="yes" xml:space="preserve">
          <source>Q</source>
          <target state="translated">Q</target>
        </trans-unit>
        <trans-unit id="4ae694911c3fee4e1df954bf5e225e075d582d11" translate="yes" xml:space="preserve">
          <source>QUERY</source>
          <target state="translated">QUERY</target>
        </trans-unit>
        <trans-unit id="ebdfba68a60db859050a346ba6621b2d1c232869" translate="yes" xml:space="preserve">
          <source>Quality Management</source>
          <target state="translated">품질 관리</target>
        </trans-unit>
        <trans-unit id="3dd6362242ec4d8e950fc308f0c9c5371ac3e523" translate="yes" xml:space="preserve">
          <source>Quality assurance in SQLite is done using &lt;a href=&quot;testing#coverage&quot;&gt;full-coverage testing&lt;/a&gt;, not by compiler warnings or other static code analysis tools. In other words, we verify that SQLite actually gets the correct answer, not that it merely satisfies stylistic constraints. Most of the SQLite code base is devoted purely to testing. The SQLite test suite runs tens of thousands of separate test cases and many of those test cases are parameterized so that hundreds of millions of tests involving billions of SQL statements are run and evaluated for correctness prior to every release. The developers use code coverage tools to verify that all paths through the code are tested. Whenever a bug is found in SQLite, new test cases are written to exhibit the bug so that the bug cannot recur undetected in the future.</source>
          <target state="translated">SQLite의 품질 보증은 컴파일러 경고 또는 기타 정적 코드 분석 도구가 아닌 &lt;a href=&quot;testing#coverage&quot;&gt;전체 범위 테스트를&lt;/a&gt; 사용하여 수행됩니다 . 다시 말해, 우리는 SQLite가 단순히 문체 적 제약을 만족시키는 것이 아니라 정답을 얻는다는 것을 확인합니다. 대부분의 SQLite 코드 기반은 순전히 테스트에 전념합니다. SQLite 테스트 스위트는 수만 건의 개별 테스트 사례를 실행하며 이러한 테스트 사례 중 다수는 매개 변수화되어 수십억 개의 SQL 문과 관련된 수억 건의 테스트가 실행되고 모든 릴리스 전에 정확성을 평가합니다. 개발자는 코드 범위 도구를 사용하여 코드를 통한 모든 경로가 테스트되었는지 확인합니다. SQLite에서 버그가 발견 될 때마다 버그를 나타 내기 위해 새로운 테스트 사례가 작성되므로 나중에 버그를 발견 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="96ecb898d9fd59826f9555c415e65eadb6f74ead" translate="yes" xml:space="preserve">
          <source>Quality management documents tend to expand into binders full of incomprehensible jargon that nobody reads. This document strives to break that pattern by being concise and useful.</source>
          <target state="translated">품질 관리 문서는 읽을 수없는 전문 용어로 가득 찬 바인더로 확장되는 경향이 있습니다. 이 문서는 간결하고 유용하여 해당 패턴을 깨기 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="61b1d96663c5eb21b3f12fad273403f6ef48c73d" translate="yes" xml:space="preserve">
          <source>Queries (and also DELETE and UPDATE statements) in which the WHERE clause contains a bare geopoly_overlap() or geopoly_within() function make use of the underlying R*Tree data structures for a fast lookup that only has to examine a subset of the rows in the table. The number of rows examines depends, of course, on the size of the $query_polygon. Large $query_polygons will normally need to look at more rows than small ones.</source>
          <target state="translated">WHERE 절에 베어 geopoly_overlap () 또는 geopoly_within () 함수가 포함 된 쿼리 (및 DELETE 및 UPDATE 문)는 기본 R * Tree 데이터 구조를 사용하여 행의 서브 세트 만 검사하면되는 빠른 검색을 수행합니다. 탁자. 검사 할 행 수는 물론 $ query_polygon의 크기에 따라 다릅니다. 큰 $ query_polygons는 일반적으로 작은 것보다 더 많은 행을보아야합니다.</target>
        </trans-unit>
        <trans-unit id="5877d4b4dd805510713fc8b0f7324db5905fcfac" translate="yes" xml:space="preserve">
          <source>Queries Against A Graph</source>
          <target state="translated">그래프에 대한 쿼리</target>
        </trans-unit>
        <trans-unit id="83b570c5458fbacf6723ef9304ccc7570ee10af8" translate="yes" xml:space="preserve">
          <source>Queries against the rowid of a geopoly table are also very quick, even for tables with a vast number of rows. However, none of the auxiliary data columns are indexes, and so queries against the auxiliary data columns will involve a full table scan.</source>
          <target state="translated">지오 폴리 테이블의 rowid에 대한 쿼리는 행 수가 많은 테이블의 경우에도 매우 빠릅니다. 그러나 보조 데이터 열은 인덱스가 아니므로 보조 데이터 열에 대한 쿼리에는 전체 테이블 스캔이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e655d8b919b6556f1f0ce40faccc63fe0ee22962" translate="yes" xml:space="preserve">
          <source>Queries of the form: &quot;SELECT max(x), y FROM table&quot; returns the value of y on the same row that contains the maximum x value.</source>
          <target state="translated">&quot;SELECT max (x), y FROM table&quot;형식의 쿼리는 최대 x 값이 포함 된 동일한 행에서 y 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4ff6a5e7ac06c745f7d49496f70f4a140defd99" translate="yes" xml:space="preserve">
          <source>Queries that contain a single MIN() or MAX() aggregate function whose argument is the left-most column of an index might be satisfied by doing a single index lookup rather than by scanning the entire table. Examples:</source>
          <target state="translated">인수가 인덱스의 가장 왼쪽 열인 단일 MIN () 또는 MAX () 집계 함수를 포함하는 쿼리는 전체 테이블을 스캔하지 않고 단일 인덱스 조회를 수행하여 충족 될 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="29a6a39bdba4fd39660625514af2f1cb40b3edcf" translate="yes" xml:space="preserve">
          <source>Queries that contain subqueries must sometime evaluate the subqueries separately and store the results in a temporary table, then use the content of the temporary table to evaluate the outer query. We call this &quot;materializing&quot; the subquery. The query optimizer in SQLite attempts to avoid materializing, but sometimes it is not easily avoidable. The temporary tables created by materialization are each stored in their own separate temporary file, which is automatically deleted at the conclusion of the query. The size of these temporary tables depends on the amount of data in the materialization of the subquery, of course.</source>
          <target state="translated">하위 쿼리가 포함 된 쿼리는 때때로 하위 쿼리를 개별적으로 평가하고 결과를 임시 테이블에 저장 한 다음 임시 테이블의 내용을 사용하여 외부 쿼리를 평가해야합니다. 이것을 하위 쿼리를 &quot;구체화&quot;한다고합니다. SQLite의 쿼리 최적화 프로그램은 구체화를 피하려고 시도하지만 때로는 쉽게 피할 수 없습니다. 구체화에 의해 작성된 임시 테이블은 각각 ​​별도의 임시 파일에 저장되며 쿼리가 완료되면 자동으로 삭제됩니다. 이러한 임시 테이블의 크기는 물론 하위 쿼리의 구체화에있는 데이터의 양에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="cfbd9457ec43caaedb5b89c759265cf2be427fe5" translate="yes" xml:space="preserve">
          <source>Queries that use ORDER BY and LIMIT now try to avoid computing rows that cannot possibly come in under the LIMIT. This can greatly improve performance of ORDER BY LIMIT queries, especially when the LIMIT is small relative to the number of unrestricted output rows.</source>
          <target state="translated">ORDER BY 및 LIMIT를 사용하는 쿼리는 이제 LIMIT 아래에 들어갈 수없는 행을 계산하지 않습니다. 이는 특히 제한이없는 출력 행 수에 비해 LIMIT가 작은 경우 ORDER BY LIMIT 쿼리의 성능을 크게 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e885c97cd0eb73037d91afe0e25f71733d813af5" translate="yes" xml:space="preserve">
          <source>Query Language Understood by SQLite</source>
          <target state="translated">SQLite가 이해하는 쿼리 언어</target>
        </trans-unit>
        <trans-unit id="3d4f16fd1d91b47c556b84948dabe05573437a3d" translate="yes" xml:space="preserve">
          <source>Query Planner</source>
          <target state="translated">쿼리 플래너</target>
        </trans-unit>
        <trans-unit id="efa9d81fc99ae6041fbe49339a919ef99bac7ade" translate="yes" xml:space="preserve">
          <source>Query Planning</source>
          <target state="translated">쿼리 계획</target>
        </trans-unit>
        <trans-unit id="625af40606e435d60c7571eb3eaed21802aa70ee" translate="yes" xml:space="preserve">
          <source>Query Progress Callbacks</source>
          <target state="translated">쿼리 진행 콜백</target>
        </trans-unit>
        <trans-unit id="4af542248ab5d4cfc6f1e9df7245e3bb184ea082" translate="yes" xml:space="preserve">
          <source>Query The EXPLAIN Setting For A Prepared Statement</source>
          <target state="translated">준비된 명령문에 대한 EXPLAIN 설정 조회</target>
        </trans-unit>
        <trans-unit id="27930b82a7c3d467781ad3b52e0b1d9894281ffa" translate="yes" xml:space="preserve">
          <source>Query flattener</source>
          <target state="translated">플래 튼 쿼리</target>
        </trans-unit>
        <trans-unit id="e60fdc9ba7fb5d86546748b364cd1dfbde0107e1" translate="yes" xml:space="preserve">
          <source>Query flattening is an important optimization when views are used as each use of a view is translated into a subquery.</source>
          <target state="translated">쿼리 병합은 뷰의 각 사용이 하위 쿼리로 변환 될 때 뷰가 사용될 때 중요한 최적화입니다.</target>
        </trans-unit>
        <trans-unit id="bfee3391ed2fb89e3470d4d2a93c4c710274a3ef" translate="yes" xml:space="preserve">
          <source>Query for the details of phrase match iIdx within the current row. Phrase matches are numbered starting from zero, so the iIdx argument should be greater than or equal to zero and smaller than the value output by xInstCount().</source>
          <target state="translated">현재 행 내에서 구문 일치 iIdx의 세부 사항을 쿼리하십시오. 구문 검색은 0부터 시작하여 번호가 매겨 지므로 iIdx 인수는 0보다 크거나 같아야하며 xInstCount ()가 출력 한 값보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="3a7dd1ac6b04f70fb3ec3bd5dfe2b333de122f27" translate="yes" xml:space="preserve">
          <source>Query optimizer enhancements:</source>
          <target state="translated">쿼리 최적화 기능 향상 :</target>
        </trans-unit>
        <trans-unit id="a2c73363a91970f8d7d0f3ba2033b2b1141c7659" translate="yes" xml:space="preserve">
          <source>Query optimizer improvements:</source>
          <target state="translated">쿼리 최적화 기능 개선 :</target>
        </trans-unit>
        <trans-unit id="65d2f2329c994ccea3b5e213a1d1b909c0f33338" translate="yes" xml:space="preserve">
          <source>Query or change a limit on the &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; setting. This is approximate number of rows examined in each index by the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command. If the argument</source>
          <target state="translated">&lt;a href=&quot;lang_analyze#approx&quot;&gt;대략적인 ANALYZE&lt;/a&gt; 설정 에 대한 제한을 쿼리하거나 변경 합니다. 이것은 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령으로 각 인덱스에서 검사 한 대략적인 행 수입니다 . 인수가</target>
        </trans-unit>
        <trans-unit id="d0fbdef4345ce05f423c29e77346a76ae1183a9c" translate="yes" xml:space="preserve">
          <source>Query or change the count-changes flag. Normally, when the count-changes flag is not set, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements return no data. When count-changes is set, each of these commands returns a single row of data consisting of one integer value - the number of rows inserted, modified or deleted by the command. The returned change count does not include any insertions, modifications or deletions performed by triggers, any changes made automatically by &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;foreign key actions&lt;/a&gt;, or updates caused by an &lt;a href=&quot;lang_upsert&quot;&gt;upsert&lt;/a&gt;.</source>
          <target state="translated">count-changes 플래그를 조회하거나 변경하십시오. 일반적으로 count-changes 플래그가 설정되지 않은 경우 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문은 데이터를 리턴하지 않습니다. count-changes가 설정되면 이러한 각 명령은 하나의 정수 값 (명령으로 삽입, 수정 또는 삭제 된 행 수)으로 구성된 단일 데이터 행을 리턴합니다. 반환 된 변경 수에는 트리거에 의해 수행 된 삽입, 수정 또는 삭제, &lt;a href=&quot;foreignkeys#fk_actions&quot;&gt;외래 키 작업에&lt;/a&gt; 의해 자동으로 수행 된 변경 또는 &lt;a href=&quot;lang_upsert&quot;&gt;upsert로&lt;/a&gt; 인한 업데이트가 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9a7df9605f2eec87d8f2db2efd84251b953fcfd6" translate="yes" xml:space="preserve">
          <source>Query or change the empty-result-callbacks flag.</source>
          <target state="translated">empty-result-callbacks 플래그를 조회하거나 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="4386c302fe03b8bf430568c307ba9f2bfa451ec8" translate="yes" xml:space="preserve">
          <source>Query or change the full_column_names flag. This flag together with the &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; flag determine the way SQLite assigns names to result columns of &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Result columns are named by applying the following rules in order:</source>
          <target state="translated">full_column_names 플래그를 조회하거나 변경하십시오. &lt;a href=&quot;pragma#pragma_short_column_names&quot;&gt;short_column_names&lt;/a&gt; 플래그 와 함께이 플래그는 SQLite가 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 결과 열에 이름을 지정하는 방법을 결정합니다 . 결과 열은 다음 규칙을 순서대로 적용하여 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="6ea33a7feb73dab172e527ce6afcb51892e3e546" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag for &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; operations. If this flag is set, then the F_FULLFSYNC syncing method is used during checkpoint operations on systems that support F_FULLFSYNC. The default value of the checkpoint_fullfsync flag is off. Only Mac OS-X supports F_FULLFSYNC.</source>
          <target state="translated">&lt;a href=&quot;wal#ckpt&quot;&gt;검사 점&lt;/a&gt; 작업을 위한 fullfsync 플래그를 쿼리하거나 변경합니다 . 이 플래그가 설정되면 F_FULLFSYNC를 지원하는 시스템에서 검사 점 작업 중에 F_FULLFSYNC 동기화 방법이 사용됩니다. checkpoint_fullfsync 플래그의 기본값은 해제입니다. Mac OS-X 만 F_FULLFSYNC를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="563bc8c4477c1c2b886876e5894cd59e0001b35e" translate="yes" xml:space="preserve">
          <source>Query or change the fullfsync flag. This flag determines whether or not the F_FULLFSYNC syncing method is used on systems that support it. The default value of the fullfsync flag is off. Only Mac OS X supports F_FULLFSYNC.</source>
          <target state="translated">fullfsync 플래그를 조회하거나 변경하십시오. 이 플래그는 F_FULLFSYNC 동기화 방법이이를 지원하는 시스템에서 사용되는지 여부를 결정합니다. fullfsync 플래그의 기본값은 해제입니다. Mac OS X 만 F_FULLFSYNC를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="77df4b91f1e34f39b185a6ee7e54e82d58dfa005" translate="yes" xml:space="preserve">
          <source>Query or change the maximum number of bytes that are set aside for memory-mapped I/O on a single database. The first form (without an argument) queries the current limit. The second form (with a numeric argument) sets the limit for the specified database, or for all databases if the optional database name is omitted. In the second form, if the database name is omitted, the limit that is set becomes the default limit for all databases that are added to the &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; by subsequent &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements.</source>
          <target state="translated">단일 데이터베이스에서 메모리 매핑 된 I / O를 위해 설정된 최대 바이트 수를 쿼리하거나 변경하십시오. 첫 번째 형식 (인수없이)은 현재 제한을 쿼리합니다. 두 번째 형식 (숫자 인수 포함)은 지정된 데이터베이스 또는 선택적 데이터베이스 이름이 생략 된 경우 모든 데이터베이스에 대한 한계를 설정합니다. 두 번째 양식에서 데이터베이스 이름이 생략되면, 설정된 한계는 후속 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문에 의해 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에 추가되는 모든 데이터베이스의 기본 한계가됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b3761ba731b4ca68bda2cd1e8fe9ffa86d5d2f0" translate="yes" xml:space="preserve">
          <source>Query or change the secure-delete setting. When secure_delete is on, SQLite overwrites deleted content with zeros. The default setting for secure_delete is determined by the &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; compile-time option and is normally off. The off setting for secure_delete improves performance by reducing the number of CPU cycles and the amount of disk I/O. Applications that wish to avoid leaving forensic traces after content is deleted or updated should enable the secure_delete pragma prior to performing the delete or update, or else run &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; after the delete or update.</source>
          <target state="translated">보안 삭제 설정을 조회하거나 변경하십시오. secure_delete가 설정되면 SQLite는 삭제 된 내용을 0으로 덮어 씁니다. secure_delete의 기본 설정은 &lt;a href=&quot;compile#secure_delete&quot;&gt;SQLITE_SECURE_DELETE&lt;/a&gt; 컴파일 타임 옵션에 의해 결정되며 일반적으로 해제되어 있습니다. secure_delete의 꺼짐 설정은 CPU주기 수와 디스크 I / O 양을 줄임으로써 성능을 향상시킵니다. 컨텐츠를 삭제하거나 업데이트 한 후 포렌식 추적을 남기지 않으려는 애플리케이션은 삭제 또는 업데이트를 수행하기 전에 secure_delete pragma를 활성화하거나 삭제 또는 업데이트 후에 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 을 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="de56ca3e30c1c074a1fd98f6d3fdce5680f699b3" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;&lt;b&gt;temp_store&lt;/b&gt;&quot; parameter. When temp_store is DEFAULT (0), the compile-time C preprocessor macro &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; is used to determine where temporary tables and indices are stored. When temp_store is MEMORY (2) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are kept in as if they were pure &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt; memory. When temp_store is FILE (1) &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices are stored in a file. The &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma can be used to specify the directory containing temporary files when &lt;b&gt;FILE&lt;/b&gt; is specified. When the temp_store setting is changed, all existing temporary tables, indices, triggers, and views are immediately deleted.</source>
          <target state="translated">&quot; &lt;b&gt;temp_store&lt;/b&gt; &quot;매개 변수 의 설정을 조회하거나 변경하십시오 . temp_store가 DEFAULT (0) 인 경우 컴파일 타임 C 프리 프로세서 매크로 &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 를 사용하여 임시 테이블 및 인덱스가 저장되는 위치를 결정합니다. temp_store가 MEMORY (2) 인 경우 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스는 순수한 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 메모리 인 것처럼 유지됩니다 . temp_store가 FILE (1) 인 경우 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스는 파일에 저장됩니다. &lt;a href=&quot;pragma#pragma_temp_store_directory&quot;&gt;temp_store_directory&lt;/a&gt; pragma는 경우 임시 파일을 포함하는 디렉토리를 지정하는 데 사용할 수있는 &lt;b&gt;파일을&lt;/b&gt; 지정합니다. temp_store 설정이 변경되면 기존의 모든 임시 테이블, 인덱스, 트리거 및 뷰가 즉시 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="0eb005d9ab4e0804f12c87dee002073b411d274d" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &quot;synchronous&quot; flag. The first (query) form will return the synchronous setting as an integer. The second form changes the synchronous setting. The meanings of the various synchronous settings are as follows:</source>
          <target state="translated">&quot;동기&quot;플래그 설정을 조회하거나 변경하십시오. 첫 번째 (쿼리) 형식은 동기 설정을 정수로 반환합니다. 두 번째 형식은 동기 설정을 변경합니다. 다양한 동기 설정의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8dcfcd54b0505cd09f50244da9bbd756766eef81" translate="yes" xml:space="preserve">
          <source>Query or change the setting of the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;busy timeout&lt;/a&gt;. This pragma is an alternative to the &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; C-language interface which is made available as a pragma for use with language bindings that do not provide direct access to &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/busy_timeout&quot;&gt;통화 중 시간 초과&lt;/a&gt; 설정을 쿼리하거나 변경합니다 . 이 pragma는 대안입니다 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; 에 직접 액세스 제공하지 않는 언어 바인딩과 함께 사용할 수있는 프라 그마로 사용할 수 있습니다 C 언어 인터페이스 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout을 ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a6f0cf05490ce574881ff5675cbd192d91cf992" translate="yes" xml:space="preserve">
          <source>Query or change the short-column-names flag. This flag affects the way SQLite names columns of data returned by &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. See the &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma for full details.</source>
          <target state="translated">short-column-names 플래그를 조회하거나 변경하십시오. 이 플래그는 SQLite가 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문에서 반환 한 데이터 열의 이름을 지정하는 방식에 영향을줍니다 . 자세한 내용은 &lt;a href=&quot;pragma#pragma_full_column_names&quot;&gt;full_column_names&lt;/a&gt; pragma를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="c472dc3fc7ff36d8acee51946b1687ac08bd59fe" translate="yes" xml:space="preserve">
          <source>Query or change the suggested maximum number of database disk pages that SQLite will hold in memory at once per open database file. Whether or not this suggestion is honored is at the discretion of the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;Application Defined Page Cache&lt;/a&gt;. The default page cache that is built into SQLite honors the request, however alternative application-defined page cache implementations may choose to interpret the suggested cache size in different ways or to ignore it all together. The default suggested cache size is -2000, which means the cache size is limited to 2048000 bytes of memory. The default suggested cache size can be altered using the &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; compile-time options. The TEMP database has a default suggested cache size of 0 pages.</source>
          <target state="translated">SQLite가 열린 데이터베이스 파일 당 한 번에 메모리에 보유 할 제안 된 최대 데이터베이스 디스크 페이지 수를 조회하거나 변경하십시오. 이 제안이 적용되는지 여부는 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;응용 프로그램 정의 페이지 캐시&lt;/a&gt; 의 재량에 따릅니다 . SQLite에 기본 제공되는 기본 페이지 캐시는 요청을 받아들이지 만 대체 응용 프로그램 정의 페이지 캐시 구현은 제안 된 캐시 크기를 다른 방식으로 해석하거나 함께 무시하도록 선택할 수 있습니다. 기본 제안 된 캐시 크기는 -2000이며, 이는 캐시 크기가 2048000 바이트의 메모리로 제한됨을 의미합니다. 기본 제안 된 캐시 크기는 &lt;a href=&quot;compile#default_cache_size&quot;&gt;SQLITE_DEFAULT_CACHE_SIZE&lt;/a&gt; 컴파일 시간 옵션을 사용하여 변경할 수 있습니다. TEMP 데이터베이스의 기본 제안 된 캐시 크기는 0 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="38317b0c0d1df51bd83790ce312ba13da0c5ed05" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; global variable, which windows operating-system interface backends use to determine where to store database files specified using a relative pathname.</source>
          <target state="translated">Windows 운영 체제 인터페이스 백엔드가 상대 경로 이름을 사용하여 지정된 데이터베이스 파일을 저장할 위치를 결정하는 데 사용 하는 &lt;a href=&quot;c3ref/data_directory&quot;&gt;sqlite3_data_directory&lt;/a&gt; 글로벌 변수 의 값을 조회하거나 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="f61590ed5a58a97ecca18f3fbb40bf0ae63fb037" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt;,...) limit for the current database connection. This limit sets an upper bound on the number of auxiliary threads that a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is allowed to launch to assist with a query. The default limit is 0 unless it is changed using the &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; compile-time option. When the limit is zero, that means no auxiliary threads will be launched.</source>
          <target state="translated">현재 데이터베이스 연결 에 대한 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; , ...) 한계 값을 쿼리하거나 변경하십시오 . 이 한계는 쿼리를 지원하기 위해 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 실행할 수있는 보조 스레드 수의 상한을 설정 합니다. &lt;a href=&quot;compile#default_worker_threads&quot;&gt;SQLITE_DEFAULT_WORKER_THREADS&lt;/a&gt; 컴파일 타임 옵션을 사용하여 변경하지 않는 한 기본 한계는 0 입니다. 한계가 0이면 보조 스레드가 시작되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4ad35fae3f5b98f4ef0cd9485074046877d96539" translate="yes" xml:space="preserve">
          <source>Query or change the value of the &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; global variable, which many operating-system interface backends use to determine where to store &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;temporary tables&lt;/a&gt; and indices.</source>
          <target state="translated">많은 운영 체제 인터페이스 백엔드가 &lt;a href=&quot;inmemorydb#temp_db&quot;&gt;임시 테이블&lt;/a&gt; 및 인덱스 를 저장할 위치를 결정하는 데 사용 하는 &lt;a href=&quot;c3ref/temp_directory&quot;&gt;sqlite3_temp_directory&lt;/a&gt; 글로벌 변수 의 값을 쿼리하거나 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="5866fac6602f3e40c19df259ea318d2b63caf2bd" translate="yes" xml:space="preserve">
          <source>Query or set the auto-vacuum status in the database.</source>
          <target state="translated">데이터베이스에서 자동 진공 상태를 조회하거나 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="3cc5d0ecc46bacf93e04d7b7978224221ecdf262" translate="yes" xml:space="preserve">
          <source>Query or set the maximum number of pages in the database file. Both forms of the pragma return the maximum page count. The second form attempts to modify the maximum page count. The maximum page count cannot be reduced below the current database size.</source>
          <target state="translated">데이터베이스 파일의 최대 페이지 수를 쿼리하거나 설정하십시오. pragma의 두 가지 형식 모두 최대 페이지 수를 반환합니다. 두 번째 양식은 최대 페이지 수 수정을 시도합니다. 최대 페이지 수는 현재 데이터베이스 크기 아래로 줄어들 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b4e54fcf1e120591a5a6535bff6e2b69b86d7df" translate="yes" xml:space="preserve">
          <source>Query or set the page size of the database. The page size must be a power of two between 512 and 65536 inclusive.</source>
          <target state="translated">데이터베이스의 페이지 크기를 쿼리하거나 설정하십시오. 페이지 크기는 512에서 65536 사이의 2의 제곱이어야합니다.</target>
        </trans-unit>
        <trans-unit id="627a1950bccb0926f06969a3db2d136c3cabdca5" translate="yes" xml:space="preserve">
          <source>Query planner checklist</source>
          <target state="translated">쿼리 플래너 체크리스트</target>
        </trans-unit>
        <trans-unit id="e93c39912e396551e04ed9b46c1ea823e2d8b3bb" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - automatic transient indices are created when doing so reduces the estimated query time.</source>
          <target state="translated">쿼리 플래너 향상-자동 임시 색인이 작성되면 예상 쿼리 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="15e2bd2467aae946e711f6cc5ade007f83eb3c87" translate="yes" xml:space="preserve">
          <source>Query planner enhancement - the ORDER BY becomes a no-op if the query also contains a GROUP BY clause that forces the correct output order.</source>
          <target state="translated">쿼리 플래너 향상-쿼리에 올바른 출력 순서를 강제하는 GROUP BY 절이 포함되어 있으면 ORDER BY가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26786d5880615e168b7819292d8f2bd689ef42b3" translate="yes" xml:space="preserve">
          <source>Query planner enhancement: Use the transitive property of constraints to move constraints into the outer loops of a join whenever possible, thereby reducing the amount of work that needs to occur in inner loops.</source>
          <target state="translated">쿼리 플래너 향상 : 제한 조건의 전이 특성을 사용하여 가능할 때마다 제한 조건을 결합의 외부 루프로 이동하여 내부 루프에서 발생해야하는 작업량을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="736e85cef8966360d93b45933c07771905d6a0b9" translate="yes" xml:space="preserve">
          <source>Query planner enhancements.</source>
          <target state="translated">쿼리 플래너 향상</target>
        </trans-unit>
        <trans-unit id="c7e16cd25b99db12dc36d4eb42e08d056acec1b1" translate="yes" xml:space="preserve">
          <source>Query planner enhancements:</source>
          <target state="translated">쿼리 플래너 향상 :</target>
        </trans-unit>
        <trans-unit id="666ab0644bcf7abdf389c79c890bad61c7c7fec2" translate="yes" xml:space="preserve">
          <source>Query planner improvements:</source>
          <target state="translated">쿼리 플래너 개선 :</target>
        </trans-unit>
        <trans-unit id="b2b452d242e61d8f7480bffaae127bf001921fa3" translate="yes" xml:space="preserve">
          <source>Query planner stability guarantee</source>
          <target state="translated">쿼리 플래너 안정성 보장</target>
        </trans-unit>
        <trans-unit id="ca5891ff28346fccc5150a605b02b68689910ebb" translate="yes" xml:space="preserve">
          <source>Query planners are what make SQL database engines so amazingly useful and powerful. (This is true of all SQL database engines, not just SQLite.) The query planner frees the programmer from the chore of selecting a particular query plan, and thereby allows the programmer to focus more mental energy on higher-level application issues and on providing more value to the end user. For simple queries where the choice of query plan is obvious, this is convenient but not hugely important. But as applications and schemas and queries grow more complex, a clever query planner can greatly speed and simplify the work of application development. There is amazing power in being about to tell the database engine what content is desired, and then let the database engine figure out the best way to retrieve that content.</source>
          <target state="translated">쿼리 플래너는 SQL 데이터베이스 엔진을 매우 유용하고 강력하게 만드는 요소입니다. (이는 SQLite뿐만 아니라 모든 SQL 데이터베이스 엔진에도 적용됩니다.) 쿼리 플래너는 프로그래머가 특정 쿼리 계획을 선택해야하는 번거 로움을 없애고 프로그래머가 더 높은 수준의 응용 프로그램 문제 및 제공에 정신적 에너지를 집중할 수 있도록합니다. 최종 사용자에게 더 많은 가치. 쿼리 계획의 선택이 명백한 간단한 쿼리의 경우 편리하지만 크게 중요하지는 않습니다. 그러나 응용 프로그램과 스키마 및 쿼리가 더욱 복잡 해짐에 따라 영리한 쿼리 플래너는 응용 프로그램 개발 작업을 크게 가속화하고 단순화 할 수 있습니다. 데이터베이스 엔진에 원하는 컨텐츠를 알려주고 데이터베이스 엔진이 해당 컨텐츠를 검색하는 가장 좋은 방법을 찾도록하는 놀라운 힘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee854629ae78a2199bdb56da8e286e6006b5d8d" translate="yes" xml:space="preserve">
          <source>Query results are returned as a list of column values. If a query requests 2 columns and there are 3 rows matching the query, then the returned list will contain 6 elements. For example:</source>
          <target state="translated">쿼리 결과는 열 값 목록으로 반환됩니다. 쿼리가 2 개의 열을 요청하고 쿼리와 일치하는 3 개의 행이 있으면 반환 된 목록에 6 개의 요소가 포함됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cb7820ab431080267a59361b01e9af99b0f2f7" translate="yes" xml:space="preserve">
          <source>Query, set, or clear READ UNCOMMITTED isolation. The default isolation level for SQLite is SERIALIZABLE. Any process or thread can select READ UNCOMMITTED isolation, but SERIALIZABLE will still be used except between connections that share a common page and schema cache. Cache sharing is enabled using the &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache()&lt;/a&gt; API. Cache sharing is disabled by default.</source>
          <target state="translated">커밋되지 않은 읽기 격리를 쿼리, 설정 또는 지 웁니다. SQLite의 기본 격리 수준은 SERIALIZABLE입니다. 모든 프로세스 또는 스레드는 커밋되지 않은 읽기 격리를 선택할 수 있지만 공통 페이지와 스키마 캐시를 공유하는 연결을 제외하고는 SERIALIZABLE이 계속 사용됩니다. 캐시 공유는 &lt;a href=&quot;c3ref/enable_shared_cache&quot;&gt;sqlite3_enable_shared_cache ()&lt;/a&gt; API를 사용하여 활성화 됩니다. 캐시 공유는 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0366bdd9a4ae5e944fbf6092ddc8900d9aeaaed5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic indexing&lt;/a&gt; capability.</source>
          <target state="translated">&lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱싱&lt;/a&gt; 기능을 쿼리, 설정 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="14ccb18dde2fc34367c93b804727ccf1143765e5" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the enforcement of &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 의 적용을 쿼리, 설정 또는 지 웁니다 .</target>
        </trans-unit>
        <trans-unit id="160bfb7a8121ce10fe672d852b6ba0dcf536c5e1" translate="yes" xml:space="preserve">
          <source>Query, set, or clear the recursive trigger capability.</source>
          <target state="translated">재귀 트리거 기능을 쿼리, 설정 또는 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="bf0ed56a136cbe5ffad095931c71813d09f0273f" translate="yes" xml:space="preserve">
          <source>Questions and confusion quickly arose on the &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about the purpose behind these new interfaces, why they were introduced, and what problem they solve. This essay attempts to answer those questions and clear up the confusion.</source>
          <target state="translated">이러한 새로운 인터페이스의 목적, 도입 된 이유 및 해결되는 문제 에 대한 &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;메일 링리스트&lt;/a&gt; 에서 질문과 혼란이 빠르게 일어났습니다 . 이 에세이는 이러한 질문에 답하고 혼란을 해결하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="6fb0e0d11a03f78b5ecb2f7f8b42ef10b6e101e0" translate="yes" xml:space="preserve">
          <source>Questions like these (and countless others) can be answered without having to uncompress or extract any content.</source>
          <target state="translated">내용을 압축 해제하거나 추출 할 필요없이 이러한 질문 (및 수많은 다른 질문)에 답변 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09a7d1d2da3256534f8a2a26b3d747dbae8b2a14" translate="yes" xml:space="preserve">
          <source>Quirks, Caveats, and Gotchas In SQLite</source>
          <target state="translated">SQLite의 Quirks, Caveats 및 Gotchas</target>
        </trans-unit>
        <trans-unit id="9432058147a91a2c4afeff95adc17f4930b4c6b9" translate="yes" xml:space="preserve">
          <source>R (cost: 3.56)</source>
          <target state="translated">R (비용 : 3.56)</target>
        </trans-unit>
        <trans-unit id="37abd4d23bc413fb5db77feee86f46ad0b861e2d" translate="yes" xml:space="preserve">
          <source>R*Tree Module</source>
          <target state="translated">R * 트리 모듈</target>
        </trans-unit>
        <trans-unit id="43ea99300f03323c6239855a57c58f91be6c0d63" translate="yes" xml:space="preserve">
          <source>R-N1 (cost: 7.03)</source>
          <target state="translated">R-N1 (비용 : 7.03)</target>
        </trans-unit>
        <trans-unit id="00f923142bbc27eb285a9f64b857d908b86719d8" translate="yes" xml:space="preserve">
          <source>R-N1-C (cost: 13.43)</source>
          <target state="translated">R-N1-C (비용 : 13.43)</target>
        </trans-unit>
        <trans-unit id="f743ed80cd4af3e3dd6aaa0242ee69bf26b480c0" translate="yes" xml:space="preserve">
          <source>R-N1-N2 (cost: 12.55)</source>
          <target state="translated">R-N1-N2 (비용 : 12.55)</target>
        </trans-unit>
        <trans-unit id="12fc721fdde87226fb7f977e95887d024b7fef9e" translate="yes" xml:space="preserve">
          <source>R-N1-P (cost: 14.74)</source>
          <target state="translated">R-N1-P (비용 : 14.74)</target>
        </trans-unit>
        <trans-unit id="fab85d63ca52ab34a7d0d4d635cb4434f4c73c7c" translate="yes" xml:space="preserve">
          <source>R-N2 (cost: 9.08)</source>
          <target state="translated">R-N2 (비용 : 9.08)</target>
        </trans-unit>
        <trans-unit id="2a3b1ad1ab0d9afa5d157dd5a7723841765c8a20" translate="yes" xml:space="preserve">
          <source>R-N2-S (cost: 15.08)</source>
          <target state="translated">R-N2-S (비용 : 15.08)</target>
        </trans-unit>
        <trans-unit id="181200f18a6abb830d9a1e4da77cb05da7c0b226" translate="yes" xml:space="preserve">
          <source>R-P {cost: 11.27}</source>
          <target state="translated">RP {비용 : 11.27}</target>
        </trans-unit>
        <trans-unit id="a39f8b032fb6773009f23cdf1fc4a43dca07ca75" translate="yes" xml:space="preserve">
          <source>R-tree indexes</source>
          <target state="translated">R- 트리 인덱스</target>
        </trans-unit>
        <trans-unit id="27625665a48434a97da2f59bce85a61c08c57d13" translate="yes" xml:space="preserve">
          <source>RAISE</source>
          <target state="translated">RAISE</target>
        </trans-unit>
        <trans-unit id="eab70b41d287161d06757b3c91f16b40700edd9b" translate="yes" xml:space="preserve">
          <source>RAISE function</source>
          <target state="translated">인상 기능</target>
        </trans-unit>
        <trans-unit id="578e6dad8d99e7211a3086f6ebcd1836a6b2b2b0" translate="yes" xml:space="preserve">
          <source>RANGE</source>
          <target state="translated">RANGE</target>
        </trans-unit>
        <trans-unit id="ddd7e61302a8592bafc0bc44fda92b4c46585957" translate="yes" xml:space="preserve">
          <source>RANGE frames</source>
          <target state="translated">범위 프레임</target>
        </trans-unit>
        <trans-unit id="3314a11c461e2d3c3169c9709d07e23cec14a354" translate="yes" xml:space="preserve">
          <source>RANGE n PRECEDING</source>
          <target state="translated">범위 n 선행</target>
        </trans-unit>
        <trans-unit id="f4c206eeb5c6f3b744195c276954fdb473ea9623" translate="yes" xml:space="preserve">
          <source>RBU Database Contents</source>
          <target state="translated">RBU 데이터베이스 내용</target>
        </trans-unit>
        <trans-unit id="712d8aa663fc4fe498c4350eb3d107a2e61b11c3" translate="yes" xml:space="preserve">
          <source>RBU Database Tables</source>
          <target state="translated">RBU 데이터베이스 테이블</target>
        </trans-unit>
        <trans-unit id="07201c49e16cf7ee53c14561a1009692319b08f1" translate="yes" xml:space="preserve">
          <source>RBU Extension</source>
          <target state="translated">RBU 확장</target>
        </trans-unit>
        <trans-unit id="e78ae84baf56b93a5fa01e9dafad71c1200f7218" translate="yes" xml:space="preserve">
          <source>RBU FTS3/4 Tables</source>
          <target state="translated">RBU FTS3 / 4 테이블</target>
        </trans-unit>
        <trans-unit id="462b7e20bcfb4a1c16aa1cac30ebb2f5b6113539" translate="yes" xml:space="preserve">
          <source>RBU Update</source>
          <target state="translated">RBU 업데이트</target>
        </trans-unit>
        <trans-unit id="fa41f4d5c464fe94904b941d3fdd9fd06f70c8d7" translate="yes" xml:space="preserve">
          <source>RBU Vacuum</source>
          <target state="translated">RBU 진공</target>
        </trans-unit>
        <trans-unit id="29b65cd1a0583c71c8f08f136996230310e8af2c" translate="yes" xml:space="preserve">
          <source>RBU Vacuum applications all implement some variation of the following procedure:</source>
          <target state="translated">RBU 진공 애플리케이션은 모두 다음 절차의 일부 변형을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="5f247eac406d30bce84777c8b0ea049a1e0cac26" translate="yes" xml:space="preserve">
          <source>RBU operations may be suspended and then later resumed, perhaps with intervening power outages and/or system resets. For an RBU update, the original database content remains visible to all database readers until the entire update has been applied - even if the update is suspended and then later resumed.</source>
          <target state="translated">RBU 작업이 일시 중단 된 다음 나중에 중단 될 수 있습니다 (중간 정전 및 / 또는 시스템 재설정). RBU 업데이트의 경우 업데이트가 일시 중지 된 후 나중에 다시 시작 되더라도 전체 업데이트가 적용될 때까지 원본 데이터베이스 내용이 모든 데이터베이스 판독기에 계속 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="51d4c96a1d92222b7d93c52475b51db8766c79b8" translate="yes" xml:space="preserve">
          <source>RBU updates cannot be applied to any tables that contain a column named &quot;rbu_control&quot;.</source>
          <target state="translated">&quot;rbu_control&quot;이라는 열이 포함 된 테이블에는 RBU 업데이트를 적용 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3b330731a188b19fdf61999609e5e9b932bb400b" translate="yes" xml:space="preserve">
          <source>REAL</source>
          <target state="translated">REAL</target>
        </trans-unit>
        <trans-unit id="d2c4a8bcf4efc09f908cb4e40d7d6f381c3c3ef0" translate="yes" xml:space="preserve">
          <source>RECURSIVE</source>
          <target state="translated">RECURSIVE</target>
        </trans-unit>
        <trans-unit id="d4730753022e62db3135b00e0df88859d25187e8" translate="yes" xml:space="preserve">
          <source>REFERENCES</source>
          <target state="translated">REFERENCES</target>
        </trans-unit>
        <trans-unit id="2347c845abd05fb0d1bae0ab927335b643793946" translate="yes" xml:space="preserve">
          <source>REGEXP</source>
          <target state="translated">REGEXP</target>
        </trans-unit>
        <trans-unit id="5345e769e7d2d5a04080b106526b4188c28b2947" translate="yes" xml:space="preserve">
          <source>REINDEX</source>
          <target state="translated">REINDEX</target>
        </trans-unit>
        <trans-unit id="f73b278fdabab028fe5f65c62197e4b5634529e5" translate="yes" xml:space="preserve">
          <source>RELEASE</source>
          <target state="translated">RELEASE</target>
        </trans-unit>
        <trans-unit id="bec39b2581dc86d96ef7eb4b59715b2db9fb5b98" translate="yes" xml:space="preserve">
          <source>RELEASE SAVEPOINT</source>
          <target state="translated">릴리즈 포인트</target>
        </trans-unit>
        <trans-unit id="4756081595ff9366e8b59c094aebf3df53a8fc98" translate="yes" xml:space="preserve">
          <source>RENAME</source>
          <target state="translated">RENAME</target>
        </trans-unit>
        <trans-unit id="a464c34da3d7dbc3eb6ade113363a4f1b48466a0" translate="yes" xml:space="preserve">
          <source>RENAME COLUMN</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c336fcec997db68ba1a16ff95d4b5a6b5f133c3b" translate="yes" xml:space="preserve">
          <source>REPLACE</source>
          <target state="translated">REPLACE</target>
        </trans-unit>
        <trans-unit id="eb5450aba42e33754272b8b32dc01c695827c179" translate="yes" xml:space="preserve">
          <source>REPLACE INTO</source>
          <target state="translated">로 교체</target>
        </trans-unit>
        <trans-unit id="044eabc2191e6bd2b8395304f84a790584ab5cd3" translate="yes" xml:space="preserve">
          <source>RESERVED</source>
          <target state="translated">RESERVED</target>
        </trans-unit>
        <trans-unit id="69ed002a9f57d1ba3022c561c2f3bb595bf68418" translate="yes" xml:space="preserve">
          <source>RESTART</source>
          <target state="translated">RESTART</target>
        </trans-unit>
        <trans-unit id="99e2cdb8b048ca3999469c35242023f92980f5e6" translate="yes" xml:space="preserve">
          <source>RESTRICT</source>
          <target state="translated">RESTRICT</target>
        </trans-unit>
        <trans-unit id="95253203f79304981143599cedfdaa606f083ca2" translate="yes" xml:space="preserve">
          <source>RIGHT</source>
          <target state="translated">RIGHT</target>
        </trans-unit>
        <trans-unit id="2ce42e824f2163751d62c49d3226c338efa1179d" translate="yes" xml:space="preserve">
          <source>ROLLBACK</source>
          <target state="translated">ROLLBACK</target>
        </trans-unit>
        <trans-unit id="1b38c7ab7be8eb4066bc5bd507af4275ed737be5" translate="yes" xml:space="preserve">
          <source>ROLLBACK TRANSACTION</source>
          <target state="translated">롤백 거래</target>
        </trans-unit>
        <trans-unit id="fee8f3fde6222d1d587520ccdcc8bdc883934e5b" translate="yes" xml:space="preserve">
          <source>ROW</source>
          <target state="translated">ROW</target>
        </trans-unit>
        <trans-unit id="27bcbad0c7dc6e890992a45957c32cb63b180961" translate="yes" xml:space="preserve">
          <source>ROWID</source>
          <target state="translated">ROWID</target>
        </trans-unit>
        <trans-unit id="1066d5101585674b0bf2bb2a7f36e54bd28ffb0c" translate="yes" xml:space="preserve">
          <source>ROWIDs and the INTEGER PRIMARY KEY</source>
          <target state="translated">ROWID 및 정수 기본 키</target>
        </trans-unit>
        <trans-unit id="35c47b79dc3cdab698d2bf71b053c1b257f8db73" translate="yes" xml:space="preserve">
          <source>ROWS</source>
          <target state="translated">ROWS</target>
        </trans-unit>
        <trans-unit id="43bc1be6b036dd85df3053c47dc4432d982cf8e0" translate="yes" xml:space="preserve">
          <source>RTRIM</source>
          <target state="translated">RTRIM</target>
        </trans-unit>
        <trans-unit id="912333c4ddec40db71424e4b21120e0065cfde78" translate="yes" xml:space="preserve">
          <source>RTRIM collating function</source>
          <target state="translated">RTRIM 조합 기능</target>
        </trans-unit>
        <trans-unit id="d4ccca8588cab0a99233c6cf71400747dcf81d92" translate="yes" xml:space="preserve">
          <source>RTRIM is like BINARY except that extra spaces at the end of either string do not change the result. In other words, strings will compare equal to one another as long as they differ only in the number of spaces at the end.</source>
          <target state="translated">RTRIM은 BINARY와 비슷하지만 문자열 끝에 여분의 공백이 있으면 결과가 변경되지 않습니다. 다시 말해서, 문자열은 끝에 공백 수가 다른 한 문자열과 서로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="73bc329996a4b61f272d21a8ef8e13d37b2f5bf8" translate="yes" xml:space="preserve">
          <source>Raising the number of open databases may improve performance in some scenarios.</source>
          <target state="translated">열린 데이터베이스 수를 늘리면 일부 시나리오에서 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62e76ddc1a4a4c5a8b50ba8345b20a992c2b937" translate="yes" xml:space="preserve">
          <source>Range query optimization</source>
          <target state="translated">범위 쿼리 최적화</target>
        </trans-unit>
        <trans-unit id="415026844c74bb5d00489173b1d5e1a90b70bfca" translate="yes" xml:space="preserve">
          <source>Raw (possibly compressed) data associated with zip file entry (a blob).</source>
          <target state="translated">zip 파일 항목 (blob)과 관련된 원시 (압축 가능) 데이터</target>
        </trans-unit>
        <trans-unit id="3685a628a8d194c36e92956d9b368621a3c4f89e" translate="yes" xml:space="preserve">
          <source>Reactivated the VACUUM command that reclaims unused disk space in a database file.</source>
          <target state="translated">데이터베이스 파일에서 사용되지 않은 디스크 공간을 회수하는 VACUUM 명령을 재 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="7bf4a534bd19935da933046f9a9ff7be5b6a7965" translate="yes" xml:space="preserve">
          <source>Read Data From A BLOB Incrementally</source>
          <target state="translated">BLOB에서 증 분식으로 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="4817ee387eb1c80d362458e295a1ce28b034e185" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the SQLITE_MASTER table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">WHERE 절 P4와 일치하는 데이터베이스 P1의 SQLITE_MASTER 테이블에서 모든 항목을 읽고 구문 분석하십시오. P4가 NULL 포인터이면 P1에 대한 전체 스키마가 재분석됩니다.</target>
        </trans-unit>
        <trans-unit id="427a567a06032b13c88b02d33d153fca76063c5d" translate="yes" xml:space="preserve">
          <source>Read and parse all entries from the schema table of database P1 that match the WHERE clause P4. If P4 is a NULL pointer, then the entire schema for P1 is reparsed.</source>
          <target state="translated">WHERE 절 P4와 일치하는 데이터베이스 P1의 스키마 테이블에서 모든 항목을 읽고 구문 분석합니다. P4가 NULL 포인터이면 P1의 전체 스키마가 다시 구문 분석됩니다.</target>
        </trans-unit>
        <trans-unit id="06b6a6259408a05057f38693264034af5b800655" translate="yes" xml:space="preserve">
          <source>Read and/or write the content of a comma-separated value (CSV) file</source>
          <target state="translated">CSV (쉼표로 구분 된 값) 파일의 내용을 읽거나 쓰십시오.</target>
        </trans-unit>
        <trans-unit id="37ad8caf62966373ce6c4e8d0b90dbca553a6d76" translate="yes" xml:space="preserve">
          <source>Read cookie number P3 from database P1 and write it into register P2. P3==1 is the schema version. P3==2 is the database format. P3==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">데이터베이스 P1에서 쿠키 번호 P3을 읽고 레지스터 P2에 씁니다. P3 == 1은 스키마 버전입니다. P3 == 2는 데이터베이스 형식입니다. P3 == 3은 권장 된 호출기 캐시 크기 등입니다. P1 == 0은 기본 데이터베이스 파일이고 P1 == 1은 임시 테이블을 저장하는 데 사용되는 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="e71f89bd0ef9b4251c544f6970cc91848cb5836e" translate="yes" xml:space="preserve">
          <source>Read the journal file and roll back the changes.</source>
          <target state="translated">저널 파일을 읽고 변경 사항을 롤백하십시오.</target>
        </trans-unit>
        <trans-unit id="6d88c31d2b81845a511df588f6a77f45dfc3be73" translate="yes" xml:space="preserve">
          <source>Read the sqlite_stat1 table for database P1 and load the content of that table into the internal index hash table. This will cause the analysis to be used when preparing all subsequent queries.</source>
          <target state="translated">데이터베이스 P1에 대한 sqlite_stat1 테이블을 읽고 해당 테이블의 컨텐츠를 내부 인덱스 해시 테이블에로드하십시오. 이로 인해 모든 후속 쿼리를 준비 할 때 분석이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e44b30ba60fce1cc60703c777be280cb42ce89f" translate="yes" xml:space="preserve">
          <source>Read transactions versus write transactions</source>
          <target state="translated">읽기 트랜잭션과 쓰기 트랜잭션</target>
        </trans-unit>
        <trans-unit id="c8e239ec9521392219205446c1db66f47cb14a6f" translate="yes" xml:space="preserve">
          <source>Read-mark name</source>
          <target state="translated">읽기 마크 이름</target>
        </trans-unit>
        <trans-unit id="e722ca5fefcf08950d7578b4ed97dfff47cf060e" translate="yes" xml:space="preserve">
          <source>Read-mark offset</source>
          <target state="translated">읽기 마크 오프셋</target>
        </trans-unit>
        <trans-unit id="54ac153bd485005c1470e6c415d25c56cea6db82" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the</source>
          <target state="translated">커밋되지 않은 읽기 모드는 데이터베이스 테이블에 쓰는 데 필요한 잠금에 영향을 미치지 않습니다 (즉, 커밋되지 않은 읽기 연결은 여전히 ​​쓰기 잠금을 얻어야하므로 데이터베이스 쓰기가 여전히 차단되거나 차단 될 수 있음). 또한 커밋되지 않은 읽기 모드는</target>
        </trans-unit>
        <trans-unit id="0f2ef9917dd28993c09e6d3368ecafd38ec21fd3" translate="yes" xml:space="preserve">
          <source>Read-uncommitted mode has no effect on the locks required to write to database tables (i.e. read-uncommitted connections must still obtain write-locks and hence database writes may still block or be blocked). Also, read-uncommitted mode has no effect on the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; locks required by the rules enumerated below (see section &quot;Schema (sqlite_schema) Level Locking&quot;).</source>
          <target state="translated">커밋되지 않은 읽기 모드는 데이터베이스 테이블에 쓰는 데 필요한 잠금에 영향을 미치지 않습니다 (즉, 커밋되지 않은 읽기 연결은 여전히 ​​쓰기 잠금을 획득해야하므로 데이터베이스 쓰기는 여전히 차단되거나 차단 될 수 있습니다). 또한 커밋되지 않은 읽기 모드는 아래 열거 된 규칙에 필요한 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 잠금 에 영향을주지 않습니다 ( &quot;스키마 (sqlite_schema) 수준 잠금&quot;섹션 참조).</target>
        </trans-unit>
        <trans-unit id="3be7f0a767b2f2348fac25e36a455df9d59b0aa8" translate="yes" xml:space="preserve">
          <source>ReadCookie</source>
          <target state="translated">ReadCookie</target>
        </trans-unit>
        <trans-unit id="31f3f980bf6aafbf0b6a01d8c93e178b55b84057" translate="yes" xml:space="preserve">
          <source>Readers can also interpret this document as a primer on the world-view of the SQLite Founder, to help them better understand &quot;where he is coming from&quot;.</source>
          <target state="translated">독자는이 문서를 SQLite Founder의 세계관에서 입문서로 해석하여 &quot;어디에서 왔는지&quot;를 더 잘 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8a4ca543f39205e57cdf686189d6cb9f899366" translate="yes" xml:space="preserve">
          <source>Reading Data</source>
          <target state="translated">데이터 읽기</target>
        </trans-unit>
        <trans-unit id="d6ac804a10ccff7c120f27eba34a8d2846e4c951" translate="yes" xml:space="preserve">
          <source>Reading Database Data</source>
          <target state="translated">데이터베이스 데이터 읽기</target>
        </trans-unit>
        <trans-unit id="5e3252839a95733cfd147953cc0469ba8c3ee82b" translate="yes" xml:space="preserve">
          <source>Reading and writing from an SQLite database is often faster than reading and writing individual files from disk. See &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; and &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt;.</source>
          <target state="translated">디스크에서 개별 파일을 읽고 쓰는 것보다 SQLite 데이터베이스에서 읽고 쓰는 것이 더 빠릅니다. 참조 &lt;a href=&quot;fasterthanfs&quot;&gt;빠른 파일 시스템보다 35 %&lt;/a&gt; 와 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;외부에 BLOB 대 내부&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="629464bd60f83394a3a117af1490178a3f7649b8" translate="yes" xml:space="preserve">
          <source>Reading is about an order of magnitude faster than writing, for all systems and for both SQLite and direct-to-disk I/O.</source>
          <target state="translated">읽기는 모든 시스템과 SQLite 및 디스크 직접 I / O 모두 쓰기보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8e16e5b2c446aea3b142d9320755f82932fc2cdf" translate="yes" xml:space="preserve">
          <source>Real</source>
          <target state="translated">Real</target>
        </trans-unit>
        <trans-unit id="51b9846d84b8915556858261f582bc9dc0399f32" translate="yes" xml:space="preserve">
          <source>RealAffinity</source>
          <target state="translated">RealAffinity</target>
        </trans-unit>
        <trans-unit id="316d0580c3ad15b3966bd98be1d84957c1e60292" translate="yes" xml:space="preserve">
          <source>Realign the memory allocation subsystem so that it never calls malloc() at all but instead satisfies all memory requests using a fixed-size memory buffer assigned to SQLite at startup.</source>
          <target state="translated">메모리 할당 서브 시스템을 다시 정렬하여 malloc ()을 전혀 호출하지 않고 시작시 SQLite에 지정된 고정 크기 메모리 버퍼를 사용하여 모든 메모리 요청을 충족 시키십시오.</target>
        </trans-unit>
        <trans-unit id="2d8e19244acdc1fed3e593bd66d86fe928aee4c4" translate="yes" xml:space="preserve">
          <source>Really means</source>
          <target state="translated">정말 의미</target>
        </trans-unit>
        <trans-unit id="9da9cf4099ea26b56238081e57a06dfa3fa584c9" translate="yes" xml:space="preserve">
          <source>Rebase a changeset</source>
          <target state="translated">체인지 셋 리베이스</target>
        </trans-unit>
        <trans-unit id="f4699eec6b4e510d56bd2c8d9d97198adba02986" translate="yes" xml:space="preserve">
          <source>Rebasing changesets</source>
          <target state="translated">기초 변경 모음</target>
        </trans-unit>
        <trans-unit id="2ef8fffd38b336e3ddd055d82551d4885c779b2a" translate="yes" xml:space="preserve">
          <source>Recall that by default SQLite assumes that sector writes are linear but not atomic. A linear write starts at one end of the sector and changes information byte by byte until it gets to the other end of the sector. If a power loss occurs in the middle of a linear write then part of the sector might be modified while the other end is unchanged. In an atomic sector write, either the entire sector is overwritten or else nothing in the sector is changed.</source>
          <target state="translated">기본적으로 SQLite는 섹터 쓰기가 선형이지만 원자는 아니라고 가정합니다. 선형 쓰기는 섹터의 한쪽 끝에서 시작하여 섹터의 다른 쪽 끝에 도달 할 때까지 바이트 단위로 정보를 변경합니다. 선형 쓰기 도중에 전력 손실이 발생하면 섹터의 일부가 수정되고 다른 쪽 끝은 변경되지 않을 수 있습니다. 원자 섹터 쓰기에서 전체 섹터를 덮어 쓰거나 섹터의 아무 것도 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fe42ed2ae63e9fc51b86e94617527ae66cabf09d" translate="yes" xml:space="preserve">
          <source>Recall that there are two versions of the count() aggregate. With zero arguments, count() returns a count of the number of rows. With one argument, count() returns the number of times that the argument was non-NULL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a00f50656a9b34825cf831a680edaba10510fe56" translate="yes" xml:space="preserve">
          <source>Recall the query template discussed above where there was a single loop that searched through every record of the table. In a join we have basically the same thing except that there are nested loops. For example, to join two tables, the query template might look something like this:</source>
          <target state="translated">테이블의 모든 레코드를 검색하는 단일 루프가있는 위에서 설명한 쿼리 템플릿을 상기하십시오. 결합에서 우리는 중첩 루프가 있다는 것을 제외하고는 기본적으로 같은 것을 가지고 있습니다. 예를 들어 두 테이블을 조인하기 위해 쿼리 템플릿은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86809186276b082875677dfb8773e34c548fc873" translate="yes" xml:space="preserve">
          <source>Recent versions of SQLite (&lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;version 3.5.4&lt;/a&gt; 2007-12-14) and later) will do this rewrite automatically if an index exists on the column ex2.b.</source>
          <target state="translated">ex2.b 열에 인덱스가있는 경우 최신 버전의 SQLite ( &lt;a href=&quot;https://sqlite.org/releaselog/3_5_4.html&quot;&gt;버전 3.5.4&lt;/a&gt; 2007-12-14) 이상에서 자동으로 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3bc92f0a6532d70c3844508e07c71adfd5cc6f39" translate="yes" xml:space="preserve">
          <source>Recently, folks have begun to use the word &quot;serverless&quot; to mean something subtly different from its intended meaning in this document. Here are two possible definitions of &quot;serverless&quot;:</source>
          <target state="translated">최근에 사람들은이 문서에서 의도 된 의미와 미묘하게 다른 것을 의미하기 위해 &quot;서버리스&quot;라는 단어를 사용하기 시작했습니다. &quot;서버리스&quot;에 대한 두 가지 가능한 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6aff9d1c0cd44324ba9f0bf36546b5e1f8429f77" translate="yes" xml:space="preserve">
          <source>Recognize TRUE and FALSE as constants. (For compatibility, if there exist columns named &quot;true&quot; or &quot;false&quot;, then the identifiers refer to the columns rather than Boolean constants.)</source>
          <target state="translated">TRUE 및 FALSE를 상수로 인식하십시오. 호환성을 위해 &quot;true&quot;또는 &quot;false&quot;라는 열이 있으면 식별자는 부울 상수가 아닌 열을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="179015156dce938e7897002183aef5320bee7f01" translate="yes" xml:space="preserve">
          <source>Recognize always that evil is your own doing, and to impute it to yourself.</source>
          <target state="translated">악은 자신이하는 일임을 항상 인식하고 그것을 자신에게 전가 시키십시오.</target>
        </trans-unit>
        <trans-unit id="29b5caee3338c6458807b234105f74058b4d7a0e" translate="yes" xml:space="preserve">
          <source>Recognize and use the &lt;a href=&quot;uri#coreqp&quot;&gt;mode=memory&lt;/a&gt; query parameter in &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; 에서 &lt;a href=&quot;uri#coreqp&quot;&gt;mode = memory&lt;/a&gt; query 매개 변수를 인식하고 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb32b6d7f8df5da26a0dcd937f77f995164cb71d" translate="yes" xml:space="preserve">
          <source>Recommended practice is to omit any extra tokens in the rtree specification. Let each argument to &quot;rtree&quot; be a single ordinary label that is the name of the corresponding column, and omit all other tokens from the argument list.</source>
          <target state="translated">권장되는 방법은 rtree 사양에서 추가 토큰을 생략하는 것입니다. &quot;rtree&quot;에 대한 각 인수를 해당 열의 이름 인 단일 일반 레이블로하고 인수 목록에서 다른 모든 토큰을 생략합니다.</target>
        </trans-unit>
        <trans-unit id="c16e180b0bdec1403e839436f75c49abbd9e4f92" translate="yes" xml:space="preserve">
          <source>Recommended storage formats are formats which, in the opinion of the preservationists at the Library of Congress, maximizes the chance of survival and continued accessibility of digital content. When selecting recommended storage formats, the following criteria are considered (quoting from the LOC website):</source>
          <target state="translated">권장 저장 형식은 의회 도서관의 보존 론자들의 견해에 따라 디지털 컨텐츠의 생존 가능성과 지속적인 접근성을 최대화하는 형식입니다. 권장 스토리지 형식을 선택할 때 다음 기준이 고려됩니다 (LOC 웹 사이트에서 인용).</target>
        </trans-unit>
        <trans-unit id="5592531a18661eb883b5bed3c568528bf424614f" translate="yes" xml:space="preserve">
          <source>Reconfigure the memory allocation subsystem to use a memory allocator other the malloc() implementation from the standard library.</source>
          <target state="translated">표준 라이브러리에서 malloc () 구현 이외의 메모리 할당자를 사용하도록 메모리 할당 서브 시스템을 재구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8ba4782c1f2f1755a1c2a5a0d315ff7ac146d397" translate="yes" xml:space="preserve">
          <source>Record A Database Snapshot</source>
          <target state="translated">데이터베이스 스냅 샷 기록</target>
        </trans-unit>
        <trans-unit id="8234a19b9512ea840c0ba24f55af66169cacecab" translate="yes" xml:space="preserve">
          <source>Record format</source>
          <target state="translated">기록 형식</target>
        </trans-unit>
        <trans-unit id="10c3664b2112d9f16bd331cd75392554bbbcdf62" translate="yes" xml:space="preserve">
          <source>Records may be removed from an existing zip archive by deleting the corresponding rows. For example, to remove file &quot;m.txt&quot; from zip archive &quot;test.zip&quot; using the virtual table created above:</source>
          <target state="translated">해당 행을 삭제하여 기존 zip 아카이브에서 레코드를 제거 할 수 있습니다. 예를 들어, 위에서 만든 가상 테이블을 사용하여 zip 아카이브 &quot;test.zip&quot;에서 &quot;m.txt&quot;파일을 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="9d25bfb94d2fc125544295d666182c0dd2c985e3" translate="yes" xml:space="preserve">
          <source>Recover snapshots from a wal file</source>
          <target state="translated">wal 파일에서 스냅 샷 복구</target>
        </trans-unit>
        <trans-unit id="a5ee4bb9875041e97087fa0bc2157c001344d43d" translate="yes" xml:space="preserve">
          <source>Recovery is run by the first thread to connect to a WAL-mode database. Recovery restores the WAL-index so that it accurately describes the WAL file. If there is no WAL file present when the first thread connects to the database, there is nothing to recover, but the recovery process still runs to initialize the WAL-index.</source>
          <target state="translated">복구는 WAL 모드 데이터베이스에 연결하기 위해 첫 번째 스레드에서 실행됩니다. 복구는 WAL 파일을 정확하게 설명하도록 WAL 색인을 복원합니다. 첫 번째 스레드가 데이터베이스에 연결할 때 WAL 파일이 없으면 복구 할 것이 없지만 복구 프로세스는 여전히 WAL 색인을 초기화하기 위해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb50e77cc812505c4eff76e2425d38fe88e897da" translate="yes" xml:space="preserve">
          <source>Recovery is the process of rebuilding the WAL-index so that it is synchronized with the WAL.</source>
          <target state="translated">복구는 WAL과 동기화되도록 WAL 인덱스를 다시 작성하는 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="126c442522e8176d581a74aac3e674f456801a72" translate="yes" xml:space="preserve">
          <source>Recovery works by doing a single pass over the WAL, from beginning to end. The checksums are verified on each frame of the WAL as it is read. The scan stops at the end of the file or at the first invalid checksum. The &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame&lt;/a&gt; field is set to the index of the last valid commit frame in WAL. Since WAL frame numbers are indexed starting with 1, mxFrame is also the number of valid frames in the WAL. A &quot;commit frame&quot; is a frame that has a non-zero value in bytes 4 through 7 of the frame header. Since the recovery procedure has no way of knowing how many frames of the WAL might have previously been copied back into the database, it initializes the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; value to zero.</source>
          <target state="translated">복구는 처음부터 끝까지 WAL을 통해 단일 패스를 수행하여 작동합니다. 체크섬은 WAL을 읽을 때 각 프레임에서 확인됩니다. 스캔은 파일 끝 또는 첫 번째 유효하지 않은 체크섬에서 중지됩니다. &lt;a href=&quot;walformat#mxframe&quot;&gt;mxFrame의&lt;/a&gt; 필드 WAL에 유효한 커밋 최종 프레임의 인덱스로 설정된다. WAL 프레임 번호는 1부터 시작하여 인덱싱되므로 mxFrame도 WAL의 유효한 프레임 수입니다. &quot;커밋 프레임&quot;은 프레임 헤더의 바이트 4에서 7까지 0이 아닌 값을 갖는 프레임입니다. 복구 프로시 저는 이전에 데이터베이스에 다시 복사 된 WAL의 프레임 수를 알 수있는 방법이 없으므로 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; 값을 0으로 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="3d82c021f8a8434797b007430def5edf49be84c3" translate="yes" xml:space="preserve">
          <source>Recursive Common Table Expressions</source>
          <target state="translated">재귀 공통 테이블 표현식</target>
        </trans-unit>
        <trans-unit id="7c623be56f37d78f01c1c7d914b54e7a24680aab" translate="yes" xml:space="preserve">
          <source>Recursive Query Examples</source>
          <target state="translated">재귀 쿼리 예제</target>
        </trans-unit>
        <trans-unit id="8f08fb34ad6f2633ad710e95a13cbec5c283657b" translate="yes" xml:space="preserve">
          <source>Recursive query</source>
          <target state="translated">재귀 쿼리</target>
        </trans-unit>
        <trans-unit id="c73052a6762ac25c0cb1d9b0bebcfc3a9bcec8a1" translate="yes" xml:space="preserve">
          <source>Recursive triggers can be enabled using the &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;PRAGMA recursive_triggers&lt;/a&gt; 문을 사용하여 재귀 트리거를 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="142c98a709e57d4d546600faca999a5bf35abdaa" translate="yes" xml:space="preserve">
          <source>Redesign the OS interface layer. See &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; for details. *** Potentially incompatible change ***</source>
          <target state="translated">OS 인터페이스 계층을 재 설계하십시오. 자세한 내용은 &lt;a href=&quot;34to35&quot;&gt;34to35.html&lt;/a&gt; 을 참조하십시오. *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="7d081723177fd4e3a870ace0d58c302ef456d798" translate="yes" xml:space="preserve">
          <source>Reduce the &lt;a href=&quot;limits&quot;&gt;limits&lt;/a&gt; that SQLite imposes on inputs. This can help prevent denial of service attacks and other kinds of mischief that can occur as a result of unusually large inputs. You can do this either at compile-time using -DSQLITE_MAX_... options, or at run-time using the &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface. Most applications can reduce limits dramatically without impacting functionality. The table below provides some suggestions, though exact values will vary depending on the application:</source>
          <target state="translated">SQLite가 입력에 부과 하는 &lt;a href=&quot;limits&quot;&gt;한계&lt;/a&gt; 를 줄 입니다. 이를 통해 비정상적으로 큰 입력으로 인해 발생할 수있는 서비스 거부 공격 및 기타 종류의 장난을 방지 할 수 있습니다. -DSQLITE_MAX _... 옵션을 사용하여 컴파일 타임에 또는 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 인터페이스를 사용하여 런타임에이를 수행 할 수 있습니다 . 대부분의 응용 프로그램은 기능에 영향을 미치지 않고 한계를 크게 줄일 수 있습니다. 아래 표는 몇 가지 제안을 제공하지만 정확한 값은 응용 프로그램에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="818c7c2bc91785e19d03eddcb38dd27df259ccaf" translate="yes" xml:space="preserve">
          <source>Reduce the amount of heap memory used, especially by TRIGGERs.</source>
          <target state="translated">특히 TRIGGER에서 사용되는 힙 메모리의 양을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="eef61fea62e3c60ebd3be2d6739fac06ddb5ab7f" translate="yes" xml:space="preserve">
          <source>Reduce the amount of memory needed to hold the schema.</source>
          <target state="translated">스키마를 보유하는 데 필요한 메모리 양을 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="46eb8cc3e58b2e58eac841d7bad510287fbae8b0" translate="yes" xml:space="preserve">
          <source>Reduce the amount of stack space used</source>
          <target state="translated">사용 된 스택 공간의 양을 줄입니다</target>
        </trans-unit>
        <trans-unit id="2a4594bb7a13597e42630528fe396b294272a9f2" translate="yes" xml:space="preserve">
          <source>Reduce the number of memcpy() operations involved in balancing a b-tree, for 3.2% overall performance boost.</source>
          <target state="translated">b- 트리 균형 조정과 관련된 memcpy () 작업 수를 줄여 전체 성능을 3.2 % 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="15563f82edab75e0e9a9533c5985511dfd901167" translate="yes" xml:space="preserve">
          <source>Reduce the size and increase the speed of various modules, especially the virtual machine.</source>
          <target state="translated">다양한 모듈, 특히 가상 머신의 크기를 줄이고 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="f355d2ddba29d09803b074513416794452b26fe2" translate="yes" xml:space="preserve">
          <source>Reenable the xCurrentTime and xGetLastError methods in the built-in unix &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; as long as &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED&lt;/a&gt; is not defined.</source>
          <target state="translated">의 xCurrentTime 및 xGetLastError 방법을 다시 활성화 내장 된 유닉스 &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; 긴만큼 &lt;a href=&quot;compile#omit_deprecated&quot;&gt;SQLITE_OMIT_DEPRECATED가&lt;/a&gt; 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f79991a5be2e57d9f5c8d975047a7ce1e99e2e69" translate="yes" xml:space="preserve">
          <source>Refactor parts of the code in order to make the code footprint smaller. The code is now also a little bit faster.</source>
          <target state="translated">코드 풋 프린트를 더 작게 만들기 위해 코드의 일부를 리팩터링하십시오. 코드는 이제 조금 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="731a046a349bd8b2ec56f17167cd9586697efc8d" translate="yes" xml:space="preserve">
          <source>Refactor the implementation of PRAGMA statements to improve parsing performance.</source>
          <target state="translated">구문 분석 성능을 향상시키기 위해 PRAGMA 문의 구현을 리팩터링하십시오.</target>
        </trans-unit>
        <trans-unit id="e01090e00d57212fc38896c2384f678dca5a4d12" translate="yes" xml:space="preserve">
          <source>Refactor the internal representation of SQL expressions so that they use less memory on embedded platforms.</source>
          <target state="translated">임베디드 플랫폼에서 더 적은 메모리를 사용하도록 SQL 표현식의 내부 표현을 리 팩터하십시오.</target>
        </trans-unit>
        <trans-unit id="f207a8a558acb07f31589303df5e596105913ffb" translate="yes" xml:space="preserve">
          <source>Refactored the pager module.</source>
          <target state="translated">호출기 모듈을 리팩토링했습니다.</target>
        </trans-unit>
        <trans-unit id="226346556688fb9ee0c75ecc678574e3685f1eba" translate="yes" xml:space="preserve">
          <source>Refer to comments in the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt; sqlite3async.h header file&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용 은 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/async/sqlite3async.h&quot;&gt;sqlite3async.h 헤더 파일의&lt;/a&gt; 주석을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="aaa837aee763755888a50c44b690c5b28c724c42" translate="yes" xml:space="preserve">
          <source>Refer to section</source>
          <target state="translated">섹션을 참조하십시오</target>
        </trans-unit>
        <trans-unit id="4604acc1b8f76983f5d1c6cf4dd45f3755df9f62" translate="yes" xml:space="preserve">
          <source>Refer to the documentation for the &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 automerge option&lt;/a&gt; for more details regarding the relationship between the full-text index and its component b-trees.</source>
          <target state="translated">전체 텍스트 인덱스와 구성 요소 b- 트리 간의 관계에 대한 자세한 내용 은 &lt;a href=&quot;fts5#the_automerge_configuration_option&quot;&gt;FTS5 자동 병합 옵션&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5c53a88bcf3d728c764909fd53351fd558c74013" translate="yes" xml:space="preserve">
          <source>Refer to the sqlite3_changegroup documentation below for details.</source>
          <target state="translated">자세한 내용은 아래 sqlite3_changegroup 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96203fca2f22f72728b0d96559374bef790492f7" translate="yes" xml:space="preserve">
          <source>Refer to wikipedia for &lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;more information regarding BM25&lt;/a&gt; and its variants.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Okapi_BM25&quot;&gt;BM25&lt;/a&gt; 및 그 변형 에 대한 자세한 내용은 Wikipedia를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="ed24ba4d4b3deaa5349f31379e8793cc898888c5" translate="yes" xml:space="preserve">
          <source>References to the table within CHECK constraints in the original CREATE TABLE statement.</source>
          <target state="translated">원래 CREATE TABLE 문의 CHECK 제한 조건 내의 테이블에 대한 참조</target>
        </trans-unit>
        <trans-unit id="f196200e5cee3f63f8cb5af84d2656fca6403f9b" translate="yes" xml:space="preserve">
          <source>References to the table within the WHERE clauses of &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절 내 테이블에 대한 참조 입니다.</target>
        </trans-unit>
        <trans-unit id="9ee14d3156938bfc006a2f0c8ed355d9ca151ab6" translate="yes" xml:space="preserve">
          <source>References to the table within the bodies of triggers and views.</source>
          <target state="translated">트리거 및 뷰 본문 내 테이블에 대한 참조</target>
        </trans-unit>
        <trans-unit id="906a77daf0ffffc997c9b5822b41dc5c11c3a7b9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#analyze-stmt&quot;&gt;분석 -stmt &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;#begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;#commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;#detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;#drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;#drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;#drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;#reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;#release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;#rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;#savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;업데이트- stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;업데이트 -stmt 제한 &lt;/a&gt;&lt;a href=&quot;#vacuum-stmt&quot;&gt;진공 -stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91c7fe4cacb331d9cfb44eb087944db8da3afcbf" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-constraint&quot;&gt;열 제한 조건 &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;유형 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d8aed8c6ef717e51cf55fa5d410506ec56f1af1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bd54af792928e125a7c3d661324a97a3ce29b673" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="071f7537398d675e45a2fdaeb7bd26af44546b4d" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="282f6190a1e00fb7ff7db1945ee84f7660a92c19" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21742ff977fd9e5a8403d3239f8a93202fb0f39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;열 이름 목록 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;색인 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f805e85c41e9b3e30cafd3a842789358c3b6f12" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c69d978973c2b2241d5e4e82a79030c6aad5250" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c2fd61f6a02e283a2e59272b7eb020a882319466" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;순서 용어 &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="667fd9a2ec0f33043daaaa5159b9ecc1f39e7b33" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8472bb382411c88450e331d7c59babdb2e746659" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;순서 지정 용어 &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77d3b028f4d456c29b115c3c1f35daadd6ff1624" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f8ccd3795f8b71bf70343d3fadc3ac179cc9d91" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a74b1ac9b009442b86c0a0250e3450f6dd245c7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="093e3a3349236fc2dfd7410c161635443356bb67" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#conflict-clause&quot;&gt;충돌 절 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="75b80513956bb1581ff56ceefb5d202b11f453b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;#signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d11da2b5af692e996d5a48b32dfe86b2041eb8fa" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d0820e324079711069f47384d996edb389c3588" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20cbc57031b425ef7fc75a576696f91fe9b3d951" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93149806f66b1921c7517b514d80a3b282666f6b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8bd75a2c3ba3eeca6c41d3a9318cbfdbb49e88c0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af58968390f59e5f5b4c323addb3e01a57ee6c1e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32f96f5ec0fb2907e9e4e032ea0ae81ddc82a1a3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9dbf0458189780b769224889b3056c63b7e1f84" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="59c40f8bbdab8cad4f5af93d93f71d7dbf30aa93" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b9919027e05781036111a8daacdadf3c525fde5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0773bdc1abf8efee6c1c60cecf9ee9685433dab7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;order-term &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24422bef8d6810e38018f045129e207f3e959155" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85f3810be175c469cf369360e14b9b2e5e01ac51" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="70abaefe9f99828256cfd758a3afb7aa4c216e61" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;#literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#raise-function&quot;&gt;raise-function &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c999a62fb82e126ba176715636e35111bb542d88" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;#join-operator&quot;&gt;join-operator &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ad3c1f9f2a404dc774db57c85b8cec60718ee04" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="442eba43f59acab4d01a4fc91704194929768abd" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be27274cd4dccea52cefd3991def25081da71262" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참고 문헌 : &lt;a href=&quot;#signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a57a4e147f3de189d6e7e73c4c51f52022e0bd82" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38492d751f295bea065fa71e3925fb3ad037a1e2" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;analyze-stmt&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt&lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt&lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt&lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt&lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt&lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt&lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt&lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt&lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;vacuum-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;analyze-stmt&quot;&gt;분석 -stmt &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt &lt;/a&gt;&lt;a href=&quot;begin-stmt&quot;&gt;begin-stmt &lt;/a&gt;&lt;a href=&quot;commit-stmt&quot;&gt;commit-stmt &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;create-virtual-table-stmt&quot;&gt;create-virtual-table-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete -stmt-limited &lt;/a&gt;&lt;a href=&quot;detach-stmt&quot;&gt;detach-stmt &lt;/a&gt;&lt;a href=&quot;drop-index-stmt&quot;&gt;drop-index-stmt &lt;/a&gt;&lt;a href=&quot;drop-table-stmt&quot;&gt;drop-table-stmt &lt;/a&gt;&lt;a href=&quot;drop-trigger-stmt&quot;&gt;drop-trigger-stmt &lt;/a&gt;&lt;a href=&quot;drop-view-stmt&quot;&gt;drop-view-stmt &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt &lt;/a&gt;&lt;a href=&quot;reindex-stmt&quot;&gt;reindex-stmt &lt;/a&gt;&lt;a href=&quot;release-stmt&quot;&gt;release-stmt &lt;/a&gt;&lt;a href=&quot;rollback-stmt&quot;&gt;rollback-stmt &lt;/a&gt;&lt;a href=&quot;savepoint-stmt&quot;&gt;savepoint-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;업데이트- stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;업데이트 -stmt 제한 &lt;/a&gt;&lt;a href=&quot;vacuum-stmt&quot;&gt;진공 -stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="650835c724bb2a86f89f84e9bbd3b780c13b6c9b" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-constraint&quot;&gt;열 제한 조건 &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;유형 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="794b40cf8cd20637c83761e0684d3f4a5ca08040" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa218b2013469fb9882536f9cece6e55484d18b7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5321f3c79df9e1ae13dc45785cee7ab2db6ce76c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d04da558e7b275ed093eaddcfd1b8fc7d2f8e276" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 서브 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0efb77e2ca9ef9f00e4b6a166106c03c563ce0be" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4f6089017390e83489b6d24ed571adac8331d80" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1113daac28cbd063c08079443895f5566fdb33e5" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;column-name-list&quot;&gt;column-name-list&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;column-name-list&quot;&gt;column-name-list &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3451b0f3b2b5af6b8d8b5aaefde1b19828f7a6c" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;순서 용어 &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bba4382f55d6ffe66c81fa9289d49182e1355fcb" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;compound-operator&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;compound-operator&quot;&gt;복합 연산자 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b632fa679cae46b9a02f325553f2a2a7613b116" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;순서 지정 용어 &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79d31ae5a462b6f054075ad5596a58eef1283d37" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;주문 기간 &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;선택 코어&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1445ac57fe2b5334ccb8353e30f33be3e0e94b22" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;규정 된 테이블 이름&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91e02a407b8ce1872e126aedfe89133ac0d4f641" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;common-table-expression&quot;&gt;공통 테이블 표현식 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8df9ea1d38fc83cf8d4c226cc463aaf1077b0c6f" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;conflict-clause&quot;&gt;충돌 절 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b098cacd25ca6e0fe7a4f6cbe7dc7b7acf41b7b8" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;conflict-clause&quot;&gt;conflict-clause &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;foreign-key-clause&quot;&gt;foreign-key-clause &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f46943158a8d7768ec74ac4bca397f3d7466cc" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52f4dcceccfec99df86cc955c80ee8cdbaf49960" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;cte-table-name&quot;&gt;cte-table-name &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96f363ba239b93df7e224622a52457e08203ac21" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b1460387ec8f592a739d62fe04e5527e471ea1d0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="192d6846ace3aa19cd52dd4ee585f12a733bb1e7" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9283f303c0dddff0aeb96fe77630b3f0f7f1cd0" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="885613b30bdc3bb4e3fc4bfce7226fd3a4194313" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</source>
          <target state="translated">참고 자료 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5bbd33495175a536a093475520310921d8e80cb9" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;인덱스 열&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ac7994da54203d91b06af47c53b1f26548090ed" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;창 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5211947595082a78c56fd9fbfa97e9aa9db46e39" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ef3d4989ffca292fb408e36d6c80a0be05d38e3" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;order-term &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f754738e511b595c21699d1599455b2ad77e7ea" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;qualified-table-name&quot;&gt;Qualified-table-name &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10dff942ab951e8379beded21b97716b5a9470ac" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aead43f0300958c1d62f97ac7d9dbb7744c5f973" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;literal-value&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;filter-clause&quot;&gt;filter-clause &lt;/a&gt;&lt;a href=&quot;literal-value&quot;&gt;리터럴 값 &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;raise-function&quot;&gt;raise-function &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4a21a32ca632c80e791992375d683d3cb2b152e" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;join-operator&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;join-constraint&quot;&gt;join-constraint &lt;/a&gt;&lt;a href=&quot;join-operator&quot;&gt;join-operator &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eab2c400e1da9841def91aa5e9939c315ac03195" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ba25d3b7bd9b22c410033510c17375ba8fbc355" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1911821b127dd809d42d87c2ae5a010deb04e3f1" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;signed-number&quot;&gt;signed-number&lt;/a&gt;</source>
          <target state="translated">참고 문헌 : &lt;a href=&quot;signed-number&quot;&gt;부호있는 숫자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4105cc2bca5aa3561ea07c37d7a688f2cefa3733" translate="yes" xml:space="preserve">
          <source>References: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fee8a9d70903bab5247e1644ccd6676a4cf76b15" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the instrumented memory allocator is used, SQLite keeps track of how much memory is currently checked out. There are hundreds of test scripts used for testing SQLite. At the end of each script, all objects are destroyed and a test is made to ensure that all memory has been freed. This is how memory leaks are detected. Notice that memory leak detection is in force at all times, during test builds and during production builds. Whenever one of the developers runs any individual test script, memory leak detection is active. Hence memory leaks that do arise during development are quickly detected and fixed.</source>
          <target state="translated">인스트루먼트 된 메모리 할당 자의 사용 여부에 관계없이 SQLite는 현재 체크 아웃 된 메모리 양을 추적합니다. SQLite 테스트에 사용되는 수백 가지 테스트 스크립트가 있습니다. 각 스크립트의 끝에서 모든 오브젝트가 삭제되고 모든 메모리가 해제되었는지 테스트합니다. 메모리 누수가 감지되는 방식입니다. 테스트 빌드 중 및 프로덕션 빌드 중 항상 메모리 누수 감지가 적용됩니다. 개발자 중 한 명이 개별 테스트 스크립트를 실행할 때마다 메모리 누수 감지가 활성화됩니다. 따라서 개발 중에 발생하는 메모리 누수가 신속하게 감지되고 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae990d665eb1948d09faab80d8ea36e2fb369696" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">한도 변경 여부에 관계없이 &lt;a href=&quot;#sqlite3_limit&quot;&gt; sqlite3_limit ()&lt;/a&gt; 인터페이스는 한계의 이전 값을 리턴합니다. 따라서 한계를 변경하지 않고 현재 한계 값을 찾으려면 세 번째 매개 변수를 -1로 설정하여이 인터페이스를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="475dd8379b7144ac8a6fe852e876196470fc7208" translate="yes" xml:space="preserve">
          <source>Regardless of whether or not the limit was changed, the &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; interface returns the prior value of the limit. Hence, to find the current value of a limit without changing it, simply invoke this interface with the third parameter set to -1.</source>
          <target state="translated">한도 변경 여부에 관계없이 &lt;a href=&quot;limit&quot;&gt; sqlite3_limit ()&lt;/a&gt; 인터페이스는 한계의 이전 값을 리턴합니다. 따라서 한계를 변경하지 않고 현재 한계 값을 찾으려면 세 번째 매개 변수를 -1로 설정하여이 인터페이스를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e9e73aedbb554e1304705d3de0f39389c534343e" translate="yes" xml:space="preserve">
          <source>Regions for custom R*Tree queries are defined by R*Tree geometry callbacks implemented by the application and registered with SQLite via a call to one of the following two APIs:</source>
          <target state="translated">사용자 지정 R * Tree 쿼리의 리전은 응용 프로그램에서 구현하고 다음 두 API 중 하나에 대한 호출을 통해 SQLite에 등록 된 R * Tree 지오메트리 콜백에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="16168729e57b855923c7a71a802959676ea3a2be" translate="yes" xml:space="preserve">
          <source>Register A Callback To Handle SQLITE_BUSY Errors</source>
          <target state="translated">SQLITE_BUSY 오류를 처리하기위한 콜백 등록</target>
        </trans-unit>
        <trans-unit id="d7ada71741a5c5efe7fce5b9acb6e7cf75421e75" translate="yes" xml:space="preserve">
          <source>Register A Virtual Table Implementation</source>
          <target state="translated">가상 테이블 구현 등록</target>
        </trans-unit>
        <trans-unit id="958187253e4e67d26cfc6c57d03a7d486067c5db" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the content of register P1 is initially greater than zero, then decrement the value in register P1. If it is non-zero (negative or positive) and then also jump to P2. If register P1 is initially zero, leave it unchanged and fall through.</source>
          <target state="translated">레지스터 P1은 정수를 포함해야합니다. 레지스터 P1의 내용이 처음에 0보다 크면 레지스터 P1의 값을 줄입니다. 0이 아닌 경우 (음수 또는 양수) P2로 이동합니다. 레지스터 P1이 처음에 0이면 변경하지 않고 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="6fc7ce61728bc6135a810d1467e955ec5c18cca5" translate="yes" xml:space="preserve">
          <source>Register P1 must contain an integer. If the value of register P1 is 1 or greater, subtract P3 from the value in P1 and jump to P2.</source>
          <target state="translated">레지스터 P1은 정수를 포함해야합니다. 레지스터 P1의 값이 1 이상이면 P1의 값에서 P3을 빼고 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="d06710a36a9775573764357fb20e740182e291de" translate="yes" xml:space="preserve">
          <source>Register P1 must hold an integer. Decrement the value in P1 and jump to P2 if the new value is exactly zero.</source>
          <target state="translated">레지스터 P1은 정수를 보유해야합니다. 새 값이 정확히 0이면 P1의 값을 줄이고 P2로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="e5b942ab2eff4aada4b58db13bc65435ed431f02" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the index P1. Data for the entry is nil.</source>
          <target state="translated">레지스터 P2에는 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어를 사용하여 작성된 SQL 인덱스 키가 있습니다. 이 opcode는 해당 키를 인덱스 P1에 씁니다. 항목에 대한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="01732db42505a803a66049796c8bf94fe2cae34d" translate="yes" xml:space="preserve">
          <source>Register P2 holds an SQL index key made using the &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; instructions. This opcode writes that key into the sorter P1. Data for the entry is nil.</source>
          <target state="translated">레지스터 P2에는 &lt;a href=&quot;opcode#MakeRecord&quot;&gt;MakeRecord&lt;/a&gt; 명령어를 사용하여 작성된 SQL 인덱스 키가 있습니다. 이 opcode는 해당 키를 분류기 P1에 씁니다. 항목에 대한 데이터가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3d2ffa8c9852450209f632158a1e7073fb3dfaaa" translate="yes" xml:space="preserve">
          <source>Register P3 is assumed to hold a 64-bit integer value. If register P1 contains a RowSet object and that RowSet object contains the value held in P3, jump to register P2. Otherwise, insert the integer in P3 into the RowSet and continue on to the next opcode.</source>
          <target state="translated">레지스터 P3은 64 비트 정수 값을 보유한다고 가정합니다. 레지스터 P1에 RowSet 객체가 포함되어 있고 해당 RowSet 객체에 P3에 보유 된 값이 포함되어 있으면 레지스터 P2로 이동합니다. 그렇지 않으면 P3의 정수를 RowSet에 삽입하고 다음 opcode로 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb45c70cacf149749ff353ab480989cee1443045" translate="yes" xml:space="preserve">
          <source>Register P3 is the first of P4 registers that form an unpacked record.</source>
          <target state="translated">레지스터 P3은 압축 해제 된 레코드를 형성하는 첫 번째 P4 레지스터입니다.</target>
        </trans-unit>
        <trans-unit id="6b0d004c3926bf5b1daf83fe67dbd02805bbbe04" translate="yes" xml:space="preserve">
          <source>Register any required virtual table modules with the database handle returned by sqlite3rbu_db(X) (where argument X is the sqlite3rbu pointer returned from sqlite3rbu_open()). Also, if required, register the rbu_delta() SQL function using &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt;.</source>
          <target state="translated">sqlite3rbu_db (X)에 의해 리턴 된 데이터베이스 핸들로 필수 가상 테이블 모듈을 등록하십시오 (여기서 X는 sqlite3rbu_open ()에서 리턴 된 sqlite3rbu 포인터 임). 또한 필요한 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2 ()를&lt;/a&gt; 사용하여 rbu_delta () SQL 함수를 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b1ab59684ecdfa6e23d462a92936dce3e5d8ac7" translate="yes" xml:space="preserve">
          <source>Register the asynchronous IO VFS with SQLite by calling the sqlite3async_initialize() function.</source>
          <target state="translated">sqlite3async_initialize () 함수를 호출하여 SQLite에 비동기 IO VFS를 등록하십시오.</target>
        </trans-unit>
        <trans-unit id="89422a050ade616c86455a9e2dd6f33cb03ad894" translate="yes" xml:space="preserve">
          <source>Register your &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; structure using one of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 인터페이스 중 하나를 사용 하여 &lt;a href=&quot;c3ref/module&quot;&gt;sqlite3_module&lt;/a&gt; 구조를 등록하십시오 .</target>
        </trans-unit>
        <trans-unit id="27c9b460c397ef5be790575add8647f1cec36dca" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">등록 된 sqlite3_vfs 객체는 pNext 포인터로 구성된 링크 된 목록에 유지됩니다. &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 와 &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_unregister는 ()&lt;/a&gt; 인터페이스는 스레드 안전 방식으로이 목록을 관리 할 수 있습니다. &lt;a href=&quot;#sqlite3_vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 인터페이스 목록을 검색한다. 응용 프로그램 코드 나 VFS 구현 모두 pNext 포인터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="de4afbb05497a501a0da1ff3e255c9bea23038bf" translate="yes" xml:space="preserve">
          <source>Registered sqlite3_vfs objects are kept on a linked list formed by the pNext pointer. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt; and &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt; interfaces manage this list in a thread-safe way. The &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find()&lt;/a&gt; interface searches the list. Neither the application code nor the VFS implementation should use the pNext pointer.</source>
          <target state="translated">등록 된 sqlite3_vfs 객체는 pNext 포인터로 구성된 링크 된 목록에 유지됩니다. &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 와 &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_unregister는 ()&lt;/a&gt; 인터페이스는 스레드 안전 방식으로이 목록을 관리 할 수 있습니다. &lt;a href=&quot;vfs_find&quot;&gt;sqlite3_vfs_find ()&lt;/a&gt; 인터페이스 목록을 검색한다. 응용 프로그램 코드 나 VFS 구현 모두 pNext 포인터를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9a5c1b8d7536fe55fb50a507d2ffb4e2ef3d6e66" translate="yes" xml:space="preserve">
          <source>Registering a NULL function disables the callback.</source>
          <target state="translated">NULL 함수를 등록하면 콜백이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7e5b14172bb50385ea604b908cd56b4ced0181ef" translate="yes" xml:space="preserve">
          <source>Registering a new FTS tokenizer is similar to registering a new virtual table module with SQLite. The user passes a pointer to a structure containing pointers to various callback functions that make up the implementation of the new tokenizer type. For tokenizers, the structure (defined in fts3_tokenizer.h) is called &quot;sqlite3_tokenizer_module&quot;.</source>
          <target state="translated">새로운 FTS 토크 나이저를 등록하는 것은 SQLite에 새로운 가상 테이블 모듈을 등록하는 것과 유사합니다. 사용자는 새로운 토크 나이저 유형의 구현을 구성하는 다양한 콜백 함수에 대한 포인터를 포함하는 구조에 포인터를 전달합니다. 토크 나이저의 경우 (fts3_tokenizer.h에 정의 된) 구조를 &quot;sqlite3_tokenizer_module&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="b0c19399b5563dfe1fd2d9520239e189e1da88bf" translate="yes" xml:space="preserve">
          <source>Registers are numbered beginning with 0. Most opcodes refer to at least one register.</source>
          <target state="translated">레지스터는 0부터 시작하여 번호가 매겨집니다. 대부분의 opcode는 하나 이상의 레지스터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3416ca847c2f3fcac36ca80a6aa453bda2a4a879" translate="yes" xml:space="preserve">
          <source>Regression tests</source>
          <target state="translated">회귀 테스트</target>
        </trans-unit>
        <trans-unit id="d3a13cdc6fea5f8b0f17f86149a799a401cfa954" translate="yes" xml:space="preserve">
          <source>Reimplemented the memory allocation subsystem and made it replaceable at compile-time.</source>
          <target state="translated">메모리 할당 서브 시스템을 다시 구현하고 컴파일 타임에 교체 할 수있게했습니다.</target>
        </trans-unit>
        <trans-unit id="7c51b2c09a7ac00c32d5f5b60d5cc13c023b651f" translate="yes" xml:space="preserve">
          <source>Reinstate performance improvements that were added in &lt;a href=&quot;#version_3_3_14&quot;&gt;Version 3.3.14&lt;/a&gt; but regressed in &lt;a href=&quot;#version_3_3_15&quot;&gt;Version 3.3.15&lt;/a&gt;.</source>
          <target state="translated">에 추가 된 분석 재개 성능 개선 &lt;a href=&quot;#version_3_3_14&quot;&gt;버전 3.3.14&lt;/a&gt; 에 있지만 회귀 &lt;a href=&quot;#version_3_3_15&quot;&gt;버전 3.3.15&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3011dfada1ebc527f6c1a610c58b9f9d0286fe3f" translate="yes" xml:space="preserve">
          <source>Related to C-API requirements:</source>
          <target state="translated">C-API 요구 사항 관련 :</target>
        </trans-unit>
        <trans-unit id="4e090a454ee61aaf3f58e28631cff8999e93331b" translate="yes" xml:space="preserve">
          <source>Related to SQL requirements:</source>
          <target state="translated">SQL 요구 사항 관련 :</target>
        </trans-unit>
        <trans-unit id="3eb999525849eac11552ac3098daf2b69f5321b3" translate="yes" xml:space="preserve">
          <source>Related to file-format requirements:</source>
          <target state="translated">파일 형식 요구 사항과 관련 :</target>
        </trans-unit>
        <trans-unit id="8f24d23adbf6898f82e865e9f816b7bd6e3ba106" translate="yes" xml:space="preserve">
          <source>Relational database engines act as bandwidth-reducing data filters. So it is best to keep the database engine and the data on the same physical device so that the high-bandwidth engine-to-disk link does not have to traverse the network, only the lower-bandwidth application-to-engine link.</source>
          <target state="translated">관계형 데이터베이스 엔진은 대역폭 감소 데이터 필터 역할을합니다. 따라서 데이터베이스 엔진과 데이터를 동일한 물리적 장치에 유지하여 고 대역폭 엔진 대 디스크 링크가 네트워크를 통과 할 필요가없고 저 대역폭 응용 프로그램 대 엔진 링크 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="720fa9e6ba7dd17be077bf0b4c2393be699b32bc" translate="yes" xml:space="preserve">
          <source>Relationship to Other Documents</source>
          <target state="translated">다른 문서와의 관계</target>
        </trans-unit>
        <trans-unit id="910fe0ebb846d769acb1f768f3b350b52b7c87fa" translate="yes" xml:space="preserve">
          <source>Relax the SQL statement length restriction in the CLI so that the &quot;.dump&quot; output of databases with very large BLOBs and strings can be played back to recreate the database.</source>
          <target state="translated">BLOB 및 문자열이 매우 큰 데이터베이스의 &quot;.dump&quot;출력을 재생하여 데이터베이스를 다시 만들 수 있도록 CLI에서 SQL 문 길이 제한을 완화하십시오.</target>
        </trans-unit>
        <trans-unit id="d41f56cea1ac933d25c57aebc6522e2b6c58eb87" translate="yes" xml:space="preserve">
          <source>Release</source>
          <target state="translated">Release</target>
        </trans-unit>
        <trans-unit id="3f453891a8b048016ad785ded9267d527fc4c217" translate="yes" xml:space="preserve">
          <source>Release History</source>
          <target state="translated">출시 역사</target>
        </trans-unit>
        <trans-unit id="b5d6e335495f80d39d703350d3e97ffdb93dd6dd" translate="yes" xml:space="preserve">
          <source>Release History Of SQLite</source>
          <target state="translated">SQLite의 출시 역사</target>
        </trans-unit>
        <trans-unit id="059948eaf49ab1f91af7a1724f1325548609c407" translate="yes" xml:space="preserve">
          <source>Release registers from service. Any content that was in the the registers is unreliable after this opcode completes.</source>
          <target state="translated">서비스에서 레지스터를 해제합니다. 이 opcode가 완료된 후에는 레지스터에 있던 모든 콘텐츠를 신뢰할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f91d8788ccb8580c59f2957385adedb96f9eebdb" translate="yes" xml:space="preserve">
          <source>Release testing proceeds by &lt;a href=&quot;testing#cklist&quot;&gt;checklist&lt;/a&gt;. The current status and complete change history for each checklist is stored in a separate SQLite database file. These files are not version controlled, but separate copies are maintained on private backup servers.</source>
          <target state="translated">&lt;a href=&quot;testing#cklist&quot;&gt;체크리스트&lt;/a&gt; 로 릴리스 테스트 진행 . 각 점검 목록의 현재 상태 및 전체 변경 내역은 별도의 SQLite 데이터베이스 파일에 저장됩니다. 이러한 파일은 버전이 제어되지 않지만 개인 백업 서버에서 별도의 사본이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d39cd2c52497ee84030ad057906e4ab9e12677f2" translate="yes" xml:space="preserve">
          <source>ReleaseReg</source>
          <target state="translated">ReleaseReg</target>
        </trans-unit>
        <trans-unit id="68bd446f9608234bde9262049ecc13307a217604" translate="yes" xml:space="preserve">
          <source>Releases the mutex.</source>
          <target state="translated">뮤텍스를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="093e4161a9fbb2d3df1b7e1618ac6472d6ffad88" translate="yes" xml:space="preserve">
          <source>Releasing a register clears the Mem.pScopyFrom pointer. That means that if the content of the released register was set using &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt;, a change to the value of the source register for the &lt;a href=&quot;opcode#SCopy&quot;&gt;SCopy&lt;/a&gt; will no longer generate an assertion fault in sqlite3VdbeMemAboutToChange().</source>
          <target state="translated">레지스터를 해제하면 Mem.pScopyFrom 포인터가 지워집니다. 즉, 그 방출 된 레지스터의 콘텐츠를 사용하여 설정 되었다면 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCOPY&lt;/a&gt; 상기의 소스 레지스터의 값의 변경 &lt;a href=&quot;opcode#SCopy&quot;&gt;SCOPY를&lt;/a&gt; 더 sqlite3VdbeMemAboutToChange 어설 오류를 발생시키지 것이다 ().</target>
        </trans-unit>
        <trans-unit id="9e7fb42133185287484ac33cdd16d16a32e9573a" translate="yes" xml:space="preserve">
          <source>Relieve the poor.</source>
          <target state="translated">가난한 사람들을 구하십시오.</target>
        </trans-unit>
        <trans-unit id="c129618e6f09666fc71019f6f11ca49c584723bd" translate="yes" xml:space="preserve">
          <source>Relinquish the shared lock on the database file obtained in step 1.</source>
          <target state="translated">1 단계에서 얻은 데이터베이스 파일에서 공유 잠금을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="c20a1017faea096d3f06199fd35a9c0037bfb227" translate="yes" xml:space="preserve">
          <source>Remainder</source>
          <target state="translated">Remainder</target>
        </trans-unit>
        <trans-unit id="d7020f448aaf8aacc8b4d63537e375e865fff9d8" translate="yes" xml:space="preserve">
          <source>Remarks</source>
          <target state="translated">Remarks</target>
        </trans-unit>
        <trans-unit id="f818b7fc01e1b4eb78ea0d60ac974d5efb37d086" translate="yes" xml:space="preserve">
          <source>Remember that every table (except sqlite_master) and every named index has an entry in the sqlite_master table. Since we are creating a new index, we have to add a new entry to sqlite_master. This is handled by instructions 3 through 15. Adding an entry to sqlite_master works just like any other INSERT statement so we will not say any more about it here. In this example, we want to focus on populating the new index with valid data, which happens on instructions 16 through 23.</source>
          <target state="translated">모든 테이블 (sqlite_master 제외)과 모든 명명 된 인덱스에는 sqlite_master 테이블에 항목이 있습니다. 새로운 인덱스를 생성하고 있기 때문에 sqlite_master에 새로운 엔트리를 추가해야합니다. sqlite_master에 항목을 추가하면 다른 INSERT 문과 동일하게 작동하므로 여기서 더 이상 언급하지 않습니다. 이 예에서는 명령 16에서 23까지 발생하는 유효한 데이터로 새 인덱스를 채우는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="69897e6a01044562fef92617e584bcaf82e348ea" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">opcode의 이름과 의미는 종종 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. 당신은 공부하는 경우에 따라서 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; SQLite는의 출력을, 당신은 실행 한 SQLite는 버전이 문서의 버전 (또는 vdbe.c 소스 코드) 것을 대응을 참조해야합니다 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; . 그렇지 않으면 opcode에 대한 설명이 정확하지 않을 수 있습니다. 이 문서는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;2019-10-10&lt;/a&gt; 날짜의 SQLite 버전 3.30.1 체크인 18db032d058f1 에서 파생 되었습니다.</target>
        </trans-unit>
        <trans-unit id="f553d13a1a4a6a005164fe968cc587aaf66e9b40" translate="yes" xml:space="preserve">
          <source>Remember that the names and meanings of opcodes often change from one release of SQLite to the next. So if you are studying the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output from SQLite, you should reference the version of this document (or the vdbe.c source code) that corresponds to the version of SQLite that ran the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;. Otherwise, the description of the opcodes may not be accurate. This document is derived from SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="translated">opcode의 이름과 의미는 SQLite의 한 릴리스에서 다음 릴리스로 변경되는 경우가 많습니다. 당신은 공부하는 경우에 따라서 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; SQLite는의 출력을, 당신은 실행 한 SQLite는 버전이 문서의 버전 (또는 vdbe.c 소스 코드)에 that 대응을 참조한다 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; . 그렇지 않으면 opcode의 설명이 정확하지 않을 수 있습니다. 이 문서는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;2020-08-14&lt;/a&gt; 날짜의 SQLite 버전 3.33.0 체크인 fca8dc8b578f2 에서 파생 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6eb5f044eeebb740c044069cc0a1760dfcfed869" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_master WHERE tbl_name='X'.</source>
          <target state="translated">표 X와 관련된 모든 인덱스, 트리거 및보기의 형식을 기억하십시오.이 정보는 아래 8 단계에서 필요합니다. 이를 수행하는 한 가지 방법은 다음과 같은 조회를 실행하는 것입니다. SELECT type, sql FROM sqlite_master WHERE tbl_name = 'X'.</target>
        </trans-unit>
        <trans-unit id="96ba241fe10cc7a94246b3ba48e08be55ea73559" translate="yes" xml:space="preserve">
          <source>Remember the format of all indexes, triggers, and views associated with table X. This information will be needed in step 8 below. One way to do this is to run a query like the following: SELECT type, sql FROM sqlite_schema WHERE tbl_name='X'.</source>
          <target state="translated">테이블 X와 연관된 모든 인덱스, 트리거 및보기의 형식을 기억하십시오.이 정보는 아래 8 단계에서 필요합니다. 이를 수행하는 한 가지 방법은 SELECT type, sql FROM sqlite_schema WHERE tbl_name = 'X'와 같은 쿼리를 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7697dd70c220c16d6cd40cffcf6ebbe938ec6d8c" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.30.1 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;18db032d058f1&lt;/a&gt; dated 2019-10-10.</source>
          <target state="translated">기억하십시오 : VDBE opcode는 SQLite에 대한 인터페이스 정의의 일부 가 &lt;u&gt;아닙니다&lt;/u&gt; . opcode의 수와 이름 및 의미는 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. 아래 표에 표시된 opcode는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=18db032d058f1&quot;&gt;2019-10-10&lt;/a&gt; 날짜의 SQLite 버전 3.30.1 체크인 18db032d058f1에 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="0cf1bdb8435fa5c7b1a229b2efb579581c575742" translate="yes" xml:space="preserve">
          <source>Remember: The VDBE opcodes are &lt;u&gt;not&lt;/u&gt; part of the interface definition for SQLite. The number of opcodes and their names and meanings change from one release of SQLite to the next. The opcodes shown in the table below are valid for SQLite version 3.33.0 check-in &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;fca8dc8b578f2&lt;/a&gt; dated 2020-08-14.</source>
          <target state="translated">기억하세요 : VDBE opcode는 SQLite에 대한 인터페이스 정의의 일부 가 &lt;u&gt;아닙니다&lt;/u&gt; . opcode의 수와 그 이름과 의미는 SQLite의 한 릴리스에서 다음 릴리스로 변경됩니다. 아래 표에 표시된 opcode는 &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=fca8dc8b578f2&quot;&gt;2020-08-14&lt;/a&gt; 날짜의 SQLite 버전 3.33.0 체크인 fca8dc8b578f2에 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="ad8914d260e2d26c0f65a1244263c5ebd74ffa40" translate="yes" xml:space="preserve">
          <source>Removals occurs sequentially from left to right. Changes caused by prior removals can affect the path search for subsequent arguments.</source>
          <target state="translated">제거는 왼쪽에서 오른쪽으로 순차적으로 발생합니다. 이전 제거로 인한 변경은 후속 인수의 경로 검색에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="911efbaa270338e46274d0437cfd895711d3b921" translate="yes" xml:space="preserve">
          <source>Remove Unnecessary Virtual Table Implementations</source>
          <target state="translated">불필요한 가상 테이블 구현 제거</target>
        </trans-unit>
        <trans-unit id="e2ba27377e47e450dcae92850eed494633ee561a" translate="yes" xml:space="preserve">
          <source>Remove a call to rand_s() in the Windows VFS since it was causing problems in Firefox on some older laptops.</source>
          <target state="translated">일부 구형 랩톱에서는 Firefox에서 문제를 일으켰으므로 Windows VFS에서 rand_s ()에 대한 호출을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="de2c1add2fd3544da9609574c31dec164859c5a6" translate="yes" xml:space="preserve">
          <source>Remove a surplus semicolon that was causing problems for older versions of MSVC.</source>
          <target state="translated">이전 버전의 MSVC에서 문제를 일으킨 잉여 세미콜론을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d1a5392ba748cb8c4dacc7b44e730fc30161dbb4" translate="yes" xml:space="preserve">
          <source>Remove all instances of sprintf() from the code</source>
          <target state="translated">코드에서 sprintf ()의 모든 인스턴스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="a7347e37ad5bb38746524ddb0e6ffca369e7fc25" translate="yes" xml:space="preserve">
          <source>Remove all uses of umask() in the unix VFS.</source>
          <target state="translated">유닉스 VFS에서 umask () 사용을 모두 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e9a7875d6c4fd8a037f45ad1e5ae66d9676a5804" translate="yes" xml:space="preserve">
          <source>Remove cruft from the APIs.</source>
          <target state="translated">API에서 cruft를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="1b6d6e3634ac9d3666b932168ce6ff89f16adfc2" translate="yes" xml:space="preserve">
          <source>Remove limits on the magnitude of precision and width value in the format specifiers of the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; family of string rendering routines.</source>
          <target state="translated">&lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 문자열 렌더링 루틴 패밀리의 형식 지정자에서 정밀도 및 너비 값의 크기에 대한 제한을 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="232f2fe0e5dd49ef4b04602d08b8943e14a7d142" translate="yes" xml:space="preserve">
          <source>Remove some C++ style comments from btree.c so that it will compile using compilers other than gcc.</source>
          <target state="translated">btree.c에서 일부 C ++ 스타일 주석을 제거하여 gcc 이외의 컴파일러를 사용하여 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="f2e07b9153ec780a2a1b29629bb1d3f64a20239f" translate="yes" xml:space="preserve">
          <source>Remove the &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL variable that was introduced in the previous version.</source>
          <target state="translated">이전 버전에서 도입 된 &lt;b&gt;sqlite_encoding&lt;/b&gt; TCL 변수를 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="2b21568b3fad30533d945c9f60e6bb04786d29af" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the index named P4 in database P1. This is called after an index is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">데이터베이스 P1에서 이름이 P4 인 인덱스를 설명하는 내부 (메모리 내) 데이터 구조를 제거하십시오. 스키마의 내부 표현을 디스크에있는 것과 일관되게 유지하기 위해 디스크에서 색인을 삭제 ( &lt;a href=&quot;opcode#Destroy&quot;&gt;파괴&lt;/a&gt; opcode 사용) 한 후에 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="36574b14e4fba42639d51b715dd56510bbbe9bbe" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the table named P4 in database P1. This is called after a table is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">데이터베이스 P1에서 이름이 P4 인 테이블을 설명하는 내부 (메모리 내) 데이터 구조를 제거하십시오. 디스크에서 테이블을 삭제 한 후에 호출됩니다 ( &lt;a href=&quot;opcode#Destroy&quot;&gt;파괴를&lt;/a&gt; 사용하여).스키마의 내부 표현을 디스크에있는 것과 일관되게 유지하기 위해 opcode 됩니다.</target>
        </trans-unit>
        <trans-unit id="a2ee755d70dfde8b6acc7bc963a2c09e0d856e3d" translate="yes" xml:space="preserve">
          <source>Remove the internal (in-memory) data structures that describe the trigger named P4 in database P1. This is called after a trigger is dropped from disk (using the &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode) in order to keep the internal representation of the schema consistent with what is on disk.</source>
          <target state="translated">데이터베이스 P1에서 이름이 P4 인 트리거를 설명하는 내부 (메모리 내) 데이터 구조를 제거하십시오. 디스크의 내용과 일치하도록 스키마의 내부 표현을 유지하기 위해 디스크에서 트리거가 삭제 된 후 ( &lt;a href=&quot;opcode#Destroy&quot;&gt;Destroy&lt;/a&gt; opcode 사용) 호출 됩니다.</target>
        </trans-unit>
        <trans-unit id="4bdb98bb814d00a40fac7a5bc5a53816ed8a4fe3" translate="yes" xml:space="preserve">
          <source>Remove the limit (formerly 100) on the number of terms in the WHERE clause</source>
          <target state="translated">WHERE 절의 용어 수에 대한 한계 (이전 100)를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6c2cfa3751933f72373c8446091ad7cbfc829e90" translate="yes" xml:space="preserve">
          <source>Remove the rarely-used &quot;scratch&quot; memory allocator. Replace it with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt; configuration setting that gives SQLite a hint that large memory allocations should be avoided when possible.</source>
          <target state="translated">거의 사용하지 않는 &quot;스크래치&quot;메모리 할당자를 제거하십시오. 로 교체 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsmallmalloc&quot;&gt;SQLITE_CONFIG_SMALL_MALLOC&lt;/a&gt;SQLite에 가능한 많은 메모리 할당을 피해야한다는 힌트를 제공 구성 설정으로 십시오.</target>
        </trans-unit>
        <trans-unit id="f76d7af1679885a7bfe9d24b6ffde8997604493f" translate="yes" xml:space="preserve">
          <source>Remove the restriction on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; and &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;. Virtual tables and shared cache can now be used at the same time.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에 대한 제한을 제거하십시오 . 가상 테이블과 공유 캐시를 동시에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f161850d96f27ed56876982a84f7c1b8a07321a" translate="yes" xml:space="preserve">
          <source>Remove the use of strcasecmp() from the shell</source>
          <target state="translated">쉘에서 strcasecmp () 사용을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="b82adca5a3d606350246be926940c7079f564580" translate="yes" xml:space="preserve">
          <source>Removed a few variables that were not being used. Etc.</source>
          <target state="translated">사용되지 않은 몇 가지 변수를 제거했습니다. 기타.</target>
        </trans-unit>
        <trans-unit id="ce23c20d6612496d01f2695dbdf3e159dffac5f1" translate="yes" xml:space="preserve">
          <source>Removed all instances of sprintf() and strcpy() from the core library.</source>
          <target state="translated">코어 라이브러리에서 sprintf () 및 strcpy ()의 모든 인스턴스를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="1cae4989947b35c7db5ba36e62fdeec64147115e" translate="yes" xml:space="preserve">
          <source>Removed encode.c file (containing unused routines) from the version 3.0 source tree.</source>
          <target state="translated">버전 3.0 소스 트리에서 encode.c 파일 (사용되지 않은 루틴 포함)을 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="57859e1d20dcbe4d104c0ddc713636157aa93b7b" translate="yes" xml:space="preserve">
          <source>Removed some unused &quot;#include</source>
          <target state="translated">사용하지 않는 일부 &quot;#include를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="8d2a9960e30e515570aed5ad791fda0cf2ff5231" translate="yes" xml:space="preserve">
          <source>Removed support for &lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt;, replacing it with the much more capable &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3&lt;/a&gt; option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat2&quot;&gt;SQLITE_ENABLE_STAT2&lt;/a&gt; 지원을 제거 하여 훨씬 더 유능한 &lt;a href=&quot;compile#enable_stat3&quot;&gt;SQLITE_ENABLE_STAT3으로 대체&lt;/a&gt; 옵션으로 .</target>
        </trans-unit>
        <trans-unit id="65be623270aae4b13c60984d581079005860c71c" translate="yes" xml:space="preserve">
          <source>Removed support for an ON CONFLICT clause on CREATE INDEX - it never worked correctly so this should not present any backward compatibility problems.</source>
          <target state="translated">CREATE INDEX에서 ON CONFLICT 절에 대한 지원이 제거되었습니다. 제대로 작동하지 않으므로 이전 버전과의 호환성 문제가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba2329a69fcada7cfc55496da4a2c7aa1027255b" translate="yes" xml:space="preserve">
          <source>Removed support for the Oracle8 outer join syntax.</source>
          <target state="translated">Oracle8 외부 조인 구문에 대한 지원이 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="29a877d4bc4a615404fe28f15ef25cea333f3dfb" translate="yes" xml:space="preserve">
          <source>Removed the experimental sqlite_open_aux_file(). Its function is subsumed in the new ATTACH command.</source>
          <target state="translated">실험적인 sqlite_open_aux_file ()을 제거했습니다. 이 기능은 새로운 ATTACH 명령에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d84a5c2bd6c237fcc154859882d3b6c252699015" translate="yes" xml:space="preserve">
          <source>Removed the vestigal SQLITE_PROTOCOL error.</source>
          <target state="translated">vestigal SQLITE_PROTOCOL 오류를 제거했습니다.</target>
        </trans-unit>
        <trans-unit id="eace5c7b4ff6a4702d4283d3160c8d68a2dcede9" translate="yes" xml:space="preserve">
          <source>Rename column</source>
          <target state="translated">열 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="23dbd5b69dca406be177f26a10ac454eda104e75" translate="yes" xml:space="preserve">
          <source>Rename new into old</source>
          <target state="translated">새로운 이름을 오래된 것으로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="5bd4049b4d784a22b055fc8e5f3c3684061c5d9c" translate="yes" xml:space="preserve">
          <source>Rename old table</source>
          <target state="translated">이전 테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="c9a739b6bb3de7aee85aef1cd51db485f31caf22" translate="yes" xml:space="preserve">
          <source>Rename table</source>
          <target state="translated">테이블 이름 바꾸기</target>
        </trans-unit>
        <trans-unit id="a6f163085aea45df98f42b1c1ebd60597433d37a" translate="yes" xml:space="preserve">
          <source>Rename the &lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt; compile-time option to &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; to better reflect the implications of using it.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_builtin_test&quot;&gt;SQLITE_OMIT_BUILTIN_TEST&lt;/a&gt; 컴파일 타임 옵션의 이름 을 &lt;a href=&quot;compile#untestable&quot;&gt;SQLITE_UNTESTABLE&lt;/a&gt; 로 바꾸어 사용의 의미를 더 잘 반영하십시오.</target>
        </trans-unit>
        <trans-unit id="be5b8fd29874b31a75967598563d2c598ed8c802" translate="yes" xml:space="preserve">
          <source>Render expressions of the form &quot;x IN (?)&quot; (with a single value in the list on the right-hand side of the IN operator) as if they where &quot;x==?&quot;, Similarly optimize &quot;x NOT IN (?)&quot;</source>
          <target state="translated">마치 &quot;x ==?&quot;인 것처럼 &quot;x IN (?)&quot;형식 (IN 연산자의 오른쪽에있는 목록에 단일 값이있는)의 식을 렌더링합니다. 마찬가지로 &quot;x NOT IN (? ) &quot;</target>
        </trans-unit>
        <trans-unit id="88333a43b7fd427d0516f0a5d5107e5f54e545df" translate="yes" xml:space="preserve">
          <source>ReopenIdx</source>
          <target state="translated">ReopenIdx</target>
        </trans-unit>
        <trans-unit id="7c28d43c9fc88003b6477ed308834ef4aec930a4" translate="yes" xml:space="preserve">
          <source>Reorganize the Unix interface in os_unix.c</source>
          <target state="translated">os_unix.c에서 유닉스 인터페이스 재구성</target>
        </trans-unit>
        <trans-unit id="4b096fbd5cf8040410b520d0087755f15a4e4623" translate="yes" xml:space="preserve">
          <source>Repeatedly switching an SQLite database in and out of &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; and running the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command in between switches, in one process or thread, can cause another process or thread that has the database file open to miss the fact that the database has changed. That second process or thread might then try to modify the database using a stale cache and cause database corruption.</source>
          <target state="translated">하나의 프로세스 또는 스레드 에서 SQLite 데이터베이스를 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 안팎으로 반복적으로 전환하고 스위치간에 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 실행 하면 데이터베이스 파일이 열려있는 다른 프로세스 또는 스레드가 데이터베이스가 변경되었다는 사실을 놓칠 수 있습니다. 그런 다음 두 번째 프로세스 또는 스레드가 오래된 캐시를 사용하여 데이터베이스를 수정하려고 시도하여 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08d1902d969043d4f5ff76c612c66edc344a58a0" translate="yes" xml:space="preserve">
          <source>Replace the built-in mutex subsystem with an alternative implementation.</source>
          <target state="translated">내장 mutex 서브 시스템을 대체 구현으로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="6fd04b040e5c22cd85b1871575a876977a443534" translate="yes" xml:space="preserve">
          <source>Replace the interface to the file system with an alternative design. In other words, override all of the system calls that SQLite makes in order to talk to the disk with a completely different set of system calls.</source>
          <target state="translated">대체 설계로 파일 시스템에 대한 인터페이스를 교체하십시오. 다시 말해, 완전히 다른 시스템 호출 세트로 디스크와 통신하기 위해 SQLite가 만드는 모든 시스템 호출을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="8a67a8b071dbf97af58f9f8fc030dc4129a982a5" translate="yes" xml:space="preserve">
          <source>Report an error if an ORDER BY or GROUP BY expression is constant.</source>
          <target state="translated">ORDER BY 또는 GROUP BY 표현식이 상수 인 경우 오류를보고하십시오.</target>
        </trans-unit>
        <trans-unit id="5382d03ec82f0e424f0e2bcd884c37beaa553f16" translate="yes" xml:space="preserve">
          <source>Report rollback recovery in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; as SQLITE_NOTICE_RECOVER_ROLLBACK. Change the error log code for WAL recover from SQLITE_OK to SQLITE_NOTICE_RECOVER_WAL.</source>
          <target state="translated">&lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에서 롤백 복구 를 SQLITE_NOTICE_RECOVER_ROLLBACK으로보고하십시오. WAL 복구에 대한 오류 로그 코드를 SQLITE_OK에서 SQLITE_NOTICE_RECOVER_WAL로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2a209e68ce6d7ef5cbfce6e23fd387511ef2796d" translate="yes" xml:space="preserve">
          <source>Report the name of specific &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; constraints that fail.</source>
          <target state="translated">실패한 특정 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK&lt;/a&gt; 제약 조건 의 이름을보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="1b12d49166f15edffd3aeb0179e7e1787f48ce27" translate="yes" xml:space="preserve">
          <source>Report the risky uses of &lt;a href=&quot;howtocorrupt#unlink&quot;&gt;unlinked database files&lt;/a&gt; and &lt;a href=&quot;howtocorrupt#alias&quot;&gt;database filename aliasing&lt;/a&gt; as SQLITE_WARNING messages in the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;howtocorrupt#unlink&quot;&gt;연결되지 않은 데이터베이스 파일&lt;/a&gt; 과 &lt;a href=&quot;howtocorrupt#alias&quot;&gt;데이터베이스 파일 이름 별칭&lt;/a&gt; 의 위험한 사용을 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 에 SQLITE_WARNING 메시지로보고하십시오 .</target>
        </trans-unit>
        <trans-unit id="a328f2c4ddffb4f007ee170c822e792cbe7ac2bd" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than or equal to the key value. If there are no records less than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">커서 P1을 키 값보다 작거나 같은 가장 큰 항목을 가리 키도록 위치를 조정하십시오. 키보다 작거나 같은 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="3135b4b4b6f2ab789efbcd1b22f24612c3f91745" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the largest entry that is less than the key value. If there are no records less than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">커서 P1이 키 값보다 작은 최대 항목을 가리 키도록 위치를 조정하십시오. 키보다 작은 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="0ecdc43c68575ffe0f6b403b40297cdd23849385" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than or equal to the key value. If there are no records greater than or equal to the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">키 P보다 크거나 같은 가장 작은 항목을 가리 키도록 커서 P1을 재배치하십시오. 키보다 크거나 같은 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="12d5076757ddc1b93a63854acae2fbdea1746c5f" translate="yes" xml:space="preserve">
          <source>Reposition cursor P1 so that it points to the smallest entry that is greater than the key value. If there are no records greater than the key and P2 is not zero, then jump to P2.</source>
          <target state="translated">커서 P1이 키 값보다 큰 가장 작은 항목을 가리 키도록 위치를 조정하십시오. 키보다 큰 레코드가없고 P2가 0이 아닌 경우 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="c029db81bd8f30ac7ba33c5eb9c17a5ae29866f1" translate="yes" xml:space="preserve">
          <source>Represent a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP Archive&lt;/a&gt; as an SQL table. Works for both reading and writing. Used by the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to implement the ability to read and write ZIP Archives.</source>
          <target state="translated">대표 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP 아카이브&lt;/a&gt; SQL 테이블 등을. 읽기와 쓰기 모두에 효과적입니다. ZIP 아카이브를 읽고 쓰는 기능을 구현하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에서 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="bf10d00bc3da2452de6c68f43ec52e620c1a7872" translate="yes" xml:space="preserve">
          <source>Representation is the essence of computer programming.</source>
          <target state="translated">대표는 컴퓨터 프로그래밍의 본질입니다.</target>
        </trans-unit>
        <trans-unit id="1d9b3293e88caaa716c1a885e5b50e65b2bb3b2a" translate="yes" xml:space="preserve">
          <source>Represents the global variables of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCL Interpreter&lt;/a&gt; as an SQL table. Used as part of the SQLite test suite.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Tcl&quot;&gt;TCL 인터프리터&lt;/a&gt; 의 글로벌 변수를 SQL 테이블로 나타냅니다. SQLite 테스트 스위트의 일부로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26bf60fed3744bb0049608ff95380b842c473a6" translate="yes" xml:space="preserve">
          <source>Requested</source>
          <target state="translated">Requested</target>
        </trans-unit>
        <trans-unit id="dbbf6c568082dd9fe7decc89c41aaaa504df8ded" translate="yes" xml:space="preserve">
          <source>Requirement H35050 (section</source>
          <target state="translated">요구 사항 H35050 (섹션</target>
        </trans-unit>
        <trans-unit id="4e1bcb3ced4612d53be234208553c503d16c2746" translate="yes" xml:space="preserve">
          <source>Requirements describing how a</source>
          <target state="translated">방법을 설명하는 요구 사항</target>
        </trans-unit>
        <trans-unit id="5472f074118e0fcc2fcc663b98dfc71e267df752" translate="yes" xml:space="preserve">
          <source>Requirements describing step 1 of the above procedure in detail:</source>
          <target state="translated">위 절차의 1 단계를 자세히 설명하는 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="fad7011bc39debdd3199704eacbe43fe1a48d858" translate="yes" xml:space="preserve">
          <source>Requirements describing step 2 of the above procedure in detail:</source>
          <target state="translated">위 절차의 2 단계를 자세히 설명하는 요구 사항 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
