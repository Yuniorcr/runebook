<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="d9994f198ea8554c8d135ebfa9e7a42a508d9f76" translate="yes" xml:space="preserve">
          <source>Add new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bindptr&quot;&gt;인터페이스를 전달하는&lt;/a&gt; 새 포인터를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c37dbbd1aba851a9c8e067c055285579f7ba5410" translate="yes" xml:space="preserve">
          <source>Add new verbs to &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; so that the &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; method of virtual tables can declare the virtual table as &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; or &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt;.</source>
          <target state="translated">가상 테이블 의 &lt;a href=&quot;vtab#xconnect&quot;&gt;xConnect&lt;/a&gt; 메서드가 가상 테이블을 &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabinnocuous&quot;&gt;SQLITE_VTAB_INNOCUOUS&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/c_vtab_constraint_support#sqlitevtabdirectonly&quot;&gt;SQLITE_VTAB_DIRECTONLY&lt;/a&gt; 로 선언 할 수 있도록 &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config ()에&lt;/a&gt; 새 동사를 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="7e6207d3440089bac343c8fc43288997a2214b79" translate="yes" xml:space="preserve">
          <source>Add option support for LIMIT and ORDER BY clauses on &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements. Only works if SQLite is compiled with &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 에서 LIMIT 및 ORDER BY 절에 대한 옵션 지원을 추가하십시오 . SQLite가 &lt;a href=&quot;compile#enable_update_delete_limit&quot;&gt;SQLITE_ENABLE_UPDATE_DELETE_LIMIT&lt;/a&gt; 로 컴파일 된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="efbdccfa6f84dcf86953bb91270d5a08c92376ba" translate="yes" xml:space="preserve">
          <source>Add options &quot;--expanded&quot;, &quot;--normalized&quot;, &quot;--plain&quot;, &quot;--profile&quot;, &quot;--row&quot;, &quot;--stmt&quot;, and &quot;--close&quot; to the &quot;.trace&quot; command.</source>
          <target state="translated">&quot;.expanded&quot;, &quot;--normalized&quot;, &quot;--plain&quot;, &quot;--profile&quot;, &quot;--row&quot;, &quot;--stmt&quot;및 &quot;--close&quot;옵션을 &quot;.trace&quot;에 추가하십시오. 명령.</target>
        </trans-unit>
        <trans-unit id="4cbca09144fd7e3e8b43bc8c2d286fd40deac6d2" translate="yes" xml:space="preserve">
          <source>Add options &lt;b&gt;-encoding&lt;/b&gt; and &lt;b&gt;-tcl-uses-utf&lt;/b&gt; to the &lt;b&gt;sqlite&lt;/b&gt; TCL command.</source>
          <target state="translated">옵션 추가 &lt;b&gt;-encoding&lt;/b&gt; 및 &lt;b&gt;-tcl - 사용 - UTF&lt;/b&gt; 받는 &lt;b&gt;SQLite는&lt;/b&gt; TCL 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0c2f37fd7facad2de96bd5183bac5e1e1511c68e" translate="yes" xml:space="preserve">
          <source>Add options to the &lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; command: --csv, --ascii, --skip</source>
          <target state="translated">&lt;a href=&quot;cli#csv&quot;&gt;.import&lt;/a&gt; 명령에 옵션 추가 : --csv, --ascii, --skip</target>
        </trans-unit>
        <trans-unit id="d573825baf33d38c179e029681eca20a46ccd519" translate="yes" xml:space="preserve">
          <source>Add pluggable tokenizers and &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU&lt;/a&gt; tokenization support to FTS2</source>
          <target state="translated">FTS2에 플러그 가능 토크 나이저 및 &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU&lt;/a&gt; 토큰 화 지원 추가</target>
        </trans-unit>
        <trans-unit id="72c6bdab5b3258b6277e55104bb87d93b720f14a" translate="yes" xml:space="preserve">
          <source>Add support for &quot;.open --hexdb&quot;. The &quot;&lt;a href=&quot;https://sqlite.org/src/doc/trunk/tool/dbtotxt.md&quot;&gt;dbtotxt&lt;/a&gt;&quot; utility program used to generate the text for the &quot;hexdb&quot; is added to the source tree.</source>
          <target state="translated">&quot;.open --hexdb&quot;에 대한 지원을 추가하십시오. &quot; &lt;a href=&quot;https://sqlite.org/src/doc/trunk/tool/dbtotxt.md&quot;&gt;hexdb&lt;/a&gt; &quot;에 대한 텍스트를 생성하는 데 사용되는 &quot; dbtotxt &quot;유틸리티 프로그램이 소스 트리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a0763ade3c8a449006c413b6f49449ce7b3a928a" translate="yes" xml:space="preserve">
          <source>Add support for &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; PRECEDING&lt;/a&gt;&quot; and &quot;&lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;expr&amp;gt; FOLLOWING&lt;/a&gt;&quot; boundaries in RANGE &lt;a href=&quot;windowfunctions#framespec&quot;&gt;frames&lt;/a&gt;.</source>
          <target state="translated">&quot;에 대한 지원을 추가 &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;&amp;lt;EXPR&amp;gt; PRECEDING&lt;/a&gt; &quot; &quot;를 &lt;a href=&quot;windowfunctions#exprrange&quot;&gt;파악하기 &amp;lt;EXPR&amp;gt;&lt;/a&gt; RANGE의에서 경계&quot; &lt;a href=&quot;windowfunctions#framespec&quot;&gt;프레임&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e92f21bcec77d71c0f65f3070792505ed0c70690" translate="yes" xml:space="preserve">
          <source>Add support for &quot;PRAGMA page_size&quot; to adjust the page size of the database.</source>
          <target state="translated">&quot;PRAGMA page_size&quot;에 대한 지원을 추가하여 데이터베이스의 페이지 크기를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="aa2fb3ed1f060dfe837a3d960578d49b6bc22685" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;gencol&quot;&gt;generated columns&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;gencol&quot;&gt;생성 된 열에&lt;/a&gt; 대한 지원을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="6a3c5f5d30415f9f1977e35ba188ec9b5fcd474e" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt;.</source>
          <target state="translated">에 대한 지원을 추가 &lt;a href=&quot;mmap&quot;&gt;메모리 매핑 I / O&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc4c8688bed6db9be32019244a2d807910dea0cc" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;partialindex&quot;&gt;partial indexes&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 지원 추가</target>
        </trans-unit>
        <trans-unit id="c5b2de4466aa197bc12dce31206322740e3db16d" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;rtree#auxcol&quot;&gt;auxiliary columns in r-tree tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rtree#auxcol&quot;&gt;r- 트리 테이블에서 보조 열에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f90c29b7cfc3c62f6507d98b86aed5242ee68ae7" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;uri&quot;&gt;URI 파일 이름&lt;/a&gt; 지원 추가</target>
        </trans-unit>
        <trans-unit id="af696b60eb69d945c8a46227c312eb8878086caa" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;windowfunctions&quot;&gt;윈도우 기능에&lt;/a&gt; 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="136f3b0eed5bac09b5f3815f7575bda175da3514" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions#grouptype&quot;&gt;GROUPS frames&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions#grouptype&quot;&gt;GROUPS 프레임에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e66dce38847e4f4f6cc41e4cccbb39be56c45c40" translate="yes" xml:space="preserve">
          <source>Add support for &lt;a href=&quot;windowfunctions#wchaining&quot;&gt;window chaining&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions#wchaining&quot;&gt;창 체인에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="212edd25833b5883700b116710f87eea867169b2" translate="yes" xml:space="preserve">
          <source>Add support for DEFERRED, IMMEDIATE, and EXCLUSIVE transactions.</source>
          <target state="translated">DEFERRED, IMMEDIATE 및 EXCLUSIVE 트랜잭션에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="5fb939adf84fb0194534bbaf8a41088037bb5c1e" translate="yes" xml:space="preserve">
          <source>Add support for INSERT OR REPLACE, INSERT OR IGNORE, and UPDATE OR REPLACE in the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블&lt;/a&gt; 에서 INSERT OR REPLACE, INSERT OR IGNORE 및 UPDATE OR REPLACE에 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f2330e77a6f10374d78e1306109d17dffa46e862" translate="yes" xml:space="preserve">
          <source>Add support for PostgreSQL-style &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT&lt;/a&gt;.</source>
          <target state="translated">PostgreSQL 스타일 &lt;a href=&quot;lang_upsert&quot;&gt;UPSERT에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="890cc871d57b4e2f53773580ef56c71b18a22739" translate="yes" xml:space="preserve">
          <source>Add support for coverage testing of VDBE programs using the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_VDBE_COVERAGE&lt;/a&gt; verb of &lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/test_control&quot;&gt;sqlite3_test_control ()&lt;/a&gt; 의 &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_VDBE_COVERAGE&lt;/a&gt; 동사를 사용하여 VDBE 프로그램의 적용 범위 테스트 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="be6c363a6bf564dc52386b7db08ec41552cf1d89" translate="yes" xml:space="preserve">
          <source>Add support for handling &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt; virtual tables. &lt;a href=&quot;#vtab&quot;&gt;See below&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt; 가상 테이블 처리에 대한 지원을 추가하십시오 . &lt;a href=&quot;#vtab&quot;&gt;자세한 내용은 아래&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a526c3a38229774d8ba86548def1a8d12a36b235" translate="yes" xml:space="preserve">
          <source>Add support for renaming columns within a table using ALTER TABLE</source>
          <target state="translated">ALTER TABLE을 사용하여 테이블 내에서 열 이름 바꾸기 지원 추가</target>
        </trans-unit>
        <trans-unit id="d659c9c8cb6c1f04393b0fc5e63bbdac64002cf9" translate="yes" xml:space="preserve">
          <source>Add support for tab-completion using the &lt;a href=&quot;completion&quot;&gt;COMPLETION extension&lt;/a&gt;, for both readline and linenoise.</source>
          <target state="translated">readline 및 linenoise에 대해 &lt;a href=&quot;completion&quot;&gt;COMPLETION 확장을&lt;/a&gt; 사용하여 탭 완성에 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4eee573107dab889c4b93bbd22bffbdf1483817" translate="yes" xml:space="preserve">
          <source>Add support for the &quot;--maxsize N&quot; option on &quot;.open --deserialize&quot;.</source>
          <target state="translated">&quot;.open --deserialize&quot;에 &quot;--maxsize N&quot;옵션에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="31f5d3e263c4687cf09a721220bb511aa4a69c6f" translate="yes" xml:space="preserve">
          <source>Add support for the &lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;FILTER clause on aggregate functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_aggfunc#aggfilter&quot;&gt;집계 함수에 FILTER 절에&lt;/a&gt; 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f217130627272aa13b670d0e6f0d5167655ce0bd" translate="yes" xml:space="preserve">
          <source>Add support for the &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS FIRST&lt;/a&gt; and &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS LAST&lt;/a&gt; syntax in &lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; clauses.</source>
          <target state="translated">&lt;a href=&quot;lang_select#orderby&quot;&gt;ORDER BY&lt;/a&gt; 절 에서 &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS FIRST&lt;/a&gt; 및 &lt;a href=&quot;lang_select#nullslast&quot;&gt;NULLS LAST&lt;/a&gt; 구문에 대한 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4007f3ce6829066fa4409e2ecd136e62637d894" translate="yes" xml:space="preserve">
          <source>Add support for the full SQL-92 join syntax and LEFT OUTER JOINs.</source>
          <target state="translated">전체 SQL-92 조인 구문 및 LEFT OUTER JOIN에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3a2eb33317dae4a033cc092362d492fb572cccd4" translate="yes" xml:space="preserve">
          <source>Add support for wildcard parameters of the form: &quot;?nnn&quot;</source>
          <target state="translated">&quot;? nnn&quot;형식의 와일드 카드 매개 변수에 대한 지원을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1eb80b8d534ca7c36dc1e214c6909a01fde00f37" translate="yes" xml:space="preserve">
          <source>Add support the &lt;a href=&quot;windowfunctions#wexcls&quot;&gt;EXCLUDE clause&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;windowfunctions#wexcls&quot;&gt;EXCLUDE 절&lt;/a&gt; 지원을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ab8baa6625378dcd2fbc2b48fe42102792d59fe" translate="yes" xml:space="preserve">
          <source>Add tclsqlite.c to the libsqlite.a library</source>
          <target state="translated">libsqlite.a 라이브러리에 tclsqlite.c 추가</target>
        </trans-unit>
        <trans-unit id="936423dc9b571e197d4ed47a549d3e24bf5f5c1f" translate="yes" xml:space="preserve">
          <source>Add tests to make sure that tclsqlite was compiled using Tcl header files and libraries that match.</source>
          <target state="translated">tclsqlite가 일치하는 Tcl 헤더 파일 및 라이브러리를 사용하여 컴파일되었는지 확인하는 테스트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8e0200d4b2125e37622440b4e128b278c449eb8c" translate="yes" xml:space="preserve">
          <source>Add the &quot;%token_class&quot; directive to &lt;a href=&quot;lemon&quot;&gt;Lemon parser generator&lt;/a&gt; and use it to simplify the grammar.</source>
          <target state="translated">&lt;a href=&quot;lemon&quot;&gt;레몬 파서 생성기에&lt;/a&gt; &quot;% token_class&quot;지시문을 추가하고 문법을 단순화하는 데 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="283b2638c2b05ae208073cb37d46fd5320238943" translate="yes" xml:space="preserve">
          <source>Add the &quot;--async&quot; option to the &quot;.backup&quot; command.</source>
          <target state="translated">&quot;.async&quot;옵션을 &quot;.backup&quot;명령에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6e8b7b2093500ea36f5f180a7347d1d5a53d8fe" translate="yes" xml:space="preserve">
          <source>Add the &quot;--memtrace&quot; command-line option, to show all memory allocations and deallocations.</source>
          <target state="translated">&quot;--memtrace&quot;명령 행 옵션을 추가하여 모든 메모리 할당 및 할당 해제를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="216e54fa647db35fda70c92921d3229237ed92dd" translate="yes" xml:space="preserve">
          <source>Add the &quot;.binary&quot; and &quot;.limits&quot; commands to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.binary&quot;및 &quot;.limits&quot;명령을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d8da8fe6a9987104191ff2baa0e3404f2a667db" translate="yes" xml:space="preserve">
          <source>Add the &quot;.cd&quot; command.</source>
          <target state="translated">&quot;.cd&quot;명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f2d55280d1b7b3a8bbfa8326a3e6f14a48e7308e" translate="yes" xml:space="preserve">
          <source>Add the &quot;.clone&quot; and &quot;.save&quot; commands to the command-line shell.</source>
          <target state="translated">&quot;.clone&quot;및 &quot;.save&quot;명령을 명령 행 쉘에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="c7d25cbe44023d988e7e9d81da8b1c5eafbc6826" translate="yes" xml:space="preserve">
          <source>Add the &quot;.eqp trace&quot; option on builds with SQLITE_DEBUG, to enable bytecode program listing with indentation and &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;PRAGMA vdbe_trace&lt;/a&gt; all in one step.</source>
          <target state="translated">SQLITE_DEBUG를 사용하여 빌드시 &quot;.eqp 추적&quot;옵션을 추가하여 들여 쓰기 및 &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;PRAGMA vdbe_trace&lt;/a&gt; 를 사용하여 바이트 코드 프로그램 목록을 모두 한 번 에 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="97816312767ca4a2c31df9a27f1fb491af457876" translate="yes" xml:space="preserve">
          <source>Add the &quot;.filectrl&quot; command useful for testing.</source>
          <target state="translated">테스트에 유용한 &quot;.filectrl&quot;명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="762e62184ff88d2ac7f6d5e9106bb08dbc9e2cb4" translate="yes" xml:space="preserve">
          <source>Add the &quot;.import&quot; command to the command-line shell.</source>
          <target state="translated">&quot;.import&quot;명령을 명령 행 쉘에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cc49dc138146b590b8cff67298e595fca2d6f169" translate="yes" xml:space="preserve">
          <source>Add the &quot;.progress&quot; command for accessing the &lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/progress_handler&quot;&gt;sqlite3_progress_handler ()&lt;/a&gt; 인터페이스 에 액세스하기 위해 &quot;.progress&quot;명령을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7c0e14ee7666efcfedda1a8139570d6579e1c44" translate="yes" xml:space="preserve">
          <source>Add the &quot;.recover&quot; command which tries to recover as much content as possible from a corrupt database file.</source>
          <target state="translated">손상된 데이터베이스 파일에서 가능한 한 많은 내용을 복구하려고하는 &quot;.recover&quot;명령을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1e8a4b92340d9f7a1f000bec88f280625487d118" translate="yes" xml:space="preserve">
          <source>Add the &quot;.system&quot; and &quot;.once&quot; commands to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.system&quot;및 &quot;.once&quot;명령을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88db3041288101d122dcba112957a35b89342c78" translate="yes" xml:space="preserve">
          <source>Add the &quot;.testcase&quot; and &quot;.check&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-commands&lt;/a&gt;.</source>
          <target state="translated">&quot;.testcase&quot;및 &quot;.check&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;도트 명령을&lt;/a&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="80eb0002e6ca30dbe7265165c28f78bf3c05f869" translate="yes" xml:space="preserve">
          <source>Add the &quot;.wheretrace&quot; command when compiled with SQLITE_DEBUG</source>
          <target state="translated">SQLITE_DEBUG로 컴파일 할 때 &quot;.wheretrace&quot;명령 추가</target>
        </trans-unit>
        <trans-unit id="8804479c26e1da45bb9e3ed0888fbc0d4a08ae1c" translate="yes" xml:space="preserve">
          <source>Add the &quot;totype.c&quot; extension, implementing the tointeger() and toreal() SQL functions.</source>
          <target state="translated">&quot;totype.c&quot;확장을 추가하여 tointeger () 및 toreal () SQL 함수를 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="92a34239c6cf2de2a3fdbbe86a2b80a08fe2e86b" translate="yes" xml:space="preserve">
          <source>Add the --bom option to the &lt;a href=&quot;cli#dotexcel&quot;&gt;.excel&lt;/a&gt;, &lt;a href=&quot;cli#dotoutput&quot;&gt;.output&lt;/a&gt;, and &lt;a href=&quot;cli#dotoutput&quot;&gt;.once&lt;/a&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;cli#dotexcel&quot;&gt;.excel&lt;/a&gt; , &lt;a href=&quot;cli#dotoutput&quot;&gt;.output&lt;/a&gt; 및 &lt;a href=&quot;cli#dotoutput&quot;&gt;.once&lt;/a&gt; 명령에 --bom 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="df81e72aa83e90414fe2ffd4c6cb48365750ab99" translate="yes" xml:space="preserve">
          <source>Add the -withoutnulls option to the &lt;a href=&quot;tclsqlite#eval&quot;&gt;TCL interface eval method&lt;/a&gt;.</source>
          <target state="translated">-withoutnulls 옵션을 &lt;a href=&quot;tclsqlite#eval&quot;&gt;TCL 인터페이스 평가 방법에&lt;/a&gt; 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe5b9c333c6038520094761f864493e2e7097cc4" translate="yes" xml:space="preserve">
          <source>Add the .oom command in debugging builds</source>
          <target state="translated">디버깅 빌드에 .oom 명령 추가</target>
        </trans-unit>
        <trans-unit id="4f125709e724b34ac5ad47f8eda53803f5734890" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; option for &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="40592c218ccd34fab463deb3f03be7da30417f9c" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; verb for &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheused&quot;&gt;SQLITE_DBSTATUS_CACHE_USED&lt;/a&gt; 동사를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="e48cfd1c7357fb4864216d4d254e3beabe8b5a2d" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachewrite&quot;&gt;SQLITE_DBSTATUS_CACHE_WRITE&lt;/a&gt; option for &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachewrite&quot;&gt;SQLITE_DBSTATUS_CACHE_WRITE&lt;/a&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="be8b97d6b9385048b55638f312823bb2eb008ce5" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; file control.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntljournalpointer&quot;&gt;SQLITE_FCNTL_JOURNAL_POINTER&lt;/a&gt; 파일 컨트롤을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="081364f71e5fefa3da91ea51b10405c027faaabe" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT&lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;file-control&lt;/a&gt; for setting an upper bound on the size of the in-memory database created by sqlite3_deserialize. The default upper bound is 1GiB, or whatever alternative value is specified by &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt;) and/or &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE&lt;/a&gt;.</source>
          <target state="translated">sqlite3_deserialize로 작성된 메모리 내 데이터베이스의 크기에 상한을 설정하기 위해 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlsizelimit&quot;&gt;SQLITE_FCNTL_SIZE_LIMIT &lt;/a&gt;&lt;a href=&quot;c3ref/file_control&quot;&gt;파일 제어&lt;/a&gt; 를 추가하십시오 . 기본 상한은 1GiB이거나 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmemdbmaxsize&quot;&gt;SQLITE_CONFIG_MEMDB_MAXSIZE&lt;/a&gt; ) 및 / 또는 &lt;a href=&quot;compile#memdb_default_maxsize&quot;&gt;SQLITE_MEMDB_DEFAULT_MAXSIZE에&lt;/a&gt; 의해 지정된 대체 값입니다 .</target>
        </trans-unit>
        <trans-unit id="5d92af1fb4c4ac1e07a26f5836df488794b6bbdc" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension(X)&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/cancel_auto_extension&quot;&gt;sqlite3_cancel_auto_extension (X)&lt;/a&gt; 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe034b4f2512875ab8ea3e02c36867f516b685b5" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/drop_modules&quot;&gt;sqlite3_drop_modules()&lt;/a&gt; interface, allowing applications to disable automatically loaded virtual tables that they do not need.</source>
          <target state="translated">&lt;a href=&quot;c3ref/drop_modules&quot;&gt;sqlite3_drop_modules ()&lt;/a&gt; 인터페이스를 추가하여 애플리케이션이 필요하지 않은 자동로드 된 가상 테이블을 비활성화 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="35fb0feea0a1d59c3a8842f9214443f77d92d83e" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64()&lt;/a&gt; interface and the corresponding &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA hard_heap_limit&lt;/a&gt; command.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_hard_heap_limit64 ()&lt;/a&gt; 인터페이스와 해당 &lt;a href=&quot;pragma#pragma_hard_heap_limit&quot;&gt;PRAGMA의 hard_heap_limit의&lt;/a&gt; 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1930b99359d377b2cc8ba418ec5abbff446f6fae" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/open#opennofollow&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt; option to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; that prevents SQLite from opening symbolic links.</source>
          <target state="translated">SQLite가 심볼릭 링크를 열지 못하게 하는 &lt;a href=&quot;c3ref/open#opennofollow&quot;&gt;SQLITE_OPEN_NOFOLLOW&lt;/a&gt; 옵션을 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()에&lt;/a&gt; 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="21d27cce565db8490729a43e1af27acdeb1a1d96" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;application-defined page cache&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;응용 프로그램 정의 페이지 캐시&lt;/a&gt; 추가</target>
        </trans-unit>
        <trans-unit id="a4d7eada875b03c7029bca58ac2ddc67b6735f11" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize()&lt;/a&gt; interfaces when the &lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; compile-time option is used.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_deserialize&quot;&gt;SQLITE_ENABLE_DESERIALIZE&lt;/a&gt; 컴파일 타임 옵션이 사용될 때 &lt;a href=&quot;c3ref/serialize&quot;&gt;sqlite3_serialize ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/deserialize&quot;&gt;sqlite3_deserialize ()&lt;/a&gt; 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="065e4967252d67f2418c2b348070eac9ee82255f" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/strglob&quot;&gt;sqlite3_strglob()&lt;/a&gt; convenience interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/strglob&quot;&gt;sqlite3_strglob ()&lt;/a&gt; 편의 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb552cbe49d24f288fc511724cd559eb4a233c0e" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_key()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_key ()&lt;/a&gt; 인터페이스를 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="52490b8c94f339853539d2cd7b35574401e395a9" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config()&lt;/a&gt; interface in support of &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses with &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 과 함께 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절을 지원 하도록 &lt;a href=&quot;c3ref/vtab_config&quot;&gt;sqlite3_vtab_config ()&lt;/a&gt; 인터페이스를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e9c1c8302237fd30d6977796970b681fda7464c" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;cksumvfs&quot;&gt;checksum VFS shim&lt;/a&gt; to the set of run-time loadable extensions included in the source tree.</source>
          <target state="translated">소스 트리에 포함 된 런타임로드 가능한 확장 집합에 &lt;a href=&quot;cksumvfs&quot;&gt;체크섬 VFS shim&lt;/a&gt; 을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="b4f5bebd726b497704665ee703792c5087bc4e88" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; compile-time option. Setting this option to 0 disables automatic indices by default.</source>
          <target state="translated">&lt;a href=&quot;compile#default_automatic_index&quot;&gt;SQLITE_DEFAULT_AUTOMATIC_INDEX&lt;/a&gt; 컴파일 타임 옵션을 추가하십시오 . 이 옵션을 0으로 설정하면 기본적으로 자동 인덱스가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="470112a79227f7c994e11abc7f3c3d991569cdaa" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#default_lookaside&quot;&gt;SQLITE_DEFAULT_LOOKASIDE&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#default_lookaside&quot;&gt;SQLITE_DEFAULT_LOOKASIDE&lt;/a&gt; 컴파일 타임 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="85aebd6ee91874adb96cb2db93f6f4d317b58eb7" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_explain_comments&quot;&gt;SQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 컴파일 타임 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="21a90d69aeda9911ff14bd96ba3dda734bfd8d53" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;compile#rtree_int_only&quot;&gt;SQLITE_RTREE_INT_ONLY&lt;/a&gt; compile-time option to force the &lt;a href=&quot;rtree&quot;&gt;R*Tree Extension Module&lt;/a&gt; to use integer instead of floating point values for both storage and computation.</source>
          <target state="translated">&lt;a href=&quot;compile#rtree_int_only&quot;&gt;SQLITE_RTREE_INT_ONLY&lt;/a&gt; 컴파일 타임 옵션을 추가하여 &lt;a href=&quot;rtree&quot;&gt;R * Tree Extension Module&lt;/a&gt; 이 스토리지 및 계산에 부동 소수점 값 대신 정수를 사용하도록하십시오.</target>
        </trans-unit>
        <trans-unit id="e8f43e6254598c7b3221cade8d257bd4fa709b38" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;dbstat#dbstatagg&quot;&gt;aggregated mode&lt;/a&gt; feature to the &lt;a href=&quot;dbstat&quot;&gt;DBSTAT virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dbstat#dbstatagg&quot;&gt;집계 모드&lt;/a&gt; 기능을 &lt;a href=&quot;dbstat&quot;&gt;DBSTAT 가상 테이블에&lt;/a&gt; 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="15e9f2fd2f640e3984cdc406903ee8672531ce05" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;FTS4 &quot;merge&quot; command&lt;/a&gt;, the &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;FTS4 &quot;automerge&quot; command&lt;/a&gt;, and the &lt;a href=&quot;fts3#*fts4ickcmd&quot;&gt;FTS4 &quot;integrity-check&quot; command&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;fts3#*fts4mergecmd&quot;&gt;FTS4 &quot;병합&quot;명령&lt;/a&gt; 의 &lt;a href=&quot;fts3#*fts4automergecmd&quot;&gt;FTS4 &quot;자동 병합&quot;명령&lt;/a&gt; 및 &lt;a href=&quot;fts3#*fts4ickcmd&quot;&gt;FTS4 &quot;무결성 검사&quot;명령을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98046a6bd29ea22d322eeeda3a2f3bdacd96dcab" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/vfsstat.c&quot;&gt;vfsstat.c&lt;/a&gt; loadable extension - a VFS shim that measures I/O together with an &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual table&lt;/a&gt; that provides access to the measurements.</source>
          <target state="translated">측정에 대한 액세스를 제공 하는 &lt;a href=&quot;https://www.sqlite.org/src/artifact?ci=trunk&amp;amp;filename=ext/misc/vfsstat.c&quot;&gt;시상 &lt;/a&gt;&lt;a href=&quot;vtab#epovtab&quot;&gt;가상 테이블&lt;/a&gt; 과 함께 I / O를 측정하는 VFS 심인 vfsstat.c 로드 가능 확장을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="7cd3c312e6d704d9ddb06fdac7e44b6ba43e781a" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; clause.</source>
          <target state="translated">&lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; 절을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="93f9efcb02f9ffd6cbf45dbb655ea785d5db4c65" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT JOIN strength reduction optimization&lt;/a&gt; that converts a LEFT JOIN into an ordinary JOIN if there exist terms in the WHERE clause that would prevent the extra all-NULL row of the LEFT JOIN from appearing in the output set.</source>
          <target state="translated">추가 &lt;a href=&quot;optoverview#leftjoinreduction&quot;&gt;LEFT를 강도 감소 최적화 가입&lt;/a&gt; 이 왼쪽의 추가 모든 NULL 행을 방해하는 WHERE 절에 조건을 존재하는 출력 세트에 나타나지 가입하는 경우 LEFT가 일반에 가입 변환이 가입 것을.</target>
        </trans-unit>
        <trans-unit id="6294f954692677e23d4407af3d20a5f13384a9c1" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table=ON&lt;/a&gt; command that causes the &quot;ALTER TABLE RENAME&quot; command to behave as it did in SQLite versions 3.24.0 and earlier: references to the renamed table inside the bodies of triggers and views are not updated. This new pragma provides a compatibility work around for older programs that expected the older, wonky behavior of ALTER TABLE RENAME.</source>
          <target state="translated">SQLite 3.24.0 및 이전 버전에서와 같이 &quot;ALTER TABLE RENAME&quot;명령이 작동하게 하는 &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table = ON&lt;/a&gt; 명령을 추가하십시오 . 트리거 및 뷰 본문 내의 이름이 바뀐 테이블에 대한 참조는 업데이트되지 않습니다. 이 새로운 pragma는 ALTER TABLE RENAME의 오래되고 기발한 동작을 예상했던 이전 프로그램에 대한 호환성 해결 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b9e0bbc3322ff734087f22e70d84d21a6e7a30fe" translate="yes" xml:space="preserve">
          <source>Add the &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xSavepoint&lt;/a&gt;, &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRelease&lt;/a&gt; and &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRollbackTo&lt;/a&gt; methods in &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt; in support of &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; for virtual tables.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 를 지원 하기 위해 가상 테이블에 &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xSavepoint&lt;/a&gt; , &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRelease&lt;/a&gt; 및 &lt;a href=&quot;vtab#xsavepoint&quot;&gt;xRollbackTo&lt;/a&gt; 메소드를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6ed36cb9eb24ef6e4831d3cb6e75c5a505ce11d8" translate="yes" xml:space="preserve">
          <source>Add the &lt;b&gt;sqlite_version[]&lt;/b&gt; string constant to the library</source>
          <target state="translated">라이브러리에 &lt;b&gt;sqlite_version []&lt;/b&gt; 문자열 상수 추가</target>
        </trans-unit>
        <trans-unit id="1a77c4f39c42e3d8e465cea41bb54ff783957906" translate="yes" xml:space="preserve">
          <source>Add the COLLATE operator used to explicitly set the collating sequence used by an expression. This feature is considered experimental pending additional testing.</source>
          <target state="translated">표현식에서 사용하는 조합 순서를 명시 적으로 설정하는 데 사용되는 COLLATE 연산자를 추가하십시오. 이 기능은 추가 테스트가 보류중인 실험적인 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="29546c6fbd4241b614f52b701e19fb42190f52db" translate="yes" xml:space="preserve">
          <source>Add the MEMORY option to the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode pragma에&lt;/a&gt; MEMORY 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="08441390d486d4a704f4d3ebdd1c1a4095467616" translate="yes" xml:space="preserve">
          <source>Add the ability for INSERT and UPDATE statements to refer to the &quot;rowid&quot; (or &quot;_rowid_&quot; or &quot;oid&quot;) columns.</source>
          <target state="translated">INSERT 및 UPDATE 문에 &quot;rowid&quot;(또는 &quot;_rowid_&quot;또는 &quot;oid&quot;) 열을 참조하는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="91d47c24f96a5ac57ed4cd528de551cd89df640b" translate="yes" xml:space="preserve">
          <source>Add the ability to change the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; status of a database by setting the auto_vaccum pragma and VACUUMing the database.</source>
          <target state="translated">auto_vaccum pragma를 설정하고 데이터베이스를 VACUUMing하여 데이터베이스 의 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 상태 를 변경하는 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="90b4842e5d50e9cfd8c2600caa26cf77f6f838dc" translate="yes" xml:space="preserve">
          <source>Add the ability to do MSVC Windows builds from the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt; 에서 MSVC Windows 빌드 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="b9cc0bb08d1187beca47dd9f85ca607d55ca39f7" translate="yes" xml:space="preserve">
          <source>Add the ability to find a full-index-scan query plan for queries using &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; which previously would fail with &quot;no query solution&quot;.</source>
          <target state="translated">이전에는 &quot;쿼리 솔루션 없음&quot;으로 실패했던 &lt;a href=&quot;lang_indexedby&quot;&gt;INDEXED BY&lt;/a&gt; 를 사용하여 쿼리에 대한 전체 인덱스 스캔 쿼리 계획을 찾는 기능을 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="9b4db540a1419635a899fe1e123412560851c41e" translate="yes" xml:space="preserve">
          <source>Add the ability to implement FROM clause subqueries as coroutines rather that manifesting the subquery into a temporary table.</source>
          <target state="translated">하위 쿼리를 임시 테이블에 표시하는 대신 FROM 절 하위 쿼리를 코 루틴으로 구현하는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="641284aafcb663d3733121dbe152ab06583bd76f" translate="yes" xml:space="preserve">
          <source>Add the ability to put TABLE.* in the column list of a SELECT statement.</source>
          <target state="translated">SELECT.의 열리스트에 TABLE. *를 넣는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="76eab5ccc29a6c69261726a47189c3c56c533ee9" translate="yes" xml:space="preserve">
          <source>Add the ability to put a single .command in the second argument of the sqlite shell</source>
          <target state="translated">sqlite 쉘의 두 번째 인수에 단일 .command를 넣는 기능 추가</target>
        </trans-unit>
        <trans-unit id="7c6f54e907a75263fd0bf968b6313ce06f8b53fe" translate="yes" xml:space="preserve">
          <source>Add the ability to read both little-endian and big-endian databases. So a database created under SunOS or Mac OS X can be read and written under Linux or Windows and vice versa.</source>
          <target state="translated">리틀 엔디안 및 빅 엔디안 데이터베이스를 모두 읽을 수있는 기능을 추가하십시오. 따라서 SunOS 또는 Mac OS X에서 작성된 데이터베이스는 Linux 또는 Windows에서 또는 그 반대로 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af73d1caadd8c6a0bfa650a1605b5bc6b382fa8b" translate="yes" xml:space="preserve">
          <source>Add the ability to read from &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; databases even if the application lacks write permission on the database and its containing directory, as long as the -shm and -wal files exist in that directory.</source>
          <target state="translated">-shm 및 -wal 파일이 해당 디렉토리에 존재하는 한 응용 프로그램에 데이터베이스 및 포함 디렉토리에 대한 쓰기 권한이없는 경우에도 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 에서 읽을 수있는 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="380f653fc0d3d6ccefb92e152868bd3b2cfdb518" translate="yes" xml:space="preserve">
          <source>Add the ability to run a full regression test with a small &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit&lt;/a&gt;.</source>
          <target state="translated">작은 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit&lt;/a&gt; 로 전체 회귀 테스트를 실행하는 기능을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb5bd71c1b0c8add951478fd6dd2ffd86268514b" translate="yes" xml:space="preserve">
          <source>Add the ability to specify an alternative temporary file directory using the &quot;sqlite_temp_directory&quot; global variable.</source>
          <target state="translated">&quot;sqlite_temp_directory&quot;글로벌 변수를 사용하여 대체 임시 파일 디렉토리를 지정하는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4f2ac397ad237a3ec1542096c2f09b239a87fcab" translate="yes" xml:space="preserve">
          <source>Add the ability to use quoted strings as table and column names in expressions.</source>
          <target state="translated">따옴표로 묶인 문자열을 표현식에서 테이블 및 열 이름으로 사용하는 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6e7939de31db1c52152d61c7f45b0bf4965a26a9" translate="yes" xml:space="preserve">
          <source>Add the build-in RTRIM collating sequence.</source>
          <target state="translated">내장 RTRIM 조합 순서를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d4031514981ccb92e8822ed8b31bcfdb01017867" translate="yes" xml:space="preserve">
          <source>Add the capability of &quot;hidden&quot; columns in virtual tables.</source>
          <target state="translated">가상 테이블에서 &quot;숨겨진&quot;열 기능을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6ce623dc6dee7dc1c4546659cdff0cc47e7ae976" translate="yes" xml:space="preserve">
          <source>Add the capability of evaluating an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt; as a sequence of comparisons as an alternative to using a table lookup. Use the sequence of comparisons implementation in circumstances where it is likely to be faster, such as when the right-hand side of the IN operator is small and/or changes frequently.</source>
          <target state="translated">테이블 조회를 사용하는 대신 &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; 를 비교 시퀀스로 평가하는 기능을 추가하십시오 . IN 연산자의 오른쪽이 작거나 자주 변경되는 경우와 같이 속도가 더 빠를 수있는 상황에서 일련의 비교 구현을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="913170471b20c5cadb18e221b79038b72aa6c5c5" translate="yes" xml:space="preserve">
          <source>Add the constant P2 to the value in register P1. The result is always an integer.</source>
          <target state="translated">상수 P2를 레지스터 P1의 값에 추가하십시오. 결과는 항상 정수입니다.</target>
        </trans-unit>
        <trans-unit id="49543ed02ed7f75a8b5f4d3033d6dbc8ce95628d" translate="yes" xml:space="preserve">
          <source>Add the fuzzcheck test program and automatically run this program using both SQL and database test cases on &quot;make test&quot;.</source>
          <target state="translated">fuzzcheck 테스트 프로그램을 추가하고 &quot;make test&quot;에서 SQL 및 데이터베이스 테스트 사례를 모두 사용하여이 프로그램을 자동으로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f6c12a1411453c369d89d2764b058c0cb481650f" translate="yes" xml:space="preserve">
          <source>Add the global variable sqlite_temp_directory which if set defines the directory in which temporary files are stored.</source>
          <target state="translated">전역 변수 sqlite_temp_directory를 추가하십시오. 설정되면 임시 파일이 저장되는 디렉토리를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="05674fc8f1df1c74cf46b61016ca2070fc8379b9" translate="yes" xml:space="preserve">
          <source>Add the long-standing &quot;.testctrl&quot; command to the &quot;.help&quot; menu.</source>
          <target state="translated">오랫동안 &quot;.testctrl&quot;명령을 &quot;.help&quot;메뉴에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="31c64589ffb807ef4d796e265bb6d226b04b8cc8" translate="yes" xml:space="preserve">
          <source>Add the name of an individual configuration setting to query the current value of that setting. Optionally add a boolean value to change a setting.</source>
          <target state="translated">개별 구성 설정의 이름을 추가하여 해당 설정의 현재 값을 쿼리합니다. 선택적으로 부울 값을 추가하여 설정을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="19a95d896cccaf286ff7b2470d35b7c705d0ca8a" translate="yes" xml:space="preserve">
          <source>Add the name of an individual configuration setting to query the current value of that setting. Optionally add a boolean value to change a setting. For example, turn off support for the &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature like this:</source>
          <target state="translated">개별 구성 설정의 이름을 추가하여 해당 설정의 현재 값을 쿼리하십시오. 선택적으로 부울 값을 추가하여 설정을 변경하십시오. 예를 들어, 다음 과 같이 &lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴&lt;/a&gt; 기능에 대한 지원을 끄십시오 .</target>
        </trans-unit>
        <trans-unit id="765e23b58c1bb51c78a2c11360fa9dffbf0998be" translate="yes" xml:space="preserve">
          <source>Add the new &quot;.genfkey&quot; command in the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; for generating triggers to implement foreign key constraints.</source>
          <target state="translated">외래 키 제약 조건을 구현하는 트리거를 생성하기 위해 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에 새로운 &quot;.genfkey&quot;명령을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="353211e020fc294eba4ff8c7f60b45103bef8637" translate="yes" xml:space="preserve">
          <source>Add the new &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error_code()&lt;/a&gt; API and use it in the implementation of &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; so that proper error codes are returned when an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; fails.</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_error_code ()&lt;/a&gt; API를 추가하고 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 구현시이를 사용 하여 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 가 실패 할 때 적절한 오류 코드가 리턴되도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="d645979e763a15ad29729f489aa54879c9058e28" translate="yes" xml:space="preserve">
          <source>Add the sorter-reference optimization as a compile-time option. Only available if compiled with SQLITE_ENABLE_SORTER_REFERENCES.</source>
          <target state="translated">분류기 참조 최적화를 컴파일 타임 옵션으로 추가하십시오. SQLITE_ENABLE_SORTER_REFERENCES로 컴파일 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="09f9f5215cd0bcd28873268a2df03e58b7edb884" translate="yes" xml:space="preserve">
          <source>Add the text in register P1 onto the end of the text in register P2 and store the result in register P3. If either the P1 or P2 text are NULL then store NULL in P3.</source>
          <target state="translated">레지스터 P1의 텍스트를 레지스터 P2의 텍스트 끝에 추가하고 결과를 레지스터 P3에 저장합니다. P1 또는 P2 텍스트가 NULL이면 P3에 NULL을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="1cf58523b65d0b130a577861b217d7b44ae4b7ae" translate="yes" xml:space="preserve">
          <source>Add the value in register P1 to the value in register P2 and store the result in register P3. If either input is NULL, the result is NULL.</source>
          <target state="translated">레지스터 P1의 값을 레지스터 P2의 값에 추가하고 결과를 레지스터 P3에 저장합니다. 입력 중 하나가 NULL이면 결과는 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="66fcebde89e16dc9a370173c80b02abe9e4c78f0" translate="yes" xml:space="preserve">
          <source>AddImm</source>
          <target state="translated">AddImm</target>
        </trans-unit>
        <trans-unit id="2110eeb59898919163140d91e36c5206d742c963" translate="yes" xml:space="preserve">
          <source>Added &quot;.lint fkey-indexes&quot; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.lint fkey-indexes&quot;를 &lt;a href=&quot;cli&quot;&gt;명령 줄 쉘에 추가했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17b3156c2ecab2f101328f99f2bb4049428c27f0" translate="yes" xml:space="preserve">
          <source>Added &quot;.mode quote&quot; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 쉘에&lt;/a&gt; &quot;.mode quote&quot;가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6f34edea5910a5e62ccf46db8b7d60aaaee76631" translate="yes" xml:space="preserve">
          <source>Added &quot;busy&quot; and &quot;timeout&quot; methods to the Tcl interface</source>
          <target state="translated">Tcl 인터페이스에 &quot;busy&quot;및 &quot;timeout&quot;메소드 추가</target>
        </trans-unit>
        <trans-unit id="379c527f7af719153fa43206a68c9c81b52a41ba" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; as an optional bit in the 4th argument to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and related interfaces, providing applications with the ability to create new functions that can be factored out of inner loops when they have constant arguments.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 관련 인터페이스 에 대한 네 번째 인수에서 선택적 비트로 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 을 추가 하여 상수 인수가있을 때 내부 루프에서 제외 될 수있는 새로운 함수를 애플리케이션에 작성할 수있는 기능을 애플리케이션에 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7c75ca03b5710969006d7c9cdc20263784e7e1d5" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; as an optional bit in the 4th argument to the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; and related interfaces, providing applications with the ability to create new functions that can be factored out of inner loops when they have constant arguments.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function ()&lt;/a&gt; 및 관련 인터페이스 에 대한 4 번째 인수의 선택적 비트로 &lt;a href=&quot;c3ref/c_deterministic#sqlitedeterministic&quot;&gt;SQLITE_DETERMINISTIC&lt;/a&gt; 을 추가 하여 응용 프로그램에 상수 인수가있을 때 내부 루프에서 제외 될 수있는 새 함수를 만들 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c33f2de4952c71c6ae8d2342c531d9ec5acdd089" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; file control opcode.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; 파일 제어 opcode가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="41f0bea9f1aab4e8e94f7f046274987aafe92259" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;fts5&quot;&gt;Full Text Search version 5 (FTS5)&lt;/a&gt; to the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, enabled using &lt;a href=&quot;compile#enable_fts5&quot;&gt;SQLITE_ENABLE_FTS5&lt;/a&gt;. FTS5 will be considered &quot;experimental&quot; (subject to incompatible changes) for at least one more release cycle.</source>
          <target state="translated">추가 된 &lt;a href=&quot;fts5&quot;&gt;전체 텍스트 검색 버전 5 (FTS5)&lt;/a&gt; 받는 &lt;a href=&quot;amalgamation&quot;&gt;합병은&lt;/a&gt; 사용 가능 &lt;a href=&quot;compile#enable_fts5&quot;&gt;SQLITE_ENABLE_FTS5을&lt;/a&gt; . FTS5는 하나 이상의 릴리스주기 동안 &quot;실험적&quot;(호환되지 않는 변경에 따라)으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="e5083f2c6979cbe0e53546ddb0afabcdf2faa5b7" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt; module in the source tree, and in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. Enable support using the &lt;a href=&quot;compile#enable_json1&quot;&gt;SQLITE_ENABLE_JSON1&lt;/a&gt; compile-time option.</source>
          <target state="translated">소스 트리 및 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에 &lt;/a&gt;&lt;a href=&quot;json1&quot;&gt;json1 확장&lt;/a&gt; 모듈을 추가 했습니다 . &lt;a href=&quot;compile#enable_json1&quot;&gt;SQLITE_ENABLE_JSON1&lt;/a&gt; 컴파일 타임 옵션을 사용하여 지원을 활성화하십시오 .</target>
        </trans-unit>
        <trans-unit id="ce4b533f0e27715071ef87eea4d93f3cf1f90e06" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_checkpoint_fullfsync&quot;&gt;PRAGMA checkpoint_fullfsync가&lt;/a&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="01f1995fb018bbb40a46ee81938b4ec1c3d8a6dc" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;pragma#pragma_freelist_count&quot;&gt;PRAGMA freelist_count&lt;/a&gt; for determining the current size of the freelist.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_freelist_count&quot;&gt;프리리스트&lt;/a&gt; 의 현재 크기를 결정하기 위해 PRAGMA freelist_count 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="971c4ac1e76be78c3a8dee23705ac7dd59d334eb" translate="yes" xml:space="preserve">
          <source>Added &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;PRAGMA table_xinfo&lt;/a&gt; that works just like &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; except that it also shows &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in virtual tables.</source>
          <target state="translated">가상 테이블에 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열도&lt;/a&gt; 표시한다는 점을 제외하고 &lt;a href=&quot;pragma#pragma_table_info&quot;&gt;PRAGMA table_info&lt;/a&gt; 와 &lt;a href=&quot;pragma#pragma_table_xinfo&quot;&gt;동일&lt;/a&gt; 하게 작동하는 PRAGMA table_xinfo 를 추가 했습니다 .</target>
        </trans-unit>
        <trans-unit id="d0a0808cf95414d138c9f313f7f4408d5a231ce9" translate="yes" xml:space="preserve">
          <source>Added &lt;em&gt;experimental&lt;/em&gt; support for the &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; PRAGMA and persistent journal.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; PRAGMA 및 영구 저널에 대한 &lt;em&gt;실험&lt;/em&gt; 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="37e5cd3d1cdeaf90ac5106de1f3234e18cceede7" translate="yes" xml:space="preserve">
          <source>Added APIs &lt;a href=&quot;c3ref/filename_database&quot;&gt;sqlite3_filename_database()&lt;/a&gt;, &lt;a href=&quot;c3ref/filename_database&quot;&gt;sqlite3_filename_journal()&lt;/a&gt;, and &lt;a href=&quot;c3ref/filename_database&quot;&gt;sqlite3_filename_wal()&lt;/a&gt; which are useful for specialized extensions.</source>
          <target state="translated">특수 확장에 유용한 API &lt;a href=&quot;c3ref/filename_database&quot;&gt;sqlite3_filename_database ()&lt;/a&gt; , &lt;a href=&quot;c3ref/filename_database&quot;&gt;sqlite3_filename_journal ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/filename_database&quot;&gt;sqlite3_filename_wal ()&lt;/a&gt; 을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="b2336dfca3803f9a8e032676d0cec38c1ebfd454" translate="yes" xml:space="preserve">
          <source>Added Mac OS X locking patches (beta - disabled by default)</source>
          <target state="translated">Mac OS X 잠금 패치 추가 (베타-기본적으로 비활성화 됨)</target>
        </trans-unit>
        <trans-unit id="db99ee2e25e21b5b81f68fcf9810b39626b69d8d" translate="yes" xml:space="preserve">
          <source>Added RPMS to the delivery (patches from Doug Henry)</source>
          <target state="translated">배달에 RPMS 추가 (Doug Henry의 패치)</target>
        </trans-unit>
        <trans-unit id="67198b6e07398a12f3c25aaf4ac2154027ff0378" translate="yes" xml:space="preserve">
          <source>Added SQL functions &lt;a href=&quot;lang_corefunc#unicode&quot;&gt;unicode(A)&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#char&quot;&gt;char(X1,...,XN)&lt;/a&gt;.</source>
          <target state="translated">추가 SQL 기능의 &lt;a href=&quot;lang_corefunc#unicode&quot;&gt;유니 코드 (A)&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#char&quot;&gt;문자 (X1, ..., XN)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ac6ca0d8ed6a2ff2db4fe6f55b929a7c0125e12" translate="yes" xml:space="preserve">
          <source>Added SQL-92 compliant handling of NULLs.</source>
          <target state="translated">NULL의 SQL-92 호환 처리를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="33c2a0ba3f2291cb99aee2473a49a09f7ccf3bf8" translate="yes" xml:space="preserve">
          <source>Added UTC to localtime conversions to the experimental date/time functions.</source>
          <target state="translated">실험 날짜 / 시간 함수로 현지 시간 변환에 UTC를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="cdce9c9a8eb91c9a8d97198c0a3be5edb3ec079e" translate="yes" xml:space="preserve">
          <source>Added a &quot;memory:&quot; backend driver that stores its database in an in-memory hash table.</source>
          <target state="translated">데이터베이스를 메모리 내 해시 테이블에 저장하는 &quot;memory :&quot;백엔드 드라이버를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="00e371dc673bc0768232c8a31e4ebbea705ef36e" translate="yes" xml:space="preserve">
          <source>Added a &lt;b&gt;GLOB&lt;/b&gt; operator: similar to &lt;b&gt;LIKE&lt;/b&gt; but it uses Unix shell globbing wildcards instead of the '%' and '_' wildcards of SQL.</source>
          <target state="translated">&lt;b&gt;GLIKE&lt;/b&gt; 연산자를 추가했습니다 . &lt;b&gt;LIKE&lt;/b&gt; 와 비슷 하지만 SQL의 '%'및 '_'와일드 카드 대신 Unix 쉘 globbing 와일드 카드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="250be653dbe1b995ef443b4744fbdd334d1af201" translate="yes" xml:space="preserve">
          <source>Added a &lt;b&gt;VACUUM&lt;/b&gt; command that calls the &lt;b&gt;gdbm_reorganize()&lt;/b&gt; function on the underlying database files.</source>
          <target state="translated">기본 데이터베이스 파일에서 &lt;b&gt;gdbm_reorganize ()&lt;/b&gt; 함수 를 호출 하는 &lt;b&gt;VACUUM&lt;/b&gt; 명령을 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="8f50be98792a4473f5df166e79e4c15e470e945f" translate="yes" xml:space="preserve">
          <source>Added a REGEXP operator to the parser. There is no function to back up this operator in the standard build but users can add their own using sqlite3_create_function()</source>
          <target state="translated">파서에 REGEXP 연산자를 추가했습니다. 표준 빌드에는이 연산자를 백업하는 함수가 없지만 사용자는 sqlite3_create_function ()을 사용하여 자신의 연산자를 추가 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c212ede6225bb468c44a057a6ea39db59358c58f" translate="yes" xml:space="preserve">
          <source>Added a bunch more tests that take advantage of the new fcnt() function. The new tests did not uncover any new problems.</source>
          <target state="translated">새로운 fcnt () 함수를 활용하는 많은 테스트를 추가했습니다. 새로운 테스트는 새로운 문제를 발견하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="405362df77d500b1d4a23148d0fa3aadc04a61a9" translate="yes" xml:space="preserve">
          <source>Added a memory barrier in the implementation of &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; to help ensure that it is thread-safe.</source>
          <target state="translated">스레드로부터 안전하도록 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize ()&lt;/a&gt; 구현에 메모리 장벽을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b9e87cd127e91da0ec0dda2b4bc2817875de241c" translate="yes" xml:space="preserve">
          <source>Added a new &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; source code file to the source tree: &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt;</source>
          <target state="translated">새로운 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 소스 코드 파일을 소스 트리에 추가했습니다 : &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a7bef2f5c6c7c126bee7d0e1381e04a2bc5d5c7" translate="yes" xml:space="preserve">
          <source>Added a new &lt;a href=&quot;rtree&quot;&gt;R*Tree index extension&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;rtree&quot;&gt;R * Tree 인덱스 확장을 추가했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b4c4957f61db08c301d624dc05f1392878c4ab6" translate="yes" xml:space="preserve">
          <source>Added a new &lt;a href=&quot;rtree&quot;&gt;R*Tree virtual table&lt;/a&gt;</source>
          <target state="translated">새로운 &lt;a href=&quot;rtree&quot;&gt;R * Tree 가상 테이블 추가&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e29fe680785011d7bda3161f75d1202d6b3c9e3" translate="yes" xml:space="preserve">
          <source>Added a new C/C++ API that does not use callback for returning data.</source>
          <target state="translated">데이터 반환에 콜백을 사용하지 않는 새로운 C / C ++ API를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="b214b9ae924929f1e2351882a725695633b6e8e3" translate="yes" xml:space="preserve">
          <source>Added a new OS interface method for determining the sector size of underlying media: sqlite3OsSectorSize().</source>
          <target state="translated">기본 미디어의 섹터 크기를 결정하기위한 새로운 OS 인터페이스 방법 인 sqlite3OsSectorSize ()가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7ce29058ae0caf8062f35fba6d887336c4a7ab9a" translate="yes" xml:space="preserve">
          <source>Added a virtual function layer for the OS interface</source>
          <target state="translated">OS 인터페이스를위한 가상 기능 계층 추가</target>
        </trans-unit>
        <trans-unit id="61b8033f44960f290c02892665b99592125d3ee3" translate="yes" xml:space="preserve">
          <source>Added additional test cases and fixed a few bugs that those test cases found.</source>
          <target state="translated">추가 테스트 사례를 추가하고 해당 테스트 사례에서 발견 된 몇 가지 버그를 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="51c1830e3a8de651ced6ed3d6d28fa7fd0b964bd" translate="yes" xml:space="preserve">
          <source>Added an experimental power-of-two, first-fit memory allocator.</source>
          <target state="translated">실험적인 2의 거듭 제곱 메모리 할당자를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="61506056435b0abe346d4b1592020fa0841dc847" translate="yes" xml:space="preserve">
          <source>Added an optimization to UNION ALL</source>
          <target state="translated">UNION ALL에 최적화 추가</target>
        </trans-unit>
        <trans-unit id="1a0bf560d56111975b663b31d372f7d04ccc0408" translate="yes" xml:space="preserve">
          <source>Added an optional 5th parameter defining the collating sequence to the next_char() extension SQL function.</source>
          <target state="translated">조합 순서를 next_char () 확장 SQL 함수에 정의하는 선택적 5 번째 매개 변수를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="03d357182f3b49b9560b914618c22b6d797e8a50" translate="yes" xml:space="preserve">
          <source>Added an output buffer size parameter to the xGetTempname() method of the VFS layer.</source>
          <target state="translated">VFS 레이어의 xGetTempname () 메서드에 출력 버퍼 크기 매개 변수를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="f92c6a94a65042a5738630118f0b6522d064c4d6" translate="yes" xml:space="preserve">
          <source>Added authorization hooks for the new ATTACH and DETACH commands.</source>
          <target state="translated">새로운 ATTACH 및 DETACH 명령에 대한 권한 부여 후크가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="29532217c190ee9ef8560df060b282fde86a0201" translate="yes" xml:space="preserve">
          <source>Added built-in support for VxWorks</source>
          <target state="translated">VxWorks에 대한 내장 지원 추가</target>
        </trans-unit>
        <trans-unit id="f73272ae7b494f886c0b2f663aab600ada22a9d0" translate="yes" xml:space="preserve">
          <source>Added code for the &lt;a href=&quot;uintcseq&quot;&gt;UINT collating sequence&lt;/a&gt; as an optional &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;a href=&quot;loadext&quot;&gt;로드 가능 확장&lt;/a&gt; 으로 &lt;a href=&quot;uintcseq&quot;&gt;UINT 조합 시퀀스에&lt;/a&gt; 대한 코드를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="147b8e42a7c5709c165ca9ec210f58e87fdbc166" translate="yes" xml:space="preserve">
          <source>Added compound select operators: &lt;b&gt;UNION&lt;/b&gt;, &lt;b&gt;UNION ALL&lt;/b&gt;, &lt;b&gt;INTERSECT&lt;/b&gt;, and &lt;b&gt;EXCEPT&lt;/b&gt;</source>
          <target state="translated">복합 선택 연산자 : &lt;b&gt;UNION&lt;/b&gt; , &lt;b&gt;UNION ALL&lt;/b&gt; , &lt;b&gt;INTERSECT&lt;/b&gt; 및 &lt;b&gt;EXCEPT 추가&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="966bb7eeb144aa22658b66260b0fc07c41cb34a5" translate="yes" xml:space="preserve">
          <source>Added documentation on SELECT DISTINCT and on how SQLite handles NULLs.</source>
          <target state="translated">SELECT DISTINCT 및 SQLite가 NULL을 처리하는 방법에 대한 설명서가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5259a8e93acf37a2a605d329efcce9e4a1e269e" translate="yes" xml:space="preserve">
          <source>Added documentation on compiling to WinNT.</source>
          <target state="translated">WinNT 컴파일에 관한 문서를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5004dca04585c7d3aaf25e1e1a41516474e09016" translate="yes" xml:space="preserve">
          <source>Added driver for OS/2</source>
          <target state="translated">OS / 2 용 드라이버 추가</target>
        </trans-unit>
        <trans-unit id="fe42510cd0463afe5cbf6d7827cc69110a1cc60c" translate="yes" xml:space="preserve">
          <source>Added experimental API: sqlite3_auto_extension()</source>
          <target state="translated">실험적 API 추가 : sqlite3_auto_extension ()</target>
        </trans-unit>
        <trans-unit id="7766b89d29253ecd84d2e8efcc547f8a4a19fdd2" translate="yes" xml:space="preserve">
          <source>Added experimental sqlite_bind() and sqlite_reset() APIs.</source>
          <target state="translated">실험적인 sqlite_bind () 및 sqlite_reset () API를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="aa8380976f60b469b795a9cfe69a68ad28519ab2" translate="yes" xml:space="preserve">
          <source>Added experimental sqlite_progress_handler() callback API</source>
          <target state="translated">실험적인 sqlite_progress_handler () 콜백 API 추가</target>
        </trans-unit>
        <trans-unit id="0dde0a29472bfdb42ef6a4ba4d29d82906afeb01" translate="yes" xml:space="preserve">
          <source>Added experimental support for &lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA functions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragfunc&quot;&gt;PRAGMA 기능에&lt;/a&gt; 대한 실험 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1b04ee6a08af9da9a7cc5155935020b217c59f16" translate="yes" xml:space="preserve">
          <source>Added explicit &lt;a href=&quot;limits&quot;&gt;upper bounds&lt;/a&gt; on the sizes and quantities of things SQLite can process. This change might cause compatibility problems for applications that use SQLite in the extreme, which is why the current release is 3.4.0 instead of 3.3.18.</source>
          <target state="translated">SQLite가 처리 할 수있는 크기와 수량에 명시적인 &lt;a href=&quot;limits&quot;&gt;상한을&lt;/a&gt; 추가했습니다 . 이 변경으로 인해 SQLite를 극단적으로 사용하는 응용 프로그램의 호환성 문제가 발생할 수 있으므로 현재 릴리스가 3.3.18이 아닌 3.4.0입니다.</target>
        </trans-unit>
        <trans-unit id="468a08b7f21336387bf99840259543add6d147c1" translate="yes" xml:space="preserve">
          <source>Added four new &lt;a href=&quot;cli#dotmode&quot;&gt;output modes&lt;/a&gt;: &quot;box&quot;, &quot;json&quot;, &quot;markdown&quot;, and &quot;table&quot;.</source>
          <target state="translated">4 개의 새로운 &lt;a href=&quot;cli#dotmode&quot;&gt;출력 모드&lt;/a&gt; 추가 : &quot;box&quot;, &quot;json&quot;, &quot;markdown&quot;및 &quot;table&quot;.</target>
        </trans-unit>
        <trans-unit id="39458a71b59bf72d180e407a4469d5eee8eb52fb" translate="yes" xml:space="preserve">
          <source>Added functions &lt;b&gt;length()&lt;/b&gt; and &lt;b&gt;substr()&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;length ()&lt;/b&gt; 및 &lt;b&gt;substr ()&lt;/b&gt; 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ea09a49bd5b911106d49b4181dd736a6c1febba9" translate="yes" xml:space="preserve">
          <source>Added improved version identification features: C-Preprocessor macro &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt;, C/C++ interface &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid()&lt;/a&gt;, and SQL function &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id()&lt;/a&gt;.</source>
          <target state="translated">C- 전 처리기 매크로 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; , C / C ++ 인터페이스 &lt;a href=&quot;c3ref/libversion&quot;&gt;sqlite3_sourceid ()&lt;/a&gt; 및 SQL 함수 &lt;a href=&quot;lang_corefunc#sqlite_source_id&quot;&gt;sqlite_source_id ()&lt;/a&gt; 와 같은 개선 된 버전 식별 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="36da124a6f3ace551424bb6aa30d21793847e7e5" translate="yes" xml:space="preserve">
          <source>Added limited support for transactions. At this point, transactions will do table locking on the GDBM backend. There is no support (yet) for rollback or atomic commit.</source>
          <target state="translated">거래에 대한 제한된 지원이 추가되었습니다. 이 시점에서 트랜잭션은 GDBM 백엔드에서 테이블 잠금을 수행합니다. 롤백 또는 원자 적 커밋에 대한 지원 (아직)이 없습니다.</target>
        </trans-unit>
        <trans-unit id="322bfefb44d4286a4a0577edd8cf824412924d23" translate="yes" xml:space="preserve">
          <source>Added logic to detect when the library API routines are called out of sequence.</source>
          <target state="translated">라이브러리 API 루틴이 순서를 벗어난 시점을 감지하는 로직이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="67317880fae037ebc6d3e2d3e37f7ba602179da1" translate="yes" xml:space="preserve">
          <source>Added lots of new test cases</source>
          <target state="translated">많은 새로운 테스트 사례 추가</target>
        </trans-unit>
        <trans-unit id="7d49fe297826d5eff0d8ba253a3d0ec9f7707bb3" translate="yes" xml:space="preserve">
          <source>Added many new loadable extensions to the source tree, including amatch, closure, fuzzer, ieee754, nextchar, regexp, spellfix, and wholenumber. See header comments on each extension source file for further information about what that extension does.</source>
          <target state="translated">일치, 클로저, 퍼저, ieee754, nextchar, regexp, spellfix 및 정수를 포함하여 소스 트리에 많은 새로운로드 가능한 확장이 추가되었습니다. 해당 확장자의 기능에 대한 자세한 정보는 각 확장자 소스 파일에 대한 헤더 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b7ee37f0f1005525b8836f4f65d7fb421a50ba51" translate="yes" xml:space="preserve">
          <source>Added new &lt;a href=&quot;uri#coreqp&quot;&gt;URI query parameters&lt;/a&gt; &quot;nolock&quot; and &quot;immutable&quot;.</source>
          <target state="translated">새로운 &lt;a href=&quot;uri#coreqp&quot;&gt;URI 쿼리 매개 변수&lt;/a&gt; &quot;nolock&quot;및 &quot;immutable&quot;이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="63392fe9fe96791514a3c1be366331a2c5669d4f" translate="yes" xml:space="preserve">
          <source>Added new commands &quot;.backup&quot; and &quot;.restore&quot; to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;.</source>
          <target state="translated">새 명령 &quot;.backup&quot;및 &quot;.restore&quot;를 &lt;a href=&quot;cli&quot;&gt;CLI에 추가했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b636e1930793301d407d0d74d8b0aa8cb970ae" translate="yes" xml:space="preserve">
          <source>Added new commands &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusschemaused&quot;&gt;SQLITE_DBSTATUS_SCHEMA_USED&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusstmtused&quot;&gt;SQLITE_DBSTATUS_STMT_USED&lt;/a&gt; to the &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface, in order to report out the amount of memory used to hold the schema and prepared statements of a connection.</source>
          <target state="translated">스키마를 보유하는 데 사용되는 메모리 양과 연결 준비된 명령문을보고하기 위해 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 새 명령 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusschemaused&quot;&gt;SQLITE_DBSTATUS_SCHEMA_USED&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusstmtused&quot;&gt;SQLITE_DBSTATUS_STMT_USED&lt;/a&gt; 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="f8dfe8f26d08433a24df679977a760d4f646d3d2" translate="yes" xml:space="preserve">
          <source>Added new extended error codes for all SQLITE_CONSTRAINT errors</source>
          <target state="translated">모든 SQLITE_CONSTRAINT 오류에 대한 새로운 확장 오류 코드 추가</target>
        </trans-unit>
        <trans-unit id="5688bbdc29e537f15ce91e77d0144288a884fe89" translate="yes" xml:space="preserve">
          <source>Added new functions: &lt;b&gt;round()&lt;/b&gt; and &lt;b&gt;abs()&lt;/b&gt;.</source>
          <target state="translated">&lt;b&gt;round ()&lt;/b&gt; 및 &lt;b&gt;abs ()&lt;/b&gt; 새로운 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d0329da0075f52ea225b62d5bf9417d8dcd00a71" translate="yes" xml:space="preserve">
          <source>Added new interfaces with 64-bit length parameters: &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc64()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob64()&lt;/a&gt;, &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob64()&lt;/a&gt;, &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text64()&lt;/a&gt;, and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_text64()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc64 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob64 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_blob64 ()&lt;/a&gt; , &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text64 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_text64 ()&lt;/a&gt; 와 같은 64 비트 길이 매개 변수가있는 새 인터페이스가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="64cc3fb84831f2e27cea592dad28ee0dfb47e000" translate="yes" xml:space="preserve">
          <source>Added new methods &lt;a href=&quot;tclsqlite#backup&quot;&gt;backup&lt;/a&gt; and &lt;a href=&quot;tclsqlite#restore&quot;&gt;restore&lt;/a&gt; to the TCL interface.</source>
          <target state="translated">TCL 인터페이스에 새로운 메소드 &lt;a href=&quot;tclsqlite#backup&quot;&gt;백업&lt;/a&gt; 및 &lt;a href=&quot;tclsqlite#restore&quot;&gt;복원&lt;/a&gt; 이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f026a440b97b07d3a085b4f6c26cd70cd6721d81" translate="yes" xml:space="preserve">
          <source>Added new operators: &lt;b&gt;&amp;amp;&lt;/b&gt; (bitwise-and) &lt;b&gt;|&lt;/b&gt; (bitwise-or), &lt;b&gt;~&lt;/b&gt; (ones-complement), &lt;b&gt;&amp;lt;&amp;lt;&lt;/b&gt; (shift left), &lt;b&gt;&amp;gt;&amp;gt;&lt;/b&gt; (shift right).</source>
          <target state="translated">새로운 연산자 추가 : &lt;b&gt;&amp;amp;&lt;/b&gt; (비트 단위) &lt;b&gt;| &lt;/b&gt;(비트 단위), &lt;b&gt;~&lt;/b&gt; (1 보수), &lt;b&gt;&amp;lt;&amp;lt;&lt;/b&gt; (왼쪽 시프트), &lt;b&gt;&amp;gt;&amp;gt;&lt;/b&gt; (오른쪽 시프트).</target>
        </trans-unit>
        <trans-unit id="de14b01c9e35bbb7629521f6a50271a7ccde1b67" translate="yes" xml:space="preserve">
          <source>Added new tests for &lt;b&gt;sqlite_complete()&lt;/b&gt; and for memory leaks.</source>
          <target state="translated">&lt;b&gt;sqlite_complete ()&lt;/b&gt; 및 메모리 누수에 대한 새로운 테스트가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c20dd22d769d6a0327cc8caabe7593808b2f880b" translate="yes" xml:space="preserve">
          <source>Added notes on how to compile for Windows95/98.</source>
          <target state="translated">Windows95 / 98 용 컴파일 방법에 대한 메모가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8b3777e6498a05a9cf616db470b108348609eefe" translate="yes" xml:space="preserve">
          <source>Added options &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachehit&quot;&gt;SQLITE_DBSTATUS_CACHE_HIT&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachemiss&quot;&gt;SQLITE_DBSTATUS_CACHE_MISS&lt;/a&gt; to the &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">추가 옵션 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachehit&quot;&gt;SQLITE_DBSTATUS_CACHE_HIT&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachemiss&quot;&gt;SQLITE_DBSTATUS_CACHE_MISS&lt;/a&gt; 받는 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f2bcb2d14872cd27ad8179b401d41712f3826ac8" translate="yes" xml:space="preserve">
          <source>Added pattern matching to the &quot;.table&quot; command in the &quot;sqlite&quot; command shell.</source>
          <target state="translated">&quot;sqlite&quot;명령 쉘의 &quot;.table&quot;명령과 일치하는 패턴을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="dd7fdec30649f808ade235da9f1d9bfc39928676" translate="yes" xml:space="preserve">
          <source>Added special column names ROWID, OID, and _ROWID_ that refer to the unique random integer key associated with every row of every table.</source>
          <target state="translated">모든 테이블의 모든 행과 관련된 고유 한 임의의 정수 키를 참조하는 특수 열 이름 ROWID, OID 및 _ROWID_를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="3d0fd30f1cefc34648f44fd621d0ab7f5704b046" translate="yes" xml:space="preserve">
          <source>Added superfluous casts and variable initializations in order to suppress nuisance compiler warnings.</source>
          <target state="translated">불필요한 컴파일러 경고를 억제하기 위해 불필요한 캐스트 및 변수 초기화가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e8034fb730a94e978b35dda6f4f886fe746b86bb" translate="yes" xml:space="preserve">
          <source>Added support for &quot;Proxy Locking&quot; on Mac OS X.</source>
          <target state="translated">Mac OS X에서 &quot;프록시 잠금&quot;에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1a768a274150328fc95ef914aa94e10888b14001" translate="yes" xml:space="preserve">
          <source>Added support for &quot;sz=NNN&quot; parameters at the end of &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1.stat&lt;/a&gt; fields used to specify the average length in bytes for table and index rows.</source>
          <target state="translated">테이블 및 인덱스 행의 평균 길이를 바이트 단위로 지정하는 데 사용되는 &lt;a href=&quot;fileformat2#stat1tab&quot;&gt;sqlite_stat1.stat&lt;/a&gt; 필드 끝에 &quot;sz = NNN&quot;매개 변수에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c5d796f1bc1788a94bdc0f744f6885401132b83b" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;c3ref/blob_open&quot;&gt;Incremental BLOB I/O&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/blob_open&quot;&gt;Incremental BLOB I / O&lt;/a&gt; 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c77bdf718a836eec40d5cc2bd3bd76b51bd6ed19" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigmaindbname&quot;&gt;SQLITE_DBCONFIG_MAINDBNAME&lt;/a&gt; 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d912639164fbfa089f0b32366f17a5c6aa911805" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4에&lt;/a&gt; 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="a7df61cc46e1a14c31ecf305ec5b3cdc2ad14931" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;expridx&quot;&gt;indexes on expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;expridx&quot;&gt;표현식에&lt;/a&gt; 대한 인덱스 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ccee6fe1568710feac231d9b82d4b7116c357c1f" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. Foreign key constraints are disabled by default. Use the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt; to turn them on.</source>
          <target state="translated">&lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건에&lt;/a&gt; 대한 지원이 추가되었습니다 . 외래 키 제약 조건은 기본적으로 비활성화되어 있습니다. &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;foreign_keys pragma&lt;/a&gt; 를 사용하여 켜십시오.</target>
        </trans-unit>
        <trans-unit id="57d3823a31c3d971b8257b18cfb2e7dd4e9220f5" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;fts3#*fts4compression&quot;&gt;compressed FTS4 content&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4compression&quot;&gt;압축 FTS4 컨텐츠에&lt;/a&gt; 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="c4787e7cb7c644f741f21a4cb4f977bb669f1d4c" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; and enhancements to the FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4&quot;&gt;FTS4에&lt;/a&gt; 대한 지원이 추가 되고 FTS &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 기능이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6092d378933e07269403fd4dd90531c8858f1c75" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;International Components for Unicode (ICU)&lt;/a&gt; to the full-text search extensions.</source>
          <target state="translated">전체 텍스트 검색 확장에 &lt;a href=&quot;http://www.icu-project.org/&quot;&gt;ICU (International Components for Unicode)&lt;/a&gt; 에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b494fc9ecd0ea1218a4c28e118fe3101d154372d" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;lang_analyze#approx&quot;&gt;approximate ANALYZE&lt;/a&gt; using the &lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_analysis_limit&quot;&gt;PRAGMA analysis_limit&lt;/a&gt; 명령을 사용하여 &lt;a href=&quot;lang_analyze#approx&quot;&gt;대략적인 ANALYZE에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1f5facc051f99921d391afa4e3643b439a064280" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;lang_expr#hexint&quot;&gt;hexadecimal integer literals&lt;/a&gt; in the SQL parser. (Ex: 0x123abc)</source>
          <target state="translated">SQL 파서에서 &lt;a href=&quot;lang_expr#hexint&quot;&gt;16 진 정수 리터럴&lt;/a&gt; 에 대한 지원이 추가되었습니다 . (예 : 0x123abc)</target>
        </trans-unit>
        <trans-unit id="3f5a1e3af94d119995760c36810093890d689e97" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt;, &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt;, and &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; operators on &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; , &lt;a href=&quot;lang_expr#glob&quot;&gt;GLOB&lt;/a&gt; 및 &lt;a href=&quot;lang_expr#regexp&quot;&gt;REGEXP&lt;/a&gt; 연산자에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="2b5ae11919833702f8097527352d77974e85a4c5" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameters&lt;/a&gt; and the &lt;a href=&quot;cli#param&quot;&gt;.parameter command&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수&lt;/a&gt; 및 &lt;a href=&quot;cli#param&quot;&gt;.parameter 명령에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="da287db3ef9d940ef6e06049e899a3255c626579" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;lang_savepoint&quot;&gt;nested transactions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;lang_savepoint&quot;&gt;중첩 트랜잭션에&lt;/a&gt; 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="57b0cb14c26129da9af31340671c9b3ff8e5ccca" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;lang_with&quot;&gt;common table expressions&lt;/a&gt; and the &lt;a href=&quot;lang_with&quot;&gt;WITH clause&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_with&quot;&gt;공통 테이블 표현식&lt;/a&gt; 및 &lt;a href=&quot;lang_with&quot;&gt;WITH 절에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a3dc90ea23f1ee6a95938b67f9463a536aa9aa65" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt; Incremental Vacuum&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;증분 진공에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="098e47061ac752cad3c4f0dd71b4386b546c1923" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;queryplanner#partialsort&quot;&gt;partial sorting by index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;queryplanner#partialsort&quot;&gt;인덱스에 의한 부분 정렬&lt;/a&gt; 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5852f13702a3f6d2950690e297970675461ddffd" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;rowvalue&quot;&gt;row values&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rowvalue&quot;&gt;행 값에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9304a1ae7bcff7f9d0294fd922fb7902290e9b40" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;rtree#customquery&quot;&gt;custom r-tree queries&lt;/a&gt; using application-supplied callback routines to define the boundary of the query region.</source>
          <target state="translated">응용 프로그램 제공 콜백 루틴을 사용하여 &lt;a href=&quot;rtree#customquery&quot;&gt;사용자 정의 r- 트리 쿼리에&lt;/a&gt; 대한 지원을 추가 하여 쿼리 영역의 경계를 정의했습니다.</target>
        </trans-unit>
        <trans-unit id="38862a5dbb5ef062dda0972b971e23cd8f009ced" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;shortnames&quot;&gt;short filenames&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;shortnames&quot;&gt;짧은 파일 이름에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0678942ca70cc2234b4d6948778baf5cfae7a7b8" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;vtab#epovtab&quot;&gt;eponymous virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#epovtab&quot;&gt;시상 가상 테이블에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f743bdcce78a1dddfc4dc927a772db18d15b9bd9" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; in the FROM clause of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문의 FROM 절에 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="28342e05a28a19c9120653536a77b2d3b8ecfa3f" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual tables&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID 가상 테이블에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e30cf1fb4cdcf9dd548c26ae0e68c541d4720f1d" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;wal&quot;&gt;write-ahead logging&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;미리 쓰기 로깅에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f2a37e36b173d50699a7a383daf4808cca9005f3" translate="yes" xml:space="preserve">
          <source>Added support for &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables.</source>
          <target state="translated">&lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="aaa626c013ccfe7078969d1a2418f195260916f5" translate="yes" xml:space="preserve">
          <source>Added support for &lt;b&gt;GROUP BY&lt;/b&gt; and &lt;b&gt;HAVING&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;GROUP BY&lt;/b&gt; 및 &lt;b&gt;HAVING에&lt;/b&gt; 대한 지원 추가&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="23c6378ca8e0385b32d8c34595a31f9e34896f43" translate="yes" xml:space="preserve">
          <source>Added support for &lt;b&gt;IN&lt;/b&gt; and &lt;b&gt;BETWEEN&lt;/b&gt; operators</source>
          <target state="translated">&lt;b&gt;IN&lt;/b&gt; 및 &lt;b&gt;BETWEEN&lt;/b&gt; 연산자에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="39906a48ce3fe7d0519d7138f444bf5e0f5d0c4e" translate="yes" xml:space="preserve">
          <source>Added support for &lt;b&gt;SELECT DISTINCT ...&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;SELECT DISTINCT&lt;/b&gt; 지원 추가 &lt;b&gt;...&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="4d369d287f216943320eb1cf4c8784d883517fcc" translate="yes" xml:space="preserve">
          <source>Added support for ALTER TABLE ADD COLUMN.</source>
          <target state="translated">ALTER TABLE ADD COLUMN에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="f61dc3bfef1b0fb9159060519a3d5996919b7cdf" translate="yes" xml:space="preserve">
          <source>Added support for CASE expressions (patch from Dan Kennedy)</source>
          <target state="translated">CASE 표현식 지원 (Dan Kennedy의 패치)</target>
        </trans-unit>
        <trans-unit id="5ef50e566503d5ec6fc8c4206728cad99f6ab4e0" translate="yes" xml:space="preserve">
          <source>Added support for COUNT(DISTINCT expr)</source>
          <target state="translated">COUNT (DISTINCT expr)에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="4f1a1db14256e94e83a51e328f837e192ca0c2b7" translate="yes" xml:space="preserve">
          <source>Added support for CREATE TABLE AS SELECT</source>
          <target state="translated">CREATE TABLE AS SELECT에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="f480cd382ac5c6dd6874aa6a99de254caa5bd680" translate="yes" xml:space="preserve">
          <source>Added support for IF EXISTS on CREATE/DROP TRIGGER/VIEW</source>
          <target state="translated">CREATE / DROP TRIGGER / VIEW에서 IF EXISTS 지원 추가</target>
        </trans-unit>
        <trans-unit id="802bbd8e68481149017b168987b2b6dcf3e3f523" translate="yes" xml:space="preserve">
          <source>Added support for TEMP triggers and indices.</source>
          <target state="translated">TEMP 트리거 및 인덱스에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="aecb8ed5eb711ab5bc883c11daa59ac6b2d5ce62" translate="yes" xml:space="preserve">
          <source>Added support for TEMPORARY tables and indices.</source>
          <target state="translated">TEMPORARY 테이블 및 인덱스에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d8ec5d1af662afdc6e8cea0faa53d9548a3715c" translate="yes" xml:space="preserve">
          <source>Added support for VIEWs.</source>
          <target state="translated">VIEW에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7d8cf0f737beb23e6e9108cf9c8ba695b902478" translate="yes" xml:space="preserve">
          <source>Added support for Windows Phone 8 platforms</source>
          <target state="translated">Windows Phone 8 플랫폼에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="156d52498375f646744777537d1b8661c3748353" translate="yes" xml:space="preserve">
          <source>Added support for aggregate functions (Ex: &lt;b&gt;COUNT(*)&lt;/b&gt;, &lt;b&gt;MIN(...)&lt;/b&gt;) to the SELECT statement.</source>
          <target state="translated">SELECT 문 에 집계 함수 (Ex : &lt;b&gt;COUNT (*)&lt;/b&gt; , &lt;b&gt;MIN (...)&lt;/b&gt; )에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="59adb1923dce593e20f6cdd76d1aad57f9b3c08b" translate="yes" xml:space="preserve">
          <source>Added support for default values on columns of a table.</source>
          <target state="translated">테이블의 열에 대한 기본값 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="da71dda5aa64971e5509406d2038fc8ff0a58226" translate="yes" xml:space="preserve">
          <source>Added support for dynamically loaded extensions (beta)</source>
          <target state="translated">동적으로로드 된 확장 (베타)에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="2caaf5d365573dc0f505bc362a8d1a5cfa8a2a47" translate="yes" xml:space="preserve">
          <source>Added support for exclusive access mode using &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt; &quot;PRAGMA locking_mode=EXCLUSIVE&quot;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;&quot;PRAGMA locking_mode = EXCLUSIVE&quot;를&lt;/a&gt; 사용하여 독점 액세스 모드 지원 추가</target>
        </trans-unit>
        <trans-unit id="edfbd1d9a982b614144ea7761b02cfc7f2dbb5f8" translate="yes" xml:space="preserve">
          <source>Added support for grave-accent quoting for compatibility with MySQL</source>
          <target state="translated">MySQL과의 호환성을 위해 억음 악센트 인용 지원 추가</target>
        </trans-unit>
        <trans-unit id="22bbd337e6061caadf8960bdff6dde0fe2e1ce00" translate="yes" xml:space="preserve">
          <source>Added support for in-memory databases.</source>
          <target state="translated">인 메모리 데이터베이스에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="269e7f8bd5682bfd59fdb502a94ab258bd85c346" translate="yes" xml:space="preserve">
          <source>Added support for new functions: &lt;b&gt;coalesce()&lt;/b&gt;, &lt;b&gt;lower()&lt;/b&gt;, &lt;b&gt;upper()&lt;/b&gt;, and &lt;b&gt;random()&lt;/b&gt;</source>
          <target state="translated">새로운 기능에 대한 지원 추가 : &lt;b&gt;coalesce ()&lt;/b&gt; , &lt;b&gt;lower ()&lt;/b&gt; , &lt;b&gt;upper ()&lt;/b&gt; 및 &lt;b&gt;random ()&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="714630549f890ebcea85844393f6d39effdd678c" translate="yes" xml:space="preserve">
          <source>Added support for parentheses in FTS3 query patterns using the &lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; 컴파일 타임 옵션을 사용하여 FTS3 쿼리 패턴에서 괄호에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f0eb5b5e0bf2134ccfb6085dc04cfe49a2b50cb2" translate="yes" xml:space="preserve">
          <source>Added support for read-only &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; when the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; option is enabled.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 옵션이 사용 가능한 경우 읽기 전용 &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f5328ffada12715fa1740f8ed07ec5f56e3e6e11" translate="yes" xml:space="preserve">
          <source>Added support for reading and writing &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; files using the &lt;a href=&quot;cli#sqlar&quot;&gt;.archive command&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#sqlar&quot;&gt;.archive 명령을&lt;/a&gt; 사용하여 &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive&lt;/a&gt; 파일 을 읽고 쓰는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d83a93fa67e821fa39cee2c0269a9594a2b7048d" translate="yes" xml:space="preserve">
          <source>Added support for row triggers.</source>
          <target state="translated">행 트리거에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7d546045a17d60665f8f36d2355b1056f5514277" translate="yes" xml:space="preserve">
          <source>Added support for sub-queries in the FROM clause of a SELECT.</source>
          <target state="translated">SELECT의 FROM 절에서 하위 쿼리에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5baf8f3125a1b4ab71c92fa8a5439c0508a7b6ff" translate="yes" xml:space="preserve">
          <source>Added support for the &quot;T&quot; separator in ISO-8601 date/time strings.</source>
          <target state="translated">ISO-8601 날짜 / 시간 문자열에서 &quot;T&quot;구분 기호에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="725493f315496bd1f2f4a13c4ac5b992869c96d8" translate="yes" xml:space="preserve">
          <source>Added support for the &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql()&lt;/a&gt; interface, when compiling with SQLITE_ENABLE_NORMALIZE.</source>
          <target state="translated">SQLITE_ENABLE_NORMALIZE로 컴파일 할 때 &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_normalized_sql ()&lt;/a&gt; 인터페이스에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="498b965855c0df0c65ab77d01077c70c3176df7c" translate="yes" xml:space="preserve">
          <source>Added support for the &lt;a href=&quot;fts3#*fts4languageid&quot;&gt;FTS4 languageid option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4languageid&quot;&gt;FTS4 languageid 옵션에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5bebd7419f01257793b74d6f7189da20f77e3cdd" translate="yes" xml:space="preserve">
          <source>Added support for the &lt;a href=&quot;fts3#fts4prefix&quot;&gt;FTS4 prefix option&lt;/a&gt; and the &lt;a href=&quot;fts3#fts4order&quot;&gt;FTS4 order option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4prefix&quot;&gt;FTS4 접두사 옵션&lt;/a&gt; 및 &lt;a href=&quot;fts3#fts4order&quot;&gt;FTS4 주문 옵션에&lt;/a&gt; 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a61e8713611aa7f646e2e630cf8669d823feec59" translate="yes" xml:space="preserve">
          <source>Added support for the &lt;a href=&quot;fts5#carrotq&quot;&gt;&quot;^&quot; initial token syntax&lt;/a&gt; in FTS5.</source>
          <target state="translated">FTS5에서 &lt;a href=&quot;fts5#carrotq&quot;&gt;&quot;^&quot;초기 토큰 구문&lt;/a&gt; 에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="63f525fb27345b220e85e4b1882d1f850d9fd641" translate="yes" xml:space="preserve">
          <source>Added support for the CAST operator</source>
          <target state="translated">CAST 연산자에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="04fad2e75b780f1e57df3facebce6367bd600478" translate="yes" xml:space="preserve">
          <source>Added support for user-defined functions implemented in C.</source>
          <target state="translated">C로 구현 된 사용자 정의 함수에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="5fd469aa2c2d142386dbb22e08493982d3a3c0cf" translate="yes" xml:space="preserve">
          <source>Added support for using &lt;b&gt;(SELECT ...)&lt;/b&gt; within expressions</source>
          <target state="translated">표현식 내에서 &lt;b&gt;(SELECT ...)&lt;/b&gt; 사용에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="9dbdc56037dd11ba01c820085bfc64d7a45c048d" translate="yes" xml:space="preserve">
          <source>Added support for virtual tables (beta)</source>
          <target state="translated">가상 테이블 (베타)에 대한 지원 추가</target>
        </trans-unit>
        <trans-unit id="5a11c44e956f0b2eed596db722d97e53d70a1408" translate="yes" xml:space="preserve">
          <source>Added the &quot;#-N&quot; array notation for &lt;a href=&quot;json1#jsonpath&quot;&gt;JSON function path arguments&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;json1#jsonpath&quot;&gt;JSON 함수 경로 인수에&lt;/a&gt; 대한 &quot;# -N&quot;배열 표기법이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ef53cbf2e79a9098a11853089aaa8d3c0fdee6d1" translate="yes" xml:space="preserve">
          <source>Added the &quot;%Q&quot; expansion to sqlite_*_printf().</source>
          <target state="translated">sqlite _ * _ printf ()에 &quot;% Q&quot;확장을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="d19a5fb60f5adeafbe53fbf0afc64944745e9a28" translate="yes" xml:space="preserve">
          <source>Added the &quot;--indent&quot; option to the &quot;.schema&quot; and &quot;.fullschema&quot; commands of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, to turn on pretty-printing.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 의 &quot;.schema&quot;및 &quot;.fullschema&quot;명령에 &quot;--indent&quot;옵션을 추가하여 예쁘게 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbed788f58b78e99986ec814826250aabd00b5f8" translate="yes" xml:space="preserve">
          <source>Added the &quot;--newlines&quot; option to the &quot;&lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt;&quot; command to cause U+000a and U+000d characters to be output literally rather than escaped using the &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace ()&lt;/a&gt; 함수를 사용하여 U + 000a 및 U + 000d 문자를 이스케이프 처리하지 않고 문자 그대로 출력 하도록 &quot; &lt;a href=&quot;cli#dump&quot;&gt;.dump&lt;/a&gt; &quot;명령에 &quot;--newlines&quot;옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="4d540026cb1605d53141475378c06aed40694ee4" translate="yes" xml:space="preserve">
          <source>Added the &quot;--transaction&quot; option to &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff에&lt;/a&gt; &quot;--transaction&quot;옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="478aa7b2f50ff9f66c73e09765475623c1296d17" translate="yes" xml:space="preserve">
          <source>Added the &quot;-echo&quot; option to the shell.</source>
          <target state="translated">쉘에 &quot;-echo&quot;옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="8299146bfa027dbb559bc3d23457ff833b781801" translate="yes" xml:space="preserve">
          <source>Added the &quot;-heap&quot; option to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸에&lt;/a&gt; &quot;-heap&quot;옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="dfd798caa17668bf08f6cc875f2f20a116ec83ed" translate="yes" xml:space="preserve">
          <source>Added the &quot;-sourceid&quot; option to the &quot;sqlite3&quot; command.</source>
          <target state="translated">&quot;sqlite3&quot;명령에 &quot;-sourceid&quot;옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="20b758a047367c847e236a7d6e0ee3c1b4474249" translate="yes" xml:space="preserve">
          <source>Added the &quot;.auth ON|OFF&quot; command to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.auth ON | OFF&quot;명령을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="940607a7aa26e4eb8956b707dcdaed3399cf8e2b" translate="yes" xml:space="preserve">
          <source>Added the &quot;.bail&quot; command to the command-line shell</source>
          <target state="translated">&quot;.bail&quot;명령을 명령 행 쉘에 추가했습니다</target>
        </trans-unit>
        <trans-unit id="3bc22cc03bccb3a5998ffd80255b3094a2a899a7" translate="yes" xml:space="preserve">
          <source>Added the &quot;.changes ON|OFF&quot; and &quot;.vfsinfo&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-commands&lt;/a&gt;.</source>
          <target state="translated">&quot;.changes ON | OFF&quot;및 &quot;.vfsinfo&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;도트 명령이 추가되었습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09be07a1075c82f137355e04fdda8ba46481b558" translate="yes" xml:space="preserve">
          <source>Added the &quot;.dbconfig&quot; command</source>
          <target state="translated">&quot;.dbconfig&quot;명령 추가</target>
        </trans-unit>
        <trans-unit id="b530795e109b90659ae4200c9b9587d5f7062df4" translate="yes" xml:space="preserve">
          <source>Added the &quot;.dbconfig&quot; command.</source>
          <target state="translated">&quot;.dbconfig&quot;명령이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="71435fab5cdfaf1ac01d7010f6e9ba64d0dc7ff6" translate="yes" xml:space="preserve">
          <source>Added the &quot;.dbinfo&quot; command to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&quot;.dbinfo&quot;명령을 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘에 추가했습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e44bed98bc9ffcac82331aa66719ea4a5d15e106" translate="yes" xml:space="preserve">
          <source>Added the &quot;.eqp full&quot; option to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, that does both &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; on each statement that is evaluated.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘에&lt;/a&gt; &quot;.eqp full&quot;옵션을 추가하여 평가되는 각 명령문에서 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 및 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 을 모두 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="bc76269d710537ecfa607d27057feb111d2f5738" translate="yes" xml:space="preserve">
          <source>Added the &quot;.eqp trigger&quot; variant of the &quot;.eqp&quot; command</source>
          <target state="translated">&quot;.eqp&quot;명령의 &quot;.eqp 트리거&quot;변형 추가</target>
        </trans-unit>
        <trans-unit id="4db11420723106d62b97b1cddde4d80a86b6d3b9" translate="yes" xml:space="preserve">
          <source>Added the &quot;.print&quot; command</source>
          <target state="translated">&quot;.print&quot;명령 추가</target>
        </trans-unit>
        <trans-unit id="2e7ac74eb8ba91a3704bc76910d5bdd08a822466" translate="yes" xml:space="preserve">
          <source>Added the &quot;.timer&quot; command to the CLI</source>
          <target state="translated">&quot;.timer&quot;명령을 CLI에 추가했습니다</target>
        </trans-unit>
        <trans-unit id="e4061075559d28d8e4ed816bdd15c79dc564dc7a" translate="yes" xml:space="preserve">
          <source>Added the &quot;.trace&quot; dot-command to the command-line shell.</source>
          <target state="translated">&quot;.trace&quot;도트 명령을 명령 행 셸에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="aadf72f23a2ada14e4167774049503cfd395b448" translate="yes" xml:space="preserve">
          <source>Added the &quot;.vfslist&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;dot-command&lt;/a&gt;.</source>
          <target state="translated">&quot;.vfslist&quot; &lt;a href=&quot;cli#dotcmd&quot;&gt;도트 명령이&lt;/a&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0d70605741bcb27d28026147f94d6cd602433b0f" translate="yes" xml:space="preserve">
          <source>Added the &quot;&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/dbdata.c&quot;&gt;sqlite_dbdata&lt;/a&gt;&quot; virtual table for extracting raw low-level content from an SQLite database, even a database that is corrupt.</source>
          <target state="translated">SQLite 데이터베이스에서 손상된 하위 데이터베이스까지 원시 하위 레벨 컨텐츠를 추출하기 위해 &quot; &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/dbdata.c&quot;&gt;sqlite_dbdata&lt;/a&gt; &quot;가상 테이블을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d2ea4e959435eb02b355c49cbea6f7bc7d2b3ef5" translate="yes" xml:space="preserve">
          <source>Added the &quot;&lt;a href=&quot;uri#urimodeof&quot;&gt;modeof=&lt;i&gt;filename&lt;/i&gt;&lt;/a&gt;&quot; URI parameter on the unix VFS</source>
          <target state="translated">유닉스 VFS에 &quot; &lt;a href=&quot;uri#urimodeof&quot;&gt;modeof = &lt;i&gt;filename&lt;/i&gt;&lt;/a&gt; &quot;URI 매개 변수 추가</target>
        </trans-unit>
        <trans-unit id="8283f3eb012777e892f47004d1b706afd30de071" translate="yes" xml:space="preserve">
          <source>Added the &quot;EXTRA&quot; option to &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; that does a sync of the containing directory when a rollback journal is unlinked in DELETE mode, for better durability. The &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; compile-time option enables &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=EXTRA&lt;/a&gt; by default.</source>
          <target state="translated">내구성 향상을 위해 롤백 저널이 DELETE 모드에서 링크 해제 될 때 포함 디렉토리의 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;동기화&lt;/a&gt; 를 수행하는 PRAGMA 동기에 &quot;EXTRA&quot;옵션이 추가되었습니다 . &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; 컴파일시 옵션을 가능하게 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기 = EXTRA를&lt;/a&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="9e0605f79be49e0270c61cb5b9dfa4647f4728a0" translate="yes" xml:space="preserve">
          <source>Added the &quot;bitvec&quot; object for keeping track of which pages have been journalled. Improves speed and reduces memory consumption, especially for large database files.</source>
          <target state="translated">저널링 된 페이지를 추적하기 위해 &quot;bitvec&quot;오브젝트를 추가했습니다. 특히 대용량 데이터베이스 파일의 경우 속도를 향상시키고 메모리 소비를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="8c6dbbfeafc55121e8fcf541554220fbbb17e684" translate="yes" xml:space="preserve">
          <source>Added the &quot;case_sensitive_like&quot; pragma and the SQLITE_CASE_SENSITIVE_LIKE compile-time option to set its default value to &quot;on&quot;.</source>
          <target state="translated">&quot;case_sensitive_like&quot;pragma 및 SQLITE_CASE_SENSITIVE_LIKE 컴파일 타임 옵션을 추가하여 기본값을 &quot;on&quot;으로 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="eb193ea8cf898f73b58007ba9543b807b3854870" translate="yes" xml:space="preserve">
          <source>Added the &quot;percentile()&quot; function as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; in the ext/misc subdirectory of the source tree.</source>
          <target state="translated">&quot;percentile ()&quot;함수를 소스 트리의 ext / misc 하위 디렉토리에 &lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장으로 추가&lt;/a&gt; 했습니다.</target>
        </trans-unit>
        <trans-unit id="5611b9f6138afb0064fc4e62d5516726fcbf742e" translate="yes" xml:space="preserve">
          <source>Added the &quot;transaction&quot; method to the Tcl interface</source>
          <target state="translated">Tcl 인터페이스에 &quot;트랜잭션&quot;메소드 추가</target>
        </trans-unit>
        <trans-unit id="1bef58aa7bf5fa4ae3d0cfd6f4672ac479bf0763" translate="yes" xml:space="preserve">
          <source>Added the &quot;unix-excl&quot; built-in VFS on unix and unix-like platforms.</source>
          <target state="translated">유닉스 및 유닉스 계열 플랫폼에 &quot;unix-excl&quot;내장 VFS를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="fd67f2b6106389654227f8b92e474aef42afe028" translate="yes" xml:space="preserve">
          <source>Added the &quot;win32-none&quot; VFS, analogous to the &quot;unix-none&quot; VFS, that works like the default &quot;win32&quot; VFS except that it ignores all file locks.</source>
          <target state="translated">&quot;unix-none&quot;VFS와 유사한 &quot;win32-none&quot;VFS를 추가하여 모든 파일 잠금을 무시한다는 점을 제외하고 기본 &quot;win32&quot;VFS와 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="badfd05b3b5c28b37d6844c2c9da5b634785d36b" translate="yes" xml:space="preserve">
          <source>Added the --append option to the &quot;.backup&quot; command.</source>
          <target state="translated">&quot;.backup&quot;명령에 --append 옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="46228df7212ca1bca7bba47d433ba46ed3b8c9d9" translate="yes" xml:space="preserve">
          <source>Added the --enable-editline and --enable-static-shell options to the various autoconf-generated configure scripts.</source>
          <target state="translated">다양한 autoconf 생성 구성 스크립트에 --enable-editline 및 --enable-static-shell 옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="40bfc9f24ea3e7bc19fd8e19fb2ea5316c41113c" translate="yes" xml:space="preserve">
          <source>Added the --new option to the &quot;.open&quot; dot-command, causing any prior content in the database to be purged prior to opening.</source>
          <target state="translated">&quot;.open&quot;도트 명령에 --new 옵션을 추가하여 데이터베이스의 이전 내용을 열기 전에 제거합니다.</target>
        </trans-unit>
        <trans-unit id="98f31449b9f6901e8d5bc307f552648c8c9f60ad" translate="yes" xml:space="preserve">
          <source>Added the -A command-line option to the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; to make it easier to manage &lt;a href=&quot;sqlar&quot;&gt;SQLite Archive files&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;sqlar&quot;&gt;SQLite Archive 파일을&lt;/a&gt; 보다 쉽게 ​​관리 할 수 ​​있도록 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 에 -A 명령 줄 옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3ab6c1327f76f890e520a0110e775c0d686745d7" translate="yes" xml:space="preserve">
          <source>Added the -D&lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt;=</source>
          <target state="translated">-D &lt;a href=&quot;compile#max_memory&quot;&gt;SQLITE_MAX_MEMORY&lt;/a&gt; = 추가</target>
        </trans-unit>
        <trans-unit id="5367ce2c93bb38a095b36e1fed991b9fb4d889ac" translate="yes" xml:space="preserve">
          <source>Added the -returntype option to the &lt;a href=&quot;tclsqlite#function&quot;&gt;function method&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;tclsqlite#function&quot;&gt;함수 메소드에&lt;/a&gt; -returntype 옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="e93bb7d2fcd01a6f436bdc9a5880040e6f97639d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;bytecodevtab&quot;&gt;bytecode virtual table&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bytecodevtab&quot;&gt;바이트 코드 가상 테이블을&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="0c8fe56b695cf00317baad779130870ca95a81df" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;hot-backup interface&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/backup_finish#sqlite3backupinit&quot;&gt;핫 백업 인터페이스를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a89f10c162ecc008c3e13971bca30f64a17a50" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_zeroblob()&lt;/a&gt; API and the &lt;a href=&quot;lang_expr#zeroblob&quot;&gt;zeroblob()&lt;/a&gt; SQL function.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_zeroblob ()&lt;/a&gt; API와 &lt;a href=&quot;lang_expr#zeroblob&quot;&gt;zeroblob ()&lt;/a&gt; SQL 함수를.</target>
        </trans-unit>
        <trans-unit id="77121aeb8c2408e6e7a1a0e10e0b563a3977d08d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface to allow an existing &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; object to be rebound to a new row.</source>
          <target state="translated">기존 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 객체를 새 행으로 리 바인드 할 수 있도록 &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="55608cf2764566ce89f4e1034e4a2042979d3f0d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface, with corresponding enhancements to &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA wal_checkpoint&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/c_checkpoint_full&quot;&gt;SQLITE_CHECKPOINT_TRUNCATE를&lt;/a&gt; 받는 옵션 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 의 향상된 기능에 대응, 인터페이스를 &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;PRAGMA의 wal_checkpoint&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="24795c7f167ca4977e5c234dc2cbe0a63579121e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; verb to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; to control the default lookaside configuration.</source>
          <target state="translated">기본 lookaside 구성을 제어 하기 위해 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; 동사를 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 에 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="5cb84f5843071fd6a0d0c50960687d9f19b751bd" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt; option to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; which makes it easier for applications to determine the appropriate amount of memory for use with &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpcachehdrsz&quot;&gt;SQLITE_CONFIG_PCACHE_HDRSZ&lt;/a&gt; 옵션을 추가하여 응용 프로그램이 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpagecache&quot;&gt;SQLITE_CONFIG_PAGECACHE&lt;/a&gt; 와 함께 사용할 적절한 메모리 양을 쉽게 결정할 수 있도록합니다 .</target>
        </trans-unit>
        <trans-unit id="78ab457ef12e647bf4dc7ecead1c36d5c4673d12" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; option which disables the ability to create corrupt database files using ordinary SQL.</source>
          <target state="translated">일반 SQL을 사용하여 손상된 데이터베이스 파일을 만들 수없는 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6e71c54907adbe78a8a28fd46aaebb36d69493c1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; for activating and deactivating the &lt;a href=&quot;quirks#dblquote&quot;&gt;double-quoted string literal&lt;/a&gt; misfeature. Both default to &quot;on&quot; for legacy compatibility, but developers are encouraged to turn them &quot;off&quot;, perhaps using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=0&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;quirks#dblquote&quot;&gt;큰 따옴표로 묶인 문자열 리터럴 &lt;/a&gt;&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;오작동&lt;/a&gt; 을 활성화 및 비활성화하기 위해 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 에 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; 및 SQLITE_DBCONFIG_DQS_DDL 작업을 추가했습니다 . 레거시 호환성을 위해 둘 다 기본적으로 &quot;on&quot;으로 설정되지만 개발자는 &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = 0&lt;/a&gt; 컴파일 타임 옵션을 사용하여 &quot;off&quot;로 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d7ad0ef8ac2497ed1aa5f01e1b664e81567669d2" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; which allows the two-argument version of the &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; SQL function to be enabled or disabled at run-time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; 옵션을 추가하여 fts3_tokenizer &lt;a href=&quot;fts3#f3tknzr&quot;&gt;()&lt;/a&gt; SQL 함수 의 두 인수 버전을 런타임에 활성화 또는 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6416a3ba6c9f666e4baee452d3cb91764a92165" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfignockptonclose&quot;&gt;SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfignockptonclose&quot;&gt;SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE&lt;/a&gt; 옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="692b08dd48ff9799615b16dfbc27375f3082dcfb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigresetdatabase&quot;&gt;SQLITE_DBCONFIG_RESET_DATABASE&lt;/a&gt; option to the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; API.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; API에 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigresetdatabase&quot;&gt;SQLITE_DBCONFIG_RESET_DATABASE&lt;/a&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c327f817896429826daa4e2c7ed4c07b63ba0c6d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; connection setting which is also controllable via the new &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;trusted_schema pragma&lt;/a&gt; and at compile-time using the &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigtrustedschema&quot;&gt;SQLITE_DBCONFIG_TRUSTED_SCHEMA&lt;/a&gt; 연결 설정이 추가되었습니다.이 연결 설정은 새로운 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;trusted_schema pragma&lt;/a&gt; 를 통해 그리고 컴파일시 &lt;a href=&quot;compile#trusted_schema&quot;&gt;-DSQLITE_TRUSTED_SCHEMA&lt;/a&gt; 컴파일 시간 옵션을 사용하여 제어 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6daec8b1f14932a0265d49a93345e89fdffd9a4" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigwritableschema&quot;&gt;SQLITE_DBCONFIG_WRITABLE_SCHEMA&lt;/a&gt; verb for the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; interface, that does the same work as &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema&lt;/a&gt; without using the SQL parser.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 인터페이스에 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigwritableschema&quot;&gt;SQLITE_DBCONFIG_WRITABLE_SCHEMA&lt;/a&gt; 동사를 추가했습니다 . SQL 구문 분석기를 사용하지 않고 &lt;a href=&quot;pragma#pragma_writable_schema&quot;&gt;PRAGMA writable_schema&lt;/a&gt; 와 동일한 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="5d750e0c7bb7bb7bec2d0c2a829768642cb54851" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachespill&quot;&gt;SQLITE_DBSTATUS_CACHE_SPILL&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; for reporting the number of cache spills that have occurred.</source>
          <target state="translated">발생한 캐시 유출 수를보고 하기 위해 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 에 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscachespill&quot;&gt;SQLITE_DBSTATUS_CACHE_SPILL&lt;/a&gt; 옵션을 추가 했습니다.</target>
        </trans-unit>
        <trans-unit id="53f2be88cd88e0e32064f44c1119c7bd8eba616a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheusedshared&quot;&gt;SQLITE_DBSTATUS_CACHE_USED_SHARED&lt;/a&gt; option to &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()에 &lt;/a&gt;&lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuscacheusedshared&quot;&gt;SQLITE_DBSTATUS_CACHE_USED_SHARED&lt;/a&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d572c740f2c606b38c1537872052780a90a1967b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasidehit&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_HIT&lt;/a&gt;, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasidemisssize&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE&lt;/a&gt;, and &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasidemissfull&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL&lt;/a&gt; options for the &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status ()&lt;/a&gt; 인터페이스에 대한 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasidehit&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_HIT&lt;/a&gt; , &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasidemisssize&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatuslookasidemissfull&quot;&gt;SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL&lt;/a&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8ff540364583dcc44fa1ef2c4aadebbebd6864c4" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag for &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; to prevent those functions from being used inside triggers and views.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 에 대한 &lt;a href=&quot;c3ref/c_deterministic&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 플래그를 추가하여 해당 함수가 트리거 및 뷰에서 사용되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="f7600d6d8a603816feb6b034aac51cea89c66055" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; flag for &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; to prevent those functions from being used inside triggers and views.</source>
          <target state="translated">&lt;a href=&quot;appfunc&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 에 대한 &lt;a href=&quot;c3ref/c_deterministic#sqlitedirectonly&quot;&gt;SQLITE_DIRECTONLY&lt;/a&gt; 플래그를 추가하여 해당 함수가 트리거 및 뷰 내에서 사용되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="1edde08f9646ef2c3e76ad318411c8fb6e51b64f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; file control, used to allow VFS implementations to get access to the busy handler callback.</source>
          <target state="translated">VFS 구현이 사용중인 핸들러 콜백에 액세스 할 수 있도록 하는 &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlbusyhandler&quot;&gt;SQLITE_FCNTL_BUSYHANDLER&lt;/a&gt; 파일 제어를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="c39ae96ebc2e88dd6b2cd7e2fc1b875ebe3e289c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; verb to the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface for both unix and windows, to cause database files to grow in large chunks in order to reduce disk fragmentation.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlchunksize&quot;&gt;SQLITE_FCNTL_CHUNK_SIZE&lt;/a&gt; verb to the &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt; interface for both unix and windows, to cause database files to grow in large chunks in order to reduce disk fragmentation.</target>
        </trans-unit>
        <trans-unit id="fe950f2e1aef661f6ce9192c747caf6f073c554c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; file-control.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntldataversion&quot;&gt;SQLITE_FCNTL_DATA_VERSION&lt;/a&gt; file-control.</target>
        </trans-unit>
        <trans-unit id="c419db6b4698987a8e91b919db8b97ecb28f7972" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; option to &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlfilepointer&quot;&gt;SQLITE_FCNTL_FILE_POINTER&lt;/a&gt; option to &lt;a href=&quot;c3ref/file_control&quot;&gt;sqlite3_file_control()&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="acf39bdbea0f8885f79a39d332adbbca1cd2395f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; file-control by which the SQLite core indicates to the VFS that the current transaction will overwrite the entire database file.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntloverwrite&quot;&gt;SQLITE_FCNTL_OVERWRITE&lt;/a&gt; file-control by which the SQLite core indicates to the VFS that the current transaction will overwrite the entire database file.</target>
        </trans-unit>
        <trans-unit id="872bfec9dc1a2fcffd8687a9f2be6d01ed62715c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control, giving &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the ability to add new &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements or to override built-in PRAGMAs.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control, giving &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations the ability to add new &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements or to override built-in PRAGMAs.</target>
        </trans-unit>
        <trans-unit id="8a08888203226d0cb933e2381c131bd134f3e0ba" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; file control opcode.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_fcntl_begin_atomic_write#sqlitefcntlwin32gethandle&quot;&gt;SQLITE_FCNTL_WIN32_GET_HANDLE&lt;/a&gt; file control opcode.</target>
        </trans-unit>
        <trans-unit id="2fe9d20a7ecb27f21ed97321987de71e7453d365" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit to the set of bits that can be returned by the xDeviceCharacteristics method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_IMMUTABLE&lt;/a&gt; bit to the set of bits that can be returned by the xDeviceCharacteristics method of a &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="7f843fb220ff24f90a61313273ce94ebe78eaef3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; option to &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command for configuring the number of available worker threads.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitworkerthreads&quot;&gt;SQLITE_LIMIT_WORKER_THREADS&lt;/a&gt; option to &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_threads&quot;&gt;PRAGMA threads&lt;/a&gt; command for configuring the number of available worker threads.</target>
        </trans-unit>
        <trans-unit id="c8e1dea17a78ee539422e7da11345abec026d26c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_VFS1&lt;/a&gt; static mutex and use it in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_mutex_fast&quot;&gt;SQLITE_MUTEX_STATIC_VFS1&lt;/a&gt; static mutex and use it in the Windows &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c9f5d53ac1d13ed7fd23ea322e4248752246fa8d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags for &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; used to override the global &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; settings for individual database connections.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_SHAREDCACHE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_open_autoproxy&quot;&gt;SQLITE_OPEN_PRIVATECACHE&lt;/a&gt; flags for &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; used to override the global &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt; settings for individual database connections.</target>
        </trans-unit>
        <trans-unit id="ee6f319a0408b5352c4ea820f41707cd9f47de22" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenovtab&quot;&gt;SQLITE_PREPARE_NO_VTAB&lt;/a&gt; option to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. Use that option to prevent circular references to &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; from causing resource leaks.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_prepare_normalize#sqlitepreparenovtab&quot;&gt;SQLITE_PREPARE_NO_VTAB&lt;/a&gt; option to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;. Use that option to prevent circular references to &lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt; from causing resource leaks.</target>
        </trans-unit>
        <trans-unit id="98b481e9d7f3d70cd2eecd21d70129ae31ed1963" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt; option to &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_stmtstatus_counter#sqlitestmtstatusvmstep&quot;&gt;SQLITE_STMTSTATUS_VM_STEP&lt;/a&gt; option to &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="173e2525ec3884e959b6bd821ed96525c786e2b2" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_BYTEORDER&lt;/a&gt; test control.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_BYTEORDER&lt;/a&gt; test control.</target>
        </trans-unit>
        <trans-unit id="3d008e63c41f50a70b14a41ab55032164f43f128" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_EXPLAIN_STMT&lt;/a&gt; test-control option with the &lt;a href=&quot;compile#enable_tree_explain&quot;&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/a&gt; compile-time option to enable the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to display ASCII-art parse trees of SQL statements that it processes, for debugging and analysis.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/c_testctrl_always&quot;&gt;SQLITE_TESTCTRL_EXPLAIN_STMT&lt;/a&gt; test-control option with the &lt;a href=&quot;compile#enable_tree_explain&quot;&gt;SQLITE_ENABLE_TREE_EXPLAIN&lt;/a&gt; compile-time option to enable the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to display ASCII-art parse trees of SQL statements that it processes, for debugging and analysis.</target>
        </trans-unit>
        <trans-unit id="6d895d26ed7e55d69a402b7a4c87a8b6ef2550de" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="bfc2c5299cf593550d927e4ff94e7186fd8be0ca" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; interfaces as well as the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; and the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;c3ref/compileoption_get&quot;&gt;sqlite3_compileoption_get()&lt;/a&gt; interfaces as well as the &lt;a href=&quot;pragma#pragma_compile_options&quot;&gt;compile_options pragma&lt;/a&gt; and the &lt;a href=&quot;lang_corefunc#sqlite_compileoption_used&quot;&gt;sqlite_compileoption_used()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#sqlite_compileoption_get&quot;&gt;sqlite_compileoption_get()&lt;/a&gt; SQL functions.</target>
        </trans-unit>
        <trans-unit id="9fb684d2d6c2147c74c80743a4ba8731d23977f3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface for doing run-time configuration of the entire SQLite library.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface for doing run-time configuration of the entire SQLite library.</target>
        </trans-unit>
        <trans-unit id="ec41ecd622afa734ab8f9b12f590344b751a2786" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/create_filename&quot;&gt;sqlite3_create_filename()&lt;/a&gt;, &lt;a href=&quot;c3ref/create_filename&quot;&gt;sqlite3_free_filename()&lt;/a&gt;, and &lt;a href=&quot;c3ref/database_file_object&quot;&gt;sqlite3_database_file_object()&lt;/a&gt; interfaces to better support of &lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; implementations.</source>
          <target state="translated">&lt;a href=&quot;vfs#shim&quot;&gt;VFS shim&lt;/a&gt; 구현 을 더 잘 지원하기 위해 &lt;a href=&quot;c3ref/create_filename&quot;&gt;sqlite3_create_filename ()&lt;/a&gt; , &lt;a href=&quot;c3ref/create_filename&quot;&gt;sqlite3_free_filename ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/database_file_object&quot;&gt;sqlite3_database_file_object ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ed3d70e2882ec52d0c7e2a7601fe732995c7a8e5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; interface that includes a destructor callback.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function_v2()&lt;/a&gt; interface that includes a destructor callback.</target>
        </trans-unit>
        <trans-unit id="32fc735cb1d9ab9a07f352a1fc25b9ea800e944b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_cacheflush&quot;&gt;sqlite3_db_cacheflush()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="44cee0699cbf54959614bd6a182f20329176bd39" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces for controlling and monitoring the lookaside allocator separately on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status()&lt;/a&gt; interfaces for controlling and monitoring the lookaside allocator separately on each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c14a9e833df50e1b6ce64060f4e3b591d691bb2f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;) interface which allows the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-API to be enabled while keeping the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function disabled for security.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableloadextension&quot;&gt;SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION&lt;/a&gt;) interface which allows the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-API to be enabled while keeping the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL function disabled for security.</target>
        </trans-unit>
        <trans-unit id="071c285856222e5eb7858ec7e945402304af9915" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_filename&quot;&gt;sqlite3_db_filename()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="0988b37104db6710779e2dd00393ccc8aed4f156" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_mutex&quot;&gt;sqlite3_db_mutex()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_mutex&quot;&gt;sqlite3_db_mutex()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="99b915781990b7bab55347af3d7784e6f66b997a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_readonly&quot;&gt;sqlite3_db_readonly()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="1689be755f4b5947383c0fa1c767961ce85ec869" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt; interface and the &lt;a href=&quot;pragma#pragma_shrink_memory&quot;&gt;shrink_memory pragma&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/db_release_memory&quot;&gt;sqlite3_db_release_memory()&lt;/a&gt; interface and the &lt;a href=&quot;pragma#pragma_shrink_memory&quot;&gt;shrink_memory pragma&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="d06e21c2743772c66eb0de3135ffb4cabfd2528d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errstr()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errstr()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="79f9185a6e3e6c23fc4569ebe588283d6a971b66" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_extended_errcode()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="800b59c31eab1692fa422187bd90b32b14e1376e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface as a replacement for &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/hard_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 를 대체 인터페이스를 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1353ba42736589cda5eaab5595079f29c695d72f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interfaces.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_initialize()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_shutdown()&lt;/a&gt; interfaces.</target>
        </trans-unit>
        <trans-unit id="dd7f42008f5ea2ae13832ff2fc538b92619a2aa1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; interface together with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; verb to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt;. The &quot;.log&quot; command is added to the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; interface together with the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglog&quot;&gt;SQLITE_CONFIG_LOG&lt;/a&gt; verb to &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt;. The &quot;.log&quot; command is added to the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="0f3b9f436d3aca81a329352d555edcf6d2fc53ab" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vsnprintf()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vsnprintf()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="cb1e02c2bfcb32dedecbd7d74f284c573c13e3ce" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/next_stmt&quot;&gt;sqlite3_next_stmt()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="3a526df89839bb699bba5ca5c33ef0946cc371fa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interface.</target>
        </trans-unit>
        <trans-unit id="3cdad7a02f932844f1d5aad978ef31e8280c723b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; API.</target>
        </trans-unit>
        <trans-unit id="f89e059472e4cdf3b79424c462aeb1d9f42e7450" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces with the extra &quot;prepFlags&quot; parameters.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt; and &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; interfaces with the extra &quot;prepFlags&quot; parameters.</target>
        </trans-unit>
        <trans-unit id="8f79e632c84dd8f613db0c9edb744b3211ad41ad" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob64()&lt;/a&gt; and &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_zeroblob64()&lt;/a&gt; interfaces.</source>
          <target state="translated">Added the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_zeroblob64()&lt;/a&gt; and &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_zeroblob64()&lt;/a&gt; interfaces.</target>
        </trans-unit>
        <trans-unit id="2ec059ca77f534e2ad1c9da5da7a07bfe515b8e8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt; interface and use the new interface in the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;, &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt;, and &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extensions to ensure that the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; interface always returns reasonable values.</source>
          <target state="translated">&lt;a href=&quot;c3ref/set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()&lt;/a&gt; 인터페이스를 추가하고 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; , &lt;a href=&quot;fts3#fts4&quot;&gt;FTS4&lt;/a&gt; 및 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 확장 에서 새 인터페이스를 사용 하여 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 인터페이스가 항상 합리적인 값을 리턴 하는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="0499000ae920f692c6c10ff730922e71f2175340" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64()&lt;/a&gt; interface as a replacement for &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit()&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/soft_heap_limit64&quot;&gt;sqlite3_soft_heap_limit64 ()&lt;/a&gt; 를 대체 인터페이스를 &lt;a href=&quot;c3ref/soft_heap_limit&quot;&gt;sqlite3_soft_heap_limit ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bed7ca4c56c731b0baef64d49ccf82b79e764321" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface used for querying run-time status information about the overall SQLite library and its subsystems.</source>
          <target state="translated">전체 SQLite 라이브러리 및 해당 서브 시스템에 대한 런타임 상태 정보를 조회하는 데 사용되는 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d388429eb7d67d2eee28cd2e532f95aff575159a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status64 ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d0c02d677fed007a0f3b79b5d1f2d07fc18c142f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_busy&quot;&gt;sqlite3_stmt_busy ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="1a521c795e189c1663c9a6d75d13d86189164b4d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="1fef1d855e862457ed32ca48c067aa07064074f2" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; interface, available only when compiled with &lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_stmt_scanstatus&quot;&gt;SQLITE_ENABLE_STMT_SCANSTATUS로&lt;/a&gt; 컴파일 할 때만 사용 가능한 &lt;a href=&quot;c3ref/stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus ()&lt;/a&gt; 인터페이스가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ab35212654f74bbb4e759f54b77da2dec843228c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status()&lt;/a&gt; interface for performance monitoring.</source>
          <target state="translated">성능 모니터링을위한 &lt;a href=&quot;c3ref/stmt_status&quot;&gt;sqlite3_stmt_status ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b17c7d56b39fa08e8e4f793f514bff570e85da50" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_stricmp()&lt;/a&gt; interface as a counterpart to &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp()&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_stricmp ()&lt;/a&gt; 에 대한 대응으로 인터페이스를 &lt;a href=&quot;c3ref/stricmp&quot;&gt;sqlite3_strnicmp ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36ab51188a3976b29c35159f06ed161f1e35db56" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/strlike&quot;&gt;sqlite3_strlike ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ec1296a97b3b974db4a08e61f32e7aafc39768" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/system_errno&quot;&gt;sqlite3_system_errno()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/system_errno&quot;&gt;sqlite3_system_errno ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="5c3ccb20e7e108f7d767e7d7513fa5c98ba8b126" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b9d150faf203ca09b9bbbc984a5975f99628a02e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_boolean()&lt;/a&gt; and &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_int64()&lt;/a&gt; interfaces.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_boolean ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_int64 ()&lt;/a&gt; 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="3426443574d8d278622270eb29b6c8bc749bbfa3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind()&lt;/a&gt; API for determining if the argument to an SQL function is from a &lt;a href=&quot;lang_expr#varparam&quot;&gt;bound parameter&lt;/a&gt;.</source>
          <target state="translated">SQL 함수에 대한 인수가 &lt;a href=&quot;lang_expr#varparam&quot;&gt;바운드 매개 변수&lt;/a&gt; 에서 온 것인지 판별하기 위해 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_frombind ()&lt;/a&gt; API를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="43b7debc2fe468faedbcf826ae56b984b1bd24d7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_dup&quot;&gt;sqlite3_value_free()&lt;/a&gt; interfaces.</source>
          <target state="translated">추가 &lt;a href=&quot;c3ref/value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_dup&quot;&gt;sqlite3_value_free ()&lt;/a&gt; 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="daa32da23e9524ac42660361582e6acf7f0d9ba3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype()&lt;/a&gt; interfaced (used by &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt;).</source>
          <target state="translated">인터페이스 된 &lt;a href=&quot;c3ref/value_subtype&quot;&gt;sqlite3_value_subtype ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_subtype&quot;&gt;sqlite3_result_subtype ()을&lt;/a&gt; 추가했습니다 ( &lt;a href=&quot;json1&quot;&gt;json1 확장에서 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e23d8810bd1d174b58a21d6487a29fbd4ec86121" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/vtab_collation&quot;&gt;sqlite3_vtab_collation()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vtab_collation&quot;&gt;sqlite3_vtab_collation ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="a4ac561108af405d7aa448c97e428307506c4b7a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; interfaces to help virtual table implementations optimize UPDATE operations.</source>
          <target state="translated">가상 테이블 구현이 UPDATE 조작을 최적화하는 데 도움이 되도록 &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ddf120a30cf931bf5d51052ad2c827a892d71cac" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface and enhanced the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; to support blocking checkpoints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스를 추가하고 차단 검사 점을 지원 하도록 &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; 를 향상 시켰습니다 .</target>
        </trans-unit>
        <trans-unit id="d0929c2ba69cbc1ab90381ef901ed1c43220d3b7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;carray&quot;&gt;carray() table-valued function&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;carray&quot;&gt;carray () 테이블 반환 함수의&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="4198af2bb2d3a6a2e5d9e717e487ffdb864f387d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#editfunc&quot;&gt;edit() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#editfunc&quot;&gt;edit () SQL 함수를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="474818afcad8b8e66370e87650be26268e65480a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#exexcel*&quot;&gt;.excel command&lt;/a&gt; to simplify exporting database content to a spreadsheet.</source>
          <target state="translated">&lt;a href=&quot;cli#exexcel*&quot;&gt;.excel 명령&lt;/a&gt; 을 추가하여 데이터베이스 내용을 스프레드 시트로 쉽게 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd0d090262bc2f05e4866375d263ebdd0c0c20b9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#fullschema&quot;&gt;.fullschema&lt;/a&gt; dot-command to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;cli#fullschema&quot;&gt;.fullschema을&lt;/a&gt; 받는 점 명령을 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efaa065fc6ae309d6f393706b579d1948716e05b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#sha3sum&quot;&gt;.sha3sum dot-command&lt;/a&gt; and the &lt;a href=&quot;cli#selftest&quot;&gt;.selftest dot-command&lt;/a&gt; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">추가 &lt;a href=&quot;cli#sha3sum&quot;&gt;.sha3sum 점 명령&lt;/a&gt; 과 &lt;a href=&quot;cli#selftest&quot;&gt;.selftest 점 명령을&lt;/a&gt; 받는 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6c65b9a76c93d9f52da8c8997329f7ae8313b1d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ce6e1df1cafb18c2d838e2c4bcdbb99f313309" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e862d7c1b81982153f4eb3d2e608a91a4403f0a9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS&lt;/a&gt; compile-time options. The &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; compile-time option replaces the &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; option, which is no longer supported.</source>
          <target state="translated">&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; 및 &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 . &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; 컴파일시 옵션은 대체 &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; 더 이상 지원되지 않습니다 옵션을.</target>
        </trans-unit>
        <trans-unit id="0d9939088e42394a02853dfc4d6f72c7cbfcfabb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option, causing &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; to be read directly from the database file, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; 컴파일 타임 옵션을 추가하여 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;페이지 캐시를&lt;/a&gt; 무시하고 데이터베이스 파일에서 &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;오버플로 페이지&lt;/a&gt; 를 직접 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="89be077605abd75e22c5ffc02c2f38f9fadca22f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#disable_fts4_deferred&quot;&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#disable_fts4_deferred&quot;&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="809eece43957fbb9e8168262d4e0fe553c274d57" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_api_armor&quot;&gt;SQLITE_ENABLE_API_ARMOR&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_api_armor&quot;&gt;SQLITE_ENABLE_API_ARMOR&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="78acf1f8c9551ddf3a305b4527973a912eca40df" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_null_trim&quot;&gt;SQLITE_ENABLE_NULL_TRIM&lt;/a&gt; compile-time option, which can result in significantly smaller database files for some applications, at the risk of being incompatible with older versions of SQLite.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_null_trim&quot;&gt;SQLITE_ENABLE_NULL_TRIM&lt;/a&gt; 컴파일 타임 옵션이 추가되어 일부 응용 프로그램의 데이터베이스 파일이 훨씬 작아 져 이전 버전의 SQLite와 호환되지 않을 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc7192a68013b4ccfb34fc5fa843f664f068838" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_unknown_sql_function&quot;&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/a&gt; compile-time option and turned that option on by default when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_unknown_sql_function&quot;&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/a&gt; 컴파일 타임 옵션을 추가하고 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘을&lt;/a&gt; 빌드 할 때 기본적으로 해당 옵션을 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="e26774dce1b145c5b9b287b32dbb4c00e6fe2392" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#fts3_max_expr_depth&quot;&gt;SQLITE_FTS3_MAX_EXPR_DEPTH&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#fts3_max_expr_depth&quot;&gt;SQLITE_FTS3_MAX_EXPR_DEPTH&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="39f704cba224d0630f060896cdfabf87b14693b5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#have_isnan&quot;&gt;SQLITE_HAVE_ISNAN&lt;/a&gt; compile-time option which will cause the isnan() function from the standard math library to be used instead of SQLite's own home-brew NaN checker.</source>
          <target state="translated">SQLite의 자체 양조 NaN 검사기 대신 표준 수학 라이브러리의 isnan () 함수를 사용 하는 &lt;a href=&quot;compile#have_isnan&quot;&gt;SQLITE_HAVE_ISNAN&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="558383d2bbd0eb67a29332971af16389f89345ef" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="84daf3b5302c6fe472e4c66d1c3fa77e1f119885" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; compile-time option</source>
          <target state="translated">추가 &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 컴파일시 옵션을</target>
        </trans-unit>
        <trans-unit id="8d7a7e10a04ea0438234a85069c16c9283a34f44" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="cb3a294a7e977a259efaa0c86a5bd58c0ece5079" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a909d1326bcfce04150c32be27f8c49b83bd0ecc" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#reverse_unordered_selects&quot;&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#reverse_unordered_selects&quot;&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="502456daba3bbfc42c2aae4e0545df4627f551ad" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option.</source>
          <target state="translated">추가 &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; 컴파일시 옵션을 선택하고 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; 시작 시간 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="28034c0cfb70c12e27ba3ede26d8dd8ede415516" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="09fb1f6511621b38cfa7a99512d14f14883fbc85" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3f3173fa35c3a879c2726fc2a5942b9f31caf835" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;completion&quot;&gt;COMPLETION extension&lt;/a&gt; - designed to suggest tab-completions for interactive user interfaces. This is a work in progress. Expect further enhancements in future releases.</source>
          <target state="translated">대화식 사용자 인터페이스를위한 탭 완성을 제안하도록 설계된 &lt;a href=&quot;completion&quot;&gt;COMPLETION 확장을&lt;/a&gt; 추가했습니다 . 현재 진행중인 작업입니다. 향후 릴리스에서 추가 개선이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="bd72639918b4a26ff2fb29a0faca5f35c83f254f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt; for reading &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated value files.</source>
          <target state="translated">&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; 형식의 쉼표로 구분 된 값 파일 을 읽기위한 &lt;a href=&quot;csv&quot;&gt;CSV 가상 테이블&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="92093860669f80e0461cf2bf8c10bee5f03e1d55" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;floatingpoint#decext&quot;&gt;decimal extension&lt;/a&gt; for doing arbitrary-precision decimal arithmetic.</source>
          <target state="translated">임의 정밀도 십진수 산술을 수행하기위한 &lt;a href=&quot;floatingpoint#decext&quot;&gt;십진수 확장&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3160ced06d046132de38a26647860622e0cdffde" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts3tok&quot;&gt;fts3tokenize virtual table&lt;/a&gt; to the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; logic.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;전체 텍스트 검색에 &lt;/a&gt;&lt;a href=&quot;fts3#fts3tok&quot;&gt;fts3tokenize 가상 테이블&lt;/a&gt; 을 추가했습니다. 로직.</target>
        </trans-unit>
        <trans-unit id="4c8b894319f521eb57fd47b0be0aa9684d1ec5aa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux를&lt;/a&gt; 추가했습니다 테이블</target>
        </trans-unit>
        <trans-unit id="4f7adb875b0c694ac11f99fb4651fab782bc54c4" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;FTS4 notindexed option&lt;/a&gt;, allowing non-indexed columns in an FTS4 table.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4notindexed&quot;&gt;FTS4 not indexed 옵션&lt;/a&gt; 추가FTS4 테이블에서 색인화되지 않은 열을 허용 .</target>
        </trans-unit>
        <trans-unit id="af80c1928f1855cabc20adda009b71283ddea157" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#matchinfo-b&quot;&gt;matchinfo 'b' flag&lt;/a&gt; to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-b&quot;&gt;FTS3&lt;/a&gt; 의 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 함수에 &lt;a href=&quot;fts3&quot;&gt;matchinfo &lt;/a&gt;'b'플래그 를 추가했습니다. .</target>
        </trans-unit>
        <trans-unit id="65d5c29f868afb57f7cc51fb08236c713031a2c7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#matchinfo-y&quot;&gt;matchinfo y flag&lt;/a&gt; to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-y&quot;&gt;FTS3&lt;/a&gt; 의 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 함수에 &lt;a href=&quot;fts3&quot;&gt;matchinfo &lt;/a&gt;y 플래그 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="a827723f97ea5885e808c3970a4b40110e42abfa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts5#the_detail_option&quot;&gt;FTS5 detail option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_detail_option&quot;&gt;FTS5 세부 옵션이&lt;/a&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a22bb4ef0d3b7209d712c5d4d93daa0aaef7a82c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;geopoly&quot;&gt;지오 폴리 모듈&lt;/a&gt; 추가</target>
        </trans-unit>
        <trans-unit id="87c6d5f726f175566512f2d2234a5c4de18fd7f8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw ()&lt;/a&gt; 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="1b0e11f7f07f3617d74c59523f8c23d59441befb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly#regpoly&quot;&gt;geopoly_regular()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;geopoly#regpoly&quot;&gt;geopoly_regular ()&lt;/a&gt; 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="f24e2a1102cf6edaae603eaa6aac92e181730dab" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/ext/userauth/user-auth.txt&quot;&gt;User Authentication&lt;/a&gt; extension.</source>
          <target state="translated">추가 된 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/ext/userauth/user-auth.txt&quot;&gt;사용자 인증&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="98eddc92334b847599f4ce6d60f53ec694b28ec8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.c&quot;&gt; source code&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.README&quot;&gt; documentation&lt;/a&gt; for the &lt;b&gt;genfkey&lt;/b&gt; program for automatically generating triggers to enforce foreign key constraints.</source>
          <target state="translated">외래 키 제약 조건을 적용하기 위해 트리거를 자동으로 생성 하기 위해 &lt;b&gt;genfkey&lt;/b&gt; 프로그램에 대한 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.c&quot;&gt;소스 코드&lt;/a&gt; 및 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.README&quot;&gt;문서&lt;/a&gt; 를 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb847b6e2ea32d443186a136c7cc13619b505325" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/anycollseq.c&quot;&gt;anycollseq.c&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that allows a generic SQLite database connection to read a schema that contains unknown and/or application-specific &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;.</source>
          <target state="translated">일반 SQLite 데이터베이스 연결이 알 수없는 및 / 또는 응용 프로그램 특정 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 를 포함하는 스키마를 읽을 수 있도록하는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/anycollseq.c&quot;&gt;anycollseq.c &lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;로드 가능 확장&lt;/a&gt; 을 추가했습니다. .</target>
        </trans-unit>
        <trans-unit id="7bcf45513f10ebd75a93f6b5b6e89e6063d27a70" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/explain.c&quot;&gt;explain virtual table&lt;/a&gt; as a run-time loadable extension.</source>
          <target state="translated">(가) 추가 된 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/explain.c&quot;&gt;가상 테이블을 설명&lt;/a&gt; 런타임로드 가능한 확장으로.</target>
        </trans-unit>
        <trans-unit id="b081bf5f1f1b82752017714981d03b1881cbb935" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fossildelta.c&quot;&gt;fossildelta.c&lt;/a&gt; extension that can create, apply, and deconstruct the &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/delta_format.wiki&quot;&gt;Fossil DVCS file delta format&lt;/a&gt; that is used by the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rbu&quot;&gt;RBU 확장자&lt;/a&gt; 가 사용 하는 &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/delta_format.wiki&quot;&gt;Fossil DVCS 파일 델타 형식&lt;/a&gt; 을 작성, 적용 및 구성 해제 할 수 있는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fossildelta.c&quot;&gt;fossildelta.c&lt;/a&gt; 확장자가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1c17244cfd78fdd7f17b6be947bca36290283497" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/normalize.c&quot;&gt;sqlite3_normalize()&lt;/a&gt; extension function.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/normalize.c&quot;&gt;sqlite3_normalize ()&lt;/a&gt; 확장 기능을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="759f9c17eb2b892ce355010ec281cce2d5bc2292" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;swarm virtual table&lt;/a&gt; to the existing union virtual table extension.</source>
          <target state="translated">추가 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;떼 가상 테이블을&lt;/a&gt; 기존의 노동 조합 가상 테이블 확장에.</target>
        </trans-unit>
        <trans-unit id="f734d95c970b9097c58b6ecfdc16f5977d6ec48b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/uuid.c&quot;&gt;uuid.c&lt;/a&gt; extension module implementing functions for processing RFC-4122 UUIDs.</source>
          <target state="translated">RFC-4122 UUID 처리를위한 기능을 구현 하는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/uuid.c&quot;&gt;uuid.c&lt;/a&gt; 확장 모듈이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b331aec1305fafaaca20c2db450d1ed83b8ce70e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/session/changesetfuzz.c&quot;&gt;changesetfuzz.c&lt;/a&gt; test-case generator utility.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/session/changesetfuzz.c&quot;&gt;changesetfuzz.c&lt;/a&gt; 테스트 케이스 생성기 유틸리티를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce84b6020b5a29dc39d3e75ab7c42a1088a870c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/src/dbpage.c&quot;&gt;sqlite_dbpage virtual table&lt;/a&gt; for providing direct access to pages of the database file. The source code is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is activated using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;-DSQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">데이터베이스 파일의 페이지에 직접 액세스 할 수 있도록 &lt;a href=&quot;https://sqlite.org/src/file/src/dbpage.c&quot;&gt;sqlite_dbpage 가상 테이블&lt;/a&gt; 을 추가했습니다 . 소스 코드는 &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 내장되어 있으며 &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;-DSQLITE_ENABLE_DBPAGE_VTAB를&lt;/a&gt; 사용하여 활성화됩니다. 컴파일 타임 옵션을 .</target>
        </trans-unit>
        <trans-unit id="c2442f1bc55ec77c692e59556f169e49a895d4fc" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/artifact/d7cc99350?ln=403-443&quot;&gt;sqlite3rbu_bp_progress()&lt;/a&gt; interface to the &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;https://www.sqlite.org/src/artifact/d7cc99350?ln=403-443&quot;&gt;sqlite3rbu_bp_progress ()&lt;/a&gt; 받는 인터페이스 &lt;a href=&quot;rbu&quot;&gt;RBU의&lt;/a&gt; 확장을.</target>
        </trans-unit>
        <trans-unit id="9465d7ab14adb931b5593d0471021aeb683a5ed7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/artifact/f971962e92ebb8b0&quot;&gt;eval.c&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements an eval() SQL function that will recursively evaluate SQL.</source>
          <target state="translated">SQL을 재귀 적으로 평가할 eval () SQL 함수를 구현하는 &lt;a href=&quot;https://www.sqlite.org/src/artifact/f971962e92ebb8b0&quot;&gt;eval.c &lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;로드 가능 확장&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="23f6d845a0f388b044a8b1c50b1667ba4a60cc2c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember(V,PTR)&lt;/a&gt; SQL function as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">추가 된 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;기억 (V, PTR)&lt;/a&gt; A와 SQL 함수를 &lt;a href=&quot;loadext&quot;&gt;로드 할 수있는 확장&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="425b7d13c017ba95b58d6a07a030a87fd80839e1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/sha1.c&quot;&gt;sha1.c&lt;/a&gt; extension.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/sha1.c&quot;&gt;sha1.c&lt;/a&gt; 확장을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="8e99c060c956cad10a0ae2061ee04da178be3f84" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;imposter#dotimposter&quot;&gt;.imposter dot-command&lt;/a&gt; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸에 &lt;/a&gt;&lt;a href=&quot;imposter#dotimposter&quot;&gt;.imposter 도트 명령&lt;/a&gt; 을 추가했습니다. .</target>
        </trans-unit>
        <trans-unit id="727f21d6dc5af5ea8308f45987497ba8687f21e0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jgrouparray&quot;&gt;json_group_array()&lt;/a&gt; and &lt;a href=&quot;json1#jgroupobject&quot;&gt;json_group_object()&lt;/a&gt; SQL functions in the &lt;a href=&quot;json1#jmini&quot;&gt;json&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;json1#jgrouparray&quot;&gt;json_group_array ()&lt;/a&gt; 및 &lt;a href=&quot;json1#jgroupobject&quot;&gt;json_group_object ()&lt;/a&gt; 에서 SQL 함수 &lt;a href=&quot;json1#jmini&quot;&gt;JSON의&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="1bb5ebb2b769f13a8af1db1abb9a9158e890bf67" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jpatch&quot;&gt;json_patch()&lt;/a&gt; SQL function to the &lt;a href=&quot;json1&quot;&gt;JSON1 extension&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;json1#jpatch&quot;&gt;json_patch ()&lt;/a&gt; 받는 SQL 기능 &lt;a href=&quot;json1&quot;&gt;JSON1 확장을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a094211337515c1dc028d6f9e6cf2117139fbc0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt; SQL function to &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;json1#jquote&quot;&gt;json_quote ()&lt;/a&gt; 에 SQL 기능 &lt;a href=&quot;json1&quot;&gt;json1 확장을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a328d8e8703958674a4567fcec41c8773ac9bc0f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#iif&quot;&gt;iif () SQL 함수를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6d18b3be87f155b2457df15bacd3dd11c3e674d5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr()&lt;/a&gt; SQL function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr ()&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="247064f74dbe4b79f59940594bcda97f277a43f3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; SQL function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#likely&quot;&gt;가능성이 (X)&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bac96e190aeab6b4919769c4f3fd24dfbe89ae73" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf()&lt;/a&gt; SQL function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf ()&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d60a43dfdb6c9e0039a4d0aa4f120238cb346854" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions to be used as hints to the query planner.</source>
          <target state="translated">쿼리 플래너에 힌트로 사용할 &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood ()&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bb0ee30e9ce216eed1bab03b1463da8795ac409d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#match&quot;&gt;경기&lt;/a&gt; 추가 연산자를 .</target>
        </trans-unit>
        <trans-unit id="afa2810329e9d36a72775faefe7a4b187615efbd" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; 명령 추가</target>
        </trans-unit>
        <trans-unit id="47f839667c95acc5a008254deb814f5fd2e72e82" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; for a speed improvement in excess of 15% on some workloads. (Your mileage may vary.)</source>
          <target state="translated">일부 워크로드에서 속도가 15 % 이상 향상 되도록 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당자를&lt;/a&gt; 추가했습니다 . (귀하의 마일리지가 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ca85bb0b52986a81e52b50ef04e5ef298fc1ebdf" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; to the query planner.</source>
          <target state="translated">쿼리 플래너에 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화&lt;/a&gt; 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="c52772fca787badd301bbb28489a51e6b2c18437" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="acf053bb493580f8d76bf2fe4425a6ee95eb3b00" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;cache_spill pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;cache_spill pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="7028868fffc72a85c59d3c3b9112eb23b4ec033e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check&lt;/a&gt; command for better and earlier detection of database file corruption.</source>
          <target state="translated">데이터베이스 파일 손상의 조기 발견을 위해 &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check&lt;/a&gt; 명령을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="f60e6b13f01cdd96d811863e696687470fe6d7c1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command that can be used to determine if a database file has been modified by another process.</source>
          <target state="translated">데이터베이스 파일이 다른 프로세스에 의해 수정되었는지 확인하는 데 사용할 수있는 &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; 명령이 추가 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6dc9cd4f3681e1d6bfff801310b10819f9c239c5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; and the &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface.</source>
          <target state="translated">추가 &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys 프라그&lt;/a&gt; 와 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt; (dB, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS을&lt;/a&gt; , ...) C 언어 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="9260575fd05ff275b40b928c8ff145c26653a33b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fd33bca500a56cb70a0e4189db705ce4c14918ef" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;PRAGMA index_xinfo&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;PRAGMA index_xinfo&lt;/a&gt; 명령이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d2cb1ad431d49ff1624974b470ad507e7e6aade5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; command, which if enabled causes the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command to behave like older version of SQLite (prior to version 3.25.0) for compatibility.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; 명령이 추가되었습니다.이 명령을 사용하면 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령이 이전 버전의 SQLite (3.23.2 이전 버전)와 같이 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="241f9aa0870d7629a649c6fcf7aff48add9bd27d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 명령 추가</target>
        </trans-unit>
        <trans-unit id="522f4f5023f50f82e4cb75d28460040b08ac77c8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;PRAGMA page_count&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_page_count&quot;&gt;PRAGMA page_count&lt;/a&gt; 명령을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="181f42a6c7e001d819f97d8ba8bb1793d0d0a062" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; PRAGMA for returning the size of the underlying database file in pages.</source>
          <target state="translated">기본 데이터베이스 파일의 크기를 페이지로 반환하기 위해 &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; PRAGMA를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b0186fd0e400893a1b30b7508e00203dc47dcbd7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_query_only&quot;&gt;query_only pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_query_only&quot;&gt;query_only pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="8f14ae05567f16f27c2ce37117eaac6068a50a87" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;reverse_unordered_selects pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;reverse_unordered_selects pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="0623635bd786359d5b3e0fa8a8c82ab7ea0f9a41" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=FAST&lt;/a&gt; command. When secure_delete is set to FAST, old content is overwritten with zeros as long as that does not increase the amount of I/O. Deleted content might still persist on the &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; but will be purged from all b-tree pages.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete = FAST&lt;/a&gt; 명령을 추가했습니다 . secure_delete가 FAST로 설정되면 I / O의 양을 늘리지 않는 한 오래된 컨텐츠를 0으로 겹쳐 씁니다. 삭제 된 컨텐츠는 여전히 사용 가능 &lt;a href=&quot;fileformat2#freelist&quot;&gt;페이지 목록&lt;/a&gt; 에 남아있을 수 있지만 모든 b- 트리 페이지에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="837b2abaf90eb53043c6e7f99d8293f985e4ea36" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6ed2f465aa832c05e440067dd7bf41e8a2ea7c7d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6aa4735afedc1efa7a8fd6ef84be33fe2ae0da0d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_stats&quot;&gt;PRAGMA stats&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_stats&quot;&gt;PRAGMA 통계&lt;/a&gt; 문을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="dda41fd88ccb8b6e627abcd4e0e1e198b532f161" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;PRAGMA vdbe_addoptrace&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;PRAGMA vdbe_debug&lt;/a&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;PRAGMA vdbe_addoptrace&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;PRAGMA vdbe_debug&lt;/a&gt; 명령이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eca68a9d9e7785e54f4fcfc001732202953d934a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property to the VFS interface. Provide the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; I/O capability, the &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;SQLITE_POWERSAFE_OVERWRITE&lt;/a&gt; compile-time option, and the &quot;psow=BOOLEAN&quot; query parameter for &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;psow&quot;&gt;powersafe 덮어 쓰기&lt;/a&gt; VFS에 인터페이스 속성을. 제공 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; I / O 기능의 &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;SQLITE_POWERSAFE_OVERWRITE&lt;/a&gt; 컴파일시 옵션 등에 대한 &quot;psow = BOOLEAN&quot;쿼리 매개 변수 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04abd4bf7e803d987674de715233b44d21ad1237" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;rtree#rtreecheck&quot;&gt;rtreecheck()&lt;/a&gt; scalar SQL function to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;rtree#rtreecheck&quot;&gt;rtreecheck ()&lt;/a&gt; 받는 스칼라 SQL 함수 &lt;a href=&quot;rtree&quot;&gt;R-트리 확장을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc105b8ec07cf1f35ee3a44ebcb504b698c185e2" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;rtree#xquery&quot;&gt;sqlite3_rtree_query_callback()&lt;/a&gt; interface to &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;</source>
          <target state="translated">추가 &lt;a href=&quot;rtree#xquery&quot;&gt;sqlite3_rtree_query_callback ()&lt;/a&gt; 에 대한 인터페이스 &lt;a href=&quot;rtree&quot;&gt;R-트리 확장&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39750cb3b229cd41fd745ee42224961db3f0e9a9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;session/c_changesetapply_invert&quot;&gt;SQLITE_CHANGESETAPPLY_INVERT&lt;/a&gt; flag</source>
          <target state="translated">&lt;a href=&quot;session/c_changesetapply_invert&quot;&gt;SQLITE_CHANGESETAPPLY_INVERT&lt;/a&gt; 플래그 추가</target>
        </trans-unit>
        <trans-unit id="be5c46b76747ab1af6431ca228fa917fafbc088c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt; interface and the &lt;a href=&quot;session/c_changesetstart_invert&quot;&gt;SQLITE_CHANGESETSTART_INVERT&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;session/c_changesetstart_invert&quot;&gt;SQLITE_CHANGESETSTART_INVERT&lt;/a&gt; 플래그가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1c498f90678af89842f0c30b1342851695eaf9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff.exe&lt;/a&gt; utility program for computing the differences between two SQLite database files.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff.exe를&lt;/a&gt; 추가했습니다두 SQLite 데이터베이스 파일의 차이점을 계산하기 위해 유틸리티 프로그램을 .</target>
        </trans-unit>
        <trans-unit id="26e4d8fe0797614c479eea512419e56f330774a0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT 가상 테이블&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="7141a7f71545fdc2d8f0941a70f5d692420e5873" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;&lt;a href=&quot;tclsqlite#config&quot;&gt;config method&lt;/a&gt; in order to be able to disable &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; as well as control other &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; options from TCL.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; 를 비활성화 하고 TCL에서 다른 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 옵션을 제어 할 수 있도록 &lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스 &lt;/a&gt;&lt;a href=&quot;tclsqlite#config&quot;&gt;구성 방법&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3034d006b7d037b3012d84d49eab4202967372ce" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;unionvtab&quot;&gt;UNION virtual table&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;unionvtab&quot;&gt;UNION 가상 테이블&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="7d1fcdd4ec63f81664121b096c84af0efcd65365" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;vtab#colUsed&quot;&gt;colUsed field&lt;/a&gt; to &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; for use by the &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; 메소드 에서 사용 하기 위해 &lt;a href=&quot;vtab#colUsed&quot;&gt;colUsed 필드&lt;/a&gt; 를 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 에 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="abff860b551a8d132b543df75ebaabf23d9a1164" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;COPY&lt;/b&gt; command patterned after &lt;a href=&quot;http://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; so that SQLite can now read the output of the &lt;b&gt;pg_dump&lt;/b&gt; database dump utility of PostgreSQL.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;http://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; 의 &lt;b&gt;pg_dump&lt;/b&gt; 데이터베이스 덤프 유틸리티의 출력을 읽을 수 있도록 PostgreSQL 이후에 패턴 화 된 &lt;b&gt;COPY&lt;/b&gt; 명령을 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e304ab36743ecbc720ac93786500ba376598ce88" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;LIKE&lt;/b&gt; operator.</source>
          <target state="translated">&lt;b&gt;LIKE&lt;/b&gt; 연산자를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="e12e3e86e8d93c49072339ca4e285a481d50fb9d" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function.</source>
          <target state="translated">&lt;b&gt;last_insert_rowid ()&lt;/b&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3193cf97b99861e9e104fce03f06019602ead587" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_..._printf()&lt;/b&gt; interface routines.</source>
          <target state="translated">추가 &lt;b&gt;sqlite가 _..._의 printf ()&lt;/b&gt; 인터페이스 루틴을.</target>
        </trans-unit>
        <trans-unit id="043d356fd73cb171db8858f0f5622b884db88636" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_busy_handler()&lt;/b&gt; and &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; interface.</source>
          <target state="translated">&lt;b&gt;sqlite_busy_handler ()&lt;/b&gt; 및 &lt;b&gt;sqlite_busy_timeout ()&lt;/b&gt; 인터페이스가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e9ea8f321d97c10573a695234e9878da4617c5e5" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_changes()&lt;/b&gt; API function to return the number of row that changed in the most recent operation.</source>
          <target state="translated">가장 최근 작업에서 변경된 행 수를 반환하기 위해 &lt;b&gt;sqlite_changes ()&lt;/b&gt; API 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b8527c0256e1df6259b3b96966c858732fd00e5f" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_get_table()&lt;/b&gt; API</source>
          <target state="translated">추가 &lt;b&gt;sqlite_get_table ()&lt;/b&gt; API를</target>
        </trans-unit>
        <trans-unit id="998f6cbca04b2d05276533a7914bab3fa482581f" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_interrupt()&lt;/b&gt; interface.</source>
          <target state="translated">&lt;b&gt;sqlite_interrupt ()&lt;/b&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="a71daae0bfba6e902831cbd84539462138fb543a" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_open_aux_file()&lt;/b&gt; API, though it is still mostly undocumented and untested.</source>
          <target state="translated">&lt;b&gt;sqlite_open_aux_file ()&lt;/b&gt; API가 추가 되었지만 여전히 대부분 문서화되지 않고 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="04ac72f388de3cc88954c42e0e92ea3b9fd55074" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_set_authorizer()&lt;/b&gt; API. Formal documentation has not been written - see the source code comments for instructions on how to use this function.</source>
          <target state="translated">&lt;b&gt;sqlite_set_authorizer ()&lt;/b&gt; API를 추가했습니다 . 공식 문서는 작성되지 않았습니다.이 기능을 사용하는 방법에 대한 지침은 소스 코드 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03c76f9466cfa8b45c7eef759eaf4885a10cbd2e" translate="yes" xml:space="preserve">
          <source>Added the &lt;em&gt;experimental&lt;/em&gt;&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;, &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, and &lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interfaces. These are subject to change or removal in a subsequent release.</source>
          <target state="translated">추가 &lt;em&gt;실험 &lt;/em&gt;&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; , &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; 인터페이스. 후속 릴리스에서는 변경되거나 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8960036bc5202bda42674d6c0203a6bd0c46dd" translate="yes" xml:space="preserve">
          <source>Added the ANALYZE command for gathering statistics on indices and using those statistics when picking an index in the optimizer</source>
          <target state="translated">인덱스에서 통계를 수집하고 옵티 마이저에서 인덱스를 선택할 때 해당 통계를 사용하기위한 ANALYZE 명령이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e76828fc2ef742c439bfc84df1818b198b243eeb" translate="yes" xml:space="preserve">
          <source>Added the ATTACH and DETACH commands to allow interacting with multiple database files at the same time.</source>
          <target state="translated">여러 데이터베이스 파일과 동시에 상호 작용할 수 있도록 ATTACH 및 DETACH 명령을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="648b7548b08d3433a571e65bdfcce48f0369af0b" translate="yes" xml:space="preserve">
          <source>Added the COUNT_CHANGES pragma.</source>
          <target state="translated">COUNT_CHANGES 개의 pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="0a82f263a7163cc945f7a54766155ffe5bad18eb" translate="yes" xml:space="preserve">
          <source>Added the EMPTY_RESULT_CALLBACKS pragma</source>
          <target state="translated">EMPTY_RESULT_CALLBACKS pragma 추가</target>
        </trans-unit>
        <trans-unit id="adf9996aa89891e17522dba8a3b313501dd38637" translate="yes" xml:space="preserve">
          <source>Added the ESCAPE clause on the LIKE operator.</source>
          <target state="translated">LIKE 연산자에 ESCAPE 절을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="f305242a3191cbfb5aec027e3852204245b42cf2" translate="yes" xml:space="preserve">
          <source>Added the FULL_COLUMN_NAMES pragma. When set to &quot;ON&quot;, the names of columns are reported back as TABLE.COLUMN instead of just COLUMN.</source>
          <target state="translated">FULL_COLUMN_NAMES pragma를 추가했습니다. &quot;ON&quot;으로 설정하면 열 이름이 COLUMN 대신 TABLE.COLUMN으로 다시보고됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9f140f4e869766b8cc9921a38bfc1214b22f28" translate="yes" xml:space="preserve">
          <source>Added the SANITY_CHECK pragma.</source>
          <target state="translated">SANITY_CHECK pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="ab67de0b2fcd45ff0f66e746a10daf00336c46a1" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_MIXED_ENDIAN_64BIT_FLOAT compile-time option to support ARM7 processors with goofy endianness.</source>
          <target state="translated">구피 엔디안으로 ARM7 프로세서를 지원하기 위해 SQLITE_MIXED_ENDIAN_64BIT_FLOAT 컴파일 타임 옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="8512503a8a6ee6ac4c42b6ec6960124aa1141343" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_READONLY_ROLLBACK extended error code for when a database cannot be opened because it needs rollback recovery but is read-only.</source>
          <target state="translated">롤백 복구가 필요하지만 읽기 전용이므로 데이터베이스를 열 수없는 경우에 대한 SQLITE_READONLY_ROLLBACK 확장 오류 코드를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="d860363ab44e2e09ecb05e55d177bb6e0cc5efda" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_UINT64_TYPE compile-time option as an analog to SQLITE_INT64_TYPE.</source>
          <target state="translated">SQLITE_INT64_TYPE과 유사하게 SQLITE_UINT64_TYPE 컴파일 타임 옵션이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0dc2a114a80ab21b7a59a0682328a2000b97132e" translate="yes" xml:space="preserve">
          <source>Added the SYNCHRONOUS pragma</source>
          <target state="translated">동기식 pragma 추가</target>
        </trans-unit>
        <trans-unit id="f2840998df920dfd1ea272df7b05ff7b737d636e" translate="yes" xml:space="preserve">
          <source>Added the TABLE_INFO() and INDEX_INFO() pragmas to help support the ODBC interface.</source>
          <target state="translated">ODBC 인터페이스를 지원하기 위해 TABLE_INFO () 및 INDEX_INFO () pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="55b81f73060b913ff9ec244fef4f2242a8077314" translate="yes" xml:space="preserve">
          <source>Added the TRUNCATE option to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode에&lt;/a&gt; TRUNCATE 옵션을 추가했습니다</target>
        </trans-unit>
        <trans-unit id="01a5050102a4554f6884185179621e32222f113e" translate="yes" xml:space="preserve">
          <source>Added the ability to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed&lt;/a&gt; database.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed&lt;/a&gt; 데이터베이스 를 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="06c38c134cf06def71bdb05238df7b454e3474fe" translate="yes" xml:space="preserve">
          <source>Added the ability to link against the &quot;&lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt;&quot; command-line editing library in unix builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 유닉스 빌드에서 &quot; &lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt; &quot;명령 행 편집 라이브러리에 링크하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="64b8cf9d4fd6b2c51e94a6a6f014fcfd569e941f" translate="yes" xml:space="preserve">
          <source>Added the ability to resolve constraint conflicts is ways other than an abort and rollback. See the documentation on the &quot;ON CONFLICT&quot; clause for details.</source>
          <target state="translated">제약 조건 충돌을 해결하는 기능은 중단 및 롤백 이외의 방법입니다. 자세한 내용은 &quot;ON CONFLICT&quot;절의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f101692603c49e55897cc1b0a0872864ceef28cd" translate="yes" xml:space="preserve">
          <source>Added the ability to specify &quot;*&quot; as part of a larger column list in the result section of a SELECT statement. For example:</source>
          <target state="translated">SELECT 문의 결과 섹션에서 더 큰 열 목록의 일부로 &quot;*&quot;를 지정하는 기능이 추가되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9da37dd2277aa54e92101d7aa5cc21a4b4b41b35" translate="yes" xml:space="preserve">
          <source>Added the concatenate string operator (||)</source>
          <target state="translated">연결 문자열 연산자 (||)를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="8781e73412ec3dcdbe8ddfaabe88ccd47d652415" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;cli#expert&quot;&gt;.expert command&lt;/a&gt;</source>
          <target state="translated">실험적인 &lt;a href=&quot;cli#expert&quot;&gt;.expert 명령&lt;/a&gt; 추가</target>
        </trans-unit>
        <trans-unit id="0fc342be926b0820e09fb4675d0d305018e3e35d" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. Note that this extension is experimental and subject to change in incompatible ways.</source>
          <target state="translated">실험적인 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 확장을 추가했습니다. 이 확장 프로그램은 실험용이며 호환되지 않는 방식으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10d4e217a57507e7cf4bdc496b8ef5f7cdbf4429" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension. Note that this extension is experimental and subject to change in incompatible ways.</source>
          <target state="translated">실험적인 &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; 확장을 추가했습니다. 이 확장 프로그램은 실험용이며 호환되지 않는 방식으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd32bd379fd1ee1dbe9dd7bcac2b99d55f0988b" translate="yes" xml:space="preserve">
          <source>Added the experimental and undocumented EXPLAIN QUERY PLAN capability</source>
          <target state="translated">실험적이고 문서화되지 않은 EXPLAIN QUERY PLAN 기능 추가</target>
        </trans-unit>
        <trans-unit id="bbf7af11f593a05578593b77e950de9d08708237" translate="yes" xml:space="preserve">
          <source>Added the experimental malloc-free memory allocator in mem3.c.</source>
          <target state="translated">mem3.c에 실험적인 malloc-free 메모리 할당자를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5c30e3baaca4fbdcfb24a460d6ac28afed94f059" translate="yes" xml:space="preserve">
          <source>Added the fcnt() function to the SQL interpreter. The fcnt() function returns the number of database &quot;Fetch&quot; operations that have occurred. This function is designed for use in test scripts to verify that queries are efficient and appropriately optimized. Fcnt() has no other useful purpose, as far as I know.</source>
          <target state="translated">SQL 인터프리터에 fcnt () 함수를 추가했습니다. fcnt () 함수는 발생한 데이터베이스 &quot;페치&quot;조작 수를 리턴합니다. 이 기능은 쿼리가 효율적이고 적절하게 최적화되었는지 확인하기 위해 테스트 스크립트에서 사용하도록 설계되었습니다. Fcnt ()는 내가 아는 한 다른 유용한 목적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a58a2fc5a5367d63f94f8275791e299dd75eb74" translate="yes" xml:space="preserve">
          <source>Added the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, for listing the files in a directory.</source>
          <target state="translated">디렉토리에 파일을 나열하기 위해 fsdir (PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 를 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; 확장자에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="17d23ff1e41223a23eed74ee1f278a16171c0953" translate="yes" xml:space="preserve">
          <source>Added the fullfsync pragma.</source>
          <target state="translated">fullfsync pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c8e37096ddd5586a6257d3283c3c1a2dfcb73ea7" translate="yes" xml:space="preserve">
          <source>Added the new &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain(S)&lt;/a&gt; interface for determining whether or not a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 인지 여부를 판별하기 위해 새로운 &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain (S)&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="4d5a2b0e9f488226eecba61aa448d45b4ae4e1d9" translate="yes" xml:space="preserve">
          <source>Added the new &lt;a href=&quot;tclsqlite#bind_fallback&quot;&gt;bind_fallback method&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;tclsqlite#bind_fallback&quot;&gt;bind_fallback 메소드를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="698d2bae74641dc2312ecf24ccb34bdaf37e3654" translate="yes" xml:space="preserve">
          <source>Added the new &lt;b&gt;SQLITE_TEMP_MASTER&lt;/b&gt; table which records the schema for temporary tables in the same way that &lt;b&gt;SQLITE_MASTER&lt;/b&gt; does for persistent tables.</source>
          <target state="translated">&lt;b&gt;SQLITE_MASTER&lt;/b&gt; 가 영속 테이블에 대해 수행 하는 것과 동일한 방식으로 임시 테이블에 대한 스키마를 기록 하는 새로운 &lt;b&gt;SQLITE_TEMP_MASTER&lt;/b&gt; 테이블을 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f8314265965cb9729309aa3a47d77b4ebbd0dc84" translate="yes" xml:space="preserve">
          <source>Added the new &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function.</source>
          <target state="translated">새로운 &lt;b&gt;sqlite_last_insert_rowid ()&lt;/b&gt; API 함수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f36e59151eae3a6b62bf13680d5957b9ac83ad96" translate="yes" xml:space="preserve">
          <source>Added the new interface &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_msize()&lt;/a&gt; that returns the size of a memory allocation obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and its variants.</source>
          <target state="translated">&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 및 해당 변형 에서 얻은 메모리 할당 크기를 반환 하는 새로운 인터페이스 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_msize ()&lt;/a&gt; 가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="49d6fc07cdd58d69c1061156379f31f91815e6f2" translate="yes" xml:space="preserve">
          <source>Added the new sqlite3_bind_parameter_name() interface.</source>
          <target state="translated">새로운 sqlite3_bind_parameter_name () 인터페이스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="294074eb5cc5a602340ff9920845209bc774b64a" translate="yes" xml:space="preserve">
          <source>Added the optional &lt;a href=&quot;asyncvfs&quot;&gt;asynchronous VFS&lt;/a&gt; module.</source>
          <target state="translated">선택적 &lt;a href=&quot;asyncvfs&quot;&gt;비동기식 VFS&lt;/a&gt; 모듈을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d2ff57d315c3b6f550eb4477360be1d9ece1af4e" translate="yes" xml:space="preserve">
          <source>Added the remove_diacritics=2 option to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 및 &lt;a href=&quot;fts5&quot;&gt;FTS5에&lt;/a&gt; remove_diacritics = 2 옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="5543829232c2352604477be7d98b18681931c4e6" translate="yes" xml:space="preserve">
          <source>Added the sqlite3_db_handle() API</source>
          <target state="translated">sqlite3_db_handle () API 추가</target>
        </trans-unit>
        <trans-unit id="31ca3dd4e3255f6b9042e4416d3da3cdbcd74a82" translate="yes" xml:space="preserve">
          <source>Added the sqlite3_get_autocommit() API</source>
          <target state="translated">sqlite3_get_autocommit () API 추가</target>
        </trans-unit>
        <trans-unit id="01da972e948cd498d37d659567824ec295b8ab3b" translate="yes" xml:space="preserve">
          <source>Added the sqlite_encode_binary() and sqlite_decode_binary() functions to the source tree. But they are not yet linked into the library.</source>
          <target state="translated">sqlite_encode_binary () 및 sqlite_decode_binary () 함수를 소스 트리에 추가했습니다. 그러나 그들은 아직 도서관에 연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b7931525b0f49699c8919c663442c12cd2042a1" translate="yes" xml:space="preserve">
          <source>Added the subquery flattening optimizer.</source>
          <target state="translated">하위 쿼리 병합 최적화 도구를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c7b7e1fb260a3da09d3b883f4ceb3d8fea98b06f" translate="yes" xml:space="preserve">
          <source>Added the test_multiplex.c module which provides an example VFS that provides multiplexing (sharding) of a DB, splitting it over multiple files of fixed size.</source>
          <target state="translated">DB의 멀티플렉싱 (샤딩)을 제공하고 고정 크기의 여러 파일로 분할하는 예제 VFS를 제공하는 test_multiplex.c 모듈을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="ae0013cb7d834fd47edf840654f5d38cdca51233" translate="yes" xml:space="preserve">
          <source>Added the test_regexp.c module as a demonstration of how to implement the REGEXP operator.</source>
          <target state="translated">REGEXP 연산자를 구현하는 방법을 보여주는 test_regexp.c 모듈을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="32a49834c953fbdb6828ba126355f3f55173d44b" translate="yes" xml:space="preserve">
          <source>Added the test_superlock.c module which provides example code for obtaining an exclusive lock to a rollback or WAL database.</source>
          <target state="translated">롤백 또는 WAL 데이터베이스에 대한 독점 잠금을 얻기위한 예제 코드를 제공하는 test_superlock.c 모듈이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="09972935bcd9fee093e7ba1782e40d68896023ca" translate="yes" xml:space="preserve">
          <source>Added the win32-longpath VFS on windows, permitting filenames up to 32K characters in length.</source>
          <target state="translated">Windows에 win32-longpath VFS를 추가하여 최대 32K 자의 파일 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f94f686ce38728ef2b6f0370975b863c680811c8" translate="yes" xml:space="preserve">
          <source>Added the xGetLastError() method to &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; for returning filesystem-specific error messages and error codes back to SQLite.</source>
          <target state="translated">파일 시스템 별 오류 메시지 및 오류 코드를 다시 SQLite로 리턴 하기 위해 xGetLastError () 메소드를 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 에 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="7f5e4ed0c375fbca2b5b605896122a1929784c92" translate="yes" xml:space="preserve">
          <source>Added two new C-language interfaces: &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_expanded_sql()&lt;/a&gt; and &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. These new interfaces subsume the functions of &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; which are now deprecated.</source>
          <target state="translated">&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_expanded_sql ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()의&lt;/a&gt; 두 가지 새로운 C 언어 인터페이스가 추가되었습니다 . 이 새로운 인터페이스 는 현재 사용되지 않는 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 의 기능을 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="82207d09f92cb6fda6e84b7a4f36383b773b1975" translate="yes" xml:space="preserve">
          <source>Added two new experimental functions: &lt;a href=&quot;lang_expr#randomblobFunc&quot;&gt;randomBlob()&lt;/a&gt; and &lt;a href=&quot;lang_expr#hexFunc&quot;&gt;hex()&lt;/a&gt;. Their intended use is to facilitate generating &lt;a href=&quot;http://en.wikipedia.org/wiki/UUID&quot;&gt;UUIDs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#randomblobFunc&quot;&gt;randomBlob ()&lt;/a&gt; 과 &lt;a href=&quot;lang_expr#hexFunc&quot;&gt;hex ()&lt;/a&gt; 두 가지 새로운 실험 함수가 추가되었습니다 . 의도 된 용도는 &lt;a href=&quot;http://en.wikipedia.org/wiki/UUID&quot;&gt;UUID&lt;/a&gt; 생성을 용이하게하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="738e6cc3217ca2553bb9e0d6d54a155cd0ad0e85" translate="yes" xml:space="preserve">
          <source>Added verbs &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatuspagecachesize&quot;&gt;SQLITE_STATUS_PAGECACHE_SIZE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusscratchsize&quot;&gt;SQLITE_STATUS_SCRATCH_SIZE&lt;/a&gt; to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatuspagecachesize&quot;&gt;SQLITE_STATUS_PAGECACHE_SIZE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusscratchsize&quot;&gt;SQLITE_STATUS_SCRATCH_SIZE&lt;/a&gt; 동사 를 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; 인터페이스에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c680515f169f90f11c5dd355902aaea8ab7434ee" translate="yes" xml:space="preserve">
          <source>Adding anything to null gives null</source>
          <target state="translated">null에 아무것도 추가하면 null이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb59cdfe69dfa59c552601b0c1f3bb462cce88b5" translate="yes" xml:space="preserve">
          <source>Adding new auxiliary functions implemented in C, and</source>
          <target state="translated">C로 구현 된 새로운 보조 기능 추가</target>
        </trans-unit>
        <trans-unit id="f056b3609aae2fc232cd7cd2146d49c24a7d20cd" translate="yes" xml:space="preserve">
          <source>Adding new tokenizers, also implemented in C.</source>
          <target state="translated">C에서 구현 된 새로운 토크 나이저 추가</target>
        </trans-unit>
        <trans-unit id="6889504fdc32a6b06fe8b6bcc4bddeee9d4dd115" translate="yes" xml:space="preserve">
          <source>Adding optional features like &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;, &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;, or &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; will increase the size of the library, obviously.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; , &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; 와 같은 선택적 기능을 추가 하면 라이브러리 크기가 커집니다.</target>
        </trans-unit>
        <trans-unit id="96d5a0933a519ba202a444bedd7df31dcc598d63" translate="yes" xml:space="preserve">
          <source>Adding to Zip</source>
          <target state="translated">Zip에 추가</target>
        </trans-unit>
        <trans-unit id="c1cc55a80b36a00837a2ba9fccba63e4cde092d5" translate="yes" xml:space="preserve">
          <source>Additional OS/2 updates</source>
          <target state="translated">추가 OS / 2 업데이트</target>
        </trans-unit>
        <trans-unit id="92dafa949d6bc0b1375a028d351e58c914e80e5e" translate="yes" xml:space="preserve">
          <source>Additional application-specific collating functions can be added to SQLite using the &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; 인터페이스를 사용하여 추가 응용 프로그램 별 조합 함수를 SQLite에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f27c7e9f8642590f605d8547ee9d3195fc42ee26" translate="yes" xml:space="preserve">
          <source>Additional background information is available in the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; document.</source>
          <target state="translated">추가 배경 정보는 &lt;a href=&quot;queryplanner&quot;&gt;색인 작성 자습서&lt;/a&gt; 문서 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26005506e7fe80738695bc038f726957b22b2e7d" translate="yes" xml:space="preserve">
          <source>Additional bits may be added in future versions of SQLite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c99c8da41f3c9e92b76081bdd22fd42577b1a01" translate="yes" xml:space="preserve">
          <source>Additional documentation is available &lt;a href=&quot;cli&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">추가 설명서는 &lt;a href=&quot;cli&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b84c5eeb4233a176f6bc28e3bd04baf2d28fa4" translate="yes" xml:space="preserve">
          <source>Additional documentation on Fossil can be found at &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&lt;/a&gt;</source>
          <target state="translated">화석에 대한 추가 문서는 &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="317e6d6c624cc48cb4d511774ceb090affd1ec71" translate="yes" xml:space="preserve">
          <source>Additional fixes for issues detected by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSSFuzz&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSSFuzz에서&lt;/a&gt; 감지 된 문제에 대한 추가 수정 사항 :</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="92a863bb50cbb4e362af4fa066e5c6af932cb4b2" translate="yes" xml:space="preserve">
          <source>Additional information about datatypes in SQLite version 3.0 is available &lt;a href=&quot;datatype3&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">SQLite 버전 3.0의 데이터 유형에 대한 추가 정보는 &lt;a href=&quot;datatype3&quot;&gt;별도로&lt;/a&gt; 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ec1e59a22ef60dce4ecbbf53a52e3ca6ce479f4" translate="yes" xml:space="preserve">
          <source>Additional information about each of these temporary file types is in the sequel.</source>
          <target state="translated">이러한 임시 파일 유형 각각에 대한 추가 정보는 속편에 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d1a81241f56a80c6f10677f29019f00a708f3e" translate="yes" xml:space="preserve">
          <source>Additional information is provided in the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; and &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; documents.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;optoverview&quot;&gt;SQLite 쿼리 플래너&lt;/a&gt; 및 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 문서에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e54fe371689214dc8e5e5e621b7eb86aecf9d56f" translate="yes" xml:space="preserve">
          <source>Additional language codes might be added in future releases.</source>
          <target state="translated">향후 릴리스에서 추가 언어 코드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd6df38d5642afc4cf37656b0d1bca445886b04" translate="yes" xml:space="preserve">
          <source>Additional notes on compiling SQLite can be found on the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page.</source>
          <target state="translated">SQLite 컴파일에 대한 추가 참고 사항은 SQLite &lt;a href=&quot;howtocompile&quot;&gt;컴파일 방법&lt;/a&gt; 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4ec2f0b6cbf4bf0e81b4a109aa98e3ffbd4166d" translate="yes" xml:space="preserve">
          <source>Additional notes:</source>
          <target state="translated">추가 사항 :</target>
        </trans-unit>
        <trans-unit id="332472b920f973dc311033ff008ad95ae21f625e" translate="yes" xml:space="preserve">
          <source>Additional speed-up can occur if an index can be used to speed the search of either or the two loops.</source>
          <target state="translated">인덱스를 사용하여 하나 또는 두 개의 루프를 빠르게 검색 할 수있는 경우 추가 속도 향상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62327a6c1f64cd300d626d84824c24a7457822b7" translate="yes" xml:space="preserve">
          <source>Additional tests added to the regression suite to cover the new ROWID feature and the TCL interface bugs mentioned below.</source>
          <target state="translated">새로운 ROWID 기능 및 아래 언급 된 TCL 인터페이스 버그를 다루기 위해 회귀 스위트에 추가 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="654733e6ef7698fde15afb843bdcb55e4a4bdac2" translate="yes" xml:space="preserve">
          <source>Additionally, all VFS implementations are required to provide the</source>
          <target state="translated">또한 모든 VFS 구현은</target>
        </trans-unit>
        <trans-unit id="751381c740adf479c5b317c56d4dbca83d940699" translate="yes" xml:space="preserve">
          <source>Additionally, five extra &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations are provided as well as the default. By specifying one of the extra VFS implementations when calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, an application may bypass the file-system detection logic and explicitly select one of the above locking styles. The five extra &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations are called &quot;unix-posix&quot;, &quot;unix-afp&quot;, &quot;unix-flock&quot;, &quot;unix-dotfile&quot; and &quot;unix-none&quot;.</source>
          <target state="translated">또한 기본적으로 5 개의 추가 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현이 제공됩니다. &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 호출 할 때 추가 VFS 구현 중 하나를 지정 하면 응용 프로그램이 파일 시스템 감지 논리를 무시하고 위의 잠금 스타일 중 하나를 명시 적으로 선택할 수 있습니다. 5 가지 추가 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현을 &quot;unix-posix&quot;, &quot;unix-afp&quot;, &quot;unix-flock&quot;, &quot;unix-dotfile&quot;및 &quot;unix-none&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9c0db46574ddb3c258907307bfcb277854bd98be" translate="yes" xml:space="preserve">
          <source>Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then SQLite also assumes that if a call to the xUpdate() method is made as part of the same statement to delete or update a virtual table row and the implementation returns SQLITE_CONSTRAINT, then there is no need to rollback any database changes. In other words, if the xUpdate() returns SQLITE_CONSTRAINT, the database contents must be exactly as they were before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by the xUpdate method are automatically rolled back by SQLite.</source>
          <target state="translated">또한 xBestIndex가 SQLITE_INDEX_SCAN_UNIQUE 플래그를 설정하면 SQLite는 가상 테이블 행을 삭제하거나 업데이트하기 위해 동일한 명령문의 일부로 xUpdate () 메서드를 호출하고 구현에서 SQLITE_CONSTRAINT를 반환한다고 가정합니다. 데이터베이스 변경 사항을 롤백합니다. 즉, xUpdate ()가 SQLITE_CONSTRAINT를 리턴하면 데이터베이스 내용은 xUpdate가 호출되기 전의 내용과 동일해야합니다. 반대로, SQLITE_INDEX_SCAN_UNIQUE가 설정되어 있지 않고 xUpdate가 SQLITE_CONSTRAINT를 반환하면 xUpdate 메서드에 의한 데이터베이스 변경 사항은 SQLite에 의해 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3296bcc9f5f36b885d1f44a772cfcd7df89079" translate="yes" xml:space="preserve">
          <source>Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get() since the last time the wal file was deleted. The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero. If either snapshot handle was obtained before the wal file was last deleted, the value returned by this function is undefined.</source>
          <target state="translated">또한 wal 파일이 마지막으로 삭제 된 이후 sqlite3_snapshot_get ()을 호출하여 두 스냅 샷 핸들을 모두 얻은 경우에만 비교 결과가 유효합니다. wal 파일은 데이터베이스가 롤백 모드로 다시 변경되거나 데이터베이스 클라이언트 수가 0으로 떨어지면 삭제됩니다. wal 파일을 마지막으로 삭제하기 전에 스냅 샷 핸들을 얻은 경우이 함수가 반환 한 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68ad616133628f7a9c711f524c6d649bfd1e605e" translate="yes" xml:space="preserve">
          <source>Adjust how SQLite does &lt;a href=&quot;malloc&quot;&gt;memory allocation&lt;/a&gt;, including setting up alternative memory allocators appropriate for safety-critical real-time embedded systems and application-defined memory allocators.</source>
          <target state="translated">안전에 중요한 실시간 임베디드 시스템 및 애플리케이션 정의 메모리 할당 자에 적합한 대체 메모리 할당자를 설정하는 등 SQLite가 &lt;a href=&quot;malloc&quot;&gt;메모리 할당을&lt;/a&gt; 수행하는 방식을 조정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b033ae4a69004f4620434e4722184d64e21543d" translate="yes" xml:space="preserve">
          <source>Adjust the &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; API so it more often returns the same values for &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements as it did in prior releases, to minimize disruption to applications that might be using that interface in unexpected ways.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; API를 조정하여 예기치 않은 방식으로 해당 인터페이스를 사용중인 애플리케이션의 중단을 최소화하기 위해 이전 릴리스에서 와 동일한 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문에 대해 동일한 값을 더 자주 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="af76f40123a61e61c36534a28bc6944e29327620" translate="yes" xml:space="preserve">
          <source>Adjust the unix driver to avoid unnecessary calls to fchown().</source>
          <target state="translated">fchown ()에 대한 불필요한 호출을 피하기 위해 유닉스 드라이버를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="8d239da6b2ab732b6958736d4e5cb3d6007246c9" translate="yes" xml:space="preserve">
          <source>Adjust the use of mutexes so that they are appropriate for various &lt;a href=&quot;threadsafe&quot;&gt;threading models&lt;/a&gt;, or substitute an application-defined mutex system.</source>
          <target state="translated">다양한 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모델에&lt;/a&gt; 적합하도록 뮤텍스의 사용을 조정 하거나 애플리케이션 정의 뮤텍스 시스템을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="94f5fc3d9b3cb240294c036969ed03df2f640df3" translate="yes" xml:space="preserve">
          <source>Adjusting SQLite To Use 8+3 Filenames</source>
          <target state="translated">8 + 3 파일 이름을 사용하도록 SQLite 조정</target>
        </trans-unit>
        <trans-unit id="42bff9e6720c99e5345613da344a0c1afa8b6dd4" translate="yes" xml:space="preserve">
          <source>Advance A Changeset Iterator</source>
          <target state="translated">Changeset Iterator 사전 진행</target>
        </trans-unit>
        <trans-unit id="5e8ccba8f1392a8bc7c3e697913930b9040f8c60" translate="yes" xml:space="preserve">
          <source>Advance cursor P1 so that it points to the next key/data pair in its table or index. If there are no more key/value pairs then fall through to the following instruction. But if the cursor advance was successful, jump immediately to P2.</source>
          <target state="translated">테이블 또는 인덱스에서 다음 키 / 데이터 쌍을 가리 키도록 커서 P1을 진행시킵니다. 더 이상 키 / 값 쌍이 없으면 다음 명령어로 넘어갑니다. 그러나 커서 이동이 성공하면 즉시 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="26c9571278da3b45a7da23cbb5f3d294d51fc11e" translate="yes" xml:space="preserve">
          <source>Advance virtual table P1 to the next row in its result set and jump to instruction P2. Or, if the virtual table has reached the end of its result set, then fall through to the next instruction.</source>
          <target state="translated">가상 테이블 P1을 결과 세트의 다음 행으로 진행하고 명령 P2로 이동하십시오. 또는 가상 테이블이 결과 세트의 끝에 도달하면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="e75e53f7ef6befbc2ec9555564b368fec377a5b4" translate="yes" xml:space="preserve">
          <source>Advantages of WAL-mode</source>
          <target state="translated">WAL 모드의 장점</target>
        </trans-unit>
        <trans-unit id="b8c612cc4e584be10a59711cc94c098821d2bdc6" translate="yes" xml:space="preserve">
          <source>Advocacy</source>
          <target state="translated">Advocacy</target>
        </trans-unit>
        <trans-unit id="2d3ad1756a210c3ecab852144ac9d98890b977fa" translate="yes" xml:space="preserve">
          <source>Affinity</source>
          <target state="translated">Affinity</target>
        </trans-unit>
        <trans-unit id="3b044120cd8e868bafac52b1f7cf9fb9852b7110" translate="yes" xml:space="preserve">
          <source>Affinity is applied to operands of a comparison operator prior to the comparison according to the following rules in the order shown:</source>
          <target state="translated">선호도는 다음 규칙에 따라 표시된 순서대로 비교 전에 비교 연산자의 피연산자에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4f72807708b980eccee8200e07c7d36460820a43" translate="yes" xml:space="preserve">
          <source>Affinity of</source>
          <target state="translated">친화력</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="23fd162046b3edf8ebd248698454f109bfd31f63" translate="yes" xml:space="preserve">
          <source>After ADD COLUMN has been run on a database, that database will not be readable by SQLite version 3.1.3 (2005-02-20) and earlier.</source>
          <target state="translated">ADD COLUMN이 데이터베이스에서 실행 된 후에는 SQLite 버전 3.1.3 (2005-02-20) 및 이전 버전에서 해당 데이터베이스를 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="027a417d23e6a18069001a7c19ad2bf39267a70e" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; has been prepared using any of &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; or one of the legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, this function must be called one or more times to evaluate the statement.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 또는 레거시 인터페이스 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 중 하나를 사용하여 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 준비한 후이 함수는 하나 이상이어야합니다. 진술을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="b4eec0463aaa1bd6eacaf86174eef649dd73f26c" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; has been evaluated by one or more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, it can be reset in order to be evaluated again by a call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. Think of &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; as rewinding the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; program back to the beginning. Using &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; on an existing &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; rather than creating a new &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; avoids unnecessary calls to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. For many SQL statements, the time needed to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; equals or exceeds the time needed by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. So avoiding calls to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; can give a significant performance improvement.</source>
          <target state="translated">후 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문이&lt;/a&gt; 하나 이상의 호출에 의해 평가 된 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; , 순서대로 다시 호출에 의해 다시 평가 될 수 있습니다 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 프로그램을 처음 으로 되 감는 것으로 생각하십시오 . 사용 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 기존에 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문을&lt;/a&gt; 하지 않고 새 만들기보다 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문하는 것은&lt;/a&gt; 불필요한 통화를 방지 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare을 ()&lt;/a&gt; . 많은 SQL 문의 경우 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 를 실행 하는 데 필요한 시간은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 필요한 시간과 같습니다 . 그래서 전화를 피&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 는 상당한 성능 향상을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="794711e92b4cb710edd2459f0377567195dd4b41" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; has been prepared using any of &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; or one of the legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, this function must be called one or more times to evaluate the statement.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 또는 레거시 인터페이스 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 중 하나를 사용하여 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 준비한 후이 함수는 하나 이상이어야합니다. 진술을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="610a52e97ff3ecd7651d2bc9d61eca8fe0a8d8a9" translate="yes" xml:space="preserve">
          <source>After a call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; returns SQLITE_LOCKED, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API may be invoked to register for an unlock-notify callback. The unlock-notify callback is invoked by SQLite after the database connection holding the table-lock that prevented the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; from succeeding has finished its transaction and released all locks. For example, if a call to sqlite3_step() is an attempt to read from table X, and some other connection Y is holding a write-lock on table X, then sqlite3_step() will return SQLITE_LOCKED. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is then called, the unlock-notify callback will be invoked after connection Y's transaction is concluded. The connection that the unlock-notify callback is waiting on, in this case connection Y, is known as the &quot;blocking connection&quot;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 호출이 SQLITE_LOCKED를 리턴 한 후, &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; API가 호출되어 잠금 해제 알림 콜백에 등록 될 수 있습니다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 호출 이 트랜잭션을 완료하지 못하고 모든 잠금을 해제 한 테이블 잠금을 보유한 데이터베이스 연결 후 데이터베이스 잠금 해제 알림 콜백이 SQLite에 의해 호출됩니다 . 예를 들어, sqlite3_step ()에 대한 호출이 테이블 X에서 읽기 시도이고 다른 연결 Y가 테이블 X에서 쓰기 잠금을 보유하는 경우 sqlite3_step ()은 SQLITE_LOCKED를 리턴합니다. &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify () 인&lt;/a&gt; 경우그런 다음 연결 Y의 트랜잭션이 완료된 후 잠금 해제 알림 콜백이 호출됩니다. 잠금 해제 알림 콜백이 대기중인 연결 (이 경우 연결 Y)을 &quot;차단 연결&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="4986de5057c6d05cb0ea3a0ad2727b5d055cdc6f" translate="yes" xml:space="preserve">
          <source>After a complete checkpoint, if no other connections are in transactions that use the WAL, then subsequent write transactions can overwrite the WAL file from the beginning. This is called &quot;resetting the WAL&quot;. At the start of the first new write transaction, the WAL header salt-1 value is incremented and the salt-2 value is randomized. These changes to the salts invalidate old frames in the WAL that have already been checkpointed but not yet overwritten, and prevent them from being checkpointed again.</source>
          <target state="translated">완전한 체크 포인트 후 WAL을 사용하는 트랜잭션에 다른 연결이 없으면 후속 쓰기 트랜잭션이 처음부터 WAL 파일을 겹쳐 쓸 수 있습니다. 이것을 &quot;WAL 재설정&quot;이라고합니다. 첫 번째 새 쓰기 트랜잭션이 시작되면 WAL 헤더 salt-1 값이 증가하고 salt-2 값이 무작위로 지정됩니다. 이러한 소금에 대한 변경 사항은 WAL에서 이미 검사 점이지만 아직 덮어 쓰지 않은 이전 프레임을 무효화하고 다시 검사 점을 만들지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="6b922aacb69272f39bced66a3ebf0a3033c1514f" translate="yes" xml:space="preserve">
          <source>After a database is closed, swarmvtab runs the equivalent of:</source>
          <target state="translated">데이터베이스가 닫힌 후 swarmvtab은 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="95563154fa733438ac343e5b67e301f468c45088" translate="yes" xml:space="preserve">
          <source>After a sequence of changes that define a single undo/redo step, invoke the undo::barrier command to define the limit of that step. In an interactive program, you can call undo::event after any change and undo::barrier will be called automatically as an idle callback.</source>
          <target state="translated">단일 실행 취소 / 다시 실행 단계를 정의하는 일련의 변경 후, undo :: barrier 명령을 호출하여 해당 단계의 한계를 정의하십시오. 대화식 프로그램에서 변경 후 undo :: event를 호출하면 undo :: barrier가 유휴 콜백으로 자동 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba37aebce03d74bebd4ab72ce08d7281954335c" translate="yes" xml:space="preserve">
          <source>After a session object has been configured, it begins monitoring for changes to its configured tables. However, it does not record an entire change each time a row within the database is modified. Instead, it records just the PRIMARY KEY fields for each inserted row, and just the PRIMARY KEY and all original row values for any updated or deleted rows. If a row is modified more than once by a single session, no new information is recorded.</source>
          <target state="translated">세션 오브젝트가 구성된 후에는 구성된 테이블의 변경 사항을 모니터링하기 시작합니다. 그러나 데이터베이스 내의 행이 수정 될 때마다 전체 변경 사항을 기록하지 않습니다. 대신, 삽입 된 각 행에 대한 PRIMARY KEY 필드와 업데이트되거나 삭제 된 행에 대한 PRIMARY KEY 및 모든 원래 행 값만 기록합니다. 단일 세션에서 행을 두 번 이상 수정하면 새로운 정보가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9ec21719ff7b0d3ffa4e429b7905254f04d4e5c" translate="yes" xml:space="preserve">
          <source>After a virtual machine has been generated using &lt;b&gt;sqlite_compile&lt;/b&gt; it is executed by one or more calls to &lt;b&gt;sqlite_step&lt;/b&gt;. Each invocation of &lt;b&gt;sqlite_step&lt;/b&gt;, except the last one, returns a single row of the result. The number of columns in the result is stored in the integer that the 2nd parameter points to. The pointer specified by the 3rd parameter is made to point to an array of pointers to column values. The pointer in the 4th parameter is made to point to an array of pointers to column names and datatypes. The 2nd through 4th parameters to &lt;b&gt;sqlite_step&lt;/b&gt; convey the same information as the 2nd through 4th parameters of the &lt;b&gt;callback&lt;/b&gt; routine when using the &lt;b&gt;sqlite_exec&lt;/b&gt; interface. Except, with &lt;b&gt;sqlite_step&lt;/b&gt; the column datatype information is always included in the in the 4th parameter regardless of whether or not the &lt;a href=&quot;pragma#pragma_show_datatypes&quot;&gt;SHOW_DATATYPES&lt;/a&gt; pragma is on or off.</source>
          <target state="translated">&lt;b&gt;sqlite_compile&lt;/b&gt; 을 사용하여 가상 머신을 생성 한 후 &lt;b&gt;sqlite_step&lt;/b&gt; 에 대한 하나 이상의 호출로 실행됩니다 . 마지막을 제외한 &lt;b&gt;sqlite_step의&lt;/b&gt; 각 호출은 결과의 단일 행을 리턴합니다. 결과의 열 수는 두 번째 매개 변수가 가리키는 정수로 저장됩니다. 3 번째 매개 변수로 지정된 포인터는 열 값에 대한 포인터 배열을 가리 키도록 만들어집니다. 네 번째 매개 변수의 포인터는 열 이름 및 데이터 유형에 대한 포인터 배열을 가리 키도록 만들어졌습니다. 에 4 매개 변수를 통해 제 2 &lt;b&gt;sqlite_step이&lt;/b&gt; 의 네번째 매개 변수를 통해 2와 같은 정보를 전달하는 &lt;b&gt;콜백&lt;/b&gt; 사용하는 경우 루틴을 &lt;b&gt;sqlite_exec&lt;/b&gt; 인터페이스를. 제외하고&lt;b&gt;sqlite_step&lt;/b&gt; 열 데이터 유형 정보는 &lt;a href=&quot;pragma#pragma_show_datatypes&quot;&gt;SHOW_DATATYPES&lt;/a&gt; pragma 의 설정 여부에 관계없이 항상 4 번째 매개 변수에 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="23265bf656595ac1bd3eabed0b381392ce07d2ae" translate="yes" xml:space="preserve">
          <source>After all information in the rollback journal has been played back into the database file (and flushed to disk in case we encounter yet another power failure), the hot rollback journal can be deleted.</source>
          <target state="translated">롤백 저널의 모든 정보가 데이터베이스 파일로 재생 된 후 (또 다른 전원 장애가 발생할 경우 디스크로 플러시 됨) 핫 롤백 저널을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84435139a07c4a4055bb439605dbd8c9789e7d7" translate="yes" xml:space="preserve">
          <source>After all needed changes are completed, xWrite() is used to move the content back into the database file. Hence the use of memory mapped I/O does not significantly change the performance of database changes. Memory mapped I/O is mostly a benefit for queries.</source>
          <target state="translated">필요한 모든 변경이 완료되면 xWrite ()를 사용하여 내용을 다시 데이터베이스 파일로 이동합니다. 따라서 메모리 맵핑 I / O를 사용해도 데이터베이스 변경 성능이 크게 변경되지 않습니다. 메모리 매핑 I / O는 대부분 쿼리에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="260239065f2a92ea494a87b7cf4ba2a2d941420e" translate="yes" xml:space="preserve">
          <source>After all records have been inserted into the Sorter object identified by P1, invoke this opcode to actually do the sorting. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if there are no records to be sorted.</source>
          <target state="translated">P1으로 식별 된 Sorter 개체에 모든 레코드를 삽입 한 후 실제로 정렬을 수행하려면이 opcode를 호출하십시오. 정렬 할 레코드가 없으면 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f3fc80e50134d3edb76d5d844058ab5382b20cae" translate="yes" xml:space="preserve">
          <source>After all rows are processed the countFinalize() routine is called exactly once. This routine computes the final result and invokes one of the &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result()&lt;/a&gt; family of functions to set the final result. The aggregate context will be freed automatically by SQLite, though the xFinalize() routine must clean up any substructure associated with the aggregate context before it returns. If the xStep() method is called one or more times, then SQLite guarantees thta the xFinal() method will be called at once, even if the query aborts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1079dc3c758cc45d2f271e573db223c2cdb12648" translate="yes" xml:space="preserve">
          <source>After an SQL statement has been prepared (and optionally bound), it is executed using:</source>
          <target state="translated">SQL 문이 준비된 후 (선택적으로 바인드 된) 다음을 사용하여 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="19e517dcca2fb3c783a27c4dacd0285a95c871db" translate="yes" xml:space="preserve">
          <source>After any changes to the TEMP database schema, all prepared statements are invalidated and must be recreated using a new call to sqlite3_prepare()</source>
          <target state="translated">TEMP 데이터베이스 스키마를 변경 한 후 모든 준비된 명령문은 무효화되며 sqlite3_prepare ()에 대한 새로운 호출을 사용하여 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8dfe7bdc91c90b1d784f46b505207e5b5bb9de" translate="yes" xml:space="preserve">
          <source>After duplicating the key, the next instruction, NotExists, pops the stack once and uses the value popped as a key to check the existence of a record in the database file. If there is no record for this key, it jumps back to the ListRead to get another key.</source>
          <target state="translated">키를 복제 한 후 다음 명령 인 NotExists는 스택을 한 번 팝하고 키로 팝된 값을 사용하여 데이터베이스 파일에 레코드가 있는지 확인합니다. 이 키에 대한 레코드가 없으면 다른 키를 얻기 위해 ListRead로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="838513ea0f9681d04eb27d7879229c002b821a85" translate="yes" xml:space="preserve">
          <source>After each INSERT on ex1, the ex1_it trigger constructs text of a DELETE statement that will undo the INSERT. The ex1_ut trigger constructs an UPDATE statement that will undo the effects of an UPDATE. And the ex1_dt trigger constructs a statement that will undo the effects of a DELETE.</source>
          <target state="translated">ex1의 각 INSERT 후에 ex1_it 트리거는 INSERT를 실행 취소 할 DELETE 문의 텍스트를 구성합니다. ex1_ut 트리거는 UPDATE의 영향을 취소하는 UPDATE 문을 구성합니다. 그리고 ex1_dt 트리거는 DELETE의 영향을 취소하는 명령문을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="126fa1adfbc14e51e51271a3d3ed7613c3632f33" translate="yes" xml:space="preserve">
          <source>After gcov has been run to verify 100% branch test coverage, then the test program is recompiled using delivery compiler options (without the special -fprofile-arcs and -ftest-coverage options) and the test program is rerun. This second run is the actual test of SQLite.</source>
          <target state="translated">gcov가 100 % 분기 테스트 적용 범위를 검증하기 위해 실행 된 후, 전달 컴파일러 옵션 (특수 -fprofile-arcs 및 -ftest-coverage 옵션없이)을 사용하여 테스트 프로그램이 재 컴파일되고 테스트 프로그램이 다시 실행됩니다. 이 두 번째 실행은 SQLite의 실제 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="db8afe929b966e405547381b33bfdc15bcc08124" translate="yes" xml:space="preserve">
          <source>After obtaining a RESERVED lock, the process that wants to write creates a rollback journal. The header of the journal is initialized with the original size of the database file. Space in the journal header is also reserved for a master journal name, though the master journal name is initially empty.</source>
          <target state="translated">예약 된 잠금을 확보 한 후, 작성하려는 프로세스는 롤백 저널을 작성합니다. 저널의 헤더는 데이터베이스 파일의 원래 크기로 초기화됩니다. 마스터 저널 이름이 처음에는 비어 있지만 저널 헤더의 공간도 마스터 저널 이름을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6274aa024e5dcdb153f9792763e691d72ddb17d5" translate="yes" xml:space="preserve">
          <source>After obtaining a RESERVED lock, the process that wants to write creates a rollback journal. The header of the journal is initialized with the original size of the database file. Space in the journal header is also reserved for a super-journal name, though the super-journal name is initially empty.</source>
          <target state="translated">RESERVED 잠금을 확보 한 후 쓰려는 프로세스는 롤백 저널을 작성합니다. 저널의 헤더는 데이터베이스 파일의 원래 크기로 초기화됩니다. 초 저널 이름은 처음에 비어 있지만 저널 헤더의 공백은 초 저널 이름으로도 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="1634d30fc252b255d4609b96665517fdcea9fa73" translate="yes" xml:space="preserve">
          <source>After process-wide configuration is complete and &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; have been created, individual database connections can be configured using calls to &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="translated">프로세스 전체 구성이 완료되고 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 작성된 후 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에 대한&lt;/a&gt; 호출을 사용하여 개별 데이터베이스 연결을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3999670e271fa814391d216ed801ffd36e68c0e2" translate="yes" xml:space="preserve">
          <source>After reading the data for a database page, SQLite stores the raw page of data in the</source>
          <target state="translated">데이터베이스 페이지의 데이터를 읽은 후 SQLite는 원시 데이터 페이지를</target>
        </trans-unit>
        <trans-unit id="f403207f2b4b981533796c7ad5f8378ebe08c950" translate="yes" xml:space="preserve">
          <source>After resolving conflicts, many users like to compile and test the new version before committing it to the repository. Or you can commit first and test later. Either way, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check-in the circle (5) version.</source>
          <target state="translated">충돌을 해결 한 후 많은 사용자가 새 버전을 리포지토리에 커밋하기 전에 컴파일하고 테스트하기를 원합니다. 또는 먼저 커밋하고 나중에 테스트 할 수 있습니다. 어느 쪽이든, &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;명령을 실행 하여 서클 (5) 버전을 체크인하십시오.</target>
        </trans-unit>
        <trans-unit id="c63b949f4e88ad0a023a0bdd59afe48dabc17031" translate="yes" xml:space="preserve">
          <source>After running the CREATE TABLE statement, disable the imposter mechanism as follows:</source>
          <target state="translated">CREATE TABLE 문을 실행 한 후 다음과 같이 임 포스터 메커니즘을 사용 불가능하게하십시오.</target>
        </trans-unit>
        <trans-unit id="538eea92ccc130ef6b680c0e55263bee066d1733" translate="yes" xml:space="preserve">
          <source>After successfully opening a file-handle on a potentially hot journal file, SQLite shall query the file for its size in bytes using the xFileSize() method of the open file handle.</source>
          <target state="translated">잠재적으로 핫 저널 파일에서 파일 핸들을 성공적으로 열면 SQLite는 열린 파일 핸들의 xFileSize () 메서드를 사용하여 파일 크기를 바이트 단위로 쿼리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fbe2d1674af788e8343a14ee7a4129b26ca4886" translate="yes" xml:space="preserve">
          <source>After the</source>
          <target state="translated">후</target>
        </trans-unit>
        <trans-unit id="f2360cfd6cf46af06ac709eb02497e9aff167465" translate="yes" xml:space="preserve">
          <source>After the algorithm above completes successfully, it is safe to read from the database file. Once all reading has completed, the SHARED lock is dropped.</source>
          <target state="translated">위의 알고리즘이 성공적으로 완료되면 데이터베이스 파일에서 읽는 것이 안전합니다. 모든 판독이 완료되면 SHARED 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="157772fcdfe2470be92e77475005f7ac0b098542" translate="yes" xml:space="preserve">
          <source>After the application has finished with the result from sqlite3_get_table(), it must pass the result table pointer to sqlite3_free_table() in order to release the memory that was malloced. Because of the way the &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; happens within sqlite3_get_table(), the calling function must not try to call &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; directly. Only &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; is able to release the memory properly and safely.</source>
          <target state="translated">응용 프로그램이 sqlite3_get_table ()의 결과로 완료된 후, malloced 된 메모리를 해제하려면 결과 테이블 포인터를 sqlite3_free_table ()에 전달해야합니다. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 이 sqlite3_get_table () 내에서 발생 하는 방식 때문에 호출 함수는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 직접 호출하지 않아야합니다 . &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table ()&lt;/a&gt; 만이 메모리를 적절하고 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c64408a8164063ed860f68818eaa546c62a346e" translate="yes" xml:space="preserve">
          <source>After the application has finished with the result from sqlite3_get_table(), it must pass the result table pointer to sqlite3_free_table() in order to release the memory that was malloced. Because of the way the &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; happens within sqlite3_get_table(), the calling function must not try to call &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; directly. Only &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; is able to release the memory properly and safely.</source>
          <target state="translated">응용 프로그램이 sqlite3_get_table ()의 결과로 완료된 후, malloced 된 메모리를 해제하려면 결과 테이블 포인터를 sqlite3_free_table ()에 전달해야합니다. &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 이 sqlite3_get_table () 내에서 발생 하는 방식 때문에 호출 함수는 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 직접 호출하지 않아야합니다 . &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table ()&lt;/a&gt; 만이 메모리를 적절하고 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af39ba2343efa84bf5f79d3192cc7d9b779717a4" translate="yes" xml:space="preserve">
          <source>After the database changes are all safely on the mass storage device, the rollback journal file is deleted. This is the instant where the transaction commits. If a power failure or system crash occurs prior to this point, then recovery processes to be described later make it appear as if no changes were ever made to the database file. If a power failure or system crash occurs after the rollback journal is deleted, then it appears as if all changes have been written to disk. Thus, SQLite gives the appearance of having made no changes to the database file or having made the complete set of changes to the database file depending on whether or not the rollback journal file exists.</source>
          <target state="translated">데이터베이스 변경 사항이 모두 대량 저장 장치에서 안전하게 된 후 롤백 저널 파일이 삭제됩니다. 이것이 트랜잭션이 커밋되는 순간입니다. 이 시점 이전에 정전 또는 시스템 충돌이 발생하면 나중에 설명 할 복구 프로세스가 데이터베이스 파일을 변경하지 않은 것처럼 나타납니다. 롤백 저널이 삭제 된 후 정전 또는 시스템 충돌이 발생하면 모든 변경 사항이 디스크에 기록 된 것처럼 나타납니다. 따라서 SQLite는 롤백 저널 파일의 존재 여부에 따라 데이터베이스 파일을 변경하지 않았거나 데이터베이스 파일을 완전히 변경 한 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="8bb7688984c453ad2bc60e9833b1d02d648b8f95" translate="yes" xml:space="preserve">
          <source>After the header and zero padding are zero or more page records. Each page record stores a copy of the content of a page from the database file before it was changed. The same page may not appear more than once within a single rollback journal. To rollback an incomplete transaction, a process has merely to read the rollback journal from beginning to end and write pages found in the journal back into the database file at the appropriate location.</source>
          <target state="translated">헤더와 제로 패딩 이후에는 0 개 이상의 페이지 레코드가 있습니다. 각 페이지 레코드는 변경되기 전에 데이터베이스 파일의 페이지 컨텐츠 사본을 저장합니다. 단일 롤백 저널에 동일한 페이지가 두 번 이상 나타나지 않을 수 있습니다. 불완전한 트랜잭션을 롤백하려면 프로세스는 롤백 저널을 처음부터 끝까지 읽고 저널에서 찾은 페이지를 적절한 위치의 데이터베이스 파일에 다시 쓰기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4bc35438aded45e22aeee0454d230e53ab207bab" translate="yes" xml:space="preserve">
          <source>After the imposter table is loaded into SQLite's internal schema as described above, the imposter table can be used as any other table. But the imposter table will only be visible to the one database connection that created it. No changes are made to the database file on disk. And the imposter table will disappear the next time the schema is loaded.</source>
          <target state="translated">위에서 설명한대로 임 포스터 테이블을 SQLite의 내부 스키마에로드 한 후에는 임 포스터 테이블을 다른 테이블로 사용할 수 있습니다. 그러나 임 포스터 테이블은이를 생성 한 하나의 데이터베이스 연결에서만 볼 수 있습니다. 디스크의 데이터베이스 파일은 변경되지 않습니다. 그리고 다음에 스키마가로드 될 때 임 포스터 테이블이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="6fb2487148ee10be0a40ce759f7c45930d397db5" translate="yes" xml:space="preserve">
          <source>After the master journal is constructed, its content is flushed to disk before any further actions are taken. On Unix, the directory that contains the master journal is also synced in order to make sure the master journal file will appear in the directory following a power failure.</source>
          <target state="translated">마스터 저널이 구성된 후에는 추가 조치를 취하기 전에 해당 컨텐츠가 디스크로 플러시됩니다. Unix에서는 마스터 저널 파일이 정전 후에 디렉토리에 표시되도록 마스터 저널이 포함 된 디렉토리도 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="93f402b283ab865f9a9eb59bcf905d302373fd8f" translate="yes" xml:space="preserve">
          <source>After the original page content has been saved in the rollback journal, the pages can be modified in user memory. Each database connection has its own private copy of user space, so the changes that are made in user space are only visible to the database connection that is making the changes. Other database connections still see the information in operating system disk cache buffers which have not yet been changed. And so even though one process is busy modifying the database, other processes can continue to read their own copies of the original database content.</source>
          <target state="translated">원본 페이지 내용이 롤백 저널에 저장되면 사용자 메모리에서 페이지를 수정할 수 있습니다. 각 데이터베이스 연결에는 고유 한 개인 사용자 공간 사본이 있으므로 사용자 공간에서 작성된 변경 사항은 변경중인 데이터베이스 연결에서만 볼 수 있습니다. 다른 데이터베이스 연결에는 아직 변경되지 않은 운영 체제 디스크 캐시 버퍼의 정보가 여전히 표시됩니다. 따라서 한 프로세스가 데이터베이스를 수정하는 중이라도 다른 프로세스는 계속해서 자신의 원본 데이터베이스 컨텐츠 사본을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b39bcb3162c3e5bf861268807e2f722487ba46f2" translate="yes" xml:space="preserve">
          <source>After the parser assembles tokens into a parse tree, the code generator runs to analyze the parser tree and generate &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; that performs the work of the SQL statement. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is a container for this bytecode. There are many files in the code generator, including: &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/pragma.c&quot;&gt;pragma.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/wherecode.c&quot;&gt;wherecode.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/whereexpr.c&quot;&gt;whereexpr.c&lt;/a&gt;. In these files is where most of the serious magic happens. &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; handles code generation for expressions. &lt;b&gt;where*.c&lt;/b&gt; handles code generation for WHERE clauses on SELECT, UPDATE and DELETE statements. The files &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt; handle the code generation for SQL statements with the same names. (Each of these files calls routines in &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; as necessary.) All other SQL statements are coded out of &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt; file implements the functionality of &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt;.</source>
          <target state="translated">구문 분석기가 토큰을 구문 분석 트리로 어셈블 한 후 코드 생성기가 실행되어 구문 분석기 트리를 분석 하고 SQL 문 작업을 수행하는 &lt;a href=&quot;opcode&quot;&gt;바이트 코드&lt;/a&gt; 를 생성 합니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체는이 바이트 코드의 컨테이너입니다. 코드 생성기에는 &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/pragma.c&quot;&gt;pragma.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt; 등 많은 파일이 있습니다. , &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/wherecode.c&quot;&gt;wherecode.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/whereexpr.c&quot;&gt;whereexpr.c&lt;/a&gt;. 이 파일에서 대부분의 심각한 마법이 발생합니다. &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; 는 표현식의 코드 생성을 처리합니다. &lt;b&gt;where * .c&lt;/b&gt; 는 SELECT, UPDATE 및 DELETE 문에서 WHERE 절에 대한 코드 생성을 처리합니다. 파일의 &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c의 &lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c의&lt;/a&gt; 같은 이름을 가진 SQL 문에 대한 핸들 코드 생성. (이러한 각 파일은 필요에 따라 &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; 에서 루틴을 호출합니다 .) 다른 모든 SQL 문은 &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c에서&lt;/a&gt; 코드화됩니다 . &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c의&lt;/a&gt; 파일의 기능을 구현&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e1c3e7c8a391dcea0df2cfdb448d836a449fa44" translate="yes" xml:space="preserve">
          <source>After the query loop ends, the table being queried is closed at instruction 14. This is done early in order to allow other processes or threads to access that table, if desired. The list of records that was built up inside the query loop is sorted by the instruction at 15. Instructions 16 through 18 walk through the record list (which is now in sorted order) and invoke the callback once for each record. Finally, the sorter is closed at instruction 19.</source>
          <target state="translated">쿼리 루프가 종료 된 후 쿼리중인 테이블은 명령어 14에서 닫힙니다. 원하는 경우 다른 프로세스 나 스레드가 해당 테이블에 액세스 할 수 있도록하기 위해 초기에 수행됩니다. 쿼리 루프 내에 구축 된 레코드 목록은 15 번 명령으로 정렬됩니다. 명령 16에서 18까지는 레코드 목록 (이제 정렬 된 순서)을 안내하고 각 레코드에 대해 콜백을 한 번 호출합니다. 마지막으로 분류기는 명령 19에서 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f7a2e27dec51b31c6ed11a02889862c44fec50cf" translate="yes" xml:space="preserve">
          <source>After the query loop is finished, the table &quot;examp2&quot; is closed at instruction 23 so that its lock will be released and it can be used by other threads or processes. The next step is to loop over all aggregate buckets and output one row of the result for each bucket. This is done by the loop at instructions 24 through 30. The AggNext instruction at 24 brings the next bucket into focus, or jumps to the end of the loop if all buckets have been examined already. The 3 columns of the result are fetched from the aggregator bucket in order at instructions 25 through 27. Finally, the callback is invoked at instruction 29.</source>
          <target state="translated">쿼리 루프가 완료된 후 명령 &quot;23&quot;에서 &quot;examp2&quot;테이블이 닫히고 잠금이 해제되어 다른 스레드 나 프로세스에서 사용할 수 있습니다. 다음 단계는 모든 집계 버킷을 반복하고 각 버킷에 대해 결과의 한 행을 출력하는 것입니다. 이는 명령 24에서 30까지의 루프에 의해 수행됩니다. 24의 AggNext 명령은 다음 버킷을 포커스 상태로 만들거나 모든 버킷이 이미 검사 된 경우 루프의 끝으로 이동합니다. 명령어 25에서 27까지 순서대로 결과의 3 개 열이 수집기 버킷에서 페치됩니다. 마지막으로, 명령어 29에서 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="429426adc150c9c3ef8de6d6350a6529072871cf" translate="yes" xml:space="preserve">
          <source>After the shared lock is acquired, we can begin reading information from the database file. In this scenario, we are assuming a cold cache, so information must first be read from mass storage into the operating system cache then transferred from operating system cache into user space. On subsequent reads, some or all of the information might already be found in the operating system cache and so only the transfer to user space would be required.</source>
          <target state="translated">공유 잠금이 확보 된 후 데이터베이스 파일에서 정보 읽기를 시작할 수 있습니다. 이 시나리오에서는 콜드 캐시를 가정하고 있으므로 먼저 대용량 스토리지에서 운영 체제 캐시로 정보를 읽은 다음 운영 체제 캐시에서 사용자 공간으로 전송해야합니다. 이후에 읽을 때 일부 또는 모든 정보가 이미 운영 체제 캐시에있을 수 있으므로 사용자 공간으로의 전송 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7dbb1609bfd1352286bb98fe2bf2342dc300ba85" translate="yes" xml:space="preserve">
          <source>After the sqlite3_test_control() call above, then run a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement the defines the imposter table. With the imposter mechanism enabled, this CREATE TABLE statement does not create a real table but instead merely adds an entry in SQLite's internal symbol table. Note that the CREATE TABLE statement must be in the correct format for the index. If the imposter table has the wrong number of columns or is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or is otherwise incompatible with the index b-tree, then &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors will result when the imposter table is used.</source>
          <target state="translated">위의 sqlite3_test_control () 호출 후 임 포스터 테이블을 정의 하는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 을 실행 하십시오. 임 포스터 메커니즘이 사용 가능한 경우,이 CREATE TABLE 문은 실제 테이블을 작성하지 않고 SQLite의 내부 기호 테이블에 항목을 추가하기 만합니다. CREATE TABLE 문은 인덱스에 올바른 형식이어야합니다. 임 포스터 테이블에 잘못된 수의 열이 있거나 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아니 거나 인덱스 b- 트리와 호환되지 않는 경우 임 포스터 테이블을 사용할 때 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="19b56f4a17eee54fbb6b1cf61515b7eba9136d01" translate="yes" xml:space="preserve">
          <source>After the super-journal is constructed, its content is flushed to disk before any further actions are taken. On Unix, the directory that contains the super-journal is also synced in order to make sure the super-journal file will appear in the directory following a power failure.</source>
          <target state="translated">수퍼 저널이 생성 된 후 추가 작업이 수행되기 전에 해당 콘텐츠가 디스크로 플러시됩니다. Unix에서는 정전 후 수퍼 저널 파일이 디렉토리에 나타나도록 수퍼 저널이 포함 된 디렉토리도 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="fbbb0de8accee9d1365cb588f7fd022b3b5c2ef0" translate="yes" xml:space="preserve">
          <source>After the virtual table has been populated with items from multiple languages, specify the language of interest using a &quot;langid=N&quot; term in the WHERE clause of the query:</source>
          <target state="translated">가상 테이블이 여러 언어의 항목으로 채워진 후 쿼리의 WHERE 절에서 &quot;langid = N&quot;용어를 사용하여 관심있는 언어를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="71df6ec7d17df1770a907c6872e525177a99e4ae" translate="yes" xml:space="preserve">
          <source>AggFinal</source>
          <target state="translated">AggFinal</target>
        </trans-unit>
        <trans-unit id="5429b1962421b3a7ef0110360651a4a4da33b0bd" translate="yes" xml:space="preserve">
          <source>AggInverse</source>
          <target state="translated">AggInverse</target>
        </trans-unit>
        <trans-unit id="d448b9ea9be90bab4fd06d12a2a56f0f2d29976a" translate="yes" xml:space="preserve">
          <source>AggStep</source>
          <target state="translated">AggStep</target>
        </trans-unit>
        <trans-unit id="cec3f9e0080e6fe913455f3060c1205f8c71a2e5" translate="yes" xml:space="preserve">
          <source>AggStep1</source>
          <target state="translated">AggStep1</target>
        </trans-unit>
        <trans-unit id="d64e85e2bbdea61d402b8d3446eb6ec6b1845b61" translate="yes" xml:space="preserve">
          <source>AggValue</source>
          <target state="translated">AggValue</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="d7162a0d5ccbad3a77b64c735aa5b633485f7bdb" translate="yes" xml:space="preserve">
          <source>Aggregate Functions And The GROUP BY and HAVING Clauses</source>
          <target state="translated">집계 함수 및 GROUP BY 및 HAVING 절</target>
        </trans-unit>
        <trans-unit id="b2609ee93dbad1daa0d495db10944455f8b52f8e" translate="yes" xml:space="preserve">
          <source>Aggregate SQL functions are implemented by using two callback functions, &lt;b&gt;xStep&lt;/b&gt; and &lt;b&gt;xFinal&lt;/b&gt;. The xStep() function is called for each row of the aggregate and the xFinal() function is invoked to compute the final answer at the end. The following (slightly simplified) version of the built-in count() function illustrates:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a5e493a395536162c8208afa9edceff4645801" translate="yes" xml:space="preserve">
          <source>Aggregate window functions</source>
          <target state="translated">집계 창 기능</target>
        </trans-unit>
        <trans-unit id="96017d1624d86e09bd79e2a89a0c2374923ae0bf" translate="yes" xml:space="preserve">
          <source>Aggregate-mode meaning</source>
          <target state="translated">집계 모드 의미</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="37b83d77a9eb919bf1eed567f29546fa4dda4c46" translate="yes" xml:space="preserve">
          <source>All C-preprocessor macros used to control compile-time options now begin with the prefix &quot;SQLITE_&quot;. This may require changes to applications that compile SQLite using their own makefiles and with custom compile-time options, hence we mark this as a *** Potentially incompatible change ***</source>
          <target state="translated">컴파일 타임 옵션을 제어하는 ​​데 사용되는 모든 C 전 처리기 매크로는 이제 접두사 &quot;SQLITE_&quot;로 시작합니다. 자체 makefile과 사용자 정의 컴파일 타임 옵션을 사용하여 SQLite를 컴파일하는 응용 프로그램을 변경해야 할 수 있으므로 *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="c755a70a5620bfbf08d2e74296f5e3952109420b" translate="yes" xml:space="preserve">
          <source>All FTS5 tables feature a special hidden column named &quot;rank&quot;. If the current query is not a full-text query (i.e. if it does not include a MATCH operator), the value of the &quot;rank&quot; column is always NULL. Otherwise, in a full-text query, column rank contains by default the same value as would be returned by executing the bm25() auxiliary function with no trailing arguments.</source>
          <target state="translated">모든 FTS5 테이블에는 &quot;rank&quot;라는 특수 숨겨진 열이 있습니다. 현재 쿼리가 전체 텍스트 쿼리가 아닌 경우 (예 : MATCH 연산자가 포함되지 않은 경우) &quot;rank&quot;열의 값은 항상 NULL입니다. 그렇지 않으면 전체 텍스트 쿼리에서 열 순위에는 기본적으로 후행 인수없이 bm25 () 보조 함수를 실행하여 반환되는 것과 동일한 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb6feba3d971df2c155ebbf32ecf1aeefc50b98" translate="yes" xml:space="preserve">
          <source>All RBU updates use the &quot;OR ROLLBACK&quot; constraint handling mechanism.</source>
          <target state="translated">모든 RBU 업데이트는 &quot;OR ROLLBACK&quot;제약 조건 처리 메커니즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="298c1a6a5b3113028f5781057322c183e5fb18cf" translate="yes" xml:space="preserve">
          <source>All SQLite database connections running within a single process share a single</source>
          <target state="translated">단일 프로세스 내에서 실행되는 모든 SQLite 데이터베이스 연결은 단일 프로세스를 공유합니다</target>
        </trans-unit>
        <trans-unit id="68fd5c55fe4176eb0a40eb1e510440312024923d" translate="yes" xml:space="preserve">
          <source>All SQLite releases starting with 3.9.0 use a three-number &quot;&lt;a href=&quot;http://semver.org&quot;&gt;semantic version&lt;/a&gt;&quot; of the form X.Y.Z. The first number X is only increased when there is a change that breaks backward compatibility. The current value for X is 3, and the SQLite developers plan to support the current SQLite database file format, SQL syntax, and C interface through &lt;a href=&quot;lts&quot;&gt;at least the year 2050&lt;/a&gt;. Hence, one can expect that all future versions of SQLite for the next several decades will begin with &quot;3.&quot;.</source>
          <target state="translated">3.9.0으로 시작하는 모든 SQLite 릴리스 는 XYZ 형식 의 3 개의 &quot; &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전&lt;/a&gt; &quot;을 사용합니다. 첫 번째 숫자 X는 이전 버전과의 호환성을 손상시키는 변경이있을 때만 증가합니다. X의 현재 값은 3이며 SQLite 개발자 &lt;a href=&quot;lts&quot;&gt;는 2050 년 이상&lt;/a&gt; 현재 SQLite 데이터베이스 파일 형식, SQL 구문 및 C 인터페이스를 지원할 계획 입니다. 따라서 향후 수십 년 동안의 모든 향후 버전의 SQLite는 &quot;3&quot;으로 시작될 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf3befd42e47b2311a200fc6c4505d6d3e74ba2" translate="yes" xml:space="preserve">
          <source>All calls obtain an exclusive &quot;checkpoint&quot; lock on the database file. If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY is returned. Even if there is a busy-handler configured, it will not be invoked in this case.</source>
          <target state="translated">모든 호출은 데이터베이스 파일에 대한 독점 &quot;체크 포인트&quot;잠금을 얻습니다. 다른 프로세스가 동시에 체크 포인트 조작을 실행중인 경우 잠금을 확보 할 수 없으며 SQLITE_BUSY가 리턴됩니다. 사용중인 처리기가 구성되어 있어도이 경우에는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34e057ca62b435caa749880050f6e16611809628" translate="yes" xml:space="preserve">
          <source>All changes made by these functions are enclosed in a savepoint transaction. If any other error (aside from a constraint failure when attempting to write to the target database) occurs, then the savepoint transaction is rolled back, restoring the target database to its original state, and an SQLite error code returned.</source>
          <target state="translated">이 기능에 의한 모든 변경 사항은 저장 점 트랜잭션으로 묶여 있습니다. 대상 데이터베이스에 쓰려고 할 때 제한 조건 실패를 제외한 다른 오류가 발생하면 저장 점 트랜잭션이 롤백되어 대상 데이터베이스를 원래 상태로 복원하고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d1dddd8355c69e5dffb77af16e6ef1de6dd31f80" translate="yes" xml:space="preserve">
          <source>All changes to a virtual table are made using the xUpdate method. This one method can be used to insert, delete, or update.</source>
          <target state="translated">가상 테이블에 대한 모든 변경은 xUpdate 메소드를 사용하여 수행됩니다. 이 방법을 사용하여 삽입, 삭제 또는 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5f7c518c035d2e61b79e18649b848121cf76a11" translate="yes" xml:space="preserve">
          <source>All changes to be applied by RBU are stored in a separate SQLite database called the &quot;RBU database&quot;. The database that is to be modified is called the &quot;target database&quot;.</source>
          <target state="translated">RBU에 의해 적용되는 모든 변경 사항은 &quot;RBU 데이터베이스&quot;라는 별도의 SQLite 데이터베이스에 저장됩니다. 수정할 데이터베이스를 &quot;대상 데이터베이스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="99a33b875d90f9fced8d63e555c38a8d47436549" translate="yes" xml:space="preserve">
          <source>All code is archived on three separate machines: &lt;a href=&quot;https://www.sqlite.org&quot;&gt;https://www.sqlite.org&lt;/a&gt;, &lt;a href=&quot;https://www2.sqlite.org&quot;&gt;https://www2.sqlite.org&lt;/a&gt;, &lt;a href=&quot;https://www3.sqlite.org&quot;&gt;https://www3.sqlite.org&lt;/a&gt;. These machines are located in different cities (Dallas, Newark, and San Francisco, respectively) and managed by two different hosting companies (&lt;a href=&quot;https://linode.com&quot;&gt;Linode&lt;/a&gt; for the first two and &lt;a href=&quot;https://digitalocean.com&quot;&gt;Digital Ocean&lt;/a&gt; for the third). This diversity is intended to avoid a single point of failure.</source>
          <target state="translated">모든 코드는 &lt;a href=&quot;https://www.sqlite.org&quot;&gt;https://www.sqlite.org&lt;/a&gt; , &lt;a href=&quot;https://www2.sqlite.org&quot;&gt;https://www2.sqlite.org&lt;/a&gt; , &lt;a href=&quot;https://www3.sqlite.org&quot;&gt;https://www3.sqlite.org라는&lt;/a&gt; 세 개의 별도 시스템에 보관됩니다 . 이 시스템은 다른 도시 (각각 달라스, 뉴 어크 및 샌프란시스코)에 위치하고 있으며 두 개의 다른 호스팅 회사 ( 첫 번째 두 개는 &lt;a href=&quot;https://linode.com&quot;&gt;Linode&lt;/a&gt; , 세 번째는 &lt;a href=&quot;https://digitalocean.com&quot;&gt;Digital Ocean&lt;/a&gt; )가 관리합니다. 이 다양성은 단일 장애 지점을 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9708b5aef2e3a29e2a2fbfcf884786831700182" translate="yes" xml:space="preserve">
          <source>All common table expressions (ordinary and recursive) are created by prepending a WITH clause in front of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. A single WITH clause can specify one or more common table expressions, some of which are ordinary and some of which are recursive.</source>
          <target state="translated">모든 공통 테이블 표현식 (일반 및 재귀)은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 앞에 WITH 절을 추가하여 작성됩니다 . 단일 WITH 절은 하나 이상의 공통 테이블 표현식을 지정할 수 있으며, 일부는 일반이고 일부는 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="202e588a0b168a0b374436adc14ca3f0090beda4" translate="yes" xml:space="preserve">
          <source>All component tables must have the same PRIMARY KEY declaration (if any).</source>
          <target state="translated">모든 구성 요소 테이블에는 동일한 PRIMARY KEY 선언이 있어야합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="daa2fa17b60e175765b75266a7e677f096a5be75" translate="yes" xml:space="preserve">
          <source>All component tables must have the same set of columns, in the same order.</source>
          <target state="translated">모든 구성 요소 테이블에는 동일한 순서로 동일한 열 세트가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="220fd2211d0e90275b8fb6a6e680abc0805ee11c" translate="yes" xml:space="preserve">
          <source>All connections hold SQLITE_LOCK_SHARED continuously while attached to a WAL-mode database. This is true for both read/write connections and read-only connections. The SQLITE_LOCK_SHARED lock is held even by connections that are not within transaction. This is different from rollback mode, where the SQLITE_LOCK_SHARED is released at the end of each transaction.</source>
          <target state="translated">모든 연결은 WAL 모드 데이터베이스에 연결되어있는 동안 SQLITE_LOCK_SHARED를 지속적으로 유지합니다. 읽기 / 쓰기 연결과 읽기 전용 연결 모두에 해당됩니다. SQLITE_LOCK_SHARED 잠금은 트랜잭션 내에 있지 않은 연결에서도 유지됩니다. 이는 롤백 모드와 다릅니다. 여기서 롤백 모드는 SQLITE_LOCK_SHARED가 각 트랜잭션 종료시 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="1db69a4cb9aa71154b4679a0d792a8e8fa8bc80c" translate="yes" xml:space="preserve">
          <source>All custom SQL functions will accept text in any encoding. Encoding conversions will happen automatically. The preferred encoding merely specifies the encoding for which the function implementation is optimized. It is possible to specify multiple functions with the same name and the same number of arguments, but different preferred encodings and different callbacks used to implement the function, and SQLite will chose the set of callbacks for which the input encodings most closely match the preferred encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="277f01faa8ef768e5f765984b4b0ad448802a74a" translate="yes" xml:space="preserve">
          <source>All database files to be modified by an UPDATE, INSERT or DELETE are now locked before any changes are made to any files. This makes it safe (I think) to access the same database simultaneously from multiple processes.</source>
          <target state="translated">UPDATE, INSERT 또는 DELETE에 의해 수정 될 모든 데이터베이스 파일은 이제 파일을 변경하기 전에 잠 깁니다. 이것은 여러 프로세스에서 동일한 데이터베이스에 동시에 액세스하는 것이 안전하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="bbad06084491f62976cce387f8ad55cb93120cd9" translate="yes" xml:space="preserve">
          <source>All existing versions of SQLite do a full table scan for ANALYZE. This can be slow for multi-gigabyte and larger databases. Future versions of SQLite might use random sampling rather than a full table scan to obtain estimates for the database shape, especially on larger tables. The results would approximate, but will be close enough for query planning purposes. As of 2017-03-20, this concept has been tested in experimental branches and appears to work well, but has not been folded into an official release.</source>
          <target state="translated">기존의 모든 SQLite 버전은 ANALYZE에 대한 전체 테이블 스캔을 수행합니다. 멀티 기가 바이트 이상의 데이터베이스에서는 느릴 수 있습니다. 이후 버전의 SQLite는 전체 테이블 스캔 대신 무작위 샘플링을 사용하여 특히 대형 테이블에서 데이터베이스 형태에 대한 추정치를 얻을 수 있습니다. 결과는 근사치이지만 쿼리 계획 목적으로 충분히 가깝습니다. 2017-03-20 현재이 개념은 실험 지점에서 테스트되었으며 잘 작동하는 것으로 보이지만 공식 릴리스로 접히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="57093dee5c757a1ceefead7158318b61ace62d82" translate="yes" xml:space="preserve">
          <source>All extended result codes are also error codes. Hence the terms &quot;extended result code&quot; and &quot;extended error code&quot; are interchangeable.</source>
          <target state="translated">모든 확장 결과 코드도 오류 코드입니다. 따라서 &quot;확장 결과 코드&quot;와 &quot;확장 오류 코드&quot;라는 용어는 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7deb3a8cda47ee51b4f2643f421866ddf4e49e" translate="yes" xml:space="preserve">
          <source>All five date and time functions take a time string as an argument. The time string is followed by zero or more modifiers. The strftime() function also takes a format string as its first argument.</source>
          <target state="translated">5 개의 날짜 및 시간 함수는 모두 시간 문자열을 인수로 사용합니다. 시간 문자열 뒤에는 0 개 이상의 수정자가옵니다. strftime () 함수는 형식 문자열을 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="27efbb224ffbae32d14448d4c9de1ee3c81cf982" translate="yes" xml:space="preserve">
          <source>All historical vulnerabilities reported against SQLite require at least one of these preconditions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53a08b0d87542a21311bc53db7ff7fe3705579a9" translate="yes" xml:space="preserve">
          <source>All incompatibilities are on obscure interfaces and hence should have zero impact on most applications.</source>
          <target state="translated">모든 비 호환성은 모호한 인터페이스에 있으므로 대부분의 응용 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7142a85dafa0005cc3ffdfca6d520d8fb0b49b9b" translate="yes" xml:space="preserve">
          <source>All internal computations assume the &lt;a href=&quot;http://en.wikipedia.org/wiki/Gregorian_calendar&quot;&gt;Gregorian calendar&lt;/a&gt; system. It is also assumed that every day is exactly 86400 seconds in duration.</source>
          <target state="translated">모든 내부 계산은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Gregorian_calendar&quot;&gt;그레고리력&lt;/a&gt; 시스템을 가정합니다 . 또한 매일 지속 시간이 정확히 86400 초라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="04348814491f3fa4a3cfd08b8932122a12a20fd2" translate="yes" xml:space="preserve">
          <source>All joins in SQLite are &lt;a href=&quot;optoverview#table_order&quot;&gt;implemented using nested scans&lt;/a&gt;. When a SELECT query that features a join is analyzed using EXPLAIN QUERY PLAN, one SCAN or SEARCH record is output for each nested loop. For example:</source>
          <target state="translated">SQLite의 모든 조인은 &lt;a href=&quot;optoverview#table_order&quot;&gt;중첩 스캔을 사용하여 구현됩니다&lt;/a&gt; . EXPLAIN QUERY PLAN을 사용하여 조인 기능이있는 SELECT 쿼리를 분석하면 중첩 된 루프마다 하나의 SCAN 또는 SEARCH 레코드가 출력됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f65525e42bafddb791aaf9fce17e894639d4b9bf" translate="yes" xml:space="preserve">
          <source>All joins in SQLite are based on the cartesian product of the left and right-hand datasets. The columns of the cartesian product dataset are, in order, all the columns of the left-hand dataset followed by all the columns of the right-hand dataset. There is a row in the cartesian product dataset formed by combining each unique combination of a row from the left-hand and right-hand datasets. In other words, if the left-hand dataset consists of</source>
          <target state="translated">SQLite의 모든 조인은 왼쪽 및 오른쪽 데이터 집합의 데카르트 곱을 기반으로합니다. 직교 곱 데이터 세트의 열은 순서대로 왼쪽 데이터 세트의 모든 열과 오른쪽 데이터 세트의 모든 열입니다. 직교 제품 데이터 집합에는 왼쪽 및 오른쪽 데이터 집합에서 행의 고유 한 각 조합을 결합하여 행이 있습니다. 즉, 왼쪽 데이터 집합이</target>
        </trans-unit>
        <trans-unit id="71cb3ce79e6a6e92d559b23cf8ac04406011b307" translate="yes" xml:space="preserve">
          <source>All machines use SSD except Win7 which has a hard-drive. The test database is 100K blobs with sizes uniformly distributed between 8K and 12K, for a total of about 1 gigabyte of content. The database page size is 4KiB. The -DSQLITE_DIRECT_OVERFLOW_READ compile-time option was used for all of these tests. Tests were run multiple times. The first run was used to warm up the cache and its timings were discarded.</source>
          <target state="translated">하드 드라이브가있는 Win7을 제외한 모든 시스템에서 SSD를 사용합니다. 테스트 데이터베이스는 총 약 1 기가 바이트의 콘텐츠를 위해 8K와 12K 사이에 균일하게 분포 된 크기를 가진 100K Blob입니다. 데이터베이스 페이지 크기는 4KiB입니다. -DSQLITE_DIRECT_OVERFLOW_READ 컴파일 타임 옵션이이 모든 테스트에 사용되었습니다. 테스트는 여러 번 실행되었습니다. 첫 번째 실행은 캐시를 예열하는 데 사용되었으며 타이밍이 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ffd5cbd04736788f9ab581e918b3089cbebbd40" translate="yes" xml:space="preserve">
          <source>All non-ASCII characters (those with codepoints greater than 127) are always considered token characters. If any non-ASCII characters are specified as part of the separators option, they are ignored.</source>
          <target state="translated">ASCII가 아닌 모든 문자 (코드 포인트가 127보다 큰 문자)는 항상 토큰 문자로 간주됩니다. ASCII가 아닌 문자가 구분 기호 옵션의 일부로 지정되면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b254312215697943ca788556e0d6b9c9450b8abd" translate="yes" xml:space="preserve">
          <source>All non-hidden columns (i.e. all columns matched by &quot;SELECT *&quot;) of the target table must be present in the input table. For virtual tables, hidden columns are optional - they are updated by RBU if present in the input table, or not otherwise. For example, to write to an fts4 table with a hidden languageid column such as:</source>
          <target state="translated">대상 테이블의 숨겨지지 않은 모든 열 (예 : &quot;SELECT *&quot;와 일치하는 모든 열)이 입력 테이블에 있어야합니다. 가상 테이블의 경우 숨겨진 열은 선택 사항입니다. 입력 테이블에있는 경우 RBU에 의해 업데이트되거나 그렇지 않으면 업데이트되지 않습니다. 예를 들어 숨겨진 languageid 열을 사용하여 fts4 테이블에 쓰려면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8f660b04140a9109b926733d1d15823285d0d8f" translate="yes" xml:space="preserve">
          <source>All of SQLite's &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; may be used as aggregate window functions. It is also possible to &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;create user-defined aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">모든 SQLite의 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계 함수&lt;/a&gt; 는 집계 창 함수로 사용될 수 있습니다. &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;사용자 정의 집계 창 함수&lt;/a&gt; 를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceaa2e316a20fa6709117f30bf44efbc7dbbc8c3" translate="yes" xml:space="preserve">
          <source>All of the WAL-index locks, except for WAL_READ_LOCK(0), are held exclusively while reconstructing the global shared WAL-index during &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">WAL_READ_LOCK (0)을 제외한 모든 WAL 인덱스 잠금은 독점적으로 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 중에 글로벌 공유 WAL 인덱스를 재구성하는 동안 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d3bdb37117516e584fc85e1c08d9757cba475e" translate="yes" xml:space="preserve">
          <source>All of the _printf() routines above are built around the following two functions:</source>
          <target state="translated">위의 모든 _printf () 루틴은 다음 두 함수를 중심으로 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="8b4e36a69bec3556f94aa311ae03a74097503a22" translate="yes" xml:space="preserve">
          <source>All of the above conditions must be false in order for problems to occur. And even if all of the conditiona above are false, most things will still operator correctly. Only the &lt;a href=&quot;#integcheck&quot;&gt;integrity-check&lt;/a&gt; command and the &lt;a href=&quot;#snippet&quot;&gt;auxiliary functions&lt;/a&gt; might given unexpected results.</source>
          <target state="translated">문제가 발생하려면 위의 모든 조건이 거짓이어야합니다. 위의 모든 조건이 거짓 인 경우에도 대부분의 항목은 여전히 ​​올바르게 작동합니다. &lt;a href=&quot;#integcheck&quot;&gt;무결성 검사&lt;/a&gt; 명령과 &lt;a href=&quot;#snippet&quot;&gt;보조 기능&lt;/a&gt; 만 예상치 못한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f6322b342eb9d2dc214ced37e7517990352762" translate="yes" xml:space="preserve">
          <source>All of the above definitions are included in the &quot;sqlite.h&quot; header file that comes in the source tree.</source>
          <target state="translated">위의 모든 정의는 소스 트리에있는 &quot;sqlite.h&quot;헤더 파일에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="693deb1c0ebd6029cb9d2f1f239c3bb4c352f744" translate="yes" xml:space="preserve">
          <source>All of the above is possible with Git, given the right extensions and tools and using the right commands. But it is not easy to do, and so it rarely gets done. Consequently, developers have less awareness of what is happening in the code.</source>
          <target state="translated">올바른 확장 및 도구를 제공하고 올바른 명령을 사용하면 Git에서 위의 모든 것이 가능합니다. 그러나 쉬운 일이 아니므로 거의 끝나지 않습니다. 결과적으로 개발자는 코드에서 발생하는 일에 대한 인식이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="ae8b16657892b5f01e3b5c073bd55f99b7c4acd2" translate="yes" xml:space="preserve">
          <source>All of the built-in SQL functions of SQLite are created using exactly these same interfaces. Refer to the SQLite source code, and in particular the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/date.c&quot;&gt;date.c&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/func.c&quot;&gt;func.c&lt;/a&gt; source files for examples.</source>
          <target state="translated">SQLite의 모든 내장 SQL 함수는 정확히 동일한 인터페이스를 사용하여 작성됩니다. SQLite 소스 코드, 특히 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/date.c&quot;&gt;date.c&lt;/a&gt; 및 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/func.c&quot;&gt;func.c&lt;/a&gt; 소스 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc1d5a95c4233b63280d0f7d11d256d9ad3780ef" translate="yes" xml:space="preserve">
          <source>All of the complications above (and others not mentioned here) arise from the need to preserve backwards compatibility for the hundreds of billions of SQLite database files in circulation. In a perfect world, there would be no such thing as a &quot;rowid&quot; and all tables would following the standard semantics implemented as &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables, only without the extra &quot;WITHOUT ROWID&quot; keywords. Unfortunately, life is messy. The designer of SQLite offers his sincere apology for the current mess.</source>
          <target state="translated">위의 모든 복잡한 문제 (및 여기에 언급되지 않은 다른 문제)는 수백억 개의 SQLite 데이터베이스 파일에 대한 하위 호환성을 유지해야 할 필요가 있습니다. 완벽한 세계에서 &quot;rowid&quot;와 같은 것은 없으며 모든 테이블은 &lt;a href=&quot;withoutrowid&quot;&gt;WITHROWROW&lt;/a&gt; 테이블 없이 구현 된 표준 의미 체계를 따르며 여분의 &quot;WITHOUT ROWID&quot;키워드없이 만 수행됩니다 . 불행히도 인생은 지저분합니다. SQLite의 디자이너는 현재 혼란에 대해 진심으로 사과드립니다.</target>
        </trans-unit>
        <trans-unit id="778689296bb157e74a14076a42a4ee37798df0eb" translate="yes" xml:space="preserve">
          <source>All of the existing safe languages are new. The developers of SQLite applaud the efforts of computer language researchers in trying to develop languages that are easier to program safely. We encourage these efforts to continue. Be we ourselves are more interested in old and boring languages when it comes to implementing SQLite.</source>
          <target state="translated">기존의 모든 안전한 언어는 새로운 언어입니다. SQLite 개발자는 컴퓨터 언어 연구원이 안전하게 프로그래밍하기 쉬운 언어를 개발하려는 노력에 박수를 보냅니다. 이러한 노력이 계속 될 것을 권장합니다. 우리는 SQLite를 구현할 때 오래되고 지루한 언어에 더 관심이 있습니까?</target>
        </trans-unit>
        <trans-unit id="7375d32a78c6b8f51d450c556f25932bdf217bf1" translate="yes" xml:space="preserve">
          <source>All of the experiments that follow operate the same with either &quot;test1.dir&quot; or &quot;test1.tree&quot;. Very little performance difference is measured in either case, regardless of operating system.</source>
          <target state="translated">다음의 모든 실험은 &quot;test1.dir&quot;또는 &quot;test1.tree&quot;와 동일하게 작동합니다. 운영 체제와 상관없이 두 경우 모두 성능 차이가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="643d0c9cb63fb8635827200eced1089f9e88183c" translate="yes" xml:space="preserve">
          <source>All of the result in the example are the same if the comparisons are commuted - if expressions of the form &quot;a&amp;lt;40&quot; are rewritten as &quot;40&amp;gt;a&quot;.</source>
          <target state="translated">&quot;a &amp;lt;40&quot;형식의 표현식을 &quot;40&amp;gt; a&quot;로 다시 쓰면 비교가 통근되는 경우 예제의 모든 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cc0e885150a13c9c4803941a5f8336469ed747f0" translate="yes" xml:space="preserve">
          <source>All of the tests above must run successfully, on multiple platforms and under multiple compile-time configurations, before each release of SQLite.</source>
          <target state="translated">위의 모든 테스트는 각 SQLite 릴리스 전에 여러 플랫폼 및 여러 컴파일 타임 구성에서 성공적으로 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7efae1cd770ea6fe5f2bf4478750e0f4cc942ea9" translate="yes" xml:space="preserve">
          <source>All of these commands work the same way if the filename argument is is a ZIP Archive instead of an SQLite database.</source>
          <target state="translated">filename 인수가 SQLite 데이터베이스 대신 ZIP 아카이브 인 경우 이러한 모든 명령이 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bf4dfc2a775cfce09d4f8b1860eec11883d0cac7" translate="yes" xml:space="preserve">
          <source>All of these factors combine to make SQLite a very trouble-free software library.</source>
          <target state="translated">이러한 모든 요소가 결합되어 SQLite를 문제없는 소프트웨어 라이브러리로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7683c6e8ad5efd15af0f1da2349a585dbe4001cb" translate="yes" xml:space="preserve">
          <source>All of these things can be provided in a single auxiliary C code file and then linked with the stock &quot;sqlite3.c&quot; code file to generate a working SQLite build for the target operating system. In addition to the alternative mutex and memory allocation subsystems and the new VFS, the auxiliary C code file should contain implementations for the following two routines:</source>
          <target state="translated">이 모든 것을 단일 보조 C 코드 파일로 제공 한 다음 스톡 &quot;sqlite3.c&quot;코드 파일과 연결하여 대상 운영 체제에 대해 작동하는 SQLite 빌드를 생성 할 수 있습니다. 대체 뮤텍스 및 메모리 할당 서브 시스템 및 새로운 VFS 외에도 보조 C 코드 파일에는 다음 두 루틴에 대한 구현이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="690aa8cfa4b8586b89a0a9eedc4d3f3b13222c70" translate="yes" xml:space="preserve">
          <source>All other bytes of the database file header are reserved for future expansion and must be set to zero.</source>
          <target state="translated">데이터베이스 파일 헤더의 다른 모든 바이트는 향후 확장을 위해 예약되어 있으며 0으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="74f932ce0ba425204c0c4c7e4d764d13c207d60d" translate="yes" xml:space="preserve">
          <source>All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</source>
          <target state="translated">데이터베이스를 사용하는 모든 프로세스는 동일한 호스트 컴퓨터에 있어야합니다. WAL은 네트워크 파일 시스템을 통해 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5249f0151d2bf61030095430f42bcf6f2a43a1f" translate="yes" xml:space="preserve">
          <source>All programming languages are processed in two steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b1adeb66f431eac1f1cb2925a5210daad86376" translate="yes" xml:space="preserve">
          <source>All programming languages uses those two basic steps. The main difference is in the executable format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78a418c8d3a0ce039842b297ad3c3dfb42d51a90" translate="yes" xml:space="preserve">
          <source>All queries on the table must be full-text queries. In other words, they must use the MATCH or = operator with the table-name column as the left-hand operand, or else use the table-valued function syntax. Any query that is not a full-text query results in an error.</source>
          <target state="translated">테이블의 모든 쿼리는 전체 텍스트 쿼리 여야합니다. 즉, 왼쪽 피연산자로 table-name 열과 함께 MATCH 또는 = 연산자를 사용하거나 테이블 반환 함수 구문을 사용해야합니다. 전체 텍스트 쿼리가 아닌 쿼리는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="38351d4546ab4ff59382ce23bdac471def2ad5d5" translate="yes" xml:space="preserve">
          <source>All reads from and writes to the main database file begin at a page boundary and all writes are an integer number of pages in size. Reads are also usually an integer number of pages in size, with the one exception that when the database is first opened, the first 100 bytes of the database file (the database file header) are read as a sub-page size unit.</source>
          <target state="translated">기본 데이터베이스 파일에 대한 모든 읽기 및 쓰기는 페이지 경계에서 시작하며 모든 쓰기는 크기가 정수인 페이지 수입니다. 읽기는 일반적으로 크기가 정수인 페이지 수이지만 데이터베이스를 처음 열 때 데이터베이스 파일의 첫 100 바이트 (데이터베이스 파일 헤더)를 하위 페이지 크기 단위로 읽는다는 점을 제외하고는 정수 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="d450d3a75d9f08311a07a29768bf79cccc1c19d2" translate="yes" xml:space="preserve">
          <source>All result codes are integers. Symbolic names for all result codes are created using &quot;#define&quot; macros in the sqlite3.h header file. There are separate sections in the sqlite3.h header file for the &lt;a href=&quot;c3ref/c_abort&quot;&gt;result code definitions&lt;/a&gt; and the &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;extended result code definitions&lt;/a&gt;.</source>
          <target state="translated">모든 결과 코드는 정수입니다. 모든 결과 코드의 기호 이름은 sqlite3.h 헤더 파일에서 &quot;#define&quot;매크로를 사용하여 작성됩니다. sqlite3.h 헤더 파일에는 &lt;a href=&quot;c3ref/c_abort&quot;&gt;결과 코드 정의&lt;/a&gt; 와 &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;확장 결과 코드 정의&lt;/a&gt; 에 대한 별도의 섹션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4028b4aa3d3e24115d72e2f624df2443ac4d4652" translate="yes" xml:space="preserve">
          <source>All spaces following the first two keywords are converted into a single space.</source>
          <target state="translated">처음 두 키워드 뒤에 오는 모든 공백은 단일 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e86f24edc76db2b20a12087f5cf419af602faa95" translate="yes" xml:space="preserve">
          <source>All string values at the SQL level in SQLite are dynamic strings. Requiring type strings to be static makes it difficult to create an application-defined SQL function that can synthesize a pointer of an arbitrary type. We do not want users to create such SQL functions, since such functions would compromise the security of the system. Thus, the requirement to use static strings helps to defend that the integrity of the pointer-passing interfaces against ill-designed SQL functions. The static string requirement is not a perfect defense, since a sophisticated programmer can code around it, and a novice program can simply take the memory leak. But by stating that the pointer type string must be static, we hope to encourage developers who might otherwise use a dynamic string for the pointer type to think more carefully about the problem and avoid introducing security issues.</source>
          <target state="translated">SQLite의 SQL 수준에있는 모든 문자열 값은 동적 문자열입니다. 유형 문자열을 정적으로 요구하면 임의 유형의 포인터를 합성 할 수있는 애플리케이션 정의 SQL 함수를 작성하기가 어렵습니다. 이러한 기능이 시스템의 보안을 손상시킬 수 있기 때문에 사용자가 이러한 SQL 기능을 작성하는 것을 원하지 않습니다. 따라서 정적 문자열을 사용해야하는 요구 사항은 잘못 디자인 된 SQL 함수에 대한 포인터 전달 인터페이스의 무결성을 방어하는 데 도움이됩니다. 정적 문자열 요구 사항은 정교한 프로그래머가 코드를 작성할 수 있고 초보자 프로그램이 단순히 메모리 누수를 일으킬 수 있기 때문에 완벽한 방어 수단은 아닙니다. 그러나 포인터 유형 문자열은 정적이어야한다고 말함으로써포인터 유형에 동적 문자열을 사용하는 개발자가 문제에 대해 더 신중하게 생각하고 보안 문제가 발생하지 않도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="9a460cfc406da09ab8128bfc4445d97c56d406f1" translate="yes" xml:space="preserve">
          <source>All subsequent command line words are command arguments, not options.</source>
          <target state="translated">모든 후속 명령 줄 단어는 옵션이 아니라 명령 인수입니다.</target>
        </trans-unit>
        <trans-unit id="1ed156deca85bc9a5dd9088fbd94f8a842f1f33c" translate="yes" xml:space="preserve">
          <source>All substitutions begin with a single &quot;%&quot; and end with a single type character. The other elements of the substitution are optional.</source>
          <target state="translated">모든 대체는 단일 &quot;%&quot;로 시작하고 단일 유형 문자로 끝납니다. 대체의 다른 요소는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6c42d2b7071c7a3c388400fdb8f6ee7f3109b7cf" translate="yes" xml:space="preserve">
          <source>All tables that participate in a union-vtab must be &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;.</source>
          <target state="translated">union-vtab에 참여하는 모든 테이블은 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a31bee81e9b968bc240c90d0ddec46a1b51435a7" translate="yes" xml:space="preserve">
          <source>All tables that participate in a union-vtab must have identical CREATE TABLE definitions, except that the names of the tables can be different.</source>
          <target state="translated">union-vtab에 참여하는 모든 테이블은 테이블 이름이 다를 수 있다는 점을 제외하고 동일한 CREATE TABLE 정의를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="567093004d4bf6708c2d16ff16df1498f9ca4cec" translate="yes" xml:space="preserve">
          <source>All terms of the WHERE clause are analyzed to see if they can be satisfied using indices. To be usable by an index a term must be of one of the following forms:</source>
          <target state="translated">WHERE 절의 모든 용어는 인덱스를 사용하여 만족할 수 있는지 분석합니다. 인덱스에서 사용하려면 용어는 다음 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cbf993933e40301457f333ff6f1f8a23481fc0a6" translate="yes" xml:space="preserve">
          <source>All tests are conducted on an otherwise quiescent machine. A simple Tcl script was used to generate and run all the tests. A copy of this Tcl script can be found in the SQLite source tree in the file &lt;b&gt;tools/speedtest.tcl&lt;/b&gt;.</source>
          <target state="translated">모든 테스트는 그렇지 않은 대기 시스템에서 수행됩니다. 간단한 Tcl 스크립트를 사용하여 모든 테스트를 생성하고 실행했습니다. 이 Tcl 스크립트의 사본은 &lt;b&gt;tools / speedtest.tcl&lt;/b&gt; 파일의 SQLite 소스 트리에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b130e54f0f69ef3abad26bc072b0470f6263286a" translate="yes" xml:space="preserve">
          <source>All tests must give the same answer in all three builds. See the &lt;a href=&quot;testing&quot;&gt;&quot;How SQLite Is Tested&quot;&lt;/a&gt; document for more detail.</source>
          <target state="translated">모든 테스트는 세 가지 빌드 모두에서 동일한 답변을 제공해야합니다. 자세한 내용은 &lt;a href=&quot;testing&quot;&gt;&quot;SQLite 테스트 방법&quot;&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f132159b2587371da6eaa867ee955aed59cbbd60" translate="yes" xml:space="preserve">
          <source>All text strings are insert using one of the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text()&lt;/a&gt; family of functions.</source>
          <target state="translated">모든 텍스트 문자열은 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text ()&lt;/a&gt; 함수 계열 중 하나를 사용하여 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="67d8d36777ef2e501af7ab9b2e6ef786e48ae2b6" translate="yes" xml:space="preserve">
          <source>All that said, it is possible that SQLite might one day be recoded in Rust. Recoding SQLite in Go is unlikely since Go hates assert(). But Rust is a possibility. Some preconditions that must occur before SQLite is recoded in Rust include:</source>
          <target state="translated">그러나 SQLite가 언젠가 Rust에서 코딩 될 수 있습니다. Go가 assert ()를 싫어하기 때문에 Go에서 SQLite를 코딩하는 것은 불가능합니다. 그러나 녹은 가능성이 있습니다. Rust에서 SQLite를 레코딩하기 전에 발생해야하는 일부 전제 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="707caca3d9bbd176531f568662a7102a40b5f6fd" translate="yes" xml:space="preserve">
          <source>All the example queries above return the ten most relevant query results. By modifying the values used with the OFFSET and LIMIT clauses, a query to return (say) the next ten most relevant results is easy to construct. This may be used to obtain the data required for a search applications second and subsequent pages of results.</source>
          <target state="translated">위의 모든 예제 쿼리는 10 개의 가장 관련성이 높은 쿼리 결과를 반환합니다. OFFSET 및 LIMIT 절에 사용 된 값을 수정하면 가장 관련성이 높은 다음 10 개의 결과를 반환하는 쿼리가 쉽게 구성됩니다. 검색 응용 프로그램의 두 번째 및 후속 결과 페이지에 필요한 데이터를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="470143461be606a45aab0f210d1498edb2c84368" translate="yes" xml:space="preserve">
          <source>All things considered, applications should normally be able to hold their maximum memory allocation size below 2K or 4K. This gives a value for log&lt;sub&gt;2&lt;/sub&gt;(&lt;b&gt;n&lt;/b&gt;) of 2 or 3. This will limit &lt;b&gt;N&lt;/b&gt; to between 2 and 2.5 times &lt;b&gt;M&lt;/b&gt;.</source>
          <target state="translated">응용 프로그램은 일반적으로 최대 메모리 할당 크기를 2K 또는 4K 미만으로 유지할 수 있어야합니다. 이것은 로그 &lt;sub&gt;2&lt;/sub&gt; ( &lt;b&gt;n&lt;/b&gt; )에 2 또는 3 의 값을 제공합니다. 이것은 &lt;b&gt;N&lt;/b&gt; 을 2에서 2.5 배 &lt;b&gt;M으로 제한&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="635a64a808a6eed58043c45da38b8c4ec5742ac1" translate="yes" xml:space="preserve">
          <source>All three auxiliary functions extract a set of &quot;matchable phrases&quot; from the FTS query expression to work with. The set of matchable phrases for a given query consists of all phrases (including unquoted tokens and token prefixes) in the expression except those that are prefixed with a unary &quot;-&quot; operator (standard syntax) or are part of a sub-expression that is used as the right-hand operand of a NOT operator.</source>
          <target state="translated">세 가지 보조 함수는 모두 FTS 쿼리 표현식에서 &quot;일치하는 문구&quot;세트를 추출하여 작업합니다. 주어진 검색어에 대해 일치하는 문구 세트는 단항 &quot;-&quot;연산자 (표준 구문)가 앞에 붙거나 하위 표현식의 일부인 문구를 제외하고 표현식의 모든 문구 (인용되지 않은 토큰 및 토큰 접두사 포함)로 구성됩니다. NOT 연산자의 오른쪽 피연산자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e856a97cf9fae10a8a385ba08b2985c87e16aaf1" translate="yes" xml:space="preserve">
          <source>All three database engines run faster when they have indices to work with. But SQLite is still the fastest.</source>
          <target state="translated">3 개의 데이터베이스 엔진 모두 작업 할 인덱스가있을 때 더 빠르게 실행됩니다. 그러나 SQLite는 여전히 가장 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="6baeeca7bdbd41abd15a40b8b926de6f745b8bb0" translate="yes" xml:space="preserve">
          <source>All three of the above source files are contained in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt; available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt;.</source>
          <target state="translated">위의 3 가지 소스 파일은 모두 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 제공되는 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;합병 타르볼에&lt;/a&gt; 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf60184a7e675d81f6bedcfe7ca27f21750f46d0" translate="yes" xml:space="preserve">
          <source>All type information or constraint specifications must be removed from column definitions. FTS3/4 ignores everything following the column name in a column definition, FTS5 attempts to parse it (and will report an error if it fails to).</source>
          <target state="translated">모든 유형 정보 또는 제한 조건 스펙은 열 정의에서 제거해야합니다. FTS3 / 4는 열 정의에서 열 이름 뒤에 오는 모든 것을 무시하고 FTS5는 구문 분석을 시도하고 실패하면 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a1de722aadb01564eff9284d3ae40b05c75cdc11" translate="yes" xml:space="preserve">
          <source>All uppercase characters within the ASCII range (Unicode codepoints less than 128), are transformed to their lowercase equivalents as part of the tokenization process. Thus, full-text queries are case-insensitive when using the simple tokenizer.</source>
          <target state="translated">ASCII 범위 (유니 코드 코드 포인트 128 미만) 내의 모든 대문자는 토큰 화 프로세스의 일부로 소문자로 변환됩니다. 따라서 간단한 토크 나이저를 사용할 때 전체 텍스트 쿼리는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="230a993ba607de10c8e04d67e19e0d8357f45f60" translate="yes" xml:space="preserve">
          <source>All values in SQL statements, whether they are literals embedded in SQL statement text or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; bound to &lt;a href=&quot;c3ref/stmt&quot;&gt;precompiled SQL statements&lt;/a&gt; have an implicit storage class. Under circumstances described below, the database engine may convert values between numeric storage classes (INTEGER and REAL) and TEXT during query execution.</source>
          <target state="translated">SQL 문 텍스트에 임베드 된 리터럴이든 &lt;a href=&quot;c3ref/stmt&quot;&gt;사전 컴파일 된 SQL 문에&lt;/a&gt; 바인드 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이든 SQL 문의 모든 값 에는 내재 된 스토리지 클래스가 있습니다. 아래 설명 된 상황에서 데이터베이스 엔진은 쿼리 실행 중 숫자 스토리지 클래스 (INTEGER 및 REAL)와 TEXT 사이의 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2db63f1dd84225eeca5b66732ebeb7dfeca7e9c" translate="yes" xml:space="preserve">
          <source>All versions of SQLite since 3.3.0 (2006-01-10) can read and write any schema format between 1 and 4. But older versions of SQLite might not be able to read formats greater than 1. So that older versions of SQLite will be able to read and write database files created by newer versions of SQLite, the default schema format was set to 1 for SQLite versions through 3.7.9 (2011-11-01). Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the default schema format is 4.</source>
          <target state="translated">3.3.0 (2006-01-10) 이후의 모든 SQLite 버전은 1과 4 사이의 스키마 형식을 읽고 쓸 수 있습니다. 그러나 이전 버전의 SQLite는 1보다 큰 형식을 읽을 수 없습니다. 따라서 이전 버전의 SQLite는 최신 버전의 SQLite에서 만든 데이터베이스 파일을 읽고 쓸 수 있도록 기본 스키마 형식은 3.7.9 (2011-11-01)까지 SQLite 버전의 경우 1로 설정되었습니다. &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16) 부터 기본 스키마 형식은 4입니다.</target>
        </trans-unit>
        <trans-unit id="a315e152418f974223f0caef4a38a40619deaba9" translate="yes" xml:space="preserve">
          <source>All versions of SQLite up to and including &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01) assume that the filesystem does &lt;u&gt;not&lt;/u&gt; provide powersafe overwrite. SQLite has traditionally assumed that when any one byte of a file changes, all other bytes within the same sector of that byte have the potential of being corrupted on a power loss. When writing, SQLite has made sure to journal all bytes in the same sector of any modifications and it pads journal files out to the next sector boundary so that subsequent appends to that journal cannot damage prior records. SQLite understands the sector size to be the value returned by the xSectorSize method in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. The SQLite team has often referred to the value returned by xSectorSize as the &quot;blast radius&quot; of a write, since it expresses the range of bytes that might be damaged if a power loss occurs during the write. The default &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; for unix and windows have always returned 512 as the sector size (or blast radius) for all versions of SQLite up to and including version 3.7.9.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;버전 3.7.9&lt;/a&gt; (2011-11-01) 이하의 모든 SQLite 버전은 파일 시스템이 전원 안전 덮어 쓰기를 제공 하지 &lt;u&gt;않는다고&lt;/u&gt; 가정합니다 . SQLite는 전통적으로 파일의 1 바이트가 변경 될 때 해당 바이트의 동일한 섹터 내에있는 다른 모든 바이트가 전원 손실로 인해 손상 될 가능성이 있다고 가정했습니다. 작성할 때 SQLite는 수정 된 동일한 섹터의 모든 바이트를 저널링해야하며 저널 파일을 다음 섹터 경계에 채워서 해당 저널에 추가 할 때 이전 레코드를 손상시킬 수 없습니다. SQLite는 섹터 크기를 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xSectorSize 메소드가 리턴 한 값으로 이해합니다.. SQLite 팀은 종종 xSectorSize에서 반환 된 값을 쓰기의 &quot;폭발 반경&quot;이라고했습니다. 쓰기 중에 전원 손실이 발생할 경우 손상 될 수있는 바이트 범위를 나타냅니다. 유닉스와 윈도우 의 기본 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 3.7.9까지의 모든 버전의 SQLite에 대한 섹터 크기 (또는 블라스트 반경)로 항상 512를 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="3ff80c8a340db91dd8a4375abd89d32aa974509b" translate="yes" xml:space="preserve">
          <source>All versions of SQLite up to and including version 3.5.9 have mishandled NULL values on the right-hand side of IN and NOT IN operators. Specifically, SQLite has previously ignored NULLs on the right-hand side of IN and NOT IN.</source>
          <target state="translated">버전 3.5.9 이하의 모든 SQLite 버전은 IN 및 NOT IN 연산자의 오른쪽에서 NULL 값을 잘못 처리했습니다. 특히 SQLite는 이전에 IN과 NOT IN의 오른쪽에서 NULL을 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="f103276ac70c09043aecb18573124bfe2497c24b" translate="yes" xml:space="preserve">
          <source>Allocate a new b-tree in the main database file if P1==0 or in the TEMP database file if P1==1 or in an attached database if P1&amp;gt;1. The P3 argument must be 1 (BTREE_INTKEY) for a rowid table it must be 2 (BTREE_BLOBKEY) for an index or WITHOUT ROWID table. The root page number of the new b-tree is stored in register P2.</source>
          <target state="translated">P1 == 0 인 경우 기본 데이터베이스 파일 또는 P1 == 1 인 경우 TEMP 데이터베이스 파일 또는 P1&amp;gt; 1 인 경우 연결된 데이터베이스에 새 b- 트리를 할당하십시오. P3 인수는 rowid 테이블의 경우 1 (BTREE_INTKEY)이어야하고 인덱스 또는 WITHOUT ROWID 테이블의 경우 2 (BTREE_BLOBKEY) 여야합니다. 새로운 b- 트리의 루트 페이지 번호는 레지스터 P2에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="98c7e4f88a0a3613dabebb78baaf9f796e649934" translate="yes" xml:space="preserve">
          <source>Allocate a new changeset rebaser object. If successful, set (*ppNew) to point to the new object and return SQLITE_OK. Otherwise, if an error occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) to NULL.</source>
          <target state="translated">새로운 체인지 셋 rebaser 객체를 할당하십시오. 성공하면 (* ppNew)를 설정하여 새 오브젝트를 가리키고 SQLITE_OK를 리턴하십시오. 그렇지 않으면, 오류가 발생하면 SQLite 오류 코드 (예 : SQLITE_NOMEM)를 리턴하고 (* ppNew)를 NULL로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="890d83377e0f9622417e6019e12893679bb2c728" translate="yes" xml:space="preserve">
          <source>Allocate a new page if it easy and convenient to do so. Otherwise return NULL.</source>
          <target state="translated">새 페이지를 쉽고 편리하게 할당하십시오. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b563fc1e21cbbe40e2fcd69876f3f214fc04c0f" translate="yes" xml:space="preserve">
          <source>Allow &quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot; as a shorthand for &quot;&amp;lt;expr&amp;gt; IN (SELECT * FROM &amp;lt;table&amp;gt;&quot;.</source>
          <target state="translated">&quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot;의 줄임말로 &quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot;을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="06d0f1303155aabcd4262ede8a9d90bfb68ed8f4" translate="yes" xml:space="preserve">
          <source>Allow &quot;?&quot; parameters in the LIMIT clause.</source>
          <target state="translated">허용하다 &quot;?&quot; LIMIT 절의 매개 변수.</target>
        </trans-unit>
        <trans-unit id="cd8e51f439edbc4cbc973e08ee46366e6e096d45" translate="yes" xml:space="preserve">
          <source>Allow &quot;VIEW&quot; to be a column name</source>
          <target state="translated">&quot;VIEW&quot;가 열 이름이되도록 허용</target>
        </trans-unit>
        <trans-unit id="377c13da16b3a423a23503b52be9d946eb79c0be" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;deterministic&quot;&gt;deterministic SQL functions&lt;/a&gt; in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절에 &lt;a href=&quot;deterministic&quot;&gt;결정적 SQL 함수&lt;/a&gt; 를 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9a09844684ca2e04e8580f1dc89f5d23c5aed0e" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands to work inside of a transaction.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; 명령이 트랜잭션 내에서 작동하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9aa4176f2699ab1a840e5917668b064b3516ba4" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; to appear on the right-hand side of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="translated">허용 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수&lt;/a&gt; 의 우측에 표시 &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48d9b4c29aa05f94ecb72a287ad5d41af03effad" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual tables&lt;/a&gt; to be writable if the PRIMARY KEY contains exactly one column.</source>
          <target state="translated">PRIMARY KEY에 정확히 하나의 열이 있으면 &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID 가상 테이블&lt;/a&gt; 을 쓸 수 있도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="269070c3e8d911c8236d5f897186b3e1ab6e4e31" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;wal&quot;&gt;WAL-mode&lt;/a&gt; databases to be opened read-only as long as there is an existing read/write connection.</source>
          <target state="translated">허용 &lt;a href=&quot;wal&quot;&gt;WAL-모드&lt;/a&gt; 데이터베이스는 읽기 전용으로 한 기존의 읽기 / 쓰기 연결이로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef741e84d49fdcc8210ba15eda342eea0faf46a9" translate="yes" xml:space="preserve">
          <source>Allow GLOB and LIKE operators to work as functions.</source>
          <target state="translated">GLOB 및 LIKE 연산자가 함수로 작동하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d8d8f395445a63807721ea16945b2777fb51092" translate="yes" xml:space="preserve">
          <source>Allow NULL arguments in sqlite_compile() and sqlite_step().</source>
          <target state="translated">sqlite_compile () 및 sqlite_step ()에서 NULL 인수를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="186268005d1a02f259dbb9958233b56b69668278" translate="yes" xml:space="preserve">
          <source>Allow WHERE clause terms on the left table of a LEFT OUTER JOIN to contain aggregate subqueries.</source>
          <target state="translated">LEFT OUTER JOIN의 왼쪽 테이블에있는 WHERE 절 용어에 집계 서브 쿼리가 포함되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="38079f81b0c869a35e192a7c7ee51456917575b5" translate="yes" xml:space="preserve">
          <source>Allow a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; to be used anywhere a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is valid.</source>
          <target state="translated">허용 &lt;a href=&quot;lang_select#values&quot;&gt;VALUES 절은&lt;/a&gt; 어디에서나 사용되는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b29c570354c3dc76b997275a38b4804dd30d724a" translate="yes" xml:space="preserve">
          <source>Allow arbitrary expressions, including function calls and subqueries, in the filename argument to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 의 파일 이름 인수에 함수 호출 및 서브 쿼리를 포함한 임의의 표현식을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="087d2618f268406853ee3cd79209ec421c2d288d" translate="yes" xml:space="preserve">
          <source>Allow collating sequence names to be quoted.</source>
          <target state="translated">조합 순서 이름을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026b30b967a2b6589a1cfbc782a3c2b403048beb" translate="yes" xml:space="preserve">
          <source>Allow constraint names on the DEFAULT clause in a table definition</source>
          <target state="translated">테이블 정의의 DEFAULT 절에 제한 조건 이름 허용</target>
        </trans-unit>
        <trans-unit id="6215a826c022df62b341a6590cb9e2024e5f7525" translate="yes" xml:space="preserve">
          <source>Allow floating point literals to begin or end with a decimal point.</source>
          <target state="translated">부동 소수점 리터럴이 소수점으로 시작하거나 끝나도록합니다.</target>
        </trans-unit>
        <trans-unit id="25c2ba2fe3b0e6c9a56edf6ddf62886b17854fb2" translate="yes" xml:space="preserve">
          <source>Allow identifiers to be quoted in square brackets, for compatibility with MS-Access.</source>
          <target state="translated">MS-Access와의 호환성을 위해 식별자를 대괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a61cbdfe59167766b82b62a24a23f799327821d" translate="yes" xml:space="preserve">
          <source>Allow indices to be used for sorting even if prior terms of the index are constrained by IN operators in the WHERE clause.</source>
          <target state="translated">인덱스의 사전 용어가 WHERE 절에서 IN 연산자에 의해 제한되는 경우에도 색인을 사용하여 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ef34a12d16effc2a1e0c0a26a046cc6b9ba4f95" translate="yes" xml:space="preserve">
          <source>Allow more system calls to be overridden in the unix VFS - to provide better support for chromium sandboxes.</source>
          <target state="translated">크롬 샌드 박스에 대한보다 나은 지원을 제공하기 위해 유닉스 VFS에서 더 많은 시스템 호출을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d47c202ac74ad6be5e5952c7d032a0006fd10e" translate="yes" xml:space="preserve">
          <source>Allow multiple simultaneous readers under Windows by simulating the reader/writers locks that are missing from Win95/98/ME.</source>
          <target state="translated">Win95 / 98 / ME에없는 판독기 / 기록기 잠금을 시뮬레이션하여 Windows에서 여러 개의 동시 판독기를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="aec002f75566ff8ab7f2b3337c8366c012290ae9" translate="yes" xml:space="preserve">
          <source>Allow new user-defined functions to be created when there are already one or more precompiled SQL statements.</source>
          <target state="translated">하나 이상의 사전 컴파일 된 SQL 문이 이미있을 때 새 사용자 정의 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1acd99d1b7ffc9d5267e039032ab7559c12120f" translate="yes" xml:space="preserve">
          <source>Allow read transactions to be freely opened and closed by SQL statements run from within the implementation of &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt; if the function is called by a SELECT statement that does not access any database table.</source>
          <target state="translated">데이터베이스 테이블에 액세스하지 않는 SELECT 문에 의해 함수가 호출되는 경우 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; 구현 내에서 실행되는 SQL 문에 의해 읽기 트랜잭션을 자유롭게 열고 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="331932f674e6d859e399fb8d0775ada55921d45e" translate="yes" xml:space="preserve">
          <source>Allow read transactions to be freely opened and closed by SQL statements run from within the implementation of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; if the function is called by a SELECT statement that does not access any database table.</source>
          <target state="translated">데이터베이스 테이블에 액세스하지 않는 SELECT 문에서 함수를 호출 한 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 구현 내에서 실행되는 SQL 문으로 읽기 트랜잭션을 자유롭게 열고 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16104cba6ed4e5c5fd3de40cb546c3fb1bc3c957" translate="yes" xml:space="preserve">
          <source>Allow sqlite_exec() to be called from within user-defined SQL functions.</source>
          <target state="translated">sqlite_exec ()를 사용자 정의 SQL 함수 내에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9296631111fc0993d0527ddffb1b74601f16736" translate="yes" xml:space="preserve">
          <source>Allow the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to change the page size of a database file.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 데이터베이스 파일의 페이지 크기를 변경하도록 허용 하십시오.</target>
        </trans-unit>
        <trans-unit id="aac64bf7a32177d90d0452da0d0056ea1b87de06" translate="yes" xml:space="preserve">
          <source>Allow the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations to return &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; to indicate that the proposed query plan is unusable and should not be given further consideration.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()&lt;/a&gt; 메소드가 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; 를 리턴 하여 제안 된 쿼리 계획을 사용할 수 없으며 더 이상 고려하지 않아야 함을 표시하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6424ee4a8785aaef1a25b07cf3555293853c9183" translate="yes" xml:space="preserve">
          <source>Allow the DEFAULT value of a column to call functions that have constant operands</source>
          <target state="translated">열의 DEFAULT 값이 상수 피연산자가있는 함수를 호출하도록 허용</target>
        </trans-unit>
        <trans-unit id="6b663434ab971b5c50c2b931e627bcf32963ce5d" translate="yes" xml:space="preserve">
          <source>Allow the error message from &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to be longer than 20000 bytes.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 의 오류 메시지 가 20000 바이트를 초과하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acb3e6f837b7598e3baf15397c889298e8fd1c4d" translate="yes" xml:space="preserve">
          <source>Allow the name of a database to be prefixed by the driver type. For now, the only driver type is &quot;gdbm:&quot;.</source>
          <target state="translated">데이터베이스 이름에 드라이버 유형이 접두어로 허용되도록하십시오. 현재 유일한 드라이버 유형은 &quot;gdbm :&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="dfc00039aaf898d163afc8dbd0e94542ba8ecc28" translate="yes" xml:space="preserve">
          <source>Allow the value -9223372036854775808 as an integer literal in SQL statements.</source>
          <target state="translated">SQL 문에서 -9223372036854775808 값을 정수 리터럴로 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="dee90ceb52dbab56bc4990303982723135b728d9" translate="yes" xml:space="preserve">
          <source>Allow transactions to span Linux Threads</source>
          <target state="translated">트랜잭션이 Linux 스레드를 확장하도록 허용</target>
        </trans-unit>
        <trans-unit id="5ffa48f8c38520d1cf8de848950d598b10eb8e45" translate="yes" xml:space="preserve">
          <source>Allow up to 64 tables in a join - the old limit was 32.</source>
          <target state="translated">조인에서 최대 64 개의 테이블을 허용합니다. 이전 제한은 32입니다.</target>
        </trans-unit>
        <trans-unit id="d2fef18fe97d9b603d8ce243c65accbdab4d874a" translate="yes" xml:space="preserve">
          <source>Allow virtual table constructors to be invoked recursively.</source>
          <target state="translated">가상 테이블 생성자가 재귀 적으로 호출되도록합니다.</target>
        </trans-unit>
        <trans-unit id="90e23d564e7f297c7a2b5ceff9d8f6ef229ac9a5" translate="yes" xml:space="preserve">
          <source>Allowed P5 bits:</source>
          <target state="translated">허용 된 P5 비트 :</target>
        </trans-unit>
        <trans-unit id="1287cd665e8d2234952aeb1f2ae2c3398192c7b9" translate="yes" xml:space="preserve">
          <source>Allowing extension components to pass private information to one another securely and without introducing pointer leaks requires new interfaces:</source>
          <target state="translated">확장 구성 요소가 개인 정보를 안전하게 전달하고 포인터 누출을 유발하지 않으면 새로운 인터페이스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="58216c0e44a2a5d1fb12649c30e0ddf5229fffd5" translate="yes" xml:space="preserve">
          <source>Almost all CVEs written against SQLite require the ability to inject and run arbitrary SQL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000b2c34686fc4cba8d7591893d96173b465ff5d" translate="yes" xml:space="preserve">
          <source>Almost all bugs reported by CVEs are just bugs and not true vulnerabilities. Claiming that they are vulnerabilities is stretching the meaning of the word &quot;vulnerability&quot; and the SQLite developers do not wish to participate in that deception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d20875a194118243c2bc48398fc9e50e653168b" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing Of All Documents</source>
          <target state="translated">모든 문서의 알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="fc6ed234869c2180894bb5c831639c8bf2a71c3a" translate="yes" xml:space="preserve">
          <source>Also available is the similar but more mature &lt;a href=&quot;fts3&quot;&gt;FTS3/4&lt;/a&gt; module. FTS5 is a new version of FTS4 that includes various fixes and solutions for problems that could not be fixed in FTS4 without sacrificing backwards compatibility. Some of these problems are &lt;a href=&quot;fts5#_summary_of_technical_differences_&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">유사하지만보다 성숙한 &lt;a href=&quot;fts3&quot;&gt;FTS3 / 4&lt;/a&gt; 모듈 도 사용할 수 있습니다 . FTS5는 이전 버전과의 호환성을 유지하면서 FTS4에서 수정할 수없는 문제에 대한 다양한 수정 및 솔루션을 포함하는 FTS4의 새로운 버전입니다. 이러한 문제 중 일부는 &lt;a href=&quot;fts5#_summary_of_technical_differences_&quot;&gt;아래&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdc4b8824c8f732ab94ebdcfb7669cd9ac01bcf0" translate="yes" xml:space="preserve">
          <source>Also available: &lt;a href=&quot;../rescode&quot;&gt;list of error codes&lt;/a&gt;</source>
          <target state="translated">사용 가능한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f04534899f708d46ebaa30f16a02cbe243e196ae" translate="yes" xml:space="preserve">
          <source>Also available: &lt;a href=&quot;rescode&quot;&gt;list of error codes&lt;/a&gt;</source>
          <target state="translated">사용 가능한 &lt;a href=&quot;rescode&quot;&gt;오류 코드 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861a9e2d67fe5f61973dab8932f2db2e113ce546" translate="yes" xml:space="preserve">
          <source>Also, whether or not P4 is set, check that this is not being called from within a callback to a virtual table xSync() method. If it is, the error code will be set to SQLITE_LOCKED.</source>
          <target state="translated">또한 P4의 설정 여부에 따라 콜백 내에서 가상 테이블 xSync () 메소드로 호출되지 않는지 확인하십시오. 그렇다면 오류 코드가 SQLITE_LOCKED로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="087d1b6052e351518f2d15a60b3d4e94a4ca524e" translate="yes" xml:space="preserve">
          <source>Alternatively, FTS5 may be built as a loadable extension.</source>
          <target state="translated">또는 FTS5를로드 가능한 확장으로 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c1c99f2707eb260cd81c76dc0cd3c1b0734ce4" translate="yes" xml:space="preserve">
          <source>Alternatively, the first argument following to &quot;.ar&quot; may be the concatenation of the short form of all required options (without the &quot;-&quot; characters). In this case arguments for options requiring them are read from the command line next, and any remaining words are considered command arguments. For example:</source>
          <target state="translated">또는 &quot;.ar&quot;다음에 오는 첫 번째 인수는 모든 필수 옵션의 짧은 형식 ( &quot;-&quot;문자 제외)을 연결 한 것일 수 있습니다. 이 경우 옵션이 필요한 옵션에 대한 인수는 다음 명령 행에서 읽히고 나머지 단어는 명령 인수로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5abd2d3f1bfc69f474a1675b744197ff1ab504ae" translate="yes" xml:space="preserve">
          <source>Alternatively, the unionvtab.c file may be compiled into the application. In this case, the following function should be invoked to register the extension with each new database connection:</source>
          <target state="translated">또는 unionvtab.c 파일을 응용 프로그램으로 컴파일 할 수 있습니다. 이 경우, 각각의 새 데이터베이스 연결에 확장을 등록하려면 다음 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee75d1aa4e172f68779a1484c212e21f3e9f3faf" translate="yes" xml:space="preserve">
          <source>Alternatively, the zipfile.c file may be compiled into the application. In this case, the following function should be invoked to register the extension with each new database connection:</source>
          <target state="translated">또는 zipfile.c 파일을 응용 프로그램으로 컴파일 할 수 있습니다. 이 경우, 각각의 새 데이터베이스 연결에 확장을 등록하려면 다음 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="5944ffdf9815956de892051d5dd5e1fe60e1a9e4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a new database using the default temporary storage, then save that database into a disk file using the &quot;.save&quot; command:</source>
          <target state="translated">또는 기본 임시 저장소를 사용하여 새 데이터베이스를 만든 다음 &quot;.save&quot;명령을 사용하여 해당 데이터베이스를 디스크 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b26855d54d9f7346a9489732c53c62b9c7f06b57" translate="yes" xml:space="preserve">
          <source>Alternatives (2) and (3) only work for the TEMP database associated with each database connection, but alternative (1) works anywhere. For historical reasons, callbacks from the &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt; interface always refer to the schema table using names (1) or (3).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b777ccc0b549914aaf4c953fa2687953baa7c2b" translate="yes" xml:space="preserve">
          <source>Although FTS3 and FTS4 are included with the SQLite core source code, they are not enabled by default. To build SQLite with FTS functionality enabled, define the preprocessor macro &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; when compiling. New applications should also define the &lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; macro to enable the &lt;a href=&quot;fts3#_set_operations_using_the_enhanced_query_syntax&quot;&gt;enhanced query syntax&lt;/a&gt; (see below). Usually, this is done by adding the following two switches to the compiler command line:</source>
          <target state="translated">FTS3 및 FTS4는 SQLite 코어 소스 코드에 포함되어 있지만 기본적으로 활성화되어 있지 않습니다. FTS 기능이 사용 가능한 SQLite를 빌드하려면 컴파일 할 때 전 처리기 매크로 &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3을&lt;/a&gt; 정의하십시오 . 새로운 응용 프로그램은 또한 &lt;a href=&quot;fts3#_set_operations_using_the_enhanced_query_syntax&quot;&gt;향상된 쿼리 구문&lt;/a&gt; 을 활성화하기 위해 &lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; 매크로를 정의해야 합니다 (아래 참조). 일반적으로 컴파일러 명령 줄에 다음 두 스위치를 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="695189fbab565d10c4e5c26d8849228747eb7d89" translate="yes" xml:space="preserve">
          <source>Although it is less common, a call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; may also return SQLITE_LOCKED if it cannot obtain a read-lock on the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema table&lt;/a&gt; of each attached database. These APIs need to read the schema data contained in the sqlite_schema table in order to compile SQL statements to &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; objects.</source>
          <target state="translated">덜 일반적이지만 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 호출 은 연결된 각 데이터베이스 의 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema 테이블&lt;/a&gt; 에 대한 읽기 잠금을 얻을 수없는 경우 SQLITE_LOCKED를 반환 할 수도 있습니다. 이러한 API는 SQL 문을 &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 개체 로 컴파일하기 위해 sqlite_schema 테이블에 포함 된 스키마 데이터를 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="024fe1545f30cb8dee088c5ad188ae320d8b4ae9" translate="yes" xml:space="preserve">
          <source>Although it is less common, a call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; may also return SQLITE_LOCKED if it cannot obtain a read-lock on the sqlite_master table of each attached database. These APIs need to read the schema data contained in the sqlite_master table in order to compile SQL statements to &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; objects.</source>
          <target state="translated">일반적이지 않지만 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 호출 은 연결된 각 데이터베이스의 sqlite_master 테이블에서 읽기 잠금을 얻을 수없는 경우 SQLITE_LOCKED를 리턴 할 수도 있습니다. 이러한 API는 SQL 문을 &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 오브젝트 로 컴파일하려면 sqlite_master 테이블에 포함 된 스키마 데이터를 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f535c18aa59fdbaaceb49a43b9f2ac5c4e156d04" translate="yes" xml:space="preserve">
          <source>Although it would be easy to design a system that uses the</source>
          <target state="translated">사용하는 시스템을 설계하는 것은 쉽지만</target>
        </trans-unit>
        <trans-unit id="38350322f36d3cb7eee20f2334360ada16ffdbe4" translate="yes" xml:space="preserve">
          <source>Always NULL</source>
          <target state="translated">항상 NULL</target>
        </trans-unit>
        <trans-unit id="6556666b4b860beb62beea54857b52422d71a07f" translate="yes" xml:space="preserve">
          <source>Always convert IEEE floating point NaN values into NULL during processing. (Ticket #3060)</source>
          <target state="translated">처리 중에는 항상 IEEE 부동 소수점 NaN 값을 NULL로 변환하십시오. (티켓 # 3060)</target>
        </trans-unit>
        <trans-unit id="87b27942fc2ef02de9cc71a49d6d11d937c022cb" translate="yes" xml:space="preserve">
          <source>Always interpret non-zero floating-point values as TRUE, even if the integer part is zero. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/36fae083b450e3a&quot;&gt;36fae083b450e3a&lt;/a&gt;</source>
          <target state="translated">정수 부분이 0 인 경우에도 항상 0이 아닌 부동 소수점 값을 TRUE로 해석하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/36fae083b450e3a&quot;&gt;36fae083b450e3a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01c848b30df81d8f55cf3c7d1f8d1d01a761b810" translate="yes" xml:space="preserve">
          <source>Always open files using FILE_FLAG_RANDOM_ACCESS under Windows.</source>
          <target state="translated">Windows에서는 항상 FILE_FLAG_RANDOM_ACCESS를 사용하여 파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="f8d9e60c4d2bfefb9734ff11e252389b5ad3e363" translate="yes" xml:space="preserve">
          <source>Always stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="translated">항상 더 빠르고 더 적은 공간을 사용하는 바이너리 형식을 사용하여 다각형을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="c0cacbdc1960d533261c8055f23aacbc49821e24" translate="yes" xml:space="preserve">
          <source>Always use &quot;.&quot; instead of &quot;,&quot; as the decimal point even if the locale requests &quot;,&quot;.</source>
          <target state="translated">항상 &quot;.&quot;를 사용하십시오. 로케일이 &quot;,&quot;를 요청하더라도 소수점 대신 &quot;,&quot;대신.</target>
        </trans-unit>
        <trans-unit id="584a08c96e54122403ed19c82a813d569f28232d" translate="yes" xml:space="preserve">
          <source>Always use memory</source>
          <target state="translated">항상 메모리를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="c823a3478b423d7cd3fa93f63e415cd1f8284276" translate="yes" xml:space="preserve">
          <source>Always use temporary files</source>
          <target state="translated">항상 임시 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57bd289a4480abf71228980bc961a3a7a81bab14" translate="yes" xml:space="preserve">
          <source>Ambiguity resolved using a WHERE clause:</source>
          <target state="translated">모호성은 WHERE 절을 사용하여 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="977cc4fa3c5b3e0d768448bc0910909b0cd480d9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of ON:</source>
          <target state="translated">ON의 모호한 사용 :</target>
        </trans-unit>
        <trans-unit id="7e0cddb45b39e592335cd66056d26b1854d76f94" translate="yes" xml:space="preserve">
          <source>Among other things, sqlite3_initialize() will invoke sqlite3_os_init(). Similarly, sqlite3_shutdown() will invoke sqlite3_os_end().</source>
          <target state="translated">무엇보다도 sqlite3_initialize ()는 sqlite3_os_init ()를 호출합니다. 마찬가지로 sqlite3_shutdown ()은 sqlite3_os_end ()를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6a0ecb85fd4a2b4dd0713046f9744fe6177cf89e" translate="yes" xml:space="preserve">
          <source>An &quot;SQLite Archive&quot; is a file container similar to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP archive&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;Tarball&lt;/a&gt; but based on an SQLite database.</source>
          <target state="translated">&quot;SQLite Archive&quot;는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP 아카이브&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;Tarball&lt;/a&gt; 과 유사 하지만 SQLite 데이터베이스를 기반으로하는 파일 컨테이너 입니다.</target>
        </trans-unit>
        <trans-unit id="348f5f09abc7f6ee023e124686a6cf3527b1dbca" translate="yes" xml:space="preserve">
          <source>An &quot;application file format&quot; is the file format used to persist application state to disk or to exchange information between programs. There are thousands of application file formats in use today. Here are just a few examples:</source>
          <target state="translated">&quot;응용 프로그램 파일 형식&quot;은 응용 프로그램 상태를 디스크에 유지하거나 프로그램간에 정보를 교환하는 데 사용되는 파일 형식입니다. 오늘날 사용중인 수천 개의 응용 프로그램 파일 형식이 있습니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="b8d82aa19e1738a25aad29a6b9a73b1ca57ba1dc" translate="yes" xml:space="preserve">
          <source>An &quot;external content&quot; FTS4 table is similar to a contentless table, except that if evaluation of a query requires the value of a column other than docid, FTS4 attempts to retrieve that value from a table (or view, or virtual table) nominated by the user (hereafter referred to as the &quot;content table&quot;). The FTS4 module never writes to the content table, and writing to the content table does not affect the full-text index. It is the responsibility of the user to ensure that the content table and the full-text index are consistent.</source>
          <target state="translated">&quot;외부 콘텐츠&quot;FTS4 테이블은 쿼리를 평가할 때 docid 이외의 열 값이 필요한 경우 FTS4가 지정한 테이블 (또는 뷰 또는 가상 테이블)에서 해당 값을 검색하려고한다는 점을 제외하고는 내용없는 테이블과 유사합니다. 사용자 (이하 &quot;컨텐츠 테이블&quot;이라고 함). FTS4 모듈은 내용 테이블에 쓰지 않으며 내용 테이블에 쓰더라도 전체 텍스트 인덱스에 영향을 미치지 않습니다. 콘텐츠 테이블과 전체 텍스트 인덱스가 일관성을 유지하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3ec1d3e19881ca421cb7ef0c70026b7ad57adf0c" translate="yes" xml:space="preserve">
          <source>An &quot;int&quot; or &quot;unsigned int&quot;. 32-bits on all modern systems.</source>
          <target state="translated">&quot;int&quot;또는 &quot;unsigned int&quot;입니다. 모든 최신 시스템에서 32 비트</target>
        </trans-unit>
        <trans-unit id="8ca7e1d1ee9bc38ef78e0ad004ec09a25f38b015" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file in the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;OS interface layer&lt;/a&gt;. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that defines methods for performing I/O operations on the open file.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 목적은 파일의 오픈 나타내는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;OS 인터페이스 층&lt;/a&gt; . 개별 OS 인터페이스 구현은 자체 사용을 위해 추가 필드를 추가하여이 오브젝트를 서브 클래스 화하려고합니다. pMethods 항목은 열린 파일에서 I / O 조작을 수행하기위한 메소드를 정의 하는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="04381375841e88bf037fe1e6179f30d5aff3be33" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; that fails due to a constraint violation is not a successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.</source>
          <target state="translated">&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 제약 조건 위반으로 인해 실패 성공하지 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 이 루틴에 의해 반환 된 값을 변경하지 않습니다. 따라서 INSERT 또는 FAIL, INSERT 또는 IGNORE, INSERT OR ROLLBACK 및 INSERT OR ABORT는 삽입 실패시이 루틴의 리턴 값을 변경하지 않습니다. INSERT OR REPLACE에 제약 조건 위반이 발생해도 실패하지 않습니다. 제약 조건 문제를 일으킨 행을 삭제 한 후 INSERT는 계속 완료되므로 INSERT OR REPLACE는 항상이 인터페이스의 반환 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b7085e9237366e0a877aba7cfe87f1fe93d5ad83" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object defines the name of the VFS and the core methods that implement the interface to the operating system, such as checking for existence of files, deleting files, creating files and opening and for reading and/or writing, converting filenames into their canonical form. The &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object also contains methods for obtaining randomness from the operating system, for suspending a process (sleeping) and for finding the current date and time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체는 VFS 및 파일의 존재 여부를 확인 파일을 삭제, 파일과 개방을 만드는 등 자신의 표준에 파일 이름을 변환, 읽기 및 / 또는 쓰기 운영 시스템에 인터페이스를 구현하는 핵심 방법의 이름을 정의 형태. &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs는&lt;/a&gt; 또한 프로세스 (자)를 정지하고 상기 현재 날짜와 시간을 찾기 위해, 운영 체제에서 난수를 획득하기위한 메소드를 포함하는 개체.</target>
        </trans-unit>
        <trans-unit id="1f60bd7f87def89c1a6337dcd5b5e2b9262a189b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file in the &lt;a href=&quot;vfs&quot;&gt;OS interface layer&lt;/a&gt;. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that defines methods for performing I/O operations on the open file.</source>
          <target state="translated">&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 목적은 파일의 오픈 나타내는 &lt;a href=&quot;vfs&quot;&gt;OS 인터페이스 층&lt;/a&gt; . 개별 OS 인터페이스 구현은 자체 사용을 위해 추가 필드를 추가하여이 오브젝트를 서브 클래스 화하려고합니다. pMethods 항목은 열린 파일에서 I / O 조작을 수행하기위한 메소드를 정의 하는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="7a08f9e5c908a78454f64ebfc15b9347529f0e74" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/R-tree&quot;&gt;R-Tree&lt;/a&gt; is a special index that is designed for doing range queries. R-Trees are most commonly used in geospatial systems where each entry is a rectangle with minimum and maximum X and Y coordinates. Given a query rectangle, an R-Tree is able to quickly find all entries that are contained within the query rectangle or which overlap the query rectangle. This idea is easily extended to three dimensions for use in CAD systems. R-Trees also find use in time-domain range look-ups. For example, suppose a database records the starting and ending times for a large number of events. A R-Tree is able to quickly find all events that were active at any time during a given time interval, or all events that started during a particular time interval, or all events that both started and ended within a given time interval. And so forth.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/R-tree&quot;&gt;R-트리&lt;/a&gt;범위 쿼리를 수행하도록 설계된 특수 인덱스입니다. R- 트리는 각 항목이 최소 및 최대 X 및 Y 좌표를 가진 사각형 인 지리 공간 시스템에서 가장 일반적으로 사용됩니다. 쿼리 사각형이 주어지면 R-Tree는 쿼리 사각형 내에 포함되거나 쿼리 사각형과 겹치는 모든 항목을 빠르게 찾을 수 있습니다. 이 아이디어는 CAD 시스템에서 사용하기 위해 3 차원으로 쉽게 확장됩니다. R- 트리는 또한 시간 영역 범위 검색에서 사용됩니다. 예를 들어, 데이터베이스가 많은 이벤트의 시작 및 종료 시간을 기록한다고 가정하십시오. R-Tree는 주어진 시간 간격 동안 언제든지 활성화 된 모든 이벤트, 또는 특정 시간 간격 동안 시작된 모든 이벤트 또는 주어진 시간 간격 내에서 시작 및 종료 된 모든 이벤트를 빠르게 찾을 수 있습니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="db689d4a40dd989536fc477e73ac5f455ae9b267" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause may be specified as part of an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; action within the body of the trigger. However if an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause is specified as part of the statement causing the trigger to fire, then conflict handling policy of the outer statement is used instead.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON 충돌&lt;/a&gt; 절은의 일부로서 특정 될 수 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT의&lt;/a&gt; 트리거의 체내 작용. 그러나 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절이 트리거를 발생시키는 명령문의 일부로 지정된 경우 외부 명령문의 충돌 처리 정책이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e711e9ab5f059bf81635cdaabe4f6f12406ca0c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement with multiple values in the VALUES clause is implemented internally as a compound SELECT. Hence, this option also disables the ability to insert more than a single row using an INSERT INTO ... VALUES ... statement.</source>
          <target state="translated">VALUES 절에 여러 값이 있는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문은 내부적으로 복합 SELECT로 구현됩니다. 따라서이 옵션은 또한 INSERT INTO ... VALUES ... 문을 사용하여 둘 이상의 행을 삽입하는 기능을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c72576d10f0db6ca1b372a30155a9969a36efce9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that fails due to a constraint violation is not a successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.</source>
          <target state="translated">&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 제약 조건 위반으로 인해 실패 성공하지 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 이 루틴에 의해 반환 된 값을 변경하지 않습니다. 따라서 INSERT 또는 FAIL, INSERT 또는 IGNORE, INSERT OR ROLLBACK 및 INSERT OR ABORT는 삽입 실패시이 루틴의 리턴 값을 변경하지 않습니다. INSERT OR REPLACE에 제약 조건 위반이 발생해도 실패하지 않습니다. 제약 조건 문제를 일으킨 행을 삭제 한 후 INSERT는 계속 완료되므로 INSERT OR REPLACE는 항상이 인터페이스의 반환 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="233c7df9e2b5c5b148e9cdae3dbfbdc38ff611a4" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; error is returned when SQLite detects an error in the structure, format, or other control elements of the database file.</source>
          <target state="translated">&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT의&lt;/a&gt; SQLite는이 구조, 형식, 또는 데이터베이스 파일의 다른 제어 요소에서 오류를 검출 할 때 에러가 반환된다.</target>
        </trans-unit>
        <trans-unit id="9dfcb5b52a759e3eac1cc34a332a837f3610b881" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error is returned when a prepared SQL statement is no longer valid and cannot be executed. When this occurs, the statement must be recompiled from SQL using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; API. An SQLITE_SCHEMA error can only occur when using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interfaces to run SQL. You will never receive an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. Nor will you receive an error if you prepare statements using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA의&lt;/a&gt; 준비된 SQL 문이 더 이상 유효하고 실행 할 수없는 경우 오류가 반환되지 않습니다. 이 경우, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; API를 사용하여 명령문을 SQL에서 다시 컴파일해야합니다 . SQLITE_SCHEMA 오류는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스를 사용하여 SQL을 실행할 때만 발생할 수 있습니다 . &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 에서 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류가 수신되지 않습니다 . 당신이 사용하는 문을 준비한다면,도 아니다 당신이 오류가 발생합니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb0be389d3467046061e0e60795dd9c8924c2d5" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;INSERT&lt;/b&gt;. An INSERT change contains a single row to add to a database table. The payload of the INSERT change consists of the values for each field of the new row.</source>
          <target state="translated">&lt;b&gt;INSERT&lt;/b&gt; . INSERT 변경 사항에는 데이터베이스 테이블에 추가 할 단일 행이 포함됩니다. INSERT 변경의 페이로드는 새 행의 각 필드에 대한 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="83cdb736e009dffced879294068506baa8e9d683" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;UPDATE&lt;/b&gt;. An UPDATE change represents the modification of one or more non-PRIMARY KEY fields of a single row within a database table, identified by its PRIMARY KEY fields. The payload for an UPDATE change consists of:</source>
          <target state="translated">&lt;b&gt;UPDATE&lt;/b&gt; . UPDATE 변경은 PRIMARY KEY 필드로 식별되는 데이터베이스 테이블 내 단일 행의 하나 이상의 기본이 아닌 KEY 필드의 수정을 나타냅니다. UPDATE 변경에 대한 페이로드는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a5dfc23afaff11afa8f689dfc92f096e1d0dd0f7" translate="yes" xml:space="preserve">
          <source>An ALWAYS(X) or NEVER(X) sometimes verifies pre-conditions that are subject to change if other parts of the code are modified in subtle ways. At &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&lt;/a&gt; we have a test for two pre-conditions that are true only because of the limited scope of use of the sqlite3BtreeRowCountEst() function. Future enhancements to SQLite might use sqlite3BtreeRowCountEst() in new ways where those preconditions no longer hold, and the NEVER() macros will quickly alert the developers to that fact when the situation arises. But if, for some reason, the pre-conditions are not satisfied in a release build, the program will still behave sanely and will not do an undefined memory access.</source>
          <target state="translated">ALWAYS (X) 또는 NEVER (X)는 때때로 코드의 다른 부분이 미묘한 방식으로 수정 될 경우 변경 될 수있는 사전 조건을 확인합니다. 에서 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&lt;/a&gt; 우리는 때문에 sqlite3BtreeRowCountEst () 함수의 사용 제한 범위에 해당하는 두 개의 사전 조건에 대한 테스트가 있습니다. 향후 SQLite 개선 사항은 sqlite3BtreeRowCountEst ()를 이러한 전제 조건이 더 이상 유지되지 않는 새로운 방식으로 사용할 수 있으며 NEVER () 매크로는 상황이 발생하면 개발자에게 그 사실을 신속하게 경고합니다. 그러나 어떤 이유로 릴리스 빌드에서 사전 조건이 충족되지 않으면 프로그램은 여전히 ​​이상하게 동작하며 정의되지 않은 메모리 액세스를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62094908e44ce569763e84accf72b5b81ec10e3e" translate="yes" xml:space="preserve">
          <source>An Abort is safe if either there have been no writes, or if there is an active statement journal.</source>
          <target state="translated">중단은 쓰기가 없거나 활성 명령문 저널이있는 경우 안전합니다.</target>
        </trans-unit>
        <trans-unit id="86d4a08053c797c7b22cbaba83f05ba798cb81a9" translate="yes" xml:space="preserve">
          <source>An Asynchronous I/O Module For SQLite</source>
          <target state="translated">SQLite를위한 비동기 I / O 모듈</target>
        </trans-unit>
        <trans-unit id="313cb43d54770c72c9e9a5b634de9c9d8807284f" translate="yes" xml:space="preserve">
          <source>An EXCLUDE clause.</source>
          <target state="translated">EXCLUDE 절.</target>
        </trans-unit>
        <trans-unit id="0a3ccdd1b90a20f1709a032dfb49632f1706153c" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_CKPT_LOCK is held by any connection that is running a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. The &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; field of the WAL-index header may be increased while holding this exclusive lock, but it may not be decreased.</source>
          <target state="translated">EXCLUSIVE WAL_CKPT_LOCK은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점을&lt;/a&gt; 실행하는 모든 연결에 의해 유지됩니다 . 이 독점 잠금을 유지하면서 WAL 인덱스 헤더 의 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; 필드를 늘릴 수 있지만 줄이지는 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a19836854f508f748dd9a22070d5c210f0d520" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_RECOVER_LOCK is held by any connection that is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; to reconstruct the shared WAL-index.</source>
          <target state="translated">EXCLUSIVE WAL_RECOVER_LOCK은 공유 WAL- 인덱스를 재구성하기 위해 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행중인 모든 연결에 의해 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d163a00e9e60a29df0fd7690728f45560ff5f27b" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_WRITE_LOCK is held by any connection that is appending content to the end of the WAL. Hence, only a single process at a time can append content to the WAL. If a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; occurs as a consequence of a write, then the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; field of the WAL-index header is reset to zero while holding this lock.</source>
          <target state="translated">EXCLUSIVE WAL_WRITE_LOCK은 WAL 끝에 컨텐츠를 추가하는 모든 연결에 의해 유지됩니다. 따라서 한 번에 하나의 프로세스 만 WAL에 내용을 추가 할 수 있습니다. 경우 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL 재설정&lt;/a&gt; 쓰기의 결과로 발생 후 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill의&lt;/a&gt; 월마트 인덱스 헤더의 필드는이 잠금을 보유하는 동안 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="b57abe13c7006fd13b284a30313d8dda20eaf017" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE is also held WAL_CKPT_LOCK, and on several other locking bytes, when a connection is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; on the shared WAL-index.</source>
          <target state="translated">연결이 공유 WAL- 인덱스 에서 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행하는 경우 EXCLUSIVE도 WAL_CKPT_LOCK과 다른 여러 잠금 바이트에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="88b81d585355ad5a271ae62aa21273cf7062ea05" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE is also held WAL_WRITE_LOCK, and on several other locking bytes, when a connection is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; on the shared WAL-index.</source>
          <target state="translated">연결이 공유 WAL- 인덱스 에서 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행하는 경우 EXCLUSIVE도 WAL_WRITE_LOCK과 다른 여러 잠금 바이트에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f52310ba827cb9fe23894a867314c3a13854ff87" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE lock is needed in order to write to the database file. Only one EXCLUSIVE lock is allowed on the file and no other locks of any kind are allowed to coexist with an EXCLUSIVE lock. In order to maximize concurrency, SQLite works to minimize the amount of time that EXCLUSIVE locks are held.</source>
          <target state="translated">데이터베이스 파일에 쓰려면 독점 잠금이 필요합니다. 파일에는 하나의 EXCLUSIVE 잠금 만 허용되며 어떤 종류의 다른 잠금도 EXCLUSIVE 잠금과 공존 할 수 없습니다. 동시성을 최대화하기 위해 SQLite는 독점 잠금이 유지되는 시간을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="fe2062deb028f6de38ba9c3021c202a7b43810db" translate="yes" xml:space="preserve">
          <source>An FTS tokenizer is a set of rules for extracting terms from a document or basic FTS full-text query.</source>
          <target state="translated">FTS 토크 나이 저는 문서 또는 기본 FTS 전체 텍스트 쿼리에서 용어를 추출하기위한 규칙 집합입니다.</target>
        </trans-unit>
        <trans-unit id="818fc889442be27af5d1325013f400680296296c" translate="yes" xml:space="preserve">
          <source>An I/O error on a memory-mapped file cannot be caught and dealt with by SQLite. Instead, the I/O error causes a signal which, if not caught by the application, results in a program crash.</source>
          <target state="translated">메모리 매핑 된 파일의 I / O 오류는 SQLite에서 포착하여 처리 할 수 ​​없습니다. 대신, I / O 오류는 신호를 발생시켜 응용 프로그램에 의해 포착되지 않으면 프로그램 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="8b95db3810ecf86965c82c39a14ddcb38a561afc" translate="yes" xml:space="preserve">
          <source>An IEEE 754 floating-point value is an integer multiplied by a power of two:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c82d6c0937081333b2317419d2ebad443727010" translate="yes" xml:space="preserve">
          <source>An IEEE double-precision (64-bit) floating point number</source>
          <target state="translated">IEEE 배정도 (64 비트) 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="4cd5420d6298ed92154e0329258defd31fd25a74" translate="yes" xml:space="preserve">
          <source>An INTEGER or REAL value is less than any TEXT or BLOB value. When an INTEGER or REAL is compared to another INTEGER or REAL, a numerical comparison is performed.</source>
          <target state="translated">INTEGER 또는 REAL 값이 TEXT 또는 BLOB 값보다 작습니다. INTEGER 또는 REAL이 다른 INTEGER 또는 REAL과 비교 될 때 숫자 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3433c2fda29528c66dead93e3becaa2d64f147" translate="yes" xml:space="preserve">
          <source>An Introduction To The SQLite C/C++ Interface</source>
          <target state="translated">SQLite C / C ++ 인터페이스 소개</target>
        </trans-unit>
        <trans-unit id="1217ba99243b6eebb93b7b8b51f28f6be4f9d08a" translate="yes" xml:space="preserve">
          <source>An ORDER BY clause on the recursive-select can be used to control whether the search of a tree is depth-first or breadth-first. To illustrate, we will use a variation on the &quot;org&quot; table from an example above, without the &quot;height&quot; column, and with some real data inserted:</source>
          <target state="translated">재귀 선택의 ORDER BY 절을 사용하여 트리 검색이 깊이 우선인지 너비 우선인지를 제어 할 수 있습니다. 예를 들어, 위의 예에서 &quot;높이&quot;열없이 실제 데이터가 삽입 된 &quot;org&quot;테이블의 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23032a9cac30263b1d8146df43c99d82099810f2" translate="yes" xml:space="preserve">
          <source>An ORDER BY or GROUP BY clause</source>
          <target state="translated">ORDER BY 또는 GROUP BY 절</target>
        </trans-unit>
        <trans-unit id="6b7badb7ceeef79983e30969dff232619460ee2c" translate="yes" xml:space="preserve">
          <source>An OpenDocument Presentation or &quot;ODP&quot; file is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archive&lt;/a&gt; containing XML files describing presentation slides and separate image files for the various images that are included as part of the presentation. (OpenDocument word processor and spreadsheet files are similarly structured but are not considered by this article.) The reader can easily see the content of an ODP file by using the &quot;zip -l&quot; command. For example, the following is the &quot;zip -l&quot; output from a 49-slide presentation about SQLite from the 2014 &lt;a href=&quot;http://southeastlinuxfest.org/&quot;&gt;SouthEast LinuxFest&lt;/a&gt; conference:</source>
          <target state="translated">OpenDocument 프리젠 테이션 또는 &quot;ODP&quot;파일은 프리젠 테이션 슬라이드를 설명하는 XML 파일과 프리젠 테이션의 일부로 포함 된 다양한 이미지에 대한 별도의 이미지 파일을 포함 하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP 아카이브&lt;/a&gt; 입니다. OpenDocument 워드 프로세서와 스프레드 시트 파일은 유사하게 구성되어 있지만이 기사에서는 고려하지 않습니다. 독자는 &quot;zip -l&quot;명령을 사용하여 ODP 파일의 내용을 쉽게 볼 수 있습니다. 예를 들어, 다음은 2014 &lt;a href=&quot;http://southeastlinuxfest.org/&quot;&gt;SouthEast LinuxFest&lt;/a&gt; 컨퍼런스 에서 SQLite에 대한 49 개 슬라이드 프레젠테이션의 &quot;zip -l&quot;출력입니다 .</target>
        </trans-unit>
        <trans-unit id="3cc6b47353bce3b91e074154d427c28b96c16d62" translate="yes" xml:space="preserve">
          <source>An R*Tree query is initialized by making the root node the only entry in a priority queue sorted by rScore. The query proceeds by extracting the entry from the priority queue that has the lowest score. If that entry is a leaf (meaning that it is an actual R*Tree entry and not a subtree) then that entry is returned as one row of the query result. If the extracted priority queue entry is a node (a subtree), then sub-subtrees or leaves contained within that entry are passed to the xQueryFunc callback, one by one. Those subelements for which the xQueryFunc callback sets eWithin to PARTLY_WITHIN or FULLY_WITHIN are added to the priority queue using the score supplied by the callback. Subelements that return NOT_WITHIN are discarded. The query runs until the priority queue is empty.</source>
          <target state="translated">R * Tree 쿼리는 루트 노드를 rScore로 정렬 된 우선 순위 큐의 유일한 항목으로 만들어 초기화됩니다. 쿼리는 점수가 가장 낮은 우선 순위 큐에서 항목을 추출하여 진행됩니다. 해당 항목이 리프 (하위 트리가 아니라 실제 R * Tree 항목임을 의미) 인 경우 해당 항목은 조회 결과의 한 행으로 리턴됩니다. 추출 된 우선 순위 큐 항목이 노드 (하위 트리)이면 해당 항목에 포함 된 하위 서브 트리 또는 잎이 xQueryFunc 콜백에 하나씩 전달됩니다. xQueryFunc 콜백이 eWithin을 PARTLY_WITHIN 또는 FULLY_WITHIN으로 설정하는 하위 요소는 콜백에서 제공 한 점수를 사용하여 우선 순위 큐에 추가됩니다. NOT_WITHIN을 반환하는 하위 요소는 삭제됩니다. 우선 순위 큐가 비워 질 때까지 쿼리가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c36503645997aef3b66492ffa49c5737331ae5b" translate="yes" xml:space="preserve">
          <source>An RBU Vacuum operation requires less temporary disk space and writes less data to disk than an SQLite VACUUM. An SQLite VACUUM requires roughly twice the size of the final database file in temporary disk space to run. The total amount of data written is around three times the size of the final database file. By contrast, an RBU Vacuum requires roughly the size of the final database file in temporary disk space and writes a total of twice that to disk.</source>
          <target state="translated">RBU Vacuum 작업은 SQLite VACUUM보다 임시 디스크 공간이 적고 디스크에 데이터를 덜 씁니다. SQLite VACUUM을 실행하려면 임시 디스크 공간에서 최종 데이터베이스 파일 크기의 약 2 배가 필요합니다. 기록 된 총 데이터 양은 최종 데이터베이스 파일 크기의 약 3 배입니다. 반대로, RBU Vacuum은 임시 디스크 공간에서 대략적인 최종 데이터베이스 파일 크기를 요구하며 디스크에 총 2 배를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b402488c545650e7a0466693ac0992d5dced3759" translate="yes" xml:space="preserve">
          <source>An RBU handle is created by calling sqlite3rbu_vacuum(T, S).</source>
          <target state="translated">sqlite3rbu_vacuum (T, S)를 호출하여 RBU 핸들이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d98c92ed51948506a67c9bcda80cc97f4fcfe4" translate="yes" xml:space="preserve">
          <source>An SQL aggregate function, which can be used to create new archives in memory.</source>
          <target state="translated">메모리에 새 아카이브를 작성하는 데 사용할 수있는 SQL 집계 함수</target>
        </trans-unit>
        <trans-unit id="9bd314dc55feb99e9480fcbcc4eb53b163d23b23" translate="yes" xml:space="preserve">
          <source>An SQL operation that is interrupted will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;. If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.</source>
          <target state="translated">중단 된 SQL 조작은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 를 리턴 합니다 . 인터럽트 된 SQL 조작이 명시 적 트랜잭션 내에있는 INSERT, UPDATE 또는 DELETE 인 경우 전체 트랜잭션이 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8b61384d0c44a2e614c579b268363eaa1fc909" translate="yes" xml:space="preserve">
          <source>An SQL operation that is interrupted will return &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;. If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.</source>
          <target state="translated">중단 된 SQL 조작은 &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 를 리턴 합니다 . 인터럽트 된 SQL 조작이 명시 적 트랜잭션 내에있는 INSERT, UPDATE 또는 DELETE 인 경우 전체 트랜잭션이 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="3de39c28f7d860e2f20cf499f83a1ecd516190b8" translate="yes" xml:space="preserve">
          <source>An SQL statement can be preceded by the keyword &quot;EXPLAIN&quot; or by the phrase &quot;EXPLAIN QUERY PLAN&quot;. Either modification causes the SQL statement to behave as a query and to return information about how the SQL statement would have operated if the EXPLAIN keyword or phrase had been omitted.</source>
          <target state="translated">SQL 문 앞에는 키워드 &quot;EXPLAIN&quot;또는 &quot;EXPLAIN QUERY PLAN&quot;문구가 올 수 있습니다. 수정하면 SQL 문이 조회로 작동하고 EXPLAIN 키워드 또는 구가 생략 된 경우 SQL 문이 작동 한 방법에 대한 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5abd7dabfe02360ec2bf6a05e3dfaa3cf5654f08" translate="yes" xml:space="preserve">
          <source>An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; instead of just &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; to start a transaction. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will return SQLITE_BUSY.</source>
          <target state="translated">트랜잭션의 어느 시점에서나 트랜잭션이 처음 시작될 때, 쓰기 또는 업데이트 작업 중 또는 트랜잭션이 커밋 될 때 SQLITE_BUSY 오류가 발생할 수 있습니다. 트랜잭션의 중간에 SQLITE_BUSY 오류가 발생하지 않도록하려면 응용 프로그램을 사용할 수 있습니다 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE에게 BEGIN&lt;/a&gt; 대신 단지 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 트랜잭션을 시작합니다. 는 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt; 자체가 SQLITE_BUSY을 반환 할 수 명령을하지만 성공하면, 다음 SQLite는 보장 옆 통해 동일한 데이터베이스에 대한 후속 작업 것을 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT는&lt;/a&gt; SQLITE_BUSY를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac700efdf9da65c96e524e1f874e4322c772698e" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_CLOSE callback is invoked when a database connection closes. The P argument is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; object and the X argument is unused.</source>
          <target state="translated">데이터베이스 연결이 닫히면 SQLITE_TRACE_CLOSE 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트에 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90dda83d19d5a0e9440a66a5153d6f08cfb8e791" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_CLOSE callback is invoked when a database connection closes. The P argument is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; object and the X argument is unused.</source>
          <target state="translated">데이터베이스 연결이 닫히면 SQLITE_TRACE_CLOSE 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트에 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6463d38e5743fc7b60a45c0dd4edf8e6196b2c76" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_PROFILE callback provides approximately the same information as is provided by the &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument points to a 64-bit integer which is the estimated of the number of nanosecond that the prepared statement took to run. The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.</source>
          <target state="translated">SQLITE_TRACE_PROFILE 콜백은 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 콜백 에서 제공하는 것과 거의 동일한 정보를 제공합니다 . P 인수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이고 X 인수는 준비된 명령문을 실행하는 데 걸린 나노초 수로 추정되는 64 비트 정수를 가리 킵니다. 명령문이 완료되면 SQLITE_TRACE_PROFILE 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="51f65212fb2842387dde50749c6891ed068f1d2c" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_PROFILE callback provides approximately the same information as is provided by the &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument points to a 64-bit integer which is the estimated of the number of nanosecond that the prepared statement took to run. The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.</source>
          <target state="translated">SQLITE_TRACE_PROFILE 콜백은 &lt;a href=&quot;profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 콜백 에서 제공하는 것과 거의 동일한 정보를 제공합니다 . P 인수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이고 X 인수는 준비된 명령문을 실행하는 데 걸린 나노초 수로 추정되는 64 비트 정수를 가리 킵니다. 명령문이 완료되면 SQLITE_TRACE_PROFILE 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="959b99495fe9f93bfe60c0c8dc39f940a8cc7107" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_ROW callback is invoked whenever a prepared statement generates a single row of result. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument is unused.</source>
          <target state="translated">준비된 명령문이 단일 결과 행을 생성 할 때마다 SQLITE_TRACE_ROW 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2c23282009e34d356e10ef768fd5d27fe9242d7" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_ROW callback is invoked whenever a prepared statement generates a single row of result. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument is unused.</source>
          <target state="translated">준비된 명령문이 단일 결과 행을 생성 할 때마다 SQLITE_TRACE_ROW 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d87f64da2cd54c09ca013ca90ee9edc2e86b39e0" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_STMT callback is invoked when a prepared statement first begins running and possibly at other times during the execution of the prepared statement, such as at the start of each trigger subprogram. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The X argument is a pointer to a string which is the unexpanded SQL text of the prepared statement or an SQL comment that indicates the invocation of a trigger. The callback can compute the same text that would have been returned by the legacy &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interface by using the X argument when X begins with &quot;--&quot; and invoking &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_expanded_sql(P)&lt;/a&gt; otherwise.</source>
          <target state="translated">SQLITE_TRACE_STMT 콜백은 준비된 명령문이 처음 실행될 때 그리고 가능하면 각 트리거 서브 프로그램의 시작과 같이 준비된 명령문을 실행하는 동안 다른 시간에 호출됩니다. P 인수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 입니다. X 인수는 준비된 명령문의 확장되지 않은 SQL 텍스트 또는 트리거 호출을 나타내는 SQL 주석 인 문자열에 대한 포인터입니다. 콜백은 X가 &quot;-&quot;로 시작할 때 X 인수를 사용하고 그렇지 않으면 &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_expanded_sql (P)를&lt;/a&gt; 호출 하여 레거시 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 인터페이스 에서 반환 된 것과 동일한 텍스트를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67e19a52fd0823eafed0ed156581e34f2ae1fb9a" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_STMT callback is invoked when a prepared statement first begins running and possibly at other times during the execution of the prepared statement, such as at the start of each trigger subprogram. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The X argument is a pointer to a string which is the unexpanded SQL text of the prepared statement or an SQL comment that indicates the invocation of a trigger. The callback can compute the same text that would have been returned by the legacy &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interface by using the X argument when X begins with &quot;--&quot; and invoking &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_expanded_sql(P)&lt;/a&gt; otherwise.</source>
          <target state="translated">SQLITE_TRACE_STMT 콜백은 준비된 명령문이 처음 실행될 때 그리고 가능하면 각 트리거 서브 프로그램의 시작과 같이 준비된 명령문을 실행하는 동안 다른 시간에 호출됩니다. P 인수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 입니다. X 인수는 준비된 명령문의 확장되지 않은 SQL 텍스트 또는 트리거 호출을 나타내는 SQL 주석 인 문자열에 대한 포인터입니다. 콜백은 X가 &quot;-&quot;로 시작할 때 X 인수를 사용하고 그렇지 않으면 &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_expanded_sql (P)를&lt;/a&gt; 호출 하여 레거시 &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 인터페이스 에서 반환 된 것과 동일한 텍스트를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40dcdd5a240705c4bdfc3ba184015a22602dc143" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can be queried using a high-level query language (SQL). Some examples:</source>
          <target state="translated">SQLite Archive는 고급 쿼리 언어 (SQL)를 사용하여 쿼리 할 수 ​​있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="b242257f9fcf2e3e2eac957dac8e90b190c245bb" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can be updated incrementally. Individual files can be added or removed or replaced without having to rewrite the entire archive.</source>
          <target state="translated">SQLite Archive는 증분 업데이트 할 수 있습니다. 전체 아카이브를 다시 쓰지 않고도 개별 파일을 추가 또는 제거하거나 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a576b713a86af9234a7a7f85c2bf0090d4320d5" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can work around firewall-imposed censorship. For example, certain file types that are considered &quot;dangerous&quot; (examples: DLLs) will be &lt;a href=&quot;https://support.google.com/mail/answer/6590&quot;&gt;blocked by Gmail&lt;/a&gt; and probably many other email services and firewall, even if those files are wrapped inside a ZIP Archive or Tarball. But these firewall usually do not care about SQLite Archives and so content can be put inside an SQLite Archive to evade censorship.</source>
          <target state="translated">SQLite Archive는 방화벽이 적용된 검열 문제를 해결할 수 있습니다. 예를 들어, &quot;위험한&quot;것으로 간주되는 특정 파일 형식 (예 : DLL)은 해당 파일이 ZIP 보관 파일 또는 Tarball에 래핑되어 있어도 &lt;a href=&quot;https://support.google.com/mail/answer/6590&quot;&gt;Gmail&lt;/a&gt; 및 기타 여러 전자 메일 서비스 및 방화벽에 의해 차단됩니다 . 그러나 이러한 방화벽은 일반적으로 SQLite Archives에 신경 쓰지 않으므로 검열을 피하기 위해 SQLite Archive에 내용을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4118c0f7a6f81cb74480ccc9fa50eb744542f589" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is an ordinary SQLite database file that contains the following table as part of its schema:</source>
          <target state="translated">SQLite Archive는 스키마의 일부로 다음 테이블을 포함하는 일반 SQLite 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="dc6cbe656d1d7ad99c40dcbbe2f8824b11660a4b" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is flexible. ZIP Archives and Tarballs are limited to storing only files. An SQLite Archive stores files plus whatever other tabular and/or relational data seems useful to the application.</source>
          <target state="translated">SQLite Archive는 유연합니다. ZIP 아카이브 및 타르볼은 파일 만 저장하도록 제한됩니다. SQLite Archive는 파일과 응용 프로그램에 유용한 다른 테이블 및 / 또는 관계형 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b26644641a5c080b143bed71ae376b8f86f40091" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is one example of a more general idea that an SQLite database can behave as a container object holding lots of smaller data components.</source>
          <target state="translated">SQLite Archive는 SQLite 데이터베이스가 많은 작은 데이터 구성 요소를 보유하는 컨테이너 개체로 작동 할 수 있다는보다 일반적인 아이디어의 한 예입니다.</target>
        </trans-unit>
        <trans-unit id="5d177845e7556bf44c101aaef7f85cf75f9d1c63" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is transactional. Updates are atomic and durable, even if there are crashes or power losses in the middle of the update. Readers see a consistent and unchanging version of the content even is some other process is simultaneously updating the archive.</source>
          <target state="translated">SQLite Archive는 트랜잭션입니다. 업데이트 도중 업데이트 나 충돌이 발생하더라도 업데이트는 원자적이고 내구성이 있습니다. 독자들은 일관성 있고 변하지 않는 내용의 버전을보고 다른 프로세스가 동시에 아카이브를 업데이트하고 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3312ff278a713e75002ecfaa844a5076353ef655" translate="yes" xml:space="preserve">
          <source>An SQLite Archive supports only the &lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt; compression method. Tarballs and ZIP Archive support a wider assortment of compression methods.</source>
          <target state="translated">SQLite Archive는 &lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt; 압축 방법 만 지원합니다 . Tarballs 및 ZIP Archive는 더 다양한 압축 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8fd49e13abc11c533a20ccc6b5f7798ff20c6616" translate="yes" xml:space="preserve">
          <source>An SQLite Database File</source>
          <target state="translated">SQLite 데이터베이스 파일</target>
        </trans-unit>
        <trans-unit id="b000f5fd9df31bd42422b2ef21f81528c08cea1a" translate="yes" xml:space="preserve">
          <source>An SQLite application file format is a great choice in cases where there is a collection or &quot;federation&quot; of separate programs, often written in different languages and by different development teams. This comes up commonly in research or laboratory environments where one team is responsible for data acquisition and other teams are responsible for various stages of analysis. Each team can use whatever hardware, operating system, programming language and development methodology that they are most comfortable with, and as long as all programs use an SQLite database with a common schema, they can all interoperate.</source>
          <target state="translated">SQLite 응용 프로그램 파일 형식은 종종 다른 언어로 작성되고 다른 개발 팀이 작성하는 별도의 프로그램 모음 또는 &quot;연합&quot;이있는 경우에 적합합니다. 이는 한 팀이 데이터 수집을 담당하고 다른 팀은 다양한 분석 단계를 담당하는 연구 또는 실험실 환경에서 일반적으로 발생합니다. 각 팀은 가장 편리한 하드웨어, 운영 체제, 프로그래밍 언어 및 개발 방법을 사용할 수 있으며 모든 프로그램이 공통 스키마가있는 SQLite 데이터베이스를 사용하는 한 모두 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bcad71b941086fc8d3676a58f2f663381ad6019" translate="yes" xml:space="preserve">
          <source>An SQLite database can become corrupt if the file content changes due to a disk drive or flash memory failure. It is very rare, but disks will occasionally flip a bit in the middle of a sector.</source>
          <target state="translated">디스크 드라이브 나 플래시 메모리 오류로 인해 파일 내용이 변경되면 SQLite 데이터베이스가 손상 될 수 있습니다. 매우 드물지만 디스크가 섹터의 한가운데서 약간 튀어 나오는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa981e15b39eb75edaa6ff0d13de7391ec0f911" translate="yes" xml:space="preserve">
          <source>An SQLite database connection defaults to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=DELETE&lt;/a&gt;. To convert to WAL mode, use the following pragma:</source>
          <target state="translated">SQLite 데이터베이스 연결의 기본값은 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = DELETE&lt;/a&gt; 입니다. WAL 모드로 변환하려면 다음 pragma를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dfa9719008b383e9c69cd74a19a5c395ef612cf2" translate="yes" xml:space="preserve">
          <source>An SQLite database facilitates data transfer between systems even when the endpoints have different word sizes and/or byte orders. The data can be a complex mix of large binary blobs, text, and small numeric or boolean values. The data format can be easily extended by adding new tables and/or columns, without breaking legacy receivers. The SQL query language means that receivers are not required to parse the entire transfer all at once, but can instead query the received content as needed. The data format is &quot;transparent&quot; in the sense that it is easily decoded for human viewing using a variety of universally available, open-source tools, from multiple vendors.</source>
          <target state="translated">SQLite 데이터베이스는 엔드 포인트의 단어 크기 및 / 또는 바이트 순서가 다른 경우에도 시스템 간의 데이터 전송을 용이하게합니다. 데이터는 큰 이진 얼룩, 텍스트 및 작은 숫자 또는 부울 값의 복잡한 혼합 일 수 있습니다. 레거시 수신기를 중단하지 않고 새 테이블 및 / 또는 열을 추가하여 데이터 형식을 쉽게 확장 할 수 있습니다. SQL 쿼리 언어는 수신자가 전체 전송을 한 번에 모두 구문 분석 할 필요는 없지만 대신 수신 된 컨텐츠를 쿼리 할 수 ​​있음을 의미합니다. 데이터 형식은 여러 공급 업체의 다양한 범용 오픈 소스 도구를 사용하여 사람이 볼 수 있도록 쉽게 디코딩된다는 점에서 &quot;투명&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="982d7ceede2aaf5d861f9c36536e7099da9073ca" translate="yes" xml:space="preserve">
          <source>An SQLite database file consists of one or more &quot;pages&quot;. For a single database file, all pages are the same size, though for different database files, the page size can any power of two between 512 and 65536, inclusive.</source>
          <target state="translated">SQLite 데이터베이스 파일은 하나 이상의 &quot;페이지&quot;로 구성됩니다. 단일 데이터베이스 파일의 경우 모든 페이지의 크기는 동일하지만 다른 데이터베이스 파일의 경우 페이지 크기는 512에서 65536 사이의 2의 제곱을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1d2c158eb6a0a9552493d7c89540c3e0f9e893f" translate="yes" xml:space="preserve">
          <source>An SQLite database file is approximately the same size, and in some cases smaller, than a ZIP archive holding the same information.</source>
          <target state="translated">SQLite 데이터베이스 파일은 동일한 정보를 보유하는 ZIP 아카이브와 크기가 대략 동일하며 경우에 따라 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="2c4396f52519eb130b5dd0375bda350b47a433fb" translate="yes" xml:space="preserve">
          <source>An SQLite database file is divided into pages. The first page is 1, the second page is 2, and so forth. There is no page 0. Every page is the same size. The size of every page is a power of 2 between 512 and 65536. See the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further details.</source>
          <target state="translated">SQLite 데이터베이스 파일은 페이지로 나뉩니다. 첫 번째 페이지는 1이고 두 번째 페이지는 2입니다. 0 페이지가 없습니다. 모든 페이지는 같은 크기입니다. 모든 페이지의 크기는 512에서 65536 사이의 2의 거듭 제곱입니다. 자세한 내용은 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f8b304d710aae6886e59c81e1a985cd1cd70645" translate="yes" xml:space="preserve">
          <source>An SQLite database file with a defined schema often makes an excellent application file format. Here are a dozen reasons why this is so:</source>
          <target state="translated">정의 된 스키마가있는 SQLite 데이터베이스 파일은 종종 우수한 응용 프로그램 파일 형식을 만듭니다. 다음과 같은 12 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ebdfe9c0e4c8eb0d11614911caf8938817b53f" translate="yes" xml:space="preserve">
          <source>An SQLite database has a lot of capability, which this essay has only begun to touch upon. But hopefully this quick glimpse has convinced some readers that using an SQL database as an application file format is worth a second look.</source>
          <target state="translated">SQLite 데이터베이스에는 많은 기능이 있으며이 에세이는 이제 막 다루기 시작했습니다. 그러나이 빠른 요약을 통해 일부 독자들은 SQL 데이터베이스를 응용 프로그램 파일 형식으로 사용하는 것이 두 번째로 가치가 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="69541d5b92ee6eb3e8f9d53bc6a238b7db778bec" translate="yes" xml:space="preserve">
          <source>An SQLite database is a &lt;a href=&quot;fileformat2&quot;&gt;well-defined and well-documented&lt;/a&gt; file format that is in widespread use by literally millions of applications and is backwards compatible to its inception in 2004 and which promises to continue to be compatible in decades to come. The longevity of SQLite database files is particularly important to bespoke applications, since it allows the document content to be accessed far in the future, long after all traces of the original application have been lost. Data lives longer than code. SQLite databases are &lt;a href=&quot;locrsf&quot;&gt;recommended by the US Library of Congress&lt;/a&gt; as a storage format for long-term preservation of digital content.</source>
          <target state="translated">SQLite 데이터베이스는 문자 그대로 수백만 개의 응용 프로그램에서 널리 사용되는 &lt;a href=&quot;fileformat2&quot;&gt;잘 정의되고 잘 문서화 된&lt;/a&gt; 파일 형식으로 2004 년에 처음부터 역 호환되며 앞으로 수십 년 동안 계속 호환 될 것입니다. SQLite 데이터베이스 파일의 수명은 원본 응용 프로그램의 모든 흔적을 잃어버린 후에도 장래에 문서 내용에 액세스 할 수 있기 때문에 응용 프로그램을 예약하는 데 특히 중요합니다. 코드보다 데이터 수명이 깁니다. SQLite 데이터베이스는 &lt;a href=&quot;locrsf&quot;&gt;미국 의회 도서관&lt;/a&gt; 에서 디지털 컨텐츠의 장기 보존을위한 스토리지 형식으로 권장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1414bb1ca0b7308fabbbb0231f95883cdfb55f17" translate="yes" xml:space="preserve">
          <source>An SQLite database is a single ordinary disk file that can be located anywhere in the directory hierarchy. If SQLite can read the disk file then it can read anything in the database. If the disk file and its directory are writable, then SQLite can change anything in the database. Database files can easily be copied onto a USB memory stick or emailed for sharing.</source>
          <target state="translated">SQLite 데이터베이스는 디렉토리 계층의 어느 곳에 나 위치 할 수있는 단일 일반 디스크 파일입니다. SQLite가 디스크 파일을 읽을 수 있으면 데이터베이스의 모든 것을 읽을 수 있습니다. 디스크 파일과 디렉토리가 쓰기 가능하면 SQLite는 데이터베이스의 모든 것을 변경할 수 있습니다. 데이터베이스 파일을 USB 메모리 스틱에 쉽게 복사하거나 이메일로 보내 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f9b6d073e3679cf263c66c45442a544e5b6ca4c" translate="yes" xml:space="preserve">
          <source>An SQLite database is a single ordinary file on disk (with a &lt;a href=&quot;fileformat2&quot;&gt;well-defined file format&lt;/a&gt;). With other systems, a &quot;database&quot; is usually a large number of separate files hidden away in obscure directories of the filesystem, or even spread across multiple machines. But with SQLite, a complete database is just an ordinary disk file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26fb41c051ef1c4cae3e65d019499aa1d3715a71" translate="yes" xml:space="preserve">
          <source>An SQLite database is highly resistant to corruption. If an application crash, or an operating-system crash, or even a power failure occurs in the middle of a transaction, the partially written transaction should be automatically rolled back the next time the database file is accessed. The recovery process is fully automatic and does not require any action on the part of the user or the application.</source>
          <target state="translated">SQLite 데이터베이스는 손상에 매우 강합니다. 트랜잭션 중간에 응용 프로그램 충돌 또는 운영 체제 충돌 또는 정전이 발생할 경우 다음에 데이터베이스 파일에 액세스 할 때 부분적으로 작성된 트랜잭션이 자동으로 롤백되어야합니다. 복구 프로세스는 완전 자동이므로 사용자 나 응용 프로그램에 대한 조치가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3b90e2f3f651754fcb6451ab34aac384e7a5fbe" translate="yes" xml:space="preserve">
          <source>An SQLite database is limited in size to 140 terabytes (2&lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; bytes, 128 tibibytes). And even if it could handle larger databases, SQLite stores the entire database in a single disk file and many filesystems limit the maximum size of files to something less than this. So if you are contemplating databases of this magnitude, you would do well to consider using a client/server database engine that spreads its content across multiple disk files, and perhaps across multiple volumes.</source>
          <target state="translated">SQLite 데이터베이스의 크기는 140 테라 바이트 (2 &lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; 바이트, 128 티비 바이트)로 제한됩니다. 더 큰 데이터베이스를 처리 할 수 ​​있더라도 SQLite는 전체 데이터베이스를 단일 디스크 파일에 저장하며 많은 파일 시스템은 파일의 최대 크기를 이보다 작은 것으로 제한합니다. 따라서이 정도 규모의 데이터베이스를 고려하는 경우 여러 디스크 파일 또는 여러 볼륨에 내용을 분산시키는 클라이언트 / 서버 데이터베이스 엔진을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="558b75a72d8c6499c78323d65dfdffa7599a1498" translate="yes" xml:space="preserve">
          <source>An SQLite database is limited in size to 281 terabytes (2&lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; bytes, 128 tibibytes). And even if it could handle larger databases, SQLite stores the entire database in a single disk file and many filesystems limit the maximum size of files to something less than this. So if you are contemplating databases of this magnitude, you would do well to consider using a client/server database engine that spreads its content across multiple disk files, and perhaps across multiple volumes.</source>
          <target state="translated">SQLite 데이터베이스의 크기는 281 테라 바이트 (2 &lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; 바이트, 128 티비 바이트)로 제한됩니다. 그리고 더 큰 데이터베이스를 처리 할 수 ​​있더라도 SQLite는 전체 데이터베이스를 단일 디스크 파일에 저장하고 많은 파일 시스템이 파일의 최대 크기를 이보다 작은 크기로 제한합니다. 따라서이 정도 규모의 데이터베이스를 고려하는 경우 콘텐츠를 여러 디스크 파일과 여러 볼륨에 분산시키는 클라이언트 / 서버 데이터베이스 엔진을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8efcb5c5b5fbf0d6f174a7bd1fdafd17d5d08348" translate="yes" xml:space="preserve">
          <source>An SQLite database is maintained on disk using a B-tree implementation found in the &lt;a href=&quot;https://sqlite.org/src/file/src/btree.c&quot;&gt;btree.c&lt;/a&gt; source file. A separate B-tree is used for each table and index in the database. All B-trees are stored in the same disk file. The &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; details are stable and well-defined and are guaranteed to be compatible moving forward.</source>
          <target state="translated">SQLite 데이터베이스는 &lt;a href=&quot;https://sqlite.org/src/file/src/btree.c&quot;&gt;btree.c&lt;/a&gt; 소스 파일 에있는 B-tree 구현을 사용하여 디스크에서 유지 관리 됩니다. 데이터베이스의 각 테이블과 인덱스에 별도의 B- 트리가 사용됩니다. 모든 B- 트리는 동일한 디스크 파일에 저장됩니다. &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 자세한 내용은 안정적이고 잘 정의하고 앞으로 호환 이동을 보장받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25bf5d553881678b34da8985ef757fc5ffe38cac" translate="yes" xml:space="preserve">
          <source>An SQLite database is normally stored in a single ordinary disk file. However, in certain circumstances, the database might be stored in memory.</source>
          <target state="translated">SQLite 데이터베이스는 일반적으로 단일 일반 디스크 파일에 저장됩니다. 그러나 특정 상황에서는 데이터베이스가 메모리에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffcfbe0c6736b628bac17f2c3fd76a08f4a70298" translate="yes" xml:space="preserve">
          <source>An SQLite extension is a shared library or DLL. To load it, you need to supply SQLite with the name of the file containing the shared library or DLL and an entry point to initialize the extension. In C code, this information is supplied using the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API. See the documentation on that routine for additional information.</source>
          <target state="translated">SQLite 확장은 공유 라이브러리 또는 DLL입니다. 이를로드하려면 SQLite에 공유 라이브러리 또는 DLL이 포함 된 파일 이름과 확장명을 초기화하기위한 진입 점을 제공해야합니다. C 코드에서이 정보는 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; API를 사용하여 제공 됩니다. 추가 정보는 해당 루틴의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="741d402ffb5729c1f12f8583e23c058762a2645f" translate="yes" xml:space="preserve">
          <source>An SQLite file associates a key with some data. For an SQLite table, the database file is set up so that the key is an integer and the data is the information for one row of the table. Indices in SQLite reverse this arrangement. The index key is (some of) the information being stored and the index data is an integer. To access a table row that has some particular content, we first look up the content in the index table to find its integer index, then we use that integer to look up the complete record in the table.</source>
          <target state="translated">SQLite 파일은 키를 일부 데이터와 연관시킵니다. SQLite 테이블의 경우 데이터베이스 파일은 키가 정수이고 데이터가 테이블의 한 행에 대한 정보가되도록 설정됩니다. SQLite의 인덱스는이 배열을 반대로합니다. 인덱스 키는 저장된 정보 중 일부이며 인덱스 데이터는 정수입니다. 특정 내용이있는 테이블 행에 액세스하기 위해 먼저 인덱스 테이블에서 내용을 검색하여 정수 인덱스를 찾은 다음 해당 정수를 사용하여 테이블에서 전체 레코드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="aa48e9ca1a9afbd598f5c369c282c95ae280985d" translate="yes" xml:space="preserve">
          <source>An UPDATE change does not contain any information regarding non-PRIMARY KEY fields that are not modified by the change. It is not possible for an UPDATE change to specify modifications to PRIMARY KEY fields.</source>
          <target state="translated">UPDATE 변경에는 변경에 의해 수정되지 않은 기본이 아닌 KEY 필드에 관한 정보가 없습니다. UPDATE 변경으로 PRIMARY KEY 필드에 수정을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8453636ce12faf3a7d30b3604973de7e92b03be" translate="yes" xml:space="preserve">
          <source>An UPDATE statement is used to modify a subset of the values stored in zero or more rows of the database table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt; specified as part of the UPDATE statement.</source>
          <target state="translated">UPDATE 문은 UPDATE 문의 일부로 지정된 &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;규정 된 table-name으로&lt;/a&gt; 식별되는 데이터베이스 테이블의 0 개 이상의 행에 저장된 값의 서브 세트를 수정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4f3409a0b0e68f9dad8c3ad576c7434229cfe7d" translate="yes" xml:space="preserve">
          <source>An UPSERT is an ordinary &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that is followed by the special ON CONFLICT clause shown above.</source>
          <target state="translated">UPSERT는 일반적인 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문이며 위에 표시된 특수 ON CONFLICT 절이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="69182763d75d3decbdc8b998206e5e9e0abdd4fa" translate="yes" xml:space="preserve">
          <source>An administrator might be cleaning up after an OS crash or power failure, see the journal file, think it is junk, and delete it.</source>
          <target state="translated">OS 충돌 또는 정전 후 관리자가 정리 중일 수 있습니다. 저널 파일을보고 정크 파일이라고 생각하여 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="3394246ad7fb8330c70e24b0e7ea728a29ef0f38" translate="yes" xml:space="preserve">
          <source>An advanced &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;</source>
          <target state="translated">고급 &lt;a href=&quot;optoverview&quot;&gt;쿼리 플래너&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="911df1dfdba68c60884217edf88c5ceef73757d1" translate="yes" xml:space="preserve">
          <source>An aggregate window function is similar to an &lt;a href=&quot;lang_aggfunc&quot;&gt;ordinary aggregate function&lt;/a&gt;, except adding it to a query does not change the number of rows returned. Instead, for each row the result of the aggregate window function is as if the corresponding aggregate were run over all rows in the &quot;window frame&quot; specified by the OVER clause.</source>
          <target state="translated">집계 창 함수는 &lt;a href=&quot;lang_aggfunc&quot;&gt;일반 집계 함수&lt;/a&gt; 와 유사하지만 쿼리에 추가해도 반환되는 행 수는 변경되지 않습니다. 대신 각 행에 대해 집계 창 함수의 결과는 해당 집계가 OVER 절에 지정된 &quot;창 프레임&quot;의 모든 행에 대해 실행 된 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="322176e856e37076d444f90d3c6a55c34f3890cf" translate="yes" xml:space="preserve">
          <source>An alternate VFS can also be specified as the 4th parameter to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; function. For example:</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 함수 의 네 번째 매개 변수로 대체 VFS를 지정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41672a8dda2c83a2c98fffccfd2de6f45dfd99a9" translate="yes" xml:space="preserve">
          <source>An alternative page cache implementation is specified using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;,...).</source>
          <target state="translated">대체 페이지 캐시 구현은 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...)를 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="947c7106a30016236017e10a97e39cd6cd0c6560" translate="yes" xml:space="preserve">
          <source>An alternative page cache implementation is specified using &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;,...).</source>
          <target state="translated">대체 페이지 캐시 구현은 &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...)를 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5b04203def7bb645f2fb1f011d7be6cb15aa11" translate="yes" xml:space="preserve">
          <source>An alternative to using the VACUUM command is auto-vacuum mode, enabled using the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum pragma&lt;/a&gt;.</source>
          <target state="translated">VACUUM 명령을 사용하는 대신 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum pragma를&lt;/a&gt; 사용하여 활성화되는 자동 진공 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7c395d93d8f14379a00c98e2d82d0ba28b9997" translate="yes" xml:space="preserve">
          <source>An alternative to using the VACUUM command to reclaim space after data has been deleted is auto-vacuum mode, enabled using the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; pragma. When &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; is enabled for a database free pages may be reclaimed after deleting data, causing the file to shrink, without rebuilding the entire database using VACUUM. However, using &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; can lead to extra database file fragmentation. And &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; does not compact partially filled pages of the database as VACUUM does.</source>
          <target state="translated">VACUUM 명령을 사용하여 데이터가 삭제 된 후 공간을 회수하는 대안은 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; pragma를 사용하여 활성화 된 자동 진공 모드 입니다. 데이터베이스에서 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 을 사용하도록 설정 하면 데이터를 삭제 한 후 사용 가능한 페이지가 회수되어 VACUUM을 사용하여 전체 데이터베이스를 다시 작성하지 않고도 파일이 축소 될 수 있습니다. 그러나 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 을 사용 하면 추가 데이터베이스 파일 조각화가 발생할 수 있습니다. 그리고 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum는&lt;/a&gt; 진공처럼 데이터베이스하지 컴팩트 부분적으로 채워진 페이지를 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ded89491896af075066baeaec69132a1eb337e1" translate="yes" xml:space="preserve">
          <source>An application can also register multiple SQL functions with the same name and same number of arguments, but a different preferred text encoding. In that case, SQLite will invoke the function using the callbacks for the version whose preferred text encoding most closely matches the database text encoding. In this way, multiple implementations of the same function can be provided that are optimized for UTF8 or UTF16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="553a75a5f14c49499d0ac2492bac151d7f6d24ab" translate="yes" xml:space="preserve">
          <source>An application can initiate a checkpoint using any writable database connection on the database simply by invoking &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;. There are three subtypes of checkpoints that vary in their aggressiveness: PASSIVE, FULL, and RESTART. The default checkpoint style is PASSIVE, which does as much work as it can without interfering with other database connections, and which might not run to completion if there are concurrent readers or writers. All checkpoints initiated by &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; and by the automatic checkpoint mechanism are PASSIVE. FULL and RESTART checkpoints try harder to run the checkpoint to completion and can only be initiated by a call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;. See the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for additional information on FULL and RESET checkpoints.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 를 호출하여 데이터베이스에서 쓰기 가능한 데이터베이스 연결을 사용하여 검사 점을 시작할 수 있습니다 . 공격성에 따라 달라지는 체크 포인트에는 세 가지 하위 유형이 있습니다 : 수동, 전체 및 다시 시작. 기본 검사 점 스타일은 수동형으로, 다른 데이터베이스 연결을 방해하지 않으면 서 최대한 많은 작업을 수행하며 동시 판독기 또는 기록기가있는 경우 완료되지 않을 수 있습니다. &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; 및 자동 체크 포인트 메커니즘에 의해 시작된 모든 체크 포인트 는 수동입니다. FULL 및 RESTART 체크 포인트는 체크 포인트를 완료하기 위해 더 열심히 시도하며 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 호출로만 시작할 수 있습니다.. FULL 및 RESET 체크 포인트에 대한 추가 정보 는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b67ba81a9225f9986e5d6153b64db41fca122a2b" translate="yes" xml:space="preserve">
          <source>An application can insert layers or &quot;overlays&quot; in between the SQLite core and the underlying memory allocator. For example, the &lt;a href=&quot;#oomtesting&quot;&gt;out-of-memory test logic&lt;/a&gt; for SQLite uses an overlay that can simulate memory allocation failures.</source>
          <target state="translated">응용 프로그램은 SQLite 코어와 기본 메모리 할당 자 사이에 계층 또는 &quot;오버레이&quot;를 삽입 할 수 있습니다. 예를 들어, SQLite에 대한 &lt;a href=&quot;#oomtesting&quot;&gt;메모리 부족 테스트 로직&lt;/a&gt; 은 메모리 할당 실패를 시뮬레이션 할 수있는 오버레이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c388b93196430467345107651fd79645679ae7e0" translate="yes" xml:space="preserve">
          <source>An application can register additional collating functions using the &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; 인터페이스를 사용하여 추가 조합 기능을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83af746376d0381ac294352b72f5044bc5a90aa4" translate="yes" xml:space="preserve">
          <source>An application is allowed to prepare multiple SQL statements in advance and evaluate them as needed. There is no arbitrary limit to the number of outstanding &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Some applications call &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; multiple times at start-up to create all of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; they will ever need. Other applications keep a cache of the most recently used &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; and then reuse &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; out of the cache when available. Another approach is to only reuse &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; when they are inside of a loop.</source>
          <target state="translated">응용 프로그램은 여러 SQL 문을 미리 준비하고 필요에 따라 평가할 수 있습니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 준비된 명령문&lt;/a&gt; 수에는 임의의 제한이 없습니다 . 일부 응용 프로그램 은 시작할 때 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()를&lt;/a&gt; 여러 번 호출 하여 필요한 모든 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 작성 합니다. 다른 응용 프로그램은 가장 최근에 사용한 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 의 캐시를 유지 한 다음 사용 가능한 경우 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 캐시에서 재사용 합니다. 또 다른 접근법은 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 루프 내부에있을 때만 재사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70a715c74846889076e9d1ad5301c64640567bdc" translate="yes" xml:space="preserve">
          <source>An application program could do all its disk I/O by direct calls to operating system I/O routines or by using a key/value storage engine like &lt;a href=&quot;https://en.wikipedia.org/wiki/Berkeley_DB&quot;&gt;Berkeley DB&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/RocksDB&quot;&gt;RocksDB&lt;/a&gt; (to name but two). But there are advantages to using a higher-level interface based on the SQL language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f92c3ae91ceb152b4ca7b440a380181cc47f0d" translate="yes" xml:space="preserve">
          <source>An application will typically use &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; during initialization. Note that &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; can be used to either open existing database files or to create and open new database files. While many applications use only a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, there is no reason why an application cannot call &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; multiple times in order to open multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; - either to the same database or to different databases. Sometimes a multi-threaded application will create separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; for each thread. Note that a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; can access two or more databases using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command, so it is not necessary to have a separate database connection for each database file.</source>
          <target state="translated">애플리케이션은 일반적으로 초기화 중에 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 을 사용하여 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 작성합니다 . 참고 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 중 하나를 열고 기존 데이터베이스 파일을 사용하거나 생성하고 열린 새 데이터베이스 파일을 할 수 있습니다. 많은 응용 프로그램이 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 만 사용하지만 동일한 데이터베이스 나 다른 데이터베이스에 대한 여러 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 열기 위해 응용 프로그램이 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()을&lt;/a&gt; 여러 번 호출 할 수없는 이유는 없습니다 . 때때로 다중 스레드 응용 프로그램은 각 스레드에 대해 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 작성 합니다. 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL 명령을 사용하여 둘 이상의 데이터베이스에 액세스 할 수 있으므로 각 데이터베이스 파일에 대해 별도의 데이터베이스 연결이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad0ed6ebbb2c20729bbba2c61a375d2fc0e59a68" translate="yes" xml:space="preserve">
          <source>An application-defined function is permitted to call other SQLite interfaces. However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running.</source>
          <target state="translated">응용 프로그램 정의 함수는 다른 SQLite 인터페이스를 호출 할 수 있습니다. 그러나 이러한 호출은 데이터베이스 연결을 닫거나 함수가 실행중인 준비된 명령문을 마무리하거나 재설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="368a116479c83bd78621f71906b14ee39f5af37e" translate="yes" xml:space="preserve">
          <source>An arbitrary length BLOB</source>
          <target state="translated">임의의 길이 BLOB</target>
        </trans-unit>
        <trans-unit id="f821dc4d7f9c71f0ab35cc4c36d94a5e6e1a02bc" translate="yes" xml:space="preserve">
          <source>An arbitrary length strings</source>
          <target state="translated">임의의 길이 문자열</target>
        </trans-unit>
        <trans-unit id="232575a5b7dcf96eebb74b1c36e1cd9952456a1f" translate="yes" xml:space="preserve">
          <source>An argument with SQL type TEXT it is normally converted into a quoted JSON string even if the input text is well-formed JSON. However, if the argument is the direct result from another json1 function, then it is treated as JSON and all of its JSON type information and substructure is preserved. This allows calls to json_object() and &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; to be nested. The &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; function can also be used to force strings to be recognized as JSON.</source>
          <target state="translated">SQL 유형이 TEXT 인 인수는 입력 텍스트가 올바른 형식의 JSON 인 경우에도 일반적으로 인용 된 JSON 문자열로 변환됩니다. 그러나 인수가 다른 json1 함수의 직접적인 결과 인 경우 JSON으로 처리되며 모든 JSON 유형 정보 및 하위 구조가 유지됩니다. 이를 통해 json_object () 및 &lt;a href=&quot;json1#jarray&quot;&gt;json_array ()에&lt;/a&gt; 대한 호출을 중첩 할 수 있습니다. &lt;a href=&quot;json1#jmini&quot;&gt;JSON ()&lt;/a&gt; 함수는 힘 문자열로 사용할 수는 JSON으로 인식한다.</target>
        </trans-unit>
        <trans-unit id="ba3098d8640bbb6ff43023d4a4dc7ae39f23e7f1" translate="yes" xml:space="preserve">
          <source>An argument with SQL type TEXT it is normally converted into a quoted JSON string. However, if the argument is the output from another json1 function, then it is stored as JSON. This allows calls to json_array() and &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt; to be nested. The &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; function can also be used to force strings to be recognized as JSON.</source>
          <target state="translated">SQL 유형이 TEXT 인 인수는 일반적으로 따옴표로 묶인 JSON 문자열로 변환됩니다. 그러나 인수가 다른 json1 함수의 출력 인 경우 JSON으로 저장됩니다. 이를 통해 json_array () 및 &lt;a href=&quot;json1#jobj&quot;&gt;json_object ()에&lt;/a&gt; 대한 호출을 중첩 할 수 있습니다. &lt;a href=&quot;json1#jmini&quot;&gt;JSON ()&lt;/a&gt; 함수는 힘 문자열로 사용할 수는 JSON으로 인식한다.</target>
        </trans-unit>
        <trans-unit id="c4806a509e481529fa2b28682facfc05b551794d" translate="yes" xml:space="preserve">
          <source>An assert() statement is often used to validate pre-conditions on internal functions and methods. Example: &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&lt;/a&gt;. This is deemed better than simply stating the pre-condition in a header comment, since the assert() is actually executed. In a highly tested program like SQLite, the reader knows that the pre-condition is true for all of the hundreds of millions of test cases run against SQLite, since it has been verified by the assert(). In contrast, a text pre-condition statement in a header comment is untested. It might have been true when the code was written, but who is to say that it is still true now?</source>
          <target state="translated">assert () 문은 종종 내부 함수 및 메서드에 대한 사전 조건을 확인하는 데 사용됩니다. 예 : &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&lt;/a&gt; . assert ()가 실제로 실행되기 때문에 헤더 주석에 사전 조건을 명시하는 것보다 낫습니다. SQLite와 같이 고도로 테스트 된 프로그램에서 독자는 assert ()에 의해 검증되었으므로 SQLite에 대해 실행 된 수억 개의 모든 테스트 사례에 대해 사전 조건이 참임을 알고 있습니다. 대조적으로, 헤더 주석의 텍스트 사전 조건문은 테스트되지 않습니다. 코드가 작성되었을 때 사실 이었을지 모르지만, 지금은 여전히 ​​사실이라고 말하는 사람은 누구입니까?</target>
        </trans-unit>
        <trans-unit id="734aa331fcaf7e910bbd2120afae3cf5a122f2fd" translate="yes" xml:space="preserve">
          <source>An assertion fails if P2 is not an integer.</source>
          <target state="translated">P2가 정수가 아닌 경우 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f4d9c6c8e0b518f22e195d912f6aa5b7d1dd73a5" translate="yes" xml:space="preserve">
          <source>An atomic commit is supposed to happen instantaneously. But the processing described above clearly takes a finite amount of time. Suppose the power to the computer were cut part way through the commit operation described above. In order to maintain the illusion that the changes were instantaneous, we have to &quot;rollback&quot; any partial changes and restore the database to the state it was in prior to the beginning of the transaction.</source>
          <target state="translated">원자 커밋은 즉시 발생합니다. 그러나 위에서 설명한 처리에는 분명히 시간이 걸립니다. 위에서 설명한 커밋 작업을 통해 컴퓨터의 전원이 일부 차단되었다고 가정합니다. 변경 사항이 즉시 발생했다는 착각을 유지하려면 부분 변경 내용을 &quot;롤백&quot;하고 데이터베이스를 트랜잭션 시작 이전 상태로 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="e11c0c4803807d87c78fdeba64f0dde4ba44fbdd" translate="yes" xml:space="preserve">
          <source>An attempt is made to upgrade to an</source>
          <target state="translated">에 업그레이드를 시도합니다</target>
        </trans-unit>
        <trans-unit id="404254ba0f2702898e820a78567011f727d4bb51" translate="yes" xml:space="preserve">
          <source>An attempt to execute COMMIT might also result in an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; return code if an another thread or process has an open read connection. When COMMIT fails in this way, the transaction remains active and the COMMIT can be retried later after the reader has had a chance to clear.</source>
          <target state="translated">다른 스레드 또는 프로세스에 열린 읽기 연결이있는 경우 COMMIT를 실행하면 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 리턴 코드 가 발생할 수도 있습니다 . COMMIT가 이런 방식으로 실패하면 트랜잭션은 활성 상태로 유지되며 독자가 지울 수있는 기회가 나중에 COMMIT를 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3979550223b90497821c0aba7295ef97c7b65e0d" translate="yes" xml:space="preserve">
          <source>An attempt to read from an expired &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;.</source>
          <target state="translated">만료 된 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 읽기 시도가 오류 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="79d2f9e7d226af948b651170c9b5bffda6c6a847" translate="yes" xml:space="preserve">
          <source>An attempt to read from an expired &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;.</source>
          <target state="translated">만료 된 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 읽기 시도가 오류 코드 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="c063fe576f329d251937e5f31d7607dcdb3d3ae3" translate="yes" xml:space="preserve">
          <source>An attempt to write to an expired &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Writes to the BLOB that occurred before the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.</source>
          <target state="translated">만료 된 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에 쓰려는 시도 는 오류 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT로&lt;/a&gt; 실패합니다 . &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들이&lt;/a&gt; 만기 되기 전에 발생한 BLOB에 대한 쓰기 는 핸들 만기에 의해 롤백되지는 않지만 BLOB 핸들이 만기 된 명령문이나 다른 독립 명령문에 의해 변경 사항이 겹쳐 써질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75bfad8795848d7c6435b7cbd7f5aec468cc1527" translate="yes" xml:space="preserve">
          <source>An attempt to write to an expired &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Writes to the BLOB that occurred before the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.</source>
          <target state="translated">만료 된 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에 쓰려는 시도 는 오류 코드 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT로&lt;/a&gt; 실패합니다 . &lt;a href=&quot;blob&quot;&gt;BLOB 핸들이&lt;/a&gt; 만기 되기 전에 발생한 BLOB에 대한 쓰기 는 핸들 만기에 의해 롤백되지는 않지만 BLOB 핸들이 만기 된 명령문이나 다른 독립 명령문에 의해 변경 사항이 겹쳐 써질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad76d49804b0b58fd84332ca5a84e267894c91f" translate="yes" xml:space="preserve">
          <source>An authorizer is used when &lt;a href=&quot;#sqlite3_prepare&quot;&gt;preparing&lt;/a&gt; SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database. For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database. But the application does not want the user to be able to make arbitrary changes to the database. An authorizer could then be put in place while the user-entered SQL is being &lt;a href=&quot;#sqlite3_prepare&quot;&gt;prepared&lt;/a&gt; that disallows everything except &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements.</source>
          <target state="translated">권한 부여자는 신뢰할 수없는 소스에서 SQL 문을 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;준비&lt;/a&gt; 할 때 SQL 문이 볼 수없는 데이터에 액세스하지 않거나 데이터베이스를 손상시키는 악의적 인 명령문을 실행하지 않도록하기 위해 사용됩니다. 예를 들어, 응용 프로그램을 통해 사용자는 데이터베이스에 의한 평가를 위해 임의의 SQL 쿼리를 입력 할 수 있습니다. 그러나 응용 프로그램은 사용자가 데이터베이스를 임의로 변경할 수 있기를 원하지 않습니다. 그런 다음 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 제외한 모든 항목을 허용하지 않는 사용자가 입력 한 SQL을 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;준비&lt;/a&gt; 하는 동안 권한 부여자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1e075e878ae45a376fd2939c290edbd89e855bf" translate="yes" xml:space="preserve">
          <source>An authorizer is used when &lt;a href=&quot;prepare&quot;&gt;preparing&lt;/a&gt; SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database. For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database. But the application does not want the user to be able to make arbitrary changes to the database. An authorizer could then be put in place while the user-entered SQL is being &lt;a href=&quot;prepare&quot;&gt;prepared&lt;/a&gt; that disallows everything except &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statements.</source>
          <target state="translated">권한 부여자는 신뢰할 수없는 소스에서 SQL 문을 &lt;a href=&quot;prepare&quot;&gt;준비&lt;/a&gt; 할 때 SQL 문이 볼 수없는 데이터에 액세스하지 않거나 데이터베이스를 손상시키는 악의적 인 명령문을 실행하지 않도록하기 위해 사용됩니다. 예를 들어, 응용 프로그램을 통해 사용자는 데이터베이스에 의한 평가를 위해 임의의 SQL 쿼리를 입력 할 수 있습니다. 그러나 응용 프로그램은 사용자가 데이터베이스를 임의로 변경할 수 있기를 원하지 않습니다. 그런 다음 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 제외한 모든 항목을 허용하지 않는 사용자가 입력 한 SQL을 &lt;a href=&quot;prepare&quot;&gt;준비&lt;/a&gt; 하는 동안 권한 부여자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c5a8d89ce83a2b735008709c97144e7c8447c49" translate="yes" xml:space="preserve">
          <source>An automatic index might also be used for a subquery:</source>
          <target state="translated">하위 쿼리에도 자동 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a27a69d5289ec3895fe5350ae755b86c8341fcb" translate="yes" xml:space="preserve">
          <source>An encoded FTS varint consumes between one and ten bytes of space. The number of bytes required is determined by the sign and magnitude of the integer value encoded. More accurately, the number of bytes used to store the encoded integer depends on the position of the most significant set bit in the 64-bit twos-complement representation of the integer value. Negative values always have the most significant bit set (the sign bit), and so are always stored using the full ten bytes. Positive integer values may be stored using less space.</source>
          <target state="translated">인코딩 된 FTS varint는 1에서 10 바이트 사이의 공간을 소비합니다. 필요한 바이트 수는 인코딩 된 정수 값의 부호와 크기에 의해 결정됩니다. 보다 정확하게는, 인코딩 된 정수를 저장하는데 사용 된 바이트 수는 정수 값의 64 비트 2 보수 표현에서 가장 중요한 세트 비트의 위치에 의존한다. 음수 값은 항상 최상위 비트 세트 (부호 비트)를 가지므로 항상 전체 10 바이트를 사용하여 저장됩니다. 더 적은 공간을 사용하여 양의 정수 값이 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23566adaf44732949e813db81dd7b604df6839d5" translate="yes" xml:space="preserve">
          <source>An ending frame boundary,</source>
          <target state="translated">끝 프레임 경계</target>
        </trans-unit>
        <trans-unit id="9b7f16750f7735a9bc64b3d85d026914564b32de" translate="yes" xml:space="preserve">
          <source>An error is now returned when trying to start a transaction if another transaction is already active.</source>
          <target state="translated">다른 트랜잭션이 이미 활성화 된 경우 트랜잭션을 시작하려고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6742ab14c7e1b0f89ab6e50a3f4d9ccb4760cbd" translate="yes" xml:space="preserve">
          <source>An error logger callback is invoked on SQLITE_MISUSE errors. This is useful in detecting application design issues when return codes are not consistently checked in the application code.</source>
          <target state="translated">오류 로그 작성기 콜백은 SQLITE_MISUSE 오류에서 호출됩니다. 이는 애플리케이션 코드에서 리턴 코드가 일관되게 확인되지 않은 경우 애플리케이션 설계 문제를 감지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e57ea0e26c7c063563f7c480ba3dfeaecea3cb15" translate="yes" xml:space="preserve">
          <source>An error. &quot;darkstar&quot; is not a recognized authority.</source>
          <target state="translated">오류입니다. &quot;darkstar&quot;는 공인 된 기관이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a9d782005fc023f48e522001d78e4867344c8d47" translate="yes" xml:space="preserve">
          <source>An error. &quot;readonly&quot; is not a valid option for the &quot;mode&quot; parameter.</source>
          <target state="translated">오류입니다. &quot;readonly&quot;는 &quot;mode&quot;매개 변수에 유효한 옵션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c1dc1f3ba0806333fcf879ed6122522e9f542e04" translate="yes" xml:space="preserve">
          <source>An example of an eponymous virtual table is the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. To use the dbstat virtual table as an eponymous virtual table, simply query against the &quot;dbstat&quot; module name, as if it were an ordinary table. (Note that SQLite must be compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option to include the dbstat virtual table in the build.)</source>
          <target state="translated">&lt;a href=&quot;dbstat&quot;&gt;시상 가상 테이블&lt;/a&gt; 의 예는 dbstat 가상 테이블 입니다. dbstat 가상 테이블을 동일한 가상 테이블로 사용하려면 일반 테이블 인 것처럼 &quot;dbstat&quot;모듈 이름을 쿼리하면됩니다. ( 빌드에 dbstat 가상 테이블을 포함 시키려면 SQLite를 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; 옵션 으로 컴파일해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="d551629b2a32e687e6920a81c2f515bee137ebdf" translate="yes" xml:space="preserve">
          <source>An example use of hidden columns can be seen in the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; virtual table implementation, where every FTS virtual table contains an &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; that is used to pass information from the virtual table into &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt; and to the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator.</source>
          <target state="translated">숨겨진 열의 사용 예는 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 가상 테이블 구현 에서 확인할 수 있습니다 . 여기서 모든 FTS 가상 테이블에는 가상 테이블의 정보를 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 함수&lt;/a&gt; 및 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; 연산자 로 전달하는 데 사용되는 &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열&lt;/a&gt; 이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e17bf1221a1fb0282388819bb91b8a5c6ed013a" translate="yes" xml:space="preserve">
          <source>An example will help to clarify this concept. Consider the following query:</source>
          <target state="translated">예를 들어이 개념을 명확히하는 데 도움이됩니다. 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0b97feb4054b223de8848c552e7e62e2eeabb327" translate="yes" xml:space="preserve">
          <source>An example: Suppose there are two database connections X and Y. X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; followed by one or more &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Then Y comes along and runs an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement to modify the database. X can subsequently do a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; against the records that Y modified but X will see the older unmodified entries because Y's changes are all invisible to X while X is holding a read transaction. If X wants to see the changes that Y made, then X must ends its read transaction and start a new one (by running &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; followed by another &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.)</source>
          <target state="translated">예 : 두 개의 데이터베이스 연결 X와 Y가 있다고 가정하십시오. X는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN을&lt;/a&gt; 사용하여 읽기 트랜잭션을 시작하고 하나 이상의 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 시작합니다. 그런 다음 Y가 와서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 하여 데이터베이스를 수정합니다. X는 나중에 Y가 수정 한 레코드에 대해 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 를 수행 할 수 있지만 X가 읽기 트랜잭션을 보유하는 동안 Y의 변경 사항이 모두 X에 표시되지 않기 때문에 X는 수정되지 않은 이전 항목을 볼 수 있습니다. X가 Y의 변경 사항을보고자하는 경우, X는 읽기 트랜잭션을 종료하고 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 를 실행 한 후 다른 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 을 실행하여 새 트랜잭션을 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b6e6d373bf06dd9c8c05c43eca6f2690b8f93a5" translate="yes" xml:space="preserve">
          <source>An exclusive lock is held on WAL_WRITE_LOCK while adding new frame onto the end of a WAL file.</source>
          <target state="translated">WAL 파일 끝에 새 프레임을 추가하는 동안 WAL_WRITE_LOCK에 독점 잠금이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="472410dd7fa81690261e9f1011036ea0cbeb522e" translate="yes" xml:space="preserve">
          <source>An experimental module providing on-demand read-only access to multiple tables spread across multiple databases, via a single virtual table abstraction.</source>
          <target state="translated">여러 테이블에 대한 주문형 읽기 전용 액세스를 제공하는 실험 모듈은 단일 가상 테이블 추상화를 통해 여러 데이터베이스에 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="667c5b4834a03d379059f491edab75c439a88d3e" translate="yes" xml:space="preserve">
          <source>An expression of the form &quot;CAST(</source>
          <target state="translated">&quot;CAST (</target>
        </trans-unit>
        <trans-unit id="818ecb03985da596f3eae278c34f7853ab10690e" translate="yes" xml:space="preserve">
          <source>An external content FTS4 table is created by setting the content option to the name of a table (or view, or virtual table) that may be queried by FTS4 to retrieve column values when required. If the nominated table does not exist, then an external content table behaves in the same way as a contentless table. For example:</source>
          <target state="translated">외부 옵션 FTS4 테이블은 content 옵션을 필요한 경우 열 값을 검색하기 위해 FTS4에 의해 조회 될 수있는 테이블 (또는 뷰 또는 가상 테이블)의 이름으로 설정하여 작성됩니다. 지명 된 테이블이 존재하지 않으면 외부 컨텐츠 테이블은 컨텐츠가없는 테이블과 동일한 방식으로 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2af47edb4534251424ba986a5ead5c83306505ff" translate="yes" xml:space="preserve">
          <source>An external content FTS5 table is created by setting the content option to the name of a table, virtual table or view (hereafter the &quot;content table&quot;) within the same database. Whenever column values are required by FTS5, it queries the content table as follows, with the rowid of the row for which values are required bound to the SQL variable:</source>
          <target state="translated">외부 데이터베이스 FTS5 테이블은 컨텐츠 옵션을 동일한 데이터베이스 내에서 테이블, 가상 테이블 또는 뷰 (이하 &quot;컨텐츠 테이블&quot;)의 이름으로 설정하여 작성됩니다. FTS5에서 열 값이 필요할 때마다 값이 필요한 행의 rowid를 SQL 변수에 바인딩하여 다음과 같이 컨텐츠 테이블을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="d52b102f266b0f6f1ccf383a15555d761fab3f49" translate="yes" xml:space="preserve">
          <source>An fts4aux virtual table is constructed with one or two arguments. When used with a single argument, that argument is the unqualified name of the FTS table that it will be used to access. To access a table in a different database (for example, to create a TEMP fts4aux table that will access an FTS3 table in the MAIN database) use the two-argument form and give the name of the target database (ex: &quot;main&quot;) in the first argument and the name of the FTS3/4 table as the second argument. (The two-argument form of fts4aux was added for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20) and will throw an error in prior releases.) For example:</source>
          <target state="translated">fts4aux 가상 테이블은 하나 또는 두 개의 인수로 구성됩니다. 단일 인수와 함께 사용되는 경우 해당 인수는 액세스하는 데 사용될 FTS 테이블의 규정되지 않은 이름입니다. 다른 데이터베이스의 테이블에 액세스하려면 (예를 들어, MAIN 데이터베이스의 FTS3 테이블에 액세스하는 TEMP fts4aux 테이블 작성) 두 인수 형식을 사용하고 대상 데이터베이스의 이름을 지정하십시오 (예 : &quot;main&quot;). 첫 번째 인수에서 FTS3 / 4 테이블의 이름을 두 번째 인수로 사용하십시오. (fts4aux의 두 인수 형식은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20) 용으로 추가 되었으며 이전 릴리스에서 오류가 발생합니다.) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c25046031c36326ccd0fd6dd82951cf50be0673" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;col&quot; contains one row for each distinct term/column combination in the associated FTS5 table. Table columns are as follows:</source>
          <target state="translated">&quot;col&quot;유형의 fts5vocab 테이블에는 연관된 FTS5 테이블의 각 고유 용어 / 열 조합에 대해 하나의 행이 포함됩니다. 테이블 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f04198cf656fcfcd60de51b84883a5a273fb8d3" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;instance&quot; contains one row for each term instance stored in the associated FTS index. Assuming the FTS5 table is created with the 'detail' option set to 'full', table columns are as follows:</source>
          <target state="translated">&quot;인스턴스&quot;유형의 fts5vocab 테이블에는 연관된 FTS 인덱스에 저장된 각 용어 인스턴스에 대해 하나의 행이 포함됩니다. FTS5 테이블이 'detail'옵션을 'full'로 설정하여 작성한다고 가정하면 테이블 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4f46cd06dd0edb512dbfe5bb420f25b92508728" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;row&quot; contains one row for each distinct term in the associated FTS5 table. The table columns are as follows:</source>
          <target state="translated">&quot;row&quot;유형의 fts5vocab 테이블에는 연관된 FTS5 테이블의 각 고유 용어에 대해 하나의 행이 포함됩니다. 테이블 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23fad742c743a6de68a81185ed3aba6fc3fafba0" translate="yes" xml:space="preserve">
          <source>An identifier for a table or column or variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e5d44e56062277710f5511afeab18594a8851fc" translate="yes" xml:space="preserve">
          <source>An implementation of the Guttmann R*Tree spatial index idea.</source>
          <target state="translated">Guttmann R * Tree 공간 인덱스 아이디어의 구현.</target>
        </trans-unit>
        <trans-unit id="4bd28b3c3d3e6a39cb2320865c316342a20f3142" translate="yes" xml:space="preserve">
          <source>An implicit transaction (a transaction that is started automatically, not a transaction started by BEGIN) is committed automatically when the last active statement finishes. A statement finishes when its last cursor closes, which is guaranteed to happen when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;. Some statements might &quot;finish&quot; for the purpose of transaction control prior to being reset or finalized, but there is no guarantee of this. The only way to ensure that a statement has &quot;finished&quot; is to invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; on that statement. An open &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; used for incremental BLOB I/O also counts as an unfinished statement. The &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; finishes when it is &lt;a href=&quot;c3ref/blob_close&quot;&gt;closed&lt;/a&gt;.</source>
          <target state="translated">내재 된 트랜잭션 (BEGIN에 의해 ​​시작된 트랜잭션이 아닌 자동으로 시작된 트랜잭션)은 마지막 활성 명령문이 완료 될 때 자동으로 커미트됩니다. 명령문은 마지막 커서가 닫히면 완료되며 준비된 명령문이 &lt;a href=&quot;c3ref/reset&quot;&gt;재설정&lt;/a&gt; 되거나 &lt;a href=&quot;c3ref/finalize&quot;&gt;완료&lt;/a&gt; 될 때 발생합니다 . 일부 명령문은 재설정 또는 완료되기 전에 트랜잭션 제어를 목적으로 &quot;완료&quot;될 수 있지만이를 보증하지는 않습니다. 명령문이 &quot;완료&quot;되었는지 확인하는 유일한 방법은 해당 명령문에서 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 를 호출 하는 것입니다. 증분 BLOB I / O에 사용 되는 열린 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 도 완료되지 않은 명령문으로 계산됩니다. &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;&lt;a href=&quot;c3ref/blob_close&quot;&gt;닫히면&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="79074d6687b22dc4e17257f4e6cee62c251811c4" translate="yes" xml:space="preserve">
          <source>An important feature of transactional databases like SQLite is &quot;atomic commit&quot;. Atomic commit means that either all database changes within a single transaction occur or none of them occur. With atomic commit, it is as if many different writes to different sections of the database file occur instantaneously and simultaneously. Real hardware serializes writes to mass storage, and writing a single sector takes a finite amount of time. So it is impossible to truly write many different sectors of a database file simultaneously and/or instantaneously. But the atomic commit logic within SQLite makes it appear as if the changes for a transaction are all written instantaneously and simultaneously.</source>
          <target state="translated">SQLite와 같은 트랜잭션 데이터베이스의 중요한 기능은 &quot;원자 커밋&quot;입니다. 원자 커밋은 단일 트랜잭션 내에서 모든 데이터베이스 변경이 발생하거나 전혀 수행되지 않음을 의미합니다. 원자 커밋을 사용하면 데이터베이스 파일의 다른 섹션에 대한 많은 다른 쓰기가 순간적으로 동시에 발생하는 것과 같습니다. 실제 하드웨어는 대량 스토리지에 대한 쓰기를 직렬화하며 단일 섹터를 작성하는 데는 시간이 걸립니다. 따라서 데이터베이스 파일의 여러 섹터를 동시에 또는 즉시 작성하는 것은 불가능합니다. 그러나 SQLite 내의 원자 커밋 논리는 마치 트랜잭션에 대한 변경 사항이 모두 동시에 동시에 작성되는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="52bb5c1058e3b07cc3eb83a0aae8a367e19c8fb8" translate="yes" xml:space="preserve">
          <source>An imposter table is a table that is attached to the same &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree&lt;/a&gt; as an index. An imposter table allows the content of an index to be queried or modified as if the index were an ordinary table.</source>
          <target state="translated">임 포스터 테이블은 인덱스 와 동일한 &lt;a href=&quot;fileformat2#btree&quot;&gt;b- 트리에&lt;/a&gt; 연결된 테이블입니다 . 임 포스터 테이블을 사용하면 인덱스가 일반 테이블 인 것처럼 인덱스의 내용을 쿼리하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548d97f9737c13966b0384ddf7c4f5316897fe64" translate="yes" xml:space="preserve">
          <source>An index b-tree interior page</source>
          <target state="translated">인덱스 b- 트리 내부 페이지</target>
        </trans-unit>
        <trans-unit id="75b00cd2ffa8d152bd911781465eeda8179c5b9f" translate="yes" xml:space="preserve">
          <source>An index b-tree leaf page</source>
          <target state="translated">인덱스 b- 트리 리프 페이지</target>
        </trans-unit>
        <trans-unit id="a23b6e554c4c927f47667a50d9e483703c1ef47e" translate="yes" xml:space="preserve">
          <source>An index is another table similar to the original &quot;fruitsforsale&quot; table but with the content (the fruit column in this case) stored in front of the rowid and with all rows in content order. &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; gives a logical view of the Idx1 index. The &quot;fruit&quot; column is the primary key used to order the elements of the table and the &quot;rowid&quot; is the secondary key used to break the tie when two or more rows have the same &quot;fruit&quot;. In the example, the rowid has to be used as a tie-breaker for the &quot;Orange&quot; rows. Notice that since the rowid is always unique over all elements of the original table, the composite key of &quot;fruit&quot; followed by &quot;rowid&quot; will be unique over all elements of the index.</source>
          <target state="translated">인덱스는 원래 &quot;fruitsforsale&quot;테이블과 유사하지만 rowid 앞에 내용 (이 경우 과일 열)이 있고 모든 행이 내용 순서로있는 다른 테이블입니다. &lt;a href=&quot;#fig4&quot;&gt;그림 4&lt;/a&gt; 는 Idx1 인덱스의 논리적 뷰입니다. &quot;fruit&quot;열은 테이블 요소를 정렬하는 데 사용되는 기본 키이고 &quot;rowid&quot;는 둘 이상의 행에 동일한 &quot;fruit&quot;가있을 때 연결을 끊는 데 사용되는 보조 키입니다. 이 예에서 rowid는 &quot;Orange&quot;행의 타이 브레이커로 사용해야합니다. rowid는 원래 테이블의 모든 요소에서 항상 고유하므로 &quot;fruit&quot;의 복합 키와 &quot;rowid&quot;는 인덱스의 모든 요소에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="3002819a06b87f2b28823dffe3c0b248534f6bf1" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="translated">스냅 샷 오브젝트의 인스턴스는 특정 히스토리 포인트에 대한 &lt;a href=&quot;../wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 의 상태를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ddc9cd2833d461982fd05cbb236027102f78db05" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="translated">스냅 샷 오브젝트의 인스턴스는 특정 히스토리 포인트에 대한 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 의 상태를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="0ad16796bc17d538460c93b836ae5c8477d8c7e2" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_str object contains a dynamically-sized string under construction.</source>
          <target state="translated">sqlite3_str 객체의 인스턴스에는 생성중인 동적 크기 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8f02269b16b7995873f0e98891ae8060c34bc231" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;../vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="translated">sqlite3_vfs 객체의 인스턴스는 SQLite 코어와 기본 운영 체제 간의 인터페이스를 정의합니다. 객체 이름의 &quot;vfs&quot;는 &quot;가상 파일 시스템&quot;을 나타냅니다. 자세한 내용은 &lt;a href=&quot;../vfs&quot;&gt;VFS 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="986d34aa72070b33f262aa39aa661f9a7021ae8a" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="translated">sqlite3_vfs 객체의 인스턴스는 SQLite 코어와 기본 운영 체제 간의 인터페이스를 정의합니다. 객체 이름의 &quot;vfs&quot;는 &quot;가상 파일 시스템&quot;을 나타냅니다. 자세한 내용은 &lt;a href=&quot;vfs&quot;&gt;VFS 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f45b93bef69dcf39c21d4d46704ba221d046f871" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="translated">이 객체의 인스턴스는 &lt;a href=&quot;../sessionintro#changeset&quot;&gt;변경 &lt;/a&gt;&lt;a href=&quot;../sessionintro#changeset&quot;&gt;세트&lt;/a&gt; 또는 패치 세트 의 요소를 반복하기위한 커서 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="bf71b1083943f3e5851ab7a42bcd920407783dbc" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="translated">이 객체의 인스턴스는 &lt;a href=&quot;sessionintro#changeset&quot;&gt;변경 &lt;/a&gt;&lt;a href=&quot;sessionintro#changeset&quot;&gt;세트&lt;/a&gt; 또는 패치 세트 의 요소를 반복하기위한 커서 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="ab7e618ccd27967f90c1e650a28d3404240080d5" translate="yes" xml:space="preserve">
          <source>An instance of this object defines the interface between SQLite and low-level memory allocation routines.</source>
          <target state="translated">이 객체의 인스턴스는 SQLite와 저수준 메모리 할당 루틴 간의 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a3b65debab7d2bc5f3be01481bf018b30e5f1a63" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;../sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="translated">이 객체의 인스턴스 는 데이터베이스의 변경 사항을 기록하는 데 사용할 수 있는 &lt;a href=&quot;../sessionintro&quot;&gt;세션&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d288e209f1c35236167d79cd8408a6e6645c8dfe" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="translated">이 객체의 인스턴스 는 데이터베이스의 변경 사항을 기록하는 데 사용할 수 있는 &lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a8cd868b7a8f02ee212f8081b22f84902c700f2" translate="yes" xml:space="preserve">
          <source>An instance of this object represents a single SQL statement that has been compiled into binary form and is ready to be evaluated.</source>
          <target state="translated">이 개체의 인스턴스는 이진 형식으로 컴파일되어 평가할 준비가 된 단일 SQL 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6ac15740a5e0d955ec96459bba2b236546957815" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="translated">이 오브젝트의 인스턴스는 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;증분 BLOB I / O&lt;/a&gt; 를 수행 할 수 있는 개방 BLOB를 나타냅니다 . 이 유형의 객체에 의해 생성되어 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()에&lt;/a&gt; 의해 소멸 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;() sqlite3_blob_close&lt;/a&gt; . &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 인터페이스는 BLOB 작은 소단원 판독 또는 기록하기 위해 사용될 수있다. &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes는 ()&lt;/a&gt; 인터페이스는 바이트 BLOB의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3e12c7941ae7ce9acfd3af6cea2f4a94a2e0d5a" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="translated">이 오브젝트의 인스턴스는 &lt;a href=&quot;blob_open&quot;&gt;증분 BLOB I / O&lt;/a&gt; 를 수행 할 수 있는 개방 BLOB를 나타냅니다 . 이 유형의 객체에 의해 생성되어 &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()에&lt;/a&gt; 의해 소멸 &lt;a href=&quot;blob_close&quot;&gt;() sqlite3_blob_close&lt;/a&gt; . &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 인터페이스는 BLOB 작은 소단원 판독 또는 기록하기 위해 사용될 수있다. &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes는 ()&lt;/a&gt; 인터페이스는 바이트 BLOB의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9c5d268a10fe06a59e3c7e963d5ed29fc68438c" translate="yes" xml:space="preserve">
          <source>An instance of this structure defines the low-level routines used to allocate and use mutexes.</source>
          <target state="translated">이 구조의 인스턴스는 뮤텍스를 할당하고 사용하는 데 사용되는 하위 수준 루틴을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7b02932da3aaeca2f83c028e321d42447d0835b5" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to read the text from. Columns are numbered from left to right starting at zero.</source>
          <target state="translated">텍스트를 읽을 FTS 테이블 열의 인덱스를 나타내는 정수입니다. 열은 0부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="c23d5e6e7614ceb92ef3b6de48759bd54ba26b48" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to select the returned text from. Columns are numbered from left to right starting at zero. A negative value indicates that the column should be automatically selected.</source>
          <target state="translated">반환 된 텍스트를 선택할 FTS 테이블 열의 인덱스를 나타내는 정수입니다. 열은 0부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨집니다. 음수 값은 열을 자동으로 선택해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c886c068ec97375a0540464685cf9e1ef166d731" translate="yes" xml:space="preserve">
          <source>An intensively used low-level library like SQLite needs to be fast. (And SQLite is fast, see &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; for example.)</source>
          <target state="translated">SQLite와 같이 집중적으로 사용되는 저수준 라이브러리는 빨라야합니다. (그리고 SQLite는 빠르다 . 예를 들어 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;외부 BLOB&lt;/a&gt; 와 내부 및 &lt;a href=&quot;fasterthanfs&quot;&gt;파일 시스템보다 35 % 더 빠름&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="02b10fc85927484bbd1851b4c4f858fb308385eb" translate="yes" xml:space="preserve">
          <source>An iterator is deleted using a call to the &lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt; API. If an error occured while iterating, an SQLite error code is returned (even if the same error code has already been returned by sqlite3changeset_next()). Or, if no error has occurred, SQLITE_OK is returned.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize ()&lt;/a&gt; API 호출을 사용하여 반복자가 삭제됩니다 . 반복하는 동안 오류가 발생하면 SQLlite 오류 코드가 리턴됩니다 (sqlite3changeset_next ()에 의해 동일한 오류 코드가 이미 리턴 된 경우에도). 또는 오류가 발생하지 않으면 SQLITE_OK가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dd92a7436e987265ed18e3cd262b66e57b47ffd2" translate="yes" xml:space="preserve">
          <source>An ongoing RBU operation (either an update or a vacuum) does not interfere with read access to the database file.</source>
          <target state="translated">지속적인 RBU 작업 (업데이트 또는 진공)은 데이터베이스 파일에 대한 읽기 액세스를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e9fb11f12f8a43c4c89d92d48bc4d12fa12b04" translate="yes" xml:space="preserve">
          <source>An operand of a comparison is considered to have an explicit collating function assignment (rule 1 above) if any subexpression of the operand uses the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;. Thus, if a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; is used anywhere in a comparision expression, the collating function defined by that operator is used for string comparison regardless of what table columns might be a part of that expression. If two or more &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; subexpressions appear anywhere in a comparison, the left most explicit collating function is used regardless of how deeply the COLLATE operators are nested in the expression and regardless of how the expression is parenthesized.</source>
          <target state="translated">피연산자의 하위 표현식이 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용하는 경우 비교 피연산자는 명시 적 조합 함수 할당 (위의 규칙 1)을 갖는 것으로 간주됩니다 . 따라서 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 가 비교 표현식의 어느 곳에서나 사용될 경우 해당 연산자에 의해 정의 된 조합 함수는 해당 표현식의 일부가 될 수있는 테이블 열에 관계없이 문자열 비교에 사용됩니다. 둘 이상의 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 하위 표현식이 비교의 어느 곳에 나 나타나는 경우 COLLATE 연산자가 표현식에 얼마나 깊이 중첩되어 있는지, 표현식이 괄호로 묶여 있는지에 관계없이 가장 왼쪽에있는 명시 적 조합 함수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1841b8b7007b74c92e11286f08f070e4631c39a7" translate="yes" xml:space="preserve">
          <source>An ordinary common table expression works as if it were a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; that exists for the duration of a single statement. Ordinary common table expressions are useful for factoring out subqueries and making the overall SQL statement easier to read and understand.</source>
          <target state="translated">일반 공통 테이블 표현식은 마치 단일 명령문 기간 동안 존재 하는 &lt;a href=&quot;lang_createview&quot;&gt;뷰인&lt;/a&gt; 것처럼 작동 합니다. 일반 공통 테이블 표현식은 서브 쿼리를 제외하고 전체 SQL 문을 읽고 이해하기 쉽게 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c64f3df3f6dbd2c4ab332d741a98dc5f74fa4c01" translate="yes" xml:space="preserve">
          <source>An ordinary filename can usually be converted into an equivalent URI by the steps shown below. The one exception is that a relative windows pathname with a drive letter cannot be converted directly into a URI; it must be changed into an absolute pathname first.</source>
          <target state="translated">일반적인 파일 이름은 일반적으로 아래 표시된 단계에 따라 동등한 URI로 변환 될 수 있습니다. 한 가지 예외는 드라이브 문자가있는 상대 창 경로 이름을 URI로 직접 변환 할 수 없다는 것입니다. 먼저 절대 경로 이름으로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="76f1c5c7c31ea92a8b28f97d519413325cc7abf4" translate="yes" xml:space="preserve">
          <source>An overlay can be created by using the</source>
          <target state="translated">를 사용하여 오버레이를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ace2a17ee0ffadfade85b391c6417dbd59dcd570" translate="yes" xml:space="preserve">
          <source>An rtree_i32 stores coordinates as 32-bit signed integers. But it still using floating point computations internally as part of the r-tree algorithm.</source>
          <target state="translated">rtree_i32는 좌표를 32 비트 부호있는 정수로 저장합니다. 그러나 여전히 r-tree 알고리즘의 일부로 내부에서 부동 소수점 계산을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="07cb8663d689220c5b11e75bcc91e43df5ab2f40" translate="yes" xml:space="preserve">
          <source>An sqlite3_changegroup object is used to combine two or more changesets (or patchsets) into a single changeset (or patchset). A single changegroup object may combine changesets or patchsets, but not both. The output is always in the same format as the input.</source>
          <target state="translated">sqlite3_changegroup 객체는 둘 이상의 변경 세트 (또는 패치 세트)를 단일 변경 세트 (또는 패치 세트)로 결합하는 데 사용됩니다. 단일 변경 그룹 객체는 변경 세트 또는 패치 세트를 결합 할 수 있지만 둘다는 아닙니다. 출력은 항상 입력과 동일한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="caf5ebeb61b12b4ca95cabbbacfd2a52d1e22645" translate="yes" xml:space="preserve">
          <source>An sqlite3_rebaser object is created by calling sqlite3rebaser_create().</source>
          <target state="translated">sqlite3rebaser_create ()를 호출하여 sqlite3_rebaser 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2af9897fcfc348b6ea18f42888797de74b915c33" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="translated">sqlite3_value 객체는 &quot;protected&quot;또는 &quot;unprotected&quot;일 수 있습니다. 일부 인터페이스에는 보호 된 sqlite3_value가 필요합니다. 다른 인터페이스는 보호 또는 비보호 sqlite3_value를 허용합니다. sqlite3_value 인수를 허용하는 모든 인터페이스는 보호 된 sqlite3_value가 필요한지 여부를 지정합니다. &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 인터페이스는 비보호 sqlite3_value로부터 새로운 보호 sqlite3_value를 구성 할 수있다.</target>
        </trans-unit>
        <trans-unit id="7bf10bfa8716c343b3bd7ed7af7b661d4bbe7281" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="translated">sqlite3_value 객체는 &quot;protected&quot;또는 &quot;unprotected&quot;일 수 있습니다. 일부 인터페이스에는 보호 된 sqlite3_value가 필요합니다. 다른 인터페이스는 보호 또는 비보호 sqlite3_value를 허용합니다. sqlite3_value 인수를 허용하는 모든 인터페이스는 보호 된 sqlite3_value가 필요한지 여부를 지정합니다. &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 인터페이스는 비보호 sqlite3_value로부터 새로운 보호 sqlite3_value를 구성 할 수있다.</target>
        </trans-unit>
        <trans-unit id="9e4dafbd07992ae7ef4dffddcd1b4a5c5cb76207" translate="yes" xml:space="preserve">
          <source>An unconditional jump to address P2. The next instruction executed will be the one at index P2 from the beginning of the program.</source>
          <target state="translated">P2 로의 무조건 점프. 다음에 실행되는 명령어는 프로그램 시작부터 인덱스 P2에있는 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="0ec2f338946c19a5c8db3e1991942cfffb1ac767" translate="yes" xml:space="preserve">
          <source>An unrelated (and minor) bug from Mark Muranwski fixed. The algorithm for figuring out where to put temporary files for a &quot;memory:&quot; database was not working quite right.</source>
          <target state="translated">Mark Muranwski의 관련이없는 버그가 수정되었습니다. &quot;memory :&quot;데이터베이스의 임시 파일을 어디에 둘 것인지 파악하는 알고리즘이 제대로 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="24a1091048c98405fcc66da02f4798476c96d7b9" translate="yes" xml:space="preserve">
          <source>And So Forth...</source>
          <target state="translated">기타 등등...</target>
        </trans-unit>
        <trans-unit id="6d62766f3bc1a62b7bc2195312ea71e091c76d3c" translate="yes" xml:space="preserve">
          <source>And if there is an entry in that table where the key column exactly matches the name of parameter (including the initial &quot;?&quot;, &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; character) then the parameter is assigned the value of the value column. If no entry exists, the parameter defaults to NULL.</source>
          <target state="translated">키 열이 매개 변수 이름 (초기 &quot;?&quot;, &quot;$&quot;, &quot;:&quot;또는 &quot;@&quot;문자 포함)과 정확히 일치하는 항목이 있으면 해당 매개 변수에 값이 할당됩니다. 값 열. 항목이 없으면 매개 변수의 기본값은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="1613947ae46cd2f84a12cf24acc0820e1f9d0a46" translate="yes" xml:space="preserve">
          <source>And it is not really about just finding the descendents of a check-in from time to time. The fact that descendents are readily available in Fossil means that the information pervades the web pages provided by Fossil. One example: Every Fossil check-in information page (&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;example&lt;/a&gt;) shows a small &quot;Context&quot; graph of the immediate predecessor and successors to that check-in. This helps the user maintain better situational awareness, and it provides useful capabilities, such as the ability click forward to the next check-in in sequence. Another example: Fossil easily shows the context around a specific check-in (&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;example&lt;/a&gt;) which again helps to promote situational awareness and a deeper understanding of what is happening in the code.</source>
          <target state="translated">그리고 실제로 체크인의 자손을 찾는 것이 아닙니다. 자손이 화석에서 쉽게 구할 수 있다는 사실은 정보가 화석이 제공 한 웹 페이지에 퍼져 있음을 의미합니다. 하나의 예 : 모든 화석 체크인 정보 페이지 ( &lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;예&lt;/a&gt; )는 바로 전임자와 그 체크인의 후임에 대한 작은 &quot;컨텍스트&quot;그래프를 보여줍니다. 이를 통해 사용자는보다 나은 상황 인식을 유지하고 다음 체크인으로 순서대로 클릭하는 등 유용한 기능을 제공합니다. 또 다른 예 : 화석은 상황에 대한 인식을 높이고 코드에서 발생하는 상황에 대한 심층적 인 이해를 돕도록 특정 체크인 ( &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;예&lt;/a&gt; :) 관련 컨텍스트를 쉽게 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c2283cc542d600a5581e49e759263651d3636f77" translate="yes" xml:space="preserve">
          <source>And let the query be:</source>
          <target state="translated">그리고 쿼리를 보자.</target>
        </trans-unit>
        <trans-unit id="9f762e3b5086b03457eac0a8ca5ae39d999e5440" translate="yes" xml:space="preserve">
          <source>And many, many bug fixes...</source>
          <target state="translated">그리고 많은 버그 수정 ...</target>
        </trans-unit>
        <trans-unit id="f247637664b32ff61f9705cffde6b438321ac676" translate="yes" xml:space="preserve">
          <source>And populated as if the target table were an ordinary SQLite table with no explicit PRIMARY KEY columns.</source>
          <target state="translated">목표 테이블이 명시적인 PRIMARY KEY 컬럼이없는 일반 SQLite 테이블 인 것처럼 채워집니다.</target>
        </trans-unit>
        <trans-unit id="f9380c403c5923e40740011085ed6c0ba26458c2" translate="yes" xml:space="preserve">
          <source>And so forth. Basically any sequence of names optionally followed by one or two signed integers in parentheses will do.</source>
          <target state="translated">기타 등등. 기본적으로 괄호 안에 하나 또는 두 개의 부호있는 정수가 오는 일련의 이름 순서가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b0959960067ae4919fa2e1ea2e691b5f145968c7" translate="yes" xml:space="preserve">
          <source>And so forth. For ZIP archives and SQLite Archives, simply change the &quot;/tarball/&quot; element into either &quot;/zip/&quot; or &quot;/sqlar/&quot;, and maybe also change the name of the download file to have a &quot;.zip&quot; or &quot;.sqlar&quot; suffix.</source>
          <target state="translated">기타 등등. ZIP 아카이브 및 SQLite 아카이브의 경우 &quot;/ tarball /&quot;요소를 &quot;/ zip /&quot;또는 &quot;/ sqlar /&quot;로 변경하고 다운로드 파일의 이름을 &quot;.zip&quot;또는 &quot;로 변경하십시오. sqlar &quot;접미사.</target>
        </trans-unit>
        <trans-unit id="ba8077732ad2502900dddf709f29aa73b1a0f6b4" translate="yes" xml:space="preserve">
          <source>And so forth. There are 8 nodes in the TPC-H Q8 query, so this process repeats a total of 8 times. In the general case of a K-way join, the storage requirement is O(N) and the computation time is O(K*N), which is significantly faster than the O(2&lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt;) exact solution.</source>
          <target state="translated">기타 등등. TPC-H Q8 쿼리에는 8 개의 노드가 있으므로이 프로세스는 총 8 번 반복됩니다. K-way 결합의 일반적인 경우 저장 요구 사항은 O (N)이고 계산 시간은 O (K * N)이며 이는 O (2 &lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt; ) 정확한 솔루션 보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="060f19a1ad677f74cc92295a75b3f1b018b239ae" translate="yes" xml:space="preserve">
          <source>And so forth....</source>
          <target state="translated">기타 등등....</target>
        </trans-unit>
        <trans-unit id="5207dcf07042e825e2caf9ab6e9995854377e2d5" translate="yes" xml:space="preserve">
          <source>And the generated code looks like this:</source>
          <target state="translated">생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e512a9542a2e3dfd52435fac1d439e588ebcee9" translate="yes" xml:space="preserve">
          <source>And then you run the query:</source>
          <target state="translated">그런 다음 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9ffeb8471359e0755ff7942bbfbee2106c5c7ff7" translate="yes" xml:space="preserve">
          <source>And, many more minor bug fixes and performance enhancements....</source>
          <target state="translated">그리고 더 많은 사소한 버그 수정 및 성능 향상 ....</target>
        </trans-unit>
        <trans-unit id="a7e85233665c7566a60532bc230bb5ff92b64c2f" translate="yes" xml:space="preserve">
          <source>Anomaly tests are tests designed to verify the correct behavior of SQLite when something goes wrong. It is (relatively) easy to build an SQL database engine that behaves correctly on well-formed inputs on a fully functional computer. It is more difficult to build a system that responds sanely to invalid inputs and continues to function following system malfunctions. The anomaly tests are designed to verify the latter behavior.</source>
          <target state="translated">이상 테스트는 문제가 발생할 때 SQLite의 올바른 동작을 확인하기 위해 설계된 테스트입니다. 완전한 기능을 갖춘 컴퓨터에서 올바르게 구성된 입력에서 올바르게 작동하는 SQL 데이터베이스 엔진을 비교적 쉽게 구축 할 수 있습니다. 유효하지 않은 입력에 잘못 응답하고 시스템 오작동 후에도 계속 작동하는 시스템을 구축하기가 더 어렵습니다. 이상 테스트는 후자의 동작을 확인하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="6f7ee88b419e1339ccb20dd6c8b4d7e9833eca0b" translate="yes" xml:space="preserve">
          <source>Another (safer) approach to creating an imposter table is to add an entry for the imposter table to SQLite's internal symbol table without updating the &quot;sqlite_master&quot; table on disk. That way, the imposter table exists in only a single database connection and is automatically removed whenever the schema is reloaded.</source>
          <target state="translated">임 포스터 테이블을 생성하는 또 다른 (유의 한) 접근 방식은 디스크에서 &quot;sqlite_master&quot;테이블을 업데이트하지 않고 임 포스터 테이블에 대한 항목을 SQLite의 내부 심볼 테이블에 추가하는 것입니다. 이런 식으로 임 포스터 테이블은 단일 데이터베이스 연결에만 존재하며 스키마를 다시로드 할 때마다 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="213aaebee52481a980f7e74b2089b3f6c24d4183" translate="yes" xml:space="preserve">
          <source>Another (safer) approach to creating an imposter table is to add an entry for the imposter table to SQLite's internal symbol table without updating the &quot;sqlite_schema&quot; table on disk. That way, the imposter table exists in only a single database connection and is automatically removed whenever the schema is reloaded.</source>
          <target state="translated">가짜 테이블을 만드는 또 다른 (안전한) 접근 방식은 디스크에서 &quot;sqlite_schema&quot;테이블을 업데이트하지 않고 SQLite의 내부 기호 테이블에 가짜 테이블에 대한 항목을 추가하는 것입니다. 이렇게하면 사기 테이블이 단일 데이터베이스 연결에만 존재하며 스키마가 다시로드 될 때마다 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0a256db65f829282a102ced1041e5c60bd3b39bb" translate="yes" xml:space="preserve">
          <source>Another approach is to initially disable the lookaside memory allocator:</source>
          <target state="translated">또 다른 방법은 처음에 lookaside 메모리 할당자를 비활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3f1ebbc20dfee63c729fadf1742ea0910dca153a" translate="yes" xml:space="preserve">
          <source>Another approach is to translate the program source text into a tree of objects in memory. This tree is the &quot;executable&quot;. An interpret runs the executable by walking the tree. This is the technique used by MySQL, PostgreSQL, and SQL-Server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9265574f7b534649a1277b85f4934a02129bee" translate="yes" xml:space="preserve">
          <source>Another example is a virtual table that implements a full-text index. The xCreate method must create and initialize data structures to hold the dictionary and posting lists for that index. The xConnect method, on the other hand, only has to locate and use an existing dictionary and posting lists that were created by a prior xCreate call.</source>
          <target state="translated">또 다른 예는 전체 텍스트 인덱스를 구현하는 가상 테이블입니다. xCreate 메소드는 해당 색인에 대한 사전 및 게시 목록을 보유 할 데이터 구조를 작성하고 초기화해야합니다. 반면에 xConnect 메소드는 이전 xCreate 호출로 작성된 기존 사전 및 게시 목록 만 찾아서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="303e110b30c7b4642bb575628bce75a8b23bc25d" translate="yes" xml:space="preserve">
          <source>Another example of corruption caused by using a closed file descriptor was &lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;reported by facebook engineers&lt;/a&gt; in a blog post on 2014-08-12.</source>
          <target state="translated">닫힌 파일 디스크립터를 사용하여 발생한 또 다른 손상 예는 2014-08-12의 블로그 게시물에서 &lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;페이스 북 엔지니어&lt;/a&gt; 에 의해보고되었습니다 .</target>
        </trans-unit>
        <trans-unit id="505afcae9498bd12848d3ae36d382e63fe35606f" translate="yes" xml:space="preserve">
          <source>Another example of this error was reported against &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; on 2019-07-11. A file descriptor would be opened for debugging output, but then closed and reopened by SQLite. But the debugging logic continued to write into the original file descriptor. See the &lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;forum discussion&lt;/a&gt; for the bug report and a link to the fix.</source>
          <target state="translated">이 오류의 다른 예는 2019-07-11의 &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; 에 대해보고 되었습니다. 출력 설명을 위해 파일 디스크립터가 열리지 만 SQLite에 의해 닫히고 다시 열립니다. 그러나 디버깅 로직은 원래 파일 디스크립터에 계속 기록했습니다. 버그 보고서 및 수정 사항에 대한 링크 는 &lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;포럼 토론&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8183751698c287cb27407f9ba084d293db7c55bd" translate="yes" xml:space="preserve">
          <source>Another example: X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, then Y makes a changes to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Then X tries to make a change to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. The attempt by X to escalate its transaction from a read transaction to a write transaction fails with an &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; error because the snapshot of the database being viewed by X is no longer the latest version of the database. If X were allowed to write, it would fork the history of the database file, which is something SQLite does not support. In order for X to write to the database, it must first release its snapshot (using &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; for example) then start a new transaction with a subsequent &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.</source>
          <target state="translated">다른 예 : X는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 및 &lt;a href=&quot;lang_select&quot;&gt;SELECT를&lt;/a&gt; 사용하여 읽기 트랜잭션을 시작한 다음 Y는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE를&lt;/a&gt; 사용하여 데이터베이스를 변경합니다 . 그런 다음 X는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE를&lt;/a&gt; 사용하여 데이터베이스를 변경하려고합니다 . X &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;가보고&lt;/a&gt; 있는 데이터베이스의 스냅 샷이 더 이상 최신 버전의 데이터베이스가 아니기 때문에 X가 트랜잭션을 읽기 트랜잭션에서 쓰기 트랜잭션으로 에스컬레이션하려는 시도는 SQLITE_BUSY_SNAPSHOT 오류 와 함께 실패 합니다. X가 쓰기가 허용되면 데이터베이스 파일의 히스토리를 포크합니다. 이는 SQLite가 지원하지 않는 것입니다. X가 데이터베이스에 쓰려면 먼저 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 을 사용하여 스냅 샷을 해제 한 후 후속 트랜잭션으로 새 트랜잭션을 시작해야합니다.&lt;a href=&quot;lang_transaction&quot;&gt;시작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1c30e5a209f39b6a21d890471cf09df8606ebc" translate="yes" xml:space="preserve">
          <source>Another flush must occur to make sure that all the database changes are written into nonvolatile storage. This is a critical step to ensure that the database will survive a power loss without damage. However, because of the inherent slowness of writing to disk or flash memory, this step together with the rollback journal file flush in section 3.7 above takes up most of the time required to complete a transaction commit in SQLite.</source>
          <target state="translated">모든 데이터베이스 변경 사항이 비 휘발성 스토리지에 기록되도록하려면 다른 플러시가 발생해야합니다. 이는 데이터베이스가 손상없이 전원 손실을 견뎌야하는 중요한 단계입니다. 그러나 디스크 나 플래시 메모리에 쓰는 속도가 느리기 때문에, 위의 3.7 절에있는 롤백 저널 파일 플러시와 함께이 단계는 SQLite에서 트랜잭션 커밋을 완료하는 데 필요한 시간이 대부분 걸립니다.</target>
        </trans-unit>
        <trans-unit id="6c301063883293bdf468d0623b6a6911c6d2293c" translate="yes" xml:space="preserve">
          <source>Another limitation of the histogram data is that it only applies to the left-most column on an index. Consider this scenario:</source>
          <target state="translated">히스토그램 데이터의 또 다른 제한 사항은 인덱스의 가장 왼쪽 열에 만 적용된다는 것입니다. 이 시나리오를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f21c319ab2ff434679be56b445eba4fa1aa43f87" translate="yes" xml:space="preserve">
          <source>Another macro used in conjunction with test coverage measurement is the &lt;code&gt;testcase()&lt;/code&gt; macro. The argument is a condition for which we want test cases that evaluate to both true and false. In non-coverage builds (that is to say, in release builds) the &lt;code&gt;testcase()&lt;/code&gt; macro is a no-op:</source>
          <target state="translated">테스트 범위 측정과 함께 사용되는 또 다른 매크로는 &lt;code&gt;testcase()&lt;/code&gt; 매크로입니다. 인수는 참과 거짓 모두로 평가되는 테스트 사례를 원하는 조건입니다. 비 커버리지 빌드 (즉, 릴리스 빌드)에서 &lt;code&gt;testcase()&lt;/code&gt; 매크로는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c493a994000d99e73cbc3f60d51dfc6589078021" translate="yes" xml:space="preserve">
          <source>Another manifestation of this problem is &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">이 문제의 또 다른 징후는 &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;8 + 3 파일 이름의 일관성없는 사용으로 인한 데이터베이스 손상&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05b9d783d5cb2f59bb8b6ca5914b9575e677009e" translate="yes" xml:space="preserve">
          <source>Another optimization introduced in SQLite version 3.5.0 makes use of &quot;safe append&quot; behavior of the underlying disk. Recall that SQLite assumes that when data is appended to a file (specifically to the rollback journal) that the size of the file is increased first and that the content is written second. So if power is lost after the file size is increased but before the content is written, the file is left containing invalid &quot;garbage&quot; data. The xDeviceCharacteristics method of the VFS might, however, indicate that the filesystem implements &quot;safe append&quot; semantics. This means that the content is written before the file size is increased so that it is impossible for garbage to be introduced into the rollback journal by a power loss or system crash.</source>
          <target state="translated">SQLite 버전 3.5.0에 도입 된 또 다른 최적화는 기본 디스크의 &quot;안전한 추가&quot;동작을 사용합니다. SQLite는 데이터가 파일에 추가 될 때 (특히 롤백 저널에) 파일의 크기가 먼저 증가하고 내용이 두 번째로 기록된다고 가정합니다. 따라서 파일 크기를 늘리고 내용을 쓰기 전에 전원이 꺼지면 파일에 잘못된 &quot;쓰레기&quot;데이터가 포함 된 채로 남아 있습니다. 그러나 VFS의 xDeviceCharacteristics 메소드는 파일 시스템이 &quot;안전한 추가&quot;시맨틱을 구현 함을 나타낼 수 있습니다. 즉, 파일 크기가 커지기 전에 내용이 기록되므로 전원 손실이나 시스템 충돌로 인해 가비지가 롤백 저널에 도입 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dad2e6d1e9648b82626f473ea27ecce5bb27928" translate="yes" xml:space="preserve">
          <source>Another option is to run &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt;. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.</source>
          <target state="translated">다른 옵션은 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF&lt;/a&gt; 를 실행하는 것 입니다. 이 명령은 SQLite가 데이터가 디스크 표면에 도달 할 때까지 기다리지 않게하므로 쓰기 작업이 훨씬 빠릅니다. 그러나 트랜잭션 도중에 전원이 끊기면 데이터베이스 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0728346ee0767219b30d3313656a41918770666a" translate="yes" xml:space="preserve">
          <source>Another useful output mode is &quot;insert&quot;. In insert mode, the output is formatted to look like SQL INSERT statements. Use insert mode to generate text that can later be used to input data into a different database.</source>
          <target state="translated">또 다른 유용한 출력 모드는 &quot;삽입&quot;입니다. 삽입 모드에서 출력은 SQL INSERT 문처럼 보이도록 형식화됩니다. 삽입 모드를 사용하여 나중에 다른 데이터베이스에 데이터를 입력하는 데 사용할 수있는 텍스트를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="603f11343da9306fc8345afa2052a80114bf6240" translate="yes" xml:space="preserve">
          <source>Another view of RELEASE is that it merges a named transaction into its parent transaction, so that the named transaction and its parent become the same transaction. After RELEASE, the named transaction and its parent will commit or rollback together, whatever their fate may be.</source>
          <target state="translated">RELEASE의 또 다른 관점은 명명 된 트랜잭션을 상위 트랜잭션으로 병합하여 명명 된 트랜잭션과 해당 상위가 동일한 트랜잭션이된다는 것입니다. RELEASE 후에는 명명 된 트랜잭션과 해당 부모가 운명에 관계없이 커밋 또는 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="e8c0bf8ab4584514edb8368d18ba85e753fa2a2d" translate="yes" xml:space="preserve">
          <source>Another way to get the row change counts is to use the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; or &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces. There is a subtle different, though. When an INSERT, UPDATE, or DELETE is run against a view using an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt;, the count_changes pragma reports the number of rows in the view that fired the trigger, whereas &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; do not.</source>
          <target state="translated">행 변경 수를 얻는 또 다른 방법은 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스를 사용하는 것입니다. 하지만 미묘한 차이가 있습니다. &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거를&lt;/a&gt; 사용하여 뷰에 대해 INSERT, UPDATE 또는 DELETE가 실행될 때 count_changes pragma는 트리거 를 시작한 뷰 의 행 수를보고하지만 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d30986ae4eff5648d38ebb9d01b585109e2411f" translate="yes" xml:space="preserve">
          <source>Another way to think about the difference between rollback and write-ahead log is that in the rollback-journal approach, there are two primitive operations, reading and writing, whereas with a write-ahead log there are now three primitive operations: reading, writing, and checkpointing.</source>
          <target state="translated">롤백과 미리 쓰기 로그의 차이점에 대해 생각할 수있는 또 다른 방법은 롤백 저널 방식에서 읽기와 쓰기라는 두 가지 기본 작업이있는 반면 미리 쓰기 로그에는 읽기, 쓰기의 세 가지 기본 작업이 있다는 것입니다. 및 검사 점.</target>
        </trans-unit>
        <trans-unit id="7d0ac016e0a7d3c26e0cccd010f12ca2f8757e4c" translate="yes" xml:space="preserve">
          <source>Another, more automated, way to tell if a string value X contains embedded NUL characters is to use an expression like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76c08af7521af2a346bb889060bcedbdd23dc992" translate="yes" xml:space="preserve">
          <source>Anticipated Future Enhancements</source>
          <target state="translated">예상되는 미래 향상</target>
        </trans-unit>
        <trans-unit id="03cbea0705f9805750be00c459dd237de0396772" translate="yes" xml:space="preserve">
          <source>Any UTF-8 character or ISO8859 character can be used as part of an identifier.</source>
          <target state="translated">식별자의 일부로 UTF-8 문자 또는 ISO8859 문자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ff5b973797aa52493296af8db3d0915fb38ed0" translate="yes" xml:space="preserve">
          <source>Any application can run an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; query to get output similar to the above. However, indentation to show the loop structure is not generated by the SQLite core. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains extra logic for indenting loops. Also, the &quot;comment&quot; column in the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output is only provided if SQLite is compiled with the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; options.</source>
          <target state="translated">모든 애플리케이션은 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 쿼리를 실행 하여 위와 유사한 출력을 얻을 수 있습니다. 그러나 루프 구조를 표시하기위한 들여 쓰기는 SQLite 코어에서 생성되지 않습니다. &lt;a href=&quot;cli&quot;&gt;명령 줄 셸은&lt;/a&gt; 루프를 들여 추가 로직이 포함되어 있습니다. 또한 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력 의 &quot;comment&quot;열은 SQLite가 &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 옵션으로 컴파일 된 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a8e347554cfc99745cad972098b020b8602be14" translate="yes" xml:space="preserve">
          <source>Any application state that can be recorded in a pile-of-files can also be recorded in an SQLite database with a simple key/value schema like this:</source>
          <target state="translated">파일 더미에 기록 될 수있는 모든 애플리케이션 상태는 다음과 같은 간단한 키 / 값 스키마를 사용하여 SQLite 데이터베이스에 기록 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ed6ff66cc7fc9ffd4cafbde2a3c28f229641fd" translate="yes" xml:space="preserve">
          <source>Any arguments following &quot;unicode61&quot; in the token specification are treated as a list of alternating option names and values. Unicode61 supports the following options:</source>
          <target state="translated">토큰 스펙에서 &quot;unicode61&quot;뒤에 오는 모든 인수는 대체 옵션 이름 및 값 목록으로 처리됩니다. Unicode61은 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="81df847e2da7c111d58995774268025f599b0ab5" translate="yes" xml:space="preserve">
          <source>Any column in an SQLite version 3 database, except an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, may be used to store a value of any storage class.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열을 제외한 SQLite 버전 3 데이터베이스의 모든 열 은 모든 스토리지 클래스의 값을 저장하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12d25e97784fac279be1123d4fbe17792ad0403" translate="yes" xml:space="preserve">
          <source>Any custom collation sequences used by indexes within the database being vacuumed are registered with both of the database handles returned by the sqlite3rbu_db() function.</source>
          <target state="translated">진공 청소기로 청소할 데이터베이스 내 인덱스에 사용 된 사용자 지정 데이터 정렬 시퀀스는 sqlite3rbu_db () 함수가 반환 한 두 데이터베이스 핸들 모두에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="151750db2f16a0f1a6b9b810158ada7a043bfbe4" translate="yes" xml:space="preserve">
          <source>Any database clients wishing to write to the database file while a backup is being created must wait until the shared lock is relinquished.</source>
          <target state="translated">백업이 작성되는 동안 데이터베이스 파일에 쓰려는 데이터베이스 클라이언트는 공유 잠금이 해제 될 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="3870d6d9202c275acd1d8b0e06d905fc8afb745c" translate="yes" xml:space="preserve">
          <source>Any database name qualifier that occurs prior to the name of the object being created is removed.</source>
          <target state="translated">작성중인 오브젝트 이름 이전에 발생하는 모든 데이터베이스 이름 규정자가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4255994cd14e9b872cd99b88c74cbf406ff9482f" translate="yes" xml:space="preserve">
          <source>Any index that includes the WHERE clause at the end is considered to be a partial index. Indexes that omit the WHERE clause (or indexes that are created by UNIQUE or PRIMARY KEY constraints inside of CREATE TABLE statements) are ordinary full indexes.</source>
          <target state="translated">끝에 WHERE 절을 포함하는 인덱스는 부분 인덱스로 간주됩니다. WHERE 절을 생략하는 인덱스 (또는 CREATE TABLE 문 내에서 UNIQUE 또는 PRIMARY KEY 제약 조건에 의해 생성 된 인덱스)는 일반적인 전체 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="b43d049b602d1fd2bf9a7b5bea3350eedf1f0673" translate="yes" xml:space="preserve">
          <source>Any number of calls to add() and output() may be made between the calls to new() and delete(), and in any order.</source>
          <target state="translated">add () 및 output ()에 대한 호출은 new () 및 delete ()에 대한 호출간에 순서에 상관없이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc7645ee06bfe979513e08246b74910b770d144" translate="yes" xml:space="preserve">
          <source>Any of the row values in the previous example could be replace by a subquery that returns three columns and the same answer would result. For example:</source>
          <target state="translated">이전 예의 행 값은 세 개의 열을 반환하는 하위 쿼리로 대체 될 수 있으며 같은 결과가 나타납니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ffe3efbd83a6aa86da6ab4b6abaf0209d6a58e2" translate="yes" xml:space="preserve">
          <source>Any one of the above test cases would provide 100% statement coverage but all three are required for 100% branch coverage. Generally speaking, 100% branch coverage implies 100% statement coverage, but the converse is not true. To reemphasize, the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness for SQLite provides the stronger form of test coverage - 100% branch test coverage.</source>
          <target state="translated">위의 테스트 사례 중 하나는 100 % 진술 범위를 제공하지만 100 % 지점 범위에는 세 가지 모두가 필요합니다. 일반적으로 100 % 지점 범위는 100 % 진술 범위를 의미하지만 그 반대는 아닙니다. 다시 강조하기 위해 SQLite 용 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 테스트 하네스는 100 % 분기 테스트 범위 인 더 강력한 형태의 테스트 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82138b97f6d9555464cfec51a14a23b82edbc037" translate="yes" xml:space="preserve">
          <source>Any operators applied to column names, including the no-op unary &quot;+&quot; operator, convert the column name into an expression which always has no affinity. Hence even if X and Y.Z are column names, the expressions +X and +Y.Z are not column names and have no affinity.</source>
          <target state="translated">no-op 단항 &quot;+&quot;연산자를 포함하여 열 이름에 적용된 모든 연산자는 열 이름을 항상 선호도가없는 식으로 변환합니다. 따라서 X와 YZ가 열 이름 인 경우에도 + X와 + YZ 표현식은 열 이름이 아니며 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7fd223421c2a13bbb89b12c2862d7c77ef4b363f" translate="yes" xml:space="preserve">
          <source>Any other value for the b-tree page type is an error.</source>
          <target state="translated">b- 트리 페이지 유형의 다른 값은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="784db6f9216a4d895c7e958df2f8f40ae24919c7" translate="yes" xml:space="preserve">
          <source>Any scalar expression may be used in the LIMIT clause, so long as it evaluates to an integer or a value that can be losslessly converted to an integer. If the expression evaluates to a NULL value or any other value that cannot be losslessly converted to an integer, an error is returned. If the LIMIT expression evaluates to a negative value, then there is no upper bound on the number of rows returned. Otherwise, the SELECT returns the first N rows of its result set only, where N is the value that the LIMIT expression evaluates to. Or, if the SELECT statement would return less than N rows without a LIMIT clause, then the entire result set is returned.</source>
          <target state="translated">정수 또는 무손실 정수로 변환 될 수있는 값으로 평가되는 한, LIMIT 절에서 스칼라 표현식을 사용할 수 있습니다. 표현식이 NULL 값 또는 손실없이 정수로 변환 될 수없는 다른 값으로 평가되면 오류가 리턴됩니다. LIMIT 표현식이 음수 값으로 평가되면 리턴 된 행 수에 상한이 없습니다. 그렇지 않으면 SELECT는 결과 집합의 첫 N 개 행만 반환합니다. 여기서 N은 LIMIT식이 평가하는 값입니다. 또는 SELECT 문이 LIMIT 절없이 N 개 미만의 행을 리턴하면 전체 결과 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="680384b496ab63e99e152271be6ec34547a5e90a" translate="yes" xml:space="preserve">
          <source>Any time there is an error either compiling an SQL statement (using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its siblings) or running an SQL statement (using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;) that error is logged.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 그 형제를 사용하여 SQL 문을 컴파일 하거나 오류가 기록되는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 사용하여 SQL 문을 실행하는 중 오류가 발생할 때마다.</target>
        </trans-unit>
        <trans-unit id="b0e18824fe4a70b0f37b9e0cb34aa95b757ca28e" translate="yes" xml:space="preserve">
          <source>Any valid query will work against an R*Tree index. But the R*Tree implementation is designed to make two kinds of queries especially efficient. First, queries against the primary key are efficient:</source>
          <target state="translated">유효한 쿼리는 R * Tree 인덱스에 대해 작동합니다. 그러나 R * Tree 구현은 두 가지 종류의 쿼리를 특히 효율적으로 만들기 위해 설계되었습니다. 먼저 기본 키에 대한 쿼리가 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dafef79386ae39cfa702a14aae7666f057897932" translate="yes" xml:space="preserve">
          <source>Any value returned by the openclose function is ignored. If an invocation made before opening a database returns an error, then the database file is not opened and the error returned to the user. This is the only scenario in which swarmvtab will issue an &quot;open&quot; invocation without also eventually issuing a corresponding &quot;close&quot; call. If there are still databases open, &quot;close&quot; calls may be issued from within the eventual sqlite3_close() call on the applications database that deletes the temp schema in which the swarmvtab table resides.</source>
          <target state="translated">openclose 함수가 리턴 한 값은 무시됩니다. 데이터베이스를 열기 전에 호출 한 경우 오류가 발생하면 데이터베이스 파일이 열리지 않고 오류가 사용자에게 리턴됩니다. 이것은 swarmvtab이 결국 해당 &quot;close&quot;호출을 발행하지 않고 &quot;open&quot;호출을 실행하는 유일한 시나리오입니다. 여전히 열려있는 데이터베이스가있는 경우 swarmvtab 테이블이 상주하는 임시 스키마를 삭제하는 애플리케이션 데이터베이스의 최종 sqlite3_close () 호출 내에서 &quot;close&quot;호출이 발행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf9bbefc76982e17471539cdea1217f5e1e0119" translate="yes" xml:space="preserve">
          <source>Anywhere</source>
          <target state="translated">Anywhere</target>
        </trans-unit>
        <trans-unit id="e511dd65bb11704e83c08777789bf5ec195f3d28" translate="yes" xml:space="preserve">
          <source>Apart from the root node, the nodes that make up a single segment b-tree are always stored using a contiguous sequence of blockids. Furthermore, the nodes that make up a single level of the b-tree are themselves stored as a contiguous block, in b-tree order. The contiguous sequence of blockids used to store the b-tree leaves are allocated starting with the blockid value stored in the &quot;start_block&quot; column of the corresponding %_segdir row, and finishing at the blockid value stored in the &quot;leaves_end_block&quot; field of the same row. It is therefore possible to iterate through all the leaves of a segment b-tree, in key order, by traversing the %_segments table in blockid order from &quot;start_block&quot; to &quot;leaves_end_block&quot;.</source>
          <target state="translated">루트 노드 외에도 단일 세그먼트 b- 트리를 구성하는 노드는 항상 연속 된 일련의 blockid를 사용하여 저장됩니다. 또한, b- 트리의 단일 레벨을 구성하는 노드는 자체적으로 b- 트리 순서로 연속 블록으로 저장됩니다. b- 트리 잎을 저장하는 데 사용되는 연속 된 일련의 blockid는 해당 % _segdir 행의 &quot;start_block&quot;열에 저장된 blockid 값부터 시작하여 동일한 &quot;leaves_end_block&quot;필드에 저장된 blockid 값에서 끝나도록 할당됩니다. 열. 따라서 &quot;start_block&quot;에서 &quot;leaves_end_block&quot;까지 blockid 순서로 % _segments 테이블을 순회하여 세그먼트 b- 트리의 모든 리프를 키 순서로 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f3127b3255a243139304b57a2de9b375a5b278" translate="yes" xml:space="preserve">
          <source>Appears in...</source>
          <target state="translated">다음에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cddd694c6980e8f63fe16956f1fed6f2e36dd876" translate="yes" xml:space="preserve">
          <source>Appending a new</source>
          <target state="translated">새로운 추가</target>
        </trans-unit>
        <trans-unit id="939a673334c7c748561f23a3fd21e4918a1efbc3" translate="yes" xml:space="preserve">
          <source>Appending a new page to the database file.</source>
          <target state="translated">데이터베이스 파일에 새 페이지를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="dff26bc78571c36fbf9a79d63221a8d63c4781c9" translate="yes" xml:space="preserve">
          <source>Appendix A: Comparison with FTS3/4</source>
          <target state="translated">부록 A : FTS3 / 4와 비교</target>
        </trans-unit>
        <trans-unit id="2f62ea77455407c6d86c7651d5f030af0222ec84" translate="yes" xml:space="preserve">
          <source>Appendix A: Search Application Tips</source>
          <target state="translated">부록 A : 응용 프로그램 검색 팁</target>
        </trans-unit>
        <trans-unit id="f9f1d1188ea485eedb2325535cccc6c2b70da6fd" translate="yes" xml:space="preserve">
          <source>Appendix B: Shadow tables created by FTS5</source>
          <target state="translated">부록 B : FTS5에 의해 생성 된 새도우 테이블</target>
        </trans-unit>
        <trans-unit id="24139aab1ccfea9a0794fea103821cef5044dd2c" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시.</target>
        </trans-unit>
        <trans-unit id="557031cad0f1b2b54264afc9d96a7aba19827147" translate="yes" xml:space="preserve">
          <source>Application ID</source>
          <target state="translated">신청 ID</target>
        </trans-unit>
        <trans-unit id="871e1857983850d1454dd7c60ae50af733931a7a" translate="yes" xml:space="preserve">
          <source>Application Interface</source>
          <target state="translated">응용 프로그램 인터페이스</target>
        </trans-unit>
        <trans-unit id="a6c10e408404322943e578d89c2bff7889c626f3" translate="yes" xml:space="preserve">
          <source>Application Porting Guide</source>
          <target state="translated">응용 프로그램 포팅 안내서</target>
        </trans-unit>
        <trans-unit id="a768f98624703793f6acc4a427b7a53a61477bff" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; 파일 제어를 호출하여 SQLite가 TEMP 테이블 및 기타 내부 용도에 대한 임시 파일 이름을 생성하는 데 사용되는 동일한 알고리즘을 사용하여 임시 파일 이름을 생성하도록 할 수 있습니다. 인수는 char **이어야하며 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 쓰여진 파일 이름으로 채워집니다 . 호출자는 메모리 누수를 피하기 위해 결과에서 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3350dbe5c54d126511b6c09afcd8f51bea6a199c" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; 파일 제어를 호출하여 SQLite가 TEMP 테이블 및 기타 내부 용도에 대한 임시 파일 이름을 생성하는 데 사용되는 동일한 알고리즘을 사용하여 임시 파일 이름을 생성하도록 할 수 있습니다. 인수는 char **이어야하며 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 쓰여진 파일 이름으로 채워집니다 . 호출자는 메모리 누수를 피하기 위해 결과에서 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f4e99a2282eb2e1c855827ddf5f64dd418ab8c7" translate="yes" xml:space="preserve">
          <source>Application code is allowed to modify the sqlite_sequence table, to add new rows, to delete rows, or to modify existing rows. However, application code cannot create the sqlite_sequence table if it does not already exist. Application code can delete all entries from the sqlite_sequence table, but application code cannot drop the sqlite_sequence table.</source>
          <target state="translated">응용 프로그램 코드는 sqlite_sequence 테이블을 수정하거나, 새 행을 추가하거나, 행을 삭제하거나, 기존 행을 수정할 수 있습니다. 그러나 sqlite_sequence 테이블이 없으면 응용 프로그램 코드에서 sqlite_sequence 테이블을 작성할 수 없습니다. 응용 프로그램 코드는 sqlite_sequence 테이블에서 모든 항목을 삭제할 수 있지만 응용 프로그램 코드는 sqlite_sequence 테이블을 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="04ce787e0da35dc9f49592d7babca6adb18799a3" translate="yes" xml:space="preserve">
          <source>Application-Defined SQL Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e1cbe2a441c6c1937a6117a0a716b80ac62de18" translate="yes" xml:space="preserve">
          <source>Application-defined SQL functions can become security vulnerabilities if not carefully managed. Suppose, for example, an application defines a new &quot;system(X)&quot; SQL function that runs its argument X as a command and returns the integer result code. Perhaps the implementation is like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="263c551ee583a68f5c9b570a6b7af2da5afc58f1" translate="yes" xml:space="preserve">
          <source>Application-defined collating functions</source>
          <target state="translated">응용 프로그램 정의 조합 기능</target>
        </trans-unit>
        <trans-unit id="cc72ed4369f2c8e42dc0e63912d4e3ec80d61b1d" translate="yes" xml:space="preserve">
          <source>Application-defined or custom SQL functions are created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; family of interfaces. Custom SQL functions can be scalar functions, aggregate functions, or &lt;a href=&quot;windowfunctions&quot;&gt;window functions&lt;/a&gt;. Custom SQL functions can have any number of arguments from 0 up to &lt;a href=&quot;limits#max_function_arg&quot;&gt;SQLITE_MAX_FUNCTION_ARG&lt;/a&gt;. The &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_function()&lt;/a&gt; interface specifies callbacks that are invoked to carry out the processing for the new SQL function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d0ad5ca7051d2b57b94a5f5601d3d125282b43" translate="yes" xml:space="preserve">
          <source>Applications are not required to use either of these standard memory allocators. If SQLite is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; then no implementation for the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; functions is provided. Instead, the application that links against SQLite must provide its own implementation of these functions. The application provided memory allocator is not required to use the malloc()/free() implementation in the standard C library. An embedded application might provide an alternative memory allocator that uses memory for a fixed memory pool set aside for the exclusive use of SQLite, for example.</source>
          <target state="translated">응용 프로그램은 이러한 표준 메모리 할당 자 중 하나를 사용할 필요가 없습니다. SQLite가 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; 으로 컴파일 되면 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 함수에 대한 구현이 제공되지 않습니다. 대신 SQLite에 연결되는 응용 프로그램은 이러한 기능을 자체적으로 구현해야합니다. 응용 프로그램 제공 메모리 할당자는 표준 C 라이브러리에서 malloc () / free () 구현을 사용할 필요가 없습니다. 임베디드 응용 프로그램은 예를 들어 SQLite 독점 사용을 위해 고정 메모리 풀 세트에 메모리를 사용하는 대체 메모리 할당자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38446a7215f8f42cf45502d1b63067076b840788" translate="yes" xml:space="preserve">
          <source>Applications are strongly discouraged from using this global variable. It is required to set a temporary folder on Windows Runtime (WinRT). But for all other platforms, it is highly recommended that applications neither read nor write this variable. This global variable is a relic that exists for backwards compatibility of legacy applications and should be avoided in new projects.</source>
          <target state="translated">응용 프로그램은이 전역 변수를 사용하지 않는 것이 좋습니다. WinRT (Windows 런타임)에서 임시 폴더를 설정해야합니다. 그러나 다른 모든 플랫폼의 경우 응용 프로그램에서이 변수를 읽거나 쓰지 않는 것이 좋습니다. 이 전역 변수는 레거시 응용 프로그램의 이전 버전과의 호환성을 위해 존재하는 유물이므로 새 프로젝트에서는 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="180a26d65b478f96354579f1533f98cb44ab9c69" translate="yes" xml:space="preserve">
          <source>Applications can activate foreign key enforcement at run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement. Or, foreign key enforcement can be activated at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt; compile-time option.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; 문을 사용하여 런타임에 외래 키 적용을 활성화 할 수 있습니다 . 또는 &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1&lt;/a&gt; 컴파일 타임 옵션을 사용하여 컴파일 타임에 외래 키 시행을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa39f6b2c61405c17ac04b8c804d6f91045049fb" translate="yes" xml:space="preserve">
          <source>Applications can call sqlite3_vfs_register() at any time, though of course a VFS needs to be registered before it can be used. The first argument is a pointer to a customized VFS object that the application has prepared. The second argument is true to make the new VFS the default VFS so that it will be used by the legacy &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; APIs. If the new VFS is not the default, then you will probably have to use the new &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; API to use it. Note, however, that if a new VFS is the only VFS known to SQLite (if SQLite was compiled without its usual default VFS or if the precompiled default VFS was removed using &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;) then the new VFS automatically becomes the default VFS regardless of the makeDflt argument to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="translated">애플리케이션은 언제든지 sqlite3_vfs_register ()를 호출 할 수 있지만 VFS를 사용하려면 먼저 등록해야합니다. 첫 번째 인수는 애플리케이션이 준비한 사용자 정의 된 VFS 오브젝트에 대한 포인터입니다. 두 번째 인수는 레거시 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; API에서 사용되도록 새 VFS를 기본 VFS로 만드는 데 적용됩니다 . 새 VFS가 기본값이 아닌 경우 새 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; API를 사용해야합니다. 그러나 새 VFS가 SQLite에 알려진 유일한 VFS 인 경우 (SQLite가 일반적인 기본 VFS없이 컴파일되었거나 사전 컴파일 된 기본 VFS가 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister ()를&lt;/a&gt; 사용하여 제거 된 경우 )) 그러면 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 의 makeDflt 인수에 관계없이 새 VFS가 자동으로 기본 VFS가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2aaaa457f07aa308713a42a915ad2852c0b39a0" translate="yes" xml:space="preserve">
          <source>Applications can chose to store dates and times in any of these formats and freely convert between formats using the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 날짜 및 시간을 이러한 형식으로 저장하도록 선택할 수 있으며 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 기능을&lt;/a&gt; 사용하여 형식간에 자유롭게 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec145e5678c1f6c0fcbe32fd22a6afa6e15334a5" translate="yes" xml:space="preserve">
          <source>Applications can easily read or write SQLite Archives by linking against SQLite and including the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext/misc/sqlar.c&lt;/a&gt; extension to handle the compression and decompression. The sqlar.c extension creates two new SQL functions.</source>
          <target state="translated">애플리케이션은 SQLite에 연결하고 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext / misc / sqlar.c&lt;/a&gt; 확장을 포함하여 압축 및 압축 해제를 처리하여 SQLite 아카이브를 쉽게 읽거나 쓸 수 있습니다 . sqlar.c 확장은 두 개의 새로운 SQL 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="1918677709e2695b409a42649a05c8c68141d7b8" translate="yes" xml:space="preserve">
          <source>Applications can invoke the &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; 파일 제어를 호출하여 SQLite가 TEMP 테이블 및 기타 내부 용도에 대한 임시 파일 이름을 생성하는 것과 동일한 알고리즘을 사용하여 임시 파일 이름을 생성하도록 할 수 있습니다. 인수는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 기록 된 파일 이름으로 채워지는 char **이어야합니다 . 호출자는 메모리 누수를 방지하기 위해 결과에 대해 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8946e0c0b189dd677211bd451c25bb7e538671e1" translate="yes" xml:space="preserve">
          <source>Applications can invoke the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; 파일 제어를 호출하여 SQLite가 TEMP 테이블 및 기타 내부 용도에 대한 임시 파일 이름을 생성하는 것과 동일한 알고리즘을 사용하여 임시 파일 이름을 생성하도록 할 수 있습니다. 인수는 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 기록 된 파일 이름으로 채워지는 char **이어야합니다 . 호출자는 메모리 누수를 방지하기 위해 결과에 대해 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="10c37b1dc4c015883a2357b3c09de919e0c79e2e" translate="yes" xml:space="preserve">
          <source>Applications can leverage the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; indexes and use triggers to implement an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;fts3&quot;&gt;전체 텍스트 검색&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; 인덱스를 활용하고 트리거를 사용하여 &lt;a href=&quot;undoredo&quot;&gt;자동화 된 실행 취소 / 다시 실행 스택&lt;/a&gt; 을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c37342832f86fc16406f3d6f977afed5099fdf" translate="yes" xml:space="preserve">
          <source>Applications can use the &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log(E,F,..)&lt;/a&gt; API to send new messages to the log, if desired, but this is discouraged. The &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; interface is intended for use by extensions only, not by applications.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log (E, F, ..)&lt;/a&gt; API를 사용하여 원하는 경우 새 메시지를 로그에 보낼 수 있지만 권장하지는 않습니다. &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스 만이 아닌 응용 프로그램 확장으로 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b11300864c54770f7c5f526b6116f644fe6e616" translate="yes" xml:space="preserve">
          <source>Applications need to receive a pointer to the &quot;fts5_api&quot; object in order to add extensions, such as custom tokenizers, to the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension.</source>
          <target state="translated">FTS5 확장에 사용자 정의 토크 나이저와 같은 확장을 추가하려면 응용 프로그램에서 &quot;fts5_api&quot;개체에 대한 포인터를 &lt;a href=&quot;fts5&quot;&gt;받아야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c62d5c6028bfae4c8b01799ff1a016b8e43ca22c" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="translated">응용 프로그램은해야 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;완료&lt;/a&gt; 모든 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;가까운&lt;/a&gt; 모든 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 하고, &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;마무리&lt;/a&gt; 모두 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup이&lt;/a&gt; 과 관련된 객체 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를&lt;/a&gt; 이전 개체를 닫기 시도에 객체입니다. sqlite3_close_v2 ()가 여전히 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트를 가진 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 호출되면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 하고 모든 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 처리 할 때까지 자원 할당이 지연됩니다.&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="370f3cced4e036aaca81af4fa9e5c1fe46910ebe" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="translated">응용 프로그램은해야 &lt;a href=&quot;finalize&quot;&gt;완료&lt;/a&gt; 모든 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; , &lt;a href=&quot;blob_close&quot;&gt;가까운&lt;/a&gt; 모든 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 하고, &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;마무리&lt;/a&gt; 모두 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup이&lt;/a&gt; 과 관련된 객체 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를&lt;/a&gt; 이전 개체를 닫기 시도에 객체입니다. sqlite3_close_v2 ()가 여전히 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 / 또는 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트를 가진 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 호출되면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 하고 모든 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 처리 할 때까지 자원 할당이 지연됩니다.&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="11da7d835aa708827d0f44dfb12fe45f22493e9a" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted SQL inputs should take the following precautions:</source>
          <target state="translated">신뢰할 수없는 SQL 입력을 허용하는 응용 프로그램은 다음 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="f32733159fe9563d84f7da23f8a179d0a799e2a5" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted database files should do the following:</source>
          <target state="translated">신뢰할 수없는 데이터베이스 파일을 허용하는 응용 프로그램은 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e886a51fcb81bff62e2c48396e856865668d639c" translate="yes" xml:space="preserve">
          <source>Applications that already use SQLite for other purposes can easily add support for SQLite Archives using a small extension (&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt;) to handle the compression and decompression of content. Even this tiny extension can be omitted if the files in the archive are uncompressed. In contrast, supporting ZIP Archives and/or Tarballs requires either separate libraries or lots of extra custom code, or sometimes both.</source>
          <target state="translated">다른 목적으로 이미 SQLite를 사용하는 애플리케이션 은 컨텐츠의 압축 및 압축 해제를 처리하기 위해 작은 확장 ( &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt; )을 사용하여 SQLite 아카이브에 대한 지원을 쉽게 추가 할 수 있습니다 . 아카이브의 파일이 압축되지 않은 경우이 작은 확장명도 생략 할 수 있습니다. 반대로 ZIP 아카이브 및 / 또는 Tarball을 지원하려면 별도의 라이브러리 또는 많은 추가 사용자 정의 코드가 필요하거나 때로는 둘 다 필요합니다.</target>
        </trans-unit>
        <trans-unit id="77baa4279beeeafb725407d72ddb6fda70fe7b8a" translate="yes" xml:space="preserve">
          <source>Applications that desire more control can run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize(0x03)&lt;/a&gt; to obtain a list of ANALYZE commands that SQLite thinks are appropriate to run, but without actually running those commands. If the returned set is non-empty, the application can then make a decision about whether or not to run the suggested ANALYZE commands, perhaps after prompting the user for guidance.</source>
          <target state="translated">더 많은 제어를 원하는 응용 프로그램은 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize (0x03)&lt;/a&gt; 를 실행하여 SQLite가 실행하기에 적합하다고 생각하는 ANALYZE 명령 목록을 얻을 수 있지만 실제로는 해당 명령을 실행하지는 않습니다. 리턴 된 세트가 비어 있지 않으면 애플리케이션은 사용자에게 안내를 요청한 후 제안 된 ANALYZE 명령을 실행할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb5bae5e54c915160fb76cb9810521459a0328b" translate="yes" xml:space="preserve">
          <source>Applications that implement their own memory allocator must provide implementation for the usual three allocation functions &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. And they must also implement a fourth function:</source>
          <target state="translated">자체 메모리 할당자를 구현하는 응용 프로그램은 일반적인 세 ​​가지 할당 함수 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()에&lt;/a&gt; 대한 구현을 제공해야합니다 . 또한 네 번째 기능도 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="3276d7f69778b6a6958211df873305e75fc12066" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="translated">신뢰할 수없는 소스에서 SQL을 처리해야하는 응용 프로그램은 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 리소스 제한을 낮추고 권한 부여자를 사용하는 것 외에도 &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 를 사용하여 데이터베이스 크기를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="354d6571e51ed32448c014f215aad54793f93f19" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="translated">신뢰할 수없는 소스에서 SQL을 처리해야하는 응용 프로그램은 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 리소스 제한을 낮추고 권한 부여자를 사용하는 것 외에도 &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 를 사용하여 데이터베이스 크기를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8e172472dcda9eeff06e1a92573e0211e5da692" translate="yes" xml:space="preserve">
          <source>Applications that read or write SQLite database files of uncertain provenance should take precautions enumerated below.</source>
          <target state="translated">출처가 불확실한 SQLite 데이터베이스 파일을 읽거나 쓰는 응용 프로그램은 아래에 열거 된 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="20b510dde80120d96a00c84ffe0b865066e5c9f7" translate="yes" xml:space="preserve">
          <source>Applications that use SQLite can define custom SQL functions that call back into application code to compute their results. The custom SQL function implementations can be embedded in the application code itself, or can be &lt;a href=&quot;loadext&quot;&gt;loadable extensions&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56219a273baff8fb63d4f640239c5a3823587f98" translate="yes" xml:space="preserve">
          <source>Applications using the split amalgamation simply compile against &quot;sqlite3-all.c&quot; instead of &quot;sqlite3.c&quot;. The two files work exactly the same. But with &quot;sqlite3-all.c&quot;, no single source file contains more than 32,767 lines of code, and so it is more convenient to use some debuggers. The downside of the split amalgamation is that it consists of 6 C source code files instead of just 1.</source>
          <target state="translated">split amalgamation을 사용하는 응용 프로그램은 단순히 &quot;sqlite3.c&quot;대신 &quot;sqlite3-all.c&quot;에 대해 컴파일됩니다. 두 파일은 정확히 동일하게 작동합니다. 그러나 &quot;sqlite3-all.c&quot;를 사용하면 단일 소스 파일에 32,767 줄 이상의 코드가 포함되지 않으므로 일부 디버거를 사용하는 것이 더 편리합니다. 분할 합병의 단점은 단 1 개가 아닌 6 개의 C 소스 코드 파일로 구성되어 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d0b5bb7dc63af158df007b2dc9a7b8099c0d304" translate="yes" xml:space="preserve">
          <source>Applications with long-lived databases that use complex queries should consider running the following commands just prior to closing each database connection:</source>
          <target state="translated">복잡한 쿼리를 사용하는 수명이 긴 데이터베이스가있는 애플리케이션은 각 데이터베이스 연결을 닫기 직전에 다음 명령을 실행하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="514f9d7fb93d92d6765510a1359338148e757312" translate="yes" xml:space="preserve">
          <source>Apply A Changeset To A Database</source>
          <target state="translated">데이터베이스에 변경 세트 적용</target>
        </trans-unit>
        <trans-unit id="0f306fb05632f0f4db7dd5e5ff03c213825dd25d" translate="yes" xml:space="preserve">
          <source>Apply a changeset or patchset to a database. These functions attempt to update the &quot;main&quot; database attached to handle db with the changes found in the changeset passed via the second and third arguments.</source>
          <target state="translated">데이터베이스에 변경 세트 또는 패치 세트를 적용하십시오. 이 함수는 두 번째 및 세 번째 인수를 통해 전달 된 변경 세트에서 발견 된 변경 사항으로 db를 처리하기 위해 첨부 된 &quot;기본&quot;데이터베이스를 업데이트하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a7bf4a5600a606d3a4f075dab8912ba1aa9d1deb" translate="yes" xml:space="preserve">
          <source>Apply affinities to a range of P2 registers starting with P1.</source>
          <target state="translated">P1로 시작하는 P2 레지스터 범위에 친 화성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="d9053b57f5f861486073c17aece29454b87cf37a" translate="yes" xml:space="preserve">
          <source>Applying a changeset to a database is simpler than capturing a changeset. Usually, a single call to &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, as depicted in the example code below, suffices.</source>
          <target state="translated">데이터베이스에 변경 세트를 적용하는 것이 변경 세트를 캡처하는 것보다 간단합니다. 일반적으로 아래 예제 코드와 같이 &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 대한 단일 호출로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9d64c94c92e46add367d8f8d91e1e8dd6a71ae2e" translate="yes" xml:space="preserve">
          <source>Appropriate Uses For SQLite</source>
          <target state="translated">SQLite의 적절한 사용</target>
        </trans-unit>
        <trans-unit id="7db317caf72bb7c9dbfdfdc313cade8bdb182e98" translate="yes" xml:space="preserve">
          <source>Approx. Date</source>
          <target state="translated">약. 데이트</target>
        </trans-unit>
        <trans-unit id="63a877b9c97333a0f773b586cf9b6ea0abe4710d" translate="yes" xml:space="preserve">
          <source>Approximately 25% better performance from the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 에서 약 25 % 향상된 성능 .</target>
        </trans-unit>
        <trans-unit id="1acd094f8de42870eb88cfeea3ebc197767f3b95" translate="yes" xml:space="preserve">
          <source>Architecture of SQLite</source>
          <target state="translated">SQLite의 아키텍처</target>
        </trans-unit>
        <trans-unit id="f076fb02f05c0b3b0347a8ec181af332464b574d" translate="yes" xml:space="preserve">
          <source>Are there any known size limits to SQLite databases?</source>
          <target state="translated">SQLite 데이터베이스에 알려진 크기 제한이 있습니까?</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="c4d2bb6ff9ec16533c1c379a0a3c41d194bcc183" translate="yes" xml:space="preserve">
          <source>Argument T is the name of the database file to vacuum. Argument S is the name of a database in which the RBU module will save its state if the vacuum operation is suspended.</source>
          <target state="translated">인수 T는 진공화할 데이터베이스 파일의 이름입니다. 인수 S는 진공 작업이 일시 중단 된 경우 RBU 모듈이 상태를 저장하는 데이터베이스의 이름입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
