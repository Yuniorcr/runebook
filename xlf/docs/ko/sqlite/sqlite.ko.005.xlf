<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="a4ac561108af405d7aa448c97e428307506c4b7a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange()&lt;/a&gt; interfaces to help virtual table implementations optimize UPDATE operations.</source>
          <target state="translated">가상 테이블 구현이 UPDATE 조작을 최적화하는 데 도움이 되도록 &lt;a href=&quot;c3ref/vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_nochange ()&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ddf120a30cf931bf5d51052ad2c827a892d71cac" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; interface and enhanced the &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; to support blocking checkpoints.</source>
          <target state="translated">&lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 인터페이스를 추가하고 차단 검사 점을 지원 하도록 &lt;a href=&quot;pragma#pragma_wal_checkpoint&quot;&gt;wal_checkpoint pragma&lt;/a&gt; 를 향상 시켰습니다 .</target>
        </trans-unit>
        <trans-unit id="d0929c2ba69cbc1ab90381ef901ed1c43220d3b7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;carray&quot;&gt;carray() table-valued function&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;carray&quot;&gt;carray () 테이블 반환 함수의&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="4198af2bb2d3a6a2e5d9e717e487ffdb864f387d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#editfunc&quot;&gt;edit() SQL function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli#editfunc&quot;&gt;edit () SQL 함수를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="474818afcad8b8e66370e87650be26268e65480a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#exexcel*&quot;&gt;.excel command&lt;/a&gt; to simplify exporting database content to a spreadsheet.</source>
          <target state="translated">&lt;a href=&quot;cli#exexcel*&quot;&gt;.excel 명령&lt;/a&gt; 을 추가하여 데이터베이스 내용을 스프레드 시트로 쉽게 내보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd0d090262bc2f05e4866375d263ebdd0c0c20b9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#fullschema&quot;&gt;.fullschema&lt;/a&gt; dot-command to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;cli#fullschema&quot;&gt;.fullschema을&lt;/a&gt; 받는 점 명령을 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="efaa065fc6ae309d6f393706b579d1948716e05b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;cli#sha3sum&quot;&gt;.sha3sum dot-command&lt;/a&gt; and the &lt;a href=&quot;cli#selftest&quot;&gt;.selftest dot-command&lt;/a&gt; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;</source>
          <target state="translated">추가 &lt;a href=&quot;cli#sha3sum&quot;&gt;.sha3sum 점 명령&lt;/a&gt; 과 &lt;a href=&quot;cli#selftest&quot;&gt;.selftest 점 명령을&lt;/a&gt; 받는 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e6c65b9a76c93d9f52da8c8997329f7ae8313b1d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#allow_uri_authority&quot;&gt;SQLITE_ALLOW_URI_AUTHORITY&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e6ce6e1df1cafb18c2d838e2c4bcdbb99f313309" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e862d7c1b81982153f4eb3d2e608a91a4403f0a9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; and &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS&lt;/a&gt; compile-time options. The &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; compile-time option replaces the &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; option, which is no longer supported.</source>
          <target state="translated">&lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; 및 &lt;a href=&quot;compile#default_wal_synchronous&quot;&gt;SQLITE_DEFAULT_WAL_SYNCHRONOUS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 . &lt;a href=&quot;compile#default_synchronous&quot;&gt;SQLITE_DEFAULT_SYNCHRONOUS&lt;/a&gt; 컴파일시 옵션은 대체 &lt;a href=&quot;compile#extra_durable&quot;&gt;SQLITE_EXTRA_DURABLE&lt;/a&gt; 더 이상 지원되지 않습니다 옵션을.</target>
        </trans-unit>
        <trans-unit id="0d9939088e42394a02853dfc4d6f72c7cbfcfabb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; compile-time option, causing &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; to be read directly from the database file, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#direct_overflow_read&quot;&gt;SQLITE_DIRECT_OVERFLOW_READ&lt;/a&gt; 컴파일 타임 옵션을 추가하여 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;페이지 캐시를&lt;/a&gt; 무시하고 데이터베이스 파일에서 &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;오버플로 페이지&lt;/a&gt; 를 직접 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="89be077605abd75e22c5ffc02c2f38f9fadca22f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#disable_fts4_deferred&quot;&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#disable_fts4_deferred&quot;&gt;SQLITE_DISABLE_FTS4_DEFERRED&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="809eece43957fbb9e8168262d4e0fe553c274d57" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_api_armor&quot;&gt;SQLITE_ENABLE_API_ARMOR&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_api_armor&quot;&gt;SQLITE_ENABLE_API_ARMOR&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="78acf1f8c9551ddf3a305b4527973a912eca40df" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_null_trim&quot;&gt;SQLITE_ENABLE_NULL_TRIM&lt;/a&gt; compile-time option, which can result in significantly smaller database files for some applications, at the risk of being incompatible with older versions of SQLite.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_null_trim&quot;&gt;SQLITE_ENABLE_NULL_TRIM&lt;/a&gt; 컴파일 타임 옵션이 추가되어 일부 응용 프로그램의 데이터베이스 파일이 훨씬 작아 져 이전 버전의 SQLite와 호환되지 않을 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc7192a68013b4ccfb34fc5fa843f664f068838" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#enable_unknown_sql_function&quot;&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/a&gt; compile-time option and turned that option on by default when building the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_unknown_sql_function&quot;&gt;SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION&lt;/a&gt; 컴파일 타임 옵션을 추가하고 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘을&lt;/a&gt; 빌드 할 때 기본적으로 해당 옵션을 설정했습니다 .</target>
        </trans-unit>
        <trans-unit id="e26774dce1b145c5b9b287b32dbb4c00e6fe2392" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#fts3_max_expr_depth&quot;&gt;SQLITE_FTS3_MAX_EXPR_DEPTH&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#fts3_max_expr_depth&quot;&gt;SQLITE_FTS3_MAX_EXPR_DEPTH&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="39f704cba224d0630f060896cdfabf87b14693b5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#have_isnan&quot;&gt;SQLITE_HAVE_ISNAN&lt;/a&gt; compile-time option which will cause the isnan() function from the standard math library to be used instead of SQLite's own home-brew NaN checker.</source>
          <target state="translated">SQLite의 자체 양조 NaN 검사기 대신 표준 수학 라이브러리의 isnan () 함수를 사용 하는 &lt;a href=&quot;compile#have_isnan&quot;&gt;SQLITE_HAVE_ISNAN&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="558383d2bbd0eb67a29332971af16389f89345ef" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#like_doesnt_match_blobs&quot;&gt;SQLITE_LIKE_DOESNT_MATCH_BLOBS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="84daf3b5302c6fe472e4c66d1c3fa77e1f119885" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; compile-time option</source>
          <target state="translated">추가 &lt;a href=&quot;compile#minimum_file_descriptor&quot;&gt;SQLITE_MINIMUM_FILE_DESCRIPTOR&lt;/a&gt; 컴파일시 옵션을</target>
        </trans-unit>
        <trans-unit id="8d7a7e10a04ea0438234a85069c16c9283a34f44" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_autoreset&quot;&gt;SQLITE_OMIT_AUTORESET&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="cb3a294a7e977a259efaa0c86a5bd58c0ece5079" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_truncate_optimization&quot;&gt;SQLITE_OMIT_TRUNCATE_OPTIMIZATION&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a909d1326bcfce04150c32be27f8c49b83bd0ecc" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#reverse_unordered_selects&quot;&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#reverse_unordered_selects&quot;&gt;SQLITE_REVERSE_UNORDERED_SELECTS&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="502456daba3bbfc42c2aae4e0545df4627f551ad" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; compile-time option and &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; start-time option.</source>
          <target state="translated">추가 &lt;a href=&quot;compile#sorter_pmasz&quot;&gt;SQLITE_SORTER_PMASZ&lt;/a&gt; 컴파일시 옵션을 선택하고 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigpmasz&quot;&gt;SQLITE_CONFIG_PMASZ&lt;/a&gt; 시작 시간 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="28034c0cfb70c12e27ba3ede26d8dd8ede415516" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#trace_size_limit&quot;&gt;SQLITE_TRACE_SIZE_LIMIT&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="09fb1f6511621b38cfa7a99512d14f14883fbc85" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; compile-time option.</source>
          <target state="translated">&lt;a href=&quot;compile#zero_malloc&quot;&gt;SQLITE_ZERO_MALLOC&lt;/a&gt; 컴파일 타임 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3f3173fa35c3a879c2726fc2a5942b9f31caf835" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;completion&quot;&gt;COMPLETION extension&lt;/a&gt; - designed to suggest tab-completions for interactive user interfaces. This is a work in progress. Expect further enhancements in future releases.</source>
          <target state="translated">대화식 사용자 인터페이스를위한 탭 완성을 제안하도록 설계된 &lt;a href=&quot;completion&quot;&gt;COMPLETION 확장을&lt;/a&gt; 추가했습니다 . 현재 진행중인 작업입니다. 향후 릴리스에서 추가 개선이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="bd72639918b4a26ff2fb29a0faca5f35c83f254f" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;csv&quot;&gt;CSV virtual table&lt;/a&gt; for reading &lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; formatted comma-separated value files.</source>
          <target state="translated">&lt;a href=&quot;https://www.ietf.org/rfc/rfc4180.txt&quot;&gt;RFC 4180&lt;/a&gt; 형식의 쉼표로 구분 된 값 파일 을 읽기위한 &lt;a href=&quot;csv&quot;&gt;CSV 가상 테이블&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3160ced06d046132de38a26647860622e0cdffde" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts3tok&quot;&gt;fts3tokenize virtual table&lt;/a&gt; to the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; logic.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;전체 텍스트 검색에 &lt;/a&gt;&lt;a href=&quot;fts3#fts3tok&quot;&gt;fts3tokenize 가상 테이블&lt;/a&gt; 을 추가했습니다. 로직.</target>
        </trans-unit>
        <trans-unit id="4c8b894319f521eb57fd47b0be0aa9684d1ec5aa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux&lt;/a&gt; table</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4aux&quot;&gt;fts4aux를&lt;/a&gt; 추가했습니다 테이블</target>
        </trans-unit>
        <trans-unit id="4f7adb875b0c694ac11f99fb4651fab782bc54c4" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#fts4notindexed&quot;&gt;FTS4 notindexed option&lt;/a&gt;, allowing non-indexed columns in an FTS4 table.</source>
          <target state="translated">&lt;a href=&quot;fts3#fts4notindexed&quot;&gt;FTS4 not indexed 옵션&lt;/a&gt; 추가FTS4 테이블에서 색인화되지 않은 열을 허용 .</target>
        </trans-unit>
        <trans-unit id="af80c1928f1855cabc20adda009b71283ddea157" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#matchinfo-b&quot;&gt;matchinfo 'b' flag&lt;/a&gt; to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function in &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-b&quot;&gt;FTS3&lt;/a&gt; 의 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 함수에 &lt;a href=&quot;fts3&quot;&gt;matchinfo &lt;/a&gt;'b'플래그 를 추가했습니다. .</target>
        </trans-unit>
        <trans-unit id="65d5c29f868afb57f7cc51fb08236c713031a2c7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts3#matchinfo-y&quot;&gt;matchinfo y flag&lt;/a&gt; to the &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; function of &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3#matchinfo-y&quot;&gt;FTS3&lt;/a&gt; 의 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 함수에 &lt;a href=&quot;fts3&quot;&gt;matchinfo &lt;/a&gt;y 플래그 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="a827723f97ea5885e808c3970a4b40110e42abfa" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;fts5#the_detail_option&quot;&gt;FTS5 detail option&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts5#the_detail_option&quot;&gt;FTS5 세부 옵션이&lt;/a&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a22bb4ef0d3b7209d712c5d4d93daa0aaef7a82c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly&quot;&gt;Geopoly module&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;geopoly&quot;&gt;지오 폴리 모듈&lt;/a&gt; 추가</target>
        </trans-unit>
        <trans-unit id="87c6d5f726f175566512f2d2234a5c4de18fd7f8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;geopoly#ccw&quot;&gt;geopoly_ccw ()&lt;/a&gt; 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="1b0e11f7f07f3617d74c59523f8c23d59441befb" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;geopoly#regpoly&quot;&gt;geopoly_regular()&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;geopoly#regpoly&quot;&gt;geopoly_regular ()&lt;/a&gt; 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="f24e2a1102cf6edaae603eaa6aac92e181730dab" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/ext/userauth/user-auth.txt&quot;&gt;User Authentication&lt;/a&gt; extension.</source>
          <target state="translated">추가 된 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/ext/userauth/user-auth.txt&quot;&gt;사용자 인증&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="98eddc92334b847599f4ce6d60f53ec694b28ec8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.c&quot;&gt; source code&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.README&quot;&gt; documentation&lt;/a&gt; for the &lt;b&gt;genfkey&lt;/b&gt; program for automatically generating triggers to enforce foreign key constraints.</source>
          <target state="translated">외래 키 제약 조건을 적용하기 위해 트리거를 자동으로 생성 하기 위해 &lt;b&gt;genfkey&lt;/b&gt; 프로그램에 대한 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.c&quot;&gt;소스 코드&lt;/a&gt; 및 &lt;a href=&quot;http://www.sqlite.org/src/finfo?name=tool/genfkey.README&quot;&gt;문서&lt;/a&gt; 를 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="fb847b6e2ea32d443186a136c7cc13619b505325" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/anycollseq.c&quot;&gt;anycollseq.c&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that allows a generic SQLite database connection to read a schema that contains unknown and/or application-specific &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;.</source>
          <target state="translated">일반 SQLite 데이터베이스 연결이 알 수없는 및 / 또는 응용 프로그램 특정 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 를 포함하는 스키마를 읽을 수 있도록하는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/anycollseq.c&quot;&gt;anycollseq.c &lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;로드 가능 확장&lt;/a&gt; 을 추가했습니다. .</target>
        </trans-unit>
        <trans-unit id="7bcf45513f10ebd75a93f6b5b6e89e6063d27a70" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/explain.c&quot;&gt;explain virtual table&lt;/a&gt; as a run-time loadable extension.</source>
          <target state="translated">(가) 추가 된 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/explain.c&quot;&gt;가상 테이블을 설명&lt;/a&gt; 런타임로드 가능한 확장으로.</target>
        </trans-unit>
        <trans-unit id="b081bf5f1f1b82752017714981d03b1881cbb935" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fossildelta.c&quot;&gt;fossildelta.c&lt;/a&gt; extension that can create, apply, and deconstruct the &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/delta_format.wiki&quot;&gt;Fossil DVCS file delta format&lt;/a&gt; that is used by the &lt;a href=&quot;rbu&quot;&gt;RBU extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rbu&quot;&gt;RBU 확장자&lt;/a&gt; 가 사용 하는 &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/delta_format.wiki&quot;&gt;Fossil DVCS 파일 델타 형식&lt;/a&gt; 을 작성, 적용 및 구성 해제 할 수 있는 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fossildelta.c&quot;&gt;fossildelta.c&lt;/a&gt; 확장자가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1c17244cfd78fdd7f17b6be947bca36290283497" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/normalize.c&quot;&gt;sqlite3_normalize()&lt;/a&gt; extension function.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/normalize.c&quot;&gt;sqlite3_normalize ()&lt;/a&gt; 확장 기능을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="759f9c17eb2b892ce355010ec281cce2d5bc2292" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;swarm virtual table&lt;/a&gt; to the existing union virtual table extension.</source>
          <target state="translated">추가 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/unionvtab.c&quot;&gt;떼 가상 테이블을&lt;/a&gt; 기존의 노동 조합 가상 테이블 확장에.</target>
        </trans-unit>
        <trans-unit id="b331aec1305fafaaca20c2db450d1ed83b8ce70e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/ext/session/changesetfuzz.c&quot;&gt;changesetfuzz.c&lt;/a&gt; test-case generator utility.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/src/file/ext/session/changesetfuzz.c&quot;&gt;changesetfuzz.c&lt;/a&gt; 테스트 케이스 생성기 유틸리티를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6ce84b6020b5a29dc39d3e75ab7c42a1088a870c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://sqlite.org/src/file/src/dbpage.c&quot;&gt;sqlite_dbpage virtual table&lt;/a&gt; for providing direct access to pages of the database file. The source code is built into the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt; and is activated using the &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;-DSQLITE_ENABLE_DBPAGE_VTAB&lt;/a&gt; compile-time option.</source>
          <target state="translated">데이터베이스 파일의 페이지에 직접 액세스 할 수 있도록 &lt;a href=&quot;https://sqlite.org/src/file/src/dbpage.c&quot;&gt;sqlite_dbpage 가상 테이블&lt;/a&gt; 을 추가했습니다 . 소스 코드는 &lt;a href=&quot;amalgamation&quot;&gt;통합에&lt;/a&gt; 내장되어 있으며 &lt;a href=&quot;compile#enable_dbpage_vtab&quot;&gt;-DSQLITE_ENABLE_DBPAGE_VTAB를&lt;/a&gt; 사용하여 활성화됩니다. 컴파일 타임 옵션을 .</target>
        </trans-unit>
        <trans-unit id="c2442f1bc55ec77c692e59556f169e49a895d4fc" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/artifact/d7cc99350?ln=403-443&quot;&gt;sqlite3rbu_bp_progress()&lt;/a&gt; interface to the &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;https://www.sqlite.org/src/artifact/d7cc99350?ln=403-443&quot;&gt;sqlite3rbu_bp_progress ()&lt;/a&gt; 받는 인터페이스 &lt;a href=&quot;rbu&quot;&gt;RBU의&lt;/a&gt; 확장을.</target>
        </trans-unit>
        <trans-unit id="9465d7ab14adb931b5593d0471021aeb683a5ed7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/artifact/f971962e92ebb8b0&quot;&gt;eval.c&lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt; that implements an eval() SQL function that will recursively evaluate SQL.</source>
          <target state="translated">SQL을 재귀 적으로 평가할 eval () SQL 함수를 구현하는 &lt;a href=&quot;https://www.sqlite.org/src/artifact/f971962e92ebb8b0&quot;&gt;eval.c &lt;/a&gt;&lt;a href=&quot;loadext&quot;&gt;로드 가능 확장&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="23f6d845a0f388b044a8b1c50b1667ba4a60cc2c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;remember(V,PTR)&lt;/a&gt; SQL function as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">추가 된 &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/remember.c&quot;&gt;기억 (V, PTR)&lt;/a&gt; A와 SQL 함수를 &lt;a href=&quot;loadext&quot;&gt;로드 할 수있는 확장&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="425b7d13c017ba95b58d6a07a030a87fd80839e1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/sha1.c&quot;&gt;sha1.c&lt;/a&gt; extension.</source>
          <target state="translated">&lt;a href=&quot;https://www.sqlite.org/src/file/ext/misc/sha1.c&quot;&gt;sha1.c&lt;/a&gt; 확장을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="8e99c060c956cad10a0ae2061ee04da178be3f84" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;imposter#dotimposter&quot;&gt;.imposter dot-command&lt;/a&gt; to the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 줄 셸에 &lt;/a&gt;&lt;a href=&quot;imposter#dotimposter&quot;&gt;.imposter 도트 명령&lt;/a&gt; 을 추가했습니다. .</target>
        </trans-unit>
        <trans-unit id="727f21d6dc5af5ea8308f45987497ba8687f21e0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jgrouparray&quot;&gt;json_group_array()&lt;/a&gt; and &lt;a href=&quot;json1#jgroupobject&quot;&gt;json_group_object()&lt;/a&gt; SQL functions in the &lt;a href=&quot;json1#jmini&quot;&gt;json&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;json1#jgrouparray&quot;&gt;json_group_array ()&lt;/a&gt; 및 &lt;a href=&quot;json1#jgroupobject&quot;&gt;json_group_object ()&lt;/a&gt; 에서 SQL 함수 &lt;a href=&quot;json1#jmini&quot;&gt;JSON의&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="1bb5ebb2b769f13a8af1db1abb9a9158e890bf67" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jpatch&quot;&gt;json_patch()&lt;/a&gt; SQL function to the &lt;a href=&quot;json1&quot;&gt;JSON1 extension&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;json1#jpatch&quot;&gt;json_patch ()&lt;/a&gt; 받는 SQL 기능 &lt;a href=&quot;json1&quot;&gt;JSON1 확장을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a094211337515c1dc028d6f9e6cf2117139fbc0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;json1#jquote&quot;&gt;json_quote()&lt;/a&gt; SQL function to &lt;a href=&quot;json1&quot;&gt;the json1 extension&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;json1#jquote&quot;&gt;json_quote ()&lt;/a&gt; 에 SQL 기능 &lt;a href=&quot;json1&quot;&gt;json1 확장을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d18b3be87f155b2457df15bacd3dd11c3e674d5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr()&lt;/a&gt; SQL function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#instr&quot;&gt;instr ()&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="247064f74dbe4b79f59940594bcda97f277a43f3" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#likely&quot;&gt;likely(X)&lt;/a&gt; SQL function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#likely&quot;&gt;가능성이 (X)&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bac96e190aeab6b4919769c4f3fd24dfbe89ae73" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf()&lt;/a&gt; SQL function.</source>
          <target state="translated">&lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf ()&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d60a43dfdb6c9e0039a4d0aa4f120238cb346854" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely()&lt;/a&gt; and &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood()&lt;/a&gt; SQL functions to be used as hints to the query planner.</source>
          <target state="translated">쿼리 플래너에 힌트로 사용할 &lt;a href=&quot;lang_corefunc#unlikely&quot;&gt;unlikely ()&lt;/a&gt; 및 &lt;a href=&quot;lang_corefunc#likelihood&quot;&gt;likelihood ()&lt;/a&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="bb0ee30e9ce216eed1bab03b1463da8795ac409d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_expr#match&quot;&gt;MATCH&lt;/a&gt; operator.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#match&quot;&gt;경기&lt;/a&gt; 추가 연산자를 .</target>
        </trans-unit>
        <trans-unit id="afa2810329e9d36a72775faefe7a4b187615efbd" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; 명령 추가</target>
        </trans-unit>
        <trans-unit id="47f839667c95acc5a008254deb814f5fd2e72e82" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; for a speed improvement in excess of 15% on some workloads. (Your mileage may vary.)</source>
          <target state="translated">일부 워크로드에서 속도가 15 % 이상 향상 되도록 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당자를&lt;/a&gt; 추가했습니다 . (귀하의 마일리지가 다를 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ca85bb0b52986a81e52b50ef04e5ef298fc1ebdf" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt; to the query planner.</source>
          <target state="translated">쿼리 플래너에 &lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화&lt;/a&gt; 를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="c52772fca787badd301bbb28489a51e6b2c18437" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_busy_timeout&quot;&gt;busy_timeout pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="acf053bb493580f8d76bf2fe4425a6ee95eb3b00" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;cache_spill pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_cache_spill&quot;&gt;cache_spill pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="7028868fffc72a85c59d3c3b9112eb23b4ec033e" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check&lt;/a&gt; command for better and earlier detection of database file corruption.</source>
          <target state="translated">데이터베이스 파일 손상의 조기 발견을 위해 &lt;a href=&quot;pragma#pragma_cell_size_check&quot;&gt;PRAGMA cell_size_check&lt;/a&gt; 명령을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="f60e6b13f01cdd96d811863e696687470fe6d7c1" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; command that can be used to determine if a database file has been modified by another process.</source>
          <target state="translated">데이터베이스 파일이 다른 프로세스에 의해 수정되었는지 확인하는 데 사용할 수있는 &lt;a href=&quot;pragma#pragma_data_version&quot;&gt;PRAGMA data_version&lt;/a&gt; 명령이 추가 되었습니다.</target>
        </trans-unit>
        <trans-unit id="6dc9cd4f3681e1d6bfff801310b10819f9c239c5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys pragma&lt;/a&gt; and the &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt;(db, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS&lt;/a&gt;,...) C-language interface.</source>
          <target state="translated">추가 &lt;a href=&quot;pragma#pragma_defer_foreign_keys&quot;&gt;defer_foreign_keys 프라그&lt;/a&gt; 와 &lt;a href=&quot;c3ref/db_status&quot;&gt;sqlite3_db_status&lt;/a&gt; (dB, &lt;a href=&quot;c3ref/c_dbstatus_options#sqlitedbstatusdeferredfks&quot;&gt;SQLITE_DBSTATUS_DEFERRED_FKS을&lt;/a&gt; , ...) C 언어 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="9260575fd05ff275b40b928c8ff145c26653a33b" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_foreign_key_check&quot;&gt;PRAGMA foreign_key_check&lt;/a&gt; 명령이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fd33bca500a56cb70a0e4189db705ce4c14918ef" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;PRAGMA index_xinfo&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_index_xinfo&quot;&gt;PRAGMA index_xinfo&lt;/a&gt; 명령이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d2cb1ad431d49ff1624974b470ad507e7e6aade5" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; command, which if enabled causes the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command to behave like older version of SQLite (prior to version 3.25.0) for compatibility.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_legacy_alter_table&quot;&gt;PRAGMA legacy_alter_table&lt;/a&gt; 명령이 추가되었습니다.이 명령을 사용하면 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령이 이전 버전의 SQLite (3.23.2 이전 버전)와 같이 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="241f9aa0870d7629a649c6fcf7aff48add9bd27d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; command</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize&lt;/a&gt; 명령 추가</target>
        </trans-unit>
        <trans-unit id="522f4f5023f50f82e4cb75d28460040b08ac77c8" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;PRAGMA page_count&lt;/a&gt; command.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_page_count&quot;&gt;PRAGMA page_count&lt;/a&gt; 명령을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="181f42a6c7e001d819f97d8ba8bb1793d0d0a062" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; PRAGMA for returning the size of the underlying database file in pages.</source>
          <target state="translated">기본 데이터베이스 파일의 크기를 페이지로 반환하기 위해 &lt;a href=&quot;pragma#pragma_page_count&quot;&gt;page_count&lt;/a&gt; PRAGMA를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b0186fd0e400893a1b30b7508e00203dc47dcbd7" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_query_only&quot;&gt;query_only pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_query_only&quot;&gt;query_only pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="8f14ae05567f16f27c2ce37117eaac6068a50a87" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;reverse_unordered_selects pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_reverse_unordered_selects&quot;&gt;reverse_unordered_selects pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="0623635bd786359d5b3e0fa8a8c82ab7ea0f9a41" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=FAST&lt;/a&gt; command. When secure_delete is set to FAST, old content is overwritten with zeros as long as that does not increase the amount of I/O. Deleted content might still persist on the &lt;a href=&quot;fileformat2#freelist&quot;&gt;free-page list&lt;/a&gt; but will be purged from all b-tree pages.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete = FAST&lt;/a&gt; 명령을 추가했습니다 . secure_delete가 FAST로 설정되면 I / O의 양을 늘리지 않는 한 오래된 컨텐츠를 0으로 겹쳐 씁니다. 삭제 된 컨텐츠는 여전히 사용 가능 &lt;a href=&quot;fileformat2#freelist&quot;&gt;페이지 목록&lt;/a&gt; 에 남아있을 수 있지만 모든 b- 트리 페이지에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="837b2abaf90eb53043c6e7f99d8293f985e4ea36" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;secure_delete pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6ed2f465aa832c05e440067dd7bf41e8a2ea7c7d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_soft_heap_limit&quot;&gt;soft_heap_limit pragma를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="6aa4735afedc1efa7a8fd6ef84be33fe2ae0da0d" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_stats&quot;&gt;PRAGMA stats&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_stats&quot;&gt;PRAGMA 통계&lt;/a&gt; 문을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="dda41fd88ccb8b6e627abcd4e0e1e198b532f161" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;PRAGMA vdbe_addoptrace&lt;/a&gt; and &lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;PRAGMA vdbe_debug&lt;/a&gt; commands.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_vdbe_addoptrace&quot;&gt;PRAGMA vdbe_addoptrace&lt;/a&gt; 및 &lt;a href=&quot;pragma#pragma_vdbe_debug&quot;&gt;PRAGMA vdbe_debug&lt;/a&gt; 명령이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="eca68a9d9e7785e54f4fcfc001732202953d934a" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;psow&quot;&gt;powersafe overwrite&lt;/a&gt; property to the VFS interface. Provide the &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; I/O capability, the &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;SQLITE_POWERSAFE_OVERWRITE&lt;/a&gt; compile-time option, and the &quot;psow=BOOLEAN&quot; query parameter for &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;psow&quot;&gt;powersafe 덮어 쓰기&lt;/a&gt; VFS에 인터페이스 속성을. 제공 &lt;a href=&quot;c3ref/c_iocap_atomic&quot;&gt;SQLITE_IOCAP_POWERSAFE_OVERWRITE&lt;/a&gt; I / O 기능의 &lt;a href=&quot;compile#powersafe_overwrite&quot;&gt;SQLITE_POWERSAFE_OVERWRITE&lt;/a&gt; 컴파일시 옵션 등에 대한 &quot;psow = BOOLEAN&quot;쿼리 매개 변수 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="04abd4bf7e803d987674de715233b44d21ad1237" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;rtree#rtreecheck&quot;&gt;rtreecheck()&lt;/a&gt; scalar SQL function to the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;a href=&quot;rtree#rtreecheck&quot;&gt;rtreecheck ()&lt;/a&gt; 받는 스칼라 SQL 함수 &lt;a href=&quot;rtree&quot;&gt;R-트리 확장을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc105b8ec07cf1f35ee3a44ebcb504b698c185e2" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;rtree#xquery&quot;&gt;sqlite3_rtree_query_callback()&lt;/a&gt; interface to &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;</source>
          <target state="translated">추가 &lt;a href=&quot;rtree#xquery&quot;&gt;sqlite3_rtree_query_callback ()&lt;/a&gt; 에 대한 인터페이스 &lt;a href=&quot;rtree&quot;&gt;R-트리 확장&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="39750cb3b229cd41fd745ee42224961db3f0e9a9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;session/c_changesetapply_invert&quot;&gt;SQLITE_CHANGESETAPPLY_INVERT&lt;/a&gt; flag</source>
          <target state="translated">&lt;a href=&quot;session/c_changesetapply_invert&quot;&gt;SQLITE_CHANGESETAPPLY_INVERT&lt;/a&gt; 플래그 추가</target>
        </trans-unit>
        <trans-unit id="be5c46b76747ab1af6431ca228fa917fafbc088c" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2()&lt;/a&gt; interface and the &lt;a href=&quot;session/c_changesetstart_invert&quot;&gt;SQLITE_CHANGESETSTART_INVERT&lt;/a&gt; flag.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_start&quot;&gt;sqlite3changeset_start_v2 ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;session/c_changesetstart_invert&quot;&gt;SQLITE_CHANGESETSTART_INVERT&lt;/a&gt; 플래그가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="bc1c498f90678af89842f0c30b1342851695eaf9" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff.exe&lt;/a&gt; utility program for computing the differences between two SQLite database files.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff.exe를&lt;/a&gt; 추가했습니다두 SQLite 데이터베이스 파일의 차이점을 계산하기 위해 유틸리티 프로그램을 .</target>
        </trans-unit>
        <trans-unit id="26e4d8fe0797614c479eea512419e56f330774a0" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT virtual table&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;stmt&quot;&gt;SQLITE_STMT 가상 테이블&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="7141a7f71545fdc2d8f0941a70f5d692420e5873" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;tclsqlite&quot;&gt;TCL Interface&lt;/a&gt;&lt;a href=&quot;tclsqlite#config&quot;&gt;config method&lt;/a&gt; in order to be able to disable &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; as well as control other &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt; options from TCL.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenableview&quot;&gt;SQLITE_DBCONFIG_ENABLE_VIEW&lt;/a&gt; 를 비활성화 하고 TCL에서 다른 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()&lt;/a&gt; 옵션을 제어 할 수 있도록 &lt;a href=&quot;tclsqlite&quot;&gt;TCL 인터페이스 &lt;/a&gt;&lt;a href=&quot;tclsqlite#config&quot;&gt;구성 방법&lt;/a&gt; 을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3034d006b7d037b3012d84d49eab4202967372ce" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;unionvtab&quot;&gt;UNION virtual table&lt;/a&gt; extension.</source>
          <target state="translated">추가 &lt;a href=&quot;unionvtab&quot;&gt;UNION 가상 테이블&lt;/a&gt; 확장.</target>
        </trans-unit>
        <trans-unit id="7d1fcdd4ec63f81664121b096c84af0efcd65365" translate="yes" xml:space="preserve">
          <source>Added the &lt;a href=&quot;vtab#colUsed&quot;&gt;colUsed field&lt;/a&gt; to &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; for use by the &lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;vtab#xbestindex&quot;&gt;sqlite3_module.xBestIndex&lt;/a&gt; 메소드 에서 사용 하기 위해 &lt;a href=&quot;vtab#colUsed&quot;&gt;colUsed 필드&lt;/a&gt; 를 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 에 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="abff860b551a8d132b543df75ebaabf23d9a1164" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;COPY&lt;/b&gt; command patterned after &lt;a href=&quot;http://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; so that SQLite can now read the output of the &lt;b&gt;pg_dump&lt;/b&gt; database dump utility of PostgreSQL.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;http://www.postgresql.org/&quot;&gt;PostgreSQL&lt;/a&gt; 의 &lt;b&gt;pg_dump&lt;/b&gt; 데이터베이스 덤프 유틸리티의 출력을 읽을 수 있도록 PostgreSQL 이후에 패턴 화 된 &lt;b&gt;COPY&lt;/b&gt; 명령을 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="e304ab36743ecbc720ac93786500ba376598ce88" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;LIKE&lt;/b&gt; operator.</source>
          <target state="translated">&lt;b&gt;LIKE&lt;/b&gt; 연산자를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="e12e3e86e8d93c49072339ca4e285a481d50fb9d" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;last_insert_rowid()&lt;/b&gt; SQL function.</source>
          <target state="translated">&lt;b&gt;last_insert_rowid ()&lt;/b&gt; SQL 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3193cf97b99861e9e104fce03f06019602ead587" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_..._printf()&lt;/b&gt; interface routines.</source>
          <target state="translated">추가 &lt;b&gt;sqlite가 _..._의 printf ()&lt;/b&gt; 인터페이스 루틴을.</target>
        </trans-unit>
        <trans-unit id="043d356fd73cb171db8858f0f5622b884db88636" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_busy_handler()&lt;/b&gt; and &lt;b&gt;sqlite_busy_timeout()&lt;/b&gt; interface.</source>
          <target state="translated">&lt;b&gt;sqlite_busy_handler ()&lt;/b&gt; 및 &lt;b&gt;sqlite_busy_timeout ()&lt;/b&gt; 인터페이스가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e9ea8f321d97c10573a695234e9878da4617c5e5" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_changes()&lt;/b&gt; API function to return the number of row that changed in the most recent operation.</source>
          <target state="translated">가장 최근 작업에서 변경된 행 수를 반환하기 위해 &lt;b&gt;sqlite_changes ()&lt;/b&gt; API 함수를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b8527c0256e1df6259b3b96966c858732fd00e5f" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_get_table()&lt;/b&gt; API</source>
          <target state="translated">추가 &lt;b&gt;sqlite_get_table ()&lt;/b&gt; API를</target>
        </trans-unit>
        <trans-unit id="998f6cbca04b2d05276533a7914bab3fa482581f" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_interrupt()&lt;/b&gt; interface.</source>
          <target state="translated">&lt;b&gt;sqlite_interrupt ()&lt;/b&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="a71daae0bfba6e902831cbd84539462138fb543a" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_open_aux_file()&lt;/b&gt; API, though it is still mostly undocumented and untested.</source>
          <target state="translated">&lt;b&gt;sqlite_open_aux_file ()&lt;/b&gt; API가 추가 되었지만 여전히 대부분 문서화되지 않고 테스트되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="04ac72f388de3cc88954c42e0e92ea3b9fd55074" translate="yes" xml:space="preserve">
          <source>Added the &lt;b&gt;sqlite_set_authorizer()&lt;/b&gt; API. Formal documentation has not been written - see the source code comments for instructions on how to use this function.</source>
          <target state="translated">&lt;b&gt;sqlite_set_authorizer ()&lt;/b&gt; API를 추가했습니다 . 공식 문서는 작성되지 않았습니다.이 기능을 사용하는 방법에 대한 지침은 소스 코드 주석을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03c76f9466cfa8b45c7eef759eaf4885a10cbd2e" translate="yes" xml:space="preserve">
          <source>Added the &lt;em&gt;experimental&lt;/em&gt;&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get()&lt;/a&gt;, &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open()&lt;/a&gt;, and &lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free()&lt;/a&gt; interfaces. These are subject to change or removal in a subsequent release.</source>
          <target state="translated">추가 &lt;em&gt;실험 &lt;/em&gt;&lt;a href=&quot;c3ref/snapshot_get&quot;&gt;sqlite3_snapshot_get ()&lt;/a&gt; , &lt;a href=&quot;c3ref/snapshot_open&quot;&gt;sqlite3_snapshot_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/snapshot_free&quot;&gt;sqlite3_snapshot_free ()&lt;/a&gt; 인터페이스. 후속 릴리스에서는 변경되거나 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb8960036bc5202bda42674d6c0203a6bd0c46dd" translate="yes" xml:space="preserve">
          <source>Added the ANALYZE command for gathering statistics on indices and using those statistics when picking an index in the optimizer</source>
          <target state="translated">인덱스에서 통계를 수집하고 옵티 마이저에서 인덱스를 선택할 때 해당 통계를 사용하기위한 ANALYZE 명령이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e76828fc2ef742c439bfc84df1818b198b243eeb" translate="yes" xml:space="preserve">
          <source>Added the ATTACH and DETACH commands to allow interacting with multiple database files at the same time.</source>
          <target state="translated">여러 데이터베이스 파일과 동시에 상호 작용할 수 있도록 ATTACH 및 DETACH 명령을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="648b7548b08d3433a571e65bdfcce48f0369af0b" translate="yes" xml:space="preserve">
          <source>Added the COUNT_CHANGES pragma.</source>
          <target state="translated">COUNT_CHANGES 개의 pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="0a82f263a7163cc945f7a54766155ffe5bad18eb" translate="yes" xml:space="preserve">
          <source>Added the EMPTY_RESULT_CALLBACKS pragma</source>
          <target state="translated">EMPTY_RESULT_CALLBACKS pragma 추가</target>
        </trans-unit>
        <trans-unit id="adf9996aa89891e17522dba8a3b313501dd38637" translate="yes" xml:space="preserve">
          <source>Added the ESCAPE clause on the LIKE operator.</source>
          <target state="translated">LIKE 연산자에 ESCAPE 절을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="f305242a3191cbfb5aec027e3852204245b42cf2" translate="yes" xml:space="preserve">
          <source>Added the FULL_COLUMN_NAMES pragma. When set to &quot;ON&quot;, the names of columns are reported back as TABLE.COLUMN instead of just COLUMN.</source>
          <target state="translated">FULL_COLUMN_NAMES pragma를 추가했습니다. &quot;ON&quot;으로 설정하면 열 이름이 COLUMN 대신 TABLE.COLUMN으로 다시보고됩니다.</target>
        </trans-unit>
        <trans-unit id="bc9f140f4e869766b8cc9921a38bfc1214b22f28" translate="yes" xml:space="preserve">
          <source>Added the SANITY_CHECK pragma.</source>
          <target state="translated">SANITY_CHECK pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="ab67de0b2fcd45ff0f66e746a10daf00336c46a1" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_MIXED_ENDIAN_64BIT_FLOAT compile-time option to support ARM7 processors with goofy endianness.</source>
          <target state="translated">구피 엔디안으로 ARM7 프로세서를 지원하기 위해 SQLITE_MIXED_ENDIAN_64BIT_FLOAT 컴파일 타임 옵션을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="8512503a8a6ee6ac4c42b6ec6960124aa1141343" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_READONLY_ROLLBACK extended error code for when a database cannot be opened because it needs rollback recovery but is read-only.</source>
          <target state="translated">롤백 복구가 필요하지만 읽기 전용이므로 데이터베이스를 열 수없는 경우에 대한 SQLITE_READONLY_ROLLBACK 확장 오류 코드를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="d860363ab44e2e09ecb05e55d177bb6e0cc5efda" translate="yes" xml:space="preserve">
          <source>Added the SQLITE_UINT64_TYPE compile-time option as an analog to SQLITE_INT64_TYPE.</source>
          <target state="translated">SQLITE_INT64_TYPE과 유사하게 SQLITE_UINT64_TYPE 컴파일 타임 옵션이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0dc2a114a80ab21b7a59a0682328a2000b97132e" translate="yes" xml:space="preserve">
          <source>Added the SYNCHRONOUS pragma</source>
          <target state="translated">동기식 pragma 추가</target>
        </trans-unit>
        <trans-unit id="f2840998df920dfd1ea272df7b05ff7b737d636e" translate="yes" xml:space="preserve">
          <source>Added the TABLE_INFO() and INDEX_INFO() pragmas to help support the ODBC interface.</source>
          <target state="translated">ODBC 인터페이스를 지원하기 위해 TABLE_INFO () 및 INDEX_INFO () pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="55b81f73060b913ff9ec244fef4f2242a8077314" translate="yes" xml:space="preserve">
          <source>Added the TRUNCATE option to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode에&lt;/a&gt; TRUNCATE 옵션을 추가했습니다</target>
        </trans-unit>
        <trans-unit id="01a5050102a4554f6884185179621e32222f113e" translate="yes" xml:space="preserve">
          <source>Added the ability to &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; an &lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed&lt;/a&gt; database.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH-ed&lt;/a&gt; 데이터베이스 를 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="06c38c134cf06def71bdb05238df7b454e3474fe" translate="yes" xml:space="preserve">
          <source>Added the ability to link against the &quot;&lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt;&quot; command-line editing library in unix builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 의 유닉스 빌드에서 &quot; &lt;a href=&quot;https://github.com/antirez/linenoise&quot;&gt;linenoise&lt;/a&gt; &quot;명령 행 편집 라이브러리에 링크하는 기능이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="64b8cf9d4fd6b2c51e94a6a6f014fcfd569e941f" translate="yes" xml:space="preserve">
          <source>Added the ability to resolve constraint conflicts is ways other than an abort and rollback. See the documentation on the &quot;ON CONFLICT&quot; clause for details.</source>
          <target state="translated">제약 조건 충돌을 해결하는 기능은 중단 및 롤백 이외의 방법입니다. 자세한 내용은 &quot;ON CONFLICT&quot;절의 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f101692603c49e55897cc1b0a0872864ceef28cd" translate="yes" xml:space="preserve">
          <source>Added the ability to specify &quot;*&quot; as part of a larger column list in the result section of a SELECT statement. For example:</source>
          <target state="translated">SELECT 문의 결과 섹션에서 더 큰 열 목록의 일부로 &quot;*&quot;를 지정하는 기능이 추가되었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9da37dd2277aa54e92101d7aa5cc21a4b4b41b35" translate="yes" xml:space="preserve">
          <source>Added the concatenate string operator (||)</source>
          <target state="translated">연결 문자열 연산자 (||)를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="8781e73412ec3dcdbe8ddfaabe88ccd47d652415" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;cli#expert&quot;&gt;.expert command&lt;/a&gt;</source>
          <target state="translated">실험적인 &lt;a href=&quot;cli#expert&quot;&gt;.expert 명령&lt;/a&gt; 추가</target>
        </trans-unit>
        <trans-unit id="0fc342be926b0820e09fb4675d0d305018e3e35d" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension. Note that this extension is experimental and subject to change in incompatible ways.</source>
          <target state="translated">실험적인 &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; 확장을 추가했습니다. 이 확장 프로그램은 실험용이며 호환되지 않는 방식으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10d4e217a57507e7cf4bdc496b8ef5f7cdbf4429" translate="yes" xml:space="preserve">
          <source>Added the experimental &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; extension. Note that this extension is experimental and subject to change in incompatible ways.</source>
          <target state="translated">실험적인 &lt;a href=&quot;rbu&quot;&gt;RBU&lt;/a&gt; 확장을 추가했습니다. 이 확장 프로그램은 실험용이며 호환되지 않는 방식으로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd32bd379fd1ee1dbe9dd7bcac2b99d55f0988b" translate="yes" xml:space="preserve">
          <source>Added the experimental and undocumented EXPLAIN QUERY PLAN capability</source>
          <target state="translated">실험적이고 문서화되지 않은 EXPLAIN QUERY PLAN 기능 추가</target>
        </trans-unit>
        <trans-unit id="bbf7af11f593a05578593b77e950de9d08708237" translate="yes" xml:space="preserve">
          <source>Added the experimental malloc-free memory allocator in mem3.c.</source>
          <target state="translated">mem3.c에 실험적인 malloc-free 메모리 할당자를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="5c30e3baaca4fbdcfb24a460d6ac28afed94f059" translate="yes" xml:space="preserve">
          <source>Added the fcnt() function to the SQL interpreter. The fcnt() function returns the number of database &quot;Fetch&quot; operations that have occurred. This function is designed for use in test scripts to verify that queries are efficient and appropriately optimized. Fcnt() has no other useful purpose, as far as I know.</source>
          <target state="translated">SQL 인터프리터에 fcnt () 함수를 추가했습니다. fcnt () 함수는 발생한 데이터베이스 &quot;페치&quot;조작 수를 리턴합니다. 이 기능은 쿼리가 효율적이고 적절하게 최적화되었는지 확인하기 위해 테스트 스크립트에서 사용하도록 설계되었습니다. Fcnt ()는 내가 아는 한 다른 유용한 목적이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7a58a2fc5a5367d63f94f8275791e299dd75eb74" translate="yes" xml:space="preserve">
          <source>Added the fsdir(PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued function&lt;/a&gt; to the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; extension, for listing the files in a directory.</source>
          <target state="translated">디렉토리에 파일을 나열하기 위해 fsdir (PATH) &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 반환 함수&lt;/a&gt; 를 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/fileio.c&quot;&gt;fileio.c&lt;/a&gt; 확장자에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="17d23ff1e41223a23eed74ee1f278a16171c0953" translate="yes" xml:space="preserve">
          <source>Added the fullfsync pragma.</source>
          <target state="translated">fullfsync pragma를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c8e37096ddd5586a6257d3283c3c1a2dfcb73ea7" translate="yes" xml:space="preserve">
          <source>Added the new &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain(S)&lt;/a&gt; interface for determining whether or not a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; is an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 인지 여부를 판별하기 위해 새로운 &lt;a href=&quot;c3ref/stmt_isexplain&quot;&gt;sqlite3_stmt_isexplain (S)&lt;/a&gt; 인터페이스를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="4d5a2b0e9f488226eecba61aa448d45b4ae4e1d9" translate="yes" xml:space="preserve">
          <source>Added the new &lt;a href=&quot;tclsqlite#bind_fallback&quot;&gt;bind_fallback method&lt;/a&gt;.</source>
          <target state="translated">새로운 &lt;a href=&quot;tclsqlite#bind_fallback&quot;&gt;bind_fallback 메소드를&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="698d2bae74641dc2312ecf24ccb34bdaf37e3654" translate="yes" xml:space="preserve">
          <source>Added the new &lt;b&gt;SQLITE_TEMP_MASTER&lt;/b&gt; table which records the schema for temporary tables in the same way that &lt;b&gt;SQLITE_MASTER&lt;/b&gt; does for persistent tables.</source>
          <target state="translated">&lt;b&gt;SQLITE_MASTER&lt;/b&gt; 가 영속 테이블에 대해 수행 하는 것과 동일한 방식으로 임시 테이블에 대한 스키마를 기록 하는 새로운 &lt;b&gt;SQLITE_TEMP_MASTER&lt;/b&gt; 테이블을 추가했습니다 .&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="f8314265965cb9729309aa3a47d77b4ebbd0dc84" translate="yes" xml:space="preserve">
          <source>Added the new &lt;b&gt;sqlite_last_insert_rowid()&lt;/b&gt; API function.</source>
          <target state="translated">새로운 &lt;b&gt;sqlite_last_insert_rowid ()&lt;/b&gt; API 함수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f36e59151eae3a6b62bf13680d5957b9ac83ad96" translate="yes" xml:space="preserve">
          <source>Added the new interface &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_msize()&lt;/a&gt; that returns the size of a memory allocation obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt; and its variants.</source>
          <target state="translated">&lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64 ()&lt;/a&gt; 및 해당 변형 에서 얻은 메모리 할당 크기를 반환 하는 새로운 인터페이스 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_msize ()&lt;/a&gt; 가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="49d6fc07cdd58d69c1061156379f31f91815e6f2" translate="yes" xml:space="preserve">
          <source>Added the new sqlite3_bind_parameter_name() interface.</source>
          <target state="translated">새로운 sqlite3_bind_parameter_name () 인터페이스가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="294074eb5cc5a602340ff9920845209bc774b64a" translate="yes" xml:space="preserve">
          <source>Added the optional &lt;a href=&quot;asyncvfs&quot;&gt;asynchronous VFS&lt;/a&gt; module.</source>
          <target state="translated">선택적 &lt;a href=&quot;asyncvfs&quot;&gt;비동기식 VFS&lt;/a&gt; 모듈을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d2ff57d315c3b6f550eb4477360be1d9ece1af4e" translate="yes" xml:space="preserve">
          <source>Added the remove_diacritics=2 option to &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 및 &lt;a href=&quot;fts5&quot;&gt;FTS5에&lt;/a&gt; remove_diacritics = 2 옵션을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="5543829232c2352604477be7d98b18681931c4e6" translate="yes" xml:space="preserve">
          <source>Added the sqlite3_db_handle() API</source>
          <target state="translated">sqlite3_db_handle () API 추가</target>
        </trans-unit>
        <trans-unit id="31ca3dd4e3255f6b9042e4416d3da3cdbcd74a82" translate="yes" xml:space="preserve">
          <source>Added the sqlite3_get_autocommit() API</source>
          <target state="translated">sqlite3_get_autocommit () API 추가</target>
        </trans-unit>
        <trans-unit id="01da972e948cd498d37d659567824ec295b8ab3b" translate="yes" xml:space="preserve">
          <source>Added the sqlite_encode_binary() and sqlite_decode_binary() functions to the source tree. But they are not yet linked into the library.</source>
          <target state="translated">sqlite_encode_binary () 및 sqlite_decode_binary () 함수를 소스 트리에 추가했습니다. 그러나 그들은 아직 도서관에 연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b7931525b0f49699c8919c663442c12cd2042a1" translate="yes" xml:space="preserve">
          <source>Added the subquery flattening optimizer.</source>
          <target state="translated">하위 쿼리 병합 최적화 도구를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c7b7e1fb260a3da09d3b883f4ceb3d8fea98b06f" translate="yes" xml:space="preserve">
          <source>Added the test_multiplex.c module which provides an example VFS that provides multiplexing (sharding) of a DB, splitting it over multiple files of fixed size.</source>
          <target state="translated">DB의 멀티플렉싱 (샤딩)을 제공하고 고정 크기의 여러 파일로 분할하는 예제 VFS를 제공하는 test_multiplex.c 모듈을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="ae0013cb7d834fd47edf840654f5d38cdca51233" translate="yes" xml:space="preserve">
          <source>Added the test_regexp.c module as a demonstration of how to implement the REGEXP operator.</source>
          <target state="translated">REGEXP 연산자를 구현하는 방법을 보여주는 test_regexp.c 모듈을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="32a49834c953fbdb6828ba126355f3f55173d44b" translate="yes" xml:space="preserve">
          <source>Added the test_superlock.c module which provides example code for obtaining an exclusive lock to a rollback or WAL database.</source>
          <target state="translated">롤백 또는 WAL 데이터베이스에 대한 독점 잠금을 얻기위한 예제 코드를 제공하는 test_superlock.c 모듈이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="09972935bcd9fee093e7ba1782e40d68896023ca" translate="yes" xml:space="preserve">
          <source>Added the win32-longpath VFS on windows, permitting filenames up to 32K characters in length.</source>
          <target state="translated">Windows에 win32-longpath VFS를 추가하여 최대 32K 자의 파일 이름을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f94f686ce38728ef2b6f0370975b863c680811c8" translate="yes" xml:space="preserve">
          <source>Added the xGetLastError() method to &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; for returning filesystem-specific error messages and error codes back to SQLite.</source>
          <target state="translated">파일 시스템 별 오류 메시지 및 오류 코드를 다시 SQLite로 리턴 하기 위해 xGetLastError () 메소드를 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 에 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="7f5e4ed0c375fbca2b5b605896122a1929784c92" translate="yes" xml:space="preserve">
          <source>Added two new C-language interfaces: &lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_expanded_sql()&lt;/a&gt; and &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2()&lt;/a&gt;. These new interfaces subsume the functions of &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; and &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile()&lt;/a&gt; which are now deprecated.</source>
          <target state="translated">&lt;a href=&quot;c3ref/expanded_sql&quot;&gt;sqlite3_expanded_sql ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/trace_v2&quot;&gt;sqlite3_trace_v2 ()의&lt;/a&gt; 두 가지 새로운 C 언어 인터페이스가 추가되었습니다 . 이 새로운 인터페이스 는 현재 사용되지 않는 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 의 기능을 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="82207d09f92cb6fda6e84b7a4f36383b773b1975" translate="yes" xml:space="preserve">
          <source>Added two new experimental functions: &lt;a href=&quot;lang_expr#randomblobFunc&quot;&gt;randomBlob()&lt;/a&gt; and &lt;a href=&quot;lang_expr#hexFunc&quot;&gt;hex()&lt;/a&gt;. Their intended use is to facilitate generating &lt;a href=&quot;http://en.wikipedia.org/wiki/UUID&quot;&gt;UUIDs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_expr#randomblobFunc&quot;&gt;randomBlob ()&lt;/a&gt; 과 &lt;a href=&quot;lang_expr#hexFunc&quot;&gt;hex ()&lt;/a&gt; 두 가지 새로운 실험 함수가 추가되었습니다 . 의도 된 용도는 &lt;a href=&quot;http://en.wikipedia.org/wiki/UUID&quot;&gt;UUID&lt;/a&gt; 생성을 용이하게하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="738e6cc3217ca2553bb9e0d6d54a155cd0ad0e85" translate="yes" xml:space="preserve">
          <source>Added verbs &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatuspagecachesize&quot;&gt;SQLITE_STATUS_PAGECACHE_SIZE&lt;/a&gt; and &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusscratchsize&quot;&gt;SQLITE_STATUS_SCRATCH_SIZE&lt;/a&gt; to the &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatuspagecachesize&quot;&gt;SQLITE_STATUS_PAGECACHE_SIZE&lt;/a&gt; 및 &lt;a href=&quot;c3ref/c_status_malloc_count#sqlitestatusscratchsize&quot;&gt;SQLITE_STATUS_SCRATCH_SIZE&lt;/a&gt; 동사 를 &lt;a href=&quot;c3ref/status&quot;&gt;sqlite3_status ()&lt;/a&gt; 인터페이스에 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c680515f169f90f11c5dd355902aaea8ab7434ee" translate="yes" xml:space="preserve">
          <source>Adding anything to null gives null</source>
          <target state="translated">null에 아무것도 추가하면 null이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb59cdfe69dfa59c552601b0c1f3bb462cce88b5" translate="yes" xml:space="preserve">
          <source>Adding new auxiliary functions implemented in C, and</source>
          <target state="translated">C로 구현 된 새로운 보조 기능 추가</target>
        </trans-unit>
        <trans-unit id="f056b3609aae2fc232cd7cd2146d49c24a7d20cd" translate="yes" xml:space="preserve">
          <source>Adding new tokenizers, also implemented in C.</source>
          <target state="translated">C에서 구현 된 새로운 토크 나이저 추가</target>
        </trans-unit>
        <trans-unit id="6889504fdc32a6b06fe8b6bcc4bddeee9d4dd115" translate="yes" xml:space="preserve">
          <source>Adding optional features like &lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt;, &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt;, or &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; will increase the size of the library, obviously.</source>
          <target state="translated">&lt;a href=&quot;compile#enable_json1&quot;&gt;-DSQLITE_ENABLE_JSON1&lt;/a&gt; , &lt;a href=&quot;compile#enable_fts5&quot;&gt;-DSQLITE_ENABLE_FTS5&lt;/a&gt; 또는 &lt;a href=&quot;compile#enable_rtree&quot;&gt;-DSQLITE_ENABLE_RTREE&lt;/a&gt; 와 같은 선택적 기능을 추가 하면 라이브러리 크기가 커집니다.</target>
        </trans-unit>
        <trans-unit id="96d5a0933a519ba202a444bedd7df31dcc598d63" translate="yes" xml:space="preserve">
          <source>Adding to Zip</source>
          <target state="translated">Zip에 추가</target>
        </trans-unit>
        <trans-unit id="c1cc55a80b36a00837a2ba9fccba63e4cde092d5" translate="yes" xml:space="preserve">
          <source>Additional OS/2 updates</source>
          <target state="translated">추가 OS / 2 업데이트</target>
        </trans-unit>
        <trans-unit id="92dafa949d6bc0b1375a028d351e58c914e80e5e" translate="yes" xml:space="preserve">
          <source>Additional application-specific collating functions can be added to SQLite using the &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface.</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; 인터페이스를 사용하여 추가 응용 프로그램 별 조합 함수를 SQLite에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f27c7e9f8642590f605d8547ee9d3195fc42ee26" translate="yes" xml:space="preserve">
          <source>Additional background information is available in the &lt;a href=&quot;queryplanner&quot;&gt;indexing tutorial&lt;/a&gt; document.</source>
          <target state="translated">추가 배경 정보는 &lt;a href=&quot;queryplanner&quot;&gt;색인 작성 자습서&lt;/a&gt; 문서 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2c99c8da41f3c9e92b76081bdd22fd42577b1a01" translate="yes" xml:space="preserve">
          <source>Additional documentation is available &lt;a href=&quot;cli&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">추가 설명서는 &lt;a href=&quot;cli&quot;&gt;여기에 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="00b84c5eeb4233a176f6bc28e3bd04baf2d28fa4" translate="yes" xml:space="preserve">
          <source>Additional documentation on Fossil can be found at &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&lt;/a&gt;</source>
          <target state="translated">화석에 대한 추가 문서는 &lt;a href=&quot;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&quot;&gt;https://fossil-scm.org/fossil/doc/trunk/www/permutedindex.html&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="317e6d6c624cc48cb4d511774ceb090affd1ec71" translate="yes" xml:space="preserve">
          <source>Additional fixes for issues detected by &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSSFuzz&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSSFuzz에서&lt;/a&gt; 감지 된 문제에 대한 추가 수정 사항 :</target>
        </trans-unit>
        <trans-unit id="911a0b354b810ade1b41221cd419095a4767144e" translate="yes" xml:space="preserve">
          <source>Additional information</source>
          <target state="translated">추가 정보</target>
        </trans-unit>
        <trans-unit id="92a863bb50cbb4e362af4fa066e5c6af932cb4b2" translate="yes" xml:space="preserve">
          <source>Additional information about datatypes in SQLite version 3.0 is available &lt;a href=&quot;datatype3&quot;&gt;separately&lt;/a&gt;.</source>
          <target state="translated">SQLite 버전 3.0의 데이터 유형에 대한 추가 정보는 &lt;a href=&quot;datatype3&quot;&gt;별도로&lt;/a&gt; 제공 됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ec1e59a22ef60dce4ecbbf53a52e3ca6ce479f4" translate="yes" xml:space="preserve">
          <source>Additional information about each of these temporary file types is in the sequel.</source>
          <target state="translated">이러한 임시 파일 유형 각각에 대한 추가 정보는 속편에 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d1a81241f56a80c6f10677f29019f00a708f3e" translate="yes" xml:space="preserve">
          <source>Additional information is provided in the &lt;a href=&quot;optoverview&quot;&gt;SQLite query planner&lt;/a&gt; and &lt;a href=&quot;queryplanner-ng&quot;&gt;next generation query planner&lt;/a&gt; documents.</source>
          <target state="translated">추가 정보는 &lt;a href=&quot;optoverview&quot;&gt;SQLite 쿼리 플래너&lt;/a&gt; 및 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 문서에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e54fe371689214dc8e5e5e621b7eb86aecf9d56f" translate="yes" xml:space="preserve">
          <source>Additional language codes might be added in future releases.</source>
          <target state="translated">향후 릴리스에서 추가 언어 코드가 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd6df38d5642afc4cf37656b0d1bca445886b04" translate="yes" xml:space="preserve">
          <source>Additional notes on compiling SQLite can be found on the &lt;a href=&quot;howtocompile&quot;&gt;How To Compile SQLite&lt;/a&gt; page.</source>
          <target state="translated">SQLite 컴파일에 대한 추가 참고 사항은 SQLite &lt;a href=&quot;howtocompile&quot;&gt;컴파일 방법&lt;/a&gt; 페이지 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4ec2f0b6cbf4bf0e81b4a109aa98e3ffbd4166d" translate="yes" xml:space="preserve">
          <source>Additional notes:</source>
          <target state="translated">추가 사항 :</target>
        </trans-unit>
        <trans-unit id="332472b920f973dc311033ff008ad95ae21f625e" translate="yes" xml:space="preserve">
          <source>Additional speed-up can occur if an index can be used to speed the search of either or the two loops.</source>
          <target state="translated">인덱스를 사용하여 하나 또는 두 개의 루프를 빠르게 검색 할 수있는 경우 추가 속도 향상이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62327a6c1f64cd300d626d84824c24a7457822b7" translate="yes" xml:space="preserve">
          <source>Additional tests added to the regression suite to cover the new ROWID feature and the TCL interface bugs mentioned below.</source>
          <target state="translated">새로운 ROWID 기능 및 아래 언급 된 TCL 인터페이스 버그를 다루기 위해 회귀 스위트에 추가 테스트가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="654733e6ef7698fde15afb843bdcb55e4a4bdac2" translate="yes" xml:space="preserve">
          <source>Additionally, all VFS implementations are required to provide the</source>
          <target state="translated">또한 모든 VFS 구현은</target>
        </trans-unit>
        <trans-unit id="751381c740adf479c5b317c56d4dbca83d940699" translate="yes" xml:space="preserve">
          <source>Additionally, five extra &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations are provided as well as the default. By specifying one of the extra VFS implementations when calling &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, an application may bypass the file-system detection logic and explicitly select one of the above locking styles. The five extra &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; implementations are called &quot;unix-posix&quot;, &quot;unix-afp&quot;, &quot;unix-flock&quot;, &quot;unix-dotfile&quot; and &quot;unix-none&quot;.</source>
          <target state="translated">또한 기본적으로 5 개의 추가 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현이 제공됩니다. &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()를&lt;/a&gt; 호출 할 때 추가 VFS 구현 중 하나를 지정 하면 응용 프로그램이 파일 시스템 감지 논리를 무시하고 위의 잠금 스타일 중 하나를 명시 적으로 선택할 수 있습니다. 5 가지 추가 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 구현을 &quot;unix-posix&quot;, &quot;unix-afp&quot;, &quot;unix-flock&quot;, &quot;unix-dotfile&quot;및 &quot;unix-none&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="9c0db46574ddb3c258907307bfcb277854bd98be" translate="yes" xml:space="preserve">
          <source>Additionally, if xBestIndex sets the SQLITE_INDEX_SCAN_UNIQUE flag, then SQLite also assumes that if a call to the xUpdate() method is made as part of the same statement to delete or update a virtual table row and the implementation returns SQLITE_CONSTRAINT, then there is no need to rollback any database changes. In other words, if the xUpdate() returns SQLITE_CONSTRAINT, the database contents must be exactly as they were before xUpdate was called. By contrast, if SQLITE_INDEX_SCAN_UNIQUE is not set and xUpdate returns SQLITE_CONSTRAINT, any database changes made by the xUpdate method are automatically rolled back by SQLite.</source>
          <target state="translated">또한 xBestIndex가 SQLITE_INDEX_SCAN_UNIQUE 플래그를 설정하면 SQLite는 가상 테이블 행을 삭제하거나 업데이트하기 위해 동일한 명령문의 일부로 xUpdate () 메서드를 호출하고 구현에서 SQLITE_CONSTRAINT를 반환한다고 가정합니다. 데이터베이스 변경 사항을 롤백합니다. 즉, xUpdate ()가 SQLITE_CONSTRAINT를 리턴하면 데이터베이스 내용은 xUpdate가 호출되기 전의 내용과 동일해야합니다. 반대로, SQLITE_INDEX_SCAN_UNIQUE가 설정되어 있지 않고 xUpdate가 SQLITE_CONSTRAINT를 반환하면 xUpdate 메서드에 의한 데이터베이스 변경 사항은 SQLite에 의해 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="bd3296bcc9f5f36b885d1f44a772cfcd7df89079" translate="yes" xml:space="preserve">
          <source>Additionally, the result of the comparison is only valid if both of the snapshot handles were obtained by calling sqlite3_snapshot_get() since the last time the wal file was deleted. The wal file is deleted when the database is changed back to rollback mode or when the number of database clients drops to zero. If either snapshot handle was obtained before the wal file was last deleted, the value returned by this function is undefined.</source>
          <target state="translated">또한 wal 파일이 마지막으로 삭제 된 이후 sqlite3_snapshot_get ()을 호출하여 두 스냅 샷 핸들을 모두 얻은 경우에만 비교 결과가 유효합니다. wal 파일은 데이터베이스가 롤백 모드로 다시 변경되거나 데이터베이스 클라이언트 수가 0으로 떨어지면 삭제됩니다. wal 파일을 마지막으로 삭제하기 전에 스냅 샷 핸들을 얻은 경우이 함수가 반환 한 값은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="68ad616133628f7a9c711f524c6d649bfd1e605e" translate="yes" xml:space="preserve">
          <source>Adjust how SQLite does &lt;a href=&quot;malloc&quot;&gt;memory allocation&lt;/a&gt;, including setting up alternative memory allocators appropriate for safety-critical real-time embedded systems and application-defined memory allocators.</source>
          <target state="translated">안전에 중요한 실시간 임베디드 시스템 및 애플리케이션 정의 메모리 할당 자에 적합한 대체 메모리 할당자를 설정하는 등 SQLite가 &lt;a href=&quot;malloc&quot;&gt;메모리 할당을&lt;/a&gt; 수행하는 방식을 조정하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b033ae4a69004f4620434e4722184d64e21543d" translate="yes" xml:space="preserve">
          <source>Adjust the &lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count()&lt;/a&gt; API so it more often returns the same values for &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements as it did in prior releases, to minimize disruption to applications that might be using that interface in unexpected ways.</source>
          <target state="translated">&lt;a href=&quot;c3ref/column_count&quot;&gt;sqlite3_column_count ()&lt;/a&gt; API를 조정하여 예기치 않은 방식으로 해당 인터페이스를 사용중인 애플리케이션의 중단을 최소화하기 위해 이전 릴리스에서 와 동일한 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 문에 대해 동일한 값을 더 자주 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="af76f40123a61e61c36534a28bc6944e29327620" translate="yes" xml:space="preserve">
          <source>Adjust the unix driver to avoid unnecessary calls to fchown().</source>
          <target state="translated">fchown ()에 대한 불필요한 호출을 피하기 위해 유닉스 드라이버를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="8d239da6b2ab732b6958736d4e5cb3d6007246c9" translate="yes" xml:space="preserve">
          <source>Adjust the use of mutexes so that they are appropriate for various &lt;a href=&quot;threadsafe&quot;&gt;threading models&lt;/a&gt;, or substitute an application-defined mutex system.</source>
          <target state="translated">다양한 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모델에&lt;/a&gt; 적합하도록 뮤텍스의 사용을 조정 하거나 애플리케이션 정의 뮤텍스 시스템을 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="94f5fc3d9b3cb240294c036969ed03df2f640df3" translate="yes" xml:space="preserve">
          <source>Adjusting SQLite To Use 8+3 Filenames</source>
          <target state="translated">8 + 3 파일 이름을 사용하도록 SQLite 조정</target>
        </trans-unit>
        <trans-unit id="42bff9e6720c99e5345613da344a0c1afa8b6dd4" translate="yes" xml:space="preserve">
          <source>Advance A Changeset Iterator</source>
          <target state="translated">Changeset Iterator 사전 진행</target>
        </trans-unit>
        <trans-unit id="5e8ccba8f1392a8bc7c3e697913930b9040f8c60" translate="yes" xml:space="preserve">
          <source>Advance cursor P1 so that it points to the next key/data pair in its table or index. If there are no more key/value pairs then fall through to the following instruction. But if the cursor advance was successful, jump immediately to P2.</source>
          <target state="translated">테이블 또는 인덱스에서 다음 키 / 데이터 쌍을 가리 키도록 커서 P1을 진행시킵니다. 더 이상 키 / 값 쌍이 없으면 다음 명령어로 넘어갑니다. 그러나 커서 이동이 성공하면 즉시 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="26c9571278da3b45a7da23cbb5f3d294d51fc11e" translate="yes" xml:space="preserve">
          <source>Advance virtual table P1 to the next row in its result set and jump to instruction P2. Or, if the virtual table has reached the end of its result set, then fall through to the next instruction.</source>
          <target state="translated">가상 테이블 P1을 결과 세트의 다음 행으로 진행하고 명령 P2로 이동하십시오. 또는 가상 테이블이 결과 세트의 끝에 도달하면 다음 명령어로 넘어갑니다.</target>
        </trans-unit>
        <trans-unit id="e75e53f7ef6befbc2ec9555564b368fec377a5b4" translate="yes" xml:space="preserve">
          <source>Advantages of WAL-mode</source>
          <target state="translated">WAL 모드의 장점</target>
        </trans-unit>
        <trans-unit id="b8c612cc4e584be10a59711cc94c098821d2bdc6" translate="yes" xml:space="preserve">
          <source>Advocacy</source>
          <target state="translated">Advocacy</target>
        </trans-unit>
        <trans-unit id="2d3ad1756a210c3ecab852144ac9d98890b977fa" translate="yes" xml:space="preserve">
          <source>Affinity</source>
          <target state="translated">Affinity</target>
        </trans-unit>
        <trans-unit id="4f72807708b980eccee8200e07c7d36460820a43" translate="yes" xml:space="preserve">
          <source>Affinity of</source>
          <target state="translated">친화력</target>
        </trans-unit>
        <trans-unit id="79ba5e1b3f99abfd54ef8d839ba12bd2ac4d79cb" translate="yes" xml:space="preserve">
          <source>After</source>
          <target state="translated">After</target>
        </trans-unit>
        <trans-unit id="23fd162046b3edf8ebd248698454f109bfd31f63" translate="yes" xml:space="preserve">
          <source>After ADD COLUMN has been run on a database, that database will not be readable by SQLite version 3.1.3 (2005-02-20) and earlier.</source>
          <target state="translated">ADD COLUMN이 데이터베이스에서 실행 된 후에는 SQLite 버전 3.1.3 (2005-02-20) 및 이전 버전에서 해당 데이터베이스를 읽을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="027a417d23e6a18069001a7c19ad2bf39267a70e" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; has been prepared using any of &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; or one of the legacy interfaces &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, this function must be called one or more times to evaluate the statement.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 또는 레거시 인터페이스 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 중 하나를 사용하여 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 준비한 후이 함수는 하나 이상이어야합니다. 진술을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="b4eec0463aaa1bd6eacaf86174eef649dd73f26c" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; has been evaluated by one or more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;, it can be reset in order to be evaluated again by a call to &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt;. Think of &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; as rewinding the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; program back to the beginning. Using &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; on an existing &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; rather than creating a new &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; avoids unnecessary calls to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;. For many SQL statements, the time needed to run &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; equals or exceeds the time needed by &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;. So avoiding calls to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; can give a significant performance improvement.</source>
          <target state="translated">후 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문이&lt;/a&gt; 하나 이상의 호출에 의해 평가 된 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; , 순서대로 다시 호출에 의해 다시 평가 될 수 있습니다 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; . &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 프로그램을 처음 으로 되 감는 것으로 생각하십시오 . 사용 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 기존에 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문을&lt;/a&gt; 하지 않고 새 만들기보다 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문하는 것은&lt;/a&gt; 불필요한 통화를 방지 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare을 ()&lt;/a&gt; . 많은 SQL 문의 경우 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 를 실행 하는 데 필요한 시간은 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 필요한 시간과 같습니다 . 그래서 전화를 피&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 는 상당한 성능 향상을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="794711e92b4cb710edd2459f0377567195dd4b41" translate="yes" xml:space="preserve">
          <source>After a &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; has been prepared using any of &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3()&lt;/a&gt;, &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2()&lt;/a&gt;, or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3()&lt;/a&gt; or one of the legacy interfaces &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16()&lt;/a&gt;, this function must be called one or more times to evaluate the statement.</source>
          <target state="translated">&lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v3 ()&lt;/a&gt; , &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v2 ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16_v3 ()&lt;/a&gt; 또는 레거시 인터페이스 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare16 ()&lt;/a&gt; 중 하나를 사용하여 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 준비한 후이 함수는 하나 이상이어야합니다. 진술을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="610a52e97ff3ecd7651d2bc9d61eca8fe0a8d8a9" translate="yes" xml:space="preserve">
          <source>After a call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; returns SQLITE_LOCKED, the &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; API may be invoked to register for an unlock-notify callback. The unlock-notify callback is invoked by SQLite after the database connection holding the table-lock that prevented the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; from succeeding has finished its transaction and released all locks. For example, if a call to sqlite3_step() is an attempt to read from table X, and some other connection Y is holding a write-lock on table X, then sqlite3_step() will return SQLITE_LOCKED. If &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; is then called, the unlock-notify callback will be invoked after connection Y's transaction is concluded. The connection that the unlock-notify callback is waiting on, in this case connection Y, is known as the &quot;blocking connection&quot;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 호출이 SQLITE_LOCKED를 리턴 한 후, &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; API가 호출되어 잠금 해제 알림 콜백에 등록 될 수 있습니다. &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()에&lt;/a&gt; 대한 호출 이 트랜잭션을 완료하지 못하고 모든 잠금을 해제 한 테이블 잠금을 보유한 데이터베이스 연결 후 데이터베이스 잠금 해제 알림 콜백이 SQLite에 의해 호출됩니다 . 예를 들어, sqlite3_step ()에 대한 호출이 테이블 X에서 읽기 시도이고 다른 연결 Y가 테이블 X에서 쓰기 잠금을 보유하는 경우 sqlite3_step ()은 SQLITE_LOCKED를 리턴합니다. &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify () 인&lt;/a&gt; 경우그런 다음 연결 Y의 트랜잭션이 완료된 후 잠금 해제 알림 콜백이 호출됩니다. 잠금 해제 알림 콜백이 대기중인 연결 (이 경우 연결 Y)을 &quot;차단 연결&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="4986de5057c6d05cb0ea3a0ad2727b5d055cdc6f" translate="yes" xml:space="preserve">
          <source>After a complete checkpoint, if no other connections are in transactions that use the WAL, then subsequent write transactions can overwrite the WAL file from the beginning. This is called &quot;resetting the WAL&quot;. At the start of the first new write transaction, the WAL header salt-1 value is incremented and the salt-2 value is randomized. These changes to the salts invalidate old frames in the WAL that have already been checkpointed but not yet overwritten, and prevent them from being checkpointed again.</source>
          <target state="translated">완전한 체크 포인트 후 WAL을 사용하는 트랜잭션에 다른 연결이 없으면 후속 쓰기 트랜잭션이 처음부터 WAL 파일을 겹쳐 쓸 수 있습니다. 이것을 &quot;WAL 재설정&quot;이라고합니다. 첫 번째 새 쓰기 트랜잭션이 시작되면 WAL 헤더 salt-1 값이 증가하고 salt-2 값이 무작위로 지정됩니다. 이러한 소금에 대한 변경 사항은 WAL에서 이미 검사 점이지만 아직 덮어 쓰지 않은 이전 프레임을 무효화하고 다시 검사 점을 만들지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="6b922aacb69272f39bced66a3ebf0a3033c1514f" translate="yes" xml:space="preserve">
          <source>After a database is closed, swarmvtab runs the equivalent of:</source>
          <target state="translated">데이터베이스가 닫힌 후 swarmvtab은 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="95563154fa733438ac343e5b67e301f468c45088" translate="yes" xml:space="preserve">
          <source>After a sequence of changes that define a single undo/redo step, invoke the undo::barrier command to define the limit of that step. In an interactive program, you can call undo::event after any change and undo::barrier will be called automatically as an idle callback.</source>
          <target state="translated">단일 실행 취소 / 다시 실행 단계를 정의하는 일련의 변경 후, undo :: barrier 명령을 호출하여 해당 단계의 한계를 정의하십시오. 대화식 프로그램에서 변경 후 undo :: event를 호출하면 undo :: barrier가 유휴 콜백으로 자동 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="9ba37aebce03d74bebd4ab72ce08d7281954335c" translate="yes" xml:space="preserve">
          <source>After a session object has been configured, it begins monitoring for changes to its configured tables. However, it does not record an entire change each time a row within the database is modified. Instead, it records just the PRIMARY KEY fields for each inserted row, and just the PRIMARY KEY and all original row values for any updated or deleted rows. If a row is modified more than once by a single session, no new information is recorded.</source>
          <target state="translated">세션 오브젝트가 구성된 후에는 구성된 테이블의 변경 사항을 모니터링하기 시작합니다. 그러나 데이터베이스 내의 행이 수정 될 때마다 전체 변경 사항을 기록하지 않습니다. 대신, 삽입 된 각 행에 대한 PRIMARY KEY 필드와 업데이트되거나 삭제 된 행에 대한 PRIMARY KEY 및 모든 원래 행 값만 기록합니다. 단일 세션에서 행을 두 번 이상 수정하면 새로운 정보가 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9ec21719ff7b0d3ffa4e429b7905254f04d4e5c" translate="yes" xml:space="preserve">
          <source>After a virtual machine has been generated using &lt;b&gt;sqlite_compile&lt;/b&gt; it is executed by one or more calls to &lt;b&gt;sqlite_step&lt;/b&gt;. Each invocation of &lt;b&gt;sqlite_step&lt;/b&gt;, except the last one, returns a single row of the result. The number of columns in the result is stored in the integer that the 2nd parameter points to. The pointer specified by the 3rd parameter is made to point to an array of pointers to column values. The pointer in the 4th parameter is made to point to an array of pointers to column names and datatypes. The 2nd through 4th parameters to &lt;b&gt;sqlite_step&lt;/b&gt; convey the same information as the 2nd through 4th parameters of the &lt;b&gt;callback&lt;/b&gt; routine when using the &lt;b&gt;sqlite_exec&lt;/b&gt; interface. Except, with &lt;b&gt;sqlite_step&lt;/b&gt; the column datatype information is always included in the in the 4th parameter regardless of whether or not the &lt;a href=&quot;pragma#pragma_show_datatypes&quot;&gt;SHOW_DATATYPES&lt;/a&gt; pragma is on or off.</source>
          <target state="translated">&lt;b&gt;sqlite_compile&lt;/b&gt; 을 사용하여 가상 머신을 생성 한 후 &lt;b&gt;sqlite_step&lt;/b&gt; 에 대한 하나 이상의 호출로 실행됩니다 . 마지막을 제외한 &lt;b&gt;sqlite_step의&lt;/b&gt; 각 호출은 결과의 단일 행을 리턴합니다. 결과의 열 수는 두 번째 매개 변수가 가리키는 정수로 저장됩니다. 3 번째 매개 변수로 지정된 포인터는 열 값에 대한 포인터 배열을 가리 키도록 만들어집니다. 네 번째 매개 변수의 포인터는 열 이름 및 데이터 유형에 대한 포인터 배열을 가리 키도록 만들어졌습니다. 에 4 매개 변수를 통해 제 2 &lt;b&gt;sqlite_step이&lt;/b&gt; 의 네번째 매개 변수를 통해 2와 같은 정보를 전달하는 &lt;b&gt;콜백&lt;/b&gt; 사용하는 경우 루틴을 &lt;b&gt;sqlite_exec&lt;/b&gt; 인터페이스를. 제외하고&lt;b&gt;sqlite_step&lt;/b&gt; 열 데이터 유형 정보는 &lt;a href=&quot;pragma#pragma_show_datatypes&quot;&gt;SHOW_DATATYPES&lt;/a&gt; pragma 의 설정 여부에 관계없이 항상 4 번째 매개 변수에 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="23265bf656595ac1bd3eabed0b381392ce07d2ae" translate="yes" xml:space="preserve">
          <source>After all information in the rollback journal has been played back into the database file (and flushed to disk in case we encounter yet another power failure), the hot rollback journal can be deleted.</source>
          <target state="translated">롤백 저널의 모든 정보가 데이터베이스 파일로 재생 된 후 (또 다른 전원 장애가 발생할 경우 디스크로 플러시 됨) 핫 롤백 저널을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b84435139a07c4a4055bb439605dbd8c9789e7d7" translate="yes" xml:space="preserve">
          <source>After all needed changes are completed, xWrite() is used to move the content back into the database file. Hence the use of memory mapped I/O does not significantly change the performance of database changes. Memory mapped I/O is mostly a benefit for queries.</source>
          <target state="translated">필요한 모든 변경이 완료되면 xWrite ()를 사용하여 내용을 다시 데이터베이스 파일로 이동합니다. 따라서 메모리 맵핑 I / O를 사용해도 데이터베이스 변경 성능이 크게 변경되지 않습니다. 메모리 매핑 I / O는 대부분 쿼리에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="260239065f2a92ea494a87b7cf4ba2a2d941420e" translate="yes" xml:space="preserve">
          <source>After all records have been inserted into the Sorter object identified by P1, invoke this opcode to actually do the sorting. &lt;a href=&quot;opcode#Jump&quot;&gt;Jump&lt;/a&gt; to P2 if there are no records to be sorted.</source>
          <target state="translated">P1으로 식별 된 Sorter 개체에 모든 레코드를 삽입 한 후 실제로 정렬을 수행하려면이 opcode를 호출하십시오. 정렬 할 레코드가 없으면 P2로 &lt;a href=&quot;opcode#Jump&quot;&gt;이동하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1079dc3c758cc45d2f271e573db223c2cdb12648" translate="yes" xml:space="preserve">
          <source>After an SQL statement has been prepared (and optionally bound), it is executed using:</source>
          <target state="translated">SQL 문이 준비된 후 (선택적으로 바인드 된) 다음을 사용하여 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="19e517dcca2fb3c783a27c4dacd0285a95c871db" translate="yes" xml:space="preserve">
          <source>After any changes to the TEMP database schema, all prepared statements are invalidated and must be recreated using a new call to sqlite3_prepare()</source>
          <target state="translated">TEMP 데이터베이스 스키마를 변경 한 후 모든 준비된 명령문은 무효화되며 sqlite3_prepare ()에 대한 새로운 호출을 사용하여 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef8dfe7bdc91c90b1d784f46b505207e5b5bb9de" translate="yes" xml:space="preserve">
          <source>After duplicating the key, the next instruction, NotExists, pops the stack once and uses the value popped as a key to check the existence of a record in the database file. If there is no record for this key, it jumps back to the ListRead to get another key.</source>
          <target state="translated">키를 복제 한 후 다음 명령 인 NotExists는 스택을 한 번 팝하고 키로 팝된 값을 사용하여 데이터베이스 파일에 레코드가 있는지 확인합니다. 이 키에 대한 레코드가 없으면 다른 키를 얻기 위해 ListRead로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="838513ea0f9681d04eb27d7879229c002b821a85" translate="yes" xml:space="preserve">
          <source>After each INSERT on ex1, the ex1_it trigger constructs text of a DELETE statement that will undo the INSERT. The ex1_ut trigger constructs an UPDATE statement that will undo the effects of an UPDATE. And the ex1_dt trigger constructs a statement that will undo the effects of a DELETE.</source>
          <target state="translated">ex1의 각 INSERT 후에 ex1_it 트리거는 INSERT를 실행 취소 할 DELETE 문의 텍스트를 구성합니다. ex1_ut 트리거는 UPDATE의 영향을 취소하는 UPDATE 문을 구성합니다. 그리고 ex1_dt 트리거는 DELETE의 영향을 취소하는 명령문을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="126fa1adfbc14e51e51271a3d3ed7613c3632f33" translate="yes" xml:space="preserve">
          <source>After gcov has been run to verify 100% branch test coverage, then the test program is recompiled using delivery compiler options (without the special -fprofile-arcs and -ftest-coverage options) and the test program is rerun. This second run is the actual test of SQLite.</source>
          <target state="translated">gcov가 100 % 분기 테스트 적용 범위를 검증하기 위해 실행 된 후, 전달 컴파일러 옵션 (특수 -fprofile-arcs 및 -ftest-coverage 옵션없이)을 사용하여 테스트 프로그램이 재 컴파일되고 테스트 프로그램이 다시 실행됩니다. 이 두 번째 실행은 SQLite의 실제 테스트입니다.</target>
        </trans-unit>
        <trans-unit id="db8afe929b966e405547381b33bfdc15bcc08124" translate="yes" xml:space="preserve">
          <source>After obtaining a RESERVED lock, the process that wants to write creates a rollback journal. The header of the journal is initialized with the original size of the database file. Space in the journal header is also reserved for a master journal name, though the master journal name is initially empty.</source>
          <target state="translated">예약 된 잠금을 확보 한 후, 작성하려는 프로세스는 롤백 저널을 작성합니다. 저널의 헤더는 데이터베이스 파일의 원래 크기로 초기화됩니다. 마스터 저널 이름이 처음에는 비어 있지만 저널 헤더의 공간도 마스터 저널 이름을 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1634d30fc252b255d4609b96665517fdcea9fa73" translate="yes" xml:space="preserve">
          <source>After process-wide configuration is complete and &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; have been created, individual database connections can be configured using calls to &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;.</source>
          <target state="translated">프로세스 전체 구성이 완료되고 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 작성된 후 &lt;a href=&quot;c3ref/limit&quot;&gt;sqlite3_limit ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에 대한&lt;/a&gt; 호출을 사용하여 개별 데이터베이스 연결을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3999670e271fa814391d216ed801ffd36e68c0e2" translate="yes" xml:space="preserve">
          <source>After reading the data for a database page, SQLite stores the raw page of data in the</source>
          <target state="translated">데이터베이스 페이지의 데이터를 읽은 후 SQLite는 원시 데이터 페이지를</target>
        </trans-unit>
        <trans-unit id="f403207f2b4b981533796c7ad5f8378ebe08c950" translate="yes" xml:space="preserve">
          <source>After resolving conflicts, many users like to compile and test the new version before committing it to the repository. Or you can commit first and test later. Either way, run the &quot;&lt;code&gt;fossil commit&lt;/code&gt;&quot; command to check-in the circle (5) version.</source>
          <target state="translated">충돌을 해결 한 후 많은 사용자가 새 버전을 리포지토리에 커밋하기 전에 컴파일하고 테스트하기를 원합니다. 또는 먼저 커밋하고 나중에 테스트 할 수 있습니다. 어느 쪽이든, &quot; &lt;code&gt;fossil commit&lt;/code&gt; &quot;명령을 실행 하여 서클 (5) 버전을 체크인하십시오.</target>
        </trans-unit>
        <trans-unit id="c63b949f4e88ad0a023a0bdd59afe48dabc17031" translate="yes" xml:space="preserve">
          <source>After running the CREATE TABLE statement, disable the imposter mechanism as follows:</source>
          <target state="translated">CREATE TABLE 문을 실행 한 후 다음과 같이 임 포스터 메커니즘을 사용 불가능하게하십시오.</target>
        </trans-unit>
        <trans-unit id="538eea92ccc130ef6b680c0e55263bee066d1733" translate="yes" xml:space="preserve">
          <source>After successfully opening a file-handle on a potentially hot journal file, SQLite shall query the file for its size in bytes using the xFileSize() method of the open file handle.</source>
          <target state="translated">잠재적으로 핫 저널 파일에서 파일 핸들을 성공적으로 열면 SQLite는 열린 파일 핸들의 xFileSize () 메서드를 사용하여 파일 크기를 바이트 단위로 쿼리해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fbe2d1674af788e8343a14ee7a4129b26ca4886" translate="yes" xml:space="preserve">
          <source>After the</source>
          <target state="translated">후</target>
        </trans-unit>
        <trans-unit id="f2360cfd6cf46af06ac709eb02497e9aff167465" translate="yes" xml:space="preserve">
          <source>After the algorithm above completes successfully, it is safe to read from the database file. Once all reading has completed, the SHARED lock is dropped.</source>
          <target state="translated">위의 알고리즘이 성공적으로 완료되면 데이터베이스 파일에서 읽는 것이 안전합니다. 모든 판독이 완료되면 SHARED 잠금이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="157772fcdfe2470be92e77475005f7ac0b098542" translate="yes" xml:space="preserve">
          <source>After the application has finished with the result from sqlite3_get_table(), it must pass the result table pointer to sqlite3_free_table() in order to release the memory that was malloced. Because of the way the &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt; happens within sqlite3_get_table(), the calling function must not try to call &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; directly. Only &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; is able to release the memory properly and safely.</source>
          <target state="translated">응용 프로그램이 sqlite3_get_table ()의 결과로 완료된 후, malloced 된 메모리를 해제하려면 결과 테이블 포인터를 sqlite3_free_table ()에 전달해야합니다. &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 이 sqlite3_get_table () 내에서 발생 하는 방식 때문에 호출 함수는 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 직접 호출하지 않아야합니다 . &lt;a href=&quot;#sqlite3_free_table&quot;&gt;sqlite3_free_table ()&lt;/a&gt; 만이 메모리를 적절하고 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c64408a8164063ed860f68818eaa546c62a346e" translate="yes" xml:space="preserve">
          <source>After the application has finished with the result from sqlite3_get_table(), it must pass the result table pointer to sqlite3_free_table() in order to release the memory that was malloced. Because of the way the &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt; happens within sqlite3_get_table(), the calling function must not try to call &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; directly. Only &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table()&lt;/a&gt; is able to release the memory properly and safely.</source>
          <target state="translated">응용 프로그램이 sqlite3_get_table ()의 결과로 완료된 후, malloced 된 메모리를 해제하려면 결과 테이블 포인터를 sqlite3_free_table ()에 전달해야합니다. &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 이 sqlite3_get_table () 내에서 발생 하는 방식 때문에 호출 함수는 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 직접 호출하지 않아야합니다 . &lt;a href=&quot;free_table&quot;&gt;sqlite3_free_table ()&lt;/a&gt; 만이 메모리를 적절하고 안전하게 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af39ba2343efa84bf5f79d3192cc7d9b779717a4" translate="yes" xml:space="preserve">
          <source>After the database changes are all safely on the mass storage device, the rollback journal file is deleted. This is the instant where the transaction commits. If a power failure or system crash occurs prior to this point, then recovery processes to be described later make it appear as if no changes were ever made to the database file. If a power failure or system crash occurs after the rollback journal is deleted, then it appears as if all changes have been written to disk. Thus, SQLite gives the appearance of having made no changes to the database file or having made the complete set of changes to the database file depending on whether or not the rollback journal file exists.</source>
          <target state="translated">데이터베이스 변경 사항이 모두 대량 저장 장치에서 안전하게 된 후 롤백 저널 파일이 삭제됩니다. 이것이 트랜잭션이 커밋되는 순간입니다. 이 시점 이전에 정전 또는 시스템 충돌이 발생하면 나중에 설명 할 복구 프로세스가 데이터베이스 파일을 변경하지 않은 것처럼 나타납니다. 롤백 저널이 삭제 된 후 정전 또는 시스템 충돌이 발생하면 모든 변경 사항이 디스크에 기록 된 것처럼 나타납니다. 따라서 SQLite는 롤백 저널 파일의 존재 여부에 따라 데이터베이스 파일을 변경하지 않았거나 데이터베이스 파일을 완전히 변경 한 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="8bb7688984c453ad2bc60e9833b1d02d648b8f95" translate="yes" xml:space="preserve">
          <source>After the header and zero padding are zero or more page records. Each page record stores a copy of the content of a page from the database file before it was changed. The same page may not appear more than once within a single rollback journal. To rollback an incomplete transaction, a process has merely to read the rollback journal from beginning to end and write pages found in the journal back into the database file at the appropriate location.</source>
          <target state="translated">헤더와 제로 패딩 이후에는 0 개 이상의 페이지 레코드가 있습니다. 각 페이지 레코드는 변경되기 전에 데이터베이스 파일의 페이지 컨텐츠 사본을 저장합니다. 단일 롤백 저널에 동일한 페이지가 두 번 이상 나타나지 않을 수 있습니다. 불완전한 트랜잭션을 롤백하려면 프로세스는 롤백 저널을 처음부터 끝까지 읽고 저널에서 찾은 페이지를 적절한 위치의 데이터베이스 파일에 다시 쓰기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4bc35438aded45e22aeee0454d230e53ab207bab" translate="yes" xml:space="preserve">
          <source>After the imposter table is loaded into SQLite's internal schema as described above, the imposter table can be used as any other table. But the imposter table will only be visible to the one database connection that created it. No changes are made to the database file on disk. And the imposter table will disappear the next time the schema is loaded.</source>
          <target state="translated">위에서 설명한대로 임 포스터 테이블을 SQLite의 내부 스키마에로드 한 후에는 임 포스터 테이블을 다른 테이블로 사용할 수 있습니다. 그러나 임 포스터 테이블은이를 생성 한 하나의 데이터베이스 연결에서만 볼 수 있습니다. 디스크의 데이터베이스 파일은 변경되지 않습니다. 그리고 다음에 스키마가로드 될 때 임 포스터 테이블이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="6fb2487148ee10be0a40ce759f7c45930d397db5" translate="yes" xml:space="preserve">
          <source>After the master journal is constructed, its content is flushed to disk before any further actions are taken. On Unix, the directory that contains the master journal is also synced in order to make sure the master journal file will appear in the directory following a power failure.</source>
          <target state="translated">마스터 저널이 구성된 후에는 추가 조치를 취하기 전에 해당 컨텐츠가 디스크로 플러시됩니다. Unix에서는 마스터 저널 파일이 정전 후에 디렉토리에 표시되도록 마스터 저널이 포함 된 디렉토리도 동기화됩니다.</target>
        </trans-unit>
        <trans-unit id="93f402b283ab865f9a9eb59bcf905d302373fd8f" translate="yes" xml:space="preserve">
          <source>After the original page content has been saved in the rollback journal, the pages can be modified in user memory. Each database connection has its own private copy of user space, so the changes that are made in user space are only visible to the database connection that is making the changes. Other database connections still see the information in operating system disk cache buffers which have not yet been changed. And so even though one process is busy modifying the database, other processes can continue to read their own copies of the original database content.</source>
          <target state="translated">원본 페이지 내용이 롤백 저널에 저장되면 사용자 메모리에서 페이지를 수정할 수 있습니다. 각 데이터베이스 연결에는 고유 한 개인 사용자 공간 사본이 있으므로 사용자 공간에서 작성된 변경 사항은 변경중인 데이터베이스 연결에서만 볼 수 있습니다. 다른 데이터베이스 연결에는 아직 변경되지 않은 운영 체제 디스크 캐시 버퍼의 정보가 여전히 표시됩니다. 따라서 한 프로세스가 데이터베이스를 수정하는 중이라도 다른 프로세스는 계속해서 자신의 원본 데이터베이스 컨텐츠 사본을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b39bcb3162c3e5bf861268807e2f722487ba46f2" translate="yes" xml:space="preserve">
          <source>After the parser assembles tokens into a parse tree, the code generator runs to analyze the parser tree and generate &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; that performs the work of the SQL statement. The &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statement&lt;/a&gt; object is a container for this bytecode. There are many files in the code generator, including: &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/pragma.c&quot;&gt;pragma.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/wherecode.c&quot;&gt;wherecode.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/whereexpr.c&quot;&gt;whereexpr.c&lt;/a&gt;. In these files is where most of the serious magic happens. &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; handles code generation for expressions. &lt;b&gt;where*.c&lt;/b&gt; handles code generation for WHERE clauses on SELECT, UPDATE and DELETE statements. The files &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt;, &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt;, and &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt; handle the code generation for SQL statements with the same names. (Each of these files calls routines in &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; and &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; as necessary.) All other SQL statements are coded out of &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt;. The &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt; file implements the functionality of &lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer()&lt;/a&gt;.</source>
          <target state="translated">구문 분석기가 토큰을 구문 분석 트리로 어셈블 한 후 코드 생성기가 실행되어 구문 분석기 트리를 분석 하고 SQL 문 작업을 수행하는 &lt;a href=&quot;opcode&quot;&gt;바이트 코드&lt;/a&gt; 를 생성 합니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 문&lt;/a&gt; 객체는이 바이트 코드의 컨테이너입니다. 코드 생성기에는 &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/pragma.c&quot;&gt;pragma.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt; 등 많은 파일이 있습니다. , &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/wherecode.c&quot;&gt;wherecode.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/whereexpr.c&quot;&gt;whereexpr.c&lt;/a&gt;. 이 파일에서 대부분의 심각한 마법이 발생합니다. &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; 는 표현식의 코드 생성을 처리합니다. &lt;b&gt;where * .c&lt;/b&gt; 는 SELECT, UPDATE 및 DELETE 문에서 WHERE 절에 대한 코드 생성을 처리합니다. 파일의 &lt;a href=&quot;https://sqlite.org/src/file/src/attach.c&quot;&gt;attach.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/delete.c&quot;&gt;delete.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/insert.c&quot;&gt;insert.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/select.c&quot;&gt;select.c&lt;/a&gt; , &lt;a href=&quot;https://sqlite.org/src/file/src/trigger.c&quot;&gt;trigger.c의 &lt;/a&gt;&lt;a href=&quot;https://sqlite.org/src/file/src/update.c&quot;&gt;update.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/vacuum.c&quot;&gt;vacuum.c의&lt;/a&gt; 같은 이름을 가진 SQL 문에 대한 핸들 코드 생성. (이러한 각 파일은 필요에 따라 &lt;a href=&quot;https://sqlite.org/src/file/src/expr.c&quot;&gt;expr.c&lt;/a&gt; 및 &lt;a href=&quot;https://sqlite.org/src/file/src/where.c&quot;&gt;where.c&lt;/a&gt; 에서 루틴을 호출합니다 .) 다른 모든 SQL 문은 &lt;a href=&quot;https://sqlite.org/src/file/src/build.c&quot;&gt;build.c에서&lt;/a&gt; 코드화됩니다 . &lt;a href=&quot;https://sqlite.org/src/file/src/auth.c&quot;&gt;auth.c의&lt;/a&gt; 파일의 기능을 구현&lt;a href=&quot;c3ref/set_authorizer&quot;&gt;sqlite3_set_authorizer ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e1c3e7c8a391dcea0df2cfdb448d836a449fa44" translate="yes" xml:space="preserve">
          <source>After the query loop ends, the table being queried is closed at instruction 14. This is done early in order to allow other processes or threads to access that table, if desired. The list of records that was built up inside the query loop is sorted by the instruction at 15. Instructions 16 through 18 walk through the record list (which is now in sorted order) and invoke the callback once for each record. Finally, the sorter is closed at instruction 19.</source>
          <target state="translated">쿼리 루프가 종료 된 후 쿼리중인 테이블은 명령어 14에서 닫힙니다. 원하는 경우 다른 프로세스 나 스레드가 해당 테이블에 액세스 할 수 있도록하기 위해 초기에 수행됩니다. 쿼리 루프 내에 구축 된 레코드 목록은 15 번 명령으로 정렬됩니다. 명령 16에서 18까지는 레코드 목록 (이제 정렬 된 순서)을 안내하고 각 레코드에 대해 콜백을 한 번 호출합니다. 마지막으로 분류기는 명령 19에서 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f7a2e27dec51b31c6ed11a02889862c44fec50cf" translate="yes" xml:space="preserve">
          <source>After the query loop is finished, the table &quot;examp2&quot; is closed at instruction 23 so that its lock will be released and it can be used by other threads or processes. The next step is to loop over all aggregate buckets and output one row of the result for each bucket. This is done by the loop at instructions 24 through 30. The AggNext instruction at 24 brings the next bucket into focus, or jumps to the end of the loop if all buckets have been examined already. The 3 columns of the result are fetched from the aggregator bucket in order at instructions 25 through 27. Finally, the callback is invoked at instruction 29.</source>
          <target state="translated">쿼리 루프가 완료된 후 명령 &quot;23&quot;에서 &quot;examp2&quot;테이블이 닫히고 잠금이 해제되어 다른 스레드 나 프로세스에서 사용할 수 있습니다. 다음 단계는 모든 집계 버킷을 반복하고 각 버킷에 대해 결과의 한 행을 출력하는 것입니다. 이는 명령 24에서 30까지의 루프에 의해 수행됩니다. 24의 AggNext 명령은 다음 버킷을 포커스 상태로 만들거나 모든 버킷이 이미 검사 된 경우 루프의 끝으로 이동합니다. 명령어 25에서 27까지 순서대로 결과의 3 개 열이 수집기 버킷에서 페치됩니다. 마지막으로, 명령어 29에서 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="429426adc150c9c3ef8de6d6350a6529072871cf" translate="yes" xml:space="preserve">
          <source>After the shared lock is acquired, we can begin reading information from the database file. In this scenario, we are assuming a cold cache, so information must first be read from mass storage into the operating system cache then transferred from operating system cache into user space. On subsequent reads, some or all of the information might already be found in the operating system cache and so only the transfer to user space would be required.</source>
          <target state="translated">공유 잠금이 확보 된 후 데이터베이스 파일에서 정보 읽기를 시작할 수 있습니다. 이 시나리오에서는 콜드 캐시를 가정하고 있으므로 먼저 대용량 스토리지에서 운영 체제 캐시로 정보를 읽은 다음 운영 체제 캐시에서 사용자 공간으로 전송해야합니다. 이후에 읽을 때 일부 또는 모든 정보가 이미 운영 체제 캐시에있을 수 있으므로 사용자 공간으로의 전송 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7dbb1609bfd1352286bb98fe2bf2342dc300ba85" translate="yes" xml:space="preserve">
          <source>After the sqlite3_test_control() call above, then run a &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; statement the defines the imposter table. With the imposter mechanism enabled, this CREATE TABLE statement does not create a real table but instead merely adds an entry in SQLite's internal symbol table. Note that the CREATE TABLE statement must be in the correct format for the index. If the imposter table has the wrong number of columns or is not a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or is otherwise incompatible with the index b-tree, then &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; errors will result when the imposter table is used.</source>
          <target state="translated">위의 sqlite3_test_control () 호출 후 임 포스터 테이블을 정의 하는 &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 문 을 실행 하십시오. 임 포스터 메커니즘이 사용 가능한 경우,이 CREATE TABLE 문은 실제 테이블을 작성하지 않고 SQLite의 내부 기호 테이블에 항목을 추가하기 만합니다. CREATE TABLE 문은 인덱스에 올바른 형식이어야합니다. 임 포스터 테이블에 잘못된 수의 열이 있거나 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 이 아니 거나 인덱스 b- 트리와 호환되지 않는 경우 임 포스터 테이블을 사용할 때 &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fbbb0de8accee9d1365cb588f7fd022b3b5c2ef0" translate="yes" xml:space="preserve">
          <source>After the virtual table has been populated with items from multiple languages, specify the language of interest using a &quot;langid=N&quot; term in the WHERE clause of the query:</source>
          <target state="translated">가상 테이블이 여러 언어의 항목으로 채워진 후 쿼리의 WHERE 절에서 &quot;langid = N&quot;용어를 사용하여 관심있는 언어를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="71df6ec7d17df1770a907c6872e525177a99e4ae" translate="yes" xml:space="preserve">
          <source>AggFinal</source>
          <target state="translated">AggFinal</target>
        </trans-unit>
        <trans-unit id="5429b1962421b3a7ef0110360651a4a4da33b0bd" translate="yes" xml:space="preserve">
          <source>AggInverse</source>
          <target state="translated">AggInverse</target>
        </trans-unit>
        <trans-unit id="d448b9ea9be90bab4fd06d12a2a56f0f2d29976a" translate="yes" xml:space="preserve">
          <source>AggStep</source>
          <target state="translated">AggStep</target>
        </trans-unit>
        <trans-unit id="cec3f9e0080e6fe913455f3060c1205f8c71a2e5" translate="yes" xml:space="preserve">
          <source>AggStep1</source>
          <target state="translated">AggStep1</target>
        </trans-unit>
        <trans-unit id="d64e85e2bbdea61d402b8d3446eb6ec6b1845b61" translate="yes" xml:space="preserve">
          <source>AggValue</source>
          <target state="translated">AggValue</target>
        </trans-unit>
        <trans-unit id="558d7aad6e94b62a3c3d222979b260b60b6db7d2" translate="yes" xml:space="preserve">
          <source>Aggregate Functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="d7162a0d5ccbad3a77b64c735aa5b633485f7bdb" translate="yes" xml:space="preserve">
          <source>Aggregate Functions And The GROUP BY and HAVING Clauses</source>
          <target state="translated">집계 함수 및 GROUP BY 및 HAVING 절</target>
        </trans-unit>
        <trans-unit id="67a5e493a395536162c8208afa9edceff4645801" translate="yes" xml:space="preserve">
          <source>Aggregate window functions</source>
          <target state="translated">집계 창 기능</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="37b83d77a9eb919bf1eed567f29546fa4dda4c46" translate="yes" xml:space="preserve">
          <source>All C-preprocessor macros used to control compile-time options now begin with the prefix &quot;SQLITE_&quot;. This may require changes to applications that compile SQLite using their own makefiles and with custom compile-time options, hence we mark this as a *** Potentially incompatible change ***</source>
          <target state="translated">컴파일 타임 옵션을 제어하는 ​​데 사용되는 모든 C 전 처리기 매크로는 이제 접두사 &quot;SQLITE_&quot;로 시작합니다. 자체 makefile과 사용자 정의 컴파일 타임 옵션을 사용하여 SQLite를 컴파일하는 응용 프로그램을 변경해야 할 수 있으므로 *** 잠재적으로 호환되지 않는 변경 ***</target>
        </trans-unit>
        <trans-unit id="c755a70a5620bfbf08d2e74296f5e3952109420b" translate="yes" xml:space="preserve">
          <source>All FTS5 tables feature a special hidden column named &quot;rank&quot;. If the current query is not a full-text query (i.e. if it does not include a MATCH operator), the value of the &quot;rank&quot; column is always NULL. Otherwise, in a full-text query, column rank contains by default the same value as would be returned by executing the bm25() auxiliary function with no trailing arguments.</source>
          <target state="translated">모든 FTS5 테이블에는 &quot;rank&quot;라는 특수 숨겨진 열이 있습니다. 현재 쿼리가 전체 텍스트 쿼리가 아닌 경우 (예 : MATCH 연산자가 포함되지 않은 경우) &quot;rank&quot;열의 값은 항상 NULL입니다. 그렇지 않으면 전체 텍스트 쿼리에서 열 순위에는 기본적으로 후행 인수없이 bm25 () 보조 함수를 실행하여 반환되는 것과 동일한 값이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="1bb6feba3d971df2c155ebbf32ecf1aeefc50b98" translate="yes" xml:space="preserve">
          <source>All RBU updates use the &quot;OR ROLLBACK&quot; constraint handling mechanism.</source>
          <target state="translated">모든 RBU 업데이트는 &quot;OR ROLLBACK&quot;제약 조건 처리 메커니즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="298c1a6a5b3113028f5781057322c183e5fb18cf" translate="yes" xml:space="preserve">
          <source>All SQLite database connections running within a single process share a single</source>
          <target state="translated">단일 프로세스 내에서 실행되는 모든 SQLite 데이터베이스 연결은 단일 프로세스를 공유합니다</target>
        </trans-unit>
        <trans-unit id="68fd5c55fe4176eb0a40eb1e510440312024923d" translate="yes" xml:space="preserve">
          <source>All SQLite releases starting with 3.9.0 use a three-number &quot;&lt;a href=&quot;http://semver.org&quot;&gt;semantic version&lt;/a&gt;&quot; of the form X.Y.Z. The first number X is only increased when there is a change that breaks backward compatibility. The current value for X is 3, and the SQLite developers plan to support the current SQLite database file format, SQL syntax, and C interface through &lt;a href=&quot;lts&quot;&gt;at least the year 2050&lt;/a&gt;. Hence, one can expect that all future versions of SQLite for the next several decades will begin with &quot;3.&quot;.</source>
          <target state="translated">3.9.0으로 시작하는 모든 SQLite 릴리스 는 XYZ 형식 의 3 개의 &quot; &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전&lt;/a&gt; &quot;을 사용합니다. 첫 번째 숫자 X는 이전 버전과의 호환성을 손상시키는 변경이있을 때만 증가합니다. X의 현재 값은 3이며 SQLite 개발자 &lt;a href=&quot;lts&quot;&gt;는 2050 년 이상&lt;/a&gt; 현재 SQLite 데이터베이스 파일 형식, SQL 구문 및 C 인터페이스를 지원할 계획 입니다. 따라서 향후 수십 년 동안의 모든 향후 버전의 SQLite는 &quot;3&quot;으로 시작될 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbf3befd42e47b2311a200fc6c4505d6d3e74ba2" translate="yes" xml:space="preserve">
          <source>All calls obtain an exclusive &quot;checkpoint&quot; lock on the database file. If any other process is running a checkpoint operation at the same time, the lock cannot be obtained and SQLITE_BUSY is returned. Even if there is a busy-handler configured, it will not be invoked in this case.</source>
          <target state="translated">모든 호출은 데이터베이스 파일에 대한 독점 &quot;체크 포인트&quot;잠금을 얻습니다. 다른 프로세스가 동시에 체크 포인트 조작을 실행중인 경우 잠금을 확보 할 수 없으며 SQLITE_BUSY가 리턴됩니다. 사용중인 처리기가 구성되어 있어도이 경우에는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34e057ca62b435caa749880050f6e16611809628" translate="yes" xml:space="preserve">
          <source>All changes made by these functions are enclosed in a savepoint transaction. If any other error (aside from a constraint failure when attempting to write to the target database) occurs, then the savepoint transaction is rolled back, restoring the target database to its original state, and an SQLite error code returned.</source>
          <target state="translated">이 기능에 의한 모든 변경 사항은 저장 점 트랜잭션으로 묶여 있습니다. 대상 데이터베이스에 쓰려고 할 때 제한 조건 실패를 제외한 다른 오류가 발생하면 저장 점 트랜잭션이 롤백되어 대상 데이터베이스를 원래 상태로 복원하고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d1dddd8355c69e5dffb77af16e6ef1de6dd31f80" translate="yes" xml:space="preserve">
          <source>All changes to a virtual table are made using the xUpdate method. This one method can be used to insert, delete, or update.</source>
          <target state="translated">가상 테이블에 대한 모든 변경은 xUpdate 메소드를 사용하여 수행됩니다. 이 방법을 사용하여 삽입, 삭제 또는 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5f7c518c035d2e61b79e18649b848121cf76a11" translate="yes" xml:space="preserve">
          <source>All changes to be applied by RBU are stored in a separate SQLite database called the &quot;RBU database&quot;. The database that is to be modified is called the &quot;target database&quot;.</source>
          <target state="translated">RBU에 의해 적용되는 모든 변경 사항은 &quot;RBU 데이터베이스&quot;라는 별도의 SQLite 데이터베이스에 저장됩니다. 수정할 데이터베이스를 &quot;대상 데이터베이스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="99a33b875d90f9fced8d63e555c38a8d47436549" translate="yes" xml:space="preserve">
          <source>All code is archived on three separate machines: &lt;a href=&quot;https://www.sqlite.org&quot;&gt;https://www.sqlite.org&lt;/a&gt;, &lt;a href=&quot;https://www2.sqlite.org&quot;&gt;https://www2.sqlite.org&lt;/a&gt;, &lt;a href=&quot;https://www3.sqlite.org&quot;&gt;https://www3.sqlite.org&lt;/a&gt;. These machines are located in different cities (Dallas, Newark, and San Francisco, respectively) and managed by two different hosting companies (&lt;a href=&quot;https://linode.com&quot;&gt;Linode&lt;/a&gt; for the first two and &lt;a href=&quot;https://digitalocean.com&quot;&gt;Digital Ocean&lt;/a&gt; for the third). This diversity is intended to avoid a single point of failure.</source>
          <target state="translated">모든 코드는 &lt;a href=&quot;https://www.sqlite.org&quot;&gt;https://www.sqlite.org&lt;/a&gt; , &lt;a href=&quot;https://www2.sqlite.org&quot;&gt;https://www2.sqlite.org&lt;/a&gt; , &lt;a href=&quot;https://www3.sqlite.org&quot;&gt;https://www3.sqlite.org라는&lt;/a&gt; 세 개의 별도 시스템에 보관됩니다 . 이 시스템은 다른 도시 (각각 달라스, 뉴 어크 및 샌프란시스코)에 위치하고 있으며 두 개의 다른 호스팅 회사 ( 첫 번째 두 개는 &lt;a href=&quot;https://linode.com&quot;&gt;Linode&lt;/a&gt; , 세 번째는 &lt;a href=&quot;https://digitalocean.com&quot;&gt;Digital Ocean&lt;/a&gt; )가 관리합니다. 이 다양성은 단일 장애 지점을 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d9708b5aef2e3a29e2a2fbfcf884786831700182" translate="yes" xml:space="preserve">
          <source>All common table expressions (ordinary and recursive) are created by prepending a WITH clause in front of a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement. A single WITH clause can specify one or more common table expressions, some of which are ordinary and some of which are recursive.</source>
          <target state="translated">모든 공통 테이블 표현식 (일반 및 재귀)은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 앞에 WITH 절을 추가하여 작성됩니다 . 단일 WITH 절은 하나 이상의 공통 테이블 표현식을 지정할 수 있으며, 일부는 일반이고 일부는 재귀 적입니다.</target>
        </trans-unit>
        <trans-unit id="202e588a0b168a0b374436adc14ca3f0090beda4" translate="yes" xml:space="preserve">
          <source>All component tables must have the same PRIMARY KEY declaration (if any).</source>
          <target state="translated">모든 구성 요소 테이블에는 동일한 PRIMARY KEY 선언이 있어야합니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="daa2fa17b60e175765b75266a7e677f096a5be75" translate="yes" xml:space="preserve">
          <source>All component tables must have the same set of columns, in the same order.</source>
          <target state="translated">모든 구성 요소 테이블에는 동일한 순서로 동일한 열 세트가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="220fd2211d0e90275b8fb6a6e680abc0805ee11c" translate="yes" xml:space="preserve">
          <source>All connections hold SQLITE_LOCK_SHARED continuously while attached to a WAL-mode database. This is true for both read/write connections and read-only connections. The SQLITE_LOCK_SHARED lock is held even by connections that are not within transaction. This is different from rollback mode, where the SQLITE_LOCK_SHARED is released at the end of each transaction.</source>
          <target state="translated">모든 연결은 WAL 모드 데이터베이스에 연결되어있는 동안 SQLITE_LOCK_SHARED를 지속적으로 유지합니다. 읽기 / 쓰기 연결과 읽기 전용 연결 모두에 해당됩니다. SQLITE_LOCK_SHARED 잠금은 트랜잭션 내에 있지 않은 연결에서도 유지됩니다. 이는 롤백 모드와 다릅니다. 여기서 롤백 모드는 SQLITE_LOCK_SHARED가 각 트랜잭션 종료시 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="277f01faa8ef768e5f765984b4b0ad448802a74a" translate="yes" xml:space="preserve">
          <source>All database files to be modified by an UPDATE, INSERT or DELETE are now locked before any changes are made to any files. This makes it safe (I think) to access the same database simultaneously from multiple processes.</source>
          <target state="translated">UPDATE, INSERT 또는 DELETE에 의해 수정 될 모든 데이터베이스 파일은 이제 파일을 변경하기 전에 잠 깁니다. 이것은 여러 프로세스에서 동일한 데이터베이스에 동시에 액세스하는 것이 안전하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="bbad06084491f62976cce387f8ad55cb93120cd9" translate="yes" xml:space="preserve">
          <source>All existing versions of SQLite do a full table scan for ANALYZE. This can be slow for multi-gigabyte and larger databases. Future versions of SQLite might use random sampling rather than a full table scan to obtain estimates for the database shape, especially on larger tables. The results would approximate, but will be close enough for query planning purposes. As of 2017-03-20, this concept has been tested in experimental branches and appears to work well, but has not been folded into an official release.</source>
          <target state="translated">기존의 모든 SQLite 버전은 ANALYZE에 대한 전체 테이블 스캔을 수행합니다. 멀티 기가 바이트 이상의 데이터베이스에서는 느릴 수 있습니다. 이후 버전의 SQLite는 전체 테이블 스캔 대신 무작위 샘플링을 사용하여 특히 대형 테이블에서 데이터베이스 형태에 대한 추정치를 얻을 수 있습니다. 결과는 근사치이지만 쿼리 계획 목적으로 충분히 가깝습니다. 2017-03-20 현재이 개념은 실험 지점에서 테스트되었으며 잘 작동하는 것으로 보이지만 공식 릴리스로 접히지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="57093dee5c757a1ceefead7158318b61ace62d82" translate="yes" xml:space="preserve">
          <source>All extended result codes are also error codes. Hence the terms &quot;extended result code&quot; and &quot;extended error code&quot; are interchangeable.</source>
          <target state="translated">모든 확장 결과 코드도 오류 코드입니다. 따라서 &quot;확장 결과 코드&quot;와 &quot;확장 오류 코드&quot;라는 용어는 서로 바꿔 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c7deb3a8cda47ee51b4f2643f421866ddf4e49e" translate="yes" xml:space="preserve">
          <source>All five date and time functions take a time string as an argument. The time string is followed by zero or more modifiers. The strftime() function also takes a format string as its first argument.</source>
          <target state="translated">5 개의 날짜 및 시간 함수는 모두 시간 문자열을 인수로 사용합니다. 시간 문자열 뒤에는 0 개 이상의 수정자가옵니다. strftime () 함수는 형식 문자열을 첫 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="53a08b0d87542a21311bc53db7ff7fe3705579a9" translate="yes" xml:space="preserve">
          <source>All incompatibilities are on obscure interfaces and hence should have zero impact on most applications.</source>
          <target state="translated">모든 비 호환성은 모호한 인터페이스에 있으므로 대부분의 응용 프로그램에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7142a85dafa0005cc3ffdfca6d520d8fb0b49b9b" translate="yes" xml:space="preserve">
          <source>All internal computations assume the &lt;a href=&quot;http://en.wikipedia.org/wiki/Gregorian_calendar&quot;&gt;Gregorian calendar&lt;/a&gt; system. It is also assumed that every day is exactly 86400 seconds in duration.</source>
          <target state="translated">모든 내부 계산은 &lt;a href=&quot;http://en.wikipedia.org/wiki/Gregorian_calendar&quot;&gt;그레고리력&lt;/a&gt; 시스템을 가정합니다 . 또한 매일 지속 시간이 정확히 86400 초라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="04348814491f3fa4a3cfd08b8932122a12a20fd2" translate="yes" xml:space="preserve">
          <source>All joins in SQLite are &lt;a href=&quot;optoverview#table_order&quot;&gt;implemented using nested scans&lt;/a&gt;. When a SELECT query that features a join is analyzed using EXPLAIN QUERY PLAN, one SCAN or SEARCH record is output for each nested loop. For example:</source>
          <target state="translated">SQLite의 모든 조인은 &lt;a href=&quot;optoverview#table_order&quot;&gt;중첩 스캔을 사용하여 구현됩니다&lt;/a&gt; . EXPLAIN QUERY PLAN을 사용하여 조인 기능이있는 SELECT 쿼리를 분석하면 중첩 된 루프마다 하나의 SCAN 또는 SEARCH 레코드가 출력됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f65525e42bafddb791aaf9fce17e894639d4b9bf" translate="yes" xml:space="preserve">
          <source>All joins in SQLite are based on the cartesian product of the left and right-hand datasets. The columns of the cartesian product dataset are, in order, all the columns of the left-hand dataset followed by all the columns of the right-hand dataset. There is a row in the cartesian product dataset formed by combining each unique combination of a row from the left-hand and right-hand datasets. In other words, if the left-hand dataset consists of</source>
          <target state="translated">SQLite의 모든 조인은 왼쪽 및 오른쪽 데이터 집합의 데카르트 곱을 기반으로합니다. 직교 곱 데이터 세트의 열은 순서대로 왼쪽 데이터 세트의 모든 열과 오른쪽 데이터 세트의 모든 열입니다. 직교 제품 데이터 집합에는 왼쪽 및 오른쪽 데이터 집합에서 행의 고유 한 각 조합을 결합하여 행이 있습니다. 즉, 왼쪽 데이터 집합이</target>
        </trans-unit>
        <trans-unit id="71cb3ce79e6a6e92d559b23cf8ac04406011b307" translate="yes" xml:space="preserve">
          <source>All machines use SSD except Win7 which has a hard-drive. The test database is 100K blobs with sizes uniformly distributed between 8K and 12K, for a total of about 1 gigabyte of content. The database page size is 4KiB. The -DSQLITE_DIRECT_OVERFLOW_READ compile-time option was used for all of these tests. Tests were run multiple times. The first run was used to warm up the cache and its timings were discarded.</source>
          <target state="translated">하드 드라이브가있는 Win7을 제외한 모든 시스템에서 SSD를 사용합니다. 테스트 데이터베이스는 총 약 1 기가 바이트의 콘텐츠를 위해 8K와 12K 사이에 균일하게 분포 된 크기를 가진 100K Blob입니다. 데이터베이스 페이지 크기는 4KiB입니다. -DSQLITE_DIRECT_OVERFLOW_READ 컴파일 타임 옵션이이 모든 테스트에 사용되었습니다. 테스트는 여러 번 실행되었습니다. 첫 번째 실행은 캐시를 예열하는 데 사용되었으며 타이밍이 삭제되었습니다.</target>
        </trans-unit>
        <trans-unit id="1ffd5cbd04736788f9ab581e918b3089cbebbd40" translate="yes" xml:space="preserve">
          <source>All non-ASCII characters (those with codepoints greater than 127) are always considered token characters. If any non-ASCII characters are specified as part of the separators option, they are ignored.</source>
          <target state="translated">ASCII가 아닌 모든 문자 (코드 포인트가 127보다 큰 문자)는 항상 토큰 문자로 간주됩니다. ASCII가 아닌 문자가 구분 기호 옵션의 일부로 지정되면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b254312215697943ca788556e0d6b9c9450b8abd" translate="yes" xml:space="preserve">
          <source>All non-hidden columns (i.e. all columns matched by &quot;SELECT *&quot;) of the target table must be present in the input table. For virtual tables, hidden columns are optional - they are updated by RBU if present in the input table, or not otherwise. For example, to write to an fts4 table with a hidden languageid column such as:</source>
          <target state="translated">대상 테이블의 숨겨지지 않은 모든 열 (예 : &quot;SELECT *&quot;와 일치하는 모든 열)이 입력 테이블에 있어야합니다. 가상 테이블의 경우 숨겨진 열은 선택 사항입니다. 입력 테이블에있는 경우 RBU에 의해 업데이트되거나 그렇지 않으면 업데이트되지 않습니다. 예를 들어 숨겨진 languageid 열을 사용하여 fts4 테이블에 쓰려면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a8f660b04140a9109b926733d1d15823285d0d8f" translate="yes" xml:space="preserve">
          <source>All of SQLite's &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; may be used as aggregate window functions. It is also possible to &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;create user-defined aggregate window functions&lt;/a&gt;.</source>
          <target state="translated">모든 SQLite의 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계 함수&lt;/a&gt; 는 집계 창 함수로 사용될 수 있습니다. &lt;a href=&quot;windowfunctions#udfwinfunc&quot;&gt;사용자 정의 집계 창 함수&lt;/a&gt; 를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ceaa2e316a20fa6709117f30bf44efbc7dbbc8c3" translate="yes" xml:space="preserve">
          <source>All of the WAL-index locks, except for WAL_READ_LOCK(0), are held exclusively while reconstructing the global shared WAL-index during &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt;.</source>
          <target state="translated">WAL_READ_LOCK (0)을 제외한 모든 WAL 인덱스 잠금은 독점적으로 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 중에 글로벌 공유 WAL 인덱스를 재구성하는 동안 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="d0d3bdb37117516e584fc85e1c08d9757cba475e" translate="yes" xml:space="preserve">
          <source>All of the _printf() routines above are built around the following two functions:</source>
          <target state="translated">위의 모든 _printf () 루틴은 다음 두 함수를 중심으로 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="99f6322b342eb9d2dc214ced37e7517990352762" translate="yes" xml:space="preserve">
          <source>All of the above definitions are included in the &quot;sqlite.h&quot; header file that comes in the source tree.</source>
          <target state="translated">위의 모든 정의는 소스 트리에있는 &quot;sqlite.h&quot;헤더 파일에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="693deb1c0ebd6029cb9d2f1f239c3bb4c352f744" translate="yes" xml:space="preserve">
          <source>All of the above is possible with Git, given the right extensions and tools and using the right commands. But it is not easy to do, and so it rarely gets done. Consequently, developers have less awareness of what is happening in the code.</source>
          <target state="translated">올바른 확장 및 도구를 제공하고 올바른 명령을 사용하면 Git에서 위의 모든 것이 가능합니다. 그러나 쉬운 일이 아니므로 거의 끝나지 않습니다. 결과적으로 개발자는 코드에서 발생하는 일에 대한 인식이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="ae8b16657892b5f01e3b5c073bd55f99b7c4acd2" translate="yes" xml:space="preserve">
          <source>All of the built-in SQL functions of SQLite are created using exactly these same interfaces. Refer to the SQLite source code, and in particular the &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/date.c&quot;&gt;date.c&lt;/a&gt; and &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/func.c&quot;&gt;func.c&lt;/a&gt; source files for examples.</source>
          <target state="translated">SQLite의 모든 내장 SQL 함수는 정확히 동일한 인터페이스를 사용하여 작성됩니다. SQLite 소스 코드, 특히 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/date.c&quot;&gt;date.c&lt;/a&gt; 및 &lt;a href=&quot;http://www.sqlite.org/src/doc/trunk/src/func.c&quot;&gt;func.c&lt;/a&gt; 소스 파일을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc1d5a95c4233b63280d0f7d11d256d9ad3780ef" translate="yes" xml:space="preserve">
          <source>All of the complications above (and others not mentioned here) arise from the need to preserve backwards compatibility for the hundreds of billions of SQLite database files in circulation. In a perfect world, there would be no such thing as a &quot;rowid&quot; and all tables would following the standard semantics implemented as &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables, only without the extra &quot;WITHOUT ROWID&quot; keywords. Unfortunately, life is messy. The designer of SQLite offers his sincere apology for the current mess.</source>
          <target state="translated">위의 모든 복잡한 문제 (및 여기에 언급되지 않은 다른 문제)는 수백억 개의 SQLite 데이터베이스 파일에 대한 하위 호환성을 유지해야 할 필요가 있습니다. 완벽한 세계에서 &quot;rowid&quot;와 같은 것은 없으며 모든 테이블은 &lt;a href=&quot;withoutrowid&quot;&gt;WITHROWROW&lt;/a&gt; 테이블 없이 구현 된 표준 의미 체계를 따르며 여분의 &quot;WITHOUT ROWID&quot;키워드없이 만 수행됩니다 . 불행히도 인생은 지저분합니다. SQLite의 디자이너는 현재 혼란에 대해 진심으로 사과드립니다.</target>
        </trans-unit>
        <trans-unit id="778689296bb157e74a14076a42a4ee37798df0eb" translate="yes" xml:space="preserve">
          <source>All of the existing safe languages are new. The developers of SQLite applaud the efforts of computer language researchers in trying to develop languages that are easier to program safely. We encourage these efforts to continue. Be we ourselves are more interested in old and boring languages when it comes to implementing SQLite.</source>
          <target state="translated">기존의 모든 안전한 언어는 새로운 언어입니다. SQLite 개발자는 컴퓨터 언어 연구원이 안전하게 프로그래밍하기 쉬운 언어를 개발하려는 노력에 박수를 보냅니다. 이러한 노력이 계속 될 것을 권장합니다. 우리는 SQLite를 구현할 때 오래되고 지루한 언어에 더 관심이 있습니까?</target>
        </trans-unit>
        <trans-unit id="7375d32a78c6b8f51d450c556f25932bdf217bf1" translate="yes" xml:space="preserve">
          <source>All of the experiments that follow operate the same with either &quot;test1.dir&quot; or &quot;test1.tree&quot;. Very little performance difference is measured in either case, regardless of operating system.</source>
          <target state="translated">다음의 모든 실험은 &quot;test1.dir&quot;또는 &quot;test1.tree&quot;와 동일하게 작동합니다. 운영 체제와 상관없이 두 경우 모두 성능 차이가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="643d0c9cb63fb8635827200eced1089f9e88183c" translate="yes" xml:space="preserve">
          <source>All of the result in the example are the same if the comparisons are commuted - if expressions of the form &quot;a&amp;lt;40&quot; are rewritten as &quot;40&amp;gt;a&quot;.</source>
          <target state="translated">&quot;a &amp;lt;40&quot;형식의 표현식을 &quot;40&amp;gt; a&quot;로 다시 쓰면 비교가 통근되는 경우 예제의 모든 결과가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="cc0e885150a13c9c4803941a5f8336469ed747f0" translate="yes" xml:space="preserve">
          <source>All of the tests above must run successfully, on multiple platforms and under multiple compile-time configurations, before each release of SQLite.</source>
          <target state="translated">위의 모든 테스트는 각 SQLite 릴리스 전에 여러 플랫폼 및 여러 컴파일 타임 구성에서 성공적으로 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7efae1cd770ea6fe5f2bf4478750e0f4cc942ea9" translate="yes" xml:space="preserve">
          <source>All of these commands work the same way if the filename argument is is a ZIP Archive instead of an SQLite database.</source>
          <target state="translated">filename 인수가 SQLite 데이터베이스 대신 ZIP 아카이브 인 경우 이러한 모든 명령이 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bf4dfc2a775cfce09d4f8b1860eec11883d0cac7" translate="yes" xml:space="preserve">
          <source>All of these factors combine to make SQLite a very trouble-free software library.</source>
          <target state="translated">이러한 모든 요소가 결합되어 SQLite를 문제없는 소프트웨어 라이브러리로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7683c6e8ad5efd15af0f1da2349a585dbe4001cb" translate="yes" xml:space="preserve">
          <source>All of these things can be provided in a single auxiliary C code file and then linked with the stock &quot;sqlite3.c&quot; code file to generate a working SQLite build for the target operating system. In addition to the alternative mutex and memory allocation subsystems and the new VFS, the auxiliary C code file should contain implementations for the following two routines:</source>
          <target state="translated">이 모든 것을 단일 보조 C 코드 파일로 제공 한 다음 스톡 &quot;sqlite3.c&quot;코드 파일과 연결하여 대상 운영 체제에 대해 작동하는 SQLite 빌드를 생성 할 수 있습니다. 대체 뮤텍스 및 메모리 할당 서브 시스템 및 새로운 VFS 외에도 보조 C 코드 파일에는 다음 두 루틴에 대한 구현이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="690aa8cfa4b8586b89a0a9eedc4d3f3b13222c70" translate="yes" xml:space="preserve">
          <source>All other bytes of the database file header are reserved for future expansion and must be set to zero.</source>
          <target state="translated">데이터베이스 파일 헤더의 다른 모든 바이트는 향후 확장을 위해 예약되어 있으며 0으로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="74f932ce0ba425204c0c4c7e4d764d13c207d60d" translate="yes" xml:space="preserve">
          <source>All processes using a database must be on the same host computer; WAL does not work over a network filesystem.</source>
          <target state="translated">데이터베이스를 사용하는 모든 프로세스는 동일한 호스트 컴퓨터에 있어야합니다. WAL은 네트워크 파일 시스템을 통해 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="78a418c8d3a0ce039842b297ad3c3dfb42d51a90" translate="yes" xml:space="preserve">
          <source>All queries on the table must be full-text queries. In other words, they must use the MATCH or = operator with the table-name column as the left-hand operand, or else use the table-valued function syntax. Any query that is not a full-text query results in an error.</source>
          <target state="translated">테이블의 모든 쿼리는 전체 텍스트 쿼리 여야합니다. 즉, 왼쪽 피연산자로 table-name 열과 함께 MATCH 또는 = 연산자를 사용하거나 테이블 반환 함수 구문을 사용해야합니다. 전체 텍스트 쿼리가 아닌 쿼리는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="38351d4546ab4ff59382ce23bdac471def2ad5d5" translate="yes" xml:space="preserve">
          <source>All reads from and writes to the main database file begin at a page boundary and all writes are an integer number of pages in size. Reads are also usually an integer number of pages in size, with the one exception that when the database is first opened, the first 100 bytes of the database file (the database file header) are read as a sub-page size unit.</source>
          <target state="translated">기본 데이터베이스 파일에 대한 모든 읽기 및 쓰기는 페이지 경계에서 시작하며 모든 쓰기는 크기가 정수인 페이지 수입니다. 읽기는 일반적으로 크기가 정수인 페이지 수이지만 데이터베이스를 처음 열 때 데이터베이스 파일의 첫 100 바이트 (데이터베이스 파일 헤더)를 하위 페이지 크기 단위로 읽는다는 점을 제외하고는 정수 페이지 수입니다.</target>
        </trans-unit>
        <trans-unit id="d450d3a75d9f08311a07a29768bf79cccc1c19d2" translate="yes" xml:space="preserve">
          <source>All result codes are integers. Symbolic names for all result codes are created using &quot;#define&quot; macros in the sqlite3.h header file. There are separate sections in the sqlite3.h header file for the &lt;a href=&quot;c3ref/c_abort&quot;&gt;result code definitions&lt;/a&gt; and the &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;extended result code definitions&lt;/a&gt;.</source>
          <target state="translated">모든 결과 코드는 정수입니다. 모든 결과 코드의 기호 이름은 sqlite3.h 헤더 파일에서 &quot;#define&quot;매크로를 사용하여 작성됩니다. sqlite3.h 헤더 파일에는 &lt;a href=&quot;c3ref/c_abort&quot;&gt;결과 코드 정의&lt;/a&gt; 와 &lt;a href=&quot;c3ref/c_abort_rollback&quot;&gt;확장 결과 코드 정의&lt;/a&gt; 에 대한 별도의 섹션이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4028b4aa3d3e24115d72e2f624df2443ac4d4652" translate="yes" xml:space="preserve">
          <source>All spaces following the first two keywords are converted into a single space.</source>
          <target state="translated">처음 두 키워드 뒤에 오는 모든 공백은 단일 공백으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e86f24edc76db2b20a12087f5cf419af602faa95" translate="yes" xml:space="preserve">
          <source>All string values at the SQL level in SQLite are dynamic strings. Requiring type strings to be static makes it difficult to create an application-defined SQL function that can synthesize a pointer of an arbitrary type. We do not want users to create such SQL functions, since such functions would compromise the security of the system. Thus, the requirement to use static strings helps to defend that the integrity of the pointer-passing interfaces against ill-designed SQL functions. The static string requirement is not a perfect defense, since a sophisticated programmer can code around it, and a novice program can simply take the memory leak. But by stating that the pointer type string must be static, we hope to encourage developers who might otherwise use a dynamic string for the pointer type to think more carefully about the problem and avoid introducing security issues.</source>
          <target state="translated">SQLite의 SQL 수준에있는 모든 문자열 값은 동적 문자열입니다. 유형 문자열을 정적으로 요구하면 임의 유형의 포인터를 합성 할 수있는 애플리케이션 정의 SQL 함수를 작성하기가 어렵습니다. 이러한 기능이 시스템의 보안을 손상시킬 수 있기 때문에 사용자가 이러한 SQL 기능을 작성하는 것을 원하지 않습니다. 따라서 정적 문자열을 사용해야하는 요구 사항은 잘못 디자인 된 SQL 함수에 대한 포인터 전달 인터페이스의 무결성을 방어하는 데 도움이됩니다. 정적 문자열 요구 사항은 정교한 프로그래머가 코드를 작성할 수 있고 초보자 프로그램이 단순히 메모리 누수를 일으킬 수 있기 때문에 완벽한 방어 수단은 아닙니다. 그러나 포인터 유형 문자열은 정적이어야한다고 말함으로써포인터 유형에 동적 문자열을 사용하는 개발자가 문제에 대해 더 신중하게 생각하고 보안 문제가 발생하지 않도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="9a460cfc406da09ab8128bfc4445d97c56d406f1" translate="yes" xml:space="preserve">
          <source>All subsequent command line words are command arguments, not options.</source>
          <target state="translated">모든 후속 명령 줄 단어는 옵션이 아니라 명령 인수입니다.</target>
        </trans-unit>
        <trans-unit id="1ed156deca85bc9a5dd9088fbd94f8a842f1f33c" translate="yes" xml:space="preserve">
          <source>All substitutions begin with a single &quot;%&quot; and end with a single type character. The other elements of the substitution are optional.</source>
          <target state="translated">모든 대체는 단일 &quot;%&quot;로 시작하고 단일 유형 문자로 끝납니다. 대체의 다른 요소는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="6c42d2b7071c7a3c388400fdb8f6ee7f3109b7cf" translate="yes" xml:space="preserve">
          <source>All tables that participate in a union-vtab must be &lt;a href=&quot;rowidtable&quot;&gt;rowid tables&lt;/a&gt;.</source>
          <target state="translated">union-vtab에 참여하는 모든 테이블은 &lt;a href=&quot;rowidtable&quot;&gt;rowid 테이블&lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a31bee81e9b968bc240c90d0ddec46a1b51435a7" translate="yes" xml:space="preserve">
          <source>All tables that participate in a union-vtab must have identical CREATE TABLE definitions, except that the names of the tables can be different.</source>
          <target state="translated">union-vtab에 참여하는 모든 테이블은 테이블 이름이 다를 수 있다는 점을 제외하고 동일한 CREATE TABLE 정의를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="567093004d4bf6708c2d16ff16df1498f9ca4cec" translate="yes" xml:space="preserve">
          <source>All terms of the WHERE clause are analyzed to see if they can be satisfied using indices. To be usable by an index a term must be of one of the following forms:</source>
          <target state="translated">WHERE 절의 모든 용어는 인덱스를 사용하여 만족할 수 있는지 분석합니다. 인덱스에서 사용하려면 용어는 다음 형식 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="cbf993933e40301457f333ff6f1f8a23481fc0a6" translate="yes" xml:space="preserve">
          <source>All tests are conducted on an otherwise quiescent machine. A simple Tcl script was used to generate and run all the tests. A copy of this Tcl script can be found in the SQLite source tree in the file &lt;b&gt;tools/speedtest.tcl&lt;/b&gt;.</source>
          <target state="translated">모든 테스트는 그렇지 않은 대기 시스템에서 수행됩니다. 간단한 Tcl 스크립트를 사용하여 모든 테스트를 생성하고 실행했습니다. 이 Tcl 스크립트의 사본은 &lt;b&gt;tools / speedtest.tcl&lt;/b&gt; 파일의 SQLite 소스 트리에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b130e54f0f69ef3abad26bc072b0470f6263286a" translate="yes" xml:space="preserve">
          <source>All tests must give the same answer in all three builds. See the &lt;a href=&quot;testing&quot;&gt;&quot;How SQLite Is Tested&quot;&lt;/a&gt; document for more detail.</source>
          <target state="translated">모든 테스트는 세 가지 빌드 모두에서 동일한 답변을 제공해야합니다. 자세한 내용은 &lt;a href=&quot;testing&quot;&gt;&quot;SQLite 테스트 방법&quot;&lt;/a&gt; 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67d8d36777ef2e501af7ab9b2e6ef786e48ae2b6" translate="yes" xml:space="preserve">
          <source>All that said, it is possible that SQLite might one day be recoded in Rust. Recoding SQLite in Go is unlikely since Go hates assert(). But Rust is a possibility. Some preconditions that must occur before SQLite is recoded in Rust include:</source>
          <target state="translated">그러나 SQLite가 언젠가 Rust에서 코딩 될 수 있습니다. Go가 assert ()를 싫어하기 때문에 Go에서 SQLite를 코딩하는 것은 불가능합니다. 그러나 녹은 가능성이 있습니다. Rust에서 SQLite를 레코딩하기 전에 발생해야하는 일부 전제 조건은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="707caca3d9bbd176531f568662a7102a40b5f6fd" translate="yes" xml:space="preserve">
          <source>All the example queries above return the ten most relevant query results. By modifying the values used with the OFFSET and LIMIT clauses, a query to return (say) the next ten most relevant results is easy to construct. This may be used to obtain the data required for a search applications second and subsequent pages of results.</source>
          <target state="translated">위의 모든 예제 쿼리는 10 개의 가장 관련성이 높은 쿼리 결과를 반환합니다. OFFSET 및 LIMIT 절에 사용 된 값을 수정하면 가장 관련성이 높은 다음 10 개의 결과를 반환하는 쿼리가 쉽게 구성됩니다. 검색 응용 프로그램의 두 번째 및 후속 결과 페이지에 필요한 데이터를 얻는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="470143461be606a45aab0f210d1498edb2c84368" translate="yes" xml:space="preserve">
          <source>All things considered, applications should normally be able to hold their maximum memory allocation size below 2K or 4K. This gives a value for log&lt;sub&gt;2&lt;/sub&gt;(&lt;b&gt;n&lt;/b&gt;) of 2 or 3. This will limit &lt;b&gt;N&lt;/b&gt; to between 2 and 2.5 times &lt;b&gt;M&lt;/b&gt;.</source>
          <target state="translated">응용 프로그램은 일반적으로 최대 메모리 할당 크기를 2K 또는 4K 미만으로 유지할 수 있어야합니다. 이것은 로그 &lt;sub&gt;2&lt;/sub&gt; ( &lt;b&gt;n&lt;/b&gt; )에 2 또는 3 의 값을 제공합니다. 이것은 &lt;b&gt;N&lt;/b&gt; 을 2에서 2.5 배 &lt;b&gt;M으로 제한&lt;/b&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="635a64a808a6eed58043c45da38b8c4ec5742ac1" translate="yes" xml:space="preserve">
          <source>All three auxiliary functions extract a set of &quot;matchable phrases&quot; from the FTS query expression to work with. The set of matchable phrases for a given query consists of all phrases (including unquoted tokens and token prefixes) in the expression except those that are prefixed with a unary &quot;-&quot; operator (standard syntax) or are part of a sub-expression that is used as the right-hand operand of a NOT operator.</source>
          <target state="translated">세 가지 보조 함수는 모두 FTS 쿼리 표현식에서 &quot;일치하는 문구&quot;세트를 추출하여 작업합니다. 주어진 검색어에 대해 일치하는 문구 세트는 단항 &quot;-&quot;연산자 (표준 구문)가 앞에 붙거나 하위 표현식의 일부인 문구를 제외하고 표현식의 모든 문구 (인용되지 않은 토큰 및 토큰 접두사 포함)로 구성됩니다. NOT 연산자의 오른쪽 피연산자로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e856a97cf9fae10a8a385ba08b2985c87e16aaf1" translate="yes" xml:space="preserve">
          <source>All three database engines run faster when they have indices to work with. But SQLite is still the fastest.</source>
          <target state="translated">3 개의 데이터베이스 엔진 모두 작업 할 인덱스가있을 때 더 빠르게 실행됩니다. 그러나 SQLite는 여전히 가장 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="6baeeca7bdbd41abd15a40b8b926de6f745b8bb0" translate="yes" xml:space="preserve">
          <source>All three of the above source files are contained in the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;amalgamation tarball&lt;/a&gt; available on the &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;download page&lt;/a&gt;.</source>
          <target state="translated">위의 3 가지 소스 파일은 모두 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;다운로드 페이지&lt;/a&gt; 에서 제공되는 &lt;a href=&quot;https://sqlite.org/download.html&quot;&gt;합병 타르볼에&lt;/a&gt; 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bf60184a7e675d81f6bedcfe7ca27f21750f46d0" translate="yes" xml:space="preserve">
          <source>All type information or constraint specifications must be removed from column definitions. FTS3/4 ignores everything following the column name in a column definition, FTS5 attempts to parse it (and will report an error if it fails to).</source>
          <target state="translated">모든 유형 정보 또는 제한 조건 스펙은 열 정의에서 제거해야합니다. FTS3 / 4는 열 정의에서 열 이름 뒤에 오는 모든 것을 무시하고 FTS5는 구문 분석을 시도하고 실패하면 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="a1de722aadb01564eff9284d3ae40b05c75cdc11" translate="yes" xml:space="preserve">
          <source>All uppercase characters within the ASCII range (Unicode codepoints less than 128), are transformed to their lowercase equivalents as part of the tokenization process. Thus, full-text queries are case-insensitive when using the simple tokenizer.</source>
          <target state="translated">ASCII 범위 (유니 코드 코드 포인트 128 미만) 내의 모든 대문자는 토큰 화 프로세스의 일부로 소문자로 변환됩니다. 따라서 간단한 토크 나이저를 사용할 때 전체 텍스트 쿼리는 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="230a993ba607de10c8e04d67e19e0d8357f45f60" translate="yes" xml:space="preserve">
          <source>All values in SQL statements, whether they are literals embedded in SQL statement text or &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; bound to &lt;a href=&quot;c3ref/stmt&quot;&gt;precompiled SQL statements&lt;/a&gt; have an implicit storage class. Under circumstances described below, the database engine may convert values between numeric storage classes (INTEGER and REAL) and TEXT during query execution.</source>
          <target state="translated">SQL 문 텍스트에 임베드 된 리터럴이든 &lt;a href=&quot;c3ref/stmt&quot;&gt;사전 컴파일 된 SQL 문에&lt;/a&gt; 바인드 된 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수&lt;/a&gt; 이든 SQL 문의 모든 값 에는 내재 된 스토리지 클래스가 있습니다. 아래 설명 된 상황에서 데이터베이스 엔진은 쿼리 실행 중 숫자 스토리지 클래스 (INTEGER 및 REAL)와 TEXT 사이의 값을 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2db63f1dd84225eeca5b66732ebeb7dfeca7e9c" translate="yes" xml:space="preserve">
          <source>All versions of SQLite since 3.3.0 (2006-01-10) can read and write any schema format between 1 and 4. But older versions of SQLite might not be able to read formats greater than 1. So that older versions of SQLite will be able to read and write database files created by newer versions of SQLite, the default schema format was set to 1 for SQLite versions through 3.7.9 (2011-11-01). Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;version 3.7.10&lt;/a&gt; (2012-01-16), the default schema format is 4.</source>
          <target state="translated">3.3.0 (2006-01-10) 이후의 모든 SQLite 버전은 1과 4 사이의 스키마 형식을 읽고 쓸 수 있습니다. 그러나 이전 버전의 SQLite는 1보다 큰 형식을 읽을 수 없습니다. 따라서 이전 버전의 SQLite는 최신 버전의 SQLite에서 만든 데이터베이스 파일을 읽고 쓸 수 있도록 기본 스키마 형식은 3.7.9 (2011-11-01)까지 SQLite 버전의 경우 1로 설정되었습니다. &lt;a href=&quot;https://sqlite.org/releaselog/3_7_10.html&quot;&gt;버전 3.7.10&lt;/a&gt; (2012-01-16) 부터 기본 스키마 형식은 4입니다.</target>
        </trans-unit>
        <trans-unit id="a315e152418f974223f0caef4a38a40619deaba9" translate="yes" xml:space="preserve">
          <source>All versions of SQLite up to and including &lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;version 3.7.9&lt;/a&gt; (2011-11-01) assume that the filesystem does &lt;u&gt;not&lt;/u&gt; provide powersafe overwrite. SQLite has traditionally assumed that when any one byte of a file changes, all other bytes within the same sector of that byte have the potential of being corrupted on a power loss. When writing, SQLite has made sure to journal all bytes in the same sector of any modifications and it pads journal files out to the next sector boundary so that subsequent appends to that journal cannot damage prior records. SQLite understands the sector size to be the value returned by the xSectorSize method in the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;. The SQLite team has often referred to the value returned by xSectorSize as the &quot;blast radius&quot; of a write, since it expresses the range of bytes that might be damaged if a power loss occurs during the write. The default &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; for unix and windows have always returned 512 as the sector size (or blast radius) for all versions of SQLite up to and including version 3.7.9.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_7_9.html&quot;&gt;버전 3.7.9&lt;/a&gt; (2011-11-01) 이하의 모든 SQLite 버전은 파일 시스템이 전원 안전 덮어 쓰기를 제공 하지 &lt;u&gt;않는다고&lt;/u&gt; 가정합니다 . SQLite는 전통적으로 파일의 1 바이트가 변경 될 때 해당 바이트의 동일한 섹터 내에있는 다른 모든 바이트가 전원 손실로 인해 손상 될 가능성이 있다고 가정했습니다. 작성할 때 SQLite는 수정 된 동일한 섹터의 모든 바이트를 저널링해야하며 저널 파일을 다음 섹터 경계에 채워서 해당 저널에 추가 할 때 이전 레코드를 손상시킬 수 없습니다. SQLite는 섹터 크기를 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xSectorSize 메소드가 리턴 한 값으로 이해합니다.. SQLite 팀은 종종 xSectorSize에서 반환 된 값을 쓰기의 &quot;폭발 반경&quot;이라고했습니다. 쓰기 중에 전원 손실이 발생할 경우 손상 될 수있는 바이트 범위를 나타냅니다. 유닉스와 윈도우 의 기본 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 는 3.7.9까지의 모든 버전의 SQLite에 대한 섹터 크기 (또는 블라스트 반경)로 항상 512를 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="3ff80c8a340db91dd8a4375abd89d32aa974509b" translate="yes" xml:space="preserve">
          <source>All versions of SQLite up to and including version 3.5.9 have mishandled NULL values on the right-hand side of IN and NOT IN operators. Specifically, SQLite has previously ignored NULLs on the right-hand side of IN and NOT IN.</source>
          <target state="translated">버전 3.5.9 이하의 모든 SQLite 버전은 IN 및 NOT IN 연산자의 오른쪽에서 NULL 값을 잘못 처리했습니다. 특히 SQLite는 이전에 IN과 NOT IN의 오른쪽에서 NULL을 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="f103276ac70c09043aecb18573124bfe2497c24b" translate="yes" xml:space="preserve">
          <source>Allocate a new b-tree in the main database file if P1==0 or in the TEMP database file if P1==1 or in an attached database if P1&amp;gt;1. The P3 argument must be 1 (BTREE_INTKEY) for a rowid table it must be 2 (BTREE_BLOBKEY) for an index or WITHOUT ROWID table. The root page number of the new b-tree is stored in register P2.</source>
          <target state="translated">P1 == 0 인 경우 기본 데이터베이스 파일 또는 P1 == 1 인 경우 TEMP 데이터베이스 파일 또는 P1&amp;gt; 1 인 경우 연결된 데이터베이스에 새 b- 트리를 할당하십시오. P3 인수는 rowid 테이블의 경우 1 (BTREE_INTKEY)이어야하고 인덱스 또는 WITHOUT ROWID 테이블의 경우 2 (BTREE_BLOBKEY) 여야합니다. 새로운 b- 트리의 루트 페이지 번호는 레지스터 P2에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="98c7e4f88a0a3613dabebb78baaf9f796e649934" translate="yes" xml:space="preserve">
          <source>Allocate a new changeset rebaser object. If successful, set (*ppNew) to point to the new object and return SQLITE_OK. Otherwise, if an error occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) to NULL.</source>
          <target state="translated">새로운 체인지 셋 rebaser 객체를 할당하십시오. 성공하면 (* ppNew)를 설정하여 새 오브젝트를 가리키고 SQLITE_OK를 리턴하십시오. 그렇지 않으면, 오류가 발생하면 SQLite 오류 코드 (예 : SQLITE_NOMEM)를 리턴하고 (* ppNew)를 NULL로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="890d83377e0f9622417e6019e12893679bb2c728" translate="yes" xml:space="preserve">
          <source>Allocate a new page if it easy and convenient to do so. Otherwise return NULL.</source>
          <target state="translated">새 페이지를 쉽고 편리하게 할당하십시오. 그렇지 않으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0b563fc1e21cbbe40e2fcd69876f3f214fc04c0f" translate="yes" xml:space="preserve">
          <source>Allow &quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot; as a shorthand for &quot;&amp;lt;expr&amp;gt; IN (SELECT * FROM &amp;lt;table&amp;gt;&quot;.</source>
          <target state="translated">&quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot;의 줄임말로 &quot;&amp;lt;expr&amp;gt; IN &amp;lt;table&amp;gt;&quot;을 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="06d0f1303155aabcd4262ede8a9d90bfb68ed8f4" translate="yes" xml:space="preserve">
          <source>Allow &quot;?&quot; parameters in the LIMIT clause.</source>
          <target state="translated">허용하다 &quot;?&quot; LIMIT 절의 매개 변수.</target>
        </trans-unit>
        <trans-unit id="cd8e51f439edbc4cbc973e08ee46366e6e096d45" translate="yes" xml:space="preserve">
          <source>Allow &quot;VIEW&quot; to be a column name</source>
          <target state="translated">&quot;VIEW&quot;가 열 이름이되도록 허용</target>
        </trans-unit>
        <trans-unit id="377c13da16b3a423a23503b52be9d946eb79c0be" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;deterministic&quot;&gt;deterministic SQL functions&lt;/a&gt; in the WHERE clause of a &lt;a href=&quot;partialindex&quot;&gt;partial index&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;partialindex&quot;&gt;부분 인덱스&lt;/a&gt; 의 WHERE 절에 &lt;a href=&quot;deterministic&quot;&gt;결정적 SQL 함수&lt;/a&gt; 를 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9a09844684ca2e04e8580f1dc89f5d23c5aed0e" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands to work inside of a transaction.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; 명령이 트랜잭션 내에서 작동하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9aa4176f2699ab1a840e5917668b064b3516ba4" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;vtab#tabfunc2&quot;&gt;table-valued functions&lt;/a&gt; to appear on the right-hand side of an &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN operator&lt;/a&gt;.</source>
          <target state="translated">허용 &lt;a href=&quot;vtab#tabfunc2&quot;&gt;테이블 값 함수&lt;/a&gt; 의 우측에 표시 &lt;a href=&quot;lang_expr#in_op&quot;&gt;IN 연산자&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48d9b4c29aa05f94ecb72a287ad5d41af03effad" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual tables&lt;/a&gt; to be writable if the PRIMARY KEY contains exactly one column.</source>
          <target state="translated">PRIMARY KEY에 정확히 하나의 열이 있으면 &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID 가상 테이블&lt;/a&gt; 을 쓸 수 있도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="269070c3e8d911c8236d5f897186b3e1ab6e4e31" translate="yes" xml:space="preserve">
          <source>Allow &lt;a href=&quot;wal&quot;&gt;WAL-mode&lt;/a&gt; databases to be opened read-only as long as there is an existing read/write connection.</source>
          <target state="translated">허용 &lt;a href=&quot;wal&quot;&gt;WAL-모드&lt;/a&gt; 데이터베이스는 읽기 전용으로 한 기존의 읽기 / 쓰기 연결이로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef741e84d49fdcc8210ba15eda342eea0faf46a9" translate="yes" xml:space="preserve">
          <source>Allow GLOB and LIKE operators to work as functions.</source>
          <target state="translated">GLOB 및 LIKE 연산자가 함수로 작동하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d8d8f395445a63807721ea16945b2777fb51092" translate="yes" xml:space="preserve">
          <source>Allow NULL arguments in sqlite_compile() and sqlite_step().</source>
          <target state="translated">sqlite_compile () 및 sqlite_step ()에서 NULL 인수를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="186268005d1a02f259dbb9958233b56b69668278" translate="yes" xml:space="preserve">
          <source>Allow WHERE clause terms on the left table of a LEFT OUTER JOIN to contain aggregate subqueries.</source>
          <target state="translated">LEFT OUTER JOIN의 왼쪽 테이블에있는 WHERE 절 용어에 집계 서브 쿼리가 포함되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="38079f81b0c869a35e192a7c7ee51456917575b5" translate="yes" xml:space="preserve">
          <source>Allow a &lt;a href=&quot;lang_select#values&quot;&gt;VALUES clause&lt;/a&gt; to be used anywhere a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement is valid.</source>
          <target state="translated">허용 &lt;a href=&quot;lang_select#values&quot;&gt;VALUES 절은&lt;/a&gt; 어디에서나 사용되는 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b29c570354c3dc76b997275a38b4804dd30d724a" translate="yes" xml:space="preserve">
          <source>Allow arbitrary expressions, including function calls and subqueries, in the filename argument to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 의 파일 이름 인수에 함수 호출 및 서브 쿼리를 포함한 임의의 표현식을 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="087d2618f268406853ee3cd79209ec421c2d288d" translate="yes" xml:space="preserve">
          <source>Allow collating sequence names to be quoted.</source>
          <target state="translated">조합 순서 이름을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="026b30b967a2b6589a1cfbc782a3c2b403048beb" translate="yes" xml:space="preserve">
          <source>Allow constraint names on the DEFAULT clause in a table definition</source>
          <target state="translated">테이블 정의의 DEFAULT 절에 제한 조건 이름 허용</target>
        </trans-unit>
        <trans-unit id="6215a826c022df62b341a6590cb9e2024e5f7525" translate="yes" xml:space="preserve">
          <source>Allow floating point literals to begin or end with a decimal point.</source>
          <target state="translated">부동 소수점 리터럴이 소수점으로 시작하거나 끝나도록합니다.</target>
        </trans-unit>
        <trans-unit id="25c2ba2fe3b0e6c9a56edf6ddf62886b17854fb2" translate="yes" xml:space="preserve">
          <source>Allow identifiers to be quoted in square brackets, for compatibility with MS-Access.</source>
          <target state="translated">MS-Access와의 호환성을 위해 식별자를 대괄호로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a61cbdfe59167766b82b62a24a23f799327821d" translate="yes" xml:space="preserve">
          <source>Allow indices to be used for sorting even if prior terms of the index are constrained by IN operators in the WHERE clause.</source>
          <target state="translated">인덱스의 사전 용어가 WHERE 절에서 IN 연산자에 의해 제한되는 경우에도 색인을 사용하여 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ef34a12d16effc2a1e0c0a26a046cc6b9ba4f95" translate="yes" xml:space="preserve">
          <source>Allow more system calls to be overridden in the unix VFS - to provide better support for chromium sandboxes.</source>
          <target state="translated">크롬 샌드 박스에 대한보다 나은 지원을 제공하기 위해 유닉스 VFS에서 더 많은 시스템 호출을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5d47c202ac74ad6be5e5952c7d032a0006fd10e" translate="yes" xml:space="preserve">
          <source>Allow multiple simultaneous readers under Windows by simulating the reader/writers locks that are missing from Win95/98/ME.</source>
          <target state="translated">Win95 / 98 / ME에없는 판독기 / 기록기 잠금을 시뮬레이션하여 Windows에서 여러 개의 동시 판독기를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="aec002f75566ff8ab7f2b3337c8366c012290ae9" translate="yes" xml:space="preserve">
          <source>Allow new user-defined functions to be created when there are already one or more precompiled SQL statements.</source>
          <target state="translated">하나 이상의 사전 컴파일 된 SQL 문이 이미있을 때 새 사용자 정의 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="331932f674e6d859e399fb8d0775ada55921d45e" translate="yes" xml:space="preserve">
          <source>Allow read transactions to be freely opened and closed by SQL statements run from within the implementation of &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt; if the function is called by a SELECT statement that does not access any database table.</source>
          <target state="translated">데이터베이스 테이블에 액세스하지 않는 SELECT 문에서 함수를 호출 한 경우 &lt;a href=&quot;c3ref/create_function&quot;&gt;애플리케이션 정의 SQL 함수&lt;/a&gt; 구현 내에서 실행되는 SQL 문으로 읽기 트랜잭션을 자유롭게 열고 닫을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16104cba6ed4e5c5fd3de40cb546c3fb1bc3c957" translate="yes" xml:space="preserve">
          <source>Allow sqlite_exec() to be called from within user-defined SQL functions.</source>
          <target state="translated">sqlite_exec ()를 사용자 정의 SQL 함수 내에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9296631111fc0993d0527ddffb1b74601f16736" translate="yes" xml:space="preserve">
          <source>Allow the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command to change the page size of a database file.</source>
          <target state="translated">&lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 데이터베이스 파일의 페이지 크기를 변경하도록 허용 하십시오.</target>
        </trans-unit>
        <trans-unit id="aac64bf7a32177d90d0452da0d0056ea1b87de06" translate="yes" xml:space="preserve">
          <source>Allow the &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex()&lt;/a&gt; method of &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt; implementations to return &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; to indicate that the proposed query plan is unusable and should not be given further consideration.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 구현 의 &lt;a href=&quot;vtab#xbestindex&quot;&gt;xBestIndex ()&lt;/a&gt; 메소드가 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; 를 리턴 하여 제안 된 쿼리 계획을 사용할 수 없으며 더 이상 고려하지 않아야 함을 표시하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="6424ee4a8785aaef1a25b07cf3555293853c9183" translate="yes" xml:space="preserve">
          <source>Allow the DEFAULT value of a column to call functions that have constant operands</source>
          <target state="translated">열의 DEFAULT 값이 상수 피연산자가있는 함수를 호출하도록 허용</target>
        </trans-unit>
        <trans-unit id="6b663434ab971b5c50c2b931e627bcf32963ce5d" translate="yes" xml:space="preserve">
          <source>Allow the error message from &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to be longer than 20000 bytes.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 의 오류 메시지 가 20000 바이트를 초과하도록 허용하십시오 .</target>
        </trans-unit>
        <trans-unit id="acb3e6f837b7598e3baf15397c889298e8fd1c4d" translate="yes" xml:space="preserve">
          <source>Allow the name of a database to be prefixed by the driver type. For now, the only driver type is &quot;gdbm:&quot;.</source>
          <target state="translated">데이터베이스 이름에 드라이버 유형이 접두어로 허용되도록하십시오. 현재 유일한 드라이버 유형은 &quot;gdbm :&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="dfc00039aaf898d163afc8dbd0e94542ba8ecc28" translate="yes" xml:space="preserve">
          <source>Allow the value -9223372036854775808 as an integer literal in SQL statements.</source>
          <target state="translated">SQL 문에서 -9223372036854775808 값을 정수 리터럴로 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="dee90ceb52dbab56bc4990303982723135b728d9" translate="yes" xml:space="preserve">
          <source>Allow transactions to span Linux Threads</source>
          <target state="translated">트랜잭션이 Linux 스레드를 확장하도록 허용</target>
        </trans-unit>
        <trans-unit id="5ffa48f8c38520d1cf8de848950d598b10eb8e45" translate="yes" xml:space="preserve">
          <source>Allow up to 64 tables in a join - the old limit was 32.</source>
          <target state="translated">조인에서 최대 64 개의 테이블을 허용합니다. 이전 제한은 32입니다.</target>
        </trans-unit>
        <trans-unit id="d2fef18fe97d9b603d8ce243c65accbdab4d874a" translate="yes" xml:space="preserve">
          <source>Allow virtual table constructors to be invoked recursively.</source>
          <target state="translated">가상 테이블 생성자가 재귀 적으로 호출되도록합니다.</target>
        </trans-unit>
        <trans-unit id="90e23d564e7f297c7a2b5ceff9d8f6ef229ac9a5" translate="yes" xml:space="preserve">
          <source>Allowed P5 bits:</source>
          <target state="translated">허용 된 P5 비트 :</target>
        </trans-unit>
        <trans-unit id="1287cd665e8d2234952aeb1f2ae2c3398192c7b9" translate="yes" xml:space="preserve">
          <source>Allowing extension components to pass private information to one another securely and without introducing pointer leaks requires new interfaces:</source>
          <target state="translated">확장 구성 요소가 개인 정보를 안전하게 전달하고 포인터 누출을 유발하지 않으면 새로운 인터페이스가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0d20875a194118243c2bc48398fc9e50e653168b" translate="yes" xml:space="preserve">
          <source>Alphabetical Listing Of All Documents</source>
          <target state="translated">모든 문서의 알파벳순 목록</target>
        </trans-unit>
        <trans-unit id="fc6ed234869c2180894bb5c831639c8bf2a71c3a" translate="yes" xml:space="preserve">
          <source>Also available is the similar but more mature &lt;a href=&quot;fts3&quot;&gt;FTS3/4&lt;/a&gt; module. FTS5 is a new version of FTS4 that includes various fixes and solutions for problems that could not be fixed in FTS4 without sacrificing backwards compatibility. Some of these problems are &lt;a href=&quot;fts5#_summary_of_technical_differences_&quot;&gt;described below&lt;/a&gt;.</source>
          <target state="translated">유사하지만보다 성숙한 &lt;a href=&quot;fts3&quot;&gt;FTS3 / 4&lt;/a&gt; 모듈 도 사용할 수 있습니다 . FTS5는 이전 버전과의 호환성을 유지하면서 FTS4에서 수정할 수없는 문제에 대한 다양한 수정 및 솔루션을 포함하는 FTS4의 새로운 버전입니다. 이러한 문제 중 일부는 &lt;a href=&quot;fts5#_summary_of_technical_differences_&quot;&gt;아래&lt;/a&gt; 에 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cdc4b8824c8f732ab94ebdcfb7669cd9ac01bcf0" translate="yes" xml:space="preserve">
          <source>Also available: &lt;a href=&quot;../rescode&quot;&gt;list of error codes&lt;/a&gt;</source>
          <target state="translated">사용 가능한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f04534899f708d46ebaa30f16a02cbe243e196ae" translate="yes" xml:space="preserve">
          <source>Also available: &lt;a href=&quot;rescode&quot;&gt;list of error codes&lt;/a&gt;</source>
          <target state="translated">사용 가능한 &lt;a href=&quot;rescode&quot;&gt;오류 코드 목록&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="861a9e2d67fe5f61973dab8932f2db2e113ce546" translate="yes" xml:space="preserve">
          <source>Also, whether or not P4 is set, check that this is not being called from within a callback to a virtual table xSync() method. If it is, the error code will be set to SQLITE_LOCKED.</source>
          <target state="translated">또한 P4의 설정 여부에 따라 콜백 내에서 가상 테이블 xSync () 메소드로 호출되지 않는지 확인하십시오. 그렇다면 오류 코드가 SQLITE_LOCKED로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="087d1b6052e351518f2d15a60b3d4e94a4ca524e" translate="yes" xml:space="preserve">
          <source>Alternatively, FTS5 may be built as a loadable extension.</source>
          <target state="translated">또는 FTS5를로드 가능한 확장으로 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0c1c99f2707eb260cd81c76dc0cd3c1b0734ce4" translate="yes" xml:space="preserve">
          <source>Alternatively, the first argument following to &quot;.ar&quot; may be the concatenation of the short form of all required options (without the &quot;-&quot; characters). In this case arguments for options requiring them are read from the command line next, and any remaining words are considered command arguments. For example:</source>
          <target state="translated">또는 &quot;.ar&quot;다음에 오는 첫 번째 인수는 모든 필수 옵션의 짧은 형식 ( &quot;-&quot;문자 제외)을 연결 한 것일 수 있습니다. 이 경우 옵션이 필요한 옵션에 대한 인수는 다음 명령 행에서 읽히고 나머지 단어는 명령 인수로 간주됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5abd2d3f1bfc69f474a1675b744197ff1ab504ae" translate="yes" xml:space="preserve">
          <source>Alternatively, the unionvtab.c file may be compiled into the application. In this case, the following function should be invoked to register the extension with each new database connection:</source>
          <target state="translated">또는 unionvtab.c 파일을 응용 프로그램으로 컴파일 할 수 있습니다. 이 경우, 각각의 새 데이터베이스 연결에 확장을 등록하려면 다음 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee75d1aa4e172f68779a1484c212e21f3e9f3faf" translate="yes" xml:space="preserve">
          <source>Alternatively, the zipfile.c file may be compiled into the application. In this case, the following function should be invoked to register the extension with each new database connection:</source>
          <target state="translated">또는 zipfile.c 파일을 응용 프로그램으로 컴파일 할 수 있습니다. 이 경우, 각각의 새 데이터베이스 연결에 확장을 등록하려면 다음 함수를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="5944ffdf9815956de892051d5dd5e1fe60e1a9e4" translate="yes" xml:space="preserve">
          <source>Alternatively, you can create a new database using the default temporary storage, then save that database into a disk file using the &quot;.save&quot; command:</source>
          <target state="translated">또는 기본 임시 저장소를 사용하여 새 데이터베이스를 만든 다음 &quot;.save&quot;명령을 사용하여 해당 데이터베이스를 디스크 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b777ccc0b549914aaf4c953fa2687953baa7c2b" translate="yes" xml:space="preserve">
          <source>Although FTS3 and FTS4 are included with the SQLite core source code, they are not enabled by default. To build SQLite with FTS functionality enabled, define the preprocessor macro &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; when compiling. New applications should also define the &lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; macro to enable the &lt;a href=&quot;fts3#_set_operations_using_the_enhanced_query_syntax&quot;&gt;enhanced query syntax&lt;/a&gt; (see below). Usually, this is done by adding the following two switches to the compiler command line:</source>
          <target state="translated">FTS3 및 FTS4는 SQLite 코어 소스 코드에 포함되어 있지만 기본적으로 활성화되어 있지 않습니다. FTS 기능이 사용 가능한 SQLite를 빌드하려면 컴파일 할 때 전 처리기 매크로 &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3을&lt;/a&gt; 정의하십시오 . 새로운 응용 프로그램은 또한 &lt;a href=&quot;fts3#_set_operations_using_the_enhanced_query_syntax&quot;&gt;향상된 쿼리 구문&lt;/a&gt; 을 활성화하기 위해 &lt;a href=&quot;compile#enable_fts3_parenthesis&quot;&gt;SQLITE_ENABLE_FTS3_PARENTHESIS&lt;/a&gt; 매크로를 정의해야 합니다 (아래 참조). 일반적으로 컴파일러 명령 줄에 다음 두 스위치를 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="024fe1545f30cb8dee088c5ad188ae320d8b4ae9" translate="yes" xml:space="preserve">
          <source>Although it is less common, a call to &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; or &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; may also return SQLITE_LOCKED if it cannot obtain a read-lock on the sqlite_master table of each attached database. These APIs need to read the schema data contained in the sqlite_master table in order to compile SQL statements to &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt*&lt;/a&gt; objects.</source>
          <target state="translated">일반적이지 않지만 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 호출 은 연결된 각 데이터베이스의 sqlite_master 테이블에서 읽기 잠금을 얻을 수없는 경우 SQLITE_LOCKED를 리턴 할 수도 있습니다. 이러한 API는 SQL 문을 &lt;a href=&quot;c3ref/stmt&quot;&gt;sqlite3_stmt *&lt;/a&gt; 오브젝트 로 컴파일하려면 sqlite_master 테이블에 포함 된 스키마 데이터를 읽어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f535c18aa59fdbaaceb49a43b9f2ac5c4e156d04" translate="yes" xml:space="preserve">
          <source>Although it would be easy to design a system that uses the</source>
          <target state="translated">사용하는 시스템을 설계하는 것은 쉽지만</target>
        </trans-unit>
        <trans-unit id="6556666b4b860beb62beea54857b52422d71a07f" translate="yes" xml:space="preserve">
          <source>Always convert IEEE floating point NaN values into NULL during processing. (Ticket #3060)</source>
          <target state="translated">처리 중에는 항상 IEEE 부동 소수점 NaN 값을 NULL로 변환하십시오. (티켓 # 3060)</target>
        </trans-unit>
        <trans-unit id="87b27942fc2ef02de9cc71a49d6d11d937c022cb" translate="yes" xml:space="preserve">
          <source>Always interpret non-zero floating-point values as TRUE, even if the integer part is zero. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/36fae083b450e3a&quot;&gt;36fae083b450e3a&lt;/a&gt;</source>
          <target state="translated">정수 부분이 0 인 경우에도 항상 0이 아닌 부동 소수점 값을 TRUE로 해석하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/36fae083b450e3a&quot;&gt;36fae083b450e3a&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="01c848b30df81d8f55cf3c7d1f8d1d01a761b810" translate="yes" xml:space="preserve">
          <source>Always open files using FILE_FLAG_RANDOM_ACCESS under Windows.</source>
          <target state="translated">Windows에서는 항상 FILE_FLAG_RANDOM_ACCESS를 사용하여 파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="c0cacbdc1960d533261c8055f23aacbc49821e24" translate="yes" xml:space="preserve">
          <source>Always use &quot;.&quot; instead of &quot;,&quot; as the decimal point even if the locale requests &quot;,&quot;.</source>
          <target state="translated">항상 &quot;.&quot;를 사용하십시오. 로케일이 &quot;,&quot;를 요청하더라도 소수점 대신 &quot;,&quot;대신.</target>
        </trans-unit>
        <trans-unit id="584a08c96e54122403ed19c82a813d569f28232d" translate="yes" xml:space="preserve">
          <source>Always use memory</source>
          <target state="translated">항상 메모리를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="c823a3478b423d7cd3fa93f63e415cd1f8284276" translate="yes" xml:space="preserve">
          <source>Always use temporary files</source>
          <target state="translated">항상 임시 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="57bd289a4480abf71228980bc961a3a7a81bab14" translate="yes" xml:space="preserve">
          <source>Ambiguity resolved using a WHERE clause:</source>
          <target state="translated">모호성은 WHERE 절을 사용하여 해결되었습니다.</target>
        </trans-unit>
        <trans-unit id="977cc4fa3c5b3e0d768448bc0910909b0cd480d9" translate="yes" xml:space="preserve">
          <source>Ambiguous use of ON:</source>
          <target state="translated">ON의 모호한 사용 :</target>
        </trans-unit>
        <trans-unit id="7e0cddb45b39e592335cd66056d26b1854d76f94" translate="yes" xml:space="preserve">
          <source>Among other things, sqlite3_initialize() will invoke sqlite3_os_init(). Similarly, sqlite3_shutdown() will invoke sqlite3_os_end().</source>
          <target state="translated">무엇보다도 sqlite3_initialize ()는 sqlite3_os_init ()를 호출합니다. 마찬가지로 sqlite3_shutdown ()은 sqlite3_os_end ()를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="6a0ecb85fd4a2b4dd0713046f9744fe6177cf89e" translate="yes" xml:space="preserve">
          <source>An &quot;SQLite Archive&quot; is a file container similar to a &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP archive&lt;/a&gt; or &lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;Tarball&lt;/a&gt; but based on an SQLite database.</source>
          <target state="translated">&quot;SQLite Archive&quot;는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Zip_(file_format)&quot;&gt;ZIP 아카이브&lt;/a&gt; 또는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tar_(computing)&quot;&gt;Tarball&lt;/a&gt; 과 유사 하지만 SQLite 데이터베이스를 기반으로하는 파일 컨테이너 입니다.</target>
        </trans-unit>
        <trans-unit id="348f5f09abc7f6ee023e124686a6cf3527b1dbca" translate="yes" xml:space="preserve">
          <source>An &quot;application file format&quot; is the file format used to persist application state to disk or to exchange information between programs. There are thousands of application file formats in use today. Here are just a few examples:</source>
          <target state="translated">&quot;응용 프로그램 파일 형식&quot;은 응용 프로그램 상태를 디스크에 유지하거나 프로그램간에 정보를 교환하는 데 사용되는 파일 형식입니다. 오늘날 사용중인 수천 개의 응용 프로그램 파일 형식이 있습니다. 다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="b8d82aa19e1738a25aad29a6b9a73b1ca57ba1dc" translate="yes" xml:space="preserve">
          <source>An &quot;external content&quot; FTS4 table is similar to a contentless table, except that if evaluation of a query requires the value of a column other than docid, FTS4 attempts to retrieve that value from a table (or view, or virtual table) nominated by the user (hereafter referred to as the &quot;content table&quot;). The FTS4 module never writes to the content table, and writing to the content table does not affect the full-text index. It is the responsibility of the user to ensure that the content table and the full-text index are consistent.</source>
          <target state="translated">&quot;외부 콘텐츠&quot;FTS4 테이블은 쿼리를 평가할 때 docid 이외의 열 값이 필요한 경우 FTS4가 지정한 테이블 (또는 뷰 또는 가상 테이블)에서 해당 값을 검색하려고한다는 점을 제외하고는 내용없는 테이블과 유사합니다. 사용자 (이하 &quot;컨텐츠 테이블&quot;이라고 함). FTS4 모듈은 내용 테이블에 쓰지 않으며 내용 테이블에 쓰더라도 전체 텍스트 인덱스에 영향을 미치지 않습니다. 콘텐츠 테이블과 전체 텍스트 인덱스가 일관성을 유지하는 것은 사용자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="3ec1d3e19881ca421cb7ef0c70026b7ad57adf0c" translate="yes" xml:space="preserve">
          <source>An &quot;int&quot; or &quot;unsigned int&quot;. 32-bits on all modern systems.</source>
          <target state="translated">&quot;int&quot;또는 &quot;unsigned int&quot;입니다. 모든 최신 시스템에서 32 비트</target>
        </trans-unit>
        <trans-unit id="8ca7e1d1ee9bc38ef78e0ad004ec09a25f38b015" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file in the &lt;a href=&quot;#sqlite3_vfs&quot;&gt;OS interface layer&lt;/a&gt;. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that defines methods for performing I/O operations on the open file.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 목적은 파일의 오픈 나타내는 &lt;a href=&quot;#sqlite3_vfs&quot;&gt;OS 인터페이스 층&lt;/a&gt; . 개별 OS 인터페이스 구현은 자체 사용을 위해 추가 필드를 추가하여이 오브젝트를 서브 클래스 화하려고합니다. pMethods 항목은 열린 파일에서 I / O 조작을 수행하기위한 메소드를 정의 하는 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="04381375841e88bf037fe1e6179f30d5aff3be33" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; that fails due to a constraint violation is not a successful &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.</source>
          <target state="translated">&lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 제약 조건 위반으로 인해 실패 성공하지 &lt;a href=&quot;../lang_insert&quot;&gt;INSERT&lt;/a&gt; 이 루틴에 의해 반환 된 값을 변경하지 않습니다. 따라서 INSERT 또는 FAIL, INSERT 또는 IGNORE, INSERT OR ROLLBACK 및 INSERT OR ABORT는 삽입 실패시이 루틴의 리턴 값을 변경하지 않습니다. INSERT OR REPLACE에 제약 조건 위반이 발생해도 실패하지 않습니다. 제약 조건 문제를 일으킨 행을 삭제 한 후 INSERT는 계속 완료되므로 INSERT OR REPLACE는 항상이 인터페이스의 반환 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="b7085e9237366e0a877aba7cfe87f1fe93d5ad83" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object defines the name of the VFS and the core methods that implement the interface to the operating system, such as checking for existence of files, deleting files, creating files and opening and for reading and/or writing, converting filenames into their canonical form. The &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object also contains methods for obtaining randomness from the operating system, for suspending a process (sleeping) and for finding the current date and time.</source>
          <target state="translated">&lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체는 VFS 및 파일의 존재 여부를 확인 파일을 삭제, 파일과 개방을 만드는 등 자신의 표준에 파일 이름을 변환, 읽기 및 / 또는 쓰기 운영 시스템에 인터페이스를 구현하는 핵심 방법의 이름을 정의 형태. &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs는&lt;/a&gt; 또한 프로세스 (자)를 정지하고 상기 현재 날짜와 시간을 찾기 위해, 운영 체제에서 난수를 획득하기위한 메소드를 포함하는 개체.</target>
        </trans-unit>
        <trans-unit id="1f60bd7f87def89c1a6337dcd5b5e2b9262a189b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object represents an open file in the &lt;a href=&quot;vfs&quot;&gt;OS interface layer&lt;/a&gt;. Individual OS interface implementations will want to subclass this object by appending additional fields for their own use. The pMethods entry is a pointer to an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object that defines methods for performing I/O operations on the open file.</source>
          <target state="translated">&lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 목적은 파일의 오픈 나타내는 &lt;a href=&quot;vfs&quot;&gt;OS 인터페이스 층&lt;/a&gt; . 개별 OS 인터페이스 구현은 자체 사용을 위해 추가 필드를 추가하여이 오브젝트를 서브 클래스 화하려고합니다. pMethods 항목은 열린 파일에서 I / O 조작을 수행하기위한 메소드를 정의 하는 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="7a08f9e5c908a78454f64ebfc15b9347529f0e74" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;http://en.wikipedia.org/wiki/R-tree&quot;&gt;R-Tree&lt;/a&gt; is a special index that is designed for doing range queries. R-Trees are most commonly used in geospatial systems where each entry is a rectangle with minimum and maximum X and Y coordinates. Given a query rectangle, an R-Tree is able to quickly find all entries that are contained within the query rectangle or which overlap the query rectangle. This idea is easily extended to three dimensions for use in CAD systems. R-Trees also find use in time-domain range look-ups. For example, suppose a database records the starting and ending times for a large number of events. A R-Tree is able to quickly find all events that were active at any time during a given time interval, or all events that started during a particular time interval, or all events that both started and ended within a given time interval. And so forth.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/R-tree&quot;&gt;R-트리&lt;/a&gt;범위 쿼리를 수행하도록 설계된 특수 인덱스입니다. R- 트리는 각 항목이 최소 및 최대 X 및 Y 좌표를 가진 사각형 인 지리 공간 시스템에서 가장 일반적으로 사용됩니다. 쿼리 사각형이 주어지면 R-Tree는 쿼리 사각형 내에 포함되거나 쿼리 사각형과 겹치는 모든 항목을 빠르게 찾을 수 있습니다. 이 아이디어는 CAD 시스템에서 사용하기 위해 3 차원으로 쉽게 확장됩니다. R- 트리는 또한 시간 영역 범위 검색에서 사용됩니다. 예를 들어, 데이터베이스가 많은 이벤트의 시작 및 종료 시간을 기록한다고 가정하십시오. R-Tree는 주어진 시간 간격 동안 언제든지 활성화 된 모든 이벤트, 또는 특정 시간 간격 동안 시작된 모든 이벤트 또는 주어진 시간 간격 내에서 시작 및 종료 된 모든 이벤트를 빠르게 찾을 수 있습니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="db689d4a40dd989536fc477e73ac5f455ae9b267" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause may be specified as part of an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; action within the body of the trigger. However if an &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clause is specified as part of the statement causing the trigger to fire, then conflict handling policy of the outer statement is used instead.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON 충돌&lt;/a&gt; 절은의 일부로서 특정 될 수 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 또는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT의&lt;/a&gt; 트리거의 체내 작용. 그러나 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절이 트리거를 발생시키는 명령문의 일부로 지정된 경우 외부 명령문의 충돌 처리 정책이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e711e9ab5f059bf81635cdaabe4f6f12406ca0c" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement with multiple values in the VALUES clause is implemented internally as a compound SELECT. Hence, this option also disables the ability to insert more than a single row using an INSERT INTO ... VALUES ... statement.</source>
          <target state="translated">VALUES 절에 여러 값이 있는 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문은 내부적으로 복합 SELECT로 구현됩니다. 따라서이 옵션은 또한 INSERT INTO ... VALUES ... 문을 사용하여 둘 이상의 행을 삽입하는 기능을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c72576d10f0db6ca1b372a30155a9969a36efce9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that fails due to a constraint violation is not a successful &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; and does not change the value returned by this routine. Thus INSERT OR FAIL, INSERT OR IGNORE, INSERT OR ROLLBACK, and INSERT OR ABORT make no changes to the return value of this routine when their insertion fails. When INSERT OR REPLACE encounters a constraint violation, it does not fail. The INSERT continues to completion after deleting rows that caused the constraint problem so INSERT OR REPLACE will always change the return value of this interface.</source>
          <target state="translated">&lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 제약 조건 위반으로 인해 실패 성공하지 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 이 루틴에 의해 반환 된 값을 변경하지 않습니다. 따라서 INSERT 또는 FAIL, INSERT 또는 IGNORE, INSERT OR ROLLBACK 및 INSERT OR ABORT는 삽입 실패시이 루틴의 리턴 값을 변경하지 않습니다. INSERT OR REPLACE에 제약 조건 위반이 발생해도 실패하지 않습니다. 제약 조건 문제를 일으킨 행을 삭제 한 후 INSERT는 계속 완료되므로 INSERT OR REPLACE는 항상이 인터페이스의 반환 값을 변경합니다.</target>
        </trans-unit>
        <trans-unit id="233c7df9e2b5c5b148e9cdae3dbfbdc38ff611a4" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT&lt;/a&gt; error is returned when SQLite detects an error in the structure, format, or other control elements of the database file.</source>
          <target state="translated">&lt;a href=&quot;rescode#corrupt&quot;&gt;SQLITE_CORRUPT의&lt;/a&gt; SQLite는이 구조, 형식, 또는 데이터베이스 파일의 다른 제어 요소에서 오류를 검출 할 때 에러가 반환된다.</target>
        </trans-unit>
        <trans-unit id="9dfcb5b52a759e3eac1cc34a332a837f3610b881" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error is returned when a prepared SQL statement is no longer valid and cannot be executed. When this occurs, the statement must be recompiled from SQL using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; API. An SQLITE_SCHEMA error can only occur when using the &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;, and &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interfaces to run SQL. You will never receive an &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; error from &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt;. Nor will you receive an error if you prepare statements using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; instead of &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA의&lt;/a&gt; 준비된 SQL 문이 더 이상 유효하고 실행 할 수없는 경우 오류가 반환되지 않습니다. 이 경우, &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; API를 사용하여 명령문을 SQL에서 다시 컴파일해야합니다 . SQLITE_SCHEMA 오류는 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스를 사용하여 SQL을 실행할 때만 발생할 수 있습니다 . &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 에서 &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류가 수신되지 않습니다 . 당신이 사용하는 문을 준비한다면,도 아니다 당신이 오류가 발생합니다 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()를&lt;/a&gt; 대신 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ceb0be389d3467046061e0e60795dd9c8924c2d5" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;INSERT&lt;/b&gt;. An INSERT change contains a single row to add to a database table. The payload of the INSERT change consists of the values for each field of the new row.</source>
          <target state="translated">&lt;b&gt;INSERT&lt;/b&gt; . INSERT 변경 사항에는 데이터베이스 테이블에 추가 할 단일 행이 포함됩니다. INSERT 변경의 페이로드는 새 행의 각 필드에 대한 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="83cdb736e009dffced879294068506baa8e9d683" translate="yes" xml:space="preserve">
          <source>An &lt;b&gt;UPDATE&lt;/b&gt;. An UPDATE change represents the modification of one or more non-PRIMARY KEY fields of a single row within a database table, identified by its PRIMARY KEY fields. The payload for an UPDATE change consists of:</source>
          <target state="translated">&lt;b&gt;UPDATE&lt;/b&gt; . UPDATE 변경은 PRIMARY KEY 필드로 식별되는 데이터베이스 테이블 내 단일 행의 하나 이상의 기본이 아닌 KEY 필드의 수정을 나타냅니다. UPDATE 변경에 대한 페이로드는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a5dfc23afaff11afa8f689dfc92f096e1d0dd0f7" translate="yes" xml:space="preserve">
          <source>An ALWAYS(X) or NEVER(X) sometimes verifies pre-conditions that are subject to change if other parts of the code are modified in subtle ways. At &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&lt;/a&gt; we have a test for two pre-conditions that are true only because of the limited scope of use of the sqlite3BtreeRowCountEst() function. Future enhancements to SQLite might use sqlite3BtreeRowCountEst() in new ways where those preconditions no longer hold, and the NEVER() macros will quickly alert the developers to that fact when the situation arises. But if, for some reason, the pre-conditions are not satisfied in a release build, the program will still behave sanely and will not do an undefined memory access.</source>
          <target state="translated">ALWAYS (X) 또는 NEVER (X)는 때때로 코드의 다른 부분이 미묘한 방식으로 수정 될 경우 변경 될 수있는 사전 조건을 확인합니다. 에서 &lt;a href=&quot;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&quot;&gt;https://sqlite.org/src/artifact/18a53540aa3?ln=5512-5516&lt;/a&gt; 우리는 때문에 sqlite3BtreeRowCountEst () 함수의 사용 제한 범위에 해당하는 두 개의 사전 조건에 대한 테스트가 있습니다. 향후 SQLite 개선 사항은 sqlite3BtreeRowCountEst ()를 이러한 전제 조건이 더 이상 유지되지 않는 새로운 방식으로 사용할 수 있으며 NEVER () 매크로는 상황이 발생하면 개발자에게 그 사실을 신속하게 경고합니다. 그러나 어떤 이유로 릴리스 빌드에서 사전 조건이 충족되지 않으면 프로그램은 여전히 ​​이상하게 동작하며 정의되지 않은 메모리 액세스를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62094908e44ce569763e84accf72b5b81ec10e3e" translate="yes" xml:space="preserve">
          <source>An Abort is safe if either there have been no writes, or if there is an active statement journal.</source>
          <target state="translated">중단은 쓰기가 없거나 활성 명령문 저널이있는 경우 안전합니다.</target>
        </trans-unit>
        <trans-unit id="86d4a08053c797c7b22cbaba83f05ba798cb81a9" translate="yes" xml:space="preserve">
          <source>An Asynchronous I/O Module For SQLite</source>
          <target state="translated">SQLite를위한 비동기 I / O 모듈</target>
        </trans-unit>
        <trans-unit id="313cb43d54770c72c9e9a5b634de9c9d8807284f" translate="yes" xml:space="preserve">
          <source>An EXCLUDE clause.</source>
          <target state="translated">EXCLUDE 절.</target>
        </trans-unit>
        <trans-unit id="0a3ccdd1b90a20f1709a032dfb49632f1706153c" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_CKPT_LOCK is held by any connection that is running a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt;. The &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; field of the WAL-index header may be increased while holding this exclusive lock, but it may not be decreased.</source>
          <target state="translated">EXCLUSIVE WAL_CKPT_LOCK은 &lt;a href=&quot;wal#ckpt&quot;&gt;검사 점을&lt;/a&gt; 실행하는 모든 연결에 의해 유지됩니다 . 이 독점 잠금을 유지하면서 WAL 인덱스 헤더 의 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; 필드를 늘릴 수 있지만 줄이지는 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42a19836854f508f748dd9a22070d5c210f0d520" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_RECOVER_LOCK is held by any connection that is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; to reconstruct the shared WAL-index.</source>
          <target state="translated">EXCLUSIVE WAL_RECOVER_LOCK은 공유 WAL- 인덱스를 재구성하기 위해 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행중인 모든 연결에 의해 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="d163a00e9e60a29df0fd7690728f45560ff5f27b" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE WAL_WRITE_LOCK is held by any connection that is appending content to the end of the WAL. Hence, only a single process at a time can append content to the WAL. If a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; occurs as a consequence of a write, then the &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt; field of the WAL-index header is reset to zero while holding this lock.</source>
          <target state="translated">EXCLUSIVE WAL_WRITE_LOCK은 WAL 끝에 컨텐츠를 추가하는 모든 연결에 의해 유지됩니다. 따라서 한 번에 하나의 프로세스 만 WAL에 내용을 추가 할 수 있습니다. 경우 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL 재설정&lt;/a&gt; 쓰기의 결과로 발생 후 &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill의&lt;/a&gt; 월마트 인덱스 헤더의 필드는이 잠금을 보유하는 동안 0으로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="b57abe13c7006fd13b284a30313d8dda20eaf017" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE is also held WAL_CKPT_LOCK, and on several other locking bytes, when a connection is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; on the shared WAL-index.</source>
          <target state="translated">연결이 공유 WAL- 인덱스 에서 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행하는 경우 EXCLUSIVE도 WAL_CKPT_LOCK과 다른 여러 잠금 바이트에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="88b81d585355ad5a271ae62aa21273cf7062ea05" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE is also held WAL_WRITE_LOCK, and on several other locking bytes, when a connection is running &lt;a href=&quot;walformat#recovery&quot;&gt;recovery&lt;/a&gt; on the shared WAL-index.</source>
          <target state="translated">연결이 공유 WAL- 인덱스 에서 &lt;a href=&quot;walformat#recovery&quot;&gt;복구&lt;/a&gt; 를 실행하는 경우 EXCLUSIVE도 WAL_WRITE_LOCK과 다른 여러 잠금 바이트에 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="f52310ba827cb9fe23894a867314c3a13854ff87" translate="yes" xml:space="preserve">
          <source>An EXCLUSIVE lock is needed in order to write to the database file. Only one EXCLUSIVE lock is allowed on the file and no other locks of any kind are allowed to coexist with an EXCLUSIVE lock. In order to maximize concurrency, SQLite works to minimize the amount of time that EXCLUSIVE locks are held.</source>
          <target state="translated">데이터베이스 파일에 쓰려면 독점 잠금이 필요합니다. 파일에는 하나의 EXCLUSIVE 잠금 만 허용되며 어떤 종류의 다른 잠금도 EXCLUSIVE 잠금과 공존 할 수 없습니다. 동시성을 최대화하기 위해 SQLite는 독점 잠금이 유지되는 시간을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="fe2062deb028f6de38ba9c3021c202a7b43810db" translate="yes" xml:space="preserve">
          <source>An FTS tokenizer is a set of rules for extracting terms from a document or basic FTS full-text query.</source>
          <target state="translated">FTS 토크 나이 저는 문서 또는 기본 FTS 전체 텍스트 쿼리에서 용어를 추출하기위한 규칙 집합입니다.</target>
        </trans-unit>
        <trans-unit id="818fc889442be27af5d1325013f400680296296c" translate="yes" xml:space="preserve">
          <source>An I/O error on a memory-mapped file cannot be caught and dealt with by SQLite. Instead, the I/O error causes a signal which, if not caught by the application, results in a program crash.</source>
          <target state="translated">메모리 매핑 된 파일의 I / O 오류는 SQLite에서 포착하여 처리 할 수 ​​없습니다. 대신, I / O 오류는 신호를 발생시켜 응용 프로그램에 의해 포착되지 않으면 프로그램 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="1c82d6c0937081333b2317419d2ebad443727010" translate="yes" xml:space="preserve">
          <source>An IEEE double-precision (64-bit) floating point number</source>
          <target state="translated">IEEE 배정도 (64 비트) 부동 소수점 숫자</target>
        </trans-unit>
        <trans-unit id="4cd5420d6298ed92154e0329258defd31fd25a74" translate="yes" xml:space="preserve">
          <source>An INTEGER or REAL value is less than any TEXT or BLOB value. When an INTEGER or REAL is compared to another INTEGER or REAL, a numerical comparison is performed.</source>
          <target state="translated">INTEGER 또는 REAL 값이 TEXT 또는 BLOB 값보다 작습니다. INTEGER 또는 REAL이 다른 INTEGER 또는 REAL과 비교 될 때 숫자 비교가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3433c2fda29528c66dead93e3becaa2d64f147" translate="yes" xml:space="preserve">
          <source>An Introduction To The SQLite C/C++ Interface</source>
          <target state="translated">SQLite C / C ++ 인터페이스 소개</target>
        </trans-unit>
        <trans-unit id="1217ba99243b6eebb93b7b8b51f28f6be4f9d08a" translate="yes" xml:space="preserve">
          <source>An ORDER BY clause on the recursive-select can be used to control whether the search of a tree is depth-first or breadth-first. To illustrate, we will use a variation on the &quot;org&quot; table from an example above, without the &quot;height&quot; column, and with some real data inserted:</source>
          <target state="translated">재귀 선택의 ORDER BY 절을 사용하여 트리 검색이 깊이 우선인지 너비 우선인지를 제어 할 수 있습니다. 예를 들어, 위의 예에서 &quot;높이&quot;열없이 실제 데이터가 삽입 된 &quot;org&quot;테이블의 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23032a9cac30263b1d8146df43c99d82099810f2" translate="yes" xml:space="preserve">
          <source>An ORDER BY or GROUP BY clause</source>
          <target state="translated">ORDER BY 또는 GROUP BY 절</target>
        </trans-unit>
        <trans-unit id="6b7badb7ceeef79983e30969dff232619460ee2c" translate="yes" xml:space="preserve">
          <source>An OpenDocument Presentation or &quot;ODP&quot; file is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP archive&lt;/a&gt; containing XML files describing presentation slides and separate image files for the various images that are included as part of the presentation. (OpenDocument word processor and spreadsheet files are similarly structured but are not considered by this article.) The reader can easily see the content of an ODP file by using the &quot;zip -l&quot; command. For example, the following is the &quot;zip -l&quot; output from a 49-slide presentation about SQLite from the 2014 &lt;a href=&quot;http://southeastlinuxfest.org/&quot;&gt;SouthEast LinuxFest&lt;/a&gt; conference:</source>
          <target state="translated">OpenDocument 프리젠 테이션 또는 &quot;ODP&quot;파일은 프리젠 테이션 슬라이드를 설명하는 XML 파일과 프리젠 테이션의 일부로 포함 된 다양한 이미지에 대한 별도의 이미지 파일을 포함 하는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Zip_%28file_format%29&quot;&gt;ZIP 아카이브&lt;/a&gt; 입니다. OpenDocument 워드 프로세서와 스프레드 시트 파일은 유사하게 구성되어 있지만이 기사에서는 고려하지 않습니다. 독자는 &quot;zip -l&quot;명령을 사용하여 ODP 파일의 내용을 쉽게 볼 수 있습니다. 예를 들어, 다음은 2014 &lt;a href=&quot;http://southeastlinuxfest.org/&quot;&gt;SouthEast LinuxFest&lt;/a&gt; 컨퍼런스 에서 SQLite에 대한 49 개 슬라이드 프레젠테이션의 &quot;zip -l&quot;출력입니다 .</target>
        </trans-unit>
        <trans-unit id="3cc6b47353bce3b91e074154d427c28b96c16d62" translate="yes" xml:space="preserve">
          <source>An R*Tree query is initialized by making the root node the only entry in a priority queue sorted by rScore. The query proceeds by extracting the entry from the priority queue that has the lowest score. If that entry is a leaf (meaning that it is an actual R*Tree entry and not a subtree) then that entry is returned as one row of the query result. If the extracted priority queue entry is a node (a subtree), then sub-subtrees or leaves contained within that entry are passed to the xQueryFunc callback, one by one. Those subelements for which the xQueryFunc callback sets eWithin to PARTLY_WITHIN or FULLY_WITHIN are added to the priority queue using the score supplied by the callback. Subelements that return NOT_WITHIN are discarded. The query runs until the priority queue is empty.</source>
          <target state="translated">R * Tree 쿼리는 루트 노드를 rScore로 정렬 된 우선 순위 큐의 유일한 항목으로 만들어 초기화됩니다. 쿼리는 점수가 가장 낮은 우선 순위 큐에서 항목을 추출하여 진행됩니다. 해당 항목이 리프 (하위 트리가 아니라 실제 R * Tree 항목임을 의미) 인 경우 해당 항목은 조회 결과의 한 행으로 리턴됩니다. 추출 된 우선 순위 큐 항목이 노드 (하위 트리)이면 해당 항목에 포함 된 하위 서브 트리 또는 잎이 xQueryFunc 콜백에 하나씩 전달됩니다. xQueryFunc 콜백이 eWithin을 PARTLY_WITHIN 또는 FULLY_WITHIN으로 설정하는 하위 요소는 콜백에서 제공 한 점수를 사용하여 우선 순위 큐에 추가됩니다. NOT_WITHIN을 반환하는 하위 요소는 삭제됩니다. 우선 순위 큐가 비워 질 때까지 쿼리가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c36503645997aef3b66492ffa49c5737331ae5b" translate="yes" xml:space="preserve">
          <source>An RBU Vacuum operation requires less temporary disk space and writes less data to disk than an SQLite VACUUM. An SQLite VACUUM requires roughly twice the size of the final database file in temporary disk space to run. The total amount of data written is around three times the size of the final database file. By contrast, an RBU Vacuum requires roughly the size of the final database file in temporary disk space and writes a total of twice that to disk.</source>
          <target state="translated">RBU Vacuum 작업은 SQLite VACUUM보다 임시 디스크 공간이 적고 디스크에 데이터를 덜 씁니다. SQLite VACUUM을 실행하려면 임시 디스크 공간에서 최종 데이터베이스 파일 크기의 약 2 배가 필요합니다. 기록 된 총 데이터 양은 최종 데이터베이스 파일 크기의 약 3 배입니다. 반대로, RBU Vacuum은 임시 디스크 공간에서 대략적인 최종 데이터베이스 파일 크기를 요구하며 디스크에 총 2 배를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b402488c545650e7a0466693ac0992d5dced3759" translate="yes" xml:space="preserve">
          <source>An RBU handle is created by calling sqlite3rbu_vacuum(T, S).</source>
          <target state="translated">sqlite3rbu_vacuum (T, S)를 호출하여 RBU 핸들이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c7d98c92ed51948506a67c9bcda80cc97f4fcfe4" translate="yes" xml:space="preserve">
          <source>An SQL aggregate function, which can be used to create new archives in memory.</source>
          <target state="translated">메모리에 새 아카이브를 작성하는 데 사용할 수있는 SQL 집계 함수</target>
        </trans-unit>
        <trans-unit id="9bd314dc55feb99e9480fcbcc4eb53b163d23b23" translate="yes" xml:space="preserve">
          <source>An SQL operation that is interrupted will return &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;. If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.</source>
          <target state="translated">중단 된 SQL 조작은 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 를 리턴 합니다 . 인터럽트 된 SQL 조작이 명시 적 트랜잭션 내에있는 INSERT, UPDATE 또는 DELETE 인 경우 전체 트랜잭션이 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="bb8b61384d0c44a2e614c579b268363eaa1fc909" translate="yes" xml:space="preserve">
          <source>An SQL operation that is interrupted will return &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt;. If the interrupted SQL operation is an INSERT, UPDATE, or DELETE that is inside an explicit transaction, then the entire transaction will be rolled back automatically.</source>
          <target state="translated">중단 된 SQL 조작은 &lt;a href=&quot;../rescode#interrupt&quot;&gt;SQLITE_INTERRUPT&lt;/a&gt; 를 리턴 합니다 . 인터럽트 된 SQL 조작이 명시 적 트랜잭션 내에있는 INSERT, UPDATE 또는 DELETE 인 경우 전체 트랜잭션이 자동으로 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="3de39c28f7d860e2f20cf499f83a1ecd516190b8" translate="yes" xml:space="preserve">
          <source>An SQL statement can be preceded by the keyword &quot;EXPLAIN&quot; or by the phrase &quot;EXPLAIN QUERY PLAN&quot;. Either modification causes the SQL statement to behave as a query and to return information about how the SQL statement would have operated if the EXPLAIN keyword or phrase had been omitted.</source>
          <target state="translated">SQL 문 앞에는 키워드 &quot;EXPLAIN&quot;또는 &quot;EXPLAIN QUERY PLAN&quot;문구가 올 수 있습니다. 수정하면 SQL 문이 조회로 작동하고 EXPLAIN 키워드 또는 구가 생략 된 경우 SQL 문이 작동 한 방법에 대한 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="5abd7dabfe02360ec2bf6a05e3dfaa3cf5654f08" translate="yes" xml:space="preserve">
          <source>An SQLITE_BUSY error can occur at any point in a transaction: when the transaction is first started, during any write or update operations, or when the transaction commits. To avoid encountering SQLITE_BUSY errors in the middle of a transaction, the application can use &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; instead of just &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; to start a transaction. The &lt;a href=&quot;lang_transaction#immediate&quot;&gt;BEGIN IMMEDIATE&lt;/a&gt; command might itself return SQLITE_BUSY, but if it succeeds, then SQLite guarantees that no subsequent operations on the same database through the next &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; will return SQLITE_BUSY.</source>
          <target state="translated">트랜잭션의 어느 시점에서나 트랜잭션이 처음 시작될 때, 쓰기 또는 업데이트 작업 중 또는 트랜잭션이 커밋 될 때 SQLITE_BUSY 오류가 발생할 수 있습니다. 트랜잭션의 중간에 SQLITE_BUSY 오류가 발생하지 않도록하려면 응용 프로그램을 사용할 수 있습니다 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE에게 BEGIN&lt;/a&gt; 대신 단지 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 트랜잭션을 시작합니다. 는 &lt;a href=&quot;lang_transaction#immediate&quot;&gt;IMMEDIATE BEGIN&lt;/a&gt; 자체가 SQLITE_BUSY을 반환 할 수 명령을하지만 성공하면, 다음 SQLite는 보장 옆 통해 동일한 데이터베이스에 대한 후속 작업 것을 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT는&lt;/a&gt; SQLITE_BUSY를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac700efdf9da65c96e524e1f874e4322c772698e" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_CLOSE callback is invoked when a database connection closes. The P argument is a pointer to the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; object and the X argument is unused.</source>
          <target state="translated">데이터베이스 연결이 닫히면 SQLITE_TRACE_CLOSE 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트에 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90dda83d19d5a0e9440a66a5153d6f08cfb8e791" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_CLOSE callback is invoked when a database connection closes. The P argument is a pointer to the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; object and the X argument is unused.</source>
          <target state="translated">데이터베이스 연결이 닫히면 SQLITE_TRACE_CLOSE 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 오브젝트에 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6463d38e5743fc7b60a45c0dd4edf8e6196b2c76" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_PROFILE callback provides approximately the same information as is provided by the &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument points to a 64-bit integer which is the estimated of the number of nanosecond that the prepared statement took to run. The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.</source>
          <target state="translated">SQLITE_TRACE_PROFILE 콜백은 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 콜백 에서 제공하는 것과 거의 동일한 정보를 제공합니다 . P 인수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이고 X 인수는 준비된 명령문을 실행하는 데 걸린 나노초 수로 추정되는 64 비트 정수를 가리 킵니다. 명령문이 완료되면 SQLITE_TRACE_PROFILE 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="51f65212fb2842387dde50749c6891ed068f1d2c" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_PROFILE callback provides approximately the same information as is provided by the &lt;a href=&quot;profile&quot;&gt;sqlite3_profile()&lt;/a&gt; callback. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument points to a 64-bit integer which is the estimated of the number of nanosecond that the prepared statement took to run. The SQLITE_TRACE_PROFILE callback is invoked when the statement finishes.</source>
          <target state="translated">SQLITE_TRACE_PROFILE 콜백은 &lt;a href=&quot;profile&quot;&gt;sqlite3_profile ()&lt;/a&gt; 콜백 에서 제공하는 것과 거의 동일한 정보를 제공합니다 . P 인수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이고 X 인수는 준비된 명령문을 실행하는 데 걸린 나노초 수로 추정되는 64 비트 정수를 가리 킵니다. 명령문이 완료되면 SQLITE_TRACE_PROFILE 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="959b99495fe9f93bfe60c0c8dc39f940a8cc7107" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_ROW callback is invoked whenever a prepared statement generates a single row of result. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument is unused.</source>
          <target state="translated">준비된 명령문이 단일 결과 행을 생성 할 때마다 SQLITE_TRACE_ROW 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2c23282009e34d356e10ef768fd5d27fe9242d7" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_ROW callback is invoked whenever a prepared statement generates a single row of result. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt; and the X argument is unused.</source>
          <target state="translated">준비된 명령문이 단일 결과 행을 생성 할 때마다 SQLITE_TRACE_ROW 콜백이 호출됩니다. P 인수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 이며 X 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d87f64da2cd54c09ca013ca90ee9edc2e86b39e0" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_STMT callback is invoked when a prepared statement first begins running and possibly at other times during the execution of the prepared statement, such as at the start of each trigger subprogram. The P argument is a pointer to the &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statement&lt;/a&gt;. The X argument is a pointer to a string which is the unexpanded SQL text of the prepared statement or an SQL comment that indicates the invocation of a trigger. The callback can compute the same text that would have been returned by the legacy &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interface by using the X argument when X begins with &quot;--&quot; and invoking &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_expanded_sql(P)&lt;/a&gt; otherwise.</source>
          <target state="translated">SQLITE_TRACE_STMT 콜백은 준비된 명령문이 처음 실행될 때 그리고 가능하면 각 트리거 서브 프로그램의 시작과 같이 준비된 명령문을 실행하는 동안 다른 시간에 호출됩니다. P 인수는 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 입니다. X 인수는 준비된 명령문의 확장되지 않은 SQL 텍스트 또는 트리거 호출을 나타내는 SQL 주석 인 문자열에 대한 포인터입니다. 콜백은 X가 &quot;-&quot;로 시작할 때 X 인수를 사용하고 그렇지 않으면 &lt;a href=&quot;#sqlite3_expanded_sql&quot;&gt;sqlite3_expanded_sql (P)를&lt;/a&gt; 호출 하여 레거시 &lt;a href=&quot;#sqlite3_profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 인터페이스 에서 반환 된 것과 동일한 텍스트를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="67e19a52fd0823eafed0ed156581e34f2ae1fb9a" translate="yes" xml:space="preserve">
          <source>An SQLITE_TRACE_STMT callback is invoked when a prepared statement first begins running and possibly at other times during the execution of the prepared statement, such as at the start of each trigger subprogram. The P argument is a pointer to the &lt;a href=&quot;stmt&quot;&gt;prepared statement&lt;/a&gt;. The X argument is a pointer to a string which is the unexpanded SQL text of the prepared statement or an SQL comment that indicates the invocation of a trigger. The callback can compute the same text that would have been returned by the legacy &lt;a href=&quot;profile&quot;&gt;sqlite3_trace()&lt;/a&gt; interface by using the X argument when X begins with &quot;--&quot; and invoking &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_expanded_sql(P)&lt;/a&gt; otherwise.</source>
          <target state="translated">SQLITE_TRACE_STMT 콜백은 준비된 명령문이 처음 실행될 때 그리고 가능하면 각 트리거 서브 프로그램의 시작과 같이 준비된 명령문을 실행하는 동안 다른 시간에 호출됩니다. P 인수는 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문에&lt;/a&gt; 대한 포인터 입니다. X 인수는 준비된 명령문의 확장되지 않은 SQL 텍스트 또는 트리거 호출을 나타내는 SQL 주석 인 문자열에 대한 포인터입니다. 콜백은 X가 &quot;-&quot;로 시작할 때 X 인수를 사용하고 그렇지 않으면 &lt;a href=&quot;expanded_sql&quot;&gt;sqlite3_expanded_sql (P)를&lt;/a&gt; 호출 하여 레거시 &lt;a href=&quot;profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 인터페이스 에서 반환 된 것과 동일한 텍스트를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40dcdd5a240705c4bdfc3ba184015a22602dc143" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can be queried using a high-level query language (SQL). Some examples:</source>
          <target state="translated">SQLite Archive는 고급 쿼리 언어 (SQL)를 사용하여 쿼리 할 수 ​​있습니다. 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="b242257f9fcf2e3e2eac957dac8e90b190c245bb" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can be updated incrementally. Individual files can be added or removed or replaced without having to rewrite the entire archive.</source>
          <target state="translated">SQLite Archive는 증분 업데이트 할 수 있습니다. 전체 아카이브를 다시 쓰지 않고도 개별 파일을 추가 또는 제거하거나 교체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a576b713a86af9234a7a7f85c2bf0090d4320d5" translate="yes" xml:space="preserve">
          <source>An SQLite Archive can work around firewall-imposed censorship. For example, certain file types that are considered &quot;dangerous&quot; (examples: DLLs) will be &lt;a href=&quot;https://support.google.com/mail/answer/6590&quot;&gt;blocked by Gmail&lt;/a&gt; and probably many other email services and firewall, even if those files are wrapped inside a ZIP Archive or Tarball. But these firewall usually do not care about SQLite Archives and so content can be put inside an SQLite Archive to evade censorship.</source>
          <target state="translated">SQLite Archive는 방화벽이 적용된 검열 문제를 해결할 수 있습니다. 예를 들어, &quot;위험한&quot;것으로 간주되는 특정 파일 형식 (예 : DLL)은 해당 파일이 ZIP 보관 파일 또는 Tarball에 래핑되어 있어도 &lt;a href=&quot;https://support.google.com/mail/answer/6590&quot;&gt;Gmail&lt;/a&gt; 및 기타 여러 전자 메일 서비스 및 방화벽에 의해 차단됩니다 . 그러나 이러한 방화벽은 일반적으로 SQLite Archives에 신경 쓰지 않으므로 검열을 피하기 위해 SQLite Archive에 내용을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4118c0f7a6f81cb74480ccc9fa50eb744542f589" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is an ordinary SQLite database file that contains the following table as part of its schema:</source>
          <target state="translated">SQLite Archive는 스키마의 일부로 다음 테이블을 포함하는 일반 SQLite 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="dc6cbe656d1d7ad99c40dcbbe2f8824b11660a4b" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is flexible. ZIP Archives and Tarballs are limited to storing only files. An SQLite Archive stores files plus whatever other tabular and/or relational data seems useful to the application.</source>
          <target state="translated">SQLite Archive는 유연합니다. ZIP 아카이브 및 타르볼은 파일 만 저장하도록 제한됩니다. SQLite Archive는 파일과 응용 프로그램에 유용한 다른 테이블 및 / 또는 관계형 데이터를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="b26644641a5c080b143bed71ae376b8f86f40091" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is one example of a more general idea that an SQLite database can behave as a container object holding lots of smaller data components.</source>
          <target state="translated">SQLite Archive는 SQLite 데이터베이스가 많은 작은 데이터 구성 요소를 보유하는 컨테이너 개체로 작동 할 수 있다는보다 일반적인 아이디어의 한 예입니다.</target>
        </trans-unit>
        <trans-unit id="5d177845e7556bf44c101aaef7f85cf75f9d1c63" translate="yes" xml:space="preserve">
          <source>An SQLite Archive is transactional. Updates are atomic and durable, even if there are crashes or power losses in the middle of the update. Readers see a consistent and unchanging version of the content even is some other process is simultaneously updating the archive.</source>
          <target state="translated">SQLite Archive는 트랜잭션입니다. 업데이트 도중 업데이트 나 충돌이 발생하더라도 업데이트는 원자적이고 내구성이 있습니다. 독자들은 일관성 있고 변하지 않는 내용의 버전을보고 다른 프로세스가 동시에 아카이브를 업데이트하고 있음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3312ff278a713e75002ecfaa844a5076353ef655" translate="yes" xml:space="preserve">
          <source>An SQLite Archive supports only the &lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt; compression method. Tarballs and ZIP Archive support a wider assortment of compression methods.</source>
          <target state="translated">SQLite Archive는 &lt;a href=&quot;https://zlib.net/&quot;&gt;Deflate&lt;/a&gt; 압축 방법 만 지원합니다 . Tarballs 및 ZIP Archive는 더 다양한 압축 방법을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8fd49e13abc11c533a20ccc6b5f7798ff20c6616" translate="yes" xml:space="preserve">
          <source>An SQLite Database File</source>
          <target state="translated">SQLite 데이터베이스 파일</target>
        </trans-unit>
        <trans-unit id="b000f5fd9df31bd42422b2ef21f81528c08cea1a" translate="yes" xml:space="preserve">
          <source>An SQLite application file format is a great choice in cases where there is a collection or &quot;federation&quot; of separate programs, often written in different languages and by different development teams. This comes up commonly in research or laboratory environments where one team is responsible for data acquisition and other teams are responsible for various stages of analysis. Each team can use whatever hardware, operating system, programming language and development methodology that they are most comfortable with, and as long as all programs use an SQLite database with a common schema, they can all interoperate.</source>
          <target state="translated">SQLite 응용 프로그램 파일 형식은 종종 다른 언어로 작성되고 다른 개발 팀이 작성하는 별도의 프로그램 모음 또는 &quot;연합&quot;이있는 경우에 적합합니다. 이는 한 팀이 데이터 수집을 담당하고 다른 팀은 다양한 분석 단계를 담당하는 연구 또는 실험실 환경에서 일반적으로 발생합니다. 각 팀은 가장 편리한 하드웨어, 운영 체제, 프로그래밍 언어 및 개발 방법을 사용할 수 있으며 모든 프로그램이 공통 스키마가있는 SQLite 데이터베이스를 사용하는 한 모두 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bcad71b941086fc8d3676a58f2f663381ad6019" translate="yes" xml:space="preserve">
          <source>An SQLite database can become corrupt if the file content changes due to a disk drive or flash memory failure. It is very rare, but disks will occasionally flip a bit in the middle of a sector.</source>
          <target state="translated">디스크 드라이브 나 플래시 메모리 오류로 인해 파일 내용이 변경되면 SQLite 데이터베이스가 손상 될 수 있습니다. 매우 드물지만 디스크가 섹터의 한가운데서 약간 튀어 나오는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="caa981e15b39eb75edaa6ff0d13de7391ec0f911" translate="yes" xml:space="preserve">
          <source>An SQLite database connection defaults to &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode=DELETE&lt;/a&gt;. To convert to WAL mode, use the following pragma:</source>
          <target state="translated">SQLite 데이터베이스 연결의 기본값은 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode = DELETE&lt;/a&gt; 입니다. WAL 모드로 변환하려면 다음 pragma를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dfa9719008b383e9c69cd74a19a5c395ef612cf2" translate="yes" xml:space="preserve">
          <source>An SQLite database facilitates data transfer between systems even when the endpoints have different word sizes and/or byte orders. The data can be a complex mix of large binary blobs, text, and small numeric or boolean values. The data format can be easily extended by adding new tables and/or columns, without breaking legacy receivers. The SQL query language means that receivers are not required to parse the entire transfer all at once, but can instead query the received content as needed. The data format is &quot;transparent&quot; in the sense that it is easily decoded for human viewing using a variety of universally available, open-source tools, from multiple vendors.</source>
          <target state="translated">SQLite 데이터베이스는 엔드 포인트의 단어 크기 및 / 또는 바이트 순서가 다른 경우에도 시스템 간의 데이터 전송을 용이하게합니다. 데이터는 큰 이진 얼룩, 텍스트 및 작은 숫자 또는 부울 값의 복잡한 혼합 일 수 있습니다. 레거시 수신기를 중단하지 않고 새 테이블 및 / 또는 열을 추가하여 데이터 형식을 쉽게 확장 할 수 있습니다. SQL 쿼리 언어는 수신자가 전체 전송을 한 번에 모두 구문 분석 할 필요는 없지만 대신 수신 된 컨텐츠를 쿼리 할 수 ​​있음을 의미합니다. 데이터 형식은 여러 공급 업체의 다양한 범용 오픈 소스 도구를 사용하여 사람이 볼 수 있도록 쉽게 디코딩된다는 점에서 &quot;투명&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="982d7ceede2aaf5d861f9c36536e7099da9073ca" translate="yes" xml:space="preserve">
          <source>An SQLite database file consists of one or more &quot;pages&quot;. For a single database file, all pages are the same size, though for different database files, the page size can any power of two between 512 and 65536, inclusive.</source>
          <target state="translated">SQLite 데이터베이스 파일은 하나 이상의 &quot;페이지&quot;로 구성됩니다. 단일 데이터베이스 파일의 경우 모든 페이지의 크기는 동일하지만 다른 데이터베이스 파일의 경우 페이지 크기는 512에서 65536 사이의 2의 제곱을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1d2c158eb6a0a9552493d7c89540c3e0f9e893f" translate="yes" xml:space="preserve">
          <source>An SQLite database file is approximately the same size, and in some cases smaller, than a ZIP archive holding the same information.</source>
          <target state="translated">SQLite 데이터베이스 파일은 동일한 정보를 보유하는 ZIP 아카이브와 크기가 대략 동일하며 경우에 따라 더 작습니다.</target>
        </trans-unit>
        <trans-unit id="2c4396f52519eb130b5dd0375bda350b47a433fb" translate="yes" xml:space="preserve">
          <source>An SQLite database file is divided into pages. The first page is 1, the second page is 2, and so forth. There is no page 0. Every page is the same size. The size of every page is a power of 2 between 512 and 65536. See the &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; documentation for further details.</source>
          <target state="translated">SQLite 데이터베이스 파일은 페이지로 나뉩니다. 첫 번째 페이지는 1이고 두 번째 페이지는 2입니다. 0 페이지가 없습니다. 모든 페이지는 같은 크기입니다. 모든 페이지의 크기는 512에서 65536 사이의 2의 거듭 제곱입니다. 자세한 내용은 &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4f8b304d710aae6886e59c81e1a985cd1cd70645" translate="yes" xml:space="preserve">
          <source>An SQLite database file with a defined schema often makes an excellent application file format. Here are a dozen reasons why this is so:</source>
          <target state="translated">정의 된 스키마가있는 SQLite 데이터베이스 파일은 종종 우수한 응용 프로그램 파일 형식을 만듭니다. 다음과 같은 12 가지 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ebdfe9c0e4c8eb0d11614911caf8938817b53f" translate="yes" xml:space="preserve">
          <source>An SQLite database has a lot of capability, which this essay has only begun to touch upon. But hopefully this quick glimpse has convinced some readers that using an SQL database as an application file format is worth a second look.</source>
          <target state="translated">SQLite 데이터베이스에는 많은 기능이 있으며이 에세이는 이제 막 다루기 시작했습니다. 그러나이 빠른 요약을 통해 일부 독자들은 SQL 데이터베이스를 응용 프로그램 파일 형식으로 사용하는 것이 두 번째로 가치가 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="69541d5b92ee6eb3e8f9d53bc6a238b7db778bec" translate="yes" xml:space="preserve">
          <source>An SQLite database is a &lt;a href=&quot;fileformat2&quot;&gt;well-defined and well-documented&lt;/a&gt; file format that is in widespread use by literally millions of applications and is backwards compatible to its inception in 2004 and which promises to continue to be compatible in decades to come. The longevity of SQLite database files is particularly important to bespoke applications, since it allows the document content to be accessed far in the future, long after all traces of the original application have been lost. Data lives longer than code. SQLite databases are &lt;a href=&quot;locrsf&quot;&gt;recommended by the US Library of Congress&lt;/a&gt; as a storage format for long-term preservation of digital content.</source>
          <target state="translated">SQLite 데이터베이스는 문자 그대로 수백만 개의 응용 프로그램에서 널리 사용되는 &lt;a href=&quot;fileformat2&quot;&gt;잘 정의되고 잘 문서화 된&lt;/a&gt; 파일 형식으로 2004 년에 처음부터 역 호환되며 앞으로 수십 년 동안 계속 호환 될 것입니다. SQLite 데이터베이스 파일의 수명은 원본 응용 프로그램의 모든 흔적을 잃어버린 후에도 장래에 문서 내용에 액세스 할 수 있기 때문에 응용 프로그램을 예약하는 데 특히 중요합니다. 코드보다 데이터 수명이 깁니다. SQLite 데이터베이스는 &lt;a href=&quot;locrsf&quot;&gt;미국 의회 도서관&lt;/a&gt; 에서 디지털 컨텐츠의 장기 보존을위한 스토리지 형식으로 권장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1414bb1ca0b7308fabbbb0231f95883cdfb55f17" translate="yes" xml:space="preserve">
          <source>An SQLite database is a single ordinary disk file that can be located anywhere in the directory hierarchy. If SQLite can read the disk file then it can read anything in the database. If the disk file and its directory are writable, then SQLite can change anything in the database. Database files can easily be copied onto a USB memory stick or emailed for sharing.</source>
          <target state="translated">SQLite 데이터베이스는 디렉토리 계층의 어느 곳에 나 위치 할 수있는 단일 일반 디스크 파일입니다. SQLite가 디스크 파일을 읽을 수 있으면 데이터베이스의 모든 것을 읽을 수 있습니다. 디스크 파일과 디렉토리가 쓰기 가능하면 SQLite는 데이터베이스의 모든 것을 변경할 수 있습니다. 데이터베이스 파일을 USB 메모리 스틱에 쉽게 복사하거나 이메일로 보내 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26fb41c051ef1c4cae3e65d019499aa1d3715a71" translate="yes" xml:space="preserve">
          <source>An SQLite database is highly resistant to corruption. If an application crash, or an operating-system crash, or even a power failure occurs in the middle of a transaction, the partially written transaction should be automatically rolled back the next time the database file is accessed. The recovery process is fully automatic and does not require any action on the part of the user or the application.</source>
          <target state="translated">SQLite 데이터베이스는 손상에 매우 강합니다. 트랜잭션 중간에 응용 프로그램 충돌 또는 운영 체제 충돌 또는 정전이 발생할 경우 다음에 데이터베이스 파일에 액세스 할 때 부분적으로 작성된 트랜잭션이 자동으로 롤백되어야합니다. 복구 프로세스는 완전 자동이므로 사용자 나 응용 프로그램에 대한 조치가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3b90e2f3f651754fcb6451ab34aac384e7a5fbe" translate="yes" xml:space="preserve">
          <source>An SQLite database is limited in size to 140 terabytes (2&lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; bytes, 128 tibibytes). And even if it could handle larger databases, SQLite stores the entire database in a single disk file and many filesystems limit the maximum size of files to something less than this. So if you are contemplating databases of this magnitude, you would do well to consider using a client/server database engine that spreads its content across multiple disk files, and perhaps across multiple volumes.</source>
          <target state="translated">SQLite 데이터베이스의 크기는 140 테라 바이트 (2 &lt;sup&gt;&lt;small&gt;47&lt;/small&gt;&lt;/sup&gt; 바이트, 128 티비 바이트)로 제한됩니다. 더 큰 데이터베이스를 처리 할 수 ​​있더라도 SQLite는 전체 데이터베이스를 단일 디스크 파일에 저장하며 많은 파일 시스템은 파일의 최대 크기를 이보다 작은 것으로 제한합니다. 따라서이 정도 규모의 데이터베이스를 고려하는 경우 여러 디스크 파일 또는 여러 볼륨에 내용을 분산시키는 클라이언트 / 서버 데이터베이스 엔진을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8efcb5c5b5fbf0d6f174a7bd1fdafd17d5d08348" translate="yes" xml:space="preserve">
          <source>An SQLite database is maintained on disk using a B-tree implementation found in the &lt;a href=&quot;https://sqlite.org/src/file/src/btree.c&quot;&gt;btree.c&lt;/a&gt; source file. A separate B-tree is used for each table and index in the database. All B-trees are stored in the same disk file. The &lt;a href=&quot;fileformat2&quot;&gt;file format&lt;/a&gt; details are stable and well-defined and are guaranteed to be compatible moving forward.</source>
          <target state="translated">SQLite 데이터베이스는 &lt;a href=&quot;https://sqlite.org/src/file/src/btree.c&quot;&gt;btree.c&lt;/a&gt; 소스 파일 에있는 B-tree 구현을 사용하여 디스크에서 유지 관리 됩니다. 데이터베이스의 각 테이블과 인덱스에 별도의 B- 트리가 사용됩니다. 모든 B- 트리는 동일한 디스크 파일에 저장됩니다. &lt;a href=&quot;fileformat2&quot;&gt;파일 형식&lt;/a&gt; 자세한 내용은 안정적이고 잘 정의하고 앞으로 호환 이동을 보장받을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25bf5d553881678b34da8985ef757fc5ffe38cac" translate="yes" xml:space="preserve">
          <source>An SQLite database is normally stored in a single ordinary disk file. However, in certain circumstances, the database might be stored in memory.</source>
          <target state="translated">SQLite 데이터베이스는 일반적으로 단일 일반 디스크 파일에 저장됩니다. 그러나 특정 상황에서는 데이터베이스가 메모리에 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffcfbe0c6736b628bac17f2c3fd76a08f4a70298" translate="yes" xml:space="preserve">
          <source>An SQLite extension is a shared library or DLL. To load it, you need to supply SQLite with the name of the file containing the shared library or DLL and an entry point to initialize the extension. In C code, this information is supplied using the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; API. See the documentation on that routine for additional information.</source>
          <target state="translated">SQLite 확장은 공유 라이브러리 또는 DLL입니다. 이를로드하려면 SQLite에 공유 라이브러리 또는 DLL이 포함 된 파일 이름과 확장명을 초기화하기위한 진입 점을 제공해야합니다. C 코드에서이 정보는 &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; API를 사용하여 제공 됩니다. 추가 정보는 해당 루틴의 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="741d402ffb5729c1f12f8583e23c058762a2645f" translate="yes" xml:space="preserve">
          <source>An SQLite file associates a key with some data. For an SQLite table, the database file is set up so that the key is an integer and the data is the information for one row of the table. Indices in SQLite reverse this arrangement. The index key is (some of) the information being stored and the index data is an integer. To access a table row that has some particular content, we first look up the content in the index table to find its integer index, then we use that integer to look up the complete record in the table.</source>
          <target state="translated">SQLite 파일은 키를 일부 데이터와 연관시킵니다. SQLite 테이블의 경우 데이터베이스 파일은 키가 정수이고 데이터가 테이블의 한 행에 대한 정보가되도록 설정됩니다. SQLite의 인덱스는이 배열을 반대로합니다. 인덱스 키는 저장된 정보 중 일부이며 인덱스 데이터는 정수입니다. 특정 내용이있는 테이블 행에 액세스하기 위해 먼저 인덱스 테이블에서 내용을 검색하여 정수 인덱스를 찾은 다음 해당 정수를 사용하여 테이블에서 전체 레코드를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="aa48e9ca1a9afbd598f5c369c282c95ae280985d" translate="yes" xml:space="preserve">
          <source>An UPDATE change does not contain any information regarding non-PRIMARY KEY fields that are not modified by the change. It is not possible for an UPDATE change to specify modifications to PRIMARY KEY fields.</source>
          <target state="translated">UPDATE 변경에는 변경에 의해 수정되지 않은 기본이 아닌 KEY 필드에 관한 정보가 없습니다. UPDATE 변경으로 PRIMARY KEY 필드에 수정을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a8453636ce12faf3a7d30b3604973de7e92b03be" translate="yes" xml:space="preserve">
          <source>An UPDATE statement is used to modify a subset of the values stored in zero or more rows of the database table identified by the &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;qualified-table-name&lt;/a&gt; specified as part of the UPDATE statement.</source>
          <target state="translated">UPDATE 문은 UPDATE 문의 일부로 지정된 &lt;a href=&quot;syntax/qualified-table-name&quot;&gt;규정 된 table-name으로&lt;/a&gt; 식별되는 데이터베이스 테이블의 0 개 이상의 행에 저장된 값의 서브 세트를 수정하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c4f3409a0b0e68f9dad8c3ad576c7434229cfe7d" translate="yes" xml:space="preserve">
          <source>An UPSERT is an ordinary &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement that is followed by the special ON CONFLICT clause shown above.</source>
          <target state="translated">UPSERT는 일반적인 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 문이며 위에 표시된 특수 ON CONFLICT 절이 뒤 따릅니다.</target>
        </trans-unit>
        <trans-unit id="69182763d75d3decbdc8b998206e5e9e0abdd4fa" translate="yes" xml:space="preserve">
          <source>An administrator might be cleaning up after an OS crash or power failure, see the journal file, think it is junk, and delete it.</source>
          <target state="translated">OS 충돌 또는 정전 후 관리자가 정리 중일 수 있습니다. 저널 파일을보고 정크 파일이라고 생각하여 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="3394246ad7fb8330c70e24b0e7ea728a29ef0f38" translate="yes" xml:space="preserve">
          <source>An advanced &lt;a href=&quot;optoverview&quot;&gt;query planner&lt;/a&gt;</source>
          <target state="translated">고급 &lt;a href=&quot;optoverview&quot;&gt;쿼리 플래너&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="911df1dfdba68c60884217edf88c5ceef73757d1" translate="yes" xml:space="preserve">
          <source>An aggregate window function is similar to an &lt;a href=&quot;lang_aggfunc&quot;&gt;ordinary aggregate function&lt;/a&gt;, except adding it to a query does not change the number of rows returned. Instead, for each row the result of the aggregate window function is as if the corresponding aggregate were run over all rows in the &quot;window frame&quot; specified by the OVER clause.</source>
          <target state="translated">집계 창 함수는 &lt;a href=&quot;lang_aggfunc&quot;&gt;일반 집계 함수&lt;/a&gt; 와 유사하지만 쿼리에 추가해도 반환되는 행 수는 변경되지 않습니다. 대신 각 행에 대해 집계 창 함수의 결과는 해당 집계가 OVER 절에 지정된 &quot;창 프레임&quot;의 모든 행에 대해 실행 된 것처럼 나타납니다.</target>
        </trans-unit>
        <trans-unit id="322176e856e37076d444f90d3c6a55c34f3890cf" translate="yes" xml:space="preserve">
          <source>An alternate VFS can also be specified as the 4th parameter to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; function. For example:</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 함수 의 네 번째 매개 변수로 대체 VFS를 지정할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41672a8dda2c83a2c98fffccfd2de6f45dfd99a9" translate="yes" xml:space="preserve">
          <source>An alternative page cache implementation is specified using &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;,...).</source>
          <target state="translated">대체 페이지 캐시 구현은 &lt;a href=&quot;#sqlite3_config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...)를 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="947c7106a30016236017e10a97e39cd6cd0c6560" translate="yes" xml:space="preserve">
          <source>An alternative page cache implementation is specified using &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt;(&lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt;,...).</source>
          <target state="translated">대체 페이지 캐시 구현은 &lt;a href=&quot;config&quot;&gt;sqlite3_config&lt;/a&gt; ( &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigpcache2&quot;&gt;SQLITE_CONFIG_PCACHE2&lt;/a&gt; , ...)를 사용하여 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a5b04203def7bb645f2fb1f011d7be6cb15aa11" translate="yes" xml:space="preserve">
          <source>An alternative to using the VACUUM command is auto-vacuum mode, enabled using the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum pragma&lt;/a&gt;.</source>
          <target state="translated">VACUUM 명령을 사용하는 대신 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum pragma를&lt;/a&gt; 사용하여 활성화되는 자동 진공 모드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad7c395d93d8f14379a00c98e2d82d0ba28b9997" translate="yes" xml:space="preserve">
          <source>An alternative to using the VACUUM command to reclaim space after data has been deleted is auto-vacuum mode, enabled using the &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; pragma. When &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; is enabled for a database free pages may be reclaimed after deleting data, causing the file to shrink, without rebuilding the entire database using VACUUM. However, using &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; can lead to extra database file fragmentation. And &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; does not compact partially filled pages of the database as VACUUM does.</source>
          <target state="translated">VACUUM 명령을 사용하여 데이터가 삭제 된 후 공간을 회수하는 대안은 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; pragma를 사용하여 활성화 된 자동 진공 모드 입니다. 데이터베이스에서 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 을 사용하도록 설정 하면 데이터를 삭제 한 후 사용 가능한 페이지가 회수되어 VACUUM을 사용하여 전체 데이터베이스를 다시 작성하지 않고도 파일이 축소 될 수 있습니다. 그러나 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 을 사용 하면 추가 데이터베이스 파일 조각화가 발생할 수 있습니다. 그리고 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum는&lt;/a&gt; 진공처럼 데이터베이스하지 컴팩트 부분적으로 채워진 페이지를 않습니다.</target>
        </trans-unit>
        <trans-unit id="553a75a5f14c49499d0ac2492bac151d7f6d24ab" translate="yes" xml:space="preserve">
          <source>An application can initiate a checkpoint using any writable database connection on the database simply by invoking &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; or &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;. There are three subtypes of checkpoints that vary in their aggressiveness: PASSIVE, FULL, and RESTART. The default checkpoint style is PASSIVE, which does as much work as it can without interfering with other database connections, and which might not run to completion if there are concurrent readers or writers. All checkpoints initiated by &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint()&lt;/a&gt; and by the automatic checkpoint mechanism are PASSIVE. FULL and RESTART checkpoints try harder to run the checkpoint to completion and can only be initiated by a call to &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt;. See the &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2()&lt;/a&gt; documentation for additional information on FULL and RESET checkpoints.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 를 호출하여 데이터베이스에서 쓰기 가능한 데이터베이스 연결을 사용하여 검사 점을 시작할 수 있습니다 . 공격성에 따라 달라지는 체크 포인트에는 세 가지 하위 유형이 있습니다 : 수동, 전체 및 다시 시작. 기본 검사 점 스타일은 수동형으로, 다른 데이터베이스 연결을 방해하지 않으면 서 최대한 많은 작업을 수행하며 동시 판독기 또는 기록기가있는 경우 완료되지 않을 수 있습니다. &lt;a href=&quot;c3ref/wal_checkpoint&quot;&gt;sqlite3_wal_checkpoint ()&lt;/a&gt; 및 자동 체크 포인트 메커니즘에 의해 시작된 모든 체크 포인트 는 수동입니다. FULL 및 RESTART 체크 포인트는 체크 포인트를 완료하기 위해 더 열심히 시도하며 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 호출로만 시작할 수 있습니다.. FULL 및 RESET 체크 포인트에 대한 추가 정보 는 &lt;a href=&quot;c3ref/wal_checkpoint_v2&quot;&gt;sqlite3_wal_checkpoint_v2 ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b67ba81a9225f9986e5d6153b64db41fca122a2b" translate="yes" xml:space="preserve">
          <source>An application can insert layers or &quot;overlays&quot; in between the SQLite core and the underlying memory allocator. For example, the &lt;a href=&quot;#oomtesting&quot;&gt;out-of-memory test logic&lt;/a&gt; for SQLite uses an overlay that can simulate memory allocation failures.</source>
          <target state="translated">응용 프로그램은 SQLite 코어와 기본 메모리 할당 자 사이에 계층 또는 &quot;오버레이&quot;를 삽입 할 수 있습니다. 예를 들어, SQLite에 대한 &lt;a href=&quot;#oomtesting&quot;&gt;메모리 부족 테스트 로직&lt;/a&gt; 은 메모리 할당 실패를 시뮬레이션 할 수있는 오버레이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c388b93196430467345107651fd79645679ae7e0" translate="yes" xml:space="preserve">
          <source>An application can register additional collating functions using the &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation()&lt;/a&gt; interface.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;c3ref/create_collation&quot;&gt;sqlite3_create_collation ()&lt;/a&gt; 인터페이스를 사용하여 추가 조합 기능을 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83af746376d0381ac294352b72f5044bc5a90aa4" translate="yes" xml:space="preserve">
          <source>An application is allowed to prepare multiple SQL statements in advance and evaluate them as needed. There is no arbitrary limit to the number of outstanding &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt;. Some applications call &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare()&lt;/a&gt; multiple times at start-up to create all of the &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; they will ever need. Other applications keep a cache of the most recently used &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; and then reuse &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; out of the cache when available. Another approach is to only reuse &lt;a href=&quot;c3ref/stmt&quot;&gt;prepared statements&lt;/a&gt; when they are inside of a loop.</source>
          <target state="translated">응용 프로그램은 여러 SQL 문을 미리 준비하고 필요에 따라 평가할 수 있습니다. &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 준비된 명령문&lt;/a&gt; 수에는 임의의 제한이 없습니다 . 일부 응용 프로그램 은 시작할 때 &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare ()를&lt;/a&gt; 여러 번 호출 하여 필요한 모든 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 작성 합니다. 다른 응용 프로그램은 가장 최근에 사용한 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 의 캐시를 유지 한 다음 사용 가능한 경우 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 을 캐시에서 재사용 합니다. 또 다른 접근법은 &lt;a href=&quot;c3ref/stmt&quot;&gt;준비된 명령문&lt;/a&gt; 이 루프 내부에있을 때만 재사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c0f92c3ae91ceb152b4ca7b440a380181cc47f0d" translate="yes" xml:space="preserve">
          <source>An application will typically use &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; to create a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; during initialization. Note that &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; can be used to either open existing database files or to create and open new database files. While many applications use only a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt;, there is no reason why an application cannot call &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; multiple times in order to open multiple &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; - either to the same database or to different databases. Sometimes a multi-threaded application will create separate &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connections&lt;/a&gt; for each thread. Note that a single &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; can access two or more databases using the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL command, so it is not necessary to have a separate database connection for each database file.</source>
          <target state="translated">애플리케이션은 일반적으로 초기화 중에 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 을 사용하여 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 작성합니다 . 참고 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 중 하나를 열고 기존 데이터베이스 파일을 사용하거나 생성하고 열린 새 데이터베이스 파일을 할 수 있습니다. 많은 응용 프로그램이 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 만 사용하지만 동일한 데이터베이스 나 다른 데이터베이스에 대한 여러 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 열기 위해 응용 프로그램이 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()을&lt;/a&gt; 여러 번 호출 할 수없는 이유는 없습니다 . 때때로 다중 스레드 응용 프로그램은 각 스레드에 대해 별도의 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 작성 합니다. 단일 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt;&lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; SQL 명령을 사용하여 둘 이상의 데이터베이스에 액세스 할 수 있으므로 각 데이터베이스 파일에 대해 별도의 데이터베이스 연결이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad0ed6ebbb2c20729bbba2c61a375d2fc0e59a68" translate="yes" xml:space="preserve">
          <source>An application-defined function is permitted to call other SQLite interfaces. However, such calls must not close the database connection nor finalize or reset the prepared statement in which the function is running.</source>
          <target state="translated">응용 프로그램 정의 함수는 다른 SQLite 인터페이스를 호출 할 수 있습니다. 그러나 이러한 호출은 데이터베이스 연결을 닫거나 함수가 실행중인 준비된 명령문을 마무리하거나 재설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="368a116479c83bd78621f71906b14ee39f5af37e" translate="yes" xml:space="preserve">
          <source>An arbitrary length BLOB</source>
          <target state="translated">임의의 길이 BLOB</target>
        </trans-unit>
        <trans-unit id="f821dc4d7f9c71f0ab35cc4c36d94a5e6e1a02bc" translate="yes" xml:space="preserve">
          <source>An arbitrary length strings</source>
          <target state="translated">임의의 길이 문자열</target>
        </trans-unit>
        <trans-unit id="232575a5b7dcf96eebb74b1c36e1cd9952456a1f" translate="yes" xml:space="preserve">
          <source>An argument with SQL type TEXT it is normally converted into a quoted JSON string even if the input text is well-formed JSON. However, if the argument is the direct result from another json1 function, then it is treated as JSON and all of its JSON type information and substructure is preserved. This allows calls to json_object() and &lt;a href=&quot;json1#jarray&quot;&gt;json_array()&lt;/a&gt; to be nested. The &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; function can also be used to force strings to be recognized as JSON.</source>
          <target state="translated">SQL 유형이 TEXT 인 인수는 입력 텍스트가 올바른 형식의 JSON 인 경우에도 일반적으로 인용 된 JSON 문자열로 변환됩니다. 그러나 인수가 다른 json1 함수의 직접적인 결과 인 경우 JSON으로 처리되며 모든 JSON 유형 정보 및 하위 구조가 유지됩니다. 이를 통해 json_object () 및 &lt;a href=&quot;json1#jarray&quot;&gt;json_array ()에&lt;/a&gt; 대한 호출을 중첩 할 수 있습니다. &lt;a href=&quot;json1#jmini&quot;&gt;JSON ()&lt;/a&gt; 함수는 힘 문자열로 사용할 수는 JSON으로 인식한다.</target>
        </trans-unit>
        <trans-unit id="ba3098d8640bbb6ff43023d4a4dc7ae39f23e7f1" translate="yes" xml:space="preserve">
          <source>An argument with SQL type TEXT it is normally converted into a quoted JSON string. However, if the argument is the output from another json1 function, then it is stored as JSON. This allows calls to json_array() and &lt;a href=&quot;json1#jobj&quot;&gt;json_object()&lt;/a&gt; to be nested. The &lt;a href=&quot;json1#jmini&quot;&gt;json()&lt;/a&gt; function can also be used to force strings to be recognized as JSON.</source>
          <target state="translated">SQL 유형이 TEXT 인 인수는 일반적으로 따옴표로 묶인 JSON 문자열로 변환됩니다. 그러나 인수가 다른 json1 함수의 출력 인 경우 JSON으로 저장됩니다. 이를 통해 json_array () 및 &lt;a href=&quot;json1#jobj&quot;&gt;json_object ()에&lt;/a&gt; 대한 호출을 중첩 할 수 있습니다. &lt;a href=&quot;json1#jmini&quot;&gt;JSON ()&lt;/a&gt; 함수는 힘 문자열로 사용할 수는 JSON으로 인식한다.</target>
        </trans-unit>
        <trans-unit id="c4806a509e481529fa2b28682facfc05b551794d" translate="yes" xml:space="preserve">
          <source>An assert() statement is often used to validate pre-conditions on internal functions and methods. Example: &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&lt;/a&gt;. This is deemed better than simply stating the pre-condition in a header comment, since the assert() is actually executed. In a highly tested program like SQLite, the reader knows that the pre-condition is true for all of the hundreds of millions of test cases run against SQLite, since it has been verified by the assert(). In contrast, a text pre-condition statement in a header comment is untested. It might have been true when the code was written, but who is to say that it is still true now?</source>
          <target state="translated">assert () 문은 종종 내부 함수 및 메서드에 대한 사전 조건을 확인하는 데 사용됩니다. 예 : &lt;a href=&quot;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&quot;&gt;https://sqlite.org/src/artifact/c1e97e4c6f?ln=1048&lt;/a&gt; . assert ()가 실제로 실행되기 때문에 헤더 주석에 사전 조건을 명시하는 것보다 낫습니다. SQLite와 같이 고도로 테스트 된 프로그램에서 독자는 assert ()에 의해 검증되었으므로 SQLite에 대해 실행 된 수억 개의 모든 테스트 사례에 대해 사전 조건이 참임을 알고 있습니다. 대조적으로, 헤더 주석의 텍스트 사전 조건문은 테스트되지 않습니다. 코드가 작성되었을 때 사실 이었을지 모르지만, 지금은 여전히 ​​사실이라고 말하는 사람은 누구입니까?</target>
        </trans-unit>
        <trans-unit id="734aa331fcaf7e910bbd2120afae3cf5a122f2fd" translate="yes" xml:space="preserve">
          <source>An assertion fails if P2 is not an integer.</source>
          <target state="translated">P2가 정수가 아닌 경우 어설 션이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="f4d9c6c8e0b518f22e195d912f6aa5b7d1dd73a5" translate="yes" xml:space="preserve">
          <source>An atomic commit is supposed to happen instantaneously. But the processing described above clearly takes a finite amount of time. Suppose the power to the computer were cut part way through the commit operation described above. In order to maintain the illusion that the changes were instantaneous, we have to &quot;rollback&quot; any partial changes and restore the database to the state it was in prior to the beginning of the transaction.</source>
          <target state="translated">원자 커밋은 즉시 발생합니다. 그러나 위에서 설명한 처리에는 분명히 시간이 걸립니다. 위에서 설명한 커밋 작업을 통해 컴퓨터의 전원이 일부 차단되었다고 가정합니다. 변경 사항이 즉시 발생했다는 착각을 유지하려면 부분 변경 내용을 &quot;롤백&quot;하고 데이터베이스를 트랜잭션 시작 이전 상태로 복원해야합니다.</target>
        </trans-unit>
        <trans-unit id="e11c0c4803807d87c78fdeba64f0dde4ba44fbdd" translate="yes" xml:space="preserve">
          <source>An attempt is made to upgrade to an</source>
          <target state="translated">에 업그레이드를 시도합니다</target>
        </trans-unit>
        <trans-unit id="404254ba0f2702898e820a78567011f727d4bb51" translate="yes" xml:space="preserve">
          <source>An attempt to execute COMMIT might also result in an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; return code if an another thread or process has an open read connection. When COMMIT fails in this way, the transaction remains active and the COMMIT can be retried later after the reader has had a chance to clear.</source>
          <target state="translated">다른 스레드 또는 프로세스에 열린 읽기 연결이있는 경우 COMMIT를 실행하면 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 리턴 코드 가 발생할 수도 있습니다 . COMMIT가 이런 방식으로 실패하면 트랜잭션은 활성 상태로 유지되며 독자가 지울 수있는 기회가 나중에 COMMIT를 다시 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3979550223b90497821c0aba7295ef97c7b65e0d" translate="yes" xml:space="preserve">
          <source>An attempt to read from an expired &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;.</source>
          <target state="translated">만료 된 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 읽기 시도가 오류 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="79d2f9e7d226af948b651170c9b5bffda6c6a847" translate="yes" xml:space="preserve">
          <source>An attempt to read from an expired &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;.</source>
          <target state="translated">만료 된 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에서 읽기 시도가 오류 코드 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="c063fe576f329d251937e5f31d7607dcdb3d3ae3" translate="yes" xml:space="preserve">
          <source>An attempt to write to an expired &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Writes to the BLOB that occurred before the &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handle&lt;/a&gt; expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.</source>
          <target state="translated">만료 된 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에 쓰려는 시도 는 오류 코드 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ABORT로&lt;/a&gt; 실패합니다 . &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들이&lt;/a&gt; 만기 되기 전에 발생한 BLOB에 대한 쓰기 는 핸들 만기에 의해 롤백되지는 않지만 BLOB 핸들이 만기 된 명령문이나 다른 독립 명령문에 의해 변경 사항이 겹쳐 써질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75bfad8795848d7c6435b7cbd7f5aec468cc1527" translate="yes" xml:space="preserve">
          <source>An attempt to write to an expired &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; fails with an error code of &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT&lt;/a&gt;. Writes to the BLOB that occurred before the &lt;a href=&quot;blob&quot;&gt;BLOB handle&lt;/a&gt; expired are not rolled back by the expiration of the handle, though of course those changes might have been overwritten by the statement that expired the BLOB handle or by other independent statements.</source>
          <target state="translated">만료 된 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들&lt;/a&gt; 에 쓰려는 시도 는 오류 코드 &lt;a href=&quot;../rescode#abort&quot;&gt;SQLITE_ABORT로&lt;/a&gt; 실패합니다 . &lt;a href=&quot;blob&quot;&gt;BLOB 핸들이&lt;/a&gt; 만기 되기 전에 발생한 BLOB에 대한 쓰기 는 핸들 만기에 의해 롤백되지는 않지만 BLOB 핸들이 만기 된 명령문이나 다른 독립 명령문에 의해 변경 사항이 겹쳐 써질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ad76d49804b0b58fd84332ca5a84e267894c91f" translate="yes" xml:space="preserve">
          <source>An authorizer is used when &lt;a href=&quot;#sqlite3_prepare&quot;&gt;preparing&lt;/a&gt; SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database. For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database. But the application does not want the user to be able to make arbitrary changes to the database. An authorizer could then be put in place while the user-entered SQL is being &lt;a href=&quot;#sqlite3_prepare&quot;&gt;prepared&lt;/a&gt; that disallows everything except &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements.</source>
          <target state="translated">권한 부여자는 신뢰할 수없는 소스에서 SQL 문을 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;준비&lt;/a&gt; 할 때 SQL 문이 볼 수없는 데이터에 액세스하지 않거나 데이터베이스를 손상시키는 악의적 인 명령문을 실행하지 않도록하기 위해 사용됩니다. 예를 들어, 응용 프로그램을 통해 사용자는 데이터베이스에 의한 평가를 위해 임의의 SQL 쿼리를 입력 할 수 있습니다. 그러나 응용 프로그램은 사용자가 데이터베이스를 임의로 변경할 수 있기를 원하지 않습니다. 그런 다음 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 제외한 모든 항목을 허용하지 않는 사용자가 입력 한 SQL을 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;준비&lt;/a&gt; 하는 동안 권한 부여자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f1e075e878ae45a376fd2939c290edbd89e855bf" translate="yes" xml:space="preserve">
          <source>An authorizer is used when &lt;a href=&quot;prepare&quot;&gt;preparing&lt;/a&gt; SQL statements from an untrusted source, to ensure that the SQL statements do not try to access data they are not allowed to see, or that they do not try to execute malicious statements that damage the database. For example, an application may allow a user to enter arbitrary SQL queries for evaluation by a database. But the application does not want the user to be able to make arbitrary changes to the database. An authorizer could then be put in place while the user-entered SQL is being &lt;a href=&quot;prepare&quot;&gt;prepared&lt;/a&gt; that disallows everything except &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; statements.</source>
          <target state="translated">권한 부여자는 신뢰할 수없는 소스에서 SQL 문을 &lt;a href=&quot;prepare&quot;&gt;준비&lt;/a&gt; 할 때 SQL 문이 볼 수없는 데이터에 액세스하지 않거나 데이터베이스를 손상시키는 악의적 인 명령문을 실행하지 않도록하기 위해 사용됩니다. 예를 들어, 응용 프로그램을 통해 사용자는 데이터베이스에 의한 평가를 위해 임의의 SQL 쿼리를 입력 할 수 있습니다. 그러나 응용 프로그램은 사용자가 데이터베이스를 임의로 변경할 수 있기를 원하지 않습니다. 그런 다음 &lt;a href=&quot;../lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 제외한 모든 항목을 허용하지 않는 사용자가 입력 한 SQL을 &lt;a href=&quot;prepare&quot;&gt;준비&lt;/a&gt; 하는 동안 권한 부여자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c5a8d89ce83a2b735008709c97144e7c8447c49" translate="yes" xml:space="preserve">
          <source>An automatic index might also be used for a subquery:</source>
          <target state="translated">하위 쿼리에도 자동 인덱스를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a27a69d5289ec3895fe5350ae755b86c8341fcb" translate="yes" xml:space="preserve">
          <source>An encoded FTS varint consumes between one and ten bytes of space. The number of bytes required is determined by the sign and magnitude of the integer value encoded. More accurately, the number of bytes used to store the encoded integer depends on the position of the most significant set bit in the 64-bit twos-complement representation of the integer value. Negative values always have the most significant bit set (the sign bit), and so are always stored using the full ten bytes. Positive integer values may be stored using less space.</source>
          <target state="translated">인코딩 된 FTS varint는 1에서 10 바이트 사이의 공간을 소비합니다. 필요한 바이트 수는 인코딩 된 정수 값의 부호와 크기에 의해 결정됩니다. 보다 정확하게는, 인코딩 된 정수를 저장하는데 사용 된 바이트 수는 정수 값의 64 비트 2 보수 표현에서 가장 중요한 세트 비트의 위치에 의존한다. 음수 값은 항상 최상위 비트 세트 (부호 비트)를 가지므로 항상 전체 10 바이트를 사용하여 저장됩니다. 더 적은 공간을 사용하여 양의 정수 값이 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23566adaf44732949e813db81dd7b604df6839d5" translate="yes" xml:space="preserve">
          <source>An ending frame boundary,</source>
          <target state="translated">끝 프레임 경계</target>
        </trans-unit>
        <trans-unit id="9b7f16750f7735a9bc64b3d85d026914564b32de" translate="yes" xml:space="preserve">
          <source>An error is now returned when trying to start a transaction if another transaction is already active.</source>
          <target state="translated">다른 트랜잭션이 이미 활성화 된 경우 트랜잭션을 시작하려고하면 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6742ab14c7e1b0f89ab6e50a3f4d9ccb4760cbd" translate="yes" xml:space="preserve">
          <source>An error logger callback is invoked on SQLITE_MISUSE errors. This is useful in detecting application design issues when return codes are not consistently checked in the application code.</source>
          <target state="translated">오류 로그 작성기 콜백은 SQLITE_MISUSE 오류에서 호출됩니다. 이는 애플리케이션 코드에서 리턴 코드가 일관되게 확인되지 않은 경우 애플리케이션 설계 문제를 감지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e57ea0e26c7c063563f7c480ba3dfeaecea3cb15" translate="yes" xml:space="preserve">
          <source>An error. &quot;darkstar&quot; is not a recognized authority.</source>
          <target state="translated">오류입니다. &quot;darkstar&quot;는 공인 된 기관이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a9d782005fc023f48e522001d78e4867344c8d47" translate="yes" xml:space="preserve">
          <source>An error. &quot;readonly&quot; is not a valid option for the &quot;mode&quot; parameter.</source>
          <target state="translated">오류입니다. &quot;readonly&quot;는 &quot;mode&quot;매개 변수에 유효한 옵션이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c1dc1f3ba0806333fcf879ed6122522e9f542e04" translate="yes" xml:space="preserve">
          <source>An example of an eponymous virtual table is the &lt;a href=&quot;dbstat&quot;&gt;dbstat virtual table&lt;/a&gt;. To use the dbstat virtual table as an eponymous virtual table, simply query against the &quot;dbstat&quot; module name, as if it were an ordinary table. (Note that SQLite must be compiled with the &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; option to include the dbstat virtual table in the build.)</source>
          <target state="translated">&lt;a href=&quot;dbstat&quot;&gt;시상 가상 테이블&lt;/a&gt; 의 예는 dbstat 가상 테이블 입니다. dbstat 가상 테이블을 동일한 가상 테이블로 사용하려면 일반 테이블 인 것처럼 &quot;dbstat&quot;모듈 이름을 쿼리하면됩니다. ( 빌드에 dbstat 가상 테이블을 포함 시키려면 SQLite를 &lt;a href=&quot;compile#enable_dbstat_vtab&quot;&gt;SQLITE_ENABLE_DBSTAT_VTAB&lt;/a&gt; 옵션 으로 컴파일해야합니다 .)</target>
        </trans-unit>
        <trans-unit id="d551629b2a32e687e6920a81c2f515bee137ebdf" translate="yes" xml:space="preserve">
          <source>An example use of hidden columns can be seen in the &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; virtual table implementation, where every FTS virtual table contains an &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS hidden column&lt;/a&gt; that is used to pass information from the virtual table into &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt; and to the &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; operator.</source>
          <target state="translated">숨겨진 열의 사용 예는 &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 가상 테이블 구현 에서 확인할 수 있습니다 . 여기서 모든 FTS 가상 테이블에는 가상 테이블의 정보를 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 함수&lt;/a&gt; 및 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;FTS MATCH&lt;/a&gt; 연산자 로 전달하는 데 사용되는 &lt;a href=&quot;fts3#hiddencol&quot;&gt;FTS 숨겨진 열&lt;/a&gt; 이 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e17bf1221a1fb0282388819bb91b8a5c6ed013a" translate="yes" xml:space="preserve">
          <source>An example will help to clarify this concept. Consider the following query:</source>
          <target state="translated">예를 들어이 개념을 명확히하는 데 도움이됩니다. 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0b97feb4054b223de8848c552e7e62e2eeabb327" translate="yes" xml:space="preserve">
          <source>An example: Suppose there are two database connections X and Y. X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; followed by one or more &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements. Then Y comes along and runs an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement to modify the database. X can subsequently do a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; against the records that Y modified but X will see the older unmodified entries because Y's changes are all invisible to X while X is holding a read transaction. If X wants to see the changes that Y made, then X must ends its read transaction and start a new one (by running &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; followed by another &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.)</source>
          <target state="translated">예 : 두 개의 데이터베이스 연결 X와 Y가 있다고 가정하십시오. X는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN을&lt;/a&gt; 사용하여 읽기 트랜잭션을 시작하고 하나 이상의 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 시작합니다. 그런 다음 Y가 와서 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 하여 데이터베이스를 수정합니다. X는 나중에 Y가 수정 한 레코드에 대해 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 를 수행 할 수 있지만 X가 읽기 트랜잭션을 보유하는 동안 Y의 변경 사항이 모두 X에 표시되지 않기 때문에 X는 수정되지 않은 이전 항목을 볼 수 있습니다. X가 Y의 변경 사항을보고자하는 경우, X는 읽기 트랜잭션을 종료하고 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 를 실행 한 후 다른 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 을 실행하여 새 트랜잭션을 시작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b6e6d373bf06dd9c8c05c43eca6f2690b8f93a5" translate="yes" xml:space="preserve">
          <source>An exclusive lock is held on WAL_WRITE_LOCK while adding new frame onto the end of a WAL file.</source>
          <target state="translated">WAL 파일 끝에 새 프레임을 추가하는 동안 WAL_WRITE_LOCK에 독점 잠금이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="472410dd7fa81690261e9f1011036ea0cbeb522e" translate="yes" xml:space="preserve">
          <source>An experimental module providing on-demand read-only access to multiple tables spread across multiple databases, via a single virtual table abstraction.</source>
          <target state="translated">여러 테이블에 대한 주문형 읽기 전용 액세스를 제공하는 실험 모듈은 단일 가상 테이블 추상화를 통해 여러 데이터베이스에 분산됩니다.</target>
        </trans-unit>
        <trans-unit id="667c5b4834a03d379059f491edab75c439a88d3e" translate="yes" xml:space="preserve">
          <source>An expression of the form &quot;CAST(</source>
          <target state="translated">&quot;CAST (</target>
        </trans-unit>
        <trans-unit id="818ecb03985da596f3eae278c34f7853ab10690e" translate="yes" xml:space="preserve">
          <source>An external content FTS4 table is created by setting the content option to the name of a table (or view, or virtual table) that may be queried by FTS4 to retrieve column values when required. If the nominated table does not exist, then an external content table behaves in the same way as a contentless table. For example:</source>
          <target state="translated">외부 옵션 FTS4 테이블은 content 옵션을 필요한 경우 열 값을 검색하기 위해 FTS4에 의해 조회 될 수있는 테이블 (또는 뷰 또는 가상 테이블)의 이름으로 설정하여 작성됩니다. 지명 된 테이블이 존재하지 않으면 외부 컨텐츠 테이블은 컨텐츠가없는 테이블과 동일한 방식으로 작동합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2af47edb4534251424ba986a5ead5c83306505ff" translate="yes" xml:space="preserve">
          <source>An external content FTS5 table is created by setting the content option to the name of a table, virtual table or view (hereafter the &quot;content table&quot;) within the same database. Whenever column values are required by FTS5, it queries the content table as follows, with the rowid of the row for which values are required bound to the SQL variable:</source>
          <target state="translated">외부 데이터베이스 FTS5 테이블은 컨텐츠 옵션을 동일한 데이터베이스 내에서 테이블, 가상 테이블 또는 뷰 (이하 &quot;컨텐츠 테이블&quot;)의 이름으로 설정하여 작성됩니다. FTS5에서 열 값이 필요할 때마다 값이 필요한 행의 rowid를 SQL 변수에 바인딩하여 다음과 같이 컨텐츠 테이블을 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="d52b102f266b0f6f1ccf383a15555d761fab3f49" translate="yes" xml:space="preserve">
          <source>An fts4aux virtual table is constructed with one or two arguments. When used with a single argument, that argument is the unqualified name of the FTS table that it will be used to access. To access a table in a different database (for example, to create a TEMP fts4aux table that will access an FTS3 table in the MAIN database) use the two-argument form and give the name of the target database (ex: &quot;main&quot;) in the first argument and the name of the FTS3/4 table as the second argument. (The two-argument form of fts4aux was added for SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20) and will throw an error in prior releases.) For example:</source>
          <target state="translated">fts4aux 가상 테이블은 하나 또는 두 개의 인수로 구성됩니다. 단일 인수와 함께 사용되는 경우 해당 인수는 액세스하는 데 사용될 FTS 테이블의 규정되지 않은 이름입니다. 다른 데이터베이스의 테이블에 액세스하려면 (예를 들어, MAIN 데이터베이스의 FTS3 테이블에 액세스하는 TEMP fts4aux 테이블 작성) 두 인수 형식을 사용하고 대상 데이터베이스의 이름을 지정하십시오 (예 : &quot;main&quot;). 첫 번째 인수에서 FTS3 / 4 테이블의 이름을 두 번째 인수로 사용하십시오. (fts4aux의 두 인수 형식은 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20) 용으로 추가 되었으며 이전 릴리스에서 오류가 발생합니다.) 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c25046031c36326ccd0fd6dd82951cf50be0673" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;col&quot; contains one row for each distinct term/column combination in the associated FTS5 table. Table columns are as follows:</source>
          <target state="translated">&quot;col&quot;유형의 fts5vocab 테이블에는 연관된 FTS5 테이블의 각 고유 용어 / 열 조합에 대해 하나의 행이 포함됩니다. 테이블 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f04198cf656fcfcd60de51b84883a5a273fb8d3" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;instance&quot; contains one row for each term instance stored in the associated FTS index. Assuming the FTS5 table is created with the 'detail' option set to 'full', table columns are as follows:</source>
          <target state="translated">&quot;인스턴스&quot;유형의 fts5vocab 테이블에는 연관된 FTS 인덱스에 저장된 각 용어 인스턴스에 대해 하나의 행이 포함됩니다. FTS5 테이블이 'detail'옵션을 'full'로 설정하여 작성한다고 가정하면 테이블 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4f46cd06dd0edb512dbfe5bb420f25b92508728" translate="yes" xml:space="preserve">
          <source>An fts5vocab table of type &quot;row&quot; contains one row for each distinct term in the associated FTS5 table. The table columns are as follows:</source>
          <target state="translated">&quot;row&quot;유형의 fts5vocab 테이블에는 연관된 FTS5 테이블의 각 고유 용어에 대해 하나의 행이 포함됩니다. 테이블 열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e5d44e56062277710f5511afeab18594a8851fc" translate="yes" xml:space="preserve">
          <source>An implementation of the Guttmann R*Tree spatial index idea.</source>
          <target state="translated">Guttmann R * Tree 공간 인덱스 아이디어의 구현.</target>
        </trans-unit>
        <trans-unit id="4bd28b3c3d3e6a39cb2320865c316342a20f3142" translate="yes" xml:space="preserve">
          <source>An implicit transaction (a transaction that is started automatically, not a transaction started by BEGIN) is committed automatically when the last active statement finishes. A statement finishes when its last cursor closes, which is guaranteed to happen when the prepared statement is &lt;a href=&quot;c3ref/reset&quot;&gt;reset&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;finalized&lt;/a&gt;. Some statements might &quot;finish&quot; for the purpose of transaction control prior to being reset or finalized, but there is no guarantee of this. The only way to ensure that a statement has &quot;finished&quot; is to invoke &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset()&lt;/a&gt; or &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize()&lt;/a&gt; on that statement. An open &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; used for incremental BLOB I/O also counts as an unfinished statement. The &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; finishes when it is &lt;a href=&quot;c3ref/blob_close&quot;&gt;closed&lt;/a&gt;.</source>
          <target state="translated">내재 된 트랜잭션 (BEGIN에 의해 ​​시작된 트랜잭션이 아닌 자동으로 시작된 트랜잭션)은 마지막 활성 명령문이 완료 될 때 자동으로 커미트됩니다. 명령문은 마지막 커서가 닫히면 완료되며 준비된 명령문이 &lt;a href=&quot;c3ref/reset&quot;&gt;재설정&lt;/a&gt; 되거나 &lt;a href=&quot;c3ref/finalize&quot;&gt;완료&lt;/a&gt; 될 때 발생합니다 . 일부 명령문은 재설정 또는 완료되기 전에 트랜잭션 제어를 목적으로 &quot;완료&quot;될 수 있지만이를 보증하지는 않습니다. 명령문이 &quot;완료&quot;되었는지 확인하는 유일한 방법은 해당 명령문에서 &lt;a href=&quot;c3ref/reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/finalize&quot;&gt;sqlite3_finalize ()&lt;/a&gt; 를 호출 하는 것입니다. 증분 BLOB I / O에 사용 되는 열린 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 도 완료되지 않은 명령문으로 계산됩니다. &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt;&lt;a href=&quot;c3ref/blob_close&quot;&gt;닫히면&lt;/a&gt; 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="79074d6687b22dc4e17257f4e6cee62c251811c4" translate="yes" xml:space="preserve">
          <source>An important feature of transactional databases like SQLite is &quot;atomic commit&quot;. Atomic commit means that either all database changes within a single transaction occur or none of them occur. With atomic commit, it is as if many different writes to different sections of the database file occur instantaneously and simultaneously. Real hardware serializes writes to mass storage, and writing a single sector takes a finite amount of time. So it is impossible to truly write many different sectors of a database file simultaneously and/or instantaneously. But the atomic commit logic within SQLite makes it appear as if the changes for a transaction are all written instantaneously and simultaneously.</source>
          <target state="translated">SQLite와 같은 트랜잭션 데이터베이스의 중요한 기능은 &quot;원자 커밋&quot;입니다. 원자 커밋은 단일 트랜잭션 내에서 모든 데이터베이스 변경이 발생하거나 전혀 수행되지 않음을 의미합니다. 원자 커밋을 사용하면 데이터베이스 파일의 다른 섹션에 대한 많은 다른 쓰기가 순간적으로 동시에 발생하는 것과 같습니다. 실제 하드웨어는 대량 스토리지에 대한 쓰기를 직렬화하며 단일 섹터를 작성하는 데는 시간이 걸립니다. 따라서 데이터베이스 파일의 여러 섹터를 동시에 또는 즉시 작성하는 것은 불가능합니다. 그러나 SQLite 내의 원자 커밋 논리는 마치 트랜잭션에 대한 변경 사항이 모두 동시에 동시에 작성되는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="52bb5c1058e3b07cc3eb83a0aae8a367e19c8fb8" translate="yes" xml:space="preserve">
          <source>An imposter table is a table that is attached to the same &lt;a href=&quot;fileformat2#btree&quot;&gt;b-tree&lt;/a&gt; as an index. An imposter table allows the content of an index to be queried or modified as if the index were an ordinary table.</source>
          <target state="translated">임 포스터 테이블은 인덱스 와 동일한 &lt;a href=&quot;fileformat2#btree&quot;&gt;b- 트리에&lt;/a&gt; 연결된 테이블입니다 . 임 포스터 테이블을 사용하면 인덱스가 일반 테이블 인 것처럼 인덱스의 내용을 쿼리하거나 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="548d97f9737c13966b0384ddf7c4f5316897fe64" translate="yes" xml:space="preserve">
          <source>An index b-tree interior page</source>
          <target state="translated">인덱스 b- 트리 내부 페이지</target>
        </trans-unit>
        <trans-unit id="75b00cd2ffa8d152bd911781465eeda8179c5b9f" translate="yes" xml:space="preserve">
          <source>An index b-tree leaf page</source>
          <target state="translated">인덱스 b- 트리 리프 페이지</target>
        </trans-unit>
        <trans-unit id="a23b6e554c4c927f47667a50d9e483703c1ef47e" translate="yes" xml:space="preserve">
          <source>An index is another table similar to the original &quot;fruitsforsale&quot; table but with the content (the fruit column in this case) stored in front of the rowid and with all rows in content order. &lt;a href=&quot;#fig4&quot;&gt;Figure 4&lt;/a&gt; gives a logical view of the Idx1 index. The &quot;fruit&quot; column is the primary key used to order the elements of the table and the &quot;rowid&quot; is the secondary key used to break the tie when two or more rows have the same &quot;fruit&quot;. In the example, the rowid has to be used as a tie-breaker for the &quot;Orange&quot; rows. Notice that since the rowid is always unique over all elements of the original table, the composite key of &quot;fruit&quot; followed by &quot;rowid&quot; will be unique over all elements of the index.</source>
          <target state="translated">인덱스는 원래 &quot;fruitsforsale&quot;테이블과 유사하지만 rowid 앞에 내용 (이 경우 과일 열)이 있고 모든 행이 내용 순서로있는 다른 테이블입니다. &lt;a href=&quot;#fig4&quot;&gt;그림 4&lt;/a&gt; 는 Idx1 인덱스의 논리적 뷰입니다. &quot;fruit&quot;열은 테이블 요소를 정렬하는 데 사용되는 기본 키이고 &quot;rowid&quot;는 둘 이상의 행에 동일한 &quot;fruit&quot;가있을 때 연결을 끊는 데 사용되는 보조 키입니다. 이 예에서 rowid는 &quot;Orange&quot;행의 타이 브레이커로 사용해야합니다. rowid는 원래 테이블의 모든 요소에서 항상 고유하므로 &quot;fruit&quot;의 복합 키와 &quot;rowid&quot;는 인덱스의 모든 요소에서 고유합니다.</target>
        </trans-unit>
        <trans-unit id="3002819a06b87f2b28823dffe3c0b248534f6bf1" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;../wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="translated">스냅 샷 오브젝트의 인스턴스는 특정 히스토리 포인트에 대한 &lt;a href=&quot;../wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 의 상태를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="ddc9cd2833d461982fd05cbb236027102f78db05" translate="yes" xml:space="preserve">
          <source>An instance of the snapshot object records the state of a &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; database for some specific point in history.</source>
          <target state="translated">스냅 샷 오브젝트의 인스턴스는 특정 히스토리 포인트에 대한 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 데이터베이스 의 상태를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="0ad16796bc17d538460c93b836ae5c8477d8c7e2" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_str object contains a dynamically-sized string under construction.</source>
          <target state="translated">sqlite3_str 객체의 인스턴스에는 생성중인 동적 크기 문자열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8f02269b16b7995873f0e98891ae8060c34bc231" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;../vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="translated">sqlite3_vfs 객체의 인스턴스는 SQLite 코어와 기본 운영 체제 간의 인터페이스를 정의합니다. 객체 이름의 &quot;vfs&quot;는 &quot;가상 파일 시스템&quot;을 나타냅니다. 자세한 내용은 &lt;a href=&quot;../vfs&quot;&gt;VFS 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="986d34aa72070b33f262aa39aa661f9a7021ae8a" translate="yes" xml:space="preserve">
          <source>An instance of the sqlite3_vfs object defines the interface between the SQLite core and the underlying operating system. The &quot;vfs&quot; in the name of the object stands for &quot;virtual file system&quot;. See the &lt;a href=&quot;vfs&quot;&gt;VFS documentation&lt;/a&gt; for further information.</source>
          <target state="translated">sqlite3_vfs 객체의 인스턴스는 SQLite 코어와 기본 운영 체제 간의 인터페이스를 정의합니다. 객체 이름의 &quot;vfs&quot;는 &quot;가상 파일 시스템&quot;을 나타냅니다. 자세한 내용은 &lt;a href=&quot;vfs&quot;&gt;VFS 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f45b93bef69dcf39c21d4d46704ba221d046f871" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;../sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;../sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="translated">이 객체의 인스턴스는 &lt;a href=&quot;../sessionintro#changeset&quot;&gt;변경 &lt;/a&gt;&lt;a href=&quot;../sessionintro#changeset&quot;&gt;세트&lt;/a&gt; 또는 패치 세트 의 요소를 반복하기위한 커서 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="bf71b1083943f3e5851ab7a42bcd920407783dbc" translate="yes" xml:space="preserve">
          <source>An instance of this object acts as a cursor for iterating over the elements of a &lt;a href=&quot;sessionintro#changeset&quot;&gt;changeset&lt;/a&gt; or &lt;a href=&quot;sessionintro#changeset&quot;&gt;patchset&lt;/a&gt;.</source>
          <target state="translated">이 객체의 인스턴스는 &lt;a href=&quot;sessionintro#changeset&quot;&gt;변경 &lt;/a&gt;&lt;a href=&quot;sessionintro#changeset&quot;&gt;세트&lt;/a&gt; 또는 패치 세트 의 요소를 반복하기위한 커서 역할을합니다 .</target>
        </trans-unit>
        <trans-unit id="ab7e618ccd27967f90c1e650a28d3404240080d5" translate="yes" xml:space="preserve">
          <source>An instance of this object defines the interface between SQLite and low-level memory allocation routines.</source>
          <target state="translated">이 객체의 인스턴스는 SQLite와 저수준 메모리 할당 루틴 간의 인터페이스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a3b65debab7d2bc5f3be01481bf018b30e5f1a63" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;../sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="translated">이 객체의 인스턴스 는 데이터베이스의 변경 사항을 기록하는 데 사용할 수 있는 &lt;a href=&quot;../sessionintro&quot;&gt;세션&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d288e209f1c35236167d79cd8408a6e6645c8dfe" translate="yes" xml:space="preserve">
          <source>An instance of this object is a &lt;a href=&quot;sessionintro&quot;&gt;session&lt;/a&gt; that can be used to record changes to a database.</source>
          <target state="translated">이 객체의 인스턴스 는 데이터베이스의 변경 사항을 기록하는 데 사용할 수 있는 &lt;a href=&quot;sessionintro&quot;&gt;세션&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1a8cd868b7a8f02ee212f8081b22f84902c700f2" translate="yes" xml:space="preserve">
          <source>An instance of this object represents a single SQL statement that has been compiled into binary form and is ready to be evaluated.</source>
          <target state="translated">이 개체의 인스턴스는 이진 형식으로 컴파일되어 평가할 준비가 된 단일 SQL 문을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6ac15740a5e0d955ec96459bba2b236546957815" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="translated">이 오브젝트의 인스턴스는 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;증분 BLOB I / O&lt;/a&gt; 를 수행 할 수 있는 개방 BLOB를 나타냅니다 . 이 유형의 객체에 의해 생성되어 &lt;a href=&quot;#sqlite3_blob_open&quot;&gt;sqlite3_blob_open ()에&lt;/a&gt; 의해 소멸 &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;() sqlite3_blob_close&lt;/a&gt; . &lt;a href=&quot;#sqlite3_blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;#sqlite3_blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 인터페이스는 BLOB 작은 소단원 판독 또는 기록하기 위해 사용될 수있다. &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes는 ()&lt;/a&gt; 인터페이스는 바이트 BLOB의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3e12c7941ae7ce9acfd3af6cea2f4a94a2e0d5a" translate="yes" xml:space="preserve">
          <source>An instance of this object represents an open BLOB on which &lt;a href=&quot;blob_open&quot;&gt;incremental BLOB I/O&lt;/a&gt; can be performed. Objects of this type are created by &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open()&lt;/a&gt; and destroyed by &lt;a href=&quot;blob_close&quot;&gt;sqlite3_blob_close()&lt;/a&gt;. The &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read()&lt;/a&gt; and &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write()&lt;/a&gt; interfaces can be used to read or write small subsections of the BLOB. The &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface returns the size of the BLOB in bytes.</source>
          <target state="translated">이 오브젝트의 인스턴스는 &lt;a href=&quot;blob_open&quot;&gt;증분 BLOB I / O&lt;/a&gt; 를 수행 할 수 있는 개방 BLOB를 나타냅니다 . 이 유형의 객체에 의해 생성되어 &lt;a href=&quot;blob_open&quot;&gt;sqlite3_blob_open ()에&lt;/a&gt; 의해 소멸 &lt;a href=&quot;blob_close&quot;&gt;() sqlite3_blob_close&lt;/a&gt; . &lt;a href=&quot;blob_read&quot;&gt;sqlite3_blob_read ()&lt;/a&gt; 및 &lt;a href=&quot;blob_write&quot;&gt;sqlite3_blob_write ()&lt;/a&gt; 인터페이스는 BLOB 작은 소단원 판독 또는 기록하기 위해 사용될 수있다. &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes는 ()&lt;/a&gt; 인터페이스는 바이트 BLOB의 크기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9c5d268a10fe06a59e3c7e963d5ed29fc68438c" translate="yes" xml:space="preserve">
          <source>An instance of this structure defines the low-level routines used to allocate and use mutexes.</source>
          <target state="translated">이 구조의 인스턴스는 뮤텍스를 할당하고 사용하는 데 사용되는 하위 수준 루틴을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7b02932da3aaeca2f83c028e321d42447d0835b5" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to read the text from. Columns are numbered from left to right starting at zero.</source>
          <target state="translated">텍스트를 읽을 FTS 테이블 열의 인덱스를 나타내는 정수입니다. 열은 0부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨집니다.</target>
        </trans-unit>
        <trans-unit id="c23d5e6e7614ceb92ef3b6de48759bd54ba26b48" translate="yes" xml:space="preserve">
          <source>An integer indicating the index of the FTS table column to select the returned text from. Columns are numbered from left to right starting at zero. A negative value indicates that the column should be automatically selected.</source>
          <target state="translated">반환 된 텍스트를 선택할 FTS 테이블 열의 인덱스를 나타내는 정수입니다. 열은 0부터 시작하여 왼쪽에서 오른쪽으로 번호가 매겨집니다. 음수 값은 열을 자동으로 선택해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c886c068ec97375a0540464685cf9e1ef166d731" translate="yes" xml:space="preserve">
          <source>An intensively used low-level library like SQLite needs to be fast. (And SQLite is fast, see &lt;a href=&quot;intern-v-extern-blob&quot;&gt;Internal Versus External BLOBs&lt;/a&gt; and &lt;a href=&quot;fasterthanfs&quot;&gt;35% Faster Than The Filesystem&lt;/a&gt; for example.)</source>
          <target state="translated">SQLite와 같이 집중적으로 사용되는 저수준 라이브러리는 빨라야합니다. (그리고 SQLite는 빠르다 . 예를 들어 &lt;a href=&quot;intern-v-extern-blob&quot;&gt;외부 BLOB&lt;/a&gt; 와 내부 및 &lt;a href=&quot;fasterthanfs&quot;&gt;파일 시스템보다 35 % 더 빠름&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="02b10fc85927484bbd1851b4c4f858fb308385eb" translate="yes" xml:space="preserve">
          <source>An iterator is deleted using a call to the &lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize()&lt;/a&gt; API. If an error occured while iterating, an SQLite error code is returned (even if the same error code has already been returned by sqlite3changeset_next()). Or, if no error has occurred, SQLITE_OK is returned.</source>
          <target state="translated">&lt;a href=&quot;session/sqlite3changeset_finalize&quot;&gt;sqlite3changeset_finalize ()&lt;/a&gt; API 호출을 사용하여 반복자가 삭제됩니다 . 반복하는 동안 오류가 발생하면 SQLlite 오류 코드가 리턴됩니다 (sqlite3changeset_next ()에 의해 동일한 오류 코드가 이미 리턴 된 경우에도). 또는 오류가 발생하지 않으면 SQLITE_OK가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="dd92a7436e987265ed18e3cd262b66e57b47ffd2" translate="yes" xml:space="preserve">
          <source>An ongoing RBU operation (either an update or a vacuum) does not interfere with read access to the database file.</source>
          <target state="translated">지속적인 RBU 작업 (업데이트 또는 진공)은 데이터베이스 파일에 대한 읽기 액세스를 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98e9fb11f12f8a43c4c89d92d48bc4d12fa12b04" translate="yes" xml:space="preserve">
          <source>An operand of a comparison is considered to have an explicit collating function assignment (rule 1 above) if any subexpression of the operand uses the postfix &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt;. Thus, if a &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; is used anywhere in a comparision expression, the collating function defined by that operator is used for string comparison regardless of what table columns might be a part of that expression. If two or more &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; subexpressions appear anywhere in a comparison, the left most explicit collating function is used regardless of how deeply the COLLATE operators are nested in the expression and regardless of how the expression is parenthesized.</source>
          <target state="translated">피연산자의 하위 표현식이 접미사 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용하는 경우 비교 피연산자는 명시 적 조합 함수 할당 (위의 규칙 1)을 갖는 것으로 간주됩니다 . 따라서 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 가 비교 표현식의 어느 곳에서나 사용될 경우 해당 연산자에 의해 정의 된 조합 함수는 해당 표현식의 일부가 될 수있는 테이블 열에 관계없이 문자열 비교에 사용됩니다. 둘 이상의 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자&lt;/a&gt; 하위 표현식이 비교의 어느 곳에 나 나타나는 경우 COLLATE 연산자가 표현식에 얼마나 깊이 중첩되어 있는지, 표현식이 괄호로 묶여 있는지에 관계없이 가장 왼쪽에있는 명시 적 조합 함수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1841b8b7007b74c92e11286f08f070e4631c39a7" translate="yes" xml:space="preserve">
          <source>An ordinary common table expression works as if it were a &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; that exists for the duration of a single statement. Ordinary common table expressions are useful for factoring out subqueries and making the overall SQL statement easier to read and understand.</source>
          <target state="translated">일반 공통 테이블 표현식은 마치 단일 명령문 기간 동안 존재 하는 &lt;a href=&quot;lang_createview&quot;&gt;뷰인&lt;/a&gt; 것처럼 작동 합니다. 일반 공통 테이블 표현식은 서브 쿼리를 제외하고 전체 SQL 문을 읽고 이해하기 쉽게 만드는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c64f3df3f6dbd2c4ab332d741a98dc5f74fa4c01" translate="yes" xml:space="preserve">
          <source>An ordinary filename can usually be converted into an equivalent URI by the steps shown below. The one exception is that a relative windows pathname with a drive letter cannot be converted directly into a URI; it must be changed into an absolute pathname first.</source>
          <target state="translated">일반적인 파일 이름은 일반적으로 아래 표시된 단계에 따라 동등한 URI로 변환 될 수 있습니다. 한 가지 예외는 드라이브 문자가있는 상대 창 경로 이름을 URI로 직접 변환 할 수 없다는 것입니다. 먼저 절대 경로 이름으로 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="76f1c5c7c31ea92a8b28f97d519413325cc7abf4" translate="yes" xml:space="preserve">
          <source>An overlay can be created by using the</source>
          <target state="translated">를 사용하여 오버레이를 만들 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ace2a17ee0ffadfade85b391c6417dbd59dcd570" translate="yes" xml:space="preserve">
          <source>An rtree_i32 stores coordinates as 32-bit signed integers. But it still using floating point computations internally as part of the r-tree algorithm.</source>
          <target state="translated">rtree_i32는 좌표를 32 비트 부호있는 정수로 저장합니다. 그러나 여전히 r-tree 알고리즘의 일부로 내부에서 부동 소수점 계산을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="07cb8663d689220c5b11e75bcc91e43df5ab2f40" translate="yes" xml:space="preserve">
          <source>An sqlite3_changegroup object is used to combine two or more changesets (or patchsets) into a single changeset (or patchset). A single changegroup object may combine changesets or patchsets, but not both. The output is always in the same format as the input.</source>
          <target state="translated">sqlite3_changegroup 객체는 둘 이상의 변경 세트 (또는 패치 세트)를 단일 변경 세트 (또는 패치 세트)로 결합하는 데 사용됩니다. 단일 변경 그룹 객체는 변경 세트 또는 패치 세트를 결합 할 수 있지만 둘다는 아닙니다. 출력은 항상 입력과 동일한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="caf5ebeb61b12b4ca95cabbbacfd2a52d1e22645" translate="yes" xml:space="preserve">
          <source>An sqlite3_rebaser object is created by calling sqlite3rebaser_create().</source>
          <target state="translated">sqlite3rebaser_create ()를 호출하여 sqlite3_rebaser 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2af9897fcfc348b6ea18f42888797de74b915c33" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="translated">sqlite3_value 객체는 &quot;protected&quot;또는 &quot;unprotected&quot;일 수 있습니다. 일부 인터페이스에는 보호 된 sqlite3_value가 필요합니다. 다른 인터페이스는 보호 또는 비보호 sqlite3_value를 허용합니다. sqlite3_value 인수를 허용하는 모든 인터페이스는 보호 된 sqlite3_value가 필요한지 여부를 지정합니다. &lt;a href=&quot;#sqlite3_value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 인터페이스는 비보호 sqlite3_value로부터 새로운 보호 sqlite3_value를 구성 할 수있다.</target>
        </trans-unit>
        <trans-unit id="7bf10bfa8716c343b3bd7ed7af7b661d4bbe7281" translate="yes" xml:space="preserve">
          <source>An sqlite3_value object may be either &quot;protected&quot; or &quot;unprotected&quot;. Some interfaces require a protected sqlite3_value. Other interfaces will accept either a protected or an unprotected sqlite3_value. Every interface that accepts sqlite3_value arguments specifies whether or not it requires a protected sqlite3_value. The &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup()&lt;/a&gt; interface can be used to construct a new protected sqlite3_value from an unprotected sqlite3_value.</source>
          <target state="translated">sqlite3_value 객체는 &quot;protected&quot;또는 &quot;unprotected&quot;일 수 있습니다. 일부 인터페이스에는 보호 된 sqlite3_value가 필요합니다. 다른 인터페이스는 보호 또는 비보호 sqlite3_value를 허용합니다. sqlite3_value 인수를 허용하는 모든 인터페이스는 보호 된 sqlite3_value가 필요한지 여부를 지정합니다. &lt;a href=&quot;value_dup&quot;&gt;sqlite3_value_dup ()&lt;/a&gt; 인터페이스는 비보호 sqlite3_value로부터 새로운 보호 sqlite3_value를 구성 할 수있다.</target>
        </trans-unit>
        <trans-unit id="9e4dafbd07992ae7ef4dffddcd1b4a5c5cb76207" translate="yes" xml:space="preserve">
          <source>An unconditional jump to address P2. The next instruction executed will be the one at index P2 from the beginning of the program.</source>
          <target state="translated">P2 로의 무조건 점프. 다음에 실행되는 명령어는 프로그램 시작부터 인덱스 P2에있는 명령어입니다.</target>
        </trans-unit>
        <trans-unit id="0ec2f338946c19a5c8db3e1991942cfffb1ac767" translate="yes" xml:space="preserve">
          <source>An unrelated (and minor) bug from Mark Muranwski fixed. The algorithm for figuring out where to put temporary files for a &quot;memory:&quot; database was not working quite right.</source>
          <target state="translated">Mark Muranwski의 관련이없는 버그가 수정되었습니다. &quot;memory :&quot;데이터베이스의 임시 파일을 어디에 둘 것인지 파악하는 알고리즘이 제대로 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="24a1091048c98405fcc66da02f4798476c96d7b9" translate="yes" xml:space="preserve">
          <source>And So Forth...</source>
          <target state="translated">기타 등등...</target>
        </trans-unit>
        <trans-unit id="6d62766f3bc1a62b7bc2195312ea71e091c76d3c" translate="yes" xml:space="preserve">
          <source>And if there is an entry in that table where the key column exactly matches the name of parameter (including the initial &quot;?&quot;, &quot;$&quot;, &quot;:&quot;, or &quot;@&quot; character) then the parameter is assigned the value of the value column. If no entry exists, the parameter defaults to NULL.</source>
          <target state="translated">키 열이 매개 변수 이름 (초기 &quot;?&quot;, &quot;$&quot;, &quot;:&quot;또는 &quot;@&quot;문자 포함)과 정확히 일치하는 항목이 있으면 해당 매개 변수에 값이 할당됩니다. 값 열. 항목이 없으면 매개 변수의 기본값은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="1613947ae46cd2f84a12cf24acc0820e1f9d0a46" translate="yes" xml:space="preserve">
          <source>And it is not really about just finding the descendents of a check-in from time to time. The fact that descendents are readily available in Fossil means that the information pervades the web pages provided by Fossil. One example: Every Fossil check-in information page (&lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;example&lt;/a&gt;) shows a small &quot;Context&quot; graph of the immediate predecessor and successors to that check-in. This helps the user maintain better situational awareness, and it provides useful capabilities, such as the ability click forward to the next check-in in sequence. Another example: Fossil easily shows the context around a specific check-in (&lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;example&lt;/a&gt;) which again helps to promote situational awareness and a deeper understanding of what is happening in the code.</source>
          <target state="translated">그리고 실제로 체크인의 자손을 찾는 것이 아닙니다. 자손이 화석에서 쉽게 구할 수 있다는 사실은 정보가 화석이 제공 한 웹 페이지에 퍼져 있음을 의미합니다. 하나의 예 : 모든 화석 체크인 정보 페이지 ( &lt;a href=&quot;https://www.sqlite.org/src/info/ec7addc87f97bcff&quot;&gt;예&lt;/a&gt; )는 바로 전임자와 그 체크인의 후임에 대한 작은 &quot;컨텍스트&quot;그래프를 보여줍니다. 이를 통해 사용자는보다 나은 상황 인식을 유지하고 다음 체크인으로 순서대로 클릭하는 등 유용한 기능을 제공합니다. 또 다른 예 : 화석은 상황에 대한 인식을 높이고 코드에서 발생하는 상황에 대한 심층적 인 이해를 돕도록 특정 체크인 ( &lt;a href=&quot;https://www.sqlite.org/src/timeline?c=2018-03-16&amp;amp;n=10&quot;&gt;예&lt;/a&gt; :) 관련 컨텍스트를 쉽게 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c2283cc542d600a5581e49e759263651d3636f77" translate="yes" xml:space="preserve">
          <source>And let the query be:</source>
          <target state="translated">그리고 쿼리를 보자.</target>
        </trans-unit>
        <trans-unit id="9f762e3b5086b03457eac0a8ca5ae39d999e5440" translate="yes" xml:space="preserve">
          <source>And many, many bug fixes...</source>
          <target state="translated">그리고 많은 버그 수정 ...</target>
        </trans-unit>
        <trans-unit id="f247637664b32ff61f9705cffde6b438321ac676" translate="yes" xml:space="preserve">
          <source>And populated as if the target table were an ordinary SQLite table with no explicit PRIMARY KEY columns.</source>
          <target state="translated">목표 테이블이 명시적인 PRIMARY KEY 컬럼이없는 일반 SQLite 테이블 인 것처럼 채워집니다.</target>
        </trans-unit>
        <trans-unit id="f9380c403c5923e40740011085ed6c0ba26458c2" translate="yes" xml:space="preserve">
          <source>And so forth. Basically any sequence of names optionally followed by one or two signed integers in parentheses will do.</source>
          <target state="translated">기타 등등. 기본적으로 괄호 안에 하나 또는 두 개의 부호있는 정수가 오는 일련의 이름 순서가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b0959960067ae4919fa2e1ea2e691b5f145968c7" translate="yes" xml:space="preserve">
          <source>And so forth. For ZIP archives and SQLite Archives, simply change the &quot;/tarball/&quot; element into either &quot;/zip/&quot; or &quot;/sqlar/&quot;, and maybe also change the name of the download file to have a &quot;.zip&quot; or &quot;.sqlar&quot; suffix.</source>
          <target state="translated">기타 등등. ZIP 아카이브 및 SQLite 아카이브의 경우 &quot;/ tarball /&quot;요소를 &quot;/ zip /&quot;또는 &quot;/ sqlar /&quot;로 변경하고 다운로드 파일의 이름을 &quot;.zip&quot;또는 &quot;로 변경하십시오. sqlar &quot;접미사.</target>
        </trans-unit>
        <trans-unit id="ba8077732ad2502900dddf709f29aa73b1a0f6b4" translate="yes" xml:space="preserve">
          <source>And so forth. There are 8 nodes in the TPC-H Q8 query, so this process repeats a total of 8 times. In the general case of a K-way join, the storage requirement is O(N) and the computation time is O(K*N), which is significantly faster than the O(2&lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt;) exact solution.</source>
          <target state="translated">기타 등등. TPC-H Q8 쿼리에는 8 개의 노드가 있으므로이 프로세스는 총 8 번 반복됩니다. K-way 결합의 일반적인 경우 저장 요구 사항은 O (N)이고 계산 시간은 O (K * N)이며 이는 O (2 &lt;small&gt;&lt;sup&gt;K&lt;/sup&gt;&lt;/small&gt; ) 정확한 솔루션 보다 훨씬 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="060f19a1ad677f74cc92295a75b3f1b018b239ae" translate="yes" xml:space="preserve">
          <source>And so forth....</source>
          <target state="translated">기타 등등....</target>
        </trans-unit>
        <trans-unit id="5207dcf07042e825e2caf9ab6e9995854377e2d5" translate="yes" xml:space="preserve">
          <source>And the generated code looks like this:</source>
          <target state="translated">생성 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e512a9542a2e3dfd52435fac1d439e588ebcee9" translate="yes" xml:space="preserve">
          <source>And then you run the query:</source>
          <target state="translated">그런 다음 쿼리를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="9ffeb8471359e0755ff7942bbfbee2106c5c7ff7" translate="yes" xml:space="preserve">
          <source>And, many more minor bug fixes and performance enhancements....</source>
          <target state="translated">그리고 더 많은 사소한 버그 수정 및 성능 향상 ....</target>
        </trans-unit>
        <trans-unit id="a7e85233665c7566a60532bc230bb5ff92b64c2f" translate="yes" xml:space="preserve">
          <source>Anomaly tests are tests designed to verify the correct behavior of SQLite when something goes wrong. It is (relatively) easy to build an SQL database engine that behaves correctly on well-formed inputs on a fully functional computer. It is more difficult to build a system that responds sanely to invalid inputs and continues to function following system malfunctions. The anomaly tests are designed to verify the latter behavior.</source>
          <target state="translated">이상 테스트는 문제가 발생할 때 SQLite의 올바른 동작을 확인하기 위해 설계된 테스트입니다. 완전한 기능을 갖춘 컴퓨터에서 올바르게 구성된 입력에서 올바르게 작동하는 SQL 데이터베이스 엔진을 비교적 쉽게 구축 할 수 있습니다. 유효하지 않은 입력에 잘못 응답하고 시스템 오작동 후에도 계속 작동하는 시스템을 구축하기가 더 어렵습니다. 이상 테스트는 후자의 동작을 확인하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="6f7ee88b419e1339ccb20dd6c8b4d7e9833eca0b" translate="yes" xml:space="preserve">
          <source>Another (safer) approach to creating an imposter table is to add an entry for the imposter table to SQLite's internal symbol table without updating the &quot;sqlite_master&quot; table on disk. That way, the imposter table exists in only a single database connection and is automatically removed whenever the schema is reloaded.</source>
          <target state="translated">임 포스터 테이블을 생성하는 또 다른 (유의 한) 접근 방식은 디스크에서 &quot;sqlite_master&quot;테이블을 업데이트하지 않고 임 포스터 테이블에 대한 항목을 SQLite의 내부 심볼 테이블에 추가하는 것입니다. 이런 식으로 임 포스터 테이블은 단일 데이터베이스 연결에만 존재하며 스키마를 다시로드 할 때마다 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0a256db65f829282a102ced1041e5c60bd3b39bb" translate="yes" xml:space="preserve">
          <source>Another approach is to initially disable the lookaside memory allocator:</source>
          <target state="translated">또 다른 방법은 처음에 lookaside 메모리 할당자를 비활성화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f9265574f7b534649a1277b85f4934a02129bee" translate="yes" xml:space="preserve">
          <source>Another example is a virtual table that implements a full-text index. The xCreate method must create and initialize data structures to hold the dictionary and posting lists for that index. The xConnect method, on the other hand, only has to locate and use an existing dictionary and posting lists that were created by a prior xCreate call.</source>
          <target state="translated">또 다른 예는 전체 텍스트 인덱스를 구현하는 가상 테이블입니다. xCreate 메소드는 해당 색인에 대한 사전 및 게시 목록을 보유 할 데이터 구조를 작성하고 초기화해야합니다. 반면에 xConnect 메소드는 이전 xCreate 호출로 작성된 기존 사전 및 게시 목록 만 찾아서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="303e110b30c7b4642bb575628bce75a8b23bc25d" translate="yes" xml:space="preserve">
          <source>Another example of corruption caused by using a closed file descriptor was &lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;reported by facebook engineers&lt;/a&gt; in a blog post on 2014-08-12.</source>
          <target state="translated">닫힌 파일 디스크립터를 사용하여 발생한 또 다른 손상 예는 2014-08-12의 블로그 게시물에서 &lt;a href=&quot;https://code.facebook.com/posts/313033472212144/debugging-file-corruption-on-ios/&quot;&gt;페이스 북 엔지니어&lt;/a&gt; 에 의해보고되었습니다 .</target>
        </trans-unit>
        <trans-unit id="505afcae9498bd12848d3ae36d382e63fe35606f" translate="yes" xml:space="preserve">
          <source>Another example of this error was reported against &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; on 2019-07-11. A file descriptor would be opened for debugging output, but then closed and reopened by SQLite. But the debugging logic continued to write into the original file descriptor. See the &lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;forum discussion&lt;/a&gt; for the bug report and a link to the fix.</source>
          <target state="translated">이 오류의 다른 예는 2019-07-11의 &lt;a href=&quot;https://fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; 에 대해보고 되었습니다. 출력 설명을 위해 파일 디스크립터가 열리지 만 SQLite에 의해 닫히고 다시 열립니다. 그러나 디버깅 로직은 원래 파일 디스크립터에 계속 기록했습니다. 버그 보고서 및 수정 사항에 대한 링크 는 &lt;a href=&quot;https://fossil-scm.org/forum/forumpost/c51b9a1169&quot;&gt;포럼 토론&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8183751698c287cb27407f9ba084d293db7c55bd" translate="yes" xml:space="preserve">
          <source>Another example: X starts a read transaction using &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; and &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt;, then Y makes a changes to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. Then X tries to make a change to the database using &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;. The attempt by X to escalate its transaction from a read transaction to a write transaction fails with an &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;SQLITE_BUSY_SNAPSHOT&lt;/a&gt; error because the snapshot of the database being viewed by X is no longer the latest version of the database. If X were allowed to write, it would fork the history of the database file, which is something SQLite does not support. In order for X to write to the database, it must first release its snapshot (using &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; for example) then start a new transaction with a subsequent &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt;.</source>
          <target state="translated">다른 예 : X는 &lt;a href=&quot;lang_transaction&quot;&gt;BEGIN&lt;/a&gt; 및 &lt;a href=&quot;lang_select&quot;&gt;SELECT를&lt;/a&gt; 사용하여 읽기 트랜잭션을 시작한 다음 Y는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE를&lt;/a&gt; 사용하여 데이터베이스를 변경합니다 . 그런 다음 X는 &lt;a href=&quot;lang_update&quot;&gt;UPDATE를&lt;/a&gt; 사용하여 데이터베이스를 변경하려고합니다 . X &lt;a href=&quot;rescode#busy_snapshot&quot;&gt;가보고&lt;/a&gt; 있는 데이터베이스의 스냅 샷이 더 이상 최신 버전의 데이터베이스가 아니기 때문에 X가 트랜잭션을 읽기 트랜잭션에서 쓰기 트랜잭션으로 에스컬레이션하려는 시도는 SQLITE_BUSY_SNAPSHOT 오류 와 함께 실패 합니다. X가 쓰기가 허용되면 데이터베이스 파일의 히스토리를 포크합니다. 이는 SQLite가 지원하지 않는 것입니다. X가 데이터베이스에 쓰려면 먼저 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; 을 사용하여 스냅 샷을 해제 한 후 후속 트랜잭션으로 새 트랜잭션을 시작해야합니다.&lt;a href=&quot;lang_transaction&quot;&gt;시작&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a1c30e5a209f39b6a21d890471cf09df8606ebc" translate="yes" xml:space="preserve">
          <source>Another flush must occur to make sure that all the database changes are written into nonvolatile storage. This is a critical step to ensure that the database will survive a power loss without damage. However, because of the inherent slowness of writing to disk or flash memory, this step together with the rollback journal file flush in section 3.7 above takes up most of the time required to complete a transaction commit in SQLite.</source>
          <target state="translated">모든 데이터베이스 변경 사항이 비 휘발성 스토리지에 기록되도록하려면 다른 플러시가 발생해야합니다. 이는 데이터베이스가 손상없이 전원 손실을 견뎌야하는 중요한 단계입니다. 그러나 디스크 나 플래시 메모리에 쓰는 속도가 느리기 때문에, 위의 3.7 절에있는 롤백 저널 파일 플러시와 함께이 단계는 SQLite에서 트랜잭션 커밋을 완료하는 데 필요한 시간이 대부분 걸립니다.</target>
        </trans-unit>
        <trans-unit id="6c301063883293bdf468d0623b6a6911c6d2293c" translate="yes" xml:space="preserve">
          <source>Another limitation of the histogram data is that it only applies to the left-most column on an index. Consider this scenario:</source>
          <target state="translated">히스토그램 데이터의 또 다른 제한 사항은 인덱스의 가장 왼쪽 열에 만 적용된다는 것입니다. 이 시나리오를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="f21c319ab2ff434679be56b445eba4fa1aa43f87" translate="yes" xml:space="preserve">
          <source>Another macro used in conjunction with test coverage measurement is the &lt;code&gt;testcase()&lt;/code&gt; macro. The argument is a condition for which we want test cases that evaluate to both true and false. In non-coverage builds (that is to say, in release builds) the &lt;code&gt;testcase()&lt;/code&gt; macro is a no-op:</source>
          <target state="translated">테스트 범위 측정과 함께 사용되는 또 다른 매크로는 &lt;code&gt;testcase()&lt;/code&gt; 매크로입니다. 인수는 참과 거짓 모두로 평가되는 테스트 사례를 원하는 조건입니다. 비 커버리지 빌드 (즉, 릴리스 빌드)에서 &lt;code&gt;testcase()&lt;/code&gt; 매크로는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c493a994000d99e73cbc3f60d51dfc6589078021" translate="yes" xml:space="preserve">
          <source>Another manifestation of this problem is &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;database corruption caused by inconsistent use of 8+3 filenames&lt;/a&gt;.</source>
          <target state="translated">이 문제의 또 다른 징후는 &lt;a href=&quot;shortnames#db83corrupt&quot;&gt;8 + 3 파일 이름의 일관성없는 사용으로 인한 데이터베이스 손상&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="05b9d783d5cb2f59bb8b6ca5914b9575e677009e" translate="yes" xml:space="preserve">
          <source>Another optimization introduced in SQLite version 3.5.0 makes use of &quot;safe append&quot; behavior of the underlying disk. Recall that SQLite assumes that when data is appended to a file (specifically to the rollback journal) that the size of the file is increased first and that the content is written second. So if power is lost after the file size is increased but before the content is written, the file is left containing invalid &quot;garbage&quot; data. The xDeviceCharacteristics method of the VFS might, however, indicate that the filesystem implements &quot;safe append&quot; semantics. This means that the content is written before the file size is increased so that it is impossible for garbage to be introduced into the rollback journal by a power loss or system crash.</source>
          <target state="translated">SQLite 버전 3.5.0에 도입 된 또 다른 최적화는 기본 디스크의 &quot;안전한 추가&quot;동작을 사용합니다. SQLite는 데이터가 파일에 추가 될 때 (특히 롤백 저널에) 파일의 크기가 먼저 증가하고 내용이 두 번째로 기록된다고 가정합니다. 따라서 파일 크기를 늘리고 내용을 쓰기 전에 전원이 꺼지면 파일에 잘못된 &quot;쓰레기&quot;데이터가 포함 된 채로 남아 있습니다. 그러나 VFS의 xDeviceCharacteristics 메소드는 파일 시스템이 &quot;안전한 추가&quot;시맨틱을 구현 함을 나타낼 수 있습니다. 즉, 파일 크기가 커지기 전에 내용이 기록되므로 전원 손실이나 시스템 충돌로 인해 가비지가 롤백 저널에 도입 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7dad2e6d1e9648b82626f473ea27ecce5bb27928" translate="yes" xml:space="preserve">
          <source>Another option is to run &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous=OFF&lt;/a&gt;. This command will cause SQLite to not wait on data to reach the disk surface, which will make write operations appear to be much faster. But if you lose power in the middle of a transaction, your database file might go corrupt.</source>
          <target state="translated">다른 옵션은 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous = OFF&lt;/a&gt; 를 실행하는 것 입니다. 이 명령은 SQLite가 데이터가 디스크 표면에 도달 할 때까지 기다리지 않게하므로 쓰기 작업이 훨씬 빠릅니다. 그러나 트랜잭션 도중에 전원이 끊기면 데이터베이스 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0728346ee0767219b30d3313656a41918770666a" translate="yes" xml:space="preserve">
          <source>Another useful output mode is &quot;insert&quot;. In insert mode, the output is formatted to look like SQL INSERT statements. Use insert mode to generate text that can later be used to input data into a different database.</source>
          <target state="translated">또 다른 유용한 출력 모드는 &quot;삽입&quot;입니다. 삽입 모드에서 출력은 SQL INSERT 문처럼 보이도록 형식화됩니다. 삽입 모드를 사용하여 나중에 다른 데이터베이스에 데이터를 입력하는 데 사용할 수있는 텍스트를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="603f11343da9306fc8345afa2052a80114bf6240" translate="yes" xml:space="preserve">
          <source>Another view of RELEASE is that it merges a named transaction into its parent transaction, so that the named transaction and its parent become the same transaction. After RELEASE, the named transaction and its parent will commit or rollback together, whatever their fate may be.</source>
          <target state="translated">RELEASE의 또 다른 관점은 명명 된 트랜잭션을 상위 트랜잭션으로 병합하여 명명 된 트랜잭션과 해당 상위가 동일한 트랜잭션이된다는 것입니다. RELEASE 후에는 명명 된 트랜잭션과 해당 부모가 운명에 관계없이 커밋 또는 롤백됩니다.</target>
        </trans-unit>
        <trans-unit id="e8c0bf8ab4584514edb8368d18ba85e753fa2a2d" translate="yes" xml:space="preserve">
          <source>Another way to get the row change counts is to use the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; or &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces. There is a subtle different, though. When an INSERT, UPDATE, or DELETE is run against a view using an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt;, the count_changes pragma reports the number of rows in the view that fired the trigger, whereas &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; do not.</source>
          <target state="translated">행 변경 수를 얻는 또 다른 방법은 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스를 사용하는 것입니다. 하지만 미묘한 차이가 있습니다. &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거를&lt;/a&gt; 사용하여 뷰에 대해 INSERT, UPDATE 또는 DELETE가 실행될 때 count_changes pragma는 트리거 를 시작한 뷰 의 행 수를보고하지만 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 는 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2d30986ae4eff5648d38ebb9d01b585109e2411f" translate="yes" xml:space="preserve">
          <source>Another way to think about the difference between rollback and write-ahead log is that in the rollback-journal approach, there are two primitive operations, reading and writing, whereas with a write-ahead log there are now three primitive operations: reading, writing, and checkpointing.</source>
          <target state="translated">롤백과 미리 쓰기 로그의 차이점에 대해 생각할 수있는 또 다른 방법은 롤백 저널 방식에서 읽기와 쓰기라는 두 가지 기본 작업이있는 반면 미리 쓰기 로그에는 읽기, 쓰기의 세 가지 기본 작업이 있다는 것입니다. 및 검사 점.</target>
        </trans-unit>
        <trans-unit id="76c08af7521af2a346bb889060bcedbdd23dc992" translate="yes" xml:space="preserve">
          <source>Anticipated Future Enhancements</source>
          <target state="translated">예상되는 미래 향상</target>
        </trans-unit>
        <trans-unit id="03cbea0705f9805750be00c459dd237de0396772" translate="yes" xml:space="preserve">
          <source>Any UTF-8 character or ISO8859 character can be used as part of an identifier.</source>
          <target state="translated">식별자의 일부로 UTF-8 문자 또는 ISO8859 문자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17ff5b973797aa52493296af8db3d0915fb38ed0" translate="yes" xml:space="preserve">
          <source>Any application can run an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; query to get output similar to the above. However, indentation to show the loop structure is not generated by the SQLite core. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains extra logic for indenting loops. Also, the &quot;comment&quot; column in the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; output is only provided if SQLite is compiled with the &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; options.</source>
          <target state="translated">모든 애플리케이션은 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 쿼리를 실행 하여 위와 유사한 출력을 얻을 수 있습니다. 그러나 루프 구조를 표시하기위한 들여 쓰기는 SQLite 코어에서 생성되지 않습니다. &lt;a href=&quot;cli&quot;&gt;명령 줄 셸은&lt;/a&gt; 루프를 들여 추가 로직이 포함되어 있습니다. 또한 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 출력 의 &quot;comment&quot;열은 SQLite가 &lt;a href=&quot;compile#enable_explain_comments&quot;&gt;-DSQLITE_ENABLE_EXPLAIN_COMMENTS&lt;/a&gt; 옵션으로 컴파일 된 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="5a8e347554cfc99745cad972098b020b8602be14" translate="yes" xml:space="preserve">
          <source>Any application state that can be recorded in a pile-of-files can also be recorded in an SQLite database with a simple key/value schema like this:</source>
          <target state="translated">파일 더미에 기록 될 수있는 모든 애플리케이션 상태는 다음과 같은 간단한 키 / 값 스키마를 사용하여 SQLite 데이터베이스에 기록 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1ed6ff66cc7fc9ffd4cafbde2a3c28f229641fd" translate="yes" xml:space="preserve">
          <source>Any arguments following &quot;unicode61&quot; in the token specification are treated as a list of alternating option names and values. Unicode61 supports the following options:</source>
          <target state="translated">토큰 스펙에서 &quot;unicode61&quot;뒤에 오는 모든 인수는 대체 옵션 이름 및 값 목록으로 처리됩니다. Unicode61은 다음 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="81df847e2da7c111d58995774268025f599b0ab5" translate="yes" xml:space="preserve">
          <source>Any column in an SQLite version 3 database, except an &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; column, may be used to store a value of any storage class.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 열을 제외한 SQLite 버전 3 데이터베이스의 모든 열 은 모든 스토리지 클래스의 값을 저장하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d12d25e97784fac279be1123d4fbe17792ad0403" translate="yes" xml:space="preserve">
          <source>Any custom collation sequences used by indexes within the database being vacuumed are registered with both of the database handles returned by the sqlite3rbu_db() function.</source>
          <target state="translated">진공 청소기로 청소할 데이터베이스 내 인덱스에 사용 된 사용자 지정 데이터 정렬 시퀀스는 sqlite3rbu_db () 함수가 반환 한 두 데이터베이스 핸들 모두에 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="151750db2f16a0f1a6b9b810158ada7a043bfbe4" translate="yes" xml:space="preserve">
          <source>Any database clients wishing to write to the database file while a backup is being created must wait until the shared lock is relinquished.</source>
          <target state="translated">백업이 작성되는 동안 데이터베이스 파일에 쓰려는 데이터베이스 클라이언트는 공유 잠금이 해제 될 때까지 기다려야합니다.</target>
        </trans-unit>
        <trans-unit id="3870d6d9202c275acd1d8b0e06d905fc8afb745c" translate="yes" xml:space="preserve">
          <source>Any database name qualifier that occurs prior to the name of the object being created is removed.</source>
          <target state="translated">작성중인 오브젝트 이름 이전에 발생하는 모든 데이터베이스 이름 규정자가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="4255994cd14e9b872cd99b88c74cbf406ff9482f" translate="yes" xml:space="preserve">
          <source>Any index that includes the WHERE clause at the end is considered to be a partial index. Indexes that omit the WHERE clause (or indexes that are created by UNIQUE or PRIMARY KEY constraints inside of CREATE TABLE statements) are ordinary full indexes.</source>
          <target state="translated">끝에 WHERE 절을 포함하는 인덱스는 부분 인덱스로 간주됩니다. WHERE 절을 생략하는 인덱스 (또는 CREATE TABLE 문 내에서 UNIQUE 또는 PRIMARY KEY 제약 조건에 의해 생성 된 인덱스)는 일반적인 전체 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="b43d049b602d1fd2bf9a7b5bea3350eedf1f0673" translate="yes" xml:space="preserve">
          <source>Any number of calls to add() and output() may be made between the calls to new() and delete(), and in any order.</source>
          <target state="translated">add () 및 output ()에 대한 호출은 new () 및 delete ()에 대한 호출간에 순서에 상관없이 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdc7645ee06bfe979513e08246b74910b770d144" translate="yes" xml:space="preserve">
          <source>Any of the row values in the previous example could be replace by a subquery that returns three columns and the same answer would result. For example:</source>
          <target state="translated">이전 예의 행 값은 세 개의 열을 반환하는 하위 쿼리로 대체 될 수 있으며 같은 결과가 나타납니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ffe3efbd83a6aa86da6ab4b6abaf0209d6a58e2" translate="yes" xml:space="preserve">
          <source>Any one of the above test cases would provide 100% statement coverage but all three are required for 100% branch coverage. Generally speaking, 100% branch coverage implies 100% statement coverage, but the converse is not true. To reemphasize, the &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; test harness for SQLite provides the stronger form of test coverage - 100% branch test coverage.</source>
          <target state="translated">위의 테스트 사례 중 하나는 100 % 진술 범위를 제공하지만 100 % 지점 범위에는 세 가지 모두가 필요합니다. 일반적으로 100 % 지점 범위는 100 % 진술 범위를 의미하지만 그 반대는 아닙니다. 다시 강조하기 위해 SQLite 용 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 테스트 하네스는 100 % 분기 테스트 범위 인 더 강력한 형태의 테스트 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="82138b97f6d9555464cfec51a14a23b82edbc037" translate="yes" xml:space="preserve">
          <source>Any operators applied to column names, including the no-op unary &quot;+&quot; operator, convert the column name into an expression which always has no affinity. Hence even if X and Y.Z are column names, the expressions +X and +Y.Z are not column names and have no affinity.</source>
          <target state="translated">no-op 단항 &quot;+&quot;연산자를 포함하여 열 이름에 적용된 모든 연산자는 열 이름을 항상 선호도가없는 식으로 변환합니다. 따라서 X와 YZ가 열 이름 인 경우에도 + X와 + YZ 표현식은 열 이름이 아니며 선호도가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7fd223421c2a13bbb89b12c2862d7c77ef4b363f" translate="yes" xml:space="preserve">
          <source>Any other value for the b-tree page type is an error.</source>
          <target state="translated">b- 트리 페이지 유형의 다른 값은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="784db6f9216a4d895c7e958df2f8f40ae24919c7" translate="yes" xml:space="preserve">
          <source>Any scalar expression may be used in the LIMIT clause, so long as it evaluates to an integer or a value that can be losslessly converted to an integer. If the expression evaluates to a NULL value or any other value that cannot be losslessly converted to an integer, an error is returned. If the LIMIT expression evaluates to a negative value, then there is no upper bound on the number of rows returned. Otherwise, the SELECT returns the first N rows of its result set only, where N is the value that the LIMIT expression evaluates to. Or, if the SELECT statement would return less than N rows without a LIMIT clause, then the entire result set is returned.</source>
          <target state="translated">정수 또는 무손실 정수로 변환 될 수있는 값으로 평가되는 한, LIMIT 절에서 스칼라 표현식을 사용할 수 있습니다. 표현식이 NULL 값 또는 손실없이 정수로 변환 될 수없는 다른 값으로 평가되면 오류가 리턴됩니다. LIMIT 표현식이 음수 값으로 평가되면 리턴 된 행 수에 상한이 없습니다. 그렇지 않으면 SELECT는 결과 집합의 첫 N 개 행만 반환합니다. 여기서 N은 LIMIT식이 평가하는 값입니다. 또는 SELECT 문이 LIMIT 절없이 N 개 미만의 행을 리턴하면 전체 결과 세트가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="680384b496ab63e99e152271be6ec34547a5e90a" translate="yes" xml:space="preserve">
          <source>Any time there is an error either compiling an SQL statement (using &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or its siblings) or running an SQL statement (using &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt;) that error is logged.</source>
          <target state="translated">&lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 그 형제를 사용하여 SQL 문을 컴파일 하거나 오류가 기록되는 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()을&lt;/a&gt; 사용하여 SQL 문을 실행하는 중 오류가 발생할 때마다.</target>
        </trans-unit>
        <trans-unit id="b0e18824fe4a70b0f37b9e0cb34aa95b757ca28e" translate="yes" xml:space="preserve">
          <source>Any valid query will work against an R*Tree index. But the R*Tree implementation is designed to make two kinds of queries especially efficient. First, queries against the primary key are efficient:</source>
          <target state="translated">유효한 쿼리는 R * Tree 인덱스에 대해 작동합니다. 그러나 R * Tree 구현은 두 가지 종류의 쿼리를 특히 효율적으로 만들기 위해 설계되었습니다. 먼저 기본 키에 대한 쿼리가 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="dafef79386ae39cfa702a14aae7666f057897932" translate="yes" xml:space="preserve">
          <source>Any value returned by the openclose function is ignored. If an invocation made before opening a database returns an error, then the database file is not opened and the error returned to the user. This is the only scenario in which swarmvtab will issue an &quot;open&quot; invocation without also eventually issuing a corresponding &quot;close&quot; call. If there are still databases open, &quot;close&quot; calls may be issued from within the eventual sqlite3_close() call on the applications database that deletes the temp schema in which the swarmvtab table resides.</source>
          <target state="translated">openclose 함수가 리턴 한 값은 무시됩니다. 데이터베이스를 열기 전에 호출 한 경우 오류가 발생하면 데이터베이스 파일이 열리지 않고 오류가 사용자에게 리턴됩니다. 이것은 swarmvtab이 결국 해당 &quot;close&quot;호출을 발행하지 않고 &quot;open&quot;호출을 실행하는 유일한 시나리오입니다. 여전히 열려있는 데이터베이스가있는 경우 swarmvtab 테이블이 상주하는 임시 스키마를 삭제하는 애플리케이션 데이터베이스의 최종 sqlite3_close () 호출 내에서 &quot;close&quot;호출이 발행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf9bbefc76982e17471539cdea1217f5e1e0119" translate="yes" xml:space="preserve">
          <source>Anywhere</source>
          <target state="translated">Anywhere</target>
        </trans-unit>
        <trans-unit id="e511dd65bb11704e83c08777789bf5ec195f3d28" translate="yes" xml:space="preserve">
          <source>Apart from the root node, the nodes that make up a single segment b-tree are always stored using a contiguous sequence of blockids. Furthermore, the nodes that make up a single level of the b-tree are themselves stored as a contiguous block, in b-tree order. The contiguous sequence of blockids used to store the b-tree leaves are allocated starting with the blockid value stored in the &quot;start_block&quot; column of the corresponding %_segdir row, and finishing at the blockid value stored in the &quot;leaves_end_block&quot; field of the same row. It is therefore possible to iterate through all the leaves of a segment b-tree, in key order, by traversing the %_segments table in blockid order from &quot;start_block&quot; to &quot;leaves_end_block&quot;.</source>
          <target state="translated">루트 노드 외에도 단일 세그먼트 b- 트리를 구성하는 노드는 항상 연속 된 일련의 blockid를 사용하여 저장됩니다. 또한, b- 트리의 단일 레벨을 구성하는 노드는 자체적으로 b- 트리 순서로 연속 블록으로 저장됩니다. b- 트리 잎을 저장하는 데 사용되는 연속 된 일련의 blockid는 해당 % _segdir 행의 &quot;start_block&quot;열에 저장된 blockid 값부터 시작하여 동일한 &quot;leaves_end_block&quot;필드에 저장된 blockid 값에서 끝나도록 할당됩니다. 열. 따라서 &quot;start_block&quot;에서 &quot;leaves_end_block&quot;까지 blockid 순서로 % _segments 테이블을 순회하여 세그먼트 b- 트리의 모든 리프를 키 순서로 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6f3127b3255a243139304b57a2de9b375a5b278" translate="yes" xml:space="preserve">
          <source>Appears in...</source>
          <target state="translated">다음에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="cddd694c6980e8f63fe16956f1fed6f2e36dd876" translate="yes" xml:space="preserve">
          <source>Appending a new</source>
          <target state="translated">새로운 추가</target>
        </trans-unit>
        <trans-unit id="939a673334c7c748561f23a3fd21e4918a1efbc3" translate="yes" xml:space="preserve">
          <source>Appending a new page to the database file.</source>
          <target state="translated">데이터베이스 파일에 새 페이지를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="dff26bc78571c36fbf9a79d63221a8d63c4781c9" translate="yes" xml:space="preserve">
          <source>Appendix A: Comparison with FTS3/4</source>
          <target state="translated">부록 A : FTS3 / 4와 비교</target>
        </trans-unit>
        <trans-unit id="2f62ea77455407c6d86c7651d5f030af0222ec84" translate="yes" xml:space="preserve">
          <source>Appendix A: Search Application Tips</source>
          <target state="translated">부록 A : 응용 프로그램 검색 팁</target>
        </trans-unit>
        <trans-unit id="f9f1d1188ea485eedb2325535cccc6c2b70da6fd" translate="yes" xml:space="preserve">
          <source>Appendix B: Shadow tables created by FTS5</source>
          <target state="translated">부록 B : FTS5에 의해 생성 된 새도우 테이블</target>
        </trans-unit>
        <trans-unit id="24139aab1ccfea9a0794fea103821cef5044dd2c" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시</target>
        </trans-unit>
        <trans-unit id="8c42705eec7c415a6997bd8c9d3dc65da77e4f55" translate="yes" xml:space="preserve">
          <source>Application Defined Page Cache.</source>
          <target state="translated">응용 프로그램 정의 페이지 캐시.</target>
        </trans-unit>
        <trans-unit id="557031cad0f1b2b54264afc9d96a7aba19827147" translate="yes" xml:space="preserve">
          <source>Application ID</source>
          <target state="translated">신청 ID</target>
        </trans-unit>
        <trans-unit id="871e1857983850d1454dd7c60ae50af733931a7a" translate="yes" xml:space="preserve">
          <source>Application Interface</source>
          <target state="translated">응용 프로그램 인터페이스</target>
        </trans-unit>
        <trans-unit id="a6c10e408404322943e578d89c2bff7889c626f3" translate="yes" xml:space="preserve">
          <source>Application Porting Guide</source>
          <target state="translated">응용 프로그램 포팅 안내서</target>
        </trans-unit>
        <trans-unit id="a768f98624703793f6acc4a427b7a53a61477bff" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; 파일 제어를 호출하여 SQLite가 TEMP 테이블 및 기타 내부 용도에 대한 임시 파일 이름을 생성하는 데 사용되는 동일한 알고리즘을 사용하여 임시 파일 이름을 생성하도록 할 수 있습니다. 인수는 char **이어야하며 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 쓰여진 파일 이름으로 채워집니다 . 호출자는 메모리 누수를 피하기 위해 결과에서 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3350dbe5c54d126511b6c09afcd8f51bea6a199c" translate="yes" xml:space="preserve">
          <source>Application can invoke the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; file-control to have SQLite generate a temporary filename using the same algorithm that is followed to generate temporary filenames for TEMP tables and other internal uses. The argument should be a char** which will be filled with the filename written into memory obtained from &lt;a href=&quot;free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. The caller should invoke &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; on the result to avoid a memory leak.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntltempfilename&quot; id=&quot;sqlitefcntltempfilename&quot;&gt;SQLITE_FCNTL_TEMPFILENAME&lt;/a&gt; 파일 제어를 호출하여 SQLite가 TEMP 테이블 및 기타 내부 용도에 대한 임시 파일 이름을 생성하는 데 사용되는 동일한 알고리즘을 사용하여 임시 파일 이름을 생성하도록 할 수 있습니다. 인수는 char **이어야하며 &lt;a href=&quot;free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 에서 얻은 메모리에 쓰여진 파일 이름으로 채워집니다 . 호출자는 메모리 누수를 피하기 위해 결과에서 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()&lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f4e99a2282eb2e1c855827ddf5f64dd418ab8c7" translate="yes" xml:space="preserve">
          <source>Application code is allowed to modify the sqlite_sequence table, to add new rows, to delete rows, or to modify existing rows. However, application code cannot create the sqlite_sequence table if it does not already exist. Application code can delete all entries from the sqlite_sequence table, but application code cannot drop the sqlite_sequence table.</source>
          <target state="translated">응용 프로그램 코드는 sqlite_sequence 테이블을 수정하거나, 새 행을 추가하거나, 행을 삭제하거나, 기존 행을 수정할 수 있습니다. 그러나 sqlite_sequence 테이블이 없으면 응용 프로그램 코드에서 sqlite_sequence 테이블을 작성할 수 없습니다. 응용 프로그램 코드는 sqlite_sequence 테이블에서 모든 항목을 삭제할 수 있지만 응용 프로그램 코드는 sqlite_sequence 테이블을 삭제할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="263c551ee583a68f5c9b570a6b7af2da5afc58f1" translate="yes" xml:space="preserve">
          <source>Application-defined collating functions</source>
          <target state="translated">응용 프로그램 정의 조합 기능</target>
        </trans-unit>
        <trans-unit id="25d0ad5ca7051d2b57b94a5f5601d3d125282b43" translate="yes" xml:space="preserve">
          <source>Applications are not required to use either of these standard memory allocators. If SQLite is compiled with &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; then no implementation for the &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt; functions is provided. Instead, the application that links against SQLite must provide its own implementation of these functions. The application provided memory allocator is not required to use the malloc()/free() implementation in the standard C library. An embedded application might provide an alternative memory allocator that uses memory for a fixed memory pool set aside for the exclusive use of SQLite, for example.</source>
          <target state="translated">응용 프로그램은 이러한 표준 메모리 할당 자 중 하나를 사용할 필요가 없습니다. SQLite가 &lt;a href=&quot;compile#omitfeatures&quot;&gt;SQLITE_OMIT_MEMORY_ALLOCATION&lt;/a&gt; 으로 컴파일 되면 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 함수에 대한 구현이 제공되지 않습니다. 대신 SQLite에 연결되는 응용 프로그램은 이러한 기능을 자체적으로 구현해야합니다. 응용 프로그램 제공 메모리 할당자는 표준 C 라이브러리에서 malloc () / free () 구현을 사용할 필요가 없습니다. 임베디드 응용 프로그램은 예를 들어 SQLite 독점 사용을 위해 고정 메모리 풀 세트에 메모리를 사용하는 대체 메모리 할당자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38446a7215f8f42cf45502d1b63067076b840788" translate="yes" xml:space="preserve">
          <source>Applications are strongly discouraged from using this global variable. It is required to set a temporary folder on Windows Runtime (WinRT). But for all other platforms, it is highly recommended that applications neither read nor write this variable. This global variable is a relic that exists for backwards compatibility of legacy applications and should be avoided in new projects.</source>
          <target state="translated">응용 프로그램은이 전역 변수를 사용하지 않는 것이 좋습니다. WinRT (Windows 런타임)에서 임시 폴더를 설정해야합니다. 그러나 다른 모든 플랫폼의 경우 응용 프로그램에서이 변수를 읽거나 쓰지 않는 것이 좋습니다. 이 전역 변수는 레거시 응용 프로그램의 이전 버전과의 호환성을 위해 존재하는 유물이므로 새 프로젝트에서는 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="180a26d65b478f96354579f1533f98cb44ab9c69" translate="yes" xml:space="preserve">
          <source>Applications can activate foreign key enforcement at run-time using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; statement. Or, foreign key enforcement can be activated at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt; compile-time option.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; 문을 사용하여 런타임에 외래 키 적용을 활성화 할 수 있습니다 . 또는 &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1&lt;/a&gt; 컴파일 타임 옵션을 사용하여 컴파일 타임에 외래 키 시행을 활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa39f6b2c61405c17ac04b8c804d6f91045049fb" translate="yes" xml:space="preserve">
          <source>Applications can call sqlite3_vfs_register() at any time, though of course a VFS needs to be registered before it can be used. The first argument is a pointer to a customized VFS object that the application has prepared. The second argument is true to make the new VFS the default VFS so that it will be used by the legacy &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt; APIs. If the new VFS is not the default, then you will probably have to use the new &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; API to use it. Note, however, that if a new VFS is the only VFS known to SQLite (if SQLite was compiled without its usual default VFS or if the precompiled default VFS was removed using &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister()&lt;/a&gt;) then the new VFS automatically becomes the default VFS regardless of the makeDflt argument to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;.</source>
          <target state="translated">애플리케이션은 언제든지 sqlite3_vfs_register ()를 호출 할 수 있지만 VFS를 사용하려면 먼저 등록해야합니다. 첫 번째 인수는 애플리케이션이 준비한 사용자 정의 된 VFS 오브젝트에 대한 포인터입니다. 두 번째 인수는 레거시 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; API에서 사용되도록 새 VFS를 기본 VFS로 만드는 데 적용됩니다 . 새 VFS가 기본값이 아닌 경우 새 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; API를 사용해야합니다. 그러나 새 VFS가 SQLite에 알려진 유일한 VFS 인 경우 (SQLite가 일반적인 기본 VFS없이 컴파일되었거나 사전 컴파일 된 기본 VFS가 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_unregister ()를&lt;/a&gt; 사용하여 제거 된 경우 )) 그러면 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 의 makeDflt 인수에 관계없이 새 VFS가 자동으로 기본 VFS가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2aaaa457f07aa308713a42a915ad2852c0b39a0" translate="yes" xml:space="preserve">
          <source>Applications can chose to store dates and times in any of these formats and freely convert between formats using the built-in &lt;a href=&quot;lang_datefunc&quot;&gt;date and time functions&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 날짜 및 시간을 이러한 형식으로 저장하도록 선택할 수 있으며 내장 &lt;a href=&quot;lang_datefunc&quot;&gt;날짜 및 시간 기능을&lt;/a&gt; 사용하여 형식간에 자유롭게 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec145e5678c1f6c0fcbe32fd22a6afa6e15334a5" translate="yes" xml:space="preserve">
          <source>Applications can easily read or write SQLite Archives by linking against SQLite and including the &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext/misc/sqlar.c&lt;/a&gt; extension to handle the compression and decompression. The sqlar.c extension creates two new SQL functions.</source>
          <target state="translated">애플리케이션은 SQLite에 연결하고 &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;ext / misc / sqlar.c&lt;/a&gt; 확장을 포함하여 압축 및 압축 해제를 처리하여 SQLite 아카이브를 쉽게 읽거나 쓸 수 있습니다 . sqlar.c 확장은 두 개의 새로운 SQL 함수를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="10c37b1dc4c015883a2357b3c09de919e0c79e2e" translate="yes" xml:space="preserve">
          <source>Applications can leverage the &lt;a href=&quot;fts3&quot;&gt;full-text search&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; indexes and use triggers to implement an &lt;a href=&quot;undoredo&quot;&gt;automated undo/redo stack&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;fts3&quot;&gt;전체 텍스트 검색&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; 인덱스를 활용하고 트리거를 사용하여 &lt;a href=&quot;undoredo&quot;&gt;자동화 된 실행 취소 / 다시 실행 스택&lt;/a&gt; 을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42c37342832f86fc16406f3d6f977afed5099fdf" translate="yes" xml:space="preserve">
          <source>Applications can use the &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log(E,F,..)&lt;/a&gt; API to send new messages to the log, if desired, but this is discouraged. The &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log()&lt;/a&gt; interface is intended for use by extensions only, not by applications.</source>
          <target state="translated">응용 프로그램은 &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log (E, F, ..)&lt;/a&gt; API를 사용하여 원하는 경우 새 메시지를 로그에 보낼 수 있지만 권장하지는 않습니다. &lt;a href=&quot;c3ref/log&quot;&gt;sqlite3_log ()&lt;/a&gt; 인터페이스 만이 아닌 응용 프로그램 확장으로 사용하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b11300864c54770f7c5f526b6116f644fe6e616" translate="yes" xml:space="preserve">
          <source>Applications need to receive a pointer to the &quot;fts5_api&quot; object in order to add extensions, such as custom tokenizers, to the &lt;a href=&quot;fts5&quot;&gt;FTS5&lt;/a&gt; extension.</source>
          <target state="translated">FTS5 확장에 사용자 정의 토크 나이저와 같은 확장을 추가하려면 응용 프로그램에서 &quot;fts5_api&quot;개체에 대한 포인터를 &lt;a href=&quot;fts5&quot;&gt;받아야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c62d5c6028bfae4c8b01799ff1a016b8e43ca22c" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;#sqlite3_finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;#sqlite3_stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="translated">응용 프로그램은해야 &lt;a href=&quot;#sqlite3_finalize&quot;&gt;완료&lt;/a&gt; 모든 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 문&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob_close&quot;&gt;가까운&lt;/a&gt; 모든 &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 하고, &lt;a href=&quot;#sqlite3backupfinish&quot;&gt;마무리&lt;/a&gt; 모두 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup이&lt;/a&gt; 과 관련된 객체 &lt;a href=&quot;#sqlite3&quot;&gt;sqlite3를&lt;/a&gt; 이전 개체를 닫기 시도에 객체입니다. sqlite3_close_v2 ()가 여전히 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 / 또는 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트를 가진 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 호출되면 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 하고 모든 &lt;a href=&quot;#sqlite3_stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;#sqlite3_blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 처리 할 때까지 자원 할당이 지연됩니다.&lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="370f3cced4e036aaca81af4fa9e5c1fe46910ebe" translate="yes" xml:space="preserve">
          <source>Applications should &lt;a href=&quot;finalize&quot;&gt;finalize&lt;/a&gt; all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob_close&quot;&gt;close&lt;/a&gt; all &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;finish&lt;/a&gt; all &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects associated with the &lt;a href=&quot;sqlite3&quot;&gt;sqlite3&lt;/a&gt; object prior to attempting to close the object. If sqlite3_close_v2() is called on a &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; that still has outstanding &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and/or &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects then it returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; and the deallocation of resources is deferred until all &lt;a href=&quot;stmt&quot;&gt;prepared statements&lt;/a&gt;, &lt;a href=&quot;blob&quot;&gt;BLOB handles&lt;/a&gt;, and &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; objects are also destroyed.</source>
          <target state="translated">응용 프로그램은해야 &lt;a href=&quot;finalize&quot;&gt;완료&lt;/a&gt; 모든 &lt;a href=&quot;stmt&quot;&gt;준비된 문&lt;/a&gt; , &lt;a href=&quot;blob_close&quot;&gt;가까운&lt;/a&gt; 모든 &lt;a href=&quot;blob&quot;&gt;BLOB 핸들을&lt;/a&gt; 하고, &lt;a href=&quot;backup_finish#sqlite3backupfinish&quot;&gt;마무리&lt;/a&gt; 모두 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup이&lt;/a&gt; 과 관련된 객체 &lt;a href=&quot;sqlite3&quot;&gt;sqlite3를&lt;/a&gt; 이전 개체를 닫기 시도에 객체입니다. sqlite3_close_v2 ()가 여전히 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 / 또는 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 오브젝트를 가진 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 에서 호출되면 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴 하고 모든 &lt;a href=&quot;stmt&quot;&gt;준비된 명령문&lt;/a&gt; , &lt;a href=&quot;blob&quot;&gt;BLOB 처리&lt;/a&gt; 및 처리 할 때까지 자원 할당이 지연됩니다.&lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체도 파괴됩니다.</target>
        </trans-unit>
        <trans-unit id="11da7d835aa708827d0f44dfb12fe45f22493e9a" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted SQL inputs should take the following precautions:</source>
          <target state="translated">신뢰할 수없는 SQL 입력을 허용하는 응용 프로그램은 다음 예방 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="f32733159fe9563d84f7da23f8a179d0a799e2a5" translate="yes" xml:space="preserve">
          <source>Applications that accept untrusted database files should do the following:</source>
          <target state="translated">신뢰할 수없는 데이터베이스 파일을 허용하는 응용 프로그램은 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="e886a51fcb81bff62e2c48396e856865668d639c" translate="yes" xml:space="preserve">
          <source>Applications that already use SQLite for other purposes can easily add support for SQLite Archives using a small extension (&lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt;) to handle the compression and decompression of content. Even this tiny extension can be omitted if the files in the archive are uncompressed. In contrast, supporting ZIP Archives and/or Tarballs requires either separate libraries or lots of extra custom code, or sometimes both.</source>
          <target state="translated">다른 목적으로 이미 SQLite를 사용하는 애플리케이션 은 컨텐츠의 압축 및 압축 해제를 처리하기 위해 작은 확장 ( &lt;a href=&quot;https://sqlite.org/src/file/ext/misc/sqlar.c&quot;&gt;https://sqlite.org/src/file/ext/misc/sqlar.c&lt;/a&gt; )을 사용하여 SQLite 아카이브에 대한 지원을 쉽게 추가 할 수 있습니다 . 아카이브의 파일이 압축되지 않은 경우이 작은 확장명도 생략 할 수 있습니다. 반대로 ZIP 아카이브 및 / 또는 Tarball을 지원하려면 별도의 라이브러리 또는 많은 추가 사용자 정의 코드가 필요하거나 때로는 둘 다 필요합니다.</target>
        </trans-unit>
        <trans-unit id="77baa4279beeeafb725407d72ddb6fda70fe7b8a" translate="yes" xml:space="preserve">
          <source>Applications that desire more control can run &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize(0x03)&lt;/a&gt; to obtain a list of ANALYZE commands that SQLite thinks are appropriate to run, but without actually running those commands. If the returned set is non-empty, the application can then make a decision about whether or not to run the suggested ANALYZE commands, perhaps after prompting the user for guidance.</source>
          <target state="translated">더 많은 제어를 원하는 응용 프로그램은 &lt;a href=&quot;pragma#pragma_optimize&quot;&gt;PRAGMA optimize (0x03)&lt;/a&gt; 를 실행하여 SQLite가 실행하기에 적합하다고 생각하는 ANALYZE 명령 목록을 얻을 수 있지만 실제로는 해당 명령을 실행하지는 않습니다. 리턴 된 세트가 비어 있지 않으면 애플리케이션은 사용자에게 안내를 요청한 후 제안 된 ANALYZE 명령을 실행할지 여부를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bb5bae5e54c915160fb76cb9810521459a0328b" translate="yes" xml:space="preserve">
          <source>Applications that implement their own memory allocator must provide implementation for the usual three allocation functions &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. And they must also implement a fourth function:</source>
          <target state="translated">자체 메모리 할당자를 구현하는 응용 프로그램은 일반적인 세 ​​가지 할당 함수 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()에&lt;/a&gt; 대한 구현을 제공해야합니다 . 또한 네 번째 기능도 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="3276d7f69778b6a6958211df873305e75fc12066" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="translated">신뢰할 수없는 소스에서 SQL을 처리해야하는 응용 프로그램은 &lt;a href=&quot;#sqlite3_limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 리소스 제한을 낮추고 권한 부여자를 사용하는 것 외에도 &lt;a href=&quot;pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 를 사용하여 데이터베이스 크기를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="354d6571e51ed32448c014f215aad54793f93f19" translate="yes" xml:space="preserve">
          <source>Applications that need to process SQL from untrusted sources might also consider lowering resource limits using &lt;a href=&quot;limit&quot;&gt;sqlite3_limit()&lt;/a&gt; and limiting database size using the &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count&lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; in addition to using an authorizer.</source>
          <target state="translated">신뢰할 수없는 소스에서 SQL을 처리해야하는 응용 프로그램은 &lt;a href=&quot;limit&quot;&gt;sqlite3_limit ()를&lt;/a&gt; 사용하여 리소스 제한을 낮추고 권한 부여자를 사용하는 것 외에도 &lt;a href=&quot;../pragma#pragma_max_page_count&quot;&gt;max_page_count &lt;/a&gt;&lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 를 사용하여 데이터베이스 크기를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="56219a273baff8fb63d4f640239c5a3823587f98" translate="yes" xml:space="preserve">
          <source>Applications using the split amalgamation simply compile against &quot;sqlite3-all.c&quot; instead of &quot;sqlite3.c&quot;. The two files work exactly the same. But with &quot;sqlite3-all.c&quot;, no single source file contains more than 32,767 lines of code, and so it is more convenient to use some debuggers. The downside of the split amalgamation is that it consists of 6 C source code files instead of just 1.</source>
          <target state="translated">split amalgamation을 사용하는 응용 프로그램은 단순히 &quot;sqlite3.c&quot;대신 &quot;sqlite3-all.c&quot;에 대해 컴파일됩니다. 두 파일은 정확히 동일하게 작동합니다. 그러나 &quot;sqlite3-all.c&quot;를 사용하면 단일 소스 파일에 32,767 줄 이상의 코드가 포함되지 않으므로 일부 디버거를 사용하는 것이 더 편리합니다. 분할 합병의 단점은 단 1 개가 아닌 6 개의 C 소스 코드 파일로 구성되어 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="514f9d7fb93d92d6765510a1359338148e757312" translate="yes" xml:space="preserve">
          <source>Apply A Changeset To A Database</source>
          <target state="translated">데이터베이스에 변경 세트 적용</target>
        </trans-unit>
        <trans-unit id="0f306fb05632f0f4db7dd5e5ff03c213825dd25d" translate="yes" xml:space="preserve">
          <source>Apply a changeset or patchset to a database. These functions attempt to update the &quot;main&quot; database attached to handle db with the changes found in the changeset passed via the second and third arguments.</source>
          <target state="translated">데이터베이스에 변경 세트 또는 패치 세트를 적용하십시오. 이 함수는 두 번째 및 세 번째 인수를 통해 전달 된 변경 세트에서 발견 된 변경 사항으로 db를 처리하기 위해 첨부 된 &quot;기본&quot;데이터베이스를 업데이트하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="a7bf4a5600a606d3a4f075dab8912ba1aa9d1deb" translate="yes" xml:space="preserve">
          <source>Apply affinities to a range of P2 registers starting with P1.</source>
          <target state="translated">P1로 시작하는 P2 레지스터 범위에 친 화성을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="d9053b57f5f861486073c17aece29454b87cf37a" translate="yes" xml:space="preserve">
          <source>Applying a changeset to a database is simpler than capturing a changeset. Usually, a single call to &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply()&lt;/a&gt;, as depicted in the example code below, suffices.</source>
          <target state="translated">데이터베이스에 변경 세트를 적용하는 것이 변경 세트를 캡처하는 것보다 간단합니다. 일반적으로 아래 예제 코드와 같이 &lt;a href=&quot;session/sqlite3changeset_apply&quot;&gt;sqlite3changeset_apply ()에&lt;/a&gt; 대한 단일 호출로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9d64c94c92e46add367d8f8d91e1e8dd6a71ae2e" translate="yes" xml:space="preserve">
          <source>Appropriate Uses For SQLite</source>
          <target state="translated">SQLite의 적절한 사용</target>
        </trans-unit>
        <trans-unit id="7db317caf72bb7c9dbfdfdc313cade8bdb182e98" translate="yes" xml:space="preserve">
          <source>Approx. Date</source>
          <target state="translated">약. 데이트</target>
        </trans-unit>
        <trans-unit id="63a877b9c97333a0f773b586cf9b6ea0abe4710d" translate="yes" xml:space="preserve">
          <source>Approximately 25% better performance from the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 에서 약 25 % 향상된 성능 .</target>
        </trans-unit>
        <trans-unit id="1acd094f8de42870eb88cfeea3ebc197767f3b95" translate="yes" xml:space="preserve">
          <source>Architecture of SQLite</source>
          <target state="translated">SQLite의 아키텍처</target>
        </trans-unit>
        <trans-unit id="f076fb02f05c0b3b0347a8ec181af332464b574d" translate="yes" xml:space="preserve">
          <source>Are there any known size limits to SQLite databases?</source>
          <target state="translated">SQLite 데이터베이스에 알려진 크기 제한이 있습니까?</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="c4d2bb6ff9ec16533c1c379a0a3c41d194bcc183" translate="yes" xml:space="preserve">
          <source>Argument T is the name of the database file to vacuum. Argument S is the name of a database in which the RBU module will save its state if the vacuum operation is suspended.</source>
          <target state="translated">인수 T는 진공화할 데이터베이스 파일의 이름입니다. 인수 S는 진공 작업이 일시 중단 된 경우 RBU 모듈이 상태를 저장하는 데이터베이스의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0059fb3429a6e57de6b5c01cc5ac92570ab99c32" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">인수 iVal은 0보다 크거나 같아야하며 현재 변경의 영향을받는 테이블의 열 수보다 작아야합니다. 그렇지 않으면 &lt;a href=&quot;../rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="12689143ab00ad889ba38fb7f63c86273b0da663" translate="yes" xml:space="preserve">
          <source>Argument iVal must be greater than or equal to 0, and less than the number of columns in the table affected by the current change. Otherwise, &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; is returned and *ppValue is set to NULL.</source>
          <target state="translated">인수 iVal은 0보다 크거나 같아야하며 현재 변경의 영향을받는 테이블의 열 수보다 작아야합니다. 그렇지 않으면 &lt;a href=&quot;rescode#range&quot;&gt;SQLITE_RANGE&lt;/a&gt; 가 리턴되고 * ppValue가 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1502f4d9bcf958ec2d3f9df8d5434c6f3fb95622" translate="yes" xml:space="preserve">
          <source>Argument pIn must point to a buffer containing a changeset nIn bytes in size. This function allocates and populates a buffer with a copy of the changeset rebased rebased according to the configuration of the rebaser object passed as the first argument. If successful, (*ppOut) is set to point to the new buffer containing the rebased changeset and (*pnOut) to its size in bytes and SQLITE_OK returned. It is the responsibility of the caller to eventually free the new buffer using sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut) are set to zero and an SQLite error code returned.</source>
          <target state="translated">인수 pIn은 크기의 변경 세트 nIn 바이트를 포함하는 버퍼를 가리켜 야합니다. 이 함수는 첫 번째 인수로 전달 된 rebaser 객체의 구성에 따라 rebased rebased rebased의 사본으로 버퍼를 할당하고 채 웁니다. 성공하면 (* ppOut)은 재 기반 변경 세트를 포함하는 새 버퍼를 가리 키도록 설정되고 (* pnOut)은 바이트 단위의 크기를 나타내며 SQLITE_OK가 리턴됩니다. sqlite3_free ()를 사용하여 새 버퍼를 결국 해제하는 것은 호출자의 책임입니다. 그렇지 않으면 오류가 발생하면 (* ppOut) 및 (* pnOut)이 0으로 설정되고 SQLite 오류 코드가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="3273cfe93e49705347b0b90c1dbaf9e32a834424" translate="yes" xml:space="preserve">
          <source>Argument zFromDb must be the name of a database (&quot;main&quot;, &quot;temp&quot; etc.) attached to the same database handle as the session object that contains a table compatible with the table attached to the session by this function. A table is considered compatible if it:</source>
          <target state="translated">인수 zFromDb는이 함수에 의해 세션에 첨부 된 테이블과 호환되는 테이블을 포함하는 세션 오브젝트와 동일한 데이터베이스 핸들에 첨부 된 데이터베이스 이름 ( &quot;main&quot;, &quot;temp&quot;등)이어야합니다. 다음과 같은 경우 테이블이 호환 가능한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c2dd08aa3192624f9fd5e4d0f584709c36b430c5" translate="yes" xml:space="preserve">
          <source>Arguments on the virtual table name are matched to &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden columns&lt;/a&gt; in order. The number of arguments can be less than the number of hidden columns, in which case the latter hidden columns are unconstrained. However, an error results if there are more arguments than there are hidden columns in the virtual table.</source>
          <target state="translated">가상 테이블 이름의 인수는 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열과&lt;/a&gt; 순서대로 일치합니다 . 인수의 수는 숨겨진 열의 수보다 적을 수 있으며,이 경우 후자의 숨겨진 열은 제한되지 않습니다. 그러나 가상 테이블에 숨겨진 열이있는 것보다 많은 인수가 있으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="90539d8182e17636548ae12105ee212ec9b16743" translate="yes" xml:space="preserve">
          <source>As SQLite developers edit the SQLite source code, they run the &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; shell script to track the performance impact of changes. This script compiles the speedtest1.c program, runs it under cachegrind, processes the cachegrind output using the &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL script, then saves the results in a series of text files. Typical output from the speed-check.sh script looks like this:</source>
          <target state="translated">SQLite 개발자는 SQLite 소스 코드를 편집 할 때 &lt;a href=&quot;https://sqlite.org/src/file/tool/speed-check.sh&quot;&gt;speed-check.sh&lt;/a&gt; 셸 스크립트를 실행하여 변경으로 인한 성능 영향을 추적합니다. 이 스크립트는 speedtest1.c 프로그램을 컴파일하고 cachegrind에서 실행하며 &lt;a href=&quot;https://sqlite.org/src/file/tool/cg_anno.tcl&quot;&gt;cg_anno.tcl&lt;/a&gt; TCL 스크립트를 사용하여 cachegrind 출력을 처리 한 다음 결과를 일련의 텍스트 파일로 저장합니다. speed-check.sh 스크립트의 일반적인 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ed7acd0a6e6b88f39315ac5d476eef951a2dd64" translate="yes" xml:space="preserve">
          <source>As a REAL value that is the fractional &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;Julian day number&lt;/a&gt;.</source>
          <target state="translated">소수 &lt;a href=&quot;https://en.wikipedia.org/wiki/Julian_day&quot;&gt;줄리안 일 수인&lt;/a&gt; REAL 값으로 .</target>
        </trans-unit>
        <trans-unit id="e71c00fe61fb07ca9e09493bb8ec226ec4260341" translate="yes" xml:space="preserve">
          <source>As a TEXT string in the ISO-8610 format. Example: '2018-04-02 12:13:46'.</source>
          <target state="translated">ISO-8610 형식의 TEXT 문자열로. 예 : '2018-04-02 12:13:46'.</target>
        </trans-unit>
        <trans-unit id="1f5eb53c0fa9975ea0940d4a4405ff35765d1d45" translate="yes" xml:space="preserve">
          <source>As a performance optimization, reduce actions in the Lemon input grammar are allowed to contain comments of the form &quot;/*A-overwrites-Z*/&quot; to indicate that the semantic value &quot;A&quot; on the right-hand side of the rule is allowed to directly overwrite the semantic value &quot;Z&quot; on the left-hand side. This simple optimization reduces the number of stack operations in the push-down automaton used to parse the input grammar, and thus improve performance of the parser. It also makes the generated code a little smaller.</source>
          <target state="translated">성능 최적화로서, 레몬 입력 문법의 감소 조치에는 규칙의 오른쪽에 의미 상 값 &quot;A&quot;가 있음을 표시하기 위해 &quot;/ * A-overwrites-Z * /&quot;형식의 주석이 포함될 수 있습니다. 왼쪽의 의미 값 &quot;Z&quot;를 직접 덮어 쓸 수 있습니다. 이 간단한 최적화는 입력 문법을 구문 분석하는 데 사용되는 푸시 다운 오토 마톤의 스택 작업 수를 줄이고 파서의 성능을 향상시킵니다. 또한 생성 된 코드를 약간 작게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="7bcc1829db91ffdb7536f92aca2feacdc8bcb274" translate="yes" xml:space="preserve">
          <source>As an FTS5 bareword that is not &quot;AND&quot;, &quot;OR&quot; or &quot;NOT&quot; (case sensitive). An FTS5 bareword is a string of one or more consecutive characters that are all either:</source>
          <target state="translated">&quot;AND&quot;, &quot;OR&quot;또는 &quot;NOT&quot;(대소 문자 구분)가 아닌 FTS5 베어 워드입니다. FTS5 베어 워드는 하나 이상의 연속 문자로 구성된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="3f6cab6c41155dd3c9ab5be0d8403065e3d7dbaf" translate="yes" xml:space="preserve">
          <source>As an INTEGER number of seconds since 1970 (also known as &quot;unix time&quot;).</source>
          <target state="translated">1970 년 이후의 초 단위의 INTEGER 수 ( &quot;유닉스 시간&quot;이라고도 함).</target>
        </trans-unit>
        <trans-unit id="32bbd071581bca01328b9dfe1b573f6b34f404d8" translate="yes" xml:space="preserve">
          <source>As an alternative to step 3 above, the transaction may be rolled back. Transaction rollback is described in section</source>
          <target state="translated">위의 3 단계에 대한 대안으로 트랜잭션이 롤백 될 수 있습니다. 트랜잭션 롤백은 섹션에 설명되어 있습니다</target>
        </trans-unit>
        <trans-unit id="131746c3b1aff392f599c85628677c24f8811860" translate="yes" xml:space="preserve">
          <source>As an example of the result table format, suppose a query result is as follows:</source>
          <target state="translated">결과 테이블 형식의 예로 쿼리 결과가 다음과 같다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="592d95d98cfd4f715eed1be5091215e09168934a" translate="yes" xml:space="preserve">
          <source>As an example, consider a virtual table implementation that provides read-only access to existing comma-separated-value (CSV) files on disk. There is no backing store that needs to be created or initialized for such a virtual table (since the CSV files already exist on disk) so the xCreate and xConnect methods will be identical for that module.</source>
          <target state="translated">예를 들어, 디스크의 기존 CSV (쉼표로 분리 된 값) 파일에 대한 읽기 전용 액세스를 제공하는 가상 테이블 구현을 고려하십시오. CSV 파일이 디스크에 이미 존재하기 때문에 이러한 가상 테이블에 대해 작성 또는 초기화해야하는 백업 저장소가 없으므로 해당 모듈에 대해 xCreate 및 xConnect 메소드가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0e3486a0e62ced4a8499838d1b8b7393bbcb9f1f" translate="yes" xml:space="preserve">
          <source>As an example, consider creating a two-dimensional R*Tree index for use in spatial queries:</source>
          <target state="translated">예를 들어, 공간 쿼리에 사용하기 위해 2 차원 R * Tree 인덱스를 만드는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1f3a827b13a126faa4b33b0ce651746d14a8fc48" translate="yes" xml:space="preserve">
          <source>As an example, consider the following query:</source>
          <target state="translated">예를 들어, 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="22e02419a6c1aa60126918f747f9d30c0add3ddc" translate="yes" xml:space="preserve">
          <source>As an example, consider the following table that tracks dollar-amount changes on various &quot;accounts&quot;:</source>
          <target state="translated">예를 들어, 다양한 &quot;계정&quot;에 대한 달러 금액 변경을 추적하는 다음 표를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="9685f258b372a754415995a52cb6b9f9c3a80f7a" translate="yes" xml:space="preserve">
          <source>As an example, suppose someone (perhaps a customer) asks you: &quot;What ever became of that 'prefer-coroutine-sort-subquery' branch from two years ago?&quot; You might try to answer the query by consulting the history in your version control system, thusly:</source>
          <target state="translated">예를 들어, 누군가 (아마도 고객)가 &quot;2 년 전에 나온 '선호-코르 테인-소트-하위 쿼리'브랜치 중 무엇이 되었습니까?&quot; 버전 제어 시스템의 히스토리를 참조하여 쿼리에 응답하려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34ff54cf6acce621207ec9ac9f6485fedf9ef893" translate="yes" xml:space="preserve">
          <source>As an example, the following graphic:</source>
          <target state="translated">예를 들어, 다음 그래픽 :</target>
        </trans-unit>
        <trans-unit id="d8a7709446ce5823dd6ac2917092a6664f0dbd82" translate="yes" xml:space="preserve">
          <source>As an example, the following setup causes TCL to throw an error if an SQL statement contains an parameter that does not match any global TCL variable:</source>
          <target state="translated">예를 들어, 다음 명령문은 SQL 문에 글로벌 TCL 변수와 일치하지 않는 매개 변수가 포함 된 경우 TCL에서 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0ed757795f16facadb1fc50b83304333bb04670f" translate="yes" xml:space="preserve">
          <source>As an example, the following table show the relative sizes for an SQLite Archive, a ZIP Archive, and a Tarball of the 1,743 files in the SQLite 3.22.0 source tree:</source>
          <target state="translated">예를 들어, 다음 표는 SQLite 3.22.0 소스 트리에서 1,743 개 파일의 SQLite Archive, ZIP Archive 및 Tarball의 상대 크기를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9d15dfd61e0635160b8312b26c2789af818a9391" translate="yes" xml:space="preserve">
          <source>As an ordinary SQLite table, &quot;wordcount&quot; is implemented as two separate B-Trees. The main table uses the hidden rowid value as the key and stores the &quot;word&quot; and &quot;cnt&quot; columns as data. The &quot;TEXT PRIMARY KEY&quot; phrase of the CREATE TABLE statement causes the creation of an &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;unique index&lt;/a&gt; on the &quot;word&quot; column. This index is a separate B-Tree that uses &quot;word&quot; and the &quot;rowid&quot; as the key and stores no data at all. Note that the complete text of every &quot;word&quot; is stored twice: once in the main table and again in the index.</source>
          <target state="translated">일반적인 SQLite 테이블 인 &quot;wordcount&quot;는 두 개의 개별 B- 트리로 구현됩니다. 기본 테이블은 숨겨진 rowid 값을 키로 사용하고 &quot;word&quot;및 &quot;cnt&quot;열을 데이터로 저장합니다. CREATE TABLE 문의 &quot;TEXT PRIMARY KEY&quot;구문은 &quot;word&quot;열에 &lt;a href=&quot;lang_createindex#uniqueidx&quot;&gt;고유 인덱스&lt;/a&gt; 를 생성 합니다. 이 인덱스는 &quot;word&quot;와 &quot;rowid&quot;를 키로 사용하고 데이터를 전혀 저장하지 않는 별도의 B-Tree입니다. 모든 &quot;단어&quot;의 전체 텍스트는 기본 테이블에 한 번, 인덱스에 다시 두 번 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8276f7702973f7730b88b6137faf5d630b77f015" translate="yes" xml:space="preserve">
          <source>As before, SQLite does single binary search for the range of rows in the covering index that satisfy the WHERE clause, the scans that range from top to bottom to get the desired results. The rows that satisfy the WHERE clause are guaranteed to be adjacent since the WHERE clause is an equality constraint on the left-most column of the index. And by scanning the matching index rows from top to bottom, the output is guaranteed to be ordered by state since the state column is the very next column to the right of the fruit column. And so the resulting query is very efficient.</source>
          <target state="translated">이전과 마찬가지로 SQLite는 WHERE 절을 만족하는 커버링 인덱스에서 행 범위에 대한 단일 이진 검색을 수행합니다. 원하는 결과를 얻기 위해 위에서 아래로 스캔합니다. WHERE 절이 색인의 가장 왼쪽 열에 대한 등식 제한 조건이므로 WHERE 절을 만족시키는 행은 인접해야합니다. 그리고 일치하는 인덱스 행을 위에서 아래로 스캔하면 상태 열이 과일 열 오른쪽의 바로 다음 열이므로 상태별로 출력이 정렬됩니다. 결과 쿼리는 매우 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="15882cefbefb220ce1658791117147edd8cba359" translate="yes" xml:space="preserve">
          <source>As before, the Column instruction uses cursor P1 and pushes the data record in column P2 (1, column &quot;two&quot;) onto the stack. The Integer instruction pushes the value 50 onto the top of the stack. After these two instructions the stack looks like:</source>
          <target state="translated">이전과 같이 열 명령어는 커서 P1을 사용하고 열 P2 (1, 열 &quot;2&quot;)의 데이터 레코드를 스택으로 푸시합니다. 정수 명령어는 값 50을 스택의 상단으로 푸시합니다. 이 두 가지 지침을 따르면 스택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c0707574912e68bc0443d44af5e83d6ee57452b" translate="yes" xml:space="preserve">
          <source>As before, the second insert on the left will fail because the comparison will convert both strings into floating-point number first and the only difference in the strings is in the 20-th digit which exceeds the resolution of a 64-bit float. In contrast, the second insert on the right will work because in that case, the numbers being inserted are strings and are compared using memcmp().</source>
          <target state="translated">이전과 같이 왼쪽의 두 번째 삽입은 비교에서 두 문자열을 부동 소수점 숫자로 먼저 변환하고 문자열의 유일한 차이는 64 번째 부동 소수점의 해상도를 초과하는 20 번째 자리에 있기 때문에 실패합니다. 반대로 오른쪽의 두 번째 삽입은 작동하는 경우 삽입되는 숫자는 문자열이며 memcmp ()를 사용하여 비교되기 때문에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="021a9e62497cd6d1534e29c131c8485644cff8ee" translate="yes" xml:space="preserve">
          <source>As can be seen above, a single run of multitest.tcl invokes th3make dozens of times and takes between 12 and 24 CPU hours. The middle section of the output shows the arguments to each individual th3make run and the result and elapse time for that th3make. All build products and output for the separate th3make runs are captures in subdirectories for post-test analysis. The two-line summary at the bottom shows the total number of errors and tests over all th3make runs and the total elapse time, together with the &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; information for the version of SQLite that was tested. This summary information is recorded in the &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; during final testing.</source>
          <target state="translated">위에서 볼 수 있듯이 multitest.tcl의 단일 실행은 th3make를 수십 번 호출하며 CPU 시간은 12-24 시간입니다. 출력의 중간 부분에는 각 th3make 실행에 대한 인수와 해당 th3make에 대한 결과 및 경과 시간이 표시됩니다. 별도의 th3make 실행에 대한 모든 빌드 제품 및 출력은 테스트 후 분석을 위해 서브 디렉토리에서 캡처됩니다. 하단의 두 줄 요약 은 테스트 된 SQLite 버전에 대한 &lt;a href=&quot;c3ref/c_source_id&quot;&gt;SQLITE_SOURCE_ID&lt;/a&gt; 정보 와 함께 모든 th3make 실행에 대한 총 오류 및 테스트 수와 총 경과 시간을 보여줍니다 . 이 요약 정보는 최종 테스트 중에 &lt;a href=&quot;https://www.sqlite.org/checklists&quot;&gt;릴리스 점검 목록에&lt;/a&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="a57eec57195e396346032e284f403497e2a6ca2c" translate="yes" xml:space="preserve">
          <source>As far as we can tell, the SQL language specification allows the use of manifest typing. Nevertheless, most other SQL database engines are statically typed and so some people feel that the use of manifest typing is a bug in SQLite. But the authors of SQLite feel very strongly that this is a feature. The use of manifest typing in SQLite is a deliberate design decision which has proven in practice to make SQLite more reliable and easier to use, especially when used in combination with dynamically typed programming languages such as Tcl and Python.</source>
          <target state="translated">우리가 알 수있는 한 SQL 언어 사양은 매니페스트 입력을 사용할 수 있습니다. 그럼에도 불구하고 대부분의 다른 SQL 데이터베이스 엔진은 정적으로 유형이 지정되므로 일부 사람들은 매니페스트 유형 사용이 SQLite의 버그라고 생각합니다. 그러나 SQLite의 저자는 이것이 기능이라는 것을 매우 강하게 느낍니다. SQLite에서 매니페스트 타이핑을 사용하는 것은 실제로 Tcl 및 Python과 같이 동적으로 유형이 지정된 프로그래밍 언어와 함께 사용될 때 SQLite를보다 안정적이고 사용하기 쉽게 만드는 것으로 입증 된 의도적 인 디자인 결정입니다.</target>
        </trans-unit>
        <trans-unit id="fc29e0fdbff3d25477a8e029f9259bac6f50556e" translate="yes" xml:space="preserve">
          <source>As for all other SQLite tables, virtual or otherwise, data is retrieved from FTS tables using a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement.</source>
          <target state="translated">다른 모든 SQLite 테이블의 경우 가상 또는 다른 방법으로 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문을 사용하여 FTS 테이블에서 데이터를 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="e10a21db398e4cbe3920a0271ec03a17da9374a2" translate="yes" xml:space="preserve">
          <source>As in &lt;a href=&quot;#section_3_11&quot;&gt;section 3.11&lt;/a&gt;, the journal file might be truncated to zero length or its header might be overwritten with zeros as an optimization on systems where deleting a file is expensive. Either way, the journal is no longer hot after this step.</source>
          <target state="translated">&lt;a href=&quot;#section_3_11&quot;&gt;섹션 3.11&lt;/a&gt; 에서처럼 저널 파일은 길이가 0으로 잘 리거나 파일 삭제 비용이 높은 시스템에서 최적화로 헤더가 0으로 겹쳐 써질 수 있습니다. 어느 쪽이든,이 단계 후에 저널이 더 이상 뜨겁지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a052665302d7ed15dacb760a0e1d99f7e61c18a" translate="yes" xml:space="preserve">
          <source>As in the INSERT example, we push the database number P1 (0, the main database) onto the stack and use OpenWrite to open the cursor P1 on table P2 (base page 3, &quot;examp&quot;) for modification.</source>
          <target state="translated">INSERT 예제에서와 같이 데이터베이스 번호 P1 (0, 주 데이터베이스)을 스택으로 푸시하고 OpenWrite를 사용하여 수정을 위해 테이블 ​​P2 (기본 페이지 3, &quot;examp&quot;)에서 커서 P1을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="493b86f021b95461d337801ffc16a105b55e8b55" translate="yes" xml:space="preserve">
          <source>As in the SELECT example, the &lt;a href=&quot;opcode#Rewind&quot;&gt;Rewind&lt;/a&gt; instruction rewinds the cursor to the beginning of the table, readying it for use in the loop body.</source>
          <target state="translated">SELECT 예에서와 같이 &lt;a href=&quot;opcode#Rewind&quot;&gt;되감기&lt;/a&gt; 명령은 커서를 테이블의 시작 부분으로 되감기 고 루프 본문에서 사용할 수 있도록 준비합니다.</target>
        </trans-unit>
        <trans-unit id="164cc333da63b4862e96f8a93857b770263a0e06" translate="yes" xml:space="preserve">
          <source>As is the case for a</source>
          <target state="translated">의 경우와 마찬가지로</target>
        </trans-unit>
        <trans-unit id="ed24902923099bb89f817d03e0f964e2ddf3fe73" translate="yes" xml:space="preserve">
          <source>As its name implies, an R*Tree is organized as a tree. Each node of the tree is a bounding box. The root of the tree is a bounding box that encapsulates all elements of the tree. Beneath the root are a number of subtrees (typically 20 or more) each with their own smaller bounding boxes and each containing some subset of the R*Tree entries. The subtrees may have sub-subtrees, and so forth until finally one reaches the leaves of the tree which are the actual R*Tree entries.</source>
          <target state="translated">이름에서 알 수 있듯이 R * Tree는 트리로 구성됩니다. 트리의 각 노드는 경계 상자입니다. 트리의 루트는 트리의 모든 요소를 ​​캡슐화하는 경계 상자입니다. 루트 아래에는 각각 더 작은 경계 상자가 있고 각각 R * Tree 항목의 일부를 포함하는 여러 하위 트리 (일반적으로 20 개 이상)가 있습니다. 서브 트리는 서브-서브 트리를 가질 수 있으며, 최종적으로 실제 R * Tree 엔트리 인 트리의 잎에 도달 할 때까지 계속된다.</target>
        </trans-unit>
        <trans-unit id="1329f3ec0fa61448c27dc490e807fec1b74fd581" translate="yes" xml:space="preserve">
          <source>As its name suggests, the &quot;close&quot; method to an SQLite database just closes the database. This has the side-effect of deleting the</source>
          <target state="translated">이름에서 알 수 있듯이 SQLite 데이터베이스에 대한 &quot;close&quot;메소드는 데이터베이스를 닫습니다. 이것은 삭제하는 부작용이 있습니다</target>
        </trans-unit>
        <trans-unit id="3b9e6df535e040569dafb3fcef3111ff226a3e67" translate="yes" xml:space="preserve">
          <source>As long as the buffer size is greater than zero, sqlite3_snprintf() guarantees that the buffer is always zero-terminated. The first parameter &quot;n&quot; is the total size of the buffer, including space for the zero terminator. So the longest string that can be completely written will be n-1 characters.</source>
          <target state="translated">버퍼 크기가 0보다 큰 한, sqlite3_snprintf ()는 버퍼가 항상 0으로 종료되도록 보장합니다. 첫 번째 매개 변수 &quot;n&quot;은 제로 터미네이터를위한 공간을 포함하여 버퍼의 전체 크기입니다. 따라서 완전히 쓸 수있는 가장 긴 문자열은 n-1 자입니다.</target>
        </trans-unit>
        <trans-unit id="26ea5ee053d47ffa17dd452debb3d0d447e3ffce" translate="yes" xml:space="preserve">
          <source>As long as the input parameter is correct, these routines can only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">입력 매개 변수가 올 바르면 형식 변환 중에 메모리 부족 오류가 발생하는 경우에만 이러한 루틴이 실패 할 수 있습니다. 다음과 같은 인터페이스 하위 집합 만 메모리 부족 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc7938d9d029402b8371ec96dc41a03cdd95d8f8" translate="yes" xml:space="preserve">
          <source>As long as the input parameters are correct, these routines will only fail if an out-of-memory error occurs during a format conversion. Only the following subset of interfaces are subject to out-of-memory errors:</source>
          <target state="translated">입력 매개 변수가 올바른 한 형식 변환 중에 메모리 부족 오류가 발생하는 경우에만이 루틴이 실패합니다. 다음과 같은 인터페이스 하위 집합 만 메모리 부족 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af3758ac84a3f79558343e605f45f43dad96f8ef" translate="yes" xml:space="preserve">
          <source>As new versions of SQLite are released, repeat steps 3.6 and 3.7 to add changes in the new release to the private branch. Additional private changes can be made on the private branch in between releases if desired.</source>
          <target state="translated">새 버전의 SQLite가 릴리스되면 3.6 및 3.7 단계를 반복하여 새 릴리스의 변경 사항을 개인 브랜치에 추가하십시오. 원하는 경우 릴리스간에 개인 브랜치에서 추가 개인 변경을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e442983efbc639e95659cc425a72881ca75f93d3" translate="yes" xml:space="preserve">
          <source>As noted above, there really is no such thing as a &quot;sqlite3_column()&quot; function in the SQLite API. Instead, what we here call &quot;sqlite3_column()&quot; is a place-holder for an entire family of functions that return a value from the result set in various data types. There are also routines in this family that return the size of the result (if it is a string or BLOB) and the number of columns in the result set.</source>
          <target state="translated">위에서 언급했듯이 SQLite API에는 실제로 &quot;sqlite3_column ()&quot;함수가 없습니다. 대신, 여기에서 &quot;sqlite3_column ()&quot;이라고 부르는 것은 다양한 데이터 유형의 결과 집합에서 값을 반환하는 전체 함수 계열의 자리 표시 자입니다. 이 패밀리에는 결과의 크기 (문자열 또는 BLOB 인 경우)와 결과 세트의 열 수를 리턴하는 루틴도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7f8a41bee17850d3fdbafd1837635d4f3b48596" translate="yes" xml:space="preserve">
          <source>As of 2017-03-12, you must use Fossil version 2.0 or later for the following instructions to work. The SQLite repository started using artifacts named using SHA3 hashes instead of SHA1 hashes on that date, and Fossil 2.0 or later is needed in order to understand the new SHA3 hashes. To find out what version of Fossil you are running, type &quot;fossil -v&quot;.</source>
          <target state="translated">2017-03-12부터 다음 지침이 작동하려면 Fossil 버전 2.0 이상을 사용해야합니다. SQLite 리포지토리는 해당 날짜의 SHA1 해시 대신 SHA3 해시를 사용하여 명명 된 아티팩트를 사용하기 시작했으며 새 SHA3 해시를 이해하려면 Fossil 2.0 이상이 필요합니다. 실행중인 Fossil 버전을 확인하려면 &quot;fossil -v&quot;를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="46e28b72fbe9e739630682b02359c85a23e23fe2" translate="yes" xml:space="preserve">
          <source>As of 2018-05-19, the TH3 source tree consists and well over 500,000 lines of source code in 1709 separate files.</source>
          <target state="translated">2018-05-19 현재 TH3 소스 트리는 1709 개의 개별 파일에 500,000 개가 넘는 소스 코드로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="32045934e18d7d7235684ae81bb4ad3e112f0c5b" translate="yes" xml:space="preserve">
          <source>As of 2019-03-20, there is now an &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;official Git mirror&lt;/a&gt; of the SQLite sources on GitHub.</source>
          <target state="translated">2019-03-20 현재 GitHub에 SQLite 소스 의 &lt;a href=&quot;https://github.com/sqlite/sqlite&quot;&gt;공식 Git 미러&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e28505b65fc1d015c678e6ae0f3c3ddff268608" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10), the SQLite library consists of approximately 138.9 KSLOC of C code. (KSLOC means thousands of &quot;Source Lines Of Code&quot; or, in other words, lines of code excluding blank lines and comments.) By comparison, the project has 662 times as much test code and test scripts - 91946.2 KSLOC.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;버전 3.29.0&lt;/a&gt; (2019년 7월 10일), SQLite는 라이브러리는 C 코드의 약 138.9 KSLOC로 구성되어 있습니다. (KSLOC는 수천 개의 &quot;소스 라인 코드&quot;를 의미합니다. 즉, 빈 줄과 주석을 제외한 코드 줄을 의미합니다.) 비교하면 프로젝트의 테스트 코드와 테스트 스크립트는 662 배나됩니다-91946.2 KSLOC.</target>
        </trans-unit>
        <trans-unit id="a53c8d218bf20b0261060ea362ee56f13c07c935" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt; (2009-10-14), SQLite supports &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt;. But enforcement of foreign key constraints is turned off by default (for backwards compatibility). To enable foreign key constraint enforcement, run &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys=ON&lt;/a&gt; or compile with &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS=1&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; (2009-10-14), SQLite는 지원 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건을&lt;/a&gt; . 그러나 외래 키 제약 조건 적용은 기본적으로 해제되어 있습니다 (이전 버전과의 호환성을 위해). 외래 키 제약 조건 적용을 활성화하려면 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys = ON을&lt;/a&gt; 실행 하거나 &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;-DSQLITE_DEFAULT_FOREIGN_KEYS = 1로&lt;/a&gt; 컴파일하십시오 .</target>
        </trans-unit>
        <trans-unit id="836b2728d9d516fbe942ba314e801009ae9980b0" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;version 3.7.6&lt;/a&gt; (2011-04-12), SQLite includes a new virtual table module called &quot;fts4aux&quot;, which can be used to inspect the full-text index of an existing FTS table directly. Despite its name, fts4aux works just as well with FTS3 tables as it does with FTS4 tables. Fts4aux tables are read-only. The only way to modify the contents of an fts4aux table is by modifying the contents of the associated FTS table. The fts4aux module is automatically included in all &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;builds that include FTS&lt;/a&gt;.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_6.html&quot;&gt;버전 3.7.6&lt;/a&gt; (2011-04-12), SQLite는 직접 기존 FTS 테이블의 전체 텍스트 인덱스를 검사 할 수 있습니다 &quot;fts4aux&quot;라는 새로운 가상 테이블 모듈을 포함한다. 이름에도 불구하고 fts4aux는 FTS4 테이블과 마찬가지로 FTS3 테이블에서도 작동합니다. Fts4aux 테이블은 읽기 전용입니다. fts4aux 테이블의 내용을 수정하는 유일한 방법은 관련 FTS 테이블의 내용을 수정하는 것입니다. fts4aux 모듈은 &lt;a href=&quot;fts3#compiling_and_enabling_fts3_and_fts4&quot;&gt;FTS가&lt;/a&gt; 포함 된 모든 빌드에 자동으로 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="03eb89fc06866a1260f6276654306363ba727d94" translate="yes" xml:space="preserve">
          <source>As of &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), FTS5 is included as part of the SQLite &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;. It is disabled by default. If using the two autoconf build system, it is enabled by specifying the &quot;--enable-fts5&quot; option when running the configure script.</source>
          <target state="translated">현재 &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015년 10월 14일) FTS5는 SQLite는의 일부로 포함되어 &lt;a href=&quot;amalgamation&quot;&gt;융합&lt;/a&gt; . 기본적으로 비활성화되어 있습니다. 두 개의 autoconf 빌드 시스템을 사용하는 경우 configure 스크립트를 실행할 때 &quot;--enable-fts5&quot;옵션을 지정하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cba18acfc338d803dd183b86646f960bc3ebd65" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.16.0 (2017-01-02), the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; contains a dot-command &quot;.imposter&quot; that does all of the work of setting up a transient imposter table. Instead of making multiple calls to sqlite3_test_control() and figuring out and invoking a compatible CREATE TABLE statement, a transient imposter table can be constructed as follows:</source>
          <target state="translated">SQLite 3.16.0 (2017-01-02)부터 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에는 임시 임 포스터 테이블 설정 작업을 모두 수행하는 도트 명령 &quot;.imposter&quot;가 포함되어 있습니다. sqlite3_test_control ()을 여러 번 호출하고 호환 가능한 CREATE TABLE 문을 알아 내고 호출하는 대신 임시 임 포스터 테이블을 다음과 같이 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a2e1c87379924c2c171b5738373e64a2f944b7" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.27.0 (2019-02-07) the use of a double-quoted string literal causes a warning message to be sent to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt;.</source>
          <target state="translated">SQLite 3.27.0 (2019-02-07)부터 큰 따옴표로 묶인 문자열 리터럴을 사용하면 경고 메시지가 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="477279c68e157e3c69007f56a275a12b81ee766f" translate="yes" xml:space="preserve">
          <source>As of SQLite 3.29.0 (2019-07-10) the use of double-quoted string literals can be disabled at run-time using the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; and &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;SQLITE_DBCONFIG_DQS_DML&lt;/a&gt; actions to &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config()&lt;/a&gt;. The default settings can be altered at compile-time using the &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS=&lt;i&gt;N&lt;/i&gt;&lt;/a&gt; compile-time option. Application developers are encouraged to compile using -DSQLITE_DQS=0 in order to disable the double-quoted string literal misfeature by default. If that is not possible, then disable double-quoted string literals for individual database connections using C-code like this:</source>
          <target state="translated">SQLite 3.29.0 (2019-07-10) &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsdml&quot;&gt;부터는 &lt;/a&gt;&lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config ()에&lt;/a&gt; 대한 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdqsddl&quot;&gt;SQLITE_DBCONFIG_DQS_DDL&lt;/a&gt; 및 SQLITE_DBCONFIG_DQS_DML 작업을 사용하여 큰 따옴표로 묶인 문자열 리터럴을 런타임에 비활성화 할 수 있습니다 . &lt;a href=&quot;compile#dqs&quot;&gt;-DSQLITE_DQS = &lt;/a&gt;&lt;i&gt;N&lt;/i&gt; 컴파일 시간 옵션을 사용하여 컴파일시 기본 설정을 변경할 수 있습니다 . 응용 프로그램 개발자는 기본적으로 큰 따옴표로 묶인 문자열 리터럴 오작동을 비활성화하기 위해 -DSQLITE_DQS = 0을 사용하여 컴파일하는 것이 좋습니다. 이것이 가능하지 않은 경우 다음과 같이 C 코드를 사용하여 개별 데이터베이스 연결에 대해 큰 따옴표로 묶인 문자열 리터럴을 비활성화하십시오.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="27ccd6edc0578e2c50724724d1f7e72fc2202881" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;version 3.11.0&lt;/a&gt; (2016-02-15), the WAL file for a single transaction should be proportional in size to the transaction itself. Pages that are changed by the transaction should only be written into the WAL file once. However, with older versions of SQLite, the same page might be written into the WAL file multiple times if the transaction grows larger than the page cache.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;버전 3.11.0&lt;/a&gt; (2016-02-15)부터 단일 트랜잭션의 WAL 파일 크기는 트랜잭션 자체에 비례해야합니다. 트랜잭션에 의해 변경된 페이지는 WAL 파일에 한 번만 기록되어야합니다. 그러나 이전 버전의 SQLite에서는 트랜잭션이 페이지 캐시보다 커지면 동일한 페이지가 WAL 파일에 여러 번 기록 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9002d4afcf5621573059e14d645945f49cc82521" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;version 3.6.1&lt;/a&gt; (2008-08-06), the soft heap limit only applies to the general-purpose memory allocator. The soft heap limit does not know about or interact with the &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache memory allocator&lt;/a&gt; or the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt;. This deficiency will likely be addressed in a future release.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_1.html&quot;&gt;버전 3.6.1&lt;/a&gt; (2008-08-06)부터 소프트 힙 제한은 범용 메모리 할당 자에만 적용됩니다. 소프트 힙 한계는 &lt;a href=&quot;malloc#pagecache&quot;&gt;pagecache 메모리 할당 자&lt;/a&gt; 또는 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당 자에&lt;/a&gt; 대해 알고 있거나 상호 작용하지 않습니다 . 이 결함은 향후 릴리스에서 해결 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="b175c36534eb0163084a39638e664737aba3d613" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;version 3.6.19&lt;/a&gt;, the default setting for foreign key enforcement is OFF. However, that might change in a future release of SQLite. The default setting for foreign key enforcement can be specified at compile-time using the &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; preprocessor macro. To minimize future problems, applications should set the foreign key enforcement flag as required by the application and not depend on the default setting.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_19.html&quot;&gt;버전 3.6.19&lt;/a&gt; 부터 외래 키 적용의 기본 설정은 OFF입니다. 그러나 이후 릴리스의 SQLite에서는 변경 될 수 있습니다. 외래 키 적용에 대한 기본 설정은 &lt;a href=&quot;compile#default_foreign_keys&quot;&gt;SQLITE_DEFAULT_FOREIGN_KEYS&lt;/a&gt; 전 처리기 매크로를 사용하여 컴파일 타임에 지정할 수 있습니다 . 향후 문제를 최소화하기 위해 응용 프로그램은 응용 프로그램에 필요한 외래 키 적용 플래그를 설정해야하며 기본 설정에 의존하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="0e6461cc943c138056429ef3ecea61d0043a0402" translate="yes" xml:space="preserve">
          <source>As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14), the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; utility is able to generate RBU databases representing the difference between two databases with identical schemas. For example, the following command:</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14)부터 &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; 유틸리티는 동일한 스키마를 가진 두 데이터베이스의 차이점을 나타내는 RBU 데이터베이스를 생성 할 수 있습니다. 예를 들어, 다음 명령은</target>
        </trans-unit>
        <trans-unit id="dfbf6fd8aef52e316e037404ed7145e5b99ccf6d" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.21.0 (2017-10-24), the query planner will always prefer to use a co-routine to implement FROM-clause subqueries that contains an ORDER BY clause and that are not part of a join when the result set of the outer query is &quot;complex&quot;. This feature allows applications to shift expensive computations from before the sorter until after the sorter, which can result in faster operation. For example, consider this query:</source>
          <target state="translated">SQLite 버전 3.21.0 (2017-10-24)부터 쿼리 플래너는 항상 코 루틴을 사용하여 ORDER BY 절을 포함하고 결과가 조인의 일부가 아닌 FROM-clause 하위 쿼리를 구현하는 것을 선호합니다. 외부 쿼리 집합은 &quot;복잡&quot;입니다. 이 기능을 사용하면 응용 프로그램이 분류기 이전에서 분류기 이후까지 고가의 계산을 전환 할 수 있으므로 작업이 더 빨라질 수 있습니다. 예를 들어 다음 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="242b46186535aea87c089fafc2bda700b6f5e078" translate="yes" xml:space="preserve">
          <source>As of SQLite version 3.22.0, the &quot;sqlite_stat1&quot; table is an exception to some of the rules above. In SQLite, the schema of sqlite_stat1 is:</source>
          <target state="translated">SQLite 버전 3.22.0부터 &quot;sqlite_stat1&quot;테이블은 위의 규칙 중 일부에 대한 예외입니다. SQLite에서 sqlite_stat1의 스키마는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ddb98490083a7f2dc1ca2a3b26fa7d781b747ca" translate="yes" xml:space="preserve">
          <source>As of this writing (2017-07-13), the completion virtual table only looks for SQL keywords, and schema, table, and column names. The context contained in $wholeline is completely ignored. Future enhancements will try to return new completions taken from function and pragma names and other sources, as well as consider more context. The completion table should be considered a work-in-progress.</source>
          <target state="translated">이 글을 쓰는 시점 (2017-07-13)에서 완료 가상 테이블은 SQL 키워드, 스키마, 테이블 및 열 이름 만 찾습니다. $ wholeline에 포함 된 컨텍스트는 완전히 무시됩니다. 향후 개선 사항은 기능 및 pragma 이름 및 기타 소스에서 가져온 새로운 완료 사항을 반환하고 더 많은 컨텍스트를 고려할 것입니다. 완료 테이블은 진행중인 작업으로 간주되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b289cb5373e1ff5a5a0c905eb902dc91bdb7b556" translate="yes" xml:space="preserve">
          <source>As of this writing (2018-05-29) the only other recommended storage formats for datasets are XML, JSON, and CSV.</source>
          <target state="translated">이 글을 쓰는 시점 (2018-05-29)에 데이터 세트에 권장되는 유일한 다른 스토리지 형식은 XML, JSON 및 CSV입니다.</target>
        </trans-unit>
        <trans-unit id="f2ad4e776d39a3ec2c252f71f4dae40cd1708a1c" translate="yes" xml:space="preserve">
          <source>As of this writing (2019-07-16), the SQLite developers have stopped using AFL for routine testing and instead are focused on running dbsqlfuzz. At least one instance of dbsqlfuzz is running on the latest SQLite source code at all times, in order to catch any new problems that might be introduced into the source tree as features are added and routine maintenance is performed.</source>
          <target state="translated">이 글을 쓰는 시점 (2019-07-16)에 SQLite 개발자는 일상적인 테스트에 AFL 사용을 중단했으며 대신 dbsqlfuzz 실행에 중점을 둡니다. 기능이 추가되고 일상적인 유지 보수가 수행 될 때 소스 트리에 발생할 수있는 새로운 문제점을 포착하기 위해 최신 SQLite 소스 코드에서 최소한 하나의 dbsqlfuzz 인스턴스가 항상 실행 중입니다.</target>
        </trans-unit>
        <trans-unit id="c36686a25a23f2cfaee766f9bfb5607ad00a8413" translate="yes" xml:space="preserve">
          <source>As one might expect, the amount of data read from the database file is minimized by caching portions of the database file in main memory. Additionally, multiple updates to the database file that are part of the same</source>
          <target state="translated">예상 한대로, 데이터베이스 파일에서 읽은 데이터의 양은 주 메모리에 데이터베이스 파일의 일부를 캐싱함으로써 최소화됩니다. 또한 동일한 데이터베이스 파일에 대한 여러 업데이트</target>
        </trans-unit>
        <trans-unit id="972efc3fd6678a6e105ba1a8f1aac17c41abd523" translate="yes" xml:space="preserve">
          <source>As part of opening a new</source>
          <target state="translated">새로운 개통의 일환으로</target>
        </trans-unit>
        <trans-unit id="9b40d60a44eca2b862c669b4ece8404effe70c95" translate="yes" xml:space="preserve">
          <source>As part of the query planning process, SQLite enumerates all usable combinations of indexes and WHERE-clause constraints. For certain pathological queries, the number of these index-and-constraint combinations can be very large, resulting in slow performance by the query planner. The SQLITE_QUERY_PLANNER_LIMIT value (in conjunction with the related &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; setting) limits the number of index-and-constraint combinations that the query planner will consider, in order to prevent the query planner from using excess CPU time. The default value for SQLITE_QUERY_PLANNER_LIMIT is set high enough so that is never reached for real-world queries. The query planner search limit only applies to queries that are deliberately crafted to use excess planning time.</source>
          <target state="translated">쿼리 계획 프로세스의 일부로 SQLite는 사용 가능한 모든 인덱스 조합과 WHERE 절 제약 조건을 열거합니다. 특정 병리학 적 쿼리의 경우 이러한 인덱스-제약 조합의 수가 매우 많을 수 있으므로 쿼리 플래너의 성능이 저하됩니다. SQLITE_QUERY_PLANNER_LIMIT 값 (관련 &lt;a href=&quot;compile#query_planner_limit_incr&quot;&gt;SQLITE_QUERY_PLANNER_LIMIT_INCR&lt;/a&gt; 설정 과 함께 )은 쿼리 플래너가 과도한 CPU 시간을 사용하지 못하도록 쿼리 플래너가 고려할 인덱스 및 제약 조합의 수를 제한합니다. SQLITE_QUERY_PLANNER_LIMIT의 기본값은 실제 쿼리에 도달 할 수 없을 정도로 충분히 높게 설정되어 있습니다. 쿼리 플래너 검색 제한은 계획 시간이 초과되도록 의도적으로 만들어진 쿼리에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="69ee480d16c703172bf696c37d4bed26f84974f4" translate="yes" xml:space="preserve">
          <source>As part of the task of creating a new &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; structure, this method &lt;u&gt;must&lt;/u&gt; invoke &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; to tell the SQLite core about the columns and datatypes in the virtual table. The &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; API has the following prototype:</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/vtab&quot;&gt;sqlite3_vtab&lt;/a&gt; 구조 를 작성하는 작업의 일부로이 메소드 &lt;u&gt;는 &lt;/u&gt;&lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; 을 호출 하여 SQLite 코어에 가상 테이블의 열 및 데이터 유형에 대해 알려야합니다. &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()&lt;/a&gt; API는 다음과 같은 프로토 타입이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c00876adc6de8fc473fb32b80195d17d4fda9f03" translate="yes" xml:space="preserve">
          <source>As pointed out in the previous paragraph, SQLite takes steps to work around the quirks of POSIX advisory locking. Part of that work-around involves keeping a global list (mutex protected) of open SQLite database files. But, if multiple copies of SQLite are linked into the same application, then there will be multiple instances of this global list. Database connections opened using one copy of the SQLite library will be unaware of database connections opened using the other copy, and will be unable to work around the POSIX advisory locking quirks. A &lt;code&gt;close()&lt;/code&gt; operation on one connection might unknowingly clear the locks on a different database connection, leading to database corruption.</source>
          <target state="translated">이전 단락에서 지적했듯이 SQLite는 POSIX 권고 잠금 문제를 해결하기위한 조치를 취합니다. 이 문제를 해결하려면 열려있는 SQLite 데이터베이스 파일의 전체 목록 (뮤텍스 보호)을 유지해야합니다. 그러나 여러 SQLite 사본이 동일한 애플리케이션에 링크 된 경우이 글로벌 목록의 인스턴스가 여러 개 있습니다. 하나의 SQLite 라이브러리 사본을 사용하여 열린 데이터베이스 연결은 다른 사본을 사용하여 열린 데이터베이스 연결을 인식하지 못하며 POSIX 권고 잠금 문제를 해결할 수 없습니다. &lt;code&gt;close()&lt;/code&gt; 하나 개의 연결에 대한 작업은 무의식적으로 데이터베이스 손상으로 이어지는, 다른 데이터베이스 연결에 잠금을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d67b507fa18e45da7b000070cada26cbc7cde7" translate="yes" xml:space="preserve">
          <source>As recently as version 2.7.0, SQLite ran at about the same speed as MySQL on this test. But recent optimizations to SQLite have more than doubled speed of UPDATEs.</source>
          <target state="translated">최근 버전 2.7.0에서 SQLite는이 테스트에서 MySQL과 거의 같은 속도로 실행되었습니다. 그러나 최근 SQLite에 대한 최적화는 UPDATE 속도가 두 배 이상 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="9a13d6d8189152816b2ae81d060e78c812a6905c" translate="yes" xml:space="preserve">
          <source>As soon as the PENDING lock is released from the database file, other processes can begin reading the database again. In the current implementation, the RESERVED lock is also released, but that is not essential for correct operation.</source>
          <target state="translated">PENDING 잠금이 데이터베이스 파일에서 해제 되 자마자 다른 프로세스가 데이터베이스를 다시 읽을 수 있습니다. 현재 구현에서는 RESERVED 잠금도 해제되지만 올바른 작동에 필수적인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="555c3a9cda5a4b25e0cdbc43fe5e7c8c0b690222" translate="yes" xml:space="preserve">
          <source>As the last step in opening a</source>
          <target state="translated">열기의 마지막 단계로</target>
        </trans-unit>
        <trans-unit id="de5e740293d719649dc267008b44fcf5aaa20455" translate="yes" xml:space="preserve">
          <source>As we enter the interior of the second loop (at instruction 17) the stack contains a single integer which is the key of the record we want to modify. We are going to need to use this key twice: once to fetch the old value of the record and a second time to write back the revised record. So the first instruction is a Dup to make a duplicate of the key on the top of the stack. The Dup instruction will duplicate any element of the stack, not just the top element. You specify which element to duplication using the P1 operand. When P1 is 0, the top of the stack is duplicated. When P1 is 1, the next element down on the stack duplication. And so forth.</source>
          <target state="translated">두 번째 루프의 내부에 들어가면 (명령 17에서) 스택에는 수정하려는 레코드의 키인 단일 정수가 포함됩니다. 이 키를 두 번 사용해야합니다. 한 번은 레코드의 이전 값을 가져오고 두 번째는 수정 된 레코드를 다시 쓰는 것입니다. 따라서 첫 번째 명령어는 스택 상단에 키 복제본을 만드는 Dup입니다. Dup 명령어는 최상위 요소뿐만 아니라 스택의 모든 요소를 ​​복제합니다. P1 피연산자를 사용하여 복제 할 요소를 지정합니다. P1이 0이면 스택의 상단이 복제됩니다. P1이 1이면 스택 복제에서 다음 요소가 내려갑니다. 기타 등등.</target>
        </trans-unit>
        <trans-unit id="cf4c617d0371eb7d2e50bdeaba7f0656cfa12c47" translate="yes" xml:space="preserve">
          <source>As well as a list of columns, the module arguments passed to a CREATE VIRTUAL TABLE statement used to create an FTS table may be used to specify a &lt;a href=&quot;fts3#tokenizer&quot;&gt;tokenizer&lt;/a&gt;. This is done by specifying a string of the form &quot;tokenize=&amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot; in place of a column name, where &amp;lt;tokenizer name&amp;gt; is the name of the tokenizer to use and &amp;lt;tokenizer args&amp;gt; is an optional list of whitespace separated qualifiers to pass to the tokenizer implementation. A tokenizer specification may be placed anywhere in the column list, but at most one tokenizer declaration is allowed for each CREATE VIRTUAL TABLE statement. &lt;a href=&quot;fts3#tokenizer&quot;&gt;See below&lt;/a&gt; for a detailed description of using (and, if necessary, implementing) a tokenizer.</source>
          <target state="translated">열 목록뿐만 아니라 FTS 테이블을 만드는 데 사용 된 CREATE VIRTUAL TABLE 문에 전달 된 모듈 인수를 사용하여 &lt;a href=&quot;fts3#tokenizer&quot;&gt;토크 나이저&lt;/a&gt; 를 지정할 수 있습니다 . 열 이름 대신 &quot;tokenize = &amp;lt;tokenizer name&amp;gt; &amp;lt;tokenizer args&amp;gt;&quot;형식의 문자열을 지정하면됩니다. 여기서 &amp;lt;tokenizer name&amp;gt;은 사용할 토크 나이저의 이름이고 &amp;lt;tokenizer args&amp;gt;는 선택적입니다 토크 나이저 구현에 전달할 공백으로 구분 된 한정자 목록 토크 나이저 스펙은 열 목록의 어느 곳에 나 배치 할 수 있지만 각 CREATE VIRTUAL TABLE 문에 대해 최대 하나의 토크 나이저 선언이 허용됩니다. 토크 나이저 사용 (및 필요한 경우 구현)에 대한 자세한 설명은 &lt;a href=&quot;fts3#tokenizer&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba6435071ee404f8eb600e0af17ad3d0179b00e" translate="yes" xml:space="preserve">
          <source>As well as aggregate window functions, SQLite features a set of built-in window functions based on &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt; those supported by PostgreSQL&lt;/a&gt;.</source>
          <target state="translated">SQLite는 집계 창 함수뿐만 아니라 &lt;a href=&quot;https://www.postgresql.org/docs/10/static/functions-window.html&quot;&gt;PostgreSQL에서 지원하는&lt;/a&gt; 기능을 기반으로 하는 내장 창 함수 세트를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="4c2adc03d8772b0c49ef19569e284dd9591a16b0" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">행이 데이터베이스 테이블에 삽입 될 때 자동으로 설정 될뿐만 아니라이 함수에 의해 리턴 된 값은 &lt;a href=&quot;#sqlite3_set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()에&lt;/a&gt; 의해 명시 적으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6da8075b78c1059d6422bee1d474218e1b6600d9" translate="yes" xml:space="preserve">
          <source>As well as being set automatically as rows are inserted into database tables, the value returned by this function may be set explicitly by &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid()&lt;/a&gt;</source>
          <target state="translated">행이 데이터베이스 테이블에 삽입 될 때 자동으로 설정 될뿐만 아니라이 함수에 의해 리턴 된 값은 &lt;a href=&quot;set_last_insert_rowid&quot;&gt;sqlite3_set_last_insert_rowid ()에&lt;/a&gt; 의해 명시 적으로 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a715526e2153a56ee0a3cbcb2c8454333e9e1d8" translate="yes" xml:space="preserve">
          <source>As well as searching for all rows that contain a term, FTS5 allows the user to search for rows that contain:</source>
          <target state="translated">FTS5를 사용하면 용어가 포함 된 모든 행을 검색 할 수있을뿐만 아니라 다음을 포함하는 행을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f6e18c709ce14d58e4401d523e835813272b3a" translate="yes" xml:space="preserve">
          <source>As well as the &quot;simple&quot; tokenizer, the FTS source code features a tokenizer that uses the &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt;Porter Stemming algorithm&lt;/a&gt;. This tokenizer uses the same rules to separate the input document into terms including folding all terms into lower case, but also uses the Porter Stemming algorithm to reduce related English language words to a common root. For example, using the same input document as in the paragraph above, the porter tokenizer extracts the following tokens: &quot;right now thei veri frustrat&quot;. Even though some of these terms are not even English words, in some cases using them to build the full-text index is more useful than the more intelligible output produced by the simple tokenizer. Using the porter tokenizer, the document not only matches full-text queries such as &quot;MATCH 'Frustrated'&quot;, but also queries such as &quot;MATCH 'Frustration'&quot;, as the term &quot;Frustration&quot; is reduced by the Porter stemmer algorithm to &quot;frustrat&quot; - just as &quot;Frustrated&quot; is. So, when using the porter tokenizer, FTS is able to find not just exact matches for queried terms, but matches against similar English language terms. For more information on the Porter Stemmer algorithm, please refer to the page linked above.</source>
          <target state="translated">&quot;간단한&quot;토크 나이저뿐만 아니라 FTS 소스 코드에는 &lt;a href=&quot;http://tartarus.org/~martin/PorterStemmer/&quot;&gt; Porter Stemming 알고리즘&lt;/a&gt;. 이 토크 나이 저는 동일한 규칙을 사용하여 모든 문서를 소문자로 접는 것을 포함하여 입력 문서를 용어로 분리하지만 Porter Stemming 알고리즘을 사용하여 관련 영어 단어를 공통 루트로 줄입니다. 예를 들어, 위의 단락에서와 동일한 입력 문서를 사용하여 포터 토크 나이 저는 다음 토큰을 추출합니다. &quot;현재 바로 그 절두체&quot;. 이러한 용어 중 일부는 영어 단어도 아니지만 일부 경우 전체 텍스트 인덱스를 작성하기 위해 해당 단어를 사용하는 것이 간단한 토크 나이저로 생성 된보다 이해하기 쉬운 결과보다 더 유용합니다. 포터 토크 나이저를 사용하면 &quot;MATCH 'Frustrated'&quot;와 같은 전체 텍스트 쿼리뿐만 아니라 &quot;Frustration&quot;이라는 용어로 &quot;MATCH 'Frustration&quot; &quot;과 같은 쿼리도 일치합니다.&quot;Frustrated&quot;와 마찬가지로 Porter stemmer 알고리즘에 의해 &quot;frustrat&quot;로 줄어 듭니다. 따라서 포터 토크 나이저를 사용할 때 FTS는 쿼리 된 용어와 정확히 일치하는 단어뿐만 아니라 유사한 영어 용어와 일치하는 것을 찾을 수 있습니다. Porter Stemmer 알고리즘에 대한 자세한 내용은 위의 링크 된 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03b7b3d7c7af14aee8c40f5a5eff47a557f13b7f" translate="yes" xml:space="preserve">
          <source>As well as the column values and rowid of a matching row, an application may use &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 auxiliary functions&lt;/a&gt; to retrieve extra information regarding the matched row. For example, an auxiliary function may be used to retrieve a copy of a column value for a matched row with all instances of the matched term surrounded by html &amp;lt;b&amp;gt;&amp;lt;/b&amp;gt; tags. Auxiliary functions are invoked in the same way as SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;scalar functions&lt;/a&gt;, except that the name of the FTS5 table is specified as the first argument. For example:</source>
          <target state="translated">일치하는 행의 열 값과 rowid뿐만 아니라 응용 프로그램은 &lt;a href=&quot;fts5#_auxiliary_functions_&quot;&gt;FTS5 보조 기능&lt;/a&gt; 을 사용 하여 일치하는 행에 대한 추가 정보를 검색 할 수 있습니다 . 예를 들어 보조 함수를 사용하여 html &amp;lt;b&amp;gt; &amp;lt;/ b&amp;gt; 태그로 둘러싸인 일치하는 용어의 모든 인스턴스가있는 일치 된 행의 열 값 사본을 검색 할 수 있습니다. 보조 함수는 FTS5 테이블의 이름이 첫 번째 인수로 지정되는 것을 제외하고 SQLite &lt;a href=&quot;lang_corefunc&quot;&gt;스칼라 함수&lt;/a&gt; 와 동일한 방식으로 호출됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f0b425505ed4df313764b933ddda058638fd396" translate="yes" xml:space="preserve">
          <source>As well as the columns named by the user (or the &quot;content&quot; column if no module arguments were specified as part of the &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement), each FTS table has a &quot;rowid&quot; column. The rowid of an FTS table behaves in the same way as the rowid column of an ordinary SQLite table, except that the values stored in the rowid column of an FTS table remain unchanged if the database is rebuilt using the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. For FTS tables, &quot;docid&quot; is allowed as an alias along with the usual &quot;rowid&quot;, &quot;oid&quot; and &quot;_oid_&quot; identifiers. Attempting to insert or update a row with a docid value that already exists in the table is an error, just as it would be with an ordinary SQLite table.</source>
          <target state="translated">사용자가 명명 한 열 (또는 &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문의 일부로 모듈 인수가 지정되지 않은 경우 &quot;content&quot;열)뿐만 아니라 각 FTS 테이블에는 &quot;rowid&quot;열이 있습니다. FTS 테이블의 rowid는 데이터베이스가 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령을 사용하여 다시 빌드되는 경우 FTS 테이블의 rowid 열에 저장된 값이 변경되지 않은 것을 제외하고 일반 SQLite 테이블의 rowid 열과 동일한 방식으로 작동합니다 . FTS 테이블의 경우 &quot;docid&quot;는 일반적인 &quot;rowid&quot;, &quot;oid&quot;및 &quot;_oid_&quot;식별자와 함께 별칭으로 허용됩니다. 테이블에 이미 존재하는 docid 값으로 행을 삽입하거나 업데이트하려고하면 일반 SQLite 테이블에서와 마찬가지로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8231b142308216452ffa1a9e5faf9c8e3f6c4c97" translate="yes" xml:space="preserve">
          <source>As well as the command option, each invocation of &quot;.ar&quot; may specify one or more modifier options. Some modifier options require an argument, some do not. The following modifier options are available:</source>
          <target state="translated">명령 옵션뿐만 아니라 &quot;.ar&quot;을 호출 할 때마다 하나 이상의 수정 자 옵션을 지정할 수 있습니다. 일부 수정 자 옵션에는 인수가 필요하지만 일부는 그렇지 않습니다. 다음과 같은 수정 자 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11a7e6bcced1d592a4403e3d9c67fd5b0f5481cf" translate="yes" xml:space="preserve">
          <source>As well as the regular sqlite3changegroup_add() and sqlite3changegroup_output() functions, also available are the streaming versions sqlite3changegroup_add_strm() and sqlite3changegroup_output_strm().</source>
          <target state="translated">일반적인 sqlite3changegroup_add () 및 sqlite3changegroup_output () 함수뿐만 아니라 스트리밍 버전 sqlite3changegroup_add_strm () 및 sqlite3changegroup_output_strm ()도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c79aa6a7ac9fe81930f35128aa127b04b14a76a2" translate="yes" xml:space="preserve">
          <source>As with &quot;.tables&quot;, the &quot;.schema&quot; command shows the schema for all &lt;a href=&quot;lang_attach&quot;&gt;attached&lt;/a&gt; databases. If you only want to see the schema for a single database (perhaps &quot;main&quot;) then you can add an argument to &quot;.schema&quot; to restrict its output:</source>
          <target state="translated">&quot;.tables&quot;와 마찬가지로 &quot;.schema&quot;명령은 &lt;a href=&quot;lang_attach&quot;&gt;연결된&lt;/a&gt; 모든 데이터베이스 의 스키마를 보여줍니다 . 단일 데이터베이스 (아마 &quot;main&quot;)에 대한 스키마 만 보려면 &quot;.schema&quot;에 인수를 추가하여 출력을 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea1906458c679a89c4cf89131d2ffd0b8ce0439a" translate="yes" xml:space="preserve">
          <source>As with all SQL syntax, the case of the keywords does not matter. One can write &quot;WITHOUT rowid&quot; or &quot;without rowid&quot; or &quot;WiThOuT rOwId&quot; and it will mean the same thing.</source>
          <target state="translated">모든 SQL 구문과 마찬가지로 키워드의 경우는 중요하지 않습니다. &quot;WITHOUT rowid&quot;또는 &quot;with rowid&quot;또는 &quot;WiThOuT rOwId&quot;를 쓸 수 있으며 같은 의미입니다.</target>
        </trans-unit>
        <trans-unit id="08e240ecd7ad7f6958c55717608dff9d30301be2" translate="yes" xml:space="preserve">
          <source>As with all other SQLite APIs, those whose names end with &quot;16&quot; return UTF-16 encoded strings and the other functions return UTF-8.</source>
          <target state="translated">다른 모든 SQLite API와 마찬가지로 이름이 &quot;16&quot;으로 끝나는 API는 UTF-16으로 인코딩 된 문자열을 반환하고 다른 함수는 UTF-8을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dad941d012cf3c0fecce4040017740b92b3cab9e" translate="yes" xml:space="preserve">
          <source>As with all virtual table types, it is not possible to create indices or triggers attached to FTS tables. Nor is it possible to use the ALTER TABLE command to add extra columns to FTS tables (although it is possible to use ALTER TABLE to rename an FTS table).</source>
          <target state="translated">모든 가상 테이블 유형과 마찬가지로 FTS 테이블에 연결된 인덱스 또는 트리거를 생성 할 수 없습니다. ALTER TABLE 명령을 사용하여 FTS 테이블에 열을 추가 할 수도 없습니다 (ALTER TABLE을 사용하여 FTS 테이블의 이름을 바꿀 수는 있지만).</target>
        </trans-unit>
        <trans-unit id="2c9244ac5b5d0550aa0d1fc8ca3aa52ca8dfaf6c" translate="yes" xml:space="preserve">
          <source>As with custom file formats, and unlike pure pile-of-file formats, a wrapped pile-of-files format is not as easy to edit, since usually the entire file must be rewritten in order to change any component part.</source>
          <target state="translated">사용자 정의 파일 형식과 마찬가지로 순수 파일 형식과 달리 줄 바꿈 된 파일 형식은 편집하기 쉽지 않습니다. 일반적으로 구성 요소 부분을 변경하려면 전체 파일을 다시 작성해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="236d7f982d31124f4b94b3c6bc8e43ed33b0fc4b" translate="yes" xml:space="preserve">
          <source>As with the output of the sqlite3session_changeset() and sqlite3session_patchset() functions, all changes related to a single table are grouped together in the output of this function. Tables appear in the same order as for the very first changeset added to the changegroup. If the second or subsequent changesets added to the changegroup contain changes for tables that do not appear in the first changeset, they are appended onto the end of the output changeset, again in the order in which they are first encountered.</source>
          <target state="translated">sqlite3session_changeset () 및 sqlite3session_patchset () 함수의 출력과 마찬가지로 단일 테이블과 관련된 모든 변경 사항이이 함수의 출력에 그룹화됩니다. 변경 그룹에 추가 된 첫 번째 변경 집합과 동일한 순서로 테이블이 나타납니다. 변경 그룹에 추가 된 두 번째 또는 그 이후의 변경 세트에 첫 번째 변경 세트에 나타나지 않는 테이블에 대한 변경 사항이 포함 된 경우, 변경 사항이 처음 발생한 순서대로 출력 변경 세트의 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="38abe488c2a235f79f98488263f0f24db0790ef4" translate="yes" xml:space="preserve">
          <source>As with unix, most of the code for the various Windows VFSes is shared.</source>
          <target state="translated">유닉스와 마찬가지로 다양한 Windows VFS에 대한 대부분의 코드가 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="ae23c67b5810fa3b2f8c5dc0de91ee63f46fa321" translate="yes" xml:space="preserve">
          <source>As you can see above, our simple insert statement is implemented in 12 instructions. The first 3 and last 2 instructions are a standard prologue and epilogue, so the real work is done in the middle 7 instructions. There are no jumps, so the program executes once through from top to bottom. Let's now look at each instruction in detail.</source>
          <target state="translated">위에서 볼 수 있듯이 간단한 insert 문은 12 개의 명령어로 구현됩니다. 처음 3 개와 마지막 2 개 명령은 표준 프롤로그 및 에필로그이므로 실제 작업은 중간 7 개 명령에서 수행됩니다. 점프는 없으므로 프로그램은 위에서 아래로 한 번 실행됩니다. 이제 각 명령어를 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="5e7f8dc6fe3c7e8373b6401e629567228cb8e775" translate="yes" xml:space="preserve">
          <source>As you would expect, it is not possible to manipulate the database to a state that violates the foreign key constraint by deleting or updating rows in the</source>
          <target state="translated">예상 한대로 데이터베이스에서 행을 삭제하거나 업데이트하여 외래 키 제약 조건을 위반하는 상태로 데이터베이스를 조작 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d60ffe4ee5253e97c8077a55a44490538dd90ceb" translate="yes" xml:space="preserve">
          <source>Aside from those read operations described by H35070 and H21XXX, SQLite shall read data from the database file in aligned blocks of</source>
          <target state="translated">SQLite는 H35070 및 H21XXX에서 설명하는 읽기 작업 외에도 데이터베이스 파일에서 데이터를 정렬 된 블록으로 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="42e2846af72fd7f80a66045f0952619fc82cc85d" translate="yes" xml:space="preserve">
          <source>Assert() macros are disabled by compiling with the NDEBUG macro defined. In most systems, asserts are enabled by default. But in SQLite, the asserts are so numerous and are in such performance critical places, that the database engine runs about three times slower when asserts are enabled. Hence, the default (production) build of SQLite disables asserts. Assert statements are only enabled when SQLite is compiled with the SQLITE_DEBUG preprocessor macro defined.</source>
          <target state="translated">Assert () 매크로는 정의 된 NDEBUG 매크로로 컴파일하여 비활성화됩니다. 대부분의 시스템에서 기본적으로 어설 션이 활성화되어 있습니다. 그러나 SQLite에서는 어설 션이 너무 많고 성능이 중요한 장소에 있으므로 어설 션을 사용할 때 데이터베이스 엔진이 약 3 배 느리게 실행됩니다. 따라서 SQLite의 기본 (프로덕션) 빌드는 어설 션을 비활성화합니다. Assert 문은 SQLite가 정의 된 SQLITE_DEBUG 전 처리기 매크로로 컴파일 된 경우에만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="c350f30044b71a607c57f6c34de0b1ed5d9089b9" translate="yes" xml:space="preserve">
          <source>Assertion fault in FTS4. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;d6ec09eccf68cfc&lt;/a&gt;</source>
          <target state="translated">FTS4의 어설 션 오류. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/d6ec09eccf68cfc&quot;&gt;D6EC09ECCF68CFC&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebc26a866ddd19c561f95f02b90e42c3048bf831" translate="yes" xml:space="preserve">
          <source>Assertion fault on queries involving expressions of the form &quot;x IN (?)&quot;. Ticket &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt;.</source>
          <target state="translated">&quot;x IN (?)&quot;형식의 표현식과 관련된 쿼리에서 어설 션 오류. 티켓 &lt;a href=&quot;http://www.sqlite.org/src/info/e39d032577&quot;&gt;e39d032577&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c84e5f05e8b60b78b6a824b91605a18f1523027" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing REPLACE on an index on an expression. Ticket &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</source>
          <target state="translated">식의 인덱스에서 REPLACE를 수행 할 때 어설 션 오류가 발생했습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/dc3f932f5a147771&quot;&gt;dc3f932f5a147771&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14462bb4d8840870eeb8b473a0f255cc7e22e056" translate="yes" xml:space="preserve">
          <source>Assertion fault when doing an IN operator on a constant index. Ticket &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</source>
          <target state="translated">상수 인덱스에서 IN 연산자를 수행 할 때 어설 션 오류가 발생했습니다. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/aa98619ad08ddcab&quot;&gt;aa98619ad08ddcab&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6cea6f6a832fd7bbb6517d045402e777f939a795" translate="yes" xml:space="preserve">
          <source>Assigned the integer at offset 68 in the &lt;a href=&quot;fileformat2#database_header&quot;&gt;database header&lt;/a&gt; as the &lt;a href=&quot;fileformat2#appid&quot;&gt;Application ID&lt;/a&gt; for when SQLite is used as an &lt;a href=&quot;appfileformat&quot;&gt;application file-format&lt;/a&gt;. Added the &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; command to query and set the Application ID.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;appfileformat&quot;&gt;응용 프로그램 파일 형식으로&lt;/a&gt; 사용되는 경우 에 대한 &lt;a href=&quot;fileformat2#database_header&quot;&gt;데이터베이스 &lt;/a&gt;&lt;a href=&quot;fileformat2#appid&quot;&gt;ID&lt;/a&gt; 의 오프셋 68에서 정수를 응용 프로그램 ID 로 할당했습니다 . &lt;a href=&quot;pragma#pragma_application_id&quot;&gt;PRAGMA application_id&lt;/a&gt; 명령을 추가하여 응용 프로그램 ID를 쿼리하고 설정했습니다.</target>
        </trans-unit>
        <trans-unit id="2dc2100f672c34160990cbf608240b0f61030c73" translate="yes" xml:space="preserve">
          <source>Assuming</source>
          <target state="translated">Assuming</target>
        </trans-unit>
        <trans-unit id="ea6dcdcecbe15c6b4677215943bc88e69426e6db" translate="yes" xml:space="preserve">
          <source>Assuming no errors have occurred, then after attempting to detect and roll back a</source>
          <target state="translated">오류가 발생하지 않았다고 가정하고 감지 및 롤백 시도 후</target>
        </trans-unit>
        <trans-unit id="2d3766c3aab2fade58e514ea17fb6dc49420a581" translate="yes" xml:space="preserve">
          <source>Assuming statistics are enabled, the following routine can be used to access them:</source>
          <target state="translated">통계가 사용 가능하다고 가정하면 다음 루틴을 사용하여 통계에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="836ad82865d510ff9a297c7660cf9d810b0b4728" translate="yes" xml:space="preserve">
          <source>Assuming that after registering for an unlock-notify callback a database waits for the callback to be issued before taking any further action (a reasonable assumption), then using this API may cause the application to deadlock. For example, if connection X is waiting for connection Y's transaction to be concluded, and similarly connection Y is waiting on connection X's transaction, then neither connection will proceed and the system may remain deadlocked indefinitely.</source>
          <target state="translated">잠금 해제 알림 콜백에 등록한 후 데이터베이스가 추가 조치를 취하기 전에 콜백이 발행 될 때까지 대기한다고 가정하면 (합리적인 가정)이 API를 사용하면 애플리케이션이 교착 상태에 빠질 수 있습니다. 예를 들어, 연결 X가 연결 Y의 트랜잭션이 완료되기를 기다리고 있고 연결 Y가 연결 X의 트랜잭션을 기다리고있는 경우 연결이 진행되지 않고 시스템이 무기한 교착 상태를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ba1c75f29bb0c1b541e404f389344df8b7d3190" translate="yes" xml:space="preserve">
          <source>Assuming that any and all sectors in the transient state may be corrupted following a power or system failure is a very pessimistic approach. Some modern systems provide more sophisticated guarantees than this. SQLite allows the VFS implementation to specify at runtime that the current platform supports zero or more of the following properties:</source>
          <target state="translated">과도 상태의 모든 섹터가 전원 또는 시스템 장애 후 손상 될 수 있다고 가정하는 것은 매우 비관적 인 접근법입니다. 일부 최신 시스템은 이보다 더 정교한 보증을 제공합니다. SQLite를 사용하면 VFS 구현에서 런타임시 현재 플랫폼이 다음 특성 중 0 개 이상을 지원하도록 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e7a33261340b9207abc7f6240781daed2437d8" translate="yes" xml:space="preserve">
          <source>Assuming that customer records are stored in the &quot;customers&quot; table, and that order records are stored in the &quot;orders&quot; table, the following UPDATE trigger ensures that all associated orders are redirected when a customer changes his or her address:</source>
          <target state="translated">고객 레코드가 &quot;고객&quot;테이블에 저장되고 주문 레코드가 &quot;주문&quot;테이블에 저장되어 있다고 가정하면 다음 UPDATE 트리거는 고객이 자신의 주소를 변경할 때 모든 관련 주문이 리디렉션되도록합니다.</target>
        </trans-unit>
        <trans-unit id="ff40c2070ad237bff82bd7bce4ef0b45898889d0" translate="yes" xml:space="preserve">
          <source>Assuming that the compile-time threading mode is not single-thread, then the threading mode can be changed during initialization using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface. The &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; verb puts SQLite into single-thread mode, the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; verb sets multi-thread mode, and the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; verb sets serialized mode.</source>
          <target state="translated">컴파일 타임 스레딩 모드가 단일 스레드가 아니라고 가정하면 초기화 중에 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 스레딩 모드를 변경할 수 있습니다 . &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigsinglethread&quot;&gt;SQLITE_CONFIG_SINGLETHREAD&lt;/a&gt; 풋 동사는 단일 스레드 모드에서로 SQLite에 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigmultithread&quot;&gt;SQLITE_CONFIG_MULTITHREAD&lt;/a&gt; 세트 멀티 스레드 모드 동사 및 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfigserialized&quot;&gt;SQLITE_CONFIG_SERIALIZED&lt;/a&gt; 모드를 직렬화 세트 동사.</target>
        </trans-unit>
        <trans-unit id="5e4099134714457b667c5a0d0c91727935a69b43" translate="yes" xml:space="preserve">
          <source>Assuming that the first hidden column of &quot;tablevaluedfunc&quot; is &quot;param1&quot;, the query above is semantically equivalent to this:</source>
          <target state="translated">&quot;tablevaluedfunc&quot;의 첫 번째 숨겨진 열이 &quot;param1&quot;이라고 가정하면 위 쿼리는 의미 적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a392f90a65c67ef3276bb011e52cf4659579c18e" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">변경 세트 Blob이 &lt;a href=&quot;#sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; , &lt;a href=&quot;#sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; 함수 중 하나에 의해 작성되었다고 가정하면 단일 테이블에 적용되는 변경 세트 내의 모든 변경 사항이 함께 그룹화됩니다. 이는 애플리케이션이이 함수로 작성된 반복기를 사용하여 변경 세트를 반복 할 때 단일 테이블과 관련된 모든 변경 사항이 연속적으로 방문됨을 의미합니다. 반복자가 테이블 X에 적용되는 변경 사항을 방문한 다음 테이블 Y에 대한 변경 사항을 방문한 다음 나중에 테이블 X에 대한 다른 변경 사항을 방문 할 가능성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae768e26e15e53e036c5e372149bd64f61fe40d5" translate="yes" xml:space="preserve">
          <source>Assuming the changeset blob was created by one of the &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset()&lt;/a&gt;, &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat()&lt;/a&gt; or &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert()&lt;/a&gt; functions, all changes within the changeset that apply to a single table are grouped together. This means that when an application iterates through a changeset using an iterator created by this function, all changes that relate to a single table are visited consecutively. There is no chance that the iterator will visit a change the applies to table X, then one for table Y, and then later on visit another change for table X.</source>
          <target state="translated">변경 세트 Blob이 &lt;a href=&quot;sqlite3session_changeset&quot;&gt;sqlite3session_changeset ()&lt;/a&gt; , &lt;a href=&quot;sqlite3changeset_concat&quot;&gt;sqlite3changeset_concat ()&lt;/a&gt; 또는 &lt;a href=&quot;sqlite3changeset_invert&quot;&gt;sqlite3changeset_invert ()&lt;/a&gt; 함수 중 하나에 의해 작성되었다고 가정하면 단일 테이블에 적용되는 변경 세트 내의 모든 변경 사항이 함께 그룹화됩니다. 이는 애플리케이션이이 함수로 작성된 반복기를 사용하여 변경 세트를 반복 할 때 단일 테이블과 관련된 모든 변경 사항이 연속적으로 방문됨을 의미합니다. 반복자가 테이블 X에 적용되는 변경 사항을 방문한 다음 테이블 Y에 대한 변경 사항을 방문한 다음 나중에 테이블 X에 대한 다른 변경 사항을 방문 할 가능성은 없습니다.</target>
        </trans-unit>
        <trans-unit id="ae27622bf93c5f8e58c667e3d2b3f8634b153cf3" translate="yes" xml:space="preserve">
          <source>Assuming the library is compiled with foreign key constraints enabled, it must still be enabled by the application at runtime, using the &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; command. For example:</source>
          <target state="translated">라이브러리가 외래 키 제약 조건이 활성화 된 상태로 컴파일되었다고 가정하면 &lt;a href=&quot;pragma#pragma_foreign_keys&quot;&gt;PRAGMA foreign_keys&lt;/a&gt; 명령을 사용하여 런타임시 응용 프로그램에서 라이브러리를 계속 활성화해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a1dda34c843a460a37b4389bc3fdea530b33452" translate="yes" xml:space="preserve">
          <source>Assuming the nominated table does exist, then its columns must be the same as or a superset of those defined for the FTS table. The external table must also be in the same database file as the FTS table. In other words, The external table cannot be in a different database file connected using &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; nor may one of the FTS table and the external content be in the TEMP database when the other is in a persistent database file such as MAIN.</source>
          <target state="translated">지명 된 테이블이 존재한다고 가정하면 해당 열은 FTS 테이블에 대해 정의 된 열과 동일하거나 상위 집합이어야합니다. 외부 테이블도 FTS 테이블과 동일한 데이터베이스 파일에 있어야합니다. 즉, 외부 테이블은 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH를&lt;/a&gt; 사용하여 연결된 다른 데이터베이스 파일에 있을 수 없으며 다른 하나는 MAIN과 같은 지속적 데이터베이스 파일에있을 때 FTS 테이블 및 외부 컨텐츠 중 하나가 TEMP 데이터베이스에있을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="921866ee0046d5a80db64dfb8749244f24a09ba6" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a &lt;a href=&quot;fts5#contentless_tables&quot;&gt;contentless table&lt;/a&gt;, the &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt;, &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt;, &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; and &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext&lt;/a&gt; are slower than usual. This is because instead of reading the required data directly from the FTS index they have to load and tokenize the document text on demand.</source>
          <target state="translated">테이블을 가정하면도 아닌 &lt;a href=&quot;fts5#contentless_tables&quot;&gt;콘텐츠가없는 테이블&lt;/a&gt; 의 &lt;a href=&quot;#xInstCount&quot;&gt;xInstCount&lt;/a&gt; , &lt;a href=&quot;#xInst&quot;&gt;xInst&lt;/a&gt; , &lt;a href=&quot;#xPhraseFirst&quot;&gt;xPhraseFirst&lt;/a&gt; 및 &lt;a href=&quot;#xPhraseNext&quot;&gt;xPhraseNext는&lt;/a&gt; 느린 평소보다 있습니다. FTS 인덱스에서 직접 필요한 데이터를 읽는 대신 요청시 문서 텍스트를로드하고 토큰 화해야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dc375c212f41b57083889574933fcd5e4987a611" translate="yes" xml:space="preserve">
          <source>Assuming the table is not also a contentless table, the &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;xPhraseFirstColumn&lt;/a&gt; and &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; are slower than usual.</source>
          <target state="translated">테이블이 &lt;a href=&quot;#xPhraseFirstColumn&quot;&gt;컨텐츠&lt;/a&gt; 가없는 테이블이 아니라고 가정하면 xPhraseFirstColumn 및 &lt;a href=&quot;#xPhraseNextColumn&quot;&gt;xPhraseNextColumn&lt;/a&gt; 이 평소보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="504be981e8ff80c0d63cd17a340b7f1cd587e84d" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O appears to give better responsiveness, but at a price. You lose the Durable property. With the default I/O backend of SQLite, once a write completes, you know that the information you wrote is safely on disk. With the asynchronous I/O, this is not the case. If your program crashes or if a power loss occurs after the database write but before the asynchronous write thread has completed, then the database change might never make it to disk and the next user of the database might not see your change.</source>
          <target state="translated">비동기 I / O는 더 나은 응답 성을 제공하지만 비용이 많이 드는 것으로 보입니다. 내구력을 잃습니다. SQLite의 기본 I / O 백엔드를 사용하면 쓰기가 완료되면 작성한 정보가 디스크에 안전하게 저장되어 있음을 알 수 있습니다. 비동기식 I / O에서는 그렇지 않습니다. 데이터베이스 쓰기 후 비동기 쓰기 스레드가 완료되기 전에 프로그램이 중단되거나 전원 손실이 발생하면 데이터베이스 변경으로 인해 디스크가 변경되지 않고 다음 데이터베이스 사용자가 변경 사항을 보지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c26b5cd54f0029b1a3269b19cfe3a6ff6addbcc" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O works by creating an SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS object&lt;/a&gt; and registering it with &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. When files opened via this VFS are written to (using the vfs xWrite() method), the data is not written directly to disk, but is placed in the &quot;write-queue&quot; to be handled by the background thread.</source>
          <target state="translated">비동기 I / O는 SQLite &lt;a href=&quot;c3ref/vfs&quot;&gt;VFS 객체&lt;/a&gt; 를 생성하고 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()에&lt;/a&gt; 등록 하여 작동합니다 . 이 VFS를 통해 열린 파일이 (vfs xWrite () 메소드를 사용하여) 기록 될 때, 데이터는 디스크에 직접 기록되지 않지만 백그라운드 쓰레드가 처리 할 &quot;쓰기 큐&quot;에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="4c91d5ce458c482219d3664734d8a556293b6cdf" translate="yes" xml:space="preserve">
          <source>At a shell or DOS prompt, enter: &quot;&lt;b&gt;sqlite3 test.db&lt;/b&gt;&quot;. This will create a new database named &quot;test.db&quot;. (You can use a different name if you like.)</source>
          <target state="translated">쉘 또는 DOS 프롬프트에서 &quot; &lt;b&gt;sqlite3 test.db&lt;/b&gt; &quot;를 입력하십시오 . &quot;test.db&quot;라는 새 데이터베이스가 생성됩니다. 원하는 경우 다른 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449f6270af54115e84fbbfac0ca3ab28ec064210" translate="yes" xml:space="preserve">
          <source>At about that same time, some avionics manufacturers were expressing interest in SQLite, which prompted the SQLite developers to design TH3 to support the rigorous testing standards of &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt;.</source>
          <target state="translated">거의 동시에, 일부 항공 전자 제품 제조업체는 SQLite에 대한 관심을 표명하면서 SQLite 개발자는 &lt;a href=&quot;https://en.wikipedia.org/wiki/DO-178B&quot;&gt;DO-178B&lt;/a&gt; 의 엄격한 테스트 표준을 지원하도록 TH3을 설계해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="d3fd57d066718d01302089d95d92c8454d1b5f4a" translate="yes" xml:space="preserve">
          <source>At any one time, a single table may have any number of active read-locks or a single active write lock. To read data a table, a connection must first obtain a read-lock. To write to a table, a connection must obtain a write-lock on that table. If a required table lock cannot be obtained, the query fails and SQLITE_LOCKED is returned to the caller.</source>
          <target state="translated">언제든지 단일 테이블은 여러 개의 활성 읽기 잠금 또는 단일 활성 쓰기 잠금을 가질 수 있습니다. 테이블에서 데이터를 읽으려면 먼저 연결에서 읽기 잠금을 얻어야합니다. 테이블에 쓰려면 연결에서 해당 테이블에 대한 쓰기 잠금을 얻어야합니다. 필요한 테이블 잠금을 확보 할 수 없으면 쿼리가 실패하고 SQLITE_LOCKED가 호출자에게 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e2c8ad5daed2b52823fb4c80a495b310ef19384a" translate="yes" xml:space="preserve">
          <source>At any one time, each</source>
          <target state="translated">언제든지, 각각</target>
        </trans-unit>
        <trans-unit id="8560f4e49c6caa4d7228201f89aa3ea44ff72f5b" translate="yes" xml:space="preserve">
          <source>At any one time, the</source>
          <target state="translated">언제든지</target>
        </trans-unit>
        <trans-unit id="faefe425b3756bc94c56346d8a50b44d5ccda922" translate="yes" xml:space="preserve">
          <source>At any point in time, every page in the main database has a single use which is one of the following:</source>
          <target state="translated">어느 시점에서든 주 데이터베이스의 모든 페이지는 다음 중 하나 인 단일 용도로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4998acdc6089555e0887c221354101b4a2253663" translate="yes" xml:space="preserve">
          <source>At first glance, the final two full-text queries in the example above seem to be syntactically incorrect, as there is a table name (&quot;mail&quot;) used as an SQL expression. The reason this is acceptable is that each FTS table actually has a &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; column with the same name as the table itself (in this case, &quot;mail&quot;). The value stored in this column is not meaningful to the application, but can be used as the left-hand operand to a MATCH operator. This special column may also be passed as an argument to the &lt;a href=&quot;fts3#snippet&quot;&gt;FTS auxiliary functions&lt;/a&gt;.</source>
          <target state="translated">언뜻보기에, 위의 예제에서 마지막 두 개의 전체 텍스트 쿼리는 SQL 표현식으로 사용되는 테이블 이름 ( &quot;mail&quot;)이 있으므로 구문 상 올바르지 않은 것 같습니다. 이것이 허용되는 이유는 각 FTS 테이블에 실제로 테이블 자체와 이름이 같은 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;HIDDEN&lt;/a&gt; 열 (이 경우에는 &quot;mail&quot;)이 있기 때문입니다. 이 열에 저장된 값은 응용 프로그램에는 의미가 없지만 MATCH 연산자의 왼쪽 피연산자로 사용할 수 있습니다. 이 특수 열은 &lt;a href=&quot;fts3#snippet&quot;&gt;FTS 보조 기능에&lt;/a&gt; 대한 인수로 전달 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f5836449640e20f49edf00efccee8083a6bcb35" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite 는 xsz에 세 번째 인수로 전달 된 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 를 보유하기 위해 최소 szOsFile 바이트의 메모리를 할당합니다 . xOpen 메소드는 구조를 할당 할 필요가 없습니다. xOpen 메소드는 sqlite3_file.pMethods를 유효한 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 또는 NULL로 설정해야 합니다. xOpen은 열기에 실패하더라도이를 수행해야합니다. SQLite는 xOpen 호출의 성공 또는 실패에 관계없이 xOpen이 반환 된 후 sqlite3_file.pMethods 요소가 유효 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="59514e13b273471c6ec6f5f109fedbde115ba166" translate="yes" xml:space="preserve">
          <source>At least szOsFile bytes of memory are allocated by SQLite to hold the &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; structure passed as the third argument to xOpen. The xOpen method does not have to allocate the structure; it should just fill it in. Note that the xOpen method must set the sqlite3_file.pMethods to either a valid &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object or to NULL. xOpen must do this even if the open fails. SQLite expects that the sqlite3_file.pMethods element will be valid after xOpen returns regardless of the success or failure of the xOpen call.</source>
          <target state="translated">SQLite 는 xsz에 세 번째 인수로 전달 된 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 구조 를 보유하기 위해 최소 szOsFile 바이트의 메모리를 할당합니다 . xOpen 메소드는 구조를 할당 할 필요가 없습니다. xOpen 메소드는 sqlite3_file.pMethods를 유효한 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 또는 NULL로 설정해야 합니다. xOpen은 열기에 실패하더라도이를 수행해야합니다. SQLite는 xOpen 호출의 성공 또는 실패에 관계없이 xOpen이 반환 된 후 sqlite3_file.pMethods 요소가 유효 할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="5cf0c7d5d4e31a3622d3bed10cffc599203f902a" translate="yes" xml:space="preserve">
          <source>At most one connection to a single shared cache may open a write transaction at any one time. This may co-exist with any number of read transactions.</source>
          <target state="translated">단일 공유 캐시에 대한 최대 하나의 연결은 언제든지 쓰기 트랜잭션을 열 수 있습니다. 여러 읽기 트랜잭션과 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2549fa7b8565911915cfbc5b3b9d42147224732f" translate="yes" xml:space="preserve">
          <source>At one point, &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; was sometimes licensed to third-parties. Such licensing no longer occurs. However, back when it was occurring, some of the TH3 test cases contained information that was sensitive and could not be released even to licensees. This sensitive information is stored in yet another repository.</source>
          <target state="translated">한때 &lt;a href=&quot;th3&quot;&gt;TH3&lt;/a&gt; 는 때때로 제 3 자에게 라이센스를 부여했습니다. 이러한 라이센스는 더 이상 발생하지 않습니다. 그러나 문제가 발생했을 때 TH3 테스트 사례 중 일부에는 민감한 정보가 포함되어 있으며 라이센스 사용자에게도 공개 할 수 없었습니다. 이 민감한 정보는 또 다른 저장소에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4d936f8adee7e8e3dc2d8a9b26c4bae945a9dd4c" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">현재이 기능을 사용하여 구성 할 수있는 옵션은 하나뿐입니다. ( &lt;a href=&quot;#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT를&lt;/a&gt; 참조하십시오 .) 나중에 추가 옵션이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0662b7a2bebf7dce7d12510693eb67ca1548c61" translate="yes" xml:space="preserve">
          <source>At present, there is only one option that may be configured using this function. (See &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT&lt;/a&gt;.) Further options may be added in the future.</source>
          <target state="translated">현재이 기능을 사용하여 구성 할 수있는 옵션은 하나뿐입니다. ( &lt;a href=&quot;c_vtab_constraint_support#sqlitevtabconstraintsupport&quot;&gt;SQLITE_VTAB_CONSTRAINT_SUPPORT를&lt;/a&gt; 참조하십시오 .) 나중에 추가 옵션이 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="598f95760d8ef9fc04e0c94379f28c6b7cd53470" translate="yes" xml:space="preserve">
          <source>At the beginning of a cache spill, the status of the database connection is as shown in &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Original page content has been saved in the rollback journal and modifications of the pages exist in user memory. To spill the cache, SQLite executes steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; through &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt;. In other words, the rollback journal is flushed to disk, an exclusive lock is acquired, and changes are written into the database. But the remaining steps are deferred until the transaction really commits. A new journal header is appended to the end of the rollback journal (in its own sector) and the exclusive database lock is retained, but otherwise processing returns to &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. When the transaction commits, or if another cache spill occurs, steps &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; and &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; are repeated. (Step &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; is omitted on second and subsequent passes since an exclusive database lock is already held due to the first pass.)</source>
          <target state="translated">캐시 유출이 시작될 때 데이터베이스 연결 상태는 &lt;a href=&quot;#section_3_6&quot;&gt;3.6 단계와 같습니다&lt;/a&gt; . 원본 페이지 내용이 롤백 저널에 저장되었으며 페이지 수정 사항이 사용자 메모리에 있습니다. 캐시를 흘리기 위해 SQLite는 &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; 에서 &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; 단계를 실행합니다 . 즉, 롤백 저널이 디스크로 플러시되고 독점 잠금이 획득되고 변경 사항이 데이터베이스에 기록됩니다. 그러나 나머지 단계는 트랜잭션이 실제로 커밋 될 때까지 연기됩니다. 새로운 저널 헤더가 (자체 섹터에있는) 롤백 저널의 끝에 추가되고 배타적 데이터베이스 잠금은 유지되지만 그렇지 않으면 처리는 &lt;a href=&quot;#section_3_6&quot;&gt;3.6 단계로&lt;/a&gt; 돌아갑니다 . 트랜잭션이 커밋되거나 다른 캐시 유출이 발생하면 &lt;a href=&quot;#section_3_7&quot;&gt;3.7&lt;/a&gt; 단계및 &lt;a href=&quot;#section_3_9&quot;&gt;3.9&lt;/a&gt; 반복한다. 배타적 데이터베이스 잠금이 첫 번째 패스로 인해 이미 보유되었으므로 &lt;a href=&quot;#section_3_8&quot;&gt;3.8&lt;/a&gt; 단계 는 두 번째 및 후속 패스에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a07c0967c09d3dbc3e32b1c4ad8479eec1c47ba2" translate="yes" xml:space="preserve">
          <source>At this point you are ready to type &quot;&lt;code&gt;./configure; make&lt;/code&gt;&quot; (or on Windows with MSVC, &quot;&lt;code&gt;nmake /f Makefile.msc&lt;/code&gt;&quot;).</source>
          <target state="translated">이제 &quot; &lt;code&gt;./configure; make&lt;/code&gt; &quot;(또는 MSVC가있는 Windows의 경우 &quot; &lt;code&gt;nmake /f Makefile.msc&lt;/code&gt; &quot;) 를 입력 할 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5d9739e0c9d62ebb2f85f2435395edecdd3fc346" translate="yes" xml:space="preserve">
          <source>At this point, you can measure the amount of disk space used by the test1.db database and the space used by the test1.dir directory and all of its content. On a standard Ubuntu Linux desktop, the database file will be 1,024,512,000 bytes in size and the test1.dir directory will use 1,228,800,000 bytes of space (according to &quot;du -k&quot;), about 20% more than the database.</source>
          <target state="translated">이 시점에서 test1.db 데이터베이스가 사용하는 디스크 공간과 test1.dir 디렉토리가 사용하는 공간 및 모든 컨텐츠를 측정 할 수 있습니다. 표준 Ubuntu Linux 데스크탑에서 데이터베이스 파일의 크기는 1,024,512,000 바이트이며 test1.dir 디렉토리는 1,228,800,000 바이트의 공간 ( &quot;du -k&quot;에 따라)을 데이터베이스보다 약 20 % 더 많이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="05593853b78d4288d0ab3317d42f66fcc3356044" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the VDBE well enough to figure out on your own how the above program works. So we will not discuss it further in this text.</source>
          <target state="translated">이 시점에서 VDBE를 잘 이해하여 위 프로그램의 작동 방식을 스스로 파악해야합니다. 따라서 우리는이 본문에서 더 이상 논의하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ed93611b051b3f2ce2f2e18dd2aa20d02819e82" translate="yes" xml:space="preserve">
          <source>At this point, you should understand the basics of how the VDBE writes to a database. Now let's look at how it does queries. We will use the following simple SELECT statement as our example:</source>
          <target state="translated">이 시점에서 VDBE가 데이터베이스에 쓰는 방법의 기본 사항을 이해해야합니다. 이제 어떻게 쿼리를하는지 봅시다. 다음 간단한 SELECT 문을 예제로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ca131936c53e26b047834300b8b5909015686af9" translate="yes" xml:space="preserve">
          <source>At this time SQLite supports only FOR EACH ROW triggers, not FOR EACH STATEMENT triggers. Hence explicitly specifying FOR EACH ROW is optional. FOR EACH ROW implies that the SQL statements specified in the trigger may be executed (depending on the WHEN clause) for each database row being inserted, updated or deleted by the statement causing the trigger to fire.</source>
          <target state="translated">현재 SQLite는 FOR EACH STATEMENT 트리거가 아닌 FOR EACH ROW 트리거 만 지원합니다. 따라서 FOR EACH ROW를 명시 적으로 지정하는 것은 선택 사항입니다. FOR EACH ROW는 트리거에 지정된 SQL 문이 명령문에 의해 삽입, 갱신 또는 삭제되는 각 데이터베이스 행에 대해 트리거에 지정된 SQL 문이 실행될 수 있음을 나타냅니다 (WHEN 절에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="9f2f2ddc27722f56f60ce157d4213f6b2caed0bd" translate="yes" xml:space="preserve">
          <source>At this writing, 2050 is still 34 years in the future. Nobody knows what will happen in that time, and we cannot absolutely promise that SQLite will be viable or useful that far out. But we can promise this: we plan as if we will be supporting SQLite until 2050. That long-term outlook affects our decisions in important ways.</source>
          <target state="translated">이 글을 쓰는 시점에서 2050 년은 여전히 ​​34 년입니다. 그 당시에 어떤 일이 일어날 지 아무도 모르며, SQLite가 멀리서도 가능하거나 유용 할 것이라고 절대 약속 할 수는 없습니다. 그러나 우리는 이것을 약속 할 수 있습니다. 2050 년까지 SQLite를 지원할 계획입니다. 이러한 장기적인 전망은 중요한 방식으로 의사 결정에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="5dc594be0856868f818e54abe920fd51cc599639" translate="yes" xml:space="preserve">
          <source>Atomic Commit In SQLite</source>
          <target state="translated">SQLite의 원자 커밋</target>
        </trans-unit>
        <trans-unit id="2d4c9569233db52020accb44326c29045c8c4cce" translate="yes" xml:space="preserve">
          <source>Atomic Transactions</source>
          <target state="translated">원자 거래</target>
        </trans-unit>
        <trans-unit id="01c8139f3cad23c8756bfadca13473ed3a8e76ee" translate="yes" xml:space="preserve">
          <source>Atomic commits for ATTACHed databases.</source>
          <target state="translated">첨부 된 데이터베이스에 대한 원자 커밋.</target>
        </trans-unit>
        <trans-unit id="92dd7a0665a3434edc8f121885515c600f18e15b" translate="yes" xml:space="preserve">
          <source>Attach A Table To A Session Object</source>
          <target state="translated">세션 객체에 테이블 첨부</target>
        </trans-unit>
        <trans-unit id="4d752510d48bfeb2c136d1e65419fdd66d0835e6" translate="yes" xml:space="preserve">
          <source>Attempt To Free Heap Memory</source>
          <target state="translated">힙 메모리를 비우려고 시도</target>
        </trans-unit>
        <trans-unit id="88ccf4926dcde2d4398cadb109fcd1c1c1205d36" translate="yes" xml:space="preserve">
          <source>Attempt to optimize the database. All schemas are optimized in the first two forms, and only the specified schema is optimized in the latter two.</source>
          <target state="translated">데이터베이스를 최적화하십시오. 모든 스키마는 처음 두 가지 형식으로 최적화되며 지정된 스키마 만 두 가지 형식으로 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="72b5f89658d37542e4f2f47adfbbada66e9f74c3" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">가장 최근의 I / O 오류 또는 파일 열기 실패의 원인이 된 기본 운영 체제 오류 코드 또는 오류 번호를 리턴하려고 시도하십시오. 반환 값은 OS에 따라 다릅니다. 예를 들어, UNIX 시스템에서 &lt;a href=&quot;#sqlite3_open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 가 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_CANTOPEN을&lt;/a&gt; 리턴 한 후이 인터페이스를 호출하여 ENOSPC, EAUTH, EISDIR 등과 같은 문제점을 야기한 기본 &quot;errno&quot;를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50dfefcf7c07518a2714e6179a3b3e2c44246560" translate="yes" xml:space="preserve">
          <source>Attempt to return the underlying operating system error code or error number that caused the most recent I/O error or failure to open a file. The return value is OS-dependent. For example, on unix systems, after &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; returns &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN&lt;/a&gt;, this interface could be called to get back the underlying &quot;errno&quot; that caused the problem, such as ENOSPC, EAUTH, EISDIR, and so forth.</source>
          <target state="translated">가장 최근의 I / O 오류 또는 파일 열기 실패의 원인이 된 기본 운영 체제 오류 코드 또는 오류 번호를 리턴하려고 시도하십시오. 반환 값은 OS에 따라 다릅니다. 예를 들어, UNIX 시스템에서 &lt;a href=&quot;open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 가 &lt;a href=&quot;../rescode#cantopen&quot;&gt;SQLITE_CANTOPEN을&lt;/a&gt; 리턴 한 후이 인터페이스를 호출하여 ENOSPC, EAUTH, EISDIR 등과 같은 문제점을 야기한 기본 &quot;errno&quot;를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316c0eb6ee34ebe2465e653e0615de6cea48d923" translate="yes" xml:space="preserve">
          <source>Attempting to read any column value except the rowid from a contentless FTS5 table returns an SQL NULL value.</source>
          <target state="translated">컨텐츠가없는 FTS5 테이블에서 rowid를 제외한 모든 열 값을 읽으려고하면 SQL NULL 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="759ff226aedc6e7693575bc9de2859284a195a00" translate="yes" xml:space="preserve">
          <source>Attempts to signal a waiting thread.</source>
          <target state="translated">대기중인 스레드에 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="70c4d17e8ff8b4302eac4e4e2a0df21e83e7e1f7" translate="yes" xml:space="preserve">
          <source>Attribute to God, and not to self, whatever good you see in yourself.</source>
          <target state="translated">자신이 보는 선이 무엇이든 자기 자신이 아니라 신을 대리하십시오.</target>
        </trans-unit>
        <trans-unit id="825e25e0e089626089745a27ce2ef2c2c1ea38e6" translate="yes" xml:space="preserve">
          <source>Authorizer Action Codes</source>
          <target state="translated">권한 부 여자 조치 코드</target>
        </trans-unit>
        <trans-unit id="1592d27599a37fb2c21560009556822d633223ac" translate="yes" xml:space="preserve">
          <source>Authorizer Return Codes</source>
          <target state="translated">권한 부 여자 리턴 코드</target>
        </trans-unit>
        <trans-unit id="8d4b099d8f18d61aaa97d7c1192205d9f09f6d1b" translate="yes" xml:space="preserve">
          <source>Authorizer callback now notified of ALTER TABLE ADD COLUMN commands</source>
          <target state="translated">ALTER TABLE ADD COLUMN 명령을 알리는 권한 부 여자 콜백</target>
        </trans-unit>
        <trans-unit id="f99108c69c3665b09cc818cd43a65b08e779b2ac" translate="yes" xml:space="preserve">
          <source>Auto-vacuuming is only possible if the database stores some additional information that allows each database page to be traced backwards to its referrer. Therefore, auto-vacuuming must be turned on before any tables are created. It is not possible to enable or disable auto-vacuum after a table has been created.</source>
          <target state="translated">데이터베이스는 각 데이터베이스 페이지를 참조 자까지 역 추적 할 수있는 추가 정보를 데이터베이스에 저장 한 경우에만 자동 진공 청소가 가능합니다. 따라서 테이블을 작성하기 전에 자동 진공 청소기를 켜야합니다. 테이블이 생성 된 후 자동 진공을 활성화 또는 비활성화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20745b1bcf8af10b98b427193825b087099c77ec" translate="yes" xml:space="preserve">
          <source>AutoCommit</source>
          <target state="translated">AutoCommit</target>
        </trans-unit>
        <trans-unit id="356d8f675fe3749abf68433babe7ea3575fd985f" translate="yes" xml:space="preserve">
          <source>Autocheckpointing is enabled by default with an interval of 1000 or &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt;.</source>
          <target state="translated">자동 검사 점은 기본적으로 1000 간격 또는 &lt;a href=&quot;compile#default_wal_autocheckpoint&quot;&gt;SQLITE_DEFAULT_WAL_AUTOCHECKPOINT&lt;/a&gt; 간격으로 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="22f681c869bb1ea71c5ddca4b639af93b4fef9e9" translate="yes" xml:space="preserve">
          <source>Autoincrement now works for INSERT from a SELECT.</source>
          <target state="translated">자동 증가는 이제 SELECT에서 INSERT에 작동합니다.</target>
        </trans-unit>
        <trans-unit id="be6b6b970c4ffe43f44cd98c8c080e19e0935d7d" translate="yes" xml:space="preserve">
          <source>Automatic Creation Of Triggers</source>
          <target state="translated">트리거 자동 생성</target>
        </trans-unit>
        <trans-unit id="b08dba6041d7d4235968c19294ed55fda427f921" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo Using SQLite</source>
          <target state="translated">SQLite를 사용하여 자동 실행 취소 / 다시 실행</target>
        </trans-unit>
        <trans-unit id="e4c6cb294be7b858504d17f8ae3afc2b1d34ca14" translate="yes" xml:space="preserve">
          <source>Automatic Undo/Redo With SQLite</source>
          <target state="translated">SQLite를 사용한 자동 실행 취소 / 다시 실행</target>
        </trans-unit>
        <trans-unit id="21544829b41ef1983cd743adcc40b46678a3e3f5" translate="yes" xml:space="preserve">
          <source>Automatic caching of prepared statements in the TCL interface</source>
          <target state="translated">TCL 인터페이스에서 준비된 명령문의 자동 캐싱</target>
        </trans-unit>
        <trans-unit id="5c31289d03ed4b24b0edaf412e508ce77bc130da" translate="yes" xml:space="preserve">
          <source>Automatic indexing</source>
          <target state="translated">자동 인덱싱</target>
        </trans-unit>
        <trans-unit id="b33bad308a6a3f5703b3375cd2f0464df392fd4f" translate="yes" xml:space="preserve">
          <source>Automatically Load Statically Linked Extensions</source>
          <target state="translated">정적으로 연결된 확장 프로그램 자동로드</target>
        </trans-unit>
        <trans-unit id="1866c31db7344041c61c845f3e6c7f6209984d28" translate="yes" xml:space="preserve">
          <source>Automatically Running ANALYZE</source>
          <target state="translated">자동 실행 분석</target>
        </trans-unit>
        <trans-unit id="4babc7f522c90b701f1e40024660f0e6d3fdb828" translate="yes" xml:space="preserve">
          <source>Automatically build binaries for Linux and Windows and put them on the website.</source>
          <target state="translated">Linux 및 Windows 용 바이너리를 자동으로 빌드하여 웹 사이트에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="b5a9f83671a7145cd855649b0b10c0da797dd48a" translate="yes" xml:space="preserve">
          <source>Automatically generated ROWIDs are now sequential.</source>
          <target state="translated">자동 생성 된 ROWID는 이제 순차적입니다.</target>
        </trans-unit>
        <trans-unit id="33b507ce65fb930f163c0cce40902e91ce9a4aa2" translate="yes" xml:space="preserve">
          <source>Automatically intercepts the raw &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output and reformats it into an ASCII-art graph.</source>
          <target state="translated">원시 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 출력을 자동으로 가로 채서 ASCII 아트 그래프로 다시 포맷합니다.</target>
        </trans-unit>
        <trans-unit id="415678a6fe9db48ebfdb4a92834062e2d75ff761" translate="yes" xml:space="preserve">
          <source>Automatically running ANALYZE</source>
          <target state="translated">ANALYZE 자동 실행</target>
        </trans-unit>
        <trans-unit id="38a90bc3ee0845edb1d6db34dc8f58cfefb8e89a" translate="yes" xml:space="preserve">
          <source>Autovacuum support added</source>
          <target state="translated">Autovacuum 지원 추가</target>
        </trans-unit>
        <trans-unit id="1e357312422cd5ec59a0a1ff553c35208f6f0981" translate="yes" xml:space="preserve">
          <source>Auxiliary Function Changes</source>
          <target state="translated">보조 기능 변경</target>
        </trans-unit>
        <trans-unit id="2291a1b828f145bde8901e514ec4c748f1d3e7aa" translate="yes" xml:space="preserve">
          <source>Auxiliary columns are marked with a &quot;+&quot; symbol before the column name. Auxiliary columns must come after all of the coordinate boundary columns. There is a limit of no more than 100 auxiliary columns. The following example shows an r-tree table with auxiliary columns that is equivalent to the two tables &quot;demo_index&quot; and &quot;demo_data&quot; above:</source>
          <target state="translated">보조 열은 열 이름 앞에 &quot;+&quot;기호로 표시됩니다. 보조 열은 모든 좌표 경계 열 뒤에 와야합니다. 보조 열은 100 개 이하로 제한됩니다. 다음 예는 위의 두 테이블 &quot;demo_index&quot;및 &quot;demo_data&quot;에 해당하는 보조 열이있는 r- 트리 테이블을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="107b868f1f6fb032b0de401c1fdc39f9a1324503" translate="yes" xml:space="preserve">
          <source>Auxiliary columns in r-tree tables</source>
          <target state="translated">r- 트리 테이블의 보조 열</target>
        </trans-unit>
        <trans-unit id="6771e220703ae7d95117926a910b1882f3865ed2" translate="yes" xml:space="preserve">
          <source>Auxiliary function mapping</source>
          <target state="translated">보조 기능 매핑</target>
        </trans-unit>
        <trans-unit id="2a6030396538d218b7dda424404dbcc0322cf175" translate="yes" xml:space="preserve">
          <source>Auxiliary functions are similar to &lt;a href=&quot;lang_corefunc&quot;&gt;SQL scalar functions&lt;/a&gt;, except that they may only be used within full-text queries (those that use the MATCH operator) on an FTS5 table. Their results are calculated based not only on the arguments passed to them, but also on the current match and matched row. For example, an auxiliary function may return a numeric value indicating the accuracy of the match (see the &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25()&lt;/a&gt; function), or a fragment of text from the matched row that contains one or more instances of the search terms (see the &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;snippet()&lt;/a&gt; function).</source>
          <target state="translated">보조 함수는 FTS5 테이블의 전체 텍스트 쿼리 (MATCH 연산자를 사용하는 쿼리) 내에서만 사용할 수 있다는 점을 제외하고 &lt;a href=&quot;lang_corefunc&quot;&gt;SQL 스칼라 함수&lt;/a&gt; 와 유사 합니다. 결과는 전달 된 인수뿐만 아니라 현재 일치 및 일치하는 행을 기반으로 계산됩니다. 예를 들어 보조 함수는 일치 정확도를 나타내는 숫자 값 ( &lt;a href=&quot;fts5#the_bm25_function&quot;&gt;bm25 ()&lt;/a&gt; 함수 참조) 또는 하나 이상의 검색어 인스턴스를 포함하는 일치하는 행의 텍스트 조각을 반환 할 수 있습니다 ( &lt;a href=&quot;fts5#the_snippet_function&quot;&gt;스 니펫 ( )&lt;/a&gt; 기능).</target>
        </trans-unit>
        <trans-unit id="ad21e0c1521884ee05b9ffda048d19b6293bf5a4" translate="yes" xml:space="preserve">
          <source>Available as a &lt;a href=&quot;amalgamation&quot;&gt;single ANSI-C source-code file&lt;/a&gt; that is &lt;a href=&quot;howtocompile&quot;&gt;easy to compile&lt;/a&gt; and hence is easy to add into a larger project.</source>
          <target state="translated">A와 가능한 &lt;a href=&quot;amalgamation&quot;&gt;한 ANSI-C 소스 코드 파일&lt;/a&gt; 입니다 &lt;a href=&quot;howtocompile&quot;&gt;컴파일하기 쉽고&lt;/a&gt; 따라서 더 큰 프로젝트에 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91da5ef1fa7e2e4b29d2c4baf5ea203498773356" translate="yes" xml:space="preserve">
          <source>Avoid a possible use-after-free error by deferring schema resets until after the query planner has finished running. Ticket &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;be436a7f4587ce5&lt;/a&gt;</source>
          <target state="translated">쿼리 플래너 실행이 완료 될 때까지 스키마 재설정을 연기하여 사용 후 사용 가능 오류를 피하십시오. 티켓 &lt;a href=&quot;https://sqlite.org/src/info/be436a7f4587ce5&quot;&gt;BE436A7F4587CE5&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e3177c978c905dc59ea3eac3bcce9510d2af169" translate="yes" xml:space="preserve">
          <source>Avoid cache pages leaks following disk-full or I/O errors</source>
          <target state="translated">디스크 가득 참 또는 I / O 오류로 인한 캐시 페이지 누출 방지</target>
        </trans-unit>
        <trans-unit id="61ddd5eec59e56887e4ac83b6d688d5421fe618d" translate="yes" xml:space="preserve">
          <source>Avoid excess heap usage when copying expressions.</source>
          <target state="translated">표현식을 복사 할 때 과도한 힙 사용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="24ba1f7d7979447a7e96cb25e07064d86e5bb1c8" translate="yes" xml:space="preserve">
          <source>Avoid invoking the &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace()&lt;/a&gt; callback multiple times when a statement is automatically reprepared due to &lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; errors.</source>
          <target state="translated">&lt;a href=&quot;rescode#schema&quot;&gt;SQLITE_SCHEMA&lt;/a&gt; 오류 로 인해 명령문이 자동으로 다시 준비 될 때 &lt;a href=&quot;c3ref/profile&quot;&gt;sqlite3_trace ()&lt;/a&gt; 콜백을 여러 번 호출하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="7080f3e1eff1f709a6ca19cf689cc05b5715bf56" translate="yes" xml:space="preserve">
          <source>Avoid recomputing &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; and &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraints&lt;/a&gt; on unchanged columns in &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문 에서 변경되지 않은 열에 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; 및 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제한 조건&lt;/a&gt; 을 다시 계산 하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b9f47e376b982a42c816c624a45b787e38257b92" translate="yes" xml:space="preserve">
          <source>Avoid resetting the schema of &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt; connections when any one connection closes. Instead, wait for the last connection to close before resetting the schema.</source>
          <target state="translated">하나의 연결이 닫힐 때 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 연결 의 스키마를 재설정하지 마십시오 . 대신 스키마를 재설정하기 전에 마지막 연결이 닫힐 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="d3426fcb94fc158c5d46e9b08cc237640ca2e54e" translate="yes" xml:space="preserve">
          <source>Avoid running foreign-key constraint checks on an UPDATE if none of the modified columns are associated with foreign keys.</source>
          <target state="translated">수정 된 열이 외래 키와 연결되어 있지 않으면 UPDATE에서 외래 키 제약 조건 검사를 실행하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fc8f5db6ab5f0aaaf5afe5d9db180abf76160161" translate="yes" xml:space="preserve">
          <source>Avoid this step if possible, as it defeats one of the huge advantages of the whole SQL language concept, specifically that the application programmer does not need to get involved with query planning. If you do use CROSS JOIN, wait until late in your development cycle to do so, and comment the use of CROSS JOIN carefully so that you can take it out later if possible. Avoid using CROSS JOIN early in the development cycle as doing so is a premature optimization, which is well known to be &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;the root of all evil&lt;/a&gt;.</source>
          <target state="translated">전체 SQL 언어 개념의 큰 장점 중 하나, 특히 응용 프로그램 프로그래머가 쿼리 계획에 관여 할 필요가 없다는 점을 무시하므로 가능하면이 단계를 피하십시오. CROSS JOIN을 사용하는 경우 개발주기가 늦을 때까지 기다렸다가 나중에 CROSS JOIN을 사용할 수 있도록주의하여 사용하십시오. 개발주기 초기에 CROSS JOIN을 사용하지 마십시오. 조기 최적화 &lt;a href=&quot;http://c2.com/cgi/wiki?PrematureOptimization&quot;&gt;는 모든 악의 근원으로&lt;/a&gt; 잘 알려져 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d522f897af88e992f364f85aee2e8282258fc265" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary foreign key processing in UPDATE statements that do not touch the columns that are constrained by the foreign keys.</source>
          <target state="translated">외래 키로 제한되는 열을 건드리지 않는 UPDATE 문에서 불필요한 외래 키 처리를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="f0262f30f0e72ef13d068b5ef0d92433c9097800" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary invalidation of &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; handles when making changes to unrelated tables.</source>
          <target state="translated">관련이없는 테이블을 변경할 때 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 핸들 의 불필요한 무효화를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="2faf372496683418fb5422fedd49afd1602aeb2d" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary loads of columns in an aggregate query that are not within an aggregate function and that are not part of the GROUP BY clause.</source>
          <target state="translated">집계 함수 내에없고 GROUP BY 절의 일부가 아닌 집계 쿼리에서 불필요한 열로드를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="0da85f25c4d81aabb9be26649b6528ed9da5a865" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary reparsing of the database schema.</source>
          <target state="translated">데이터베이스 스키마의 불필요한 재분석을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="31ab1c695488dd1d3fd9d54bae9338af8b817457" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary writes to the sqlite_sequence table when an &lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; table is updated with an rowid that is less than the maximum.</source>
          <target state="translated">&lt;a href=&quot;autoinc&quot;&gt;AUTOINCREMENT&lt;/a&gt; 테이블이 최대 값보다 작은 rowid로 업데이트 될 때 sqlite_sequence 테이블에 대한 불필요한 쓰기를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="446e18ff4fd4514774047f13cdefc3e3875bc4b1" translate="yes" xml:space="preserve">
          <source>Avoid using a prepared statement for &quot;.stats on&quot; command of the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; after it has been closed by the &quot;.eqp full&quot; logicc. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76&lt;/a&gt;.</source>
          <target state="translated">&quot;.eqp full&quot;logicc에 의해 닫힌 &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt; 의 &quot;.stats on&quot;명령에 대해 준비된 명령문을 사용하지 마십시오 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7be932dfa60a8a6b3b26bcf76&quot;&gt;7be932dfa60a8a6b3b26bcf76에&lt;/a&gt; 대한 수정 .</target>
        </trans-unit>
        <trans-unit id="e234fd1edb94740adc1207ebef38597b49b7c1f2" translate="yes" xml:space="preserve">
          <source>Avoiding the use of low-numbered file descriptors is a defense against accidental database corruption. If a database file was opened using file descriptor 2, for example, and then an assert() failed and invoked write(2,...), that would likely cause database corruption by overwriting part of the database file with the assertion error message. Using only higher-valued file descriptors avoids this potential problem. The protection against using low-numbered file descriptors can be disabled by setting this compile-time option to 0.</source>
          <target state="translated">번호가 낮은 파일 디스크립터를 사용하지 않는 것은 우발적 인 데이터베이스 손상을 방지합니다. 예를 들어 파일 디스크립터 2를 사용하여 데이터베이스 파일을 연 다음 assert ()가 실패하고 write (2, ...)를 호출 한 경우 데이터베이스 파일의 일부를 어설 션 오류 메시지로 겹쳐 써서 데이터베이스가 손상 될 수 있습니다. . 가치가 높은 파일 디스크립터 만 사용하면이 잠재적 인 문제를 피할 수 있습니다. 이 컴파일 타임 옵션을 0으로 설정하면 낮은 번호의 파일 디스크립터를 사용하지 못하도록 보호 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4253b60bc870d118d832ba2a3c8eabe133ebeb0" translate="yes" xml:space="preserve">
          <source>Aways stores polygons using the binary format, which is faster and uses less space.</source>
          <target state="translated">자리 비움은 이진 형식을 사용하여 다각형을 저장하므로 더 빠르고 공간을 덜 사용합니다.</target>
        </trans-unit>
        <trans-unit id="209ebb59c54866e4ac4c2bdf04c9d0b7b4a958ec" translate="yes" xml:space="preserve">
          <source>B-Tree</source>
          <target state="translated">B-Tree</target>
        </trans-unit>
        <trans-unit id="b149afb9ac3420444ce1e62aefbcdead10e7e777" translate="yes" xml:space="preserve">
          <source>B-tree</source>
          <target state="translated">B-tree</target>
        </trans-unit>
        <trans-unit id="5b87dc158f4c367648401e86eddf1c6445bb5bf6" translate="yes" xml:space="preserve">
          <source>B-tree Cell Format</source>
          <target state="translated">B- 트리 셀 형식</target>
        </trans-unit>
        <trans-unit id="92950af5441bd3255130ef7a72cc86532e49b1e9" translate="yes" xml:space="preserve">
          <source>B-tree Page Header Format</source>
          <target state="translated">B- 트리 페이지 헤더 형식</target>
        </trans-unit>
        <trans-unit id="90a72ea1d2706a588dd39ad58e7cba99ec26696d" translate="yes" xml:space="preserve">
          <source>BEFORE</source>
          <target state="translated">BEFORE</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="4821edeb87e72ffadc6bc2dd7758d1af495e515f" translate="yes" xml:space="preserve">
          <source>BEGIN IMMEDIATE</source>
          <target state="translated">시작 즉시</target>
        </trans-unit>
        <trans-unit id="8913dda08c8185748e987da82c484c6d35030cb9" translate="yes" xml:space="preserve">
          <source>BEGIN TRANSACTION</source>
          <target state="translated">거래 시작</target>
        </trans-unit>
        <trans-unit id="51b1b0c3e98b1211a4bf44a668731efbeb0029e7" translate="yes" xml:space="preserve">
          <source>BEGIN;</source>
          <target state="translated">BEGIN;</target>
        </trans-unit>
        <trans-unit id="f8e3370718865431368fd54f746d7da4322cc582" translate="yes" xml:space="preserve">
          <source>BETWEEN</source>
          <target state="translated">BETWEEN</target>
        </trans-unit>
        <trans-unit id="2d0fe684054a53889de74128877e23cf3189b322" translate="yes" xml:space="preserve">
          <source>BIGINT</source>
          <target state="translated">BIGINT</target>
        </trans-unit>
        <trans-unit id="d05fb01e0b399387c3a28586f5fd296e2670d6a3" translate="yes" xml:space="preserve">
          <source>BINARY</source>
          <target state="translated">BINARY</target>
        </trans-unit>
        <trans-unit id="1ce04f29dadb9973458555f164627f66e504686e" translate="yes" xml:space="preserve">
          <source>BLOB</source>
          <target state="translated">BLOB</target>
        </trans-unit>
        <trans-unit id="21ca9d91ce78c58717f1f26654ca03e2a7b624ba" translate="yes" xml:space="preserve">
          <source>BLOB (a.k.a &quot;NONE&quot;)</source>
          <target state="translated">BLOB (일명 &quot;NONE&quot;)</target>
        </trans-unit>
        <trans-unit id="16304f06bca682f9f5ee4a2a62fcbf2abac5ed50" translate="yes" xml:space="preserve">
          <source>BLOB literals are string literals containing hexadecimal data and preceded by a single &quot;x&quot; or &quot;X&quot; character. Example: X'53514C697465'</source>
          <target state="translated">BLOB 리터럴은 16 진 데이터를 포함하고 단일 &quot;x&quot;또는 &quot;X&quot;문자가 앞에 오는 문자열 리터럴입니다. 예 : X'53514C697465 '</target>
        </trans-unit>
        <trans-unit id="fb465d6672ffe8826d619cf7ad2f842e941cbb22" translate="yes" xml:space="preserve">
          <source>BLOB size</source>
          <target state="translated">BLOB 크기</target>
        </trans-unit>
        <trans-unit id="80845ed51d0eb2f39da54fe848593b51f5b7523f" translate="yes" xml:space="preserve">
          <source>BLOB support.</source>
          <target state="translated">BLOB 지원.</target>
        </trans-unit>
        <trans-unit id="9bf36d55a66f6b65f2497e6f96eb9c688f9ee788" translate="yes" xml:space="preserve">
          <source>BLOB values (even serial types 12 and larger) sort last and in the order determined by memcmp().</source>
          <target state="translated">BLOB 값 (직렬 유형 12 이상)도 memcmp ()에 의해 결정된 순서대로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="066ed32331b295c453ee3f4c55916aa0d7c725b0" translate="yes" xml:space="preserve">
          <source>BLOBs sort last</source>
          <target state="translated">BLOB 마지막 정렬</target>
        </trans-unit>
        <trans-unit id="ab68d8e893a82cff70979ba20bec0023dbfe4be3" translate="yes" xml:space="preserve">
          <source>BOOLEAN</source>
          <target state="translated">BOOLEAN</target>
        </trans-unit>
        <trans-unit id="64c3f5e89864d5e803ba483fadc3c80068321744" translate="yes" xml:space="preserve">
          <source>BY</source>
          <target state="translated">BY</target>
        </trans-unit>
        <trans-unit id="987f01f766f58cd662fc3c685393d0d4667cbc0b" translate="yes" xml:space="preserve">
          <source>Back up cursor P1 so that it points to the previous key/data pair in its table or index. If there is no previous key/value pairs then fall through to the following instruction. But if the cursor backup was successful, jump immediately to P2.</source>
          <target state="translated">테이블 또는 인덱스의 이전 키 / 데이터 쌍을 가리 키도록 커서 P1을 백업하십시오. 이전 키 / 값 쌍이없는 경우 다음 명령어로 넘어갑니다. 그러나 커서 백업에 성공하면 즉시 P2로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="f09881dbbda2f40a1bff480104e690d3c9470795" translate="yes" xml:space="preserve">
          <source>Backport a &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;simple query planner optimization&lt;/a&gt; that allows the IS operator to drive an index on a LEFT OUTER JOIN. No other changes from the &lt;a href=&quot;#version_3_9_2&quot;&gt;version 3.9.2&lt;/a&gt; baseline.</source>
          <target state="translated">IS 연산자가 LEFT OUTER JOIN에서 인덱스를 구동 할 수 있도록 하는 &lt;a href=&quot;https://www.sqlite.org/src/info/c648539b52ca28c0&quot;&gt;간단한 쿼리 플래너 최적화&lt;/a&gt; 를 백 포트합니다 . &lt;a href=&quot;#version_3_9_2&quot;&gt;버전 3.9.2&lt;/a&gt; 기준 과 다른 변경 사항은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="88c7762ebd772cef5a8b0f5dbf885740af02d796" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">백업 A : &lt;a href=&quot;https://www2.sqlite.org/docsrc&quot;&gt;https://www2.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3758d4866043fb72f7921be565221b2798bf18ec" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">백업 A : &lt;a href=&quot;https://www2.sqlite.org/src&quot;&gt;https://www2.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5635a7bbe580f297d0f1cfe698eb39a60af249f7" translate="yes" xml:space="preserve">
          <source>Backup A: &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">백업 A : &lt;a href=&quot;https://www2.sqlite.org/th3&quot;&gt;https://www2.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="354ff6f3afacd7c64aab0b45ca232e39fd5ab191" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</source>
          <target state="translated">백업 B : &lt;a href=&quot;https://www3.sqlite.org/docsrc&quot;&gt;https://www3.sqlite.org/docsrc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a437cf7f4394ac5ab3c8c6bf1f4decbf817f299c" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</source>
          <target state="translated">백업 B : &lt;a href=&quot;https://www3.sqlite.org/src&quot;&gt;https://www3.sqlite.org/src&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06b0bc099757fb937c2145628c4ebe2caf89fed6" translate="yes" xml:space="preserve">
          <source>Backup B: &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</source>
          <target state="translated">백업 B : &lt;a href=&quot;https://www3.sqlite.org/th3&quot;&gt;https://www3.sqlite.org/th3&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad652023d4f99d0238bf9d42108eaead0a853d3a" translate="yes" xml:space="preserve">
          <source>Backup-filename</source>
          <target state="translated">Backup-filename</target>
        </trans-unit>
        <trans-unit id="8999e5aefef2d471c86fa4aebf649d22b2fddfc3" translate="yes" xml:space="preserve">
          <source>Backups on private servers</source>
          <target state="translated">개인 서버의 백업</target>
        </trans-unit>
        <trans-unit id="63591d4f03e6c8c8462a238e710f0f3cd900691f" translate="yes" xml:space="preserve">
          <source>Backwards compatibility constraints mean that SQLite is only able to store values that are NULL, integers, floating-point numbers, text, and BLOBs. It is not possible to add a sixth &quot;JSON&quot; type.</source>
          <target state="translated">이전 버전과의 호환성 제약 조건은 SQLite가 NULL, 정수, 부동 소수점 숫자, 텍스트 및 BLOB 값만 저장할 수 있음을 의미합니다. 여섯 번째 &quot;JSON&quot;유형을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac8e908309343005a016d54d23589bde15362521" translate="yes" xml:space="preserve">
          <source>Backwards compatibility note:</source>
          <target state="translated">이전 버전과의 호환성 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="70457c51de59bc0303eae7ef527e14f90b80a187" translate="yes" xml:space="preserve">
          <source>Backwards-incompatible changes to some extensions in order to take advantage of the improved security offered by the new &lt;a href=&quot;bindptr&quot;&gt;pointer passing interfaces&lt;/a&gt;:</source>
          <target state="translated">새로운 &lt;a href=&quot;bindptr&quot;&gt;포인터 전달 인터페이스&lt;/a&gt; 에서 제공하는 향상된 보안 기능을 활용하기 위해 일부 확장에 대한 이전 버전과 호환되지 않는 변경 사항 :</target>
        </trans-unit>
        <trans-unit id="af928fbbb6d75554958505ba9734eca9710f8051" translate="yes" xml:space="preserve">
          <source>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</source>
          <target state="translated">나쁜 프로그래머는 코드에 대해 걱정합니다. 훌륭한 프로그래머는 데이터 구조와 관계에 대해 걱정합니다.</target>
        </trans-unit>
        <trans-unit id="d97ded08ec4df20e52b3ce05668bb0a2705fa978" translate="yes" xml:space="preserve">
          <source>Bare aggregate terms</source>
          <target state="translated">베어 집계 용어</target>
        </trans-unit>
        <trans-unit id="5e2b9b9d48fdc95bbb5af1e6353dd4395e3738d9" translate="yes" xml:space="preserve">
          <source>Based on the above, SQLite is designed around a model of the file-system whereby any sector of a file written to is considered to be in a transient state until after the file has been successfully</source>
          <target state="translated">위의 내용을 기반으로 SQLite는 파일 시스템 모델을 중심으로 설계되었으므로 파일의 모든 섹터는 파일이 성공적으로 완료 될 때까지 일시적 상태로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="2843b17c6eb4616657b580040fb118c722f6edb6" translate="yes" xml:space="preserve">
          <source>Be a help in times of trouble.</source>
          <target state="translated">어려움에 처했을 때 도움을 받으십시오.</target>
        </trans-unit>
        <trans-unit id="d1a6a5570deb3a7eb7ea55daa060ee1c39dbe74c" translate="yes" xml:space="preserve">
          <source>Be a stranger to the world's ways.</source>
          <target state="translated">세상의 길에 낯선 사람이 되십시오.</target>
        </trans-unit>
        <trans-unit id="7fe99077b2a420989db9a6580456c2197461f868" translate="yes" xml:space="preserve">
          <source>Be careful when using the &quot;.save&quot; command as it will overwrite any preexisting database files having the same name without prompting for confirmation. As with the &quot;.open&quot; command, you might want to use a full pathname with forward-slash directory separators to avoid ambiguity.</source>
          <target state="translated">&quot;.save&quot;명령을 사용할 때는 확인을 요구하지 않고 동일한 이름을 가진 기존 데이터베이스 파일을 덮어 쓰므로주의하십시오. &quot;.open&quot;명령과 마찬가지로, 애매함을 피하기 위해 슬래시 디렉토리 구분 기호와 함께 전체 경로 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="131acb5be798f8713c6bbeeaf8a6813dbe81748d" translate="yes" xml:space="preserve">
          <source>Be in dread of hell.</source>
          <target state="translated">지옥을 두려워하십시오.</target>
        </trans-unit>
        <trans-unit id="dbdb220ba30f3bde62d258265aacea82a8c9ef6a" translate="yes" xml:space="preserve">
          <source>Be not a detractor.</source>
          <target state="translated">낙담하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d18586b20264d29baf4b88bd2bdc140f64986d83" translate="yes" xml:space="preserve">
          <source>Be not a great eater.</source>
          <target state="translated">훌륭한 먹는 사람이되지 마십시오.</target>
        </trans-unit>
        <trans-unit id="7c62076277d9f6b2639631bb528912ff4eff4ffa" translate="yes" xml:space="preserve">
          <source>Be not a grumbler.</source>
          <target state="translated">불평꾼이되지 마십시오.</target>
        </trans-unit>
        <trans-unit id="288a450b2fc66179cb51c9c9d0a00b7f03fc2121" translate="yes" xml:space="preserve">
          <source>Be not addicted to wine.</source>
          <target state="translated">와인에 중독되지 마십시오.</target>
        </trans-unit>
        <trans-unit id="30d66a95d2dfd76a1e01a40e31a7daa8f6db0117" translate="yes" xml:space="preserve">
          <source>Be not drowsy.</source>
          <target state="translated">졸리지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c8f81046cf302e1b08a651f45ee31005254461af" translate="yes" xml:space="preserve">
          <source>Be not jealous, nor harbor envy.</source>
          <target state="translated">질투하거나 부러워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="6f5bf647a944160204f29d66b6480eda5640fcdc" translate="yes" xml:space="preserve">
          <source>Be not lazy.</source>
          <target state="translated">게으르지 마십시오.</target>
        </trans-unit>
        <trans-unit id="1c899d6734a837258800bab2a2f7343b95199829" translate="yes" xml:space="preserve">
          <source>Be not proud.</source>
          <target state="translated">자랑스러워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9305ebf69b60c3d882da16805b530bbf3e6f3d95" translate="yes" xml:space="preserve">
          <source>Bear persecution for justice's sake.</source>
          <target state="translated">정의를 위해 박해를가하십시오.</target>
        </trans-unit>
        <trans-unit id="6ca5c28c37834244df00d49b68c2bef2606b1e1f" translate="yes" xml:space="preserve">
          <source>Because &quot;text&quot; columns have a different sort order from numeric, indices on &quot;text&quot; columns occur in a different order for version 2.7.0 and later database. Hence version 2.6.3 and earlier of SQLite will be unable to read a 2.7.0 or later database. But version 2.7.0 and later of SQLite will read earlier databases.</source>
          <target state="translated">&quot;텍스트&quot;열은 숫자와 정렬 순서가 다르기 때문에 &quot;텍스트&quot;열의 인덱스는 버전 2.7.0 이상의 데이터베이스에서 다른 순서로 발생합니다. 따라서 SQLite 2.6.3 및 이전 버전은 2.7.0 이상의 데이터베이스를 읽을 수 없습니다. 그러나 SQLite 버전 2.7.0 이상에서는 이전 데이터베이스를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="85eeb52404350645676cc7b1bb211e4acfd5ad5b" translate="yes" xml:space="preserve">
          <source>Because AUTOINCREMENT keyword changes the behavior of the ROWID selection algorithm, AUTOINCREMENT is not allowed on &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables or on any table column other than INTEGER PRIMARY KEY. Any attempt to use AUTOINCREMENT on a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table or on a column other than the INTEGER PRIMARY KEY column results in an error.</source>
          <target state="translated">AUTOINCREMENT 키워드는 ROWID 선택 알고리즘의 동작을 변경하므로 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 또는 INTEGER PRIMARY KEY 이외의 테이블 열에 는 AUTOINCREMENT가 허용되지 않습니다 . &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 또는 INTEGER PRIMARY KEY 컬럼 이외의 컬럼에서 AUTOINCREMENT를 사용하려고 하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eeb868502c2d293980db003c26a1d7e59cde0343" translate="yes" xml:space="preserve">
          <source>Because FTS3 and FTS4 are virtual tables, The &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; compile-time option is incompatible with the &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; option.</source>
          <target state="translated">FTS3 및 FTS4는 가상 테이블이므로 &lt;a href=&quot;compile#enable_fts3&quot;&gt;SQLITE_ENABLE_FTS3&lt;/a&gt; 컴파일 타임 옵션은 &lt;a href=&quot;compile#omit_virtualtable&quot;&gt;SQLITE_OMIT_VIRTUALTABLE&lt;/a&gt; 옵션 과 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4912d0649aa9ed8b2a285af375de29c2823b504b" translate="yes" xml:space="preserve">
          <source>Because Lemon is a program not normally found on development machines, the complete source code to Lemon (just one C file) is included in the SQLite distribution in the &quot;tool&quot; subdirectory.</source>
          <target state="translated">레몬은 일반적으로 개발 머신에서 찾을 수없는 프로그램이므로 레몬에 대한 완전한 소스 코드 (단 하나의 C 파일)는 &quot;tool&quot;서브 디렉토리의 SQLite 배포에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="89b4ac6aceecf052168be7879566274bb4b65047" translate="yes" xml:space="preserve">
          <source>Because ZIP archives are optimized for storing big chunks of content, they encourage a style of programming where the entire document is read into memory at startup, all editing occurs in memory, then the entire document is written to disk during &quot;File/Save&quot;. OpenOffice and its descendants embrace that pattern.</source>
          <target state="translated">ZIP 아카이브는 많은 양의 컨텐츠를 저장하는 데 최적화되어 있기 때문에 시작시 전체 문서를 메모리로 읽어들이는 모든 프로그래밍 방식을 메모리에서 읽은 다음 &quot;파일 / 저장&quot;중에 전체 문서를 디스크에 쓰는 프로그래밍 스타일을 권장합니다. OpenOffice와 그 후손들은 그 패턴을 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="1aef204394eb2f42a054518ac1383e25f6308e7c" translate="yes" xml:space="preserve">
          <source>Because allocations are all the same size, the memory allocator can operate much faster. The allocator need not bother with coalescing adjacent free slots or searching for a slot of an appropriate size. All unallocated memory slots can be stored on a linked list. Allocating consists of removing the first entry from the list. Deallocating is simply adding an entry to the beginning of the list.</source>
          <target state="translated">할당은 모두 같은 크기이므로 메모리 할당자는 훨씬 빠르게 작동 할 수 있습니다. 할당자는 인접한 빈 슬롯을 병합하거나 적절한 크기의 슬롯을 검색 할 필요가 없습니다. 할당되지 않은 모든 메모리 슬롯은 연결된 목록에 저장할 수 있습니다. 할당은 목록에서 첫 번째 항목을 제거하는 것으로 구성됩니다. 할당 해제는 단순히 목록의 시작 부분에 항목을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8fe792a90bccd6800bd67f3f37ebbaabb1467610" translate="yes" xml:space="preserve">
          <source>Because an SQLite database is a single compact file in a &lt;a href=&quot;fileformat2&quot;&gt;well-defined cross-platform format&lt;/a&gt;, it is often used as a container for transferring content from one system to another. The sender gathers content into an SQLite database file, transfers that one file to the receiver, then the receiver uses SQL to extract the content as needed.</source>
          <target state="translated">SQLite 데이터베이스는 &lt;a href=&quot;fileformat2&quot;&gt;잘 정의 된 크로스 플랫폼 형식&lt;/a&gt; 의 단일 압축 파일이기 때문에 종종 한 시스템에서 다른 시스템으로 컨텐츠를 전송하기위한 컨테이너로 사용됩니다. 송신자는 컨텐츠를 SQLite 데이터베이스 파일로 수집하고 해당 파일을 수신자에게 전송 한 다음 수신자는 SQL을 사용하여 필요에 따라 컨텐츠를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a4c1f92dc828402b18e6e117bb816b40d1c734ed" translate="yes" xml:space="preserve">
          <source>Because an SQLite database requires no administration, it works well in devices that must operate without expert human support. SQLite is a good fit for use in cellphones, set-top boxes, televisions, game consoles, cameras, watches, kitchen appliances, thermostats, automobiles, machine tools, airplanes, remote sensors, drones, medical devices, and robots: the &quot;internet of things&quot;.</source>
          <target state="translated">SQLite 데이터베이스는 관리가 필요하지 않으므로 전문가의 전문적인 지원없이 작동해야하는 장치에서 잘 작동합니다. SQLite는 휴대폰, 셋톱 박스, 텔레비전, 게임 콘솔, 카메라, 시계, 주방 용품, 온도 조절 장치, 자동차, 공작 기계, 비행기, 원격 센서, 드론, 의료 기기 및 로봇에 사용하기에 적합합니다. &quot;의.</target>
        </trans-unit>
        <trans-unit id="788be5cf964c9ee21f08ece0ea7377ef2e19234d" translate="yes" xml:space="preserve">
          <source>Because assert() can be and is commonly misused, some programming language theorists and designers look upon it with disfavor. For example, the designers of the &lt;a href=&quot;https://golang.org&quot;&gt;Go programming language&lt;/a&gt; intentionally &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;omit a built-in assert()&lt;/a&gt;. They feel that the harm caused by misuse of assert() outweighs the benefits of including it as a language built-in. The SQLite developers disagree. In fact, the original purpose of this article is to push back against the common notion that assert() is harmful. In our experience, SQLite would be much more difficult to develop, test, and maintain without assert().</source>
          <target state="translated">assert ()는 일반적으로 오용 될 수 있고 일반적으로 오용되기 때문에 일부 프로그래밍 언어 이론가와 디자이너는이를 선호하지 않습니다. 예를 들어 &lt;a href=&quot;https://golang.org&quot;&gt;Go 프로그래밍 언어&lt;/a&gt; 디자이너는 의도적 &lt;a href=&quot;https://golang.org/doc/faq#assertions&quot;&gt;으로 내장 assert ()를 생략합니다&lt;/a&gt; . 그들은 assert ()의 오용으로 인한 피해가 언어를 내장 언어로 포함시키는 것의 이점보다 중요하다고 생각합니다. SQLite 개발자는 동의하지 않습니다. 사실,이 기사의 원래 목적은 assert ()가 해롭다는 일반적인 개념에 반하여 반대하는 것입니다. 경험상 SQLite는 assert () 없이는 개발, 테스트 및 유지 관리가 훨씬 어려울 것입니다.</target>
        </trans-unit>
        <trans-unit id="a6c8b76107dc390feb365087dd23a9e6847d8ec8" translate="yes" xml:space="preserve">
          <source>Because it does not have a central server to coordinate access, SQLite must close and reopen the database file, and thus invalidate its cache, for each transaction. In this test, each SQL statement is a separate transaction so the database file must be opened and closed and the cache must be flushed 1000 times. In spite of this, the asynchronous version of SQLite is still nearly as fast as MySQL. Notice how much slower the synchronous version is, however. SQLite calls &lt;b&gt;fsync()&lt;/b&gt; after each synchronous transaction to make sure that all data is safely on the disk surface before continuing. For most of the 13 seconds in the synchronous test, SQLite was sitting idle waiting on disk I/O to complete.</source>
          <target state="translated">액세스를 조정하는 중앙 서버가 없기 때문에 SQLite는 데이터베이스 파일을 닫았다가 다시 열어야하므로 각 트랜잭션마다 캐시를 ​​무효화해야합니다. 이 테스트에서 각 SQL 문은 별도의 트랜잭션이므로 데이터베이스 파일을 열고 닫고 캐시를 1000 번 플러시해야합니다. 그럼에도 불구하고 SQLite의 비동기 버전은 여전히 ​​MySQL만큼 빠릅니다. 그러나 동기 버전이 얼마나 느리게 진행되는지 확인하십시오. SQLite는 각 동기화 트랜잭션 후에 &lt;b&gt;fsync ()를&lt;/b&gt; 호출 하여 계속하기 전에 모든 데이터가 디스크 표면에 안전하게 있는지 확인합니다. 동기 테스트에서 13 초 동안 대부분 SQLite는 디스크 I / O가 완료되기를 기다리면서 유휴 상태였습니다.</target>
        </trans-unit>
        <trans-unit id="44c3dab6a322e3be0dd40f52ec50b7f7abadf611" translate="yes" xml:space="preserve">
          <source>Because it is a simulator, running a binary in Valgrind is slower than running it on native hardware. (To a first approximation, an application running in Valgrind on a workstation will perform about the same as it would running natively on a smartphone.) So it is impractical to run the full SQLite test suite through Valgrind. However, the veryquick tests and the coverage of the TH3 tests are run through Valgrind prior to every release.</source>
          <target state="translated">시뮬레이터이기 때문에 Valgrind에서 바이너리를 실행하는 것이 기본 하드웨어에서 실행하는 것보다 느립니다. (첫 번째 근사치로 워크 스테이션에서 Valgrind에서 실행되는 응용 프로그램은 기본적으로 스마트 폰에서 실행되는 것과 거의 동일하게 수행됩니다.) 따라서 Valgrind를 통해 전체 SQLite 테스트 스위트를 실행하는 것은 비현실적입니다. 그러나 매우 빠른 테스트와 TH3 테스트의 적용 범위는 모든 릴리스 전에 Valgrind를 통해 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2d7f244d51b1fc8bd92e3755f3ff4412ae2f2b57" translate="yes" xml:space="preserve">
          <source>Because it is simple to setup and use (installation is trivial: just copy the &lt;b&gt;sqlite3&lt;/b&gt; or &lt;b&gt;sqlite3.exe&lt;/b&gt; executable to the target machine and run it) SQLite makes a good database engine for use in teaching SQL. Students can easily create as many databases as they like and can email databases to the instructor for comments or grading. For more advanced students who are interested in studying how an RDBMS is implemented, the modular and well-commented and documented SQLite code can serve as a good basis.</source>
          <target state="translated">설정 및 사용이 간단하기 때문에 (설치는 간단합니다. &lt;b&gt;sqlite3&lt;/b&gt; 또는 &lt;b&gt;sqlite3.exe&lt;/b&gt; 실행 파일을 대상 시스템에 복사 하고 실행하면됩니다) SQLite는 SQL을 교육하는 데 사용하기에 적합한 데이터베이스 엔진을 만듭니다. 학생들은 원하는만큼 데이터베이스를 쉽게 만들 수 있으며, 의견이나 채점을 위해 강사에게 데이터베이스를 이메일로 보낼 수 있습니다. RDBMS가 어떻게 구현되는지 연구하는 데 관심이있는 상급 학생들을 위해, 잘 짜여진 모듈화되고 문서화 된 SQLite 코드가 좋은 기반이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f8ea41ffd9236f49c6f3b48d5813c7ba03da82f" translate="yes" xml:space="preserve">
          <source>Because it reorganizes the entire FTS index, the optimize command can take a long time to run. The &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 merge command&lt;/a&gt; can be used to divide the work of optimizing the FTS index into multiple steps. To do this:</source>
          <target state="translated">전체 FTS 인덱스를 재구성하므로 optimize 명령을 실행하는 데 시간이 오래 걸릴 수 있습니다. &lt;a href=&quot;fts5#the_merge_command&quot;&gt;FTS5 병합 명령은&lt;/a&gt; 여러 단계로 FTS 인덱스를 최적화하는 작업을 분할하는 데 사용할 수 있습니다. 이것을하기 위해:</target>
        </trans-unit>
        <trans-unit id="444393da5087c1cdc4456d5a26de8bf63b917b08" translate="yes" xml:space="preserve">
          <source>Because it stores extra information on disk in two new &lt;a href=&quot;fts3#*shadowtab&quot;&gt;shadow tables&lt;/a&gt; in order to support the performance optimizations and extra matchinfo() options, FTS4 tables may consume more disk space than the equivalent table created using FTS3. Usually the overhead is 1-2% or less, but may be as high as 10% if the documents stored in the FTS table are very small. The overhead may be reduced by specifying the directive &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo=fts3&quot;&lt;/a&gt; as part of the FTS4 table declaration, but this comes at the expense of sacrificing some of the extra supported matchinfo() options.</source>
          <target state="translated">성능 최적화 및 추가 matchinfo () 옵션을 지원하기 위해 디스크에 추가 정보를 두 개의 새 &lt;a href=&quot;fts3#*shadowtab&quot;&gt;새도우 테이블&lt;/a&gt; 에 저장 하므로 FTS4 테이블은 FTS3을 사용하여 작성된 동등한 테이블보다 많은 디스크 공간을 소비 할 수 있습니다. 일반적으로 오버 헤드는 1-2 % 이하이지만 FTS 테이블에 저장된 문서가 매우 작은 경우 10 %가 될 수 있습니다. FTS4 테이블 선언의 일부로 지시문 &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;&quot;matchinfo = fts3&quot;&lt;/a&gt; 을 지정하여 오버 헤드를 줄일 수 있지만, 이는 지원되는 추가 matchinfo () 옵션 중 일부를 희생하는 대신 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c9b96b15368e6c99132d7d8a67a04e723712af54" translate="yes" xml:space="preserve">
          <source>Because lookaside allocations are always the same size, the allocation and deallocation algorithms are very quick. There is no need to coalesce adjacent free slots or search for a slot of a particular size. Each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; maintains a singly-linked list of unused slots. Allocation requests simply pull the first element of this list. Deallocations simply push the element back onto the front of the list. Furthermore, each &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is assumed to already be running in a single thread (there are mutexes already in place to enforce this) so no additional mutexing is required to serialize access to the lookaside slot freelist. Consequently, lookaside memory allocations and deallocations are very fast. In speed tests on Linux and Mac OS X workstations, SQLite has shown overall performance improvements as high as 10% and 15%, depending on the workload how and lookaside is configured.</source>
          <target state="translated">lookaside 할당은 항상 같은 크기이므로 할당 및 할당 해제 알고리즘이 매우 빠릅니다. 인접한 빈 슬롯을 통합하거나 특정 크기의 슬롯을 검색 할 필요가 없습니다. 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 은 단일 링크로 사용되지 않는 슬롯 목록을 유지 관리합니다. 할당 요청은 단순히이 목록의 첫 번째 요소를 가져옵니다. 할당 해제는 단순히 요소를 목록의 맨 앞으로 다시 밀어 넣습니다. 또한 각 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt;는 이미 단일 스레드에서 실행중인 것으로 가정하고 (이를 강제하기 위해 이미 뮤텍스가 있음) lookaside 슬롯 사용 가능 목록에 대한 액세스를 직렬화하는 데 추가 뮤텍스가 필요하지 않습니다. 따라서 lookaside 메모리 할당 및 할당 해제가 매우 빠릅니다. Linux 및 Mac OS X 워크 스테이션의 속도 테스트에서 SQLite는 워크로드 및 구성 방법에 따라 전체 성능이 10 % 및 15 % 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="668e105a1044bfeea3b1760bf6f04ba2a54183c0" translate="yes" xml:space="preserve">
          <source>Because main-memory is a limited resource, the</source>
          <target state="translated">메인 메모리는 제한된 리소스이므로</target>
        </trans-unit>
        <trans-unit id="fdc0f2ea6af2e7d5aa2876f1718288d4bc691129" translate="yes" xml:space="preserve">
          <source>Because of continuing security concerns, the two-argument version of of the seldom-used and little-known &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; function is disabled unless SQLite is compiled with the &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt;.</source>
          <target state="translated">지속적인 보안 문제로 인해 SQLite가 &lt;a href=&quot;compile#enable_fts3_tokenizer&quot;&gt;SQLITE_ENABLE_FTS3_TOKENIZER&lt;/a&gt; 로 컴파일되지 않으면 거의 사용되지 않고 거의 알려지지 않은 &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 함수 의 2 인수 버전 이 비활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="70e6d86d9770a8829aec592e59f4248ba67ce358" translate="yes" xml:space="preserve">
          <source>Because of its past success, AFL became a standard part of the testing strategy for SQLite beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;version 3.8.10&lt;/a&gt; (2015-05-07). Both SQL statements and database files are fuzzed. Billions and billions of mutations have been tried, but AFL's instrumentation has narrowed them down to less than 50,000 test cases that cover all distinct behaviors. Newly discovered test cases are periodically captured and added to the &lt;a href=&quot;testing#tcl&quot;&gt;TCL test suite&lt;/a&gt; where they can be rerun using the &quot;make fuzztest&quot; or &quot;make valgrindfuzz&quot; commands.</source>
          <target state="translated">과거의 성공으로 인해 AFL은 &lt;a href=&quot;https://sqlite.org/releaselog/3_8_10.html&quot;&gt;버전 3.8.10&lt;/a&gt; (2015-05-07) 부터 SQLite 테스트 전략의 표준이되었습니다 . SQL 문과 데이터베이스 파일 모두 퍼지됩니다. 수십억 개의 돌연변이가 시도되었지만 AFL의 계측은 그것들을 모든 별개의 행동을 다루는 50,000 개 미만의 테스트 사례로 좁혔습니다. 새로 발견 된 테스트 케이스는 주기적으로 캡처되어 &quot;make fuzztest&quot;또는 &quot;make valgrindfuzz&quot;명령을 사용하여 다시 실행할 수있는 &lt;a href=&quot;testing#tcl&quot;&gt;TCL 테스트 스위트에&lt;/a&gt; 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="35a2bab974445beaebfdcb0d2e216e6aab6976e2" translate="yes" xml:space="preserve">
          <source>Because of security concerns, the two-argument fts3_tokenizer() feature was disabled beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;Version 3.11.0&lt;/a&gt; (2016-02-15) unless this compile-time option is used. &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;Version 3.12.0&lt;/a&gt; (2016-03-29) added the &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt;(db,&lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt;,1,0) interface that activates the two-argument version of &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer()&lt;/a&gt; for a specific &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; at run-time.</source>
          <target state="translated">보안 문제로 &lt;a href=&quot;https://sqlite.org/releaselog/3_11_0.html&quot;&gt;인해이&lt;/a&gt; 컴파일 타임 옵션을 사용하지 않으면 두 인수 fts3_tokenizer () 기능이 버전 3.11.0 (2016-02-15) 부터 비활성화되었습니다 . &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; (2016-03-29)은 &lt;a href=&quot;c3ref/db_config&quot;&gt;sqlite3_db_config&lt;/a&gt; (db, &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigenablefts3tokenizer&quot;&gt;SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER&lt;/a&gt; , 1,0) 인터페이스를 추가하여 런타임시 특정 &lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 위해 두 인수 버전의 &lt;a href=&quot;fts3#f3tknzr&quot;&gt;fts3_tokenizer ()&lt;/a&gt; 를 활성화합니다 .</target>
        </trans-unit>
        <trans-unit id="90667c0d2f4c3f9e700d1a02bf683d36a408bbd8" translate="yes" xml:space="preserve">
          <source>Because of the behaviors described above, programmers are encouraged to prefer AFTER triggers over BEFORE triggers.</source>
          <target state="translated">위에서 설명한 동작으로 인해 프로그래머는 BEFORE 트리거보다 AFTER 트리거를 선호하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="428b411cc0640abd27f1cf3a950377d2c4b5358f" translate="yes" xml:space="preserve">
          <source>Because of the potential disadvantages, memory-mapped I/O is disabled by default. To activate memory-mapped I/O, use the &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma&lt;/a&gt; and set the mmap_size to some large number, usually 256MB or larger, depending on how much address space your application can spare. The rest is automatic. The &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA mmap_size&lt;/a&gt; statement will be a silent no-op on systems that do not support memory-mapped I/O.</source>
          <target state="translated">잠재적 인 단점으로 인해 메모리 매핑 I / O는 기본적으로 비활성화되어 있습니다. 메모리 매핑 된 I / O를 활성화하려면 &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;mmap_size pragma를&lt;/a&gt; 사용하고 응용 프로그램이 할당 할 수있는 주소 공간의 양에 따라 mmap_size를 보통 256MB 이상으로 설정하십시오. 나머지는 자동입니다. &lt;a href=&quot;pragma#pragma_mmap_size&quot;&gt;PRAGMA의 mmap_size의&lt;/a&gt; 문이 지원하지 않는 시스템에서 자동 무 조작 될 것입니다 I / O를 메모리 매핑.</target>
        </trans-unit>
        <trans-unit id="3b4a67ca1996129326c7f0bddce34637e22bf4f7" translate="yes" xml:space="preserve">
          <source>Because of these advantages, SQLite always tries to do a partial sort using an index even if a complete sort by index is not possible.</source>
          <target state="translated">이러한 장점 때문에 SQLite는 인덱스별로 완전한 정렬이 불가능하더라도 항상 인덱스를 사용하여 부분 정렬을 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0aff0a8b5eb6e0fbec96bd0626840af7bfdbee19" translate="yes" xml:space="preserve">
          <source>Because resetting a database is destructive and irreversible, the process requires the use of this obscure API and multiple steps to help ensure that it does not happen by accident.</source>
          <target state="translated">데이터베이스를 재설정하는 것은 파괴적이고 되돌릴 수 없기 때문에이 프로세스는이 모호한 API와 여러 단계를 사용하여 우발적으로 발생하지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b538eb844bddf9ea8a5b9a11872b1b61bfa979d" translate="yes" xml:space="preserve">
          <source>Because sorting can be expensive, SQLite works hard to convert ORDER BY clauses into no-ops. If SQLite determines that output will naturally appear in the order specified, then no sorting is done. So, for example, if you request the output in rowid order, no sorting will be done:</source>
          <target state="translated">정렬은 비용이 많이들 수 있으므로 SQLite는 ORDER BY 절을 no-ops로 변환하기 위해 열심히 노력합니다. SQLite가 출력이 지정된 순서대로 자연스럽게 나타날 것으로 판단하면 정렬이 수행되지 않습니다. 예를 들어, rowid 순서로 출력을 요청하면 정렬이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b9e05ab9d98b3cd637f9791d810eeb3b04a00c42" translate="yes" xml:space="preserve">
          <source>Because the SQLite developers do not know whether the SQLITE_ENABLE_SORTER_REFERENCES option will help or hurt performance, it is disabled by default at this time (2018-05-04). It might be enabled by default in some future release, depending on what is learned about its impact on performance.</source>
          <target state="translated">SQLite 개발자는 SQLITE_ENABLE_SORTER_REFERENCES 옵션이 성능에 도움이 될지 여부를 알 수 없으므로 현재 기본적으로 비활성화되어 있습니다 (2018-05-04). 성능에 미치는 영향에 대해 학습 한 내용에 따라 향후 릴리스에서 기본적으로 활성화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ba7f227189763df8625f3bee22f683d880802a" translate="yes" xml:space="preserve">
          <source>Because the completion table is built into the command-line shell in order to provide for tab-completions, you can run test queries against the completion table directly in the command-line shell. Simply type a query such as the example shown above, filling in appropriate values for $prefix and $wholeline, and observe the output.</source>
          <target state="translated">완료 테이블이 탭 완성을 제공하기 위해 명령 행 쉘에 내장되어 있으므로 명령 행 쉘에서 완료 테이블에 대해 테스트 쿼리를 직접 실행할 수 있습니다. $ prefix 및 $ wholeline에 적절한 값을 입력하여 위의 예와 같은 쿼리를 입력하고 출력을 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="a8514da27bd50380cff29e01b5a61eb7772e130b" translate="yes" xml:space="preserve">
          <source>Because the content of leaf freelist pages is unimportant, SQLite avoids storing leaf freelist page content in the rollback journal in &lt;a href=&quot;#section_3_5&quot;&gt;step 3.5&lt;/a&gt; of the commit process. If a leaf freelist page is changed and that change does not get rolled back during a transaction recovery, the database is not harmed by the omission. Similarly, the content of a new freelist page is never written back into the database at &lt;a href=&quot;#section_3_9&quot;&gt;step 3.9&lt;/a&gt; nor read from the database at &lt;a href=&quot;#section_3_3&quot;&gt;step 3.3&lt;/a&gt;. These optimizations can greatly reduce the amount of I/O that occurs when making changes to a database file that contains free space.</source>
          <target state="translated">리프 프리리스트 페이지의 컨텐츠는 중요하지 않으므로 SQLite는 커밋 프로세스의 &lt;a href=&quot;#section_3_5&quot;&gt;3.5 단계&lt;/a&gt; 에서 롤백 저널에 리프 프리리스트 페이지 컨텐츠를 저장하지 않습니다 . 리프 프리리스트 페이지가 변경되고 트랜잭션 복구 중에 해당 변경 사항이 롤백되지 않으면 데이터베이스가 누락되어 피해를받지 않습니다. 마찬가지로, 새로운 프리리스트 페이지의 내용은 &lt;a href=&quot;#section_3_9&quot;&gt;3.9 단계&lt;/a&gt; 에서 데이터베이스에 다시 쓰거나 &lt;a href=&quot;#section_3_3&quot;&gt;3.3 단계&lt;/a&gt; 에서 데이터베이스에서 읽지 않습니다 . 이러한 최적화는 여유 공간이있는 데이터베이스 파일을 변경할 때 발생하는 I / O의 양을 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e09f5109878254b678ca47d639d75e4bf226a1da" translate="yes" xml:space="preserve">
          <source>Because the indexed documents themselves are usually much larger than the full-text index, the content option can be used to achieve significant space savings.</source>
          <target state="translated">인덱싱 된 문서 자체는 일반적으로 전체 텍스트 인덱스보다 훨씬 크기 때문에 내용 옵션을 사용하여 공간을 크게 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="761cb8246ba69558ca8aeb80b8dbab8c62f5efed" translate="yes" xml:space="preserve">
          <source>Because the left-most column of the index does not appear in the WHERE clause of the query, one is tempted to conclude that the index is not usable here. But SQLite is able to use the index. Conceptually, SQLite uses the index as if the query were more like the following:</source>
          <target state="translated">인덱스의 가장 왼쪽 열이 쿼리의 WHERE 절에 나타나지 않기 때문에 여기서는 인덱스를 사용할 수 없다고 결론을 내릴 수 있습니다. 그러나 SQLite는 인덱스를 사용할 수 있습니다. 개념적으로 SQLite는 쿼리가 다음과 같은 것처럼 인덱스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a128485eb3a76806acc833997f2bb0ca8f3bab85" translate="yes" xml:space="preserve">
          <source>Because the non-primary key &quot;old.*&quot; fields are omitted, no SQLITE_CHANGESET_DATA conflicts can be detected or reported if a patchset is passed to the sqlite3changeset_apply() API. Other conflict types work in the same way as for changesets.</source>
          <target state="translated">기본이 아닌 키 &quot;old. *&quot;필드는 생략되므로 패치 세트가 sqlite3changeset_apply () API에 전달되면 SQLITE_CHANGESET_DATA 충돌을 감지하거나보고 할 수 없습니다. 다른 충돌 유형은 변경 세트와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2e558ba54b31e234aa1a29ff45d5a07a13c1806f" translate="yes" xml:space="preserve">
          <source>Because the pointer is passed in the t1 column of the t1 table as a BLOB (in older versions of SQLite), such a query would have shown the value of the pointer in hex. The attacker could then modify that pointer to try to get the snippet() function to modify memory in some other part of the application address space instead of the fts3cursor object it was supposed to be operating on:</source>
          <target state="translated">포인터는 t1 테이블의 t1 열에 BLOB (이전 버전의 SQLite)으로 전달되므로 이러한 쿼리는 포인터 값을 16 진수로 표시했을 것입니다. 그런 다음 공격자는 해당 포인터를 수정하여 snippet () 함수가 응용 프로그램 주소 공간의 다른 부분에서 fts3cursor 객체 대신 메모리를 수정하도록 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72ea5223eef09f4a78746e1785e07a1242a94565" translate="yes" xml:space="preserve">
          <source>Because the same query could be written without the use of row values, row values do not provide new capabilities. However, many developers say that the row value format is easier to read, write, and debug.</source>
          <target state="translated">행 값을 사용하지 않고 동일한 쿼리를 작성할 수 있으므로 행 값은 새로운 기능을 제공하지 않습니다. 그러나 많은 개발자들은 행 값 형식이 읽기, 쓰기 및 디버그가 더 쉽다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="fc8629347e97d2900d75943390265d789337dab5" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">세션 모듈이 &lt;a href=&quot;../c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; API를 사용하기 때문에 애플리케이션이 하나 이상의 세션 오브젝트가 첨부 된 데이터베이스 핸들에 사전 업데이트 후크를 등록 할 수 없습니다. 사전 갱신 후크가 이미 정의 된 데이터베이스 핸들에 첨부 된 세션 오브젝트를 작성할 수도 없습니다. 이 중 하나를 시도한 결과는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2d755c27985069d9c58f3f925b7f20c86ab3fc1d" translate="yes" xml:space="preserve">
          <source>Because the session module uses the &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook()&lt;/a&gt; API, it is not possible for an application to register a pre-update hook on a database handle that has one or more session objects attached. Nor is it possible to create a session object attached to a database handle for which a pre-update hook is already defined. The results of attempting either of these things are undefined.</source>
          <target state="translated">세션 모듈이 &lt;a href=&quot;c3ref/preupdate_count&quot;&gt;sqlite3_preupdate_hook ()&lt;/a&gt; API를 사용하기 때문에 애플리케이션이 하나 이상의 세션 오브젝트가 첨부 된 데이터베이스 핸들에 사전 업데이트 후크를 등록 할 수 없습니다. 사전 갱신 후크가 이미 정의 된 데이터베이스 핸들에 첨부 된 세션 오브젝트를 작성할 수도 없습니다. 이 중 하나를 시도한 결과는 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="adc547a5fb4644ceebfd077fa4efa0549df654d8" translate="yes" xml:space="preserve">
          <source>Because the shm file is not involved in recovery, the shm file does not need to be machine byte-order independent. Hence, numeric values in the shm file are written in the native byte order of the host computer, rather than being converted into a specific cross-platform byte order as is done with the main database file and the wal file.</source>
          <target state="translated">shm 파일은 복구에 관여하지 않기 때문에 shm 파일은 기계 바이트 순서와 무관 할 필요가 없습니다. 따라서 shm 파일의 숫자 값은 기본 데이터베이스 파일 및 wal 파일에서와 같이 특정 크로스 플랫폼 바이트 순서로 변환되지 않고 호스트 컴퓨터의 기본 바이트 순서로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="57d0b82e26ee2d676d928a1d7402d5916fc2656a" translate="yes" xml:space="preserve">
          <source>Because the shm is only used to coordinate access between concurrent clients, the shm file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, as an optimization. When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set, SQLite uses heap memory in place of the memory-mapped shm file.</source>
          <target state="translated">shm은 동시 클라이언트 간의 액세스를 조정하는 데만 사용되므로 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;배타적 잠금 모드&lt;/a&gt; 가 최적화로 설정된 경우 shm 파일이 생략됩니다 . 때 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드가&lt;/a&gt; 설정되어, SQLite는 메모리 매핑 SHM 파일 대신에 힙 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2da09f02d441cbe1ccd49c9803ec08e4160143a9" translate="yes" xml:space="preserve">
          <source>Because there is no cross-platform way to specify 64-bit integer types SQLite includes typedefs for 64-bit signed and unsigned integers.</source>
          <target state="translated">64 비트 정수 유형을 지정하는 크로스 플랫폼 방법이 없기 때문에 SQLite에는 64 비트 부호있는 정수 및 부호없는 정수에 대한 typedef가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7d5873520ec115c715db00ab0ac94f393f103400" translate="yes" xml:space="preserve">
          <source>Before SQLite can write to a database, it must first read the database to see what is there already. Even if it is just appending new data, SQLite still has to read in the database schema from the &lt;b&gt;sqlite_master&lt;/b&gt; table so that it can know how to parse the INSERT statements and discover where in the database file the new information should be stored.</source>
          <target state="translated">SQLite가 데이터베이스에 쓰려면 먼저 데이터베이스를 읽고 이미 존재하는 것을 확인해야합니다. 새 데이터를 추가하는 경우에도 SQLite는 &lt;b&gt;sqlite_master&lt;/b&gt; 테이블 에서 데이터베이스 스키마를 읽어야 INSERT 문을 구문 분석하고 데이터베이스 파일에서 새 정보를 저장할 위치를 &lt;b&gt;찾는&lt;/b&gt; 방법을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccacc0177cbd2ba716b19132f920379d439772e2" translate="yes" xml:space="preserve">
          <source>Before a &lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; statement can be run, the module specified in that statement must be registered with the database connection. This is accomplished using either of the &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module()&lt;/a&gt; or &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2()&lt;/a&gt; interfaces:</source>
          <target state="translated">&lt;a href=&quot;lang_createvtab&quot;&gt;CREATE VIRTUAL TABLE&lt;/a&gt; 문을 실행 하기 전에 해당 명령문에 지정된 모듈을 데이터베이스 연결에 등록해야합니다. 이는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/create_module&quot;&gt;sqlite3_create_module_v2 ()&lt;/a&gt; 인터페이스 중 하나를 사용하여 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="c589001febca68c36ef8079ff9faca5b3d4efc6b" translate="yes" xml:space="preserve">
          <source>Before a new auxiliary function or tokenizer implementation may be registered with FTS5, an application must obtain a pointer to the &quot;fts5_api&quot; structure. There is one fts5_api structure for each database connection with which the FTS5 extension is registered. To obtain the pointer, the application invokes the SQL user-defined function fts5() with a single argument. That argument must be set to a pointer to a pointer to an fts5_api object using the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; interface. The following example code demonstrates the technique:</source>
          <target state="translated">새로운 보조 기능 또는 토크 나이저 구현이 FTS5에 등록되기 전에 응용 프로그램은 &quot;fts5_api&quot;구조에 대한 포인터를 가져와야합니다. FTS5 확장이 등록 된 각 데이터베이스 연결마다 하나의 fts5_api 구조가 있습니다. 포인터를 얻기 위해 응용 프로그램은 단일 인수로 SQL 사용자 정의 함수 fts5 ()를 호출합니다. 이 인수는 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 인터페이스를 사용하여 fts5_api 객체에 대한 포인터를 가리키는 포인터로 설정해야합니다 . 다음 예제 코드는 기술을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6ae8b38a31b33865e805e86015a35fae53d45a85" translate="yes" xml:space="preserve">
          <source>Before any database pages may be modified within the</source>
          <target state="translated">데이터베이스 페이지 내에서 데이터베이스 페이지를 수정하기 전에</target>
        </trans-unit>
        <trans-unit id="2aafeb2e2bb5cf3269cb7e705f038008b263f110" translate="yes" xml:space="preserve">
          <source>Before any information-bearing page of the database is modified, the original unmodified content of that page is written into the rollback journal. If a transaction is interrupted and needs to be rolled back, the rollback journal can then be used to restore the database to its original state. Freelist leaf pages bear no information that would need to be restored on a rollback and so they are not written to the journal prior to modification, in order to reduce disk I/O.</source>
          <target state="translated">데이터베이스의 정보가 포함 된 페이지를 수정하기 전에 해당 페이지의 수정되지 않은 원본 내용이 롤백 저널에 기록됩니다. 트랜잭션이 중단되어 롤백해야하는 경우 롤백 저널을 사용하여 데이터베이스를 원래 상태로 복원 할 수 있습니다. 프리리스트 리프 페이지에는 롤백시 복원해야 할 정보가 없으므로 디스크 I / O를 줄이기 위해 수정 전에 저널에 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e31e39238fffa8a7d3425c769271d3112873aa6f" translate="yes" xml:space="preserve">
          <source>Before calling this method, the SQLite core initializes an instance of the &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; structure with information about the query that it is currently trying to process. This information derives mainly from the WHERE clause and ORDER BY or GROUP BY clauses of the query, but also from any ON or USING clauses if the query is a join. The information that the SQLite core provides to the xBestIndex method is held in the part of the structure that is marked as &quot;Inputs&quot;. The &quot;Outputs&quot; section is initialized to zero.</source>
          <target state="translated">이 메소드를 호출하기 전에 SQLite 코어 는 현재 처리하려는 쿼리에 대한 정보로 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; 구조 의 인스턴스를 초기화합니다 . 이 정보는 주로 쿼리의 WHERE 절과 ORDER BY 또는 GROUP BY 절에서 파생되며 쿼리가 조인 인 경우 ON 또는 USING 절에서도 파생됩니다. SQLite 코어가 xBestIndex 메소드에 제공하는 정보는 &quot;입력&quot;으로 표시된 구조 부분에 보유됩니다. &quot;출력&quot;섹션이 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="29b6c291315b8e1fb3f265c15e369937b630aaf5" translate="yes" xml:space="preserve">
          <source>Before data may be read from a</source>
          <target state="translated">데이터를 읽기 전에</target>
        </trans-unit>
        <trans-unit id="cae7b06f8fadf1f8b2bbb51c0629366481aebe32" translate="yes" xml:space="preserve">
          <source>Before entering a trigger program the value returned by sqlite3_changes() function is saved. After the trigger program has finished, the original value is restored.</source>
          <target state="translated">트리거 프로그램을 시작하기 전에 sqlite3_changes () 함수가 반환 한 값이 저장됩니다. 트리거 프로그램이 완료되면 원래 값이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="7968bdea3fbca698f15e058c3369cb48f81fd4ca" translate="yes" xml:space="preserve">
          <source>Before executing a statement that modifies the database schema (i.e. a CREATE or DROP TABLE statement), a connection must obtain a write-lock on</source>
          <target state="translated">데이터베이스 스키마를 수정하는 명령문 (예 : CREATE 또는 DROP TABLE 문)을 실행하기 전에 연결에서 쓰기 잠금을 얻어야합니다.</target>
        </trans-unit>
        <trans-unit id="64443a5dc257f480bf4a79d829dcae9017cc971a" translate="yes" xml:space="preserve">
          <source>Before making changes to any page of the database, the process writes the original content of that page into the rollback journal. Changes to pages are held in memory at first and are not written to the disk. The original database file remains unaltered, which means that other processes can continue to read the database.</source>
          <target state="translated">데이터베이스의 페이지를 변경하기 전에 프로세스는 해당 페이지의 원래 컨텐츠를 롤백 저널에 기록합니다. 페이지 변경 사항은 처음에 메모리에 유지되며 디스크에 기록되지 않습니다. 원래 데이터베이스 파일은 변경되지 않은 상태로 유지되므로 다른 프로세스가 데이터베이스를 계속 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed294139e05d80e58de31e418d68f4cfaebeb6a7" translate="yes" xml:space="preserve">
          <source>Before making changes to the database, SQLite first obtains a &quot;reserved&quot; lock on the database file. A reserved lock is similar to a shared lock in that both a reserved lock and shared lock allow other processes to read from the database file. A single reserve lock can coexist with multiple shared locks from other processes. However, there can only be a single reserved lock on the database file. Hence only a single process can be attempting to write to the database at one time.</source>
          <target state="translated">데이터베이스를 변경하기 전에 SQLite는 먼저 데이터베이스 파일에 대한 &quot;예약 된&quot;잠금을 얻습니다. 예약 잠금은 예약 잠금과 공유 잠금이 다른 프로세스가 데이터베이스 파일에서 읽을 수 있다는 점에서 공유 잠금과 유사합니다. 단일 예약 잠금은 다른 프로세스의 여러 공유 잠금과 공존 할 수 있습니다. 그러나 데이터베이스 파일에는 단일 예약 잠금 만있을 수 있습니다. 따라서 한 번에 하나의 프로세스 만 데이터베이스에 쓰려고 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0b64dbebb4ad46a9aeb1a098c15aadd4e3eaf44" translate="yes" xml:space="preserve">
          <source>Before modifying a database page within the</source>
          <target state="translated">데이터베이스 페이지에서 데이터베이스 페이지를 수정하기 전에</target>
        </trans-unit>
        <trans-unit id="98e0ccf77dc018ac7ea18b90477a40f1a7c510fa" translate="yes" xml:space="preserve">
          <source>Before opening a</source>
          <target state="translated">열기 전에</target>
        </trans-unit>
        <trans-unit id="6822a9cef8f0664c32cddfaac23e4bff41485b02" translate="yes" xml:space="preserve">
          <source>Before reading from a database file, SQLite always checks to see if that database file has a hot journal. If the file does have a hot journal, then the journal is rolled back before the file is read. In this way, we ensure that the database file is in a consistent state before it is read.</source>
          <target state="translated">데이터베이스 파일에서 읽기 전에 SQLite는 항상 해당 데이터베이스 파일에 핫 저널이 있는지 확인합니다. 파일에 핫 저널이있는 경우 파일을 읽기 전에 저널이 롤백됩니다. 이러한 방식으로, 데이터베이스 파일을 읽기 전에 일관성있는 상태에 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="2ffabc9625263621654187c58d31675c59e6730d" translate="yes" xml:space="preserve">
          <source>Before the content of a page modified within the</source>
          <target state="translated">페이지 내용이 페이지 내부에서 수정되기 전에</target>
        </trans-unit>
        <trans-unit id="2a76187aef00ad8a5abadfac889a6b98dd1db2fb" translate="yes" xml:space="preserve">
          <source>Before the contents of the</source>
          <target state="translated">내용 전에</target>
        </trans-unit>
        <trans-unit id="5f97138118a317cbc3bf1e3e8dd4c6fd1edd23a0" translate="yes" xml:space="preserve">
          <source>Before we begin looking at this problem, let's briefly review how queries work in SQLite so that we will know what we are trying to accomplish. For each row in the result of a query, SQLite will invoke a callback function with the following prototype:</source>
          <target state="translated">이 문제를 살펴보기 전에 SQLite에서 쿼리가 작동하는 방식을 간단히 검토하여 수행하려는 작업을 알도록하겠습니다. 쿼리 결과의 각 행에 대해 SQLite는 다음 프로토 타입을 사용하여 콜백 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="5c00a0d3ea5cf97be2cbc8e0c749bfff4206bbf5" translate="yes" xml:space="preserve">
          <source>Begin a transaction on database P1 if a transaction is not already active. If P2 is non-zero, then a write-transaction is started, or if a read-transaction is already active, it is upgraded to a write-transaction. If P2 is zero, then a read-transaction is started.</source>
          <target state="translated">트랜잭션이 아직 활성화되지 않은 경우 데이터베이스 P1에서 트랜잭션을 시작하십시오. P2가 0이 아닌 경우 쓰기 트랜잭션이 시작되거나 읽기 트랜잭션이 이미 활성화 된 경우 쓰기 트랜잭션으로 업그레이드됩니다. P2가 0이면 읽기 트랜잭션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd194a93ac6ccfaf40c7f7cd5a992cb067293a7" translate="yes" xml:space="preserve">
          <source>Begin adding lots of new documentation</source>
          <target state="translated">많은 새로운 문서 추가 시작</target>
        </trans-unit>
        <trans-unit id="90c994ef269c7ca4806cc0aace7ca7e97ba28671" translate="yes" xml:space="preserve">
          <source>Begin by obtaining a copy of SQLite in whatever form you use it. The public SQLite you obtain should be as close to your private edited copy as possible. If your project uses the SQLite amalgamation, then get a copy of the amalgamation. If you use the preprocessed separate source files, get those instead. Put all the source files in the checkout directory created in the previous step.</source>
          <target state="translated">어떤 형태로든 SQLite 사본을 구하십시오. 당신이 얻는 공개 SQLite는 가능한 한 개인 편집 사본에 가깝습니다. 프로젝트에서 SQLite 합병을 사용하는 경우 합병의 사본을 받으십시오. 사전 처리 된 별도의 소스 파일을 사용하는 경우 해당 파일을 대신 가져 오십시오. 모든 소스 파일을 이전 단계에서 작성된 체크 아웃 디렉토리에 두십시오.</target>
        </trans-unit>
        <trans-unit id="c95a84f6810e9547323b7d36381036499b6e85a2" translate="yes" xml:space="preserve">
          <source>Begin enforcing &lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt;. This can be used, for example, to prevent excessively large prepared statements in systems that accept SQL queries from untrusted users.</source>
          <target state="translated">&lt;a href=&quot;c3ref/c_limit_attached#sqlitelimitvdbeop&quot;&gt;SQLITE_LIMIT_VDBE_OP&lt;/a&gt; 시행을 시작하십시오 . 예를 들어, 신뢰할 수없는 사용자의 SQL 쿼리를 허용하는 시스템에서 너무 큰 준비된 명령문을 방지하기 위해 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5e2f03338f65ea55efadd743c2073f0844124d" translate="yes" xml:space="preserve">
          <source>Begin every identifier with the letter &quot;Z&quot; as no SQL keywords start with &quot;Z&quot;.</source>
          <target state="translated">SQL 키워드가 &quot;Z&quot;로 시작하지 않으므로 문자 &quot;Z&quot;로 모든 식별자를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c9b7ac07f4b963268a3915518a82c60026c1c8" translate="yes" xml:space="preserve">
          <source>Begin writing documentation on the TCL interface.</source>
          <target state="translated">TCL 인터페이스에서 문서 작성을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="d93624195948cab4e3c3cf8a06c4ba66150434ee" translate="yes" xml:space="preserve">
          <source>Begin writing the &lt;a href=&quot;vdbe&quot;&gt;VDBE tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;vdbe&quot;&gt;VDBE 튜토리얼&lt;/a&gt; 작성을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="2891bac57361d1d80487ccfbba99ba09325df3b5" translate="yes" xml:space="preserve">
          <source>Beginning a Write Transaction</source>
          <target state="translated">쓰기 트랜잭션 시작</target>
        </trans-unit>
        <trans-unit id="60eca843fdd7093ad8665839ef32416ade71c639" translate="yes" xml:space="preserve">
          <source>Beginning in 2016, a team of engineers at Google started the &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; project. OSS Fuzz uses a AFL-style guided fuzzer running on Google's infrastructure. The Fuzzer automatically downloads the latest check-ins for participating projects, fuzzes them, and sends email to the developers reporting any problems. When a fix is checked in, the fuzzer automatically detects this and emails a confirmation to the developers.</source>
          <target state="translated">2016 년부터 Google 엔지니어 팀이 &lt;a href=&quot;https://github.com/google/oss-fuzz&quot;&gt;OSS Fuzz&lt;/a&gt; 프로젝트를 시작했습니다 . OSS Fuzz는 Google 인프라에서 실행되는 AFL 스타일 안내 식 퍼저를 사용합니다. Fuzzer는 참여 프로젝트에 대한 최신 체크인을 자동으로 다운로드하여 퍼징 한 다음 문제를보고 한 개발자에게 이메일을 보냅니다. 수정 프로그램이 체크인되면 퍼 저가이를 자동으로 감지하여 개발자에게 확인 이메일을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="52ddec92a44c4044495e3a4272f88fb5bf0d2787" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;version 3.15.0&lt;/a&gt; (2016-10-14), an assignment in the SET clause can be a &lt;a href=&quot;syntax/column-name-list&quot;&gt;parenthesized list of column names&lt;/a&gt; on the left and a &lt;a href=&quot;rowvalue&quot;&gt;row value&lt;/a&gt; of the same size on the right.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_15_0.html&quot;&gt;버전 3.15.0&lt;/a&gt; (2016-10-14) 부터 SET 절의 할당 은 왼쪽에 &lt;a href=&quot;syntax/column-name-list&quot;&gt;괄호로 묶인 열 이름 목록&lt;/a&gt; 과 오른쪽에 동일한 크기 의 &lt;a href=&quot;rowvalue&quot;&gt;행 값&lt;/a&gt; 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8e0744464084ddf340ea6c6e0a24aad6d9c12c18" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;version 3.6.4&lt;/a&gt; (2008-10-15), the TRUNCATE journal mode is also supported:</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_4.html&quot;&gt;버전 3.6.4&lt;/a&gt; (2008-10-15)부터 TRUNCATE 저널 모드도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6adac7327da12129344605aed8c6230ec2a45b5c" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;version 3.7.4&lt;/a&gt; (2010-12-07), WAL databases can be created, read, and written even if shared memory is unavailable as long as the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; is set to EXCLUSIVE before the first attempted access. In other words, a process can interact with a WAL database without using shared memory if that process is guaranteed to be the only process accessing the database. This feature allows WAL databases to be created, read, and written by legacy &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; that lack the &quot;version 2&quot; shared-memory methods xShmMap, xShmLock, xShmBarrier, and xShmUnmap on the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_4.html&quot;&gt;버전 3.7.4&lt;/a&gt; (2010-12-07) 부터는 첫 번째 액세스 시도 전에 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;locking_mode&lt;/a&gt; 가 EXCLUSIVE로 설정 되어있는 한 공유 메모리를 사용할 수없는 경우에도 WAL 데이터베이스를 작성하고 읽고 쓸 수 있습니다. 즉, 프로세스가 데이터베이스에 액세스하는 유일한 프로세스 인 경우 프로세스는 공유 메모리를 사용하지 않고 WAL 데이터베이스와 상호 작용할 수 있습니다. 이 기능을 사용 하면 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 오브젝트 에서 &quot;버전 2&quot;공유 메모리 메소드 xShmMap, xShmLock, xShmBarrier 및 xShmUnmap이없는 레거시 &lt;a href=&quot;vfs&quot;&gt;VFS에서&lt;/a&gt; WAL 데이터베이스를 작성하고 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f100a899b26537fc63caa4230653ce9716130e4" translate="yes" xml:space="preserve">
          <source>Beginning in SQLite version 3.5.0, the new Virtual File System (VFS) interface contains a method named xDeviceCharacteristics which reports on special properties that the underlying mass storage device might have. Among the special properties that xDeviceCharacteristics might report is the ability of to do an atomic sector write.</source>
          <target state="translated">SQLite 버전 3.5.0부터 새로운 가상 파일 시스템 (VFS) 인터페이스에는 기본 대용량 저장 장치가 가질 수있는 특수 속성을보고하는 xDeviceCharacteristics라는 메서드가 포함되어 있습니다. xDeviceCharacteristics가보고 할 수있는 특수한 속성 중에는 원자 섹터 쓰기 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbe6df39f8d021809fb2ab3e47422b19fa74d670" translate="yes" xml:space="preserve">
          <source>Beginning in late 2018, SQLite has been fuzzed using a new proprietary fuzzer called &quot;dbsqlfuzz&quot;. Dbsqlfuzz is built using the &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; framework of LLVM.</source>
          <target state="translated">2018 년 후반부터 SQLite는 &quot;dbsqlfuzz&quot;라는 새로운 독점적 퍼저를 사용하여 퍼징되었습니다. Dbsqlfuzz는 LLVM 의 &lt;a href=&quot;http://llvm.org/docs/LibFuzzer.html&quot;&gt;libFuzzer&lt;/a&gt; 프레임 워크를 사용하여 빌드됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4f6d3a3a096224887296bd514258ca7ceae764c" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;version 3.7.0&lt;/a&gt; (2010-07-21), SQLite supports a new transaction control mechanism called &quot;&lt;a href=&quot;wal&quot;&gt;write-ahead log&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt;&quot;. When a database is in WAL mode, all connections to that database must use the WAL. A particular database will use either a rollback journal or a WAL, but not both at the same time. The WAL is always located in the same directory as the database file and has the same name as the database file but with the string &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; appended.</source>
          <target state="translated">를 시작으로 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_0.html&quot;&gt;버전 3.7.0&lt;/a&gt; (2010-07-21), SQLite는이 &quot;라는 새로운 트랜잭션 제어 메커니즘 지원 &lt;a href=&quot;wal&quot;&gt;미리 쓰기 로그&lt;/a&gt; &quot; &quot;또는 &lt;a href=&quot;wal&quot;&gt;WAL을&lt;/a&gt; &quot;. 데이터베이스가 WAL 모드 인 경우 해당 데이터베이스에 대한 모든 연결은 WAL을 사용해야합니다. 특정 데이터베이스는 롤백 저널 또는 WAL을 사용하지만 동시에 둘 다 사용하지는 않습니다. WAL은 항상 데이터베이스 파일과 동일한 디렉토리에 있으며 데이터베이스 파일과 이름은 동일하지만 문자열 &quot; &lt;code&gt;-wal&lt;/code&gt; &quot;이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d9839d2cef57fa5d151a0ce9cbe15a6e0c36fbc7" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), SQLite has the option of accessing disk content directly using memory-mapped I/O and the new xFetch() and xUnfetch() methods on &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt;.</source>
          <target state="translated">로 시작하는 &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013년 5월 20일), SQLite는 직접 디스크 콘텐츠에 액세스 메모리 매핑 I / O 및 새로운 xFetch ()와 xUnfetch () 메소드를 사용하는 옵션이있다 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26a395622db69c8b77803fcd06e3a2c5d4cdefa3" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;version 3.7.7&lt;/a&gt; (2011-06-23), the SQLite database file argument to the &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, and &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; interfaces and to the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; command can be specified either as an ordinary filename or as a Uniform Resource Identifier or URI. The advantage of using a URI filename is that query parameters on the URI can be used to control details of the newly created database connection. For example, an alternative &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; can be specified using a &quot;vfs=&quot; query parameter. Or the database can be opened read-only by using &quot;mode=ro&quot; as a query parameter.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_7_7.html&quot;&gt;버전 3.7.7&lt;/a&gt; (2011-06-23) 부터 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 인터페이스 및 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 명령에 대한 SQLite 데이터베이스 파일 인수 는 일반 파일 이름 또는 a로 지정할 수 있습니다. URI (Uniform Resource Identifier). URI 파일 이름을 사용하면 URI에서 쿼리 매개 변수를 사용하여 새로 만든 데이터베이스 연결의 세부 정보를 제어 할 수 있다는 이점이 있습니다. 예를 들어 &quot;vfs =&quot;쿼리 매개 변수를 사용하여 대체 &lt;a href=&quot;vfs&quot;&gt;VFS를&lt;/a&gt; 지정할 수 있습니다. 또는 &quot;mode = ro&quot;를 쿼리 매개 변수로 사용하여 데이터베이스를 읽기 전용으로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b26610830584adfe4c3b1f430311725c505dc65" translate="yes" xml:space="preserve">
          <source>Beginning with &lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;version 3.9.0&lt;/a&gt; (2015-10-14) SQLite uses &lt;a href=&quot;http://semver.org&quot;&gt;semantic versioning&lt;/a&gt;. Prior to that time, SQLite employed a version identifier that contained between two and four numbers.</source>
          <target state="translated">&lt;a href=&quot;https://sqlite.org/releaselog/3_9_0.html&quot;&gt;버전 3.9.0&lt;/a&gt; (2015-10-14) 부터 SQLite는 &lt;a href=&quot;http://semver.org&quot;&gt;시맨틱 버전 관리를&lt;/a&gt; 사용합니다 . 그 전에 SQLite는 2-4 개의 숫자로 구성된 버전 식별자를 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="e8a7a785dc79c6f97e7e9b629f10c98e7d6eaa12" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite 3.23.0 (2018-04-02), SQLite recognizes the identifiers &quot;TRUE&quot; and &quot;FALSE&quot; as boolean literals, if and only if those identifiers are not already used for some other meaning. If there already exists columns or tables or other objects named TRUE or FALSE, then for the sake of backwards compatibility, the TRUE and FALSE identifiers refer to those other objects, not to the boolean values.</source>
          <target state="translated">SQLite 3.23.0 (2018-04-02)부터 SQLite는 식별자 &quot;TRUE&quot;및 &quot;FALSE&quot;를 부울 리터럴로 인식합니다 (만약 식별자가 다른 의미로 사용되지 않은 경우에만). TRUE 또는 FALSE라는 열 또는 테이블 또는 다른 개체가 이미있는 경우 이전 버전과의 호환성을 위해 TRUE 및 FALSE 식별자는 부울 값이 아닌 다른 개체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="e27a2a72ed98b30f89096b193da3e3a912285cdd" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;version 3.10.0&lt;/a&gt; (2016-01-06), the unix OS interface will attempt to resolve symbolic links and open the database file by its canonical name. Prior to version 3.10.0, opening a database file through a symbolic link was similar to opening a database file that had multiple hard links and resulted in undefined behavior.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_10_0.html&quot;&gt;버전 3.10.0&lt;/a&gt; (2016-01-06) 부터 Uniix OS 인터페이스는 심볼릭 링크를 확인하고 표준 이름으로 데이터베이스 파일을 열려고 시도합니다. 버전 3.10.0 이전에는 기호 링크를 통해 데이터베이스 파일을 여는 것이 여러 개의 하드 링크가있는 데이터베이스 파일을 여는 것과 유사하며 정의되지 않은 동작이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="669009bffd329a7525e12f992041efbc93a9e4fc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;version 3.14.0&lt;/a&gt; (2016-08-08), the CREATE TABLE statement that is passed into &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab()&lt;/a&gt; may contain a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; clause. This is useful for cases where the virtual table rows cannot easily be mapped into unique integers. A CREATE TABLE statement that includes WITHOUT ROWID must define one or more columns as the PRIMARY KEY. Every column of the PRIMARY KEY must individually be NOT NULL and all columns for each row must be collectively unique.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_14.html&quot;&gt;버전 3.14.0&lt;/a&gt; (2016-08-08) 부터 &lt;a href=&quot;c3ref/declare_vtab&quot;&gt;sqlite3_declare_vtab ()에&lt;/a&gt; 전달 된 CREATE TABLE 문 에 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 절이 포함될 수 있습니다 . 이는 가상 테이블 행을 고유 한 정수로 쉽게 맵핑 할 수없는 경우에 유용합니다. WITHOUT ROWID를 포함하는 CREATE TABLE 문은 하나 이상의 열을 PRIMARY KEY로 정의해야합니다. PRIMARY KEY의 모든 열은 개별적으로 NOT NULL이어야하며 각 행의 모든 ​​열은 집합 적으로 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="914fd4075646f327da4b592c31312990facc6a8d" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;version 3.23.0&lt;/a&gt; (2018-04-02), SQLite also recognizes TRUE and FALSE keywords as aliases for integer values 1 and 0, respectively. This provides better compatibility with other SQL implementations. But to retain backwards compatibility, if there are columns named TRUE or FALSE, then the keywords are treated as identifiers referencing those columns, rather than BOOLEAN literals.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_23_0.html&quot;&gt;버전 3.23.0&lt;/a&gt; (2018-04-02)부터 SQLite는 TRUE 및 FALSE 키워드를 각각 정수 값 1 및 0의 별칭으로 인식합니다. 이것은 다른 SQL 구현과의 호환성을 향상시킵니다. 그러나 이전 버전과의 호환성을 유지하기 위해 TRUE 또는 FALSE라는 열이있는 경우 키워드는 BOOLEAN 리터럴이 아니라 해당 열을 참조하는 식별자로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f2cb99d27921b6ac8152e7a3c891a53596352b" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;version 3.7.13&lt;/a&gt; (2012-06-11), shared cache can be used on &lt;a href=&quot;inmemorydb&quot;&gt;in-memory databases&lt;/a&gt;, provided that the database is created using a &lt;a href=&quot;uri&quot;&gt;URI filename&lt;/a&gt;. For backwards compatibility, shared cache is always disable for in-memory databases if the unadorned name &quot;:memory:&quot; is used to open the database. Prior to version 3.7.13, shared cache was always disabled for in-memory databases regardless of the database name used, current system shared cache setting, or query parameters or flags.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_13.html&quot;&gt;버전 3.7.13&lt;/a&gt; (2012-06-11) 부터는 데이터베이스가 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름을&lt;/a&gt; 사용하여 생성되는 경우 &lt;a href=&quot;inmemorydb&quot;&gt;메모리 내 데이터베이스에서&lt;/a&gt; 공유 캐시를 사용할 수 있습니다 . 이전 버전과의 호환성을 위해 비공식 이름 &quot;: memory :&quot;를 사용하여 데이터베이스를 열면 메모리 내 데이터베이스에 대해 공유 캐시가 항상 비활성화됩니다. 버전 3.7.13 이전에는 사용 된 데이터베이스 이름, 현재 시스템 공유 캐시 설정 또는 쿼리 매개 변수 또는 플래그에 관계없이 메모리 내 데이터베이스에 대해 공유 캐시가 항상 사용 안함으로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="4d897fef3b918d90f462942b797bcba2f181cd38" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file has multiple hard links.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20) 부터는 데이터베이스 파일에 여러 개의 하드 링크가있는 경우 UNIX OS 인터페이스가 &lt;a href=&quot;errlog&quot;&gt;오류 로그에&lt;/a&gt; SQLITE_WARNING 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="7fa120398347f1152da8e84a3905c5d3c58c3466" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;version 3.7.17&lt;/a&gt; (2013-05-20), the unix OS interface will send SQLITE_WARNING messages to the &lt;a href=&quot;errlog&quot;&gt;error log&lt;/a&gt; if a database file is unlinked while it is still in use.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_17.html&quot;&gt;버전 3.7.17&lt;/a&gt; (2013-05-20) 부터는 데이터베이스 파일이 아직 사용 중일 때 링크 해제 된 경우 unix OS 인터페이스가 SQLITE_WARNING 메시지를 &lt;a href=&quot;errlog&quot;&gt;오류 로그&lt;/a&gt; 로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="8f4af8bd16f5f6dcf0575ed25d9da5ad7a3cecfc" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;버전 3.7.3&lt;/a&gt; (2010-10-08) &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;부터는 SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션의 호출 여부에 관계없이 소프트 힙 제한이 적용 됩니다. &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하면 모든 메모리 할당에서 소프트 힙 제한이 적용됩니다. &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT가&lt;/a&gt; 없으면 소프트 힙 한계는 메모리가 페이지 캐시에 의해 할당 된 경우에만 적용됩니다. 테스트 결과, 페이지 캐시가 SQLite의 주요 메모리 사용자이므로 대부분의 응용 프로그램은 &lt;a href=&quot;../compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하지 않고도 적절한 소프트 힙 제한 적용을 달성 할 수 있다고 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="a0dfecc63fffa644348dc3e00941cc0dedd6014a" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;version 3.7.3&lt;/a&gt; (2010-10-08), the soft heap limit is enforced regardless of whether or not the &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; compile-time option is invoked. With &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is enforced on every memory allocation. Without &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;, the soft heap limit is only enforced when memory is allocated by the page cache. Testing suggests that because the page cache is the predominate memory user in SQLite, most applications will achieve adequate soft heap limit enforcement without the use of &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt;.</source>
          <target state="translated">SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_7_3.html&quot;&gt;버전 3.7.3&lt;/a&gt; (2010-10-08) &lt;a href=&quot;compile#enable_memory_management&quot;&gt;부터는 SQLITE_ENABLE_MEMORY_MANAGEMENT&lt;/a&gt; 컴파일 타임 옵션의 호출 여부에 관계없이 소프트 힙 제한이 적용 됩니다. &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하면 모든 메모리 할당에서 소프트 힙 제한이 적용됩니다. &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT가&lt;/a&gt; 없으면 소프트 힙 한계는 메모리가 페이지 캐시에 의해 할당 된 경우에만 적용됩니다. 테스트 결과, 페이지 캐시가 SQLite의 주요 메모리 사용자이므로 대부분의 응용 프로그램은 &lt;a href=&quot;compile#enable_memory_management&quot;&gt;SQLITE_ENABLE_MEMORY_MANAGEMENT를&lt;/a&gt; 사용하지 않고도 적절한 소프트 힙 제한 적용을 달성 할 수 있다고 제안 합니다.</target>
        </trans-unit>
        <trans-unit id="c179ab3e7d04af330c7efc2cec123a479ee926c3" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.24.0 (2018-06-04), r-tree tables can have auxiliary columns that store arbitrary data. Auxiliary columns can be used in place of secondary tables such as &quot;demo_data&quot;.</source>
          <target state="translated">SQLite 버전 3.24.0 (2018-06-04)부터 r-tree 테이블에는 임의의 데이터를 저장하는 보조 열이있을 수 있습니다. &quot;demo_data&quot;와 같은 보조 테이블 대신 보조 열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6d8128996ffada537e69bde476b38bfd6abdaaa" translate="yes" xml:space="preserve">
          <source>Beginning with SQLite version 3.3.14 a mechanism has been added to try to reduce the needless rereading of data. In newer versions of SQLite, the data in the user-space pager cache is retained when the lock on the database file is released. Later, after the shared lock is acquired at the beginning of the next transaction, SQLite checks to see if any other process has modified the database file. If the database has been changed in any way since the lock was last released, the user-space cache is erased at that point. But commonly the database file is unchanged and the user-space cache can be retained, and some unnecessary read operations can be avoided.</source>
          <target state="translated">SQLite 버전 3.3.14부터 불필요한 데이터 다시 읽기를 줄이기위한 메커니즘이 추가되었습니다. 최신 버전의 SQLite에서는 데이터베이스 파일에 대한 잠금이 해제 될 때 사용자 공간 호출기 캐시의 데이터가 유지됩니다. 나중에 다음 트랜잭션이 시작될 때 공유 잠금이 획득 된 후 SQLite는 다른 프로세스가 데이터베이스 파일을 수정했는지 확인합니다. 잠금이 마지막으로 해제 된 이후 데이터베이스가 어떤 식 으로든 변경되면 해당 시점에서 사용자 공간 캐시가 지워집니다. 그러나 일반적으로 데이터베이스 파일은 변경되지 않고 사용자 공간 캐시를 보유 할 수 있으며 불필요한 읽기 조작을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0eba5a240e8bc3220e00f595afb167768fa6cb7" translate="yes" xml:space="preserve">
          <source>Beginning with release 3.25.0 (2018-09-15), references to the table within trigger bodies and view definitions are also renamed.</source>
          <target state="translated">릴리스 3.25.0 (2018-09-15)부터 트리거 본문 및 뷰 정의 내의 테이블에 대한 참조 이름도 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="d654ce8d1a877b686fbd470426c428e02c9409c6" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.2.0, SQLite no longer builds an index for an INTEGER PRIMARY KEY column. Instead, it uses that column as the actual B-Tree key for the main table.</source>
          <target state="translated">버전 2.2.0부터 SQLite는 더 이상 INTEGER PRIMARY KEY 열에 대한 색인을 작성하지 않습니다. 대신, 해당 열을 기본 테이블의 실제 B- 트리 키로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="042e0229fee0d8bfed5724fa18cd980bad0c1945" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.3.0, SQLite supports some additional syntax (the &quot;ON CONFLICT&quot; clause) in the CREATE TABLE and CREATE INDEX statements that are stored in the SQLITE_MASTER table. If you create a database that contains this new syntax, then try to read that database using version 2.2.5 or earlier, the parser will not understand the new syntax and you will get an error. Otherwise, databases for 2.2.x and 2.3.x are interchangeable.</source>
          <target state="translated">버전 2.3.0부터 SQLite는 SQLITE_MASTER 테이블에 저장된 CREATE TABLE 및 CREATE INDEX 문에서 일부 추가 구문 ( &quot;ON CONFLICT&quot;절)을 지원합니다. 이 새 구문이 포함 된 데이터베이스를 작성하는 경우 버전 2.2.5 이하를 사용하여 해당 데이터베이스를 읽으려고하면 구문 분석기가 새 구문을 이해하지 못하므로 오류가 발생합니다. 그렇지 않은 경우 2.2.x 및 2.3.x의 데이터베이스는 서로 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="d9bdf31e2f633cc8ef293e098f7f5d722da8a2a8" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite added support for views. Information about views is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains VIEW information in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail. Also, the way SQLite keeps track of unused disk blocks in the database file changed slightly. If an older version of SQLite attempts to write a database that was previously written by version 2.4.0 or later, then it may leak disk blocks.</source>
          <target state="translated">버전 2.4.0부터 SQLite는 뷰에 대한 지원을 추가했습니다. 뷰에 대한 정보는 SQLITE_MASTER 테이블에 저장됩니다. 이전 버전의 SQLite가 SQLITE_MASTER 테이블에 VIEW 정보가 포함 된 데이터베이스를 읽으려고하면 구문 분석기가 새 구문을 이해하지 못하므로 초기화에 실패합니다. 또한 SQLite가 데이터베이스 파일에서 사용되지 않은 디스크 블록을 추적하는 방식이 약간 변경되었습니다. 이전 버전의 SQLite가 이전에 버전 2.4.0 이상에서 작성된 데이터베이스를 쓰려고 시도하면 디스크 블록이 누출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="413008ed4f165a3aca53c2fe0890bace8386a170" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.4.0, SQLite allows the SQL language to be extended with new functions implemented as C code. The following interface is used:</source>
          <target state="translated">버전 2.4.0부터 SQLite는 C 코드로 구현 된 새로운 기능으로 SQL 언어를 확장 할 수 있습니다. 다음과 같은 인터페이스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8dad8b696b630a32cf19067fe14052c10b2bac25" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.5.0, SQLite added support for triggers. Information about triggers is stored in the SQLITE_MASTER table. If an older version of SQLite attempts to read a database that contains a CREATE TRIGGER in the SQLITE_MASTER table, the parser will not understand the new syntax and initialization will fail.</source>
          <target state="translated">버전 2.5.0부터 SQLite는 트리거에 대한 지원을 추가했습니다. 트리거에 대한 정보는 SQLITE_MASTER 테이블에 저장됩니다. 이전 버전의 SQLite가 SQLITE_MASTER 테이블에 CREATE TRIGGER가 포함 된 데이터베이스를 읽으려고하면 구문 분석기가 새 구문을 이해하지 못하므로 초기화에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="50c1ec93a00d0cbe5badad130d3d4fbd2db53937" translate="yes" xml:space="preserve">
          <source>Beginning with version 2.7.0, SQLite understands two different datatypes: text and numeric. Text data sorts in memcmp() order. Numeric data sorts in numerical order if it looks like a number, or in memcmp() order if it does not.</source>
          <target state="translated">버전 2.7.0부터 SQLite는 텍스트와 숫자의 두 가지 데이터 유형을 이해합니다. 텍스트 데이터는 memcmp () 순서로 정렬됩니다. 숫자 데이터는 숫자처럼 보이는 경우 숫자 순서로 정렬되거나 그렇지 않으면 memcmp () 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c06e002a374c4a8233bf3048a5c902a5ad629404" translate="yes" xml:space="preserve">
          <source>Beginning with version 3.5, SQLite obtains all of the heap memory it needs using the routines &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;, &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;, and &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc()&lt;/a&gt;. These routines have existed in prior versions of SQLite, but SQLite has previously bypassed these routines and used its own memory allocator. This all changes in version 3.5.0.</source>
          <target state="translated">버전 3.5부터 SQLite는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; , &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_realloc ()&lt;/a&gt; 루틴을 사용하여 필요한 모든 힙 메모리를 얻습니다 . 이러한 루틴은 이전 버전의 SQLite에 존재했지만 SQLite는 이전에 이러한 루틴을 무시하고 자체 메모리 할당자를 사용했습니다. 이것은 버전 3.5.0에서 모두 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb8a180b3917332f0d153bfa0ea4cd9cfa4625e" translate="yes" xml:space="preserve">
          <source>Behavior when page is not already in cache</source>
          <target state="translated">페이지가 캐시에없는 경우의 동작</target>
        </trans-unit>
        <trans-unit id="8f48bb3f768498f6c1f4331bb2d5a6b0f760fe90" translate="yes" xml:space="preserve">
          <source>Below is a simple &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL program&lt;/a&gt; that demonstrates how to use the TCL interface to SQLite. The program executes the SQL statements given as the second argument on the database defined by the first argument. The commands to watch for are the &lt;b&gt;sqlite3&lt;/b&gt; command on line 7 which opens an SQLite database and creates a new object named &quot;&lt;b&gt;db&lt;/b&gt;&quot; to access that database, the use of the &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval method&lt;/a&gt; on the &lt;b&gt;db&lt;/b&gt; object on line 8 to run SQL commands against the database, and the closing of the database connection on the last line of the script.</source>
          <target state="translated">다음은 TCL 인터페이스를 사용하여 SQLite에 사용하는 방법을 보여주는 간단한 &lt;a href=&quot;http://www.tcl-lang.org&quot;&gt;TCL 프로그램&lt;/a&gt; 입니다. 프로그램은 첫 번째 인수로 정의 된 데이터베이스에서 두 번째 인수로 제공된 SQL 문을 실행합니다. 감시 할 명령은 7 행 의 &lt;b&gt;sqlite3&lt;/b&gt; 명령으로 SQLite 데이터베이스를 열고 해당 데이터베이스에 액세스하기 위해 &quot; &lt;b&gt;db&lt;/b&gt; &quot; 라는 새 오브젝트를 작성합니다. 8 행 의 &lt;b&gt;db&lt;/b&gt; 오브젝트에서 &lt;a href=&quot;tclsqlite#eval&quot;&gt;eval 메소드&lt;/a&gt; 를 사용하여 SQL 명령을 실행합니다. 데이터베이스 및 스크립트의 마지막 행에서 데이터베이스 연결을 닫습니다.&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="51e427c04349f8bec5760358d6c76a33f48f0315" translate="yes" xml:space="preserve">
          <source>Below is a simple C program that demonstrates how to use the &lt;a href=&quot;c3ref/intro&quot;&gt;C/C++ interface&lt;/a&gt; to SQLite. The name of a database is given by the first argument and the second argument is one or more SQL statements to execute against the database. The function calls to pay attention to here are the call to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; on line 22 which opens the database, &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec()&lt;/a&gt; on line 28 that executes SQL commands against the database, and &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; on line 33 that closes the database connection.</source>
          <target state="translated">다음은 &lt;a href=&quot;c3ref/intro&quot;&gt;C / C ++ 인터페이스&lt;/a&gt; 를 사용하여 SQLite 에 사용하는 방법을 보여주는 간단한 C 프로그램입니다 . 데이터베이스 이름은 첫 번째 인수로 제공되며 두 번째 인수는 데이터베이스에 대해 실행할 하나 이상의 SQL 문입니다. 여기에 임금의 관심에 함수 호출에 대한 호출입니다 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 데이터베이스가 열립니다 라인 (22)에 &lt;a href=&quot;c3ref/exec&quot;&gt;sqlite3_exec ()&lt;/a&gt; 가 실행이 데이터베이스에 대해 명령을 SQL 것을 라인 (28)과의 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 데이터베이스 연결을 닫 라인 (33)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ff95327015619a83afc17706ad74370a046f84" translate="yes" xml:space="preserve">
          <source>Benefits of SQLite As A File Format</source>
          <target state="translated">파일 형식으로 SQLite의 장점</target>
        </trans-unit>
        <trans-unit id="616211207d8aaf668be94882f808c6f4c9f8f380" translate="yes" xml:space="preserve">
          <source>Benefits of using WITHOUT ROWID</source>
          <target state="translated">ROWID없이 사용할 때의 이점</target>
        </trans-unit>
        <trans-unit id="115df5f31354f3b89a7926f5d6643866714998ab" translate="yes" xml:space="preserve">
          <source>Better Applications</source>
          <target state="translated">더 나은 응용</target>
        </trans-unit>
        <trans-unit id="4f38499da00d33476ac2d33142547447ccd5f2e2" translate="yes" xml:space="preserve">
          <source>Better detection and handling of corrupt database files.</source>
          <target state="translated">손상된 데이터베이스 파일을보다 잘 감지하고 처리합니다.</target>
        </trans-unit>
        <trans-unit id="add6069aec6aedde19e26e2f4dc8b5d52557685c" translate="yes" xml:space="preserve">
          <source>Better error reporting when problems occur during the automatic 2.5.6 to 2.6.0 database format upgrade.</source>
          <target state="translated">자동 2.5.6에서 2.6.0 데이터베이스 형식으로 업그레이드하는 동안 문제가 발생하면 오류보고 기능이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="5c0db7dca50a13779a4f0032e6c97723feb41348" translate="yes" xml:space="preserve">
          <source>Better handling of aggregate queries where the aggregate functions are contained within subqueries.</source>
          <target state="translated">집계 함수가 서브 쿼리 내에 포함되어있는 집계 쿼리를보다 잘 처리합니다.</target>
        </trans-unit>
        <trans-unit id="da084dd71de733c50c5b48104f01706c6f95c252" translate="yes" xml:space="preserve">
          <source>Better labels on column names of the result.</source>
          <target state="translated">결과의 열 이름에 더 나은 레이블.</target>
        </trans-unit>
        <trans-unit id="03681c8056a98d5199927eacf80bcf86a612f164" translate="yes" xml:space="preserve">
          <source>Better optimization of some IN operator expressions.</source>
          <target state="translated">일부 IN 연산자 표현식의 최적화가 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="591ea8e488260fd421c2b234d660007536c8a620" translate="yes" xml:space="preserve">
          <source>Better support for file locking so that two or more processes (or threads) can access the same database simultaneously. More work needed in this area, though.</source>
          <target state="translated">둘 이상의 프로세스 (또는 스레드)가 동일한 데이터베이스에 동시에 액세스 할 수 있도록 파일 잠금 지원이 향상되었습니다. 하지만이 분야에서 더 많은 작업이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="edfa329825b8b1d38ad9507f28f42ef4366de8b4" translate="yes" xml:space="preserve">
          <source>Between them, the contents of the &quot;level&quot; and &quot;idx&quot; fields define the relative age of the segment b-tree. The smaller the value stored in the &quot;level&quot; field, the more recently the segment b-tree was created. If two segment b-trees are of the same &quot;level&quot;, the segment with the larger value stored in the &quot;idx&quot; column is more recent. The PRIMARY KEY constraint on the %_segdir table prevents any two segments from having the same value for both the &quot;level&quot; and &quot;idx&quot; fields.</source>
          <target state="translated">그들 사이에서, &quot;level&quot;및 &quot;idx&quot;필드의 내용은 세그먼트 b- 트리의 상대적 연령을 정의합니다. &quot;레벨&quot;필드에 저장된 값이 작을수록 더 최근에 세그먼트 b- 트리가 작성되었습니다. 두 개의 세그먼트 b- 트리가 동일한 &quot;레벨&quot;인 경우 &quot;idx&quot;열에 더 큰 값을 저장 한 세그먼트가 더 최신입니다. % _segdir 테이블의 PRIMARY KEY 제약 조건으로 인해 두 세그먼트가 &quot;level&quot;및 &quot;idx&quot;필드 모두에 대해 동일한 값을 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a826f46e213d85c4e2bac37d6cf8440b8e199d0" translate="yes" xml:space="preserve">
          <source>Beware of deleting persistent journal files by any other means since the journal file might be hot, in which case deleting it will corrupt the corresponding database file.</source>
          <target state="translated">저널 파일이 뜨거울 수 있으므로 다른 방법으로 영구 저널 파일을 삭제하지 않도록주의하십시오.이 경우 삭제하면 해당 데이터베이스 파일이 손상됩니다.</target>
        </trans-unit>
        <trans-unit id="bb96cbd05d1971e3d28050245a8829dd6b6aafd2" translate="yes" xml:space="preserve">
          <source>Binary operators</source>
          <target state="translated">이진 연산자</target>
        </trans-unit>
        <trans-unit id="d2ac1eab329712a8a9c96ce99d077a92e950ad90" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;../lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">sqlite3_bind _ * () 인터페이스를 사용하여 값을 &lt;a href=&quot;../lang_expr#varparam&quot;&gt;매개 변수에&lt;/a&gt; 바인드하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8d99e3f4d2a89e533a8c574a3feaf717d81ec03" translate="yes" xml:space="preserve">
          <source>Bind values to &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameters&lt;/a&gt; using the sqlite3_bind_*() interfaces.</source>
          <target state="translated">sqlite3_bind _ * () 인터페이스를 사용하여 값을 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수에&lt;/a&gt; 바인드하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e1661e468dacca4fb2103651a60de473fcaf35b" translate="yes" xml:space="preserve">
          <source>Binding Values To Prepared Statements</source>
          <target state="translated">준비된 명령문에 값 바인딩</target>
        </trans-unit>
        <trans-unit id="416ca5a10db41c1cbc8b3d0b2abf3f34e937f4af" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 루틴으로 바인딩을 지우지 않습니다 . 언 바운드 매개 변수는 NULL로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="712e7456596b23817bd39e4145191dbf11698c78" translate="yes" xml:space="preserve">
          <source>Bindings are not cleared by the &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; routine. Unbound parameters are interpreted as NULL.</source>
          <target state="translated">&lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 루틴으로 바인딩을 지우지 않습니다 . 언 바운드 매개 변수는 NULL로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="309af9e25956170a810f78e3c71afc45e9766ccf" translate="yes" xml:space="preserve">
          <source>BitAnd</source>
          <target state="translated">BitAnd</target>
        </trans-unit>
        <trans-unit id="0c26c52f02ad0e8a5ab4b7954c846a924ecffb7e" translate="yes" xml:space="preserve">
          <source>BitNot</source>
          <target state="translated">BitNot</target>
        </trans-unit>
        <trans-unit id="f64578ede789cb16c75f551e17bc358c839da2a7" translate="yes" xml:space="preserve">
          <source>BitOr</source>
          <target state="translated">BitOr</target>
        </trans-unit>
        <trans-unit id="c24315eb20cc1f5a565ec08f29abab31c0925f1a" translate="yes" xml:space="preserve">
          <source>Blob</source>
          <target state="translated">Blob</target>
        </trans-unit>
        <trans-unit id="d309b3faf2ef71b6ca2ba079fca1c0074e7599d4" translate="yes" xml:space="preserve">
          <source>Blob containing the root node of the segment b-tree.</source>
          <target state="translated">세그먼트 b- 트리의 루트 노드를 포함하는 Blob.</target>
        </trans-unit>
        <trans-unit id="d284e53d53a1c613b92c33b3c974704b23b2a857" translate="yes" xml:space="preserve">
          <source>Block until the unlock-notify callback is invoked by another thread.</source>
          <target state="translated">다른 스레드가 잠금 해제 알림 콜백을 호출 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="c9ac379f83771407fb1e0d78aaf3f7b5adc6706f" translate="yes" xml:space="preserve">
          <source>Boolean Expressions</source>
          <target state="translated">부울 식</target>
        </trans-unit>
        <trans-unit id="c4e413aea96ae1ca804567104303036969e3a88f" translate="yes" xml:space="preserve">
          <source>Boolean datatype</source>
          <target state="translated">부울 데이터 유형</target>
        </trans-unit>
        <trans-unit id="cb72c24cf8f622cb6c601ea54b18c1fb6181c3db" translate="yes" xml:space="preserve">
          <source>Boolean expression</source>
          <target state="translated">부울 식</target>
        </trans-unit>
        <trans-unit id="275cc7006db94d75505db825dc5542aed9bfc26c" translate="yes" xml:space="preserve">
          <source>Borland</source>
          <target state="translated">Borland</target>
        </trans-unit>
        <trans-unit id="2198db2aa3b167004c136853d6cdd281fb62f84a" translate="yes" xml:space="preserve">
          <source>Borland Interbase does not support CASE expressions.</source>
          <target state="translated">Borland Interbase는 CASE 표현식을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ddec281bbecd09ca0988545c1af57dbffaa268c1" translate="yes" xml:space="preserve">
          <source>Both UPDATE statements do exactly the same thing. (They generate identical &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt;.) But the first form, the row value form, seems to make it clearer that the intent of the statement is to swap the values in columns A and B.</source>
          <target state="translated">두 UPDATE 문은 모두 정확히 똑같습니다. (동일한 &lt;a href=&quot;opcode&quot;&gt;바이트 코드를&lt;/a&gt; 생성합니다 .) 그러나 첫 번째 형식 인 행 값 형식은 명령문의 의도가 열 A와 B의 값을 바꾸는 것임을 분명히하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dfb4c7d44434c0c4d4db97610721023fe7e4509" translate="yes" xml:space="preserve">
          <source>Both forms of the CASE expression use lazy, or short-circuit, evaluation.</source>
          <target state="translated">CASE 표현의 두 가지 형태는 모두 게으른 또는 단락 평가를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bb63583b07e5e464e63e50a8a4cb32ce2f9c5978" translate="yes" xml:space="preserve">
          <source>Both methods for loading an extension allow you to specify the name of an entry point for the extension. You can leave this argument blank - passing in a NULL pointer for the &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension()&lt;/a&gt; C-language interface or omitting the second argument for the &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension()&lt;/a&gt; SQL interface - and the extension loader logic will attempt to figure out the entry point on its own. It will first try the generic extension name &quot;sqlite3_extension_init&quot;. If that does not work, it constructs a entry point using the template &quot;sqlite3_X_init&quot; where the X is replaced by the lowercase equivalent of every ASCII character in the filename after the last &quot;/&quot; and before the first following &quot;.&quot; omitting the first three characters if they happen to be &quot;lib&quot;. So, for example, if the filename is &quot;/usr/lib/libmathfunc-4.8.so&quot; the entry point name would be &quot;sqlite3_mathfunc_init&quot;. Or if the filename is &quot;./SpellFixExt.dll&quot; then the entry point would be called &quot;sqlite3_spellfixext_init&quot;.</source>
          <target state="translated">확장을로드하는 두 가지 방법 모두 확장에 대한 진입 점의 이름을 지정할 수 있습니다. &lt;a href=&quot;c3ref/load_extension&quot;&gt;sqlite3_load_extension ()&lt;/a&gt; C 언어 인터페이스에 NULL 포인터를 전달 하거나 &lt;a href=&quot;lang_corefunc#load_extension&quot;&gt;load_extension ()에&lt;/a&gt; 대한 두 번째 인수를 생략 하여이 인수를 비워 둘 수 있습니다.SQL 인터페이스-확장 로더 로직은 자체적으로 진입 점을 파악하려고 시도합니다. 먼저 일반 확장명 &quot;sqlite3_extension_init&quot;를 시도합니다. 그래도 작동하지 않으면 &quot;sqlite3_X_init&quot;템플릿을 사용하여 시작점을 생성합니다. 여기서 X는 마지막 &quot;/&quot;다음 및 첫 번째 &quot;&quot; &quot;이전의 파일 이름에서 모든 ASCII 문자에 해당하는 소문자로 바뀝니다. &quot;lib&quot;인 경우 처음 세 문자를 생략합니다. 예를 들어 파일 이름이 &quot;/usr/lib/libmathfunc-4.8.so&quot;인 경우 진입 점 이름은 &quot;sqlite3_mathfunc_init&quot;입니다. 또는 파일 이름이 &quot;./SpellFixExt.dll&quot;인 경우 진입 점은 &quot;sqlite3_spellfixext_init&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8d91ab9fdfa652980c96ceff09049c0ea85b3c70" translate="yes" xml:space="preserve">
          <source>Both of the RBU functions may be accomplished using SQLite's built-in SQL commands - RBU update via a series of &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; and &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; commands within a single transaction, and RBU vacuum by a single &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command. The RBU module provides the following advantages over these simpler approaches:</source>
          <target state="translated">두 RBU 기능은 단일 트랜잭션 내에서 일련의 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; , &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 및 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 명령을 통한 SQLite의 내장 SQL 명령-RBU 업데이트 및 단일 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령에 의한 RBU 진공을 사용하여 수행 할 수 있습니다. RBU 모듈은 이러한 간단한 접근 방식에 비해 다음과 같은 장점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e0f6600d4e5a9c39fa518762238ad90dd63b65fb" translate="yes" xml:space="preserve">
          <source>Both of the above example queries would work fine without the acctchng_magnitude index. The acctchng_magnitude index index merely helps the queries to run faster, especially on databases where there are many entries in the table for each account.</source>
          <target state="translated">위의 두 예제 쿼리 모두 acctchng_magnitude 인덱스가 없으면 제대로 작동합니다. acctchng_magnitude 인덱스 인덱스는 특히 각 계정에 대해 테이블에 많은 항목이있는 데이터베이스에서 쿼리 실행 속도를 높이는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="7a2132ed90a9ffb07d66917a3fc0b34d8d92cac4" translate="yes" xml:space="preserve">
          <source>Both the TCL and TH3 test harnesses automatically track system resources and report resource leaks on &lt;u&gt;every&lt;/u&gt; test run. No special configuration or setup is required. The test harnesses are especially vigilant with regard to memory leaks. If a change causes a memory leak, the test harnesses will recognize this quickly. SQLite is designed to never leak memory, even after an exception such as an OOM error or disk I/O error. The test harnesses are zealous to enforce this.</source>
          <target state="translated">TCL 및 TH3 테스트 하네스는 시스템 테스트를 자동으로 추적하고 &lt;u&gt;모든&lt;/u&gt; 테스트 실행 에서 리소스 누수를보고 합니다. 특별한 구성이나 설정이 필요하지 않습니다. 테스트 하네스는 특히 메모리 누수와 관련하여주의를 기울입니다. 변경으로 인해 메모리 누수가 발생하는 경우 테스트 장치가이를 빠르게 인식합니다. SQLite는 OOM 오류 또는 디스크 I / O 오류와 같은 예외 후에도 메모리가 누출되지 않도록 설계되었습니다. 테스트 하네스는이를 시행하기 위해 열성적입니다.</target>
        </trans-unit>
        <trans-unit id="0ad3d82720f17203691deee7f5777d99c121ae33" translate="yes" xml:space="preserve">
          <source>Both the WHEN clause and the trigger actions may access elements of the row being inserted, deleted or updated using references of the form &quot;NEW.</source>
          <target state="translated">WHEN 절과 트리거 조치 모두 &quot;NEW. 형식의 참조를 사용하여 삽입, 삭제 또는 업데이트되는 행의 요소에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f093637993a88624b64eec10be0614efea759e81" translate="yes" xml:space="preserve">
          <source>Both the pointer and the pointer type parameter to the &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer()&lt;/a&gt; and &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer()&lt;/a&gt; interfaces are &quot;owned&quot; by the caller. In other words, the caller is responsible for ensuring that both values remain valid until after the last access via &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer()&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_pointer ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/result_blob&quot;&gt;sqlite3_result_pointer ()&lt;/a&gt; 인터페이스에 대한 포인터 및 포인터 유형 매개 변수 는 호출자가 &quot;소유&quot;합니다. 다시 말해, 호출자는 &lt;a href=&quot;c3ref/value_blob&quot;&gt;sqlite3_value_pointer ()&lt;/a&gt; 를 통한 마지막 액세스 이후까지 두 값이 모두 유효한 상태를 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2992a96404e75efb9d5d247c72b5e6d63bb4aa3e" translate="yes" xml:space="preserve">
          <source>Boundary value tests</source>
          <target state="translated">경계 값 테스트</target>
        </trans-unit>
        <trans-unit id="3145fd01726b003b2b97b5a9fb483277f3a90dd2" translate="yes" xml:space="preserve">
          <source>Branch coverage in SQLite is currently measured using &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; with the &quot;-b&quot; option. First the test program is compiled using options &quot;-g -fprofile-arcs -ftest-coverage&quot; and then the test program is run. Then &quot;gcov -b&quot; is run to generate a coverage report. The coverage report is verbose and inconvenient to read, so the gcov-generated report is processed using some simple scripts to put it into a more human-friendly format. This entire process is automated using scripts, of course.</source>
          <target state="translated">SQLite의 분기 범위는 현재 &quot;-b&quot;옵션과 함께 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; 를 사용하여 측정됩니다 . 먼저 &quot;-g -fprofile-arcs -ftest-coverage&quot;옵션을 사용하여 테스트 프로그램을 컴파일 한 다음 테스트 프로그램을 실행합니다. 그런 다음 &quot;gcov -b&quot;가 실행되어 적용 범위 보고서를 생성합니다. 적용 범위 보고서는 장황하고 읽기가 불편하므로 gcov 생성 보고서는 간단한 스크립트를 사용하여보다 인간 친화적 인 형식으로 작성됩니다. 이 전체 프로세스는 물론 스크립트를 사용하여 자동화됩니다.</target>
        </trans-unit>
        <trans-unit id="c4adfe3c542d88432092f783bc046835df0fe815" translate="yes" xml:space="preserve">
          <source>Branch coverage is more rigorous than statement coverage. Branch coverage measures the number of machine-code branch instructions that are evaluated at least once on both directions.</source>
          <target state="translated">지점 범위는 명세서 범위보다 더 엄격합니다. 분기 범위는 양방향에서 한 번 이상 평가되는 기계 코드 분기 명령어의 수를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="a22b75ea309c645c4530e03f4541cb259f2d61c7" translate="yes" xml:space="preserve">
          <source>Branch coverage is more strict. With branch coverage, each test and each subblock within the statement is considered separately. In order to achieve 100% branch coverage in the example above, there must be at least three test cases:</source>
          <target state="translated">지점 적용 범위가 더 엄격합니다. 분기 적용 범위를 사용하면 명령문 내의 각 테스트와 각 하위 블록이 별도로 고려됩니다. 위의 예에서 100 % 분기 적용 범위를 달성하려면 최소한 세 가지 테스트 사례가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="97c730065aaff2da27316c3a4fdb27f33630fd48" translate="yes" xml:space="preserve">
          <source>Break out the &quot;Presentor Notes&quot; from each slide into a separate table, for easier access from third-party applications and/or scripts.</source>
          <target state="translated">타사 응용 프로그램 및 / 또는 스크립트에서 쉽게 액세스 할 수 있도록 각 슬라이드의 &quot;발표자 노트&quot;를 별도의 테이블로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="c53bff6ff25ebaccf14a4078fdb0261d0ccc01ee" translate="yes" xml:space="preserve">
          <source>Break out the GDBM driver into a separate file in anticipation to added new drivers.</source>
          <target state="translated">새 드라이버를 추가 할 것으로 예상하여 GDBM 드라이버를 별도의 파일로 분리하십시오.</target>
        </trans-unit>
        <trans-unit id="282c5dfb378bb6abed7a208812bdb6a15f29a876" translate="yes" xml:space="preserve">
          <source>Bring the OS/2 porting layer up-to-date.</source>
          <target state="translated">OS / 2 포팅 계층을 최신 상태로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="82e575ff594a72cfcaccd19ccbf9ad35b704bb47" translate="yes" xml:space="preserve">
          <source>Bring the processing of ORDER BY into compliance with the SQL standard for case where a result alias and a table column name are in conflict. Correct behavior is to prefer the result alias. Older versions of SQLite incorrectly picked the table column. (See ticket #2822.)</source>
          <target state="translated">결과 별명과 테이블 열 이름이 충돌하는 경우 ORDER BY 처리를 SQL 표준에 따르십시오. 올바른 동작은 결과 별칭을 선호하는 것입니다. 이전 버전의 SQLite는 테이블 열을 잘못 선택했습니다. (티켓 # 2822 참조)</target>
        </trans-unit>
        <trans-unit id="4f04fd57f5bfebe96a862aebe73b135def3ab6df" translate="yes" xml:space="preserve">
          <source>Bug fix in the processing of the ORDER BY clause for GROUP BY queries</source>
          <target state="translated">GROUP BY 쿼리에 대한 ORDER BY 절 처리시 버그 수정</target>
        </trans-unit>
        <trans-unit id="a725ca76655ec9003bb82b1a676029a85c0e7d07" translate="yes" xml:space="preserve">
          <source>Bug fix: &quot;SELECT count(*)&quot; was returning NULL for empty tables. Now it returns 0.</source>
          <target state="translated">버그 수정 : &quot;SELECT count (*)&quot;가 빈 테이블에 대해 NULL을 반환했습니다. 이제 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9e476047ffbbf1baca852a2317f6d224dd2d875a" translate="yes" xml:space="preserve">
          <source>Bug fix: Add in a mutex that was omitted from the previous release.</source>
          <target state="translated">버그 수정 : 이전 릴리스에서 생략 된 뮤텍스를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="ab7e0eb1f7494f905f4da13b15772e1fb07bbe1e" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing if &quot;PRAGMA full_column_names=ON;&quot; was set and you did a query that used a rowid, like this: &quot;SELECT rowid, * FROM ...&quot;.</source>
          <target state="translated">버그 수정 : &quot;PRAGMA full_column_names = ON;&quot;인 경우 어설 션이 실패했습니다. &quot;SELECT rowid, * FROM ...&quot;과 같이 rowid를 사용하는 쿼리를 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="421117f09c1ef6c1c766b17bffc8c48c0d11cebc" translate="yes" xml:space="preserve">
          <source>Bug fix: An assertion was failing when a temporary table with an index had the same name as a permanent table created by a separate process.</source>
          <target state="translated">버그 수정 : 인덱스가있는 임시 테이블의 이름이 별도의 프로세스로 작성된 영구 테이블과 동일한 경우 어설 션이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="0dceede8b9155b23f776e96cfdf9ce26f1c18497" translate="yes" xml:space="preserve">
          <source>Bug fix: An attempt to delete a single row of a table with a WHERE clause of &quot;ROWID=x&quot; when no such rowid exists was causing an error.</source>
          <target state="translated">버그 수정 : 그러한 rowid가 없을 때 WHERE 절이 &quot;ROWID = x&quot;인 테이블의 단일 행을 삭제하려는 시도로 인해 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="faaa0c6caea2e40fd936178cd8a1148168d7f164" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid a deadlock or crash if the &lt;a href=&quot;backup&quot;&gt;backup API&lt;/a&gt;, &lt;a href=&quot;sharedcache&quot;&gt;shared cache&lt;/a&gt;, and the SQLite Encryption Extension are all used at once.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;backup&quot;&gt;백업 API&lt;/a&gt; , &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시&lt;/a&gt; 및 SQLite 암호화 확장이 모두 동시에 사용되는 경우 교착 상태 또는 충돌을 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9851f7cc2ef1b47f1ede36a70787a28d8a73936" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid leaking memory on LIMIT and OFFSET clauses in deeply nested UNION ALL queries.</source>
          <target state="translated">버그 수정 : 깊이 중첩 된 UNION ALL 쿼리에서 LIMIT 및 OFFSET 절의 메모리 누수를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="eb351871f180a85fd09c35dd04ce4b51eee599a0" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid segfault when using the &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE operator&lt;/a&gt; inside of a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;lang_createview&quot;&gt;view&lt;/a&gt; in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 내 에서 &lt;a href=&quot;lang_expr#collateop&quot;&gt;COLLATE 연산자를&lt;/a&gt; 사용 하거나 &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 &lt;a href=&quot;lang_createview&quot;&gt;뷰&lt;/a&gt; 를 사용할 때는 segfault를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="a618ecebefb94412f1562472983ff94e3605eaab" translate="yes" xml:space="preserve">
          <source>Bug fix: Avoid various concurrency problems in &lt;a href=&quot;sharedcache&quot;&gt;shared cache mode&lt;/a&gt;.</source>
          <target state="translated">버그 수정 : &lt;a href=&quot;sharedcache&quot;&gt;공유 캐시 모드&lt;/a&gt; 에서 다양한 동시성 문제를 피하십시오 .</target>
        </trans-unit>
        <trans-unit id="633b128d954ff36563e10076bd92bfc7d4d254bc" translate="yes" xml:space="preserve">
          <source>Bug fix: Bare identifiers in ORDER BY clauses bind more tightly to output column names, but identifiers in expressions bind more tightly to input column names. Identifiers in GROUP BY clauses always prefer output column names, however.</source>
          <target state="translated">버그 수정 : ORDER BY 절의 베어 식별자는 출력 열 이름에 더 밀접하게 바인딩되지만 식의 식별자는 입력 열 이름에 더 밀접하게 바인딩됩니다. 그러나 GROUP BY 절의 식별자는 항상 출력 열 이름을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="6a402a829e3faf4148ff927e5cc1ab64a56cfa4a" translate="yes" xml:space="preserve">
          <source>Bug fix: Column names in the result set were not being generated correctly for some (rather complex) VIEWs. This could cause a segfault under certain circumstances.</source>
          <target state="translated">버그 수정 : 결과 집합의 열 이름이 일부 (보다 복잡한) VIEW에 대해 올바르게 생성되지 않았습니다. 특정 상황에서 segfault가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6507d4034fca406ed1e6de7d9c69eb86666298e" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute correct table names with the FULL_COLUMN_NAMES pragma is turned on.</source>
          <target state="translated">버그 수정 : FULL_COLUMN_NAMES pragma를 사용하여 올바른 테이블 이름을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="d170d4831a6701524951017930d51215c0de3ceb" translate="yes" xml:space="preserve">
          <source>Bug fix: Compute the correct answer for queries that contain an IS NOT NULL term in the WHERE clause and also contain an OR term in the WHERE clause and are compiled with &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt;. &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;Ticket [4c86b126f2]&lt;/a&gt;</source>
          <target state="translated">버그 수정 : WHERE 절에 IS NOT NULL 용어가 포함되어 있고 WHERE 절에 OR 용어가 포함되어 있고 &lt;a href=&quot;compile#enable_stat4&quot;&gt;SQLITE_ENABLE_STAT4&lt;/a&gt; 로 컴파일 된 쿼리에 대한 정답을 계산하십시오 . &lt;a href=&quot;http://www.sqlite.org/src/info/4c86b126f2&quot;&gt;티켓 [4c86b126f2]&lt;/a&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
