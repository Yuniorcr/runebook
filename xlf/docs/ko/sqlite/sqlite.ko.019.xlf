<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="sqlite">
    <body>
      <group id="sqlite">
        <trans-unit id="59ef232ad2a9a13529bf5e89145da92a1a6319d6" translate="yes" xml:space="preserve">
          <source>Type affinity</source>
          <target state="translated">친화력</target>
        </trans-unit>
        <trans-unit id="38895187a3c7e29b6f02e06c184834c7180dd221" translate="yes" xml:space="preserve">
          <source>Typical output from a single TH3 test program run looks like this:</source>
          <target state="translated">단일 TH3 테스트 프로그램 실행의 일반적인 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8711d8537a2bf9829ad98f22b75b8b8dc119969c" translate="yes" xml:space="preserve">
          <source>UNBOUNDED</source>
          <target state="translated">UNBOUNDED</target>
        </trans-unit>
        <trans-unit id="363cb5cb9b015bf8fe75ee8f6f3ad675ca5618cc" translate="yes" xml:space="preserve">
          <source>UNION</source>
          <target state="translated">UNION</target>
        </trans-unit>
        <trans-unit id="e0f0a7115a4e0b11973725c719a99090b1a2caa7" translate="yes" xml:space="preserve">
          <source>UNION ALL ... UNION ALL SELECT</source>
          <target state="translated">UNION ALL ... UNION ALL SELECT</target>
        </trans-unit>
        <trans-unit id="2ef896dc8994d71c3776f028df0d2a89b61b4550" translate="yes" xml:space="preserve">
          <source>UNION, UNION ALL, INTERSECT, and EXCEPT</source>
          <target state="translated">UNION, UNION ALL, INTERSECT 및 EXCEPT</target>
        </trans-unit>
        <trans-unit id="c9e6a29d14f3f27cd2ee75b65407552ad50a3078" translate="yes" xml:space="preserve">
          <source>UNIQUE</source>
          <target state="translated">UNIQUE</target>
        </trans-unit>
        <trans-unit id="841c884fb288309550412babe47484ff0e3745f9" translate="yes" xml:space="preserve">
          <source>UNIQUE, CHECK, and NOT NULL constraint errors</source>
          <target state="translated">UNIQUE, CHECK 및 NOT NULL 제약 조건 오류</target>
        </trans-unit>
        <trans-unit id="7ead37d8578ae9705f3d87c1d034addd810cd1ed" translate="yes" xml:space="preserve">
          <source>UNIX mode, as returned by stat(2) for the zip file record (an integer). This identifies the type of record (file, directory or symbolic link), and the associated user/group/all permissions.</source>
          <target state="translated">zip 파일 레코드 (정수)에 대해 stat (2)에 의해 리턴 된 UNIX 모드. 레코드 유형 (파일, 디렉토리 또는 기호 링크) 및 연관된 사용자 / 그룹 / 모든 권한을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="f6fee659655c0db9d5b27d3ee09d34358c974b03" translate="yes" xml:space="preserve">
          <source>UNLOCKED</source>
          <target state="translated">UNLOCKED</target>
        </trans-unit>
        <trans-unit id="d272346adafef58007de20094d2f682eb2fe1bd2" translate="yes" xml:space="preserve">
          <source>UNSIGNED BIG INT</source>
          <target state="translated">서명되지 않은 큰 지능</target>
        </trans-unit>
        <trans-unit id="52c6c1812015585dc1092393a1f244f60d68c60a" translate="yes" xml:space="preserve">
          <source>UPDATE</source>
          <target state="translated">UPDATE</target>
        </trans-unit>
        <trans-unit id="688e558eee1d1bb512a94d0cc620288bf7d472f2" translate="yes" xml:space="preserve">
          <source>UPDATE And DELETE Statements</source>
          <target state="translated">UPDATE 및 DELETE 문</target>
        </trans-unit>
        <trans-unit id="49a16f1602f22a2ff3d079003de17960196cd62b" translate="yes" xml:space="preserve">
          <source>UPDATE Changes</source>
          <target state="translated">업데이트 변경</target>
        </trans-unit>
        <trans-unit id="bf53a6aae01db9b5dad497a7e025817f66502008" translate="yes" xml:space="preserve">
          <source>UPDATE and DELETE statements work similarly.</source>
          <target state="translated">UPDATE 및 DELETE 문은 비슷하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1c9d5c3eed910621fdbd8231e3b605e82a063d04" translate="yes" xml:space="preserve">
          <source>UPDATE statements work very much like DELETE statements except that instead of deleting the record they replace it with a new one. Consider this example:</source>
          <target state="translated">UPDATE 문은 레코드를 삭제하는 대신 새 레코드로 대체한다는 점을 제외하고 DELETE 문과 매우 유사하게 작동합니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="23f1f94678733621721dfbd9281a151e75fd39b3" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b = 'v2' WHERE a=1;</source>
          <target state="translated">업데이트 t1 SET b = 'v2'여기서 a = 1;</target>
        </trans-unit>
        <trans-unit id="9d1ad45a1d025bcccb63dad4f87235cf205b5b63" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=0 AND a&amp;lt;10;</source>
          <target state="translated">업데이트 t1 SET b = b * 2 a&amp;gt; = 0 및 a &amp;lt;10;</target>
        </trans-unit>
        <trans-unit id="7bc4a22623437c880e8e4324cc657c00abd18be7" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=10 AND a&amp;lt;20;</source>
          <target state="translated">업데이트 t1 SET b = b * 2 여기서 a&amp;gt; = 10 및 a &amp;lt;20;</target>
        </trans-unit>
        <trans-unit id="69fa4f2a787b8c6d32fe94ec05425d1fb170202e" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9980 AND a&amp;lt;9990;</source>
          <target state="translated">업데이트 t1 SET b = b * 2 여기서 a&amp;gt; = 9980 및 a &amp;lt;9990;</target>
        </trans-unit>
        <trans-unit id="bd6a359ea6d6ffa5fa77996361d46448cd59ce9f" translate="yes" xml:space="preserve">
          <source>UPDATE t1 SET b=b*2 WHERE a&amp;gt;=9990 AND a&amp;lt;10000;</source>
          <target state="translated">업데이트 t1 SET b = b * 2 여기서 a&amp;gt; = 9990 및 a &amp;lt;10000;</target>
        </trans-unit>
        <trans-unit id="0afa724368a197872d6c5ffb446fe74a06bc33c2" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=121928 WHERE a=2;</source>
          <target state="translated">업데이트 t2 SET b = 121928 여기서 a = 2;</target>
        </trans-unit>
        <trans-unit id="3526291b0bb67daddf75ff2b44713d0b345a7083" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=347393 WHERE a=25000;</source>
          <target state="translated">업데이트 t2 SET b = 347393 여기서 a = 25000;</target>
        </trans-unit>
        <trans-unit id="1e3a05f35bab1c3145c54848bb462d616f180f96" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=35065 WHERE a=24999;</source>
          <target state="translated">업데이트 t2 SET b = 35065 어디에서 = 24999;</target>
        </trans-unit>
        <trans-unit id="83da842c2149e8d92733fb66a7c52922e2a8bb02" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET b=468026 WHERE a=1;</source>
          <target state="translated">업데이트 t2 SET b = 468026 여기서 a = 1;</target>
        </trans-unit>
        <trans-unit id="abe0aeef0bc8c95cf7dba0b992e2c26051c0fbd4" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='one hundred forty eight thousand three hundred eighty two' WHERE a=1;</source>
          <target state="translated">업데이트 t2 SET c = '백사 십팔 삼백 팔십이'어디에서 = 1;</target>
        </trans-unit>
        <trans-unit id="2e646600f6e7b2bb70471ce989105819d65503b9" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred eighty three thousand ninety nine' WHERE a=24999;</source>
          <target state="translated">업데이트 t2 SET c = '삼백 팔십 삼십 구'의 경우 a = 24999;</target>
        </trans-unit>
        <trans-unit id="24be2b2373e2e643ec5af7225d298b219c086994" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='three hundred sixty six thousand five hundred two' WHERE a=2;</source>
          <target state="translated">업데이트 t2 SET c = '삼백 육십 오백이'어디에서 a = 2;</target>
        </trans-unit>
        <trans-unit id="317adbaa4dc2a3c2843d99c6771359a7f0624c58" translate="yes" xml:space="preserve">
          <source>UPDATE t2 SET c='two hundred fifty six thousand eight hundred thirty' WHERE a=25000;</source>
          <target state="translated">업데이트 t2 SET c = '이백 오천 팔백 삼십'어디에서 = 25000;</target>
        </trans-unit>
        <trans-unit id="c55112b254b71dd5f11927b24c53d183f3ed4118" translate="yes" xml:space="preserve">
          <source>UPSERT</source>
          <target state="translated">UPSERT</target>
        </trans-unit>
        <trans-unit id="6eee69d236c66ab4ffc25696fb830833cbb3fd3c" translate="yes" xml:space="preserve">
          <source>UPSERT does not currently work for &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;.</source>
          <target state="translated">UPSERT는 현재 &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 에서 작동하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1c2066bfe0e8babe467800cce0c33996ece301c4" translate="yes" xml:space="preserve">
          <source>UPSERT is a special syntax addition to &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; that causes the INSERT to behave as an &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; or a no-op if the INSERT would violate a uniqueness constraint. UPSERT is not standard SQL. UPSERT in SQLite follows the syntax established by PostgreSQL. UPSERT syntax was added to SQLite with version 3.24.0 (2018-06-04).</source>
          <target state="translated">UPSERT이에게 특별한 구문 추가되었습니다 &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; int로서 행동 할 수있는 INSERT가 발생 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 삽입이 고유성 제약 조건을 위반하는 경우 또는 어떤 조합을. UPSERT는 표준 SQL이 아닙니다. SQLite의 UPSERT는 PostgreSQL에서 설정 한 구문을 따릅니다. UPSERT 구문이 버전 3.24.0 (2018-06-04)의 SQLite에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="095b20b5d88a77f400266be9db4f8fd23dca8121" translate="yes" xml:space="preserve">
          <source>URI Filenames</source>
          <target state="translated">URI 파일 이름</target>
        </trans-unit>
        <trans-unit id="6b3e19882ec7248890e4c5d13ea994d174863955" translate="yes" xml:space="preserve">
          <source>URI filename examples</source>
          <target state="translated">URI 파일 이름 예제</target>
        </trans-unit>
        <trans-unit id="5e847e5e42eefec738b40d802039de3c59cd0211" translate="yes" xml:space="preserve">
          <source>URI filenames</source>
          <target state="translated">URI 파일 이름</target>
        </trans-unit>
        <trans-unit id="bcc83fb4f795835fa81fea70c5b7f4ce3da5fb80" translate="yes" xml:space="preserve">
          <source>URI filenames are parsed according to RFC 3986. If the URI contains an authority, then it must be either an empty string or the string &quot;localhost&quot;. If the authority is not an empty string or &quot;localhost&quot;, an error is returned to the caller. The fragment component of a URI, if present, is ignored.</source>
          <target state="translated">URI 파일 이름은 RFC 3986에 따라 구문 분석됩니다. URI에 권한이 포함 된 경우 빈 문자열이거나 &quot;localhost&quot;문자열이어야합니다. 권한이 빈 문자열 또는 &quot;localhost&quot;가 아닌 경우 호출자에게 오류가 리턴됩니다. URI의 조각 구성 요소가 있으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f52fa99533bd53d2651964895f6aead88e88448d" translate="yes" xml:space="preserve">
          <source>URI filenames in sqlite3_open()</source>
          <target state="translated">sqlite3_open ()의 URI 파일 이름</target>
        </trans-unit>
        <trans-unit id="26ed4ff394970482b699209414b942167f2dd638" translate="yes" xml:space="preserve">
          <source>URI hexadecimal escape sequences (%HH) are supported within the path and query components of a URI. A hexadecimal escape sequence consists of a percent sign - &quot;%&quot; - followed by exactly two hexadecimal digits specifying an octet value. Before the path or query components of a URI filename are interpreted, they are encoded using UTF-8 and all hexadecimal escape sequences replaced by a single byte containing the corresponding octet. If this process generates an invalid UTF-8 encoding, the results are undefined.</source>
          <target state="translated">URI 16 진 이스케이프 시퀀스 (% HH)는 URI의 경로 및 쿼리 구성 요소 내에서 지원됩니다. 16 진 이스케이프 시퀀스는 퍼센트 부호 ( &quot;%&quot;)와 8 진수 값을 지정하는 정확히 2 개의 16 진 숫자로 구성됩니다. URI 파일 이름의 경로 또는 쿼리 구성 요소가 해석되기 전에 UTF-8을 사용하여 인코딩되고 모든 16 진수 이스케이프 시퀀스가 ​​해당 옥텟을 포함하는 단일 바이트로 대체됩니다. 이 프로세스가 유효하지 않은 UTF-8 인코딩을 생성하면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40da99c368fe0d628f9b0dcc937070f1edfd1b1f" translate="yes" xml:space="preserve">
          <source>URIs are processed as UTF8 text. The filename argument sqlite3_open16() is converted from UTF16 native byte order into UTF8 prior to processing.</source>
          <target state="translated">URI는 UTF8 텍스트로 처리됩니다. 파일 이름 인수 sqlite3_open16 ()은 처리하기 전에 UTF16 기본 바이트 순서에서 UTF8로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="41b3da30e1707f2b0bc331e3534b952825349eed" translate="yes" xml:space="preserve">
          <source>USB flash memory sticks seem to be especially pernicious liars regarding sync requests. One can easily see this by committing a large transaction to an SQLite database on a USB memory stick. The COMMIT command will return relatively quickly, indicating that the memory stick has told the operating system and the operating system has told SQLite that all content is safely in persistent storage, and yet the LED on the end of the memory stick will continue flashing for several more seconds. Pulling out the memory stick while the LED is still flashing will frequently result in database corruption.</source>
          <target state="translated">USB 플래시 메모리 스틱은 동기화 요청과 관련하여 특히 악의적 인 거짓말로 보입니다. USB 메모리 스틱의 SQLite 데이터베이스에 큰 트랜잭션을 커밋하면이를 쉽게 확인할 수 있습니다. COMMIT 명령은 비교적 빠르게 리턴되어 메모리 스틱이 운영 체제에 알리고 운영 체제가 SQLite에 모든 컨텐츠가 지속적 스토리지에 안전하게 있음을 알 렸지만 메모리 스틱 끝에있는 LED가 여러 번 계속 깜박임을 나타냅니다. 더 많은 초. LED가 계속 깜박이는 동안 메모리 스틱을 당기면 데이터베이스가 손상되는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="b0138e4f9dc0aacc367a1f86d8e4506b943320e8" translate="yes" xml:space="preserve">
          <source>USING</source>
          <target state="translated">USING</target>
        </trans-unit>
        <trans-unit id="4a2b12a8f9db417e4cc5f36a3e1c2fec1469fe7f" translate="yes" xml:space="preserve">
          <source>UTC timestamp, in seconds since the UNIX epoch (an integer).</source>
          <target state="translated">UNIX 시간 (정수) 이후의 UTC 시간 소인 (초)입니다.</target>
        </trans-unit>
        <trans-unit id="28ef7752ac0283beed8e66a2b5b204db183549fd" translate="yes" xml:space="preserve">
          <source>Unallocated space</source>
          <target state="translated">할당되지 않은 공간</target>
        </trans-unit>
        <trans-unit id="b0b4a5a01660223c1f1c6d19e4a89997fe5e3325" translate="yes" xml:space="preserve">
          <source>Unary &quot;-&quot;</source>
          <target state="translated">단항 &quot;-&quot;</target>
        </trans-unit>
        <trans-unit id="6bfa68ac4d2f61f36caa0def08a4a0095686e16a" translate="yes" xml:space="preserve">
          <source>Undefined BEFORE trigger behavior</source>
          <target state="translated">정의되지 않은 BEFORE 트리거 동작</target>
        </trans-unit>
        <trans-unit id="9e37e5dd8e036cac3e0f290adf0e16da58e3ffe8" translate="yes" xml:space="preserve">
          <source>Undefined behavior checks</source>
          <target state="translated">정의되지 않은 동작 확인</target>
        </trans-unit>
        <trans-unit id="79dfa4a9456d7e99f2303579887d4ea94c961a44" translate="yes" xml:space="preserve">
          <source>Under Unix, an &lt;b&gt;sqlite*&lt;/b&gt; pointer should not be carried across a &lt;b&gt;fork()&lt;/b&gt; system call into the child process. The child process should open its own copy of the database after the &lt;b&gt;fork()&lt;/b&gt;.</source>
          <target state="translated">유닉스에서는 &lt;b&gt;sqlite *&lt;/b&gt; 포인터를 &lt;b&gt;fork ()&lt;/b&gt; 시스템 호출을 통해 자식 프로세스로 가져 와서 는 안됩니다 . 자식 프로세스는 &lt;b&gt;fork ()&lt;/b&gt; 다음에 자체 데이터베이스 복사본을 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7887974e08825eb481696126029ce641dab388bf" translate="yes" xml:space="preserve">
          <source>Under Unix, you should not carry an open SQLite database across a fork() system call into the child process.</source>
          <target state="translated">Unix에서는 fork () 시스템 호출을 통해 열린 SQLite 데이터베이스를 하위 프로세스로 가져 와서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="d2245919272810b035145426205e128fae32a19a" translate="yes" xml:space="preserve">
          <source>Under most circumstances, the original LIKE or GLOB operator is still tested against each input row even if the virtual terms are used to constrain an index. This is because we do not know what additional constraints may be imposed by characters to the right of the</source>
          <target state="translated">대부분의 상황에서 가상 용어를 사용하여 인덱스를 제한하더라도 원래 LIKE 또는 GLOB 연산자는 각 입력 행에 대해 테스트됩니다. 이는 오른쪽에있는 문자가 어떤 추가 제한을 가할 수 있는지 알 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="0aafde4f0303b5c58e56ca1461baa83fd0408041" translate="yes" xml:space="preserve">
          <source>Unfortunately, SQLite contains many branch instructions that help the code run faster without changing the output. Such branches generate false-positives during mutation testing. As an example, consider the following &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;hash function&lt;/a&gt; used to accelerate table-name lookup:</source>
          <target state="translated">불행히도 SQLite에는 출력을 변경하지 않고 코드를 더 빠르게 실행하는 데 도움이되는 많은 분기 명령이 포함되어 있습니다. 이러한 분지는 돌연변이 테스트 중에 가양 성을 생성합니다. 예를 들어, 테이블 이름 조회를 가속화하는 데 사용되는 다음 &lt;a href=&quot;https://www.sqlite.org/src/artifact/55b5fb474?ln=55-62&quot;&gt;해시 함수를&lt;/a&gt; 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c6793d3cab2ac8df02302e6322b00044082495f" translate="yes" xml:space="preserve">
          <source>Unfortunately, algorithm-2 is slower than algorithm-1 in this application.</source>
          <target state="translated">불행하게도,이 어플리케이션에서 algorithm-2는 algorithm-1보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="fcfb2377607479ca817d6a09b03610de66f64da2" translate="yes" xml:space="preserve">
          <source>Unfortunately, even though virtual tables are ignored by default, any &lt;a href=&quot;fts3#*shadowtab&quot;&gt;underlying database tables&lt;/a&gt; that they create in order to store data within the database are not, and &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; will include add these to any RBU database. For this reason, users attempting to use sqldiff to create RBU updates to apply to target databases with one or more virtual tables will likely have to run sqldiff using the --table option separately for each table to update in the target database.</source>
          <target state="translated">불행하게도, 가상 테이블은 기본적으로 무시 되더라도 &lt;a href=&quot;fts3#*shadowtab&quot;&gt;데이터베이스&lt;/a&gt; 내에 데이터를 저장하기 위해 작성 하는 기본 데이터베이스 테이블 은 포함 되지 않으며 &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; 는이를 RBU 데이터베이스에 추가합니다. 이러한 이유로 sqldiff를 사용하여 하나 이상의 가상 테이블이있는 대상 데이터베이스에 적용하기 위해 RBU 업데이트를 작성하려는 사용자는 대상 데이터베이스에서 업데이트 할 각 테이블에 대해 --table 옵션을 사용하여 sqldiff를 별도로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c58a4f6c2a537b213079cd1adcaa6b2001643e9a" translate="yes" xml:space="preserve">
          <source>Unfortunately, most consumer-grade mass storage devices lie about syncing. Disk drives will report that content is safely on persistent media as soon as it reaches the track buffer and before actually being written to oxide. This makes the disk drives seem to operate faster (which is vitally important to the manufacturer so that they can show good benchmark numbers in trade magazines). And in fairness, the lie normally causes no harm, as long as there is no power loss or hard reset prior to the track buffer actually being written to oxide. But if a power loss or hard reset does occur, and if that results in content that was written after a sync reaching oxide while content written before the sync is still in a track buffer, then database corruption can occur.</source>
          <target state="translated">불행히도, 대부분의 소비자 급 대용량 저장 장치는 동기화에 있습니다. 디스크 드라이브는 내용이 트랙 버퍼에 도달하자마자 실제로 산화물에 기록되기 전에 영구 미디어에 안전하게 있다고보고합니다. 이로 인해 디스크 드라이브가 더 빠르게 작동하는 것처럼 보입니다 (제조업체가 트레이드 매거진에서 우수한 벤치 마크 번호를 표시 할 수 있도록 제조업체에게 매우 중요합니다). 그리고 공정하게, 트랙 버퍼가 실제로 산화물에 기록되기 전에 전력 손실 또는 하드 리셋이없는 한 거짓말은 일반적으로 해를 끼치 지 않습니다. 그러나 전원 손실 또는 하드 리셋이 발생하여 동기화 이전에 작성된 내용이 여전히 트랙 버퍼에있는 동안 동기화 후 산화물에 도달 한 후 작성된 내용이 발생하면 데이터베이스가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af520d1880e5ee3cdc82e50d4d1525585fc7beb9" translate="yes" xml:space="preserve">
          <source>Unfortunately, the NGQP caused a performance regression in Fossil.</source>
          <target state="translated">불행히도 NGQP는 화석에서 성능 회귀를 일으켰습니다.</target>
        </trans-unit>
        <trans-unit id="7536fed3548161a0855cd29750230303476e4484" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs (including possible security exploits) were often found when pushing SQLite to extremes. For this reason, newer versions of SQLite have well-defined limits and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">불행히도, 무제한 정책은 문제를 일으키는 것으로 나타났습니다. 상한이 제대로 정의되지 않았기 때문에 테스트되지 않았으며 SQLite를 극도로 추진할 때 버그 (보안 가능한 익스플로잇 포함)가 종종 발견되었습니다. 이러한 이유로 최신 버전의 SQLite에는 잘 정의 된 한계가 있으며 이러한 한계는 &lt;a href=&quot;testing&quot;&gt;테스트 스위트의&lt;/a&gt; 일부로 테스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="154cee1be1782349508f9f52cb47759ac0528fca" translate="yes" xml:space="preserve">
          <source>Unfortunately, the no-limits policy has been shown to create problems. Because the upper bounds were not well defined, they were not tested, and bugs were often found when pushing SQLite to extremes. For this reason, versions of SQLite since about release 3.5.8 (2008-04-16) have well-defined limits, and those limits are tested as part of the &lt;a href=&quot;testing&quot;&gt;test suite&lt;/a&gt;.</source>
          <target state="translated">불행히도 제한 없음 정책은 문제를 일으키는 것으로 나타났습니다. 상한이 잘 정의되지 않았기 때문에 테스트되지 않았으며 SQLite를 극한으로 밀 때 종종 버그가 발견되었습니다. 이러한 이유로 릴리스 3.5.8 (2008-04-16) 이후 SQLite 버전에는 제한이 잘 정의되어 있으며 이러한 제한은 &lt;a href=&quot;testing&quot;&gt;테스트 제품군의&lt;/a&gt; 일부로 테스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="9809fad4d13ccafd43c46a06696bc5f74c1752de" translate="yes" xml:space="preserve">
          <source>Unfortunately, the query plan computed by NN for TPC-H Q8 is not optimal. The plan computed using NN is R-N1-N2-S-C-O-L-P with a cost of 36.92. The notation in the previous sentence means that the R table is run in the outer loop, N1 is in the next inner loop, N2 is in the third loop, and so forth down to P which is in the inner-most loop. The shortest path through the graph (as found via exhaustive search) is P-L-O-C-N1-R-S-N2 with a cost of 27.38. The difference might not seem like much, but remember that the costs are logarithmic, so the shortest path is nearly 750 times faster than that path found using the NN heuristic.</source>
          <target state="translated">불행하게도, NN에서 TPC-H Q8에 대해 계산 한 쿼리 계획은 최적이 아닙니다. NN을 사용하여 계산 된 계획은 36.92의 비용으로 R-N1-N2-SCOLP입니다. 이전 문장의 표기법은 R 테이블이 외부 루프에서 실행되고 N1은 다음 내부 루프에 있고 N2는 세 번째 루프에 있으며 가장 안쪽 루프에있는 P로 내려갑니다. 그래프를 통한 최단 경로 (전체 검색을 통해 찾은)는 27.38의 비용으로 PLOC-N1-RS-N2입니다. 차이는 그리 많지 않지만 비용은 대수적이라는 점을 기억하십시오. 따라서 최단 경로는 NN 휴리스틱을 사용하여 찾은 경로보다 거의 750 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="12b20c37115e65b5f7d7e36cc94465f524bad30b" translate="yes" xml:space="preserve">
          <source>Uniform Resource Identifiers</source>
          <target state="translated">균일 한 자원 식별자</target>
        </trans-unit>
        <trans-unit id="77df08227da6ac685804effa87058e13d84c4065" translate="yes" xml:space="preserve">
          <source>Unique constraint</source>
          <target state="translated">독특한 제약</target>
        </trans-unit>
        <trans-unit id="aa980d194e964e7fb7f97273f5336434b107da41" translate="yes" xml:space="preserve">
          <source>Unique index</source>
          <target state="translated">고유 인덱스</target>
        </trans-unit>
        <trans-unit id="7157e0defd66f64a5eef1f6b25ed305c7ea76e58" translate="yes" xml:space="preserve">
          <source>Unix builds come with multiple built-in VFSes. The default VFS for unix is called &quot;unix&quot; and is used in most applications. Other VFSes that might be found in unix (depending on compile-time options) include:</source>
          <target state="translated">유닉스 빌드에는 여러 개의 내장 VFS가 제공됩니다. 유닉스 용 기본 VFS는 &quot;unix&quot;라고하며 대부분의 응용 프로그램에서 사용됩니다. 유닉스에서 찾을 수있는 다른 VFS (컴파일 타임 옵션에 따라 다름)는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="e08358316619a161ecbcf33073f1d600c7a3d1d8" translate="yes" xml:space="preserve">
          <source>Unless SQLite is running in &quot;auto_vacuum=FULL&quot; mode, when a large amount of data is deleted from the database file it leaves behind empty space, or &quot;free&quot; database pages. This means the database file might be larger than strictly necessary. Running VACUUM to rebuild the database reclaims this space and reduces the size of the database file.</source>
          <target state="translated">SQLite가 &quot;auto_vacuum = FULL&quot;모드에서 실행되지 않는 한 데이터베이스 파일에서 많은 양의 데이터가 삭제되면 빈 공간 또는 &quot;사용 가능한&quot;데이터베이스 페이지가 남습니다. 이는 데이터베이스 파일이 꼭 필요한 것보다 클 수 있음을 의미합니다. VACUUM을 실행하여 데이터베이스를 재 구축하면이 공간이 회수되고 데이터베이스 파일의 크기가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="0e73f60b051af43064d6e0d8d691c92bf067b075" translate="yes" xml:space="preserve">
          <source>Unless a specific tokenizer is specified as part of the CREATE VIRTUAL TABLE statement used to create the FTS table, the default tokenizer, &quot;simple&quot;, is used. The simple tokenizer extracts tokens from a document or basic FTS full-text query according to the following rules:</source>
          <target state="translated">FTS 테이블을 작성하는 데 사용 된 CREATE VIRTUAL TABLE 문의 일부로 특정 토크 나이저를 지정하지 않으면 기본 토크 나이저 인 &quot;simple&quot;이 사용됩니다. 단순 토크 나이 저는 다음 규칙에 따라 문서 또는 기본 FTS 전체 텍스트 쿼리에서 토큰을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="5fdc85037d052204b60739c85a692574cdca8812" translate="yes" xml:space="preserve">
          <source>Unless deadlock is detected (see below), sqlite3_unlock_notify() always returns SQLITE_OK.</source>
          <target state="translated">교착 상태가 감지되지 않으면 (아래 참조) sqlite3_unlock_notify ()는 항상 SQLITE_OK를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c4feec28833f0a64ab53ef0f49205604d9d8edc" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the table data.</source>
          <target state="translated">CREATE TABLE ... AS SELECT 문이 아닌 경우 CREATE TABLE은 하나 이상의 &lt;a href=&quot;syntax/column-def&quot;&gt;열 정의를 포함&lt;/a&gt; 하며 선택적으로 &lt;a href=&quot;syntax/table-constraint&quot;&gt;테이블 제약 조건&lt;/a&gt; 목록이 뒤 따릅니다 . 각 열 정의는 열 이름, 선택적으로 선언 된 열 유형, 하나 이상의 선택적 &lt;a href=&quot;syntax/column-constraint&quot;&gt;열 제약 조건으로 구성&lt;/a&gt; 됩니다. COLLATE 및 DEFAULT 절은 테이블이 포함 할 수있는 데이터를 제한하지 않는다는 점에서 실제로 제약이 아니지만 이전 명령문의 목적을 위해 &quot;열 제약 조건&quot;의 정의에 포함되었습니다. 다른 제약 조건 (NOT NULL, CHECK, UNIQUE, PRIMARY KEY 및 FOREIGN KEY 제약 조건)은 테이블 데이터에 제한을 부과합니다.</target>
        </trans-unit>
        <trans-unit id="318eb4656e47b06b6ea5260cd43d217bcb29a47f" translate="yes" xml:space="preserve">
          <source>Unless it is a CREATE TABLE ... AS SELECT statement, a CREATE TABLE includes one or more &lt;a href=&quot;syntax/column-def&quot;&gt;column definitions&lt;/a&gt;, optionally followed by a list of &lt;a href=&quot;syntax/table-constraint&quot;&gt;table constraints&lt;/a&gt;. Each column definition consists of the name of the column, optionally followed by the declared type of the column, then one or more optional &lt;a href=&quot;syntax/column-constraint&quot;&gt;column constraints&lt;/a&gt;. Included in the definition of &quot;column constraints&quot; for the purposes of the previous statement are the COLLATE and DEFAULT clauses, even though these are not really constraints in the sense that they do not restrict the data that the table may contain. The other constraints - NOT NULL, CHECK, UNIQUE, PRIMARY KEY and FOREIGN KEY constraints - impose restrictions on the tables data, and are are described under &lt;a href=&quot;lang_createtable#constraints&quot;&gt;SQL Data Constraints&lt;/a&gt; below.</source>
          <target state="translated">CREATE TABLE ... AS SELECT 문이 아닌 한 CREATE TABLE에는 하나 이상의 &lt;a href=&quot;syntax/column-def&quot;&gt;열 정의가 포함&lt;/a&gt; 되며 선택적으로 &lt;a href=&quot;syntax/table-constraint&quot;&gt;테이블 제약 조건&lt;/a&gt; 목록이 뒤 따릅니다 . 각 열 정의는 열의 이름으로 구성되며, 선택적으로 열의 선언 된 유형, 하나 이상의 선택적 &lt;a href=&quot;syntax/column-constraint&quot;&gt;열 제한 조건으로 구성&lt;/a&gt; 됩니다. 이전 명령문의 목적을 위해 &quot;열 제한 조건&quot;의 정의에는 COLLATE 및 DEFAULT 절이 포함됩니다. 비록 테이블이 포함 할 수있는 데이터를 제한하지 않는다는 점에서 실제로는 제한 조건이 아닙니다. NOT NULL, CHECK, UNIQUE, PRIMARY KEY 및 FOREIGN KEY 제약 조건과 같은 다른 제약 조건은 테이블 데이터에 제한을 부과하며 &lt;a href=&quot;lang_createtable#constraints&quot;&gt; SQL 데이터 제약 조건에&lt;/a&gt;아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c00ba237aa117de710c9323f816c96f6ada7a01" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">SQLITE_MISUSE를 리턴하지 않으면 sqlite3_wal_checkpoint_v2 () 인터페이스는 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode ()에&lt;/a&gt; 의해 조회되는 오류 정보를 설정합니다. 및 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg ()에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e06b73ee3affa8214cc1405f997b2bb6e5fc2af" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, the sqlite3_wal_checkpoint_v2() interface sets the error information that is queried by &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt;.</source>
          <target state="translated">그것은 SQLITE_MISUSE의 sqlite3_wal_checkpoint_v2 () 인터페이스에 의해 쿼리 오류 정보 설정 반환하지 않는 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode을 ()&lt;/a&gt; 와&lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg ()에&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4591266e2017f729f7aff5d0aced794f6644a4c3" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">이 SQLITE_MISUSE을 반환하지 않는 한,이 기능은 설정 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 통해 액세스 오류 코드 및 메시지 &lt;a href=&quot;#sqlite3_errcode&quot;&gt;sqlite3_errcode를 ()&lt;/a&gt; 및&lt;a href=&quot;#sqlite3_errcode&quot;&gt; sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 .</target>
        </trans-unit>
        <trans-unit id="0e4971f6a57c5c65a9a1ae31e9cf2a3e92d4934e" translate="yes" xml:space="preserve">
          <source>Unless it returns SQLITE_MISUSE, this function sets the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; error code and message accessible via &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode()&lt;/a&gt; and &lt;a href=&quot;errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; and related functions.</source>
          <target state="translated">이 SQLITE_MISUSE을 반환하지 않는 한,이 기능은 설정 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 을 통해 액세스 오류 코드 및 메시지 &lt;a href=&quot;errcode&quot;&gt;sqlite3_errcode를 ()&lt;/a&gt; 및&lt;a href=&quot;errcode&quot;&gt; sqlite3_errmsg ()&lt;/a&gt; 및 관련 함수 .</target>
        </trans-unit>
        <trans-unit id="b37e8216d0e44ec2efee716d4c9dd7d3e0183bf7" translate="yes" xml:space="preserve">
          <source>Unless the &lt;a href=&quot;optoverview#flattening&quot;&gt;flattening optimization&lt;/a&gt; is applied, if a subquery appears in the FROM clause of a SELECT statement, SQLite can either run the subquery and stores the results in a temporary table, or it can run the subquery as a co-routine. The following query is an example of the latter. The subquery is run by a co-routine. The outer query blocks whenever it needs another row of input from the subquery. Control switches to the co-routine which produces the desired output row, then control switches back to the main routine which continues processing.</source>
          <target state="translated">그렇지 않으면 &lt;a href=&quot;optoverview#flattening&quot;&gt;병합 최적화&lt;/a&gt; 가 적용 경우 하위 쿼리가 SELECT 문의 FROM 절에 나타나면 SQLite는 하위 쿼리를 실행하고 결과를 임시 테이블에 저장하거나 하위 쿼리를 공동 루틴으로 실행할 수 있습니다. 다음 쿼리는 후자의 예입니다. 서브 쿼리는 공동 루틴에 의해 실행됩니다. 외부 쿼리는 하위 쿼리에서 다른 입력 행이 필요할 때마다 차단합니다. 제어는 원하는 출력 행을 생성하는 코 루틴으로 전환 한 다음 제어는 메인 루틴으로 되돌아가 처리를 계속합니다.</target>
        </trans-unit>
        <trans-unit id="6debb16b797e55251f765dccb022c7b2f7c44222" translate="yes" xml:space="preserve">
          <source>Unlike most SQL databases, SQLite does not restrict the type of data that may be inserted into a column based on the columns declared type. Instead, SQLite uses &lt;a href=&quot;datatype3&quot;&gt;dynamic typing&lt;/a&gt;. The declared type of a column is used to determine the &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; of the column only.</source>
          <target state="translated">대부분의 SQL 데이터베이스와 달리 SQLite는 선언 된 열 유형에 따라 열에 삽입 될 수있는 데이터 유형을 제한하지 않습니다. 대신 SQLite는 &lt;a href=&quot;datatype3&quot;&gt;동적 입력을&lt;/a&gt; 사용합니다 . 선언 된 열 유형은 열의 &lt;a href=&quot;datatype3#affinity&quot;&gt;선호도&lt;/a&gt; 만 결정하는 데 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="8fc35fdda18e32589afbc6422311960ed986aa1d" translate="yes" xml:space="preserve">
          <source>Unlike most other SQL implementations, SQLite does not have a separate BOOLEAN data type. Instead, TRUE and FALSE are (normally) represented as integers 1 and 0, respectively. This does not seem to cause many problems, as we seldom get complaints about it. But it is important to recognize.</source>
          <target state="translated">대부분의 다른 SQL 구현과 달리 SQLite에는 별도의 BOOLEAN 데이터 형식이 없습니다. 대신 TRUE와 FALSE는 각각 정수 1과 0으로 표시됩니다. 우리가 거의 불만을 제기하기 때문에 이것은 많은 문제를 일으키는 것으로 보이지 않습니다. 그러나 인식하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="19f905f254ee85ddda7a69f550a125cf0e71bdf9" translate="yes" xml:space="preserve">
          <source>Unlike option values and column names, SQL text literals intended as tokenizers must be quoted using single quote characters. For example:</source>
          <target state="translated">옵션 값 및 열 이름과 달리 토크 나이저로 의도 된 SQL 텍스트 리터럴은 작은 따옴표 문자를 사용하여 따옴표로 묶어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a575ebe60947d8ad09098452667c713c7ab1bb2" translate="yes" xml:space="preserve">
          <source>Unlike ordinary functions, window functions cannot use the DISTINCT keyword. Also, Window functions may only appear in the result set and in the ORDER BY clause of a SELECT statement.</source>
          <target state="translated">일반 함수와 달리 창 함수는 DISTINCT 키워드를 사용할 수 없습니다. 또한 창 함수는 결과 집합과 SELECT 문의 ORDER BY 절에만 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f67d962c33cac256671fd15a0b1070b30d60167" translate="yes" xml:space="preserve">
          <source>Unlike other OMIT options which make the SQLite library smaller, this option actually increases the size of SQLite and makes it run a little slower. Only use this option if SQLite is being built for an embedded target that does not support WSD.</source>
          <target state="translated">SQLite 라이브러리를 더 작게 만드는 다른 OMIT 옵션과 달리이 옵션은 실제로 SQLite의 크기를 늘리고 약간 느리게 실행합니다. Wite를 지원하지 않는 임베디드 대상에 대해 SQLite를 빌드하는 경우에만이 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0fc95e0cae6fea6934c86fc94073155aecd6590f" translate="yes" xml:space="preserve">
          <source>Unlike the other journaling modes, &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=WAL&lt;/a&gt; is persistent. If a process sets WAL mode, then closes and reopens the database, the database will come back in WAL mode. In contrast, if a process sets (for example) PRAGMA journal_mode=TRUNCATE and then closes and reopens the database will come back up in the default rollback mode of DELETE rather than the previous TRUNCATE setting.</source>
          <target state="translated">다른 저널링 모드와 달리 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = WAL&lt;/a&gt; 은 지속적입니다. 프로세스가 WAL 모드를 설정 한 다음 데이터베이스를 닫았다가 다시 열면 데이터베이스가 WAL 모드로 돌아옵니다. 반대로 프로세스가 (예를 들어) PRAGMA journal_mode = TRUNCATE를 설정 한 다음 닫았다가 다시 열면 데이터베이스는 이전 TRUNCATE 설정이 아닌 DELETE의 기본 롤백 모드로 백업됩니다.</target>
        </trans-unit>
        <trans-unit id="3542ed2ff90a29869b311f3e2e4680675b20b4a0" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the master journal does not contain any original database page content. Instead, the master journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">롤백 저널과 달리 마스터 저널에는 원본 데이터베이스 페이지 내용이 없습니다. 대신 마스터 저널에는 트랜잭션에 참여하는 모든 데이터베이스의 롤백 저널에 대한 전체 경로 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3dcad4a4f47bac4601655442badbb882f7ce80cb" translate="yes" xml:space="preserve">
          <source>Unlike the rollback journals, the super-journal does not contain any original database page content. Instead, the super-journal contains the full pathnames for rollback journals for every database that is participating in the transaction.</source>
          <target state="translated">롤백 저널과 달리 수퍼 저널에는 원본 데이터베이스 페이지 콘텐츠가 포함되어 있지 않습니다. 대신 수퍼 저널에는 트랜잭션에 참여하는 모든 데이터베이스의 롤백 저널에 대한 전체 경로 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="02b418069c25f685f24a747aa6e2e42a4b27661e" translate="yes" xml:space="preserve">
          <source>Unlike the xFilter argument, xConflict may not be passed NULL. The results of passing anything other than a valid function pointer as the xConflict argument are undefined.</source>
          <target state="translated">xFilter 인수와 달리 xConflict에는 NULL이 전달되지 않을 수 있습니다. xConflict 인수로 유효한 함수 포인터 이외의 것을 전달한 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8cc38ff6e04932db1753dbe47e43a46b66cca7d3" translate="yes" xml:space="preserve">
          <source>Unlinked database files</source>
          <target state="translated">연결되지 않은 데이터베이스 파일</target>
        </trans-unit>
        <trans-unit id="2e66bd886206de5f2b17ce23c8df1ed8d25d65b5" translate="yes" xml:space="preserve">
          <source>Unlock Notification</source>
          <target state="translated">알림 잠금 해제</target>
        </trans-unit>
        <trans-unit id="1129dcb047456b603be7d9e26492484e1ef87d61" translate="yes" xml:space="preserve">
          <source>Unlock the btree to which cursor P1 is pointing so that it can be written by other cursors.</source>
          <target state="translated">다른 커서가 쓸 수 있도록 커서 P1이 가리키는 btree를 잠금 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="dc88710cf7a309e590112924b4f0f18efd64749f" translate="yes" xml:space="preserve">
          <source>Unnecessary OP_IsNull, OP_Affinity, and OP_MustBeInt VDBE opcodes are suppressed</source>
          <target state="translated">불필요한 OP_IsNull, OP_Affinity 및 OP_MustBeInt VDBE opcode가 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="b028e3e382d48044cb8ac6852f58d5f9280df947" translate="yes" xml:space="preserve">
          <source>Unpinning a database page.</source>
          <target state="translated">데이터베이스 페이지를 고정 해제합니다.</target>
        </trans-unit>
        <trans-unit id="4d158e591edd9ba39fa4326da9d09c5874218ca5" translate="yes" xml:space="preserve">
          <source>Unregister a VFS with the sqlite3_vfs_unregister() interface. If the default VFS is unregistered, another VFS is chosen as the default. The choice for the new VFS is arbitrary.</source>
          <target state="translated">sqlite3_vfs_unregister () 인터페이스를 사용하여 VFS를 등록 취소하십시오. 기본 VFS가 등록되지 않은 경우 다른 VFS가 기본값으로 선택됩니다. 새로운 VFS에 대한 선택은 임의적입니다.</target>
        </trans-unit>
        <trans-unit id="ef3bbadff8cc850c1a14d5bac3c132d39dd7aef1" translate="yes" xml:space="preserve">
          <source>Unsigned integer counter, incremented with each transaction</source>
          <target state="translated">각 트랜잭션마다 증가하는 부호없는 정수 카운터</target>
        </trans-unit>
        <trans-unit id="3c2ab651c10dcd781af9d81861dc05c7e00cd0e4" translate="yes" xml:space="preserve">
          <source>Unused bytes of on the current page or btree</source>
          <target state="translated">현재 페이지 또는 btree에서 사용되지 않은 바이트</target>
        </trans-unit>
        <trans-unit id="3ae451c5b9e60f30746c607b23e33192b93fe52d" translate="yes" xml:space="preserve">
          <source>Unused padding space. Must be zero.</source>
          <target state="translated">사용되지 않은 패딩 공간. 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="e3a057d9b649ee6d00a614b6de91fb18fda426f0" translate="yes" xml:space="preserve">
          <source>Unused pages in the database file are stored on a freelist. The 4-byte big-endian integer at offset 32 stores the page number of the first page of the freelist, or zero if the freelist is empty. The 4-byte big-endian integer at offset 36 stores stores the total number of pages on the freelist.</source>
          <target state="translated">데이터베이스 파일에서 사용되지 않은 페이지는 사용 가능 목록에 저장됩니다. 오프셋 32의 4 바이트 빅 엔디안 정수는 사용 가능 목록의 첫 번째 페이지의 페이지 번호를 저장하거나 사용 가능 목록이 비어있는 경우 0을 저장합니다. 오프셋 36의 4 바이트 빅 엔디안 정수는 프리리스트에 총 페이지 수를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="533ec3a09a391d616af998c213244ec0a1e5a3cc" translate="yes" xml:space="preserve">
          <source>Unused space reserved for further expansion.</source>
          <target state="translated">추가 확장을 위해 사용되지 않은 공간이 예약되었습니다.</target>
        </trans-unit>
        <trans-unit id="c494dd09b1047ff61f225fbdc40bf010e62739a8" translate="yes" xml:space="preserve">
          <source>Unused space set aside for 8 file locks.</source>
          <target state="translated">8 개의 파일 잠금을 위해 사용하지 않은 공간을 따로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6ccb1ae240f52b5b4ac6a0a3624ae84ecc9e72d1" translate="yes" xml:space="preserve">
          <source>Up to 32K columns in a table and unlimited rows</source>
          <target state="translated">테이블에서 최대 32K 열 및 무제한 행</target>
        </trans-unit>
        <trans-unit id="6b12c595d758d017b4f8b2df393f1e4bc59a0386" translate="yes" xml:space="preserve">
          <source>Up to 64-way joins</source>
          <target state="translated">최대 64 방향 조인</target>
        </trans-unit>
        <trans-unit id="cb305c54c2dd32659178ffaaae86eb202de286b0" translate="yes" xml:space="preserve">
          <source>Upcoming maintenance releases announced on the sqlite-users and sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;mailing lists&lt;/a&gt; about two weeks prior to the anticipated release. Approximately one week prior to release, the lead developer declares &quot;pencils down&quot; after which only bug-fix check-ins are allowed on trunk. A new &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;release checklist&lt;/a&gt; is created and updated as needed. As items of the checklist are verified, they are checked off and turn green. The release occurs when all elements of the checklist are green. That process normally takes about a week.</source>
          <target state="translated">향후 출시 예정인 약 2 주 전에 sqlite-users 및 sqlite-dev &lt;a href=&quot;https://sqlite.org/support.html#mailinglists&quot;&gt;메일 링리스트&lt;/a&gt; 에 예정된 유지 보수 릴리스가 발표 되었습니다. 릴리스 약 1 주일 전에 수석 개발자는 &quot;펜슬 다운&quot;을 선언 한 후 트렁크에서 버그 수정 체크인 만 허용합니다. 필요에 따라 새 &lt;a href=&quot;https://sqlite.org/checklists&quot;&gt;릴리스 점검 목록&lt;/a&gt; 이 작성되고 업데이트됩니다. 점검 목록의 항목이 확인되면 점검되고 녹색으로 바뀝니다. 점검 목록의 모든 요소가 녹색이면 릴리스가 발생합니다. 이 과정은 보통 일주일 정도 걸립니다.</target>
        </trans-unit>
        <trans-unit id="8621615ea5e13954070618a81964dc62abe12dff" translate="yes" xml:space="preserve">
          <source>Update 2003-07-13:</source>
          <target state="translated">2003-07-13 업데이트 :</target>
        </trans-unit>
        <trans-unit id="e6d951c5abc007e402d1496a11b3024eba850b99" translate="yes" xml:space="preserve">
          <source>Update cygwin interfaces to omit deprecated API calls.</source>
          <target state="translated">더 이상 사용되지 않는 API 호출을 생략하도록 cygwin 인터페이스를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="f8692a500a2140ecfbdf4ae0b2b2fa362f3e4d18" translate="yes" xml:space="preserve">
          <source>Update on 2018-11-24: This section was important when the NGQP was new. But five years have elapsed, the NGQP has been deployed successfully to billions of devices, and everyone has upgraded. The upgrade hazard has vanished. This section is retained for historical reference only. Modern reads can skip ahead to the &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;query planner checklist&lt;/a&gt;.</source>
          <target state="translated">2018-11-24의 업데이트 :이 섹션은 NGQP가 처음 도입되었을 때 중요했습니다. 그러나 5 년이 지났고 NGQP는 수십억 개의 장치에 성공적으로 배포되었으며 모든 사람이 업그레이드되었습니다. 업그레이드 위험이 사라졌습니다. 이 섹션은 기록 참조 용으로 만 유지됩니다. 최신 읽기는 &lt;a href=&quot;queryplanner-ng#howtofix&quot;&gt;쿼리 플래너 점검 목록으로&lt;/a&gt; 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f7a5f87f2cf88e6e7e5e6ca7b270c03397b5d3d9" translate="yes" xml:space="preserve">
          <source>Update or delete the row in the parent table,</source>
          <target state="translated">부모 테이블에서 행을 업데이트하거나 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="eadf20cb1fcf64b516be4d0e9aca0f806ea0946c" translate="yes" xml:space="preserve">
          <source>Update the &quot;.import&quot; command in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; to support multi-line fields and correct RFC-4180 quoting and to issue warning and/or error messages if the input text is not strictly RFC-4180 compliant.</source>
          <target state="translated">입력 텍스트가 RFC-4180을 엄격하게 준수하지 않는 경우 여러 줄 필드를 지원하고 RFC-4180 인용을 수정하고 경고 및 / 또는 오류 메시지를 표시 하도록 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 &quot;.import&quot;명령을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="95e555f2b3f8baa46d6d1c3fa11a385e51f02eb2" translate="yes" xml:space="preserve">
          <source>Update the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to make use of the enhanced virtual table interface.</source>
          <target state="translated">향상된 가상 테이블 인터페이스를 사용 하도록 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장&lt;/a&gt; 을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="afd4ef5f9984771affe8a02ef21dc1f52c746e3a" translate="yes" xml:space="preserve">
          <source>Update the NULL-handling documentation.</source>
          <target state="translated">NULL 처리 문서를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8eb7bca41bb60469d609f31a7c94a8af987dd0b7" translate="yes" xml:space="preserve">
          <source>Update the _FILE_OFFSET_BITS macro so that builds work again on QNX.</source>
          <target state="translated">QNX에서 빌드 작업이 다시 수행되도록 _FILE_OFFSET_BITS 매크로를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="83db802c5575f2f5c375cb1b62089d3a370412c6" translate="yes" xml:space="preserve">
          <source>Update the banner on the command-line shell to alert novice users when they are using an ephemeral in-memory database.</source>
          <target state="translated">명령 줄 셸에서 배너를 업데이트하여 초보 메모리 내 데이터베이스를 사용할 때 초보자에게 경고합니다.</target>
        </trans-unit>
        <trans-unit id="5deccb253aff130770ec3068052cf362ce9ebe27" translate="yes" xml:space="preserve">
          <source>Update the built-in &lt;a href=&quot;fts3&quot;&gt;FTS3/FTS4&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; virtual tables to support &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; clauses and &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 절 및 &lt;a href=&quot;lang_replace&quot;&gt;REPLACE&lt;/a&gt; 를 지원 하도록 내장 &lt;a href=&quot;fts3&quot;&gt;FTS3 / FTS4&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;RTREE&lt;/a&gt; 가상 테이블을 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="b504122b8dfef94ab33eb2666fd1889d16053291" translate="yes" xml:space="preserve">
          <source>Update the text of error messages returned by &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg()&lt;/a&gt; for some error codes.</source>
          <target state="translated">일부 오류 코드에 대해 &lt;a href=&quot;c3ref/errcode&quot;&gt;sqlite3_errmsg ()&lt;/a&gt; 에 의해 리턴 된 오류 메시지의 텍스트를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="f19ef97f712dc9336cd9881c1cc678760d93cdf8" translate="yes" xml:space="preserve">
          <source>Update: As of SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;version 3.29.0&lt;/a&gt; (2019-07-10) the use of AFL has been superceded by the new &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz&lt;/a&gt; fuzzer described below.</source>
          <target state="translated">업데이트 : SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_29_0.html&quot;&gt;버전 3.29.0&lt;/a&gt; (2019-07-10)부터 AFL 사용이 아래 설명 된 새로운 &lt;a href=&quot;testing#dbsqlfuzz&quot;&gt;dbsqlfuzz 퍼저&lt;/a&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c202e0c1d72e2322ab1803ee32b5877979d2de60" translate="yes" xml:space="preserve">
          <source>Update: New measurements for SQLite version 3.19.0 (2017-05-22) show that SQLite is about &lt;a href=&quot;fasterthanfs&quot;&gt;35% faster&lt;/a&gt; than direct disk I/O for both reads and writes of 10KB blobs.</source>
          <target state="translated">업데이트 : SQLite 버전 3.19.0 (2017-05-22)에 대한 새로운 측정 결과에 따르면 SQLite는 10KB BLOB의 읽기 및 쓰기에 대한 직접 디스크 I / O보다 약 &lt;a href=&quot;fasterthanfs&quot;&gt;35 % 빠릅니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a960dbfb2b124d6ed06bf7e934a25380bb894d60" translate="yes" xml:space="preserve">
          <source>Update: The &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; command introduced in SQLite version 3.27.0 (2019-02-07) can serve as an alternative to the backup API.</source>
          <target state="translated">업데이트 : SQLite 버전 3.27.0 (2019-02-07)에 도입 된 &lt;a href=&quot;lang_vacuum#vacuuminto&quot;&gt;VACUUM INTO&lt;/a&gt; 명령은 백업 API의 대안으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae9f91d2ff06391addf58fdcc8dd4af3777ab8ac" translate="yes" xml:space="preserve">
          <source>Updated the &quot;unix-dotfile&quot; &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to use locking directories with mkdir() and rmdir() instead of locking files with open() and unlink().</source>
          <target state="translated">open () 및 unlink ()로 파일을 잠그는 대신 mkdir () 및 rmdir ()로 잠그는 디렉토리를 사용 하도록 &quot;unix-dotfile&quot; &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 업데이트했습니다 .</target>
        </trans-unit>
        <trans-unit id="9ecd4cacc54f9eb845eb05b8c1cec0b8deaabeb2" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; so that it can be built using &lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; and &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;compile#omit_floating_point&quot;&gt;SQLITE_OMIT_FLOATING_POINT&lt;/a&gt; 및 &lt;a href=&quot;compile#omit_autoinit&quot;&gt;SQLITE_OMIT_AUTOINIT를&lt;/a&gt; 사용하여 빌드 할 수 있도록 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘을&lt;/a&gt; 업데이트했습니다 .</target>
        </trans-unit>
        <trans-unit id="ae68475963e11d8ffb9d1743f7f05f6343c16e81" translate="yes" xml:space="preserve">
          <source>Updated the &lt;a href=&quot;nulls&quot;&gt;NULL-handling document&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;nulls&quot;&gt;NULL 처리 문서를&lt;/a&gt; 업데이트했습니다 .</target>
        </trans-unit>
        <trans-unit id="2cc8e0782c7a9b456827f5ac2f3deff6afb93a61" translate="yes" xml:space="preserve">
          <source>Updated the documentation for due to the above change.</source>
          <target state="translated">위 변경으로 인해 설명서가 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="e10ae62e4bb036329cb9ea0d831ba16069afdf6b" translate="yes" xml:space="preserve">
          <source>Updates to &lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly()&lt;/a&gt; so that its result is well-defined for all prepared statements and so that it works with &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/stmt_readonly&quot;&gt;sqlite3_stmt_readonly ()로&lt;/a&gt; 업데이트하여 모든 준비된 명령문에 대해 결과가 잘 정의되고 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 과 작동하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="611a149936e51e86e5dc517a30918e94113a5c96" translate="yes" xml:space="preserve">
          <source>Updates to comments and documentation.</source>
          <target state="translated">의견 및 설명서 업데이트</target>
        </trans-unit>
        <trans-unit id="5cd9f8d0a6523c89d101b12728ca830f506daa93" translate="yes" xml:space="preserve">
          <source>Updates to the FAQ</source>
          <target state="translated">FAQ 업데이트</target>
        </trans-unit>
        <trans-unit id="225b3af8e67127ee3d34043567f27a4b206ed152" translate="yes" xml:space="preserve">
          <source>Updates to the co-hosted &lt;a href=&quot;lemon&quot;&gt;Lemon LALR(1) parser generator&lt;/a&gt;. (These updates did not affect SQLite.)</source>
          <target state="translated">공동 주최 업데이트 &lt;a href=&quot;lemon&quot;&gt;레몬 LALR (1) 파서 생성기&lt;/a&gt; . (이 업데이트는 SQLite에 영향을 미치지 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="5ff086f286850610a359720beb1814b02bde490c" translate="yes" xml:space="preserve">
          <source>Updates to the man page</source>
          <target state="translated">매뉴얼 페이지 업데이트</target>
        </trans-unit>
        <trans-unit id="0b579189066ad6233ab9a30e75015931b715153e" translate="yes" xml:space="preserve">
          <source>Upgrade to an</source>
          <target state="translated">로 업그레이드</target>
        </trans-unit>
        <trans-unit id="fa23bdbf593290f21c99984edfe7206d0b3f48ab" translate="yes" xml:space="preserve">
          <source>Upgraded the &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter()&lt;/a&gt; function so that it works with the rollback journal or WAL filename in addition to the database filename.</source>
          <target state="translated">데이터베이스 파일 이름 외에 롤백 저널 또는 WAL 파일 이름과 함께 작동하도록 &lt;a href=&quot;c3ref/uri_boolean&quot;&gt;sqlite3_uri_parameter ()&lt;/a&gt; 함수를 업그레이드했습니다 .</target>
        </trans-unit>
        <trans-unit id="54e621618c30d2d51e0e7eb2f7c9980b70d460c6" translate="yes" xml:space="preserve">
          <source>Upgrading SQLite, Backwards Compatibility</source>
          <target state="translated">SQLite, 이전 버전과의 호환성 업그레이드</target>
        </trans-unit>
        <trans-unit id="f63424e9ccf9758aa115a08c1ca29da89505f175" translate="yes" xml:space="preserve">
          <source>Upgrading to an Exclusive Lock</source>
          <target state="translated">배타적 잠금으로 업그레이드</target>
        </trans-unit>
        <trans-unit id="0b7b831bc0dc4db0969e61d108d5ed08e60a2a5a" translate="yes" xml:space="preserve">
          <source>Usable size</source>
          <target state="translated">사용 가능한 크기</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="f7d660e7e185b02ed0b42d1ed9b98bb6209a9521" translate="yes" xml:space="preserve">
          <source>Use &quot;&lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt;&quot; at the top of your source code files instead of &quot;&lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt;&quot;.</source>
          <target state="translated">&quot; &lt;code&gt;#include &amp;lt;sqlite3.h&amp;gt;&lt;/code&gt; &quot; 대신 소스 코드 파일 맨 위에 &quot; &lt;code&gt;#include &amp;lt;sqlite3ext.h&amp;gt;&lt;/code&gt; &quot;를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="62e753b43ef69616b1563515522f39fb45747e31" translate="yes" xml:space="preserve">
          <source>Use &quot;trunk&quot; for</source>
          <target state="translated">&quot;트렁크&quot;사용</target>
        </trans-unit>
        <trans-unit id="237aa140efed61c820a219860ca38adb64fb7ec3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_corefunc#replace&quot;&gt;replace()&lt;/a&gt; instead of &lt;a href=&quot;lang_corefunc#char&quot;&gt;char()&lt;/a&gt; for escaping newline and carriage-return characters embedded in strings in the .dump output from the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;명령 행 shell&lt;/a&gt; 의 .dump 출력에서 ​​문자열에 포함 된 개행 및 캐리지 리턴 문자를 이스케이프 하려면 &lt;a href=&quot;lang_corefunc#char&quot;&gt;char &lt;/a&gt;&lt;a href=&quot;lang_corefunc#replace&quot;&gt;()&lt;/a&gt; 대신 replace () 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7a8d415f6b6311567858afd10504aff2606d36c" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt;, &lt;a href=&quot;lang_createtrigger&quot;&gt;CREATE TRIGGER&lt;/a&gt;, and &lt;a href=&quot;lang_createview&quot;&gt;CREATE VIEW&lt;/a&gt; to reconstruct indexes, triggers, and views associated with table X. Perhaps use the old format of the triggers, indexes, and views saved from step 3 above as a guide, making changes as appropriate for the alteration.</source>
          <target state="translated">사용 &lt;a href=&quot;lang_createindex&quot;&gt;INDEX 생성&lt;/a&gt; , &lt;a href=&quot;lang_createtrigger&quot;&gt;트리거 CREATE&lt;/a&gt; 및 &lt;a href=&quot;lang_createview&quot;&gt;VIEW CREATE&lt;/a&gt; 에 맞게 변경, 아마도 가이드로 위의 3 단계에서 저장 트리거, 인덱스 및 뷰의 이전 형식을 사용하여 테이블 X.과 관련 인덱스, 트리거 및 뷰를 재구성하기를 변경.</target>
        </trans-unit>
        <trans-unit id="536befb3634409293843309bd592f3735064b803" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; to construct a new table &quot;new_X&quot; that is in the desired revised format of table X. Make sure that the name &quot;new_X&quot; does not collide with any existing table name, of course.</source>
          <target state="translated">&lt;a href=&quot;lang_createtable&quot;&gt;CREATE TABLE&lt;/a&gt; 을 사용 하여 원하는 수정 된 테이블 X 형식의 새 테이블 &quot;new_X&quot;를 구성하십시오. 물론 &quot;new_X&quot;라는 이름이 기존 테이블 이름과 충돌하지 않는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4324752dc06a9ac4571627fdbc5052d079c7ceec" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX&lt;/a&gt; statement to create a new index on one or more expressions just like you would to create an index on columns. The only difference is that expressions are listed as the elements to be indexed rather than column names.</source>
          <target state="translated">용도 &lt;a href=&quot;lang_createindex&quot;&gt;CREATE INDEX의&lt;/a&gt; 컬럼에 인덱스를 생성하는 것입니다 당신처럼 하나 이상의 표현식에 새 인덱스를 생성하는 문을. 유일한 차이점은 표현식이 열 이름 대신 색인화 될 요소로 나열된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7496f7181dc9302ddc248c78082db1a132361364" translate="yes" xml:space="preserve">
          <source>Use a negative column width for right-justified columns.</source>
          <target state="translated">오른쪽 정렬 된 열에는 음의 열 너비를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ed5b81249d213d275afc651f4e6fd002e1e541a" translate="yes" xml:space="preserve">
          <source>Use a separate mutex on every inode in the unix &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt;, rather than a single mutex shared among them all, for slightly better concurrency in multi-threaded environments.</source>
          <target state="translated">멀티 스레드 환경에서 약간 더 나은 동시성을 위해서는 유닉스 &lt;a href=&quot;vfs&quot;&gt;VFS의&lt;/a&gt; 모든 inode에 단일 뮤텍스를 공유하는 대신 별도의 뮤텍스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="de146a75582fa0d61aaa74e50c8ce2d58d1921c8" translate="yes" xml:space="preserve">
          <source>Use an index to satisfy an IS NULL operator in the WHERE clause</source>
          <target state="translated">WHERE 절에서 IS NULL 연산자를 만족 시키려면 색인을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="6bdba762bb27236a6cb868fd917b885a3fb66243" translate="yes" xml:space="preserve">
          <source>Use compiler built-ins __builtin_sub_overflow(), __builtin_add_overflow(), and __builtin_mul_overflow() when available. (All compiler built-ins can be omitted with the &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt; compile-time option.)</source>
          <target state="translated">사용 가능한 경우 컴파일러 내장 __builtin_sub_overflow (), __builtin_add_overflow () 및 __builtin_mul_overflow ()를 사용하십시오. ( &lt;a href=&quot;compile#disable_intrinsic&quot;&gt;SQLITE_DISABLE_INTRINSIC&lt;/a&gt; 컴파일 타임 옵션으로 모든 내장 컴파일러를 생략 할 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="137cf73aa42452fce0415a41813408b4501767a7" translate="yes" xml:space="preserve">
          <source>Use either disk or memory storage for temporary files as determined by the &lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; compile-time parameter.</source>
          <target state="translated">&lt;a href=&quot;compile#temp_store&quot;&gt;SQLITE_TEMP_STORE&lt;/a&gt; 컴파일 시간 매개 변수에 의해 결정된 임시 파일에 디스크 또는 메모리 스토리지를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2af669874066cde2346e922c573e9e835ac690a1" translate="yes" xml:space="preserve">
          <source>Use fdatasync() instead of fsync() where possible in order to speed up commits slightly</source>
          <target state="translated">커밋 속도를 약간 높이려면 가능한 경우 fsync () 대신 fdatasync ()를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50f06d5432236287d8673fac9ba31c9f7a72e979" translate="yes" xml:space="preserve">
          <source>Use files by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">기본적으로 파일을 사용하지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; 명령이 무시 하도록 허용</target>
        </trans-unit>
        <trans-unit id="263a25f617f6abfd3d532ea4693a64ebfdbddfbe" translate="yes" xml:space="preserve">
          <source>Use heap space instead of stack space for large buffers in the pager - useful on embedded platforms with stack-space limitations.</source>
          <target state="translated">호출기의 대용량 버퍼에 스택 공간 대신 ​​힙 공간을 사용하십시오. 스택 공간 제한이있는 임베디드 플랫폼에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3a48cc9a1a2d824c57ec5e25aeb6cff31334d1e8" translate="yes" xml:space="preserve">
          <source>Use indices to help with GLOB expressions and LIKE expressions too when the case_sensitive_like pragma is enabled</source>
          <target state="translated">case_sensitive_like pragma가 사용 가능한 경우 색인을 사용하여 GLOB 표현식 및 LIKE 표현식에도 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bc1fcae1e921cce9fd520fbec66677338b3c72ed" translate="yes" xml:space="preserve">
          <source>Use less memory by not remembering CHECK constraints on read-only database connections.</source>
          <target state="translated">읽기 전용 데이터베이스 연결에서 CHECK 제한 조건을 기억하지 않아서 메모리를 덜 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0f855b65765fc8c17befd3c681198b2b5b5c7616" translate="yes" xml:space="preserve">
          <source>Use memmove() instead of memcpy() when moving between memory regions that might overlap. Ticket #2334</source>
          <target state="translated">겹칠 수있는 메모리 영역간에 이동할 때는 memcpy () 대신 memmove ()를 사용하십시오. 티켓 # 2334</target>
        </trans-unit>
        <trans-unit id="469854fc5e213a56cb9e96864bf70b794360aa2e" translate="yes" xml:space="preserve">
          <source>Use memory by default but allow the &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; command to override</source>
          <target state="translated">기본적으로 메모리를 사용하지만 &lt;a href=&quot;pragma#pragma_temp_store&quot;&gt;PRAGMA temp_store&lt;/a&gt; 명령이 무시 하도록 허용</target>
        </trans-unit>
        <trans-unit id="48a8e3645a8edde160a5adbd651d1d588f3d82af" translate="yes" xml:space="preserve">
          <source>Use of the CROSS keyword in a join turns off the table reordering optimization</source>
          <target state="translated">조인에 CROSS 키워드를 사용하면 테이블 재정렬 최적화가 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="4efb979f35de88aa03beb8b52191a1054ccebd97" translate="yes" xml:space="preserve">
          <source>Use single-quotes, not double-quotes, around string literals in SQL. This is what the SQL standard requires. Your WHERE clause expression should read: &lt;code&gt;column1='column1'&lt;/code&gt;</source>
          <target state="translated">SQL에서 문자열 리터럴 주위에 큰 따옴표가 아닌 작은 따옴표를 사용하십시오. 이것이 SQL 표준에 필요한 것입니다. WHERE 절 표현식은 다음과 같아야합니다. &lt;code&gt;column1='column1'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc43b1a2c6a31ffdd8561f57d1fbf734126319be" translate="yes" xml:space="preserve">
          <source>Use sqlite3_mprintf() instead of strdup() to avoid libc dependencies</source>
          <target state="translated">libc 의존성을 피하기 위해 strdup () 대신 sqlite3_mprintf ()를 사용하십시오</target>
        </trans-unit>
        <trans-unit id="b154d5767d626fe947b811cbac8223761d775253" translate="yes" xml:space="preserve">
          <source>Use the &quot;.dump&quot; command to convert the entire contents of a database into a single ASCII text file. This file can be converted back into a database by piping it back into &lt;b&gt;sqlite3&lt;/b&gt;.</source>
          <target state="translated">&quot;.dump&quot;명령을 사용하여 데이터베이스의 전체 내용을 단일 ASCII 텍스트 파일로 변환하십시오. 이 파일은 &lt;b&gt;sqlite3&lt;/b&gt; 로 다시 파이핑하여 데이터베이스로 다시 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="031acdfcfcb7c6ac30666a1a6360f5fb4b5b9407" translate="yes" xml:space="preserve">
          <source>Use the &quot;.import&quot; command to import CSV (comma separated value) data into an SQLite table. The &quot;.import&quot; command takes two arguments which are the name of the disk file from which CSV data is to be read and the name of the SQLite table into which the CSV data is to be inserted.</source>
          <target state="translated">&quot;.import&quot;명령을 사용하여 CSV (쉼표로 구분 된 값) 데이터를 SQLite 테이블로 가져 오십시오. &quot;.import&quot;명령은 CSV 데이터를 읽을 디스크 파일 이름과 CSV 데이터를 삽입 할 SQLite 테이블의 이름 인 두 개의 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1514a3f709961a8c5a81dddff2a1805d46c2a271" translate="yes" xml:space="preserve">
          <source>Use the &quot;.separator&quot; dot command to change the separator. For example, to change the separator to a comma and a space, you could do this:</source>
          <target state="translated">&quot;.separator&quot;도트 명령을 사용하여 구분 기호를 변경하십시오. 예를 들어 구분 기호를 쉼표와 공백으로 변경하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7e3a1db63b5ffcfa0304033285d6169940ca5e9f" translate="yes" xml:space="preserve">
          <source>Use the &quot;&lt;code&gt;fossil ui&lt;/code&gt;&quot; command from within the ~/sqlite checkout to bring up a local copy of the website.</source>
          <target state="translated">~ / sqlite 체크 아웃에서 &quot; &lt;code&gt;fossil ui&lt;/code&gt; &quot;명령을 사용하여 웹 사이트의 로컬 복사본을 불러옵니다.</target>
        </trans-unit>
        <trans-unit id="2314ee65a646ac667a54b17ec0394586fd245f83" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">사용 &lt;a href=&quot;#sqlite3_blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 열린 방울의 크기를 결정하기 위해 인터페이스를. 이 인터페이스로 BLOB의 크기를 변경할 수 없습니다. &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL 명령을 사용하여 얼룩 크기를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="36f9cf35dec4a270350f0bd2263a94cc3699ef47" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes()&lt;/a&gt; interface to determine the size of the opened blob. The size of a blob may not be changed by this interface. Use the &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL command to change the size of a blob.</source>
          <target state="translated">사용 &lt;a href=&quot;blob_bytes&quot;&gt;sqlite3_blob_bytes ()&lt;/a&gt; 열린 방울의 크기를 결정하기 위해 인터페이스를. 이 인터페이스로 BLOB의 크기를 변경할 수 없습니다. &lt;a href=&quot;../lang_update&quot;&gt;UPDATE&lt;/a&gt; SQL 명령을 사용하여 얼룩 크기를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="bd4ed3d4650cd4e7bc264eb1acc9e459a702bd1f" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter to selected the threading mode. If no &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; compile-time parameter is present, then serialized mode is used. This can be made explicit with &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=1&lt;/a&gt;. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=0&lt;/a&gt; the threading mode is single-thread. With &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE=2&lt;/a&gt; the threading mode is multi-thread.</source>
          <target state="translated">스레딩 모드를 선택 하려면 &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 컴파일 타임 매개 변수를 사용하십시오 . &lt;a href=&quot;compile#threadsafe&quot;&gt;SQLITE_THREADSAFE&lt;/a&gt; 컴파일 타임 매개 변수가 없으면 직렬화 된 모드가 사용됩니다. 이는 &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 1&lt;/a&gt; 로 명시 적으로 만들 수 있습니다 . 함께 &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 0&lt;/a&gt; 스레딩 모드는 단일 스레드이다. 함께 &lt;a href=&quot;compile#threadsafe&quot;&gt;-DSQLITE_THREADSAFE = 2&lt;/a&gt; 스레딩 모드는 멀티 쓰레드 (multi-thread)이다.</target>
        </trans-unit>
        <trans-unit id="274f4747a1320d774731188d128cb3683b032794" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE optimization&lt;/a&gt; even if the right-hand side string contains no wildcards.</source>
          <target state="translated">오른쪽 문자열에 와일드 카드가없는 경우에도 &lt;a href=&quot;optoverview#like_opt&quot;&gt;LIKE 최적화를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f4e51240cb42418de496e090c0f24ccbb024987" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA trusted_schema=OFF&lt;/a&gt; SQL statement to disable trusted schema. This has the same effect as the previous bullet, but does not require the use of C-code and hence can be performed in programs written in another programming language and that do not have access SQLite C-language APIs.</source>
          <target state="translated">사용 &lt;a href=&quot;pragma#pragma_trusted_schema&quot;&gt;PRAGMA의 trusted_schema = OFF&lt;/a&gt; 해제 신뢰할 수있는 스키마로 SQL 문을. 이는 이전 글 머리 기호와 동일한 효과가 있지만 C 코드를 사용할 필요가 없으므로 다른 프로그래밍 언어로 작성되고 SQLite C 언어 API에 액세스 할 수없는 프로그램에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5308e85c61acbd7495be650845b12311f9dc3964" translate="yes" xml:space="preserve">
          <source>Use the &lt;b&gt;sqlite_open&lt;/b&gt; function to open an existing SQLite database or to create a new SQLite database. The first argument is the database name. The second argument is intended to signal whether the database is going to be used for reading and writing or just for reading. But in the current implementation, the second argument to &lt;b&gt;sqlite_open&lt;/b&gt; is ignored. The third argument is a pointer to a string pointer. If the third argument is not NULL and an error occurs while trying to open the database, then an error message will be written to memory obtained from malloc() and *errmsg will be made to point to this error message. The calling function is responsible for freeing the memory when it has finished with it.</source>
          <target state="translated">사용 &lt;b&gt;sqlite_open&lt;/b&gt; 기존 SQLite 데이터베이스를 열거 나 새 SQLite 데이터베이스를 생성하는 기능. 첫 번째 인수는 데이터베이스 이름입니다. 두 번째 주장은 데이터베이스를 읽고 쓰는 데 사용할 것인지 아니면 읽는 데 사용할 것인지를 알려주기위한 것입니다. 그러나 현재 구현에서 &lt;b&gt;sqlite_open에&lt;/b&gt; 대한 두 번째 인수 는 무시됩니다. 세 번째 인수는 문자열 포인터에 대한 포인터입니다. 세 번째 인수가 NULL이 아니고 데이터베이스를 열려고 시도하는 동안 오류가 발생하면 malloc ()에서 얻은 메모리에 오류 메시지가 작성되고이 오류 메시지를 가리 키도록 * errmsg가 작성됩니다. 호출 함수는 메모리가 끝나면 메모리를 해제합니다.</target>
        </trans-unit>
        <trans-unit id="c6d46e33d7807116ac9add91d72550fca2ffbf23" translate="yes" xml:space="preserve">
          <source>Use the WHERE clause to reduce the size of a materialized VIEW in an UPDATE or DELETE statement. (Optimization)</source>
          <target state="translated">WHERE 절을 사용하여 UPDATE 또는 DELETE 문에서 구체화 된 VIEW의 크기를 줄이십시오. (최적화)</target>
        </trans-unit>
        <trans-unit id="efe8cfb25313b8ffdcda22d1d22b3397432240d2" translate="yes" xml:space="preserve">
          <source>Use the correct affinity for columns of automatic indexes. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt;.</source>
          <target state="translated">자동 색인 열에 올바른 선호도를 사용하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/7ffd1ca1d2ad4ec&quot;&gt;7ffd1ca1d2ad4ec&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d6f456699b36362dd68589f9f76baf09757ec2f" translate="yes" xml:space="preserve">
          <source>Use the decimal_cmp(A,B) to compare two decimal values. The result will be negative, zero, or positive if A is less than, equal to, or greater than B, respectively.</source>
          <target state="translated">두 개의 십진수 값을 비교하려면 decimal_cmp (A, B)를 사용합니다. A가 각각 B보다 작거나 같거나 크면 결과는 음수, 0 또는 양수입니다.</target>
        </trans-unit>
        <trans-unit id="f8484df7605c1331750609f898da67fe4dcaeabf" translate="yes" xml:space="preserve">
          <source>Use the macro SQLITE_PRIVATE (defaulting to &quot;static&quot;) on all internal functions in the amalgamation.</source>
          <target state="translated">통합의 모든 내부 함수에 매크로 SQLITE_PRIVATE (기본값은 &quot;정적&quot;)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bc78bf67fa7d6c1c485c06940843c7741c22f19b" translate="yes" xml:space="preserve">
          <source>Use the new &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen()&lt;/a&gt; interface to improve the performance of FTS.</source>
          <target state="translated">새로운 &lt;a href=&quot;c3ref/blob_reopen&quot;&gt;sqlite3_blob_reopen ()&lt;/a&gt; 인터페이스를 사용하여 FTS의 성능을 향상 시키십시오.</target>
        </trans-unit>
        <trans-unit id="3b2244da3774583cbb3fc1a48e72dfd44d3ab95d" translate="yes" xml:space="preserve">
          <source>Use the normal SQLite API to read and write to databases via the asynchronous IO VFS.</source>
          <target state="translated">일반 SQLite API를 사용하여 비동기 IO VFS를 통해 데이터베이스를 읽고 씁니다.</target>
        </trans-unit>
        <trans-unit id="26f92b5c0905f544db1bb7d8ca5ebd0ed63e16d8" translate="yes" xml:space="preserve">
          <source>Use the resulting &quot;kvtest&quot; program to generate a test database with 100,000 random uncompressible blobs, each with a random size between 8,000 and 12,000 bytes using a command like this:</source>
          <target state="translated">결과 &quot;kvtest&quot;프로그램을 사용하여 다음과 같은 명령을 사용하여 각각 8,000에서 12,000 바이트 사이의 임의의 크기를 가진 100,000 개의 임의의 압축 할 수없는 얼룩이있는 테스트 데이터베이스를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7834abce7ece24f8701462e346703566e2de3e27" translate="yes" xml:space="preserve">
          <source>Use the schema-defined &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; instead of the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to pair rows in the source and destination database. (See additional explanation below.)</source>
          <target state="translated">&lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 대신 스키마 정의 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY를&lt;/a&gt; 사용 하여 소스 및 대상 데이터베이스의 행을 쌍으로 연결하십시오. (아래 추가 설명 참조)</target>
        </trans-unit>
        <trans-unit id="02df1e951c416cb903ab43afc2694bfdea186be2" translate="yes" xml:space="preserve">
          <source>Use the strcspn() C-library routine to speed up the LIKE and GLOB operators.</source>
          <target state="translated">strcspn () C 라이브러리 루틴을 사용하여 LIKE 및 GLOB 연산자의 속도를 높이십시오.</target>
        </trans-unit>
        <trans-unit id="f1f443135d8d6987de124f0e64e3f9227d9a5c27" translate="yes" xml:space="preserve">
          <source>Use the transitive property to try to propagate constant values within the WHERE clause. For example, convert &quot;a=99 AND b=a&quot; into &quot;a=99 AND b=99&quot;.</source>
          <target state="translated">전이 특성을 사용하여 WHERE 절 내에서 상수 값을 전파하십시오. 예를 들어 &quot;a = 99 AND b = a&quot;를 &quot;a = 99 AND b = 99&quot;로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea0700fa56071e98d4cc761a6e621b61eff1903" translate="yes" xml:space="preserve">
          <source>Use the unicode API in Windows</source>
          <target state="translated">Windows에서 유니 코드 API 사용</target>
        </trans-unit>
        <trans-unit id="97776a8d79289b0d1017fb264bc954bd7ad83946" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">에서 사용 : &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;집계 함수 - 호출 &lt;/a&gt;&lt;a href=&quot;#attach-stmt&quot;&gt;부착-stmt를 &lt;/a&gt;&lt;a href=&quot;#column-constraint&quot;&gt;열 제약 &lt;/a&gt;&lt;a href=&quot;#compound-select-stmt&quot;&gt;화합물 - 선택 - STMT &lt;/a&gt;&lt;a href=&quot;#create-index-stmt&quot;&gt;생성 - 인덱스 STMT &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;만들 트리거 - stmt를 &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;삭제-stmt를 &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;삭제-stmt를 제한 &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;고려 - 선택 - stmt를 &lt;/a&gt;&lt;a href=&quot;#filter-clause&quot;&gt;필터 절 &lt;/a&gt;&lt;a href=&quot;#frame-spec&quot;&gt;프레임 사양 &lt;/a&gt;&lt;a href=&quot;#indexed-column&quot;&gt;indexed- 열 &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#join-constraint&quot;&gt;조인 제약 조건 &lt;/a&gt;&lt;a href=&quot;#ordering-term&quot;&gt;순서 용어 &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;과절 &lt;/a&gt;&lt;a href=&quot;#result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;선택 코어 &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-function-invocation&quot;&gt;단순 함수 호출 &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;테이블 제약 조건 &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;업데이트 &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;-stmt &lt;/a&gt;제한 upsert- 절 &lt;a href=&quot;#window-defn&quot;&gt;윈도우 정의 &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;윈도우 함수 호출&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3cfe8ec4e623b595e4ac50171983c062621b492" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#aggregate-function-invocation&quot;&gt;집계 함수 호출 &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;창 함수 호출&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9fa16a928ddc1dc237caf8ee5a2f33829abb8c95" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7605fd600c574fecb47de09ab5decde53c108336" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">사용하는 사람 : &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9d132b987e9571018a10419466ce9e4241f4144" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#column-constraint&quot;&gt;열 제약 &lt;/a&gt;&lt;a href=&quot;#pragma-value&quot;&gt;pragma- 값 &lt;/a&gt;&lt;a href=&quot;#type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6859f1dc44376fa95c8d38fdf3b6141e03d2c1ae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#column-constraint&quot;&gt;열 제한 조건 &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;테이블 제한 조건&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a380af02d8c9c93f329808cab4b27595f6a4a3c5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d289a73c451effafc4667d2bf1f3b0e030afac60" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a431a18a7738c53de3472c652954e2bc59958670" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;#expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="224be4c1f3c548d22132987eb2bf278a86171468" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="abb141b71ecdf70ef024445a846b6364ea02ee67" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">다음에 의해 사용됨 : &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab6cea255f6025204d21b009964174b973b40cd6" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">에 의해 사용 : &lt;a href=&quot;#compound-select-stmt&quot;&gt;복합 선택 stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;인수 선택 선택 stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;선택 &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;단순 stst&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9a35f3e8899c13b9a454dc09b2554a9fc11894f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#compound-select-stmt&quot;&gt;복합 선택 -stmt &lt;/a&gt;&lt;a href=&quot;#factored-select-stmt&quot;&gt;인수 선택 -stmt &lt;/a&gt;&lt;a href=&quot;#simple-select-stmt&quot;&gt;단순 선택 -stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56b558cf19b1f43efb09e7c3cf6f834bdf6f9e08" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;#table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ed338e20414f7c9ffcbc59e0281f80cccd5a763" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6b50a14ac773fa0a58261d63783e57e4cbe15c68" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed0705dac87c2b47586b5a816bab059a80c3dff1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fed14e0505bafc78d4d9d690a2b7426f9c8198b2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;#delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a021ee5a9dccd79e0bc3acd62766c09cd9fb8cae" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="082ab3c78daf3f012c8a8cd5f4c53643a071209a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09a6e3cc1f24c34ba4f2a0f20d3c51dbe35db3c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97d8dfd0bb5c0f6552eb23078a3e1e860cc9a6c3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed8783360dda42990afd13092353a2478b98c818" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4cd678b8b993f3438c0117dedb1f0fd21e9e1b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9af677aaf273d3f1f76df6b503b77ba2fd60bed2" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;#window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">과에 의해 사용 : &lt;a href=&quot;#window-defn&quot;&gt;창 &lt;/a&gt;&lt;a href=&quot;#over-clause&quot;&gt;절 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8079f3adf01a444617315e6ee69c27b2f0e4367b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80938cb5970c9483ff312171cb2cce6f1c888a48" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#recursive-cte&quot;&gt;recursive-cte &lt;/a&gt;&lt;a href=&quot;#with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ae852a57048a30f81de513ccc896f0c0dd648fe" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3f7cbedd2f19d68e5c65e3a5494b079eb45e6d0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;테이블 또는 하위 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="589e0a5319c833b4b7bc5d107ed94b7fe1c7d8cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35ea943fa5a24500d0b2de81bfcae0c263e9c947" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;#select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;#window-function-invocation&quot;&gt;창 함수 호출&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6ef1477fa5df999acf552fb4e67164b37b0a48f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b6d1945ca75963e8557621ed71f512d0d1f8a13e" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1042aa6c3f092cc75f0c8a676be3f2d32a0e48e0" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;#update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;#update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;#upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1f1be8756f8f6e3850d5a9e7441499016850919" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;attach-stmt&lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;filter-clause&lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;frame-spec&lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed-column&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;join-constraint&lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;ordering-term&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;result-column&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;simple-function-invocation&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">에서 사용 : &lt;a href=&quot;aggregate-function-invocation&quot;&gt;집계 함수 - 호출 &lt;/a&gt;&lt;a href=&quot;attach-stmt&quot;&gt;부착-stmt를 &lt;/a&gt;&lt;a href=&quot;column-constraint&quot;&gt;열 제약 &lt;/a&gt;&lt;a href=&quot;compound-select-stmt&quot;&gt;화합물 - 선택 - STMT &lt;/a&gt;&lt;a href=&quot;create-index-stmt&quot;&gt;생성 - 인덱스 STMT &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;만들 트리거 - stmt를 &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;삭제-stmt를 &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;삭제-stmt를 제한 &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;고려 - 선택 - stmt를 &lt;/a&gt;&lt;a href=&quot;filter-clause&quot;&gt;필터 절 &lt;/a&gt;&lt;a href=&quot;frame-spec&quot;&gt;프레임 사양 &lt;/a&gt;&lt;a href=&quot;indexed-column&quot;&gt;indexed- 열 &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;join-constraint&quot;&gt;조인 제약 조건 &lt;/a&gt;&lt;a href=&quot;ordering-term&quot;&gt;순서 용어 &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;과절 &lt;/a&gt;&lt;a href=&quot;result-column&quot;&gt;결과 열 &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;선택 코어 &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-function-invocation&quot;&gt;단순 함수 호출 &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;테이블 제약 조건 &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;업데이트 &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;-stmt &lt;/a&gt;제한 upsert- 절 &lt;a href=&quot;window-defn&quot;&gt;윈도우 정의 &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;윈도우 함수 호출&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dba34c5ead7ae94617f98c7cde1dd99c8cf20f1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;aggregate-function-invocation&quot;&gt;aggregate-function-invocation&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;aggregate-function-invocation&quot;&gt;집계 함수 호출 &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;창 함수 호출&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="307e140208125cd798472be7cbdee684ec27af23" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;alter-table-stmt&quot;&gt;alter-table-stmt &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5caeae659f486a37e2e78f0f36394d00574f259" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">사용하는 사람 : &lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a86521d0d079a24ae129812150a3753aecda3e41" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;pragma-value&lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</source>
          <target state="translated">다음에 의해 사용됨 : &lt;a href=&quot;column-constraint&quot;&gt;column-constraint &lt;/a&gt;&lt;a href=&quot;pragma-value&quot;&gt;pragma-value &lt;/a&gt;&lt;a href=&quot;type-name&quot;&gt;type-name&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4797572b6c11d132a08e6eb97c1346965d8c3891" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-constraint&quot;&gt;column-constraint&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;column-constraint&quot;&gt;열 제한 조건 &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;테이블 제한 조건&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="530c72cf587d62fa294e2381602271f96f0f96d7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae571e21875de9dbe7973158d01f4c614d8c361" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;column-def&quot;&gt;column-def&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;column-def&quot;&gt;column-def &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d621ef2d30a77aac0f67e4cb22f0496953330ae4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression&lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt&lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;common-table-expression&quot;&gt;common-table-expression &lt;/a&gt;&lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt &lt;/a&gt;&lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;create-view-stmt&quot;&gt;create-view-stmt &lt;/a&gt;&lt;a href=&quot;expr&quot;&gt;expr &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리 &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7999cb7cebc65a8fd79ca0339c4bb490ea515b01" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0856e25a6da8ebb570311e60dcc92e62c9700b8" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">다음에 의해 사용됨 : &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;over-clause &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="21f8541c9dc2a69fa16cf43b335b7b363315d397" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">에 의해 사용 : &lt;a href=&quot;compound-select-stmt&quot;&gt;복합 선택 stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;인수 선택 선택 stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;선택 &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;단순 stst&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4ab6ebc8f279a3034f0fdb604843d248415ee1bf" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;compound-select-stmt&quot;&gt;compound-select-stmt&lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;simple-select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;compound-select-stmt&quot;&gt;복합 선택 -stmt &lt;/a&gt;&lt;a href=&quot;factored-select-stmt&quot;&gt;인수 선택 -stmt &lt;/a&gt;&lt;a href=&quot;simple-select-stmt&quot;&gt;단순 선택 -stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9b73b88651ef8bf860289b6de3757bded750bc5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt&lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;create-index-stmt&quot;&gt;create-index-stmt &lt;/a&gt;&lt;a href=&quot;table-constraint&quot;&gt;table-constraint &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f17754185255593ea4e239b7777c291185f4d22a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;create-table-stmt&quot;&gt;create-table-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1250d862d07127e87b9840caf01bde3487514be4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt&lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;create-trigger-stmt&quot;&gt;create-trigger-stmt &lt;/a&gt;&lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ffe5f5730adb72eee0e8790e0d4f442453ca532" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b346b7bdc3d0ceef5715a064d5778a794c30fe18" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt&lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;delete-stmt&quot;&gt;delete-stmt &lt;/a&gt;&lt;a href=&quot;delete-stmt-limited&quot;&gt;delete-stmt-limited &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecd461adaec5db6b876f0dff52c7be72090d1b14" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;expr&quot;&gt;expr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1d46198801b0b7bba9815dc12e4cdb3e29b72db5" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;factored-select-stmt&quot;&gt;factored-select-stmt &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="79c1bf6cb1bf604130309cdb21b4f8fbff437aa3" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;insert-stmt&quot;&gt;insert-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9892cdf8b7abbe2222939b3dd694fd626893c60f" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8026c06ece9d695e8c405568f97c947f459d098" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e21ce3a84da1747a72ee6509dcd2b66aa22588d4" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;join-clause&quot;&gt;join-clause&lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;join-clause&quot;&gt;join-clause &lt;/a&gt;&lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9280252176a18a8cad0168e3316dcfbe48390b81" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;over-clause&quot;&gt;over-clause&lt;/a&gt;&lt;a href=&quot;window-defn&quot;&gt;window-defn&lt;/a&gt;</source>
          <target state="translated">과에 의해 사용 : &lt;a href=&quot;window-defn&quot;&gt;창 &lt;/a&gt;&lt;a href=&quot;over-clause&quot;&gt;절 정의&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98a46233f40109c7b176062c4c3a604629e49ee7" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;pragma-stmt&quot;&gt;pragma-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b50593211eada2909f681edc15211383687e61a9" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte&lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;recursive-cte&quot;&gt;recursive-cte &lt;/a&gt;&lt;a href=&quot;with-clause&quot;&gt;with-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="36f9352a3528ee1d344ab047f86be842bf862c8a" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7939044785ba0a8ca2c0b2b3b645bfec873f9c5c" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;테이블 또는 하위 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8113b13214eea91b3a3368ba7da6ad54a4268b3b" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery&lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;table-or-subquery&quot;&gt;table-or-subquery &lt;/a&gt;&lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bcd5b650bb8cb46f8defc106f0dfcc99d5b051cd" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;select-core&quot;&gt;select-core&lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt&lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;window-function-invocation&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;select-core&quot;&gt;select-core &lt;/a&gt;&lt;a href=&quot;select-stmt&quot;&gt;select-stmt &lt;/a&gt;&lt;a href=&quot;window-function-invocation&quot;&gt;창 함수 호출&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4594a38d58964e1e237c00459543be8431bc246" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;sql-stmt&quot;&gt;sql-stmt&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35b40c8cd50b969bfb81394dd732cd863e0cd4d1" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;sql-stmt-list&quot;&gt;sql-stmt-list&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b23afd53b16f293ca94992760b0d75920c0db155" translate="yes" xml:space="preserve">
          <source>Used by: &lt;a href=&quot;update-stmt&quot;&gt;update-stmt&lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited&lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</source>
          <target state="translated">사용 : &lt;a href=&quot;update-stmt&quot;&gt;update-stmt &lt;/a&gt;&lt;a href=&quot;update-stmt-limited&quot;&gt;update-stmt-limited &lt;/a&gt;&lt;a href=&quot;upsert-clause&quot;&gt;upsert-clause&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="83a28142d94277b9f824e8d439d35c64935809cf" translate="yes" xml:space="preserve">
          <source>User Data For Functions</source>
          <target state="translated">기능에 대한 사용자 데이터</target>
        </trans-unit>
        <trans-unit id="f87f9bec30fa447642063fa0c8666b7e8eb0bcd7" translate="yes" xml:space="preserve">
          <source>User defined functions can be created using the following routine:</source>
          <target state="translated">다음 루틴을 사용하여 사용자 정의 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="444756f6f1895c936bb10bab307f679e2df66fa7" translate="yes" xml:space="preserve">
          <source>User-definable text collating sequences.</source>
          <target state="translated">사용자 정의 가능한 텍스트 조합 순서.</target>
        </trans-unit>
        <trans-unit id="41cabf87c0640a35632815a9c1c75379f4b103ed" translate="yes" xml:space="preserve">
          <source>User-defined Collating Sequences</source>
          <target state="translated">사용자 정의 배열 순서</target>
        </trans-unit>
        <trans-unit id="679b4a0d57b60e54b747cb9aacd21774ca84d965" translate="yes" xml:space="preserve">
          <source>User-defined aggregate window functions may be created using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt;() API. Implementing an aggregate window function is very similar to an ordinary aggregate function. Any user-defined aggregate window function may also be used as an ordinary aggregate. To implement a user-defined aggregate window function the application must supply four callback functions:</source>
          <target state="translated">&lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function&lt;/a&gt; () API를 사용하여 사용자 정의 집계 창 함수를 작성할 수 있습니다 . 집계 창 함수 구현은 일반 집계 함수와 매우 유사합니다. 사용자 정의 집계 창 함수는 일반 집계로도 사용할 수 있습니다. 사용자 정의 집계 창 함수를 구현하려면 응용 프로그램에서 다음 네 가지 콜백 함수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb5450ed96e61339c7346965130b897dcacb151" translate="yes" xml:space="preserve">
          <source>User-defined text collating sequences.</source>
          <target state="translated">사용자 정의 텍스트 조합 순서.</target>
        </trans-unit>
        <trans-unit id="e6d26b2d97c6ea4098987a42caa6c50e042619be" translate="yes" xml:space="preserve">
          <source>Uses 9% fewer CPU cycles. (See the &lt;a href=&quot;cpu&quot;&gt;CPU performance measurement&lt;/a&gt; report for details on how this performance increase was computed.)</source>
          <target state="translated">9 % 적은 CPU주기를 사용합니다. ( 이 성능 증가 계산 방법에 대한 자세한 내용은 &lt;a href=&quot;cpu&quot;&gt;CPU 성능 측정&lt;/a&gt; 보고서를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="d0301d0d4694000bac42286a893da835217aae2d" translate="yes" xml:space="preserve">
          <source>Uses compiler built-ins (ex: __builtin_bswap32() or _byteswap_ulong()) for byteswapping when available.</source>
          <target state="translated">사용 가능한 경우 바이트 내장을 위해 컴파일러 내장 (예 : __builtin_bswap32 () 또는 _byteswap_ulong ())을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f10225b09b2eddd2b69fc1125f1e8c1790100225" translate="yes" xml:space="preserve">
          <source>Uses the &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; key/value access object instead of SQL for pulling content out of R-Tree nodes</source>
          <target state="translated">R-Tree 노드에서 컨텐츠를 가져 오기 위해 SQL 대신 &lt;a href=&quot;c3ref/blob&quot;&gt;sqlite3_blob&lt;/a&gt; 키 / 값 액세스 오브젝트를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf6a8d8b0b161f49ba5a16ea51a640dcb0e4cfe4" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=OFF&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode=MEMORY&lt;/a&gt; and taking an application crash in the middle of a write transaction.</source>
          <target state="translated">사용 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA의 journal_mode = OFF&lt;/a&gt; 또는 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;PRAGMA journal_mode = MEMORY를&lt;/a&gt; 하고 쓰기 트랜잭션의 중간에 응용 프로그램 충돌을 복용.</target>
        </trans-unit>
        <trans-unit id="1020c3daf5ee3d9c72ef57a803c58bd0586e47f7" translate="yes" xml:space="preserve">
          <source>Using CREATE or DROP to create or destroy a table or index is really the same as doing an INSERT or DELETE from the special &quot;sqlite_master&quot; table, at least from the point of view of the VDBE. The sqlite_master table is a special table that is automatically created for every SQLite database. It looks like this:</source>
          <target state="translated">CREATE 또는 DROP을 사용하여 테이블 또는 인덱스를 작성 또는 제거하는 것은 적어도 VDBE의 관점에서 특수 &quot;sqlite_master&quot;테이블에서 INSERT 또는 DELETE를 수행하는 것과 동일합니다. sqlite_master 테이블은 모든 SQLite 데이터베이스에 대해 자동으로 생성되는 특수 테이블입니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="4d2637c8d86cb85da8f8da94256a0cdc80d9b4c2" translate="yes" xml:space="preserve">
          <source>Using DDL or DML SQL statements, SQLite users may modify the contents and size of a database file. Exactly how changes to the logical database are translated to modifications to the database file is described in</source>
          <target state="translated">SQLite 사용자는 DDL 또는 DML SQL 문을 사용하여 데이터베이스 파일의 내용과 크기를 수정할 수 있습니다. 논리 데이터베이스에 대한 변경 사항이 데이터베이스 파일에 대한 수정 사항으로 변환되는 방법은 정확하게 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="435c55e01cffb5570c6c79cda02f466b6061178b" translate="yes" xml:space="preserve">
          <source>Using Idx2 instead of Idx1 causes SQLite to examine a different set of rows, but it gets the same answer in the end (which is very important - remember that indices should never change the answer, only help SQLite to get to the answer more quickly) and it does the same amount of work. So the Idx2 index did not help performance in this case.</source>
          <target state="translated">Idx1 대신 Idx2를 사용하면 SQLite가 다른 행 집합을 검사하지만 결국 동일한 대답을 얻습니다 (매우 중요합니다. 인덱스는 절대로 대답을 변경해서는 안되며 SQLite가 더 빨리 대답을 얻도록 도와줍니다) 그리고 같은 양의 작업을 수행합니다. 따라서 Idx2 인덱스는이 경우 성능에 도움이되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c7fd16dcb5fbd84cb48400bd250b2f97394100cb" translate="yes" xml:space="preserve">
          <source>Using Indexes To Speed Searching</source>
          <target state="translated">색인을 사용하여 검색 속도 향상</target>
        </trans-unit>
        <trans-unit id="9f210fd1e7b63cdc7dd0138afd84809f14583a65" translate="yes" xml:space="preserve">
          <source>Using SELECT Statements As Terms In An Expression</source>
          <target state="translated">식에서 SELECT 문을 용어로 사용</target>
        </trans-unit>
        <trans-unit id="97437976ebeb573c52b13ddfd438d2c91bf1893b" translate="yes" xml:space="preserve">
          <source>Using SQLite In Multi-Threaded Applications</source>
          <target state="translated">다중 스레드 응용 프로그램에서 SQLite 사용</target>
        </trans-unit>
        <trans-unit id="307f31c1c11aebab82631ac4f8b0ab54eca6e078" translate="yes" xml:space="preserve">
          <source>Using a MATCH operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">SELECT 문의 WHERE 절에서 MATCH 연산자 사용 또는</target>
        </trans-unit>
        <trans-unit id="3e68860fe2d2ad5dc9651e317f240eed014363dc" translate="yes" xml:space="preserve">
          <source>Using a built-in printf() implementation means that SQLite has one fewer dependency on the host environment, making it more portable.</source>
          <target state="translated">내장 된 printf () 구현을 사용한다는 것은 SQLite가 호스트 환경에 대한 의존성이 한 단계 낮아서 이식성이 향상되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c90117e39221737f02ea3e7e44c49c43210beeb3" translate="yes" xml:space="preserve">
          <source>Using a database file with 8+3 filenames in some cases while in other cases using long filenames is equivalent to &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;deleting a hot journal&lt;/a&gt;.</source>
          <target state="translated">경우에 따라 파일 이름이 8 + 3 인 데이터베이스 파일을 사용하는 경우 긴 파일 이름을 사용 &lt;a href=&quot;howtocorrupt#delhotjrnl&quot;&gt;하는 것은 핫 저널&lt;/a&gt; 을 삭제하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="8fb331fbfc19c9ad94dbe708335967012f83cb31" translate="yes" xml:space="preserve">
          <source>Using a dataset of American place names (derived from &lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt;) the query above returns 20 results beginning with:</source>
          <target state="translated">&lt;a href=&quot;http://geonames.usgs.gov/domestic/download_data.htm&quot;&gt;http://geonames.usgs.gov/domestic/download_data.htm&lt;/a&gt; 에서 파생 된 미국 장소 이름의 데이터 집합을 사용하여 위 쿼리는 다음으로 시작하는 20 개의 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cced5340290d93733d759f1a49ce8d467995399f" translate="yes" xml:space="preserve">
          <source>Using a single query such as the above, the application obtains a list of the slideIds for all slides in the presentation. The application then queries for the content of the first slide, and parses and displays that content, as before.</source>
          <target state="translated">위와 같은 단일 쿼리를 사용하여 응용 프로그램은 프레젠테이션의 모든 슬라이드에 대한 slideId 목록을 가져옵니다. 그런 다음 응용 프로그램은 첫 번째 슬라이드의 내용을 쿼리하고 이전과 같이 해당 내용을 구문 분석하고 표시합니다.</target>
        </trans-unit>
        <trans-unit id="7dd3bf0fc645009566609bccf3a14f62d35a3f59" translate="yes" xml:space="preserve">
          <source>Using an equals (&quot;=&quot;) operator in the WHERE clause of a SELECT statement, or</source>
          <target state="translated">SELECT 문의 WHERE 절에서 등호 ( &quot;=&quot;) 연산자 사용 또는</target>
        </trans-unit>
        <trans-unit id="23bf7370fe569447da050d73459abb59d1093647" translate="yes" xml:space="preserve">
          <source>Using an ordinary disk file to provide shared memory has the disadvantage that it might actually do unnecessary disk I/O by writing the shared memory to disk. However, the developers do not think this is a major concern since the wal-index rarely exceeds 32 KiB in size and is never synced. Furthermore, the wal-index backing file is deleted when the last database connection disconnects, which often prevents any real disk I/O from ever happening.</source>
          <target state="translated">일반 디스크 파일을 사용하여 공유 메모리를 제공하면 실제로 공유 메모리를 디스크에 기록하여 불필요한 디스크 I / O를 수행 할 수 있다는 단점이 있습니다. 그러나 월 인덱스의 크기가 32 KiB를 거의 넘지 않고 동기화되지 않기 때문에 개발자는 이것이 주요 관심사라고 생각하지 않습니다. 또한 마지막 데이터베이스 연결이 끊어지면 월 인덱스 백업 파일이 삭제되어 실제 디스크 I / O가 발생하지 않는 경우가 종종 있습니다.</target>
        </trans-unit>
        <trans-unit id="314bb9e64d758d2b63c2c5acc0e1727dc6e61abf" translate="yes" xml:space="preserve">
          <source>Using an unnamed subquery in a FROM clause would cause a segfault.</source>
          <target state="translated">FROM 절에서 이름없는 서브 쿼리를 사용하면 segfault가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9766cdfa57f62810ee226e9c3deec347064cc20b" translate="yes" xml:space="preserve">
          <source>Using gcov (or similar) to show that every branch instruction is taken at least once in both directions is good measure of test suite quality. But even better is showing that every branch instruction makes a difference in the output. In other words, we want to show not only that every branch instruction both jumps and falls through but also that every branch is doing useful work and that the test suite is able to detect and verify that work. When a branch is found that does not make a difference in the output, that suggests that the code associated the branch can be removed (reducing the size of the library and perhaps making it run faster) or that the test suite is inadequately testing the feature that the branch implements.</source>
          <target state="translated">gcov (또는 이와 유사한)를 사용하여 모든 분기 명령이 양방향으로 한 번 이상 수행되는 것을 보여주는 것은 테스트 스위트 품질의 좋은 척도입니다. 그러나 모든 분기 명령이 출력에 차이를 만든다는 것이 더 좋습니다. 다시 말해, 모든 브랜치 명령이 점프하고 넘어 질뿐만 아니라 모든 브랜치가 유용한 작업을 수행하고 있으며 테스트 스위트가 해당 작업을 감지하고 확인할 수 있음을 보여주고 자합니다. 출력에 차이가없는 분기가 발견되면 분기와 관련된 코드를 제거하거나 (라이브러리 크기를 줄이고 실행 속도를 높일 수 있음) 테스트 스위트가 기능을 부적절하게 테스트하고 있음을 나타냅니다. 지점이 구현합니다.</target>
        </trans-unit>
        <trans-unit id="db5729475276e1f07562cb2df1e724ad2371713c" translate="yes" xml:space="preserve">
          <source>Using one particular subset of the available TH3 test modules (the &quot;cov1&quot; tests) SQLite obtained &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt; and 100% &lt;a href=&quot;testing#mcdc&quot;&gt;MC/DC&lt;/a&gt; as measured by &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; on Linux x86 and x86_64 hardware. All releases of SQLite since &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;version 3.6.17&lt;/a&gt; (2009-08-10) have been tested to this standard. The SQLite developers are committed to maintaining 100% branch coverage and MC/DC for all future releases of SQLite.</source>
          <target state="translated">사용 가능한 TH3 테스트 모듈 ( &quot;cov1&quot;테스트)의 특정 하위 집합을 사용하여 SQLite 는 Linux x86 및 x86_64 하드웨어에서 &lt;a href=&quot;http://gcc.gnu.org/onlinedocs/gcc/Gcov.html&quot;&gt;gcov&lt;/a&gt; 로 측정 한 &lt;a href=&quot;testing#coverage&quot;&gt;100 % 분기 테스트 적용 범위&lt;/a&gt; 및 100 % &lt;a href=&quot;testing#mcdc&quot;&gt;MC / DC&lt;/a&gt; 를 얻었습니다 . &lt;a href=&quot;https://sqlite.org/releaselog/3_6_17.html&quot;&gt;버전 3.6.17&lt;/a&gt; (2009-08-10) 이후의 모든 SQLite 릴리스는 이 표준에 따라 테스트되었습니다. SQLite 개발자는 향후 출시 될 모든 SQLite 릴리스에 대해 100 % 지점 적용 범위 및 MC / DC를 유지하기 위해 노력하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9270ae0408b0c691c7bbd964a691a187fe62e891" translate="yes" xml:space="preserve">
          <source>Using subtypes to identify valid pointers prevented the WebSQL exploit. But it turned out to be an incomplete solution.</source>
          <target state="translated">하위 유형을 사용하여 유효한 포인터를 식별하면 WebSQL 악용이 방지되었습니다. 그러나 불완전한 솔루션으로 판명되었습니다.</target>
        </trans-unit>
        <trans-unit id="4b795c9ed4e93bd126c1058e30a1d247be674aba" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 content option&lt;/a&gt; and failing to manually keep the content in sync with the FTS4 inverted indices.</source>
          <target state="translated">&lt;a href=&quot;fts3#*fts4content&quot;&gt;FTS4 컨텐츠 옵션을&lt;/a&gt; 사용하고 컨텐츠를 FTS4 반전 인덱스와 동기화 된 상태로 수동 유지하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="c352b493b2f0901876aea8d20656c0d87ef6b6a9" translate="yes" xml:space="preserve">
          <source>Using the N+1 Query pattern in Fossil does not harm the application. But the N+1 Query pattern does have benefits. For one, the section of the code that creates the timeline query can be completely separate from the section that prepares each timeline entry for display. This provides a separation of responsibility that helps keep the code simple and easy to maintain. Secondly, the information needed for display, and the queries needed to extract that information, vary according to what type of objects to be shown. Check-ins need one set of queries. Tickets need another set of queries. Wiki pages need a different query. And so forth. By implementing these queries on-demand and in the part of the code dealing with the various entities, there is further separation of responsibility and simplification of the overall code base.</source>
          <target state="translated">Fossil에서 N + 1 쿼리 패턴을 사용해도 응용 프로그램이 손상되지 않습니다. 그러나 N + 1 쿼리 패턴에는 이점이 있습니다. 하나는 타임 라인 쿼리를 생성하는 코드 섹션이 각 타임 라인 항목을 표시 할 수 있도록 준비하는 섹션과 완전히 분리 될 수 있습니다. 이는 코드를 단순하고 유지 관리하기 쉽게 유지하는 책임 분리를 제공합니다. 둘째, 표시하는 데 필요한 정보와 해당 정보를 추출하는 데 필요한 쿼리는 표시 할 개체 유형에 따라 다릅니다. 체크인에는 하나의 쿼리 세트가 필요합니다. 티켓에는 다른 쿼리 세트가 필요합니다. 위키 페이지에는 다른 쿼리가 필요합니다. 기타 등등. 이러한 쿼리를 주문형으로 구현하고 다양한 엔터티를 다루는 코드 부분에서 책임을 분리하고 전체 코드 기반을 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed8c795d039e297badfdb934d5dad24eb9711fc6" translate="yes" xml:space="preserve">
          <source>Using the SQLite Online Backup API</source>
          <target state="translated">SQLite 온라인 백업 API 사용</target>
        </trans-unit>
        <trans-unit id="702c33598d91f7511e11baf351b09ecd585c68e7" translate="yes" xml:space="preserve">
          <source>Using the VFS xAccess() method, SQLite queries the file-system to see if the journal file associated with the database exists. If it does not, then there is no hot-journal file.</source>
          <target state="translated">Vite xAccess () 메소드를 사용하여 SQLite는 파일 시스템을 쿼리하여 데이터베이스와 연관된 저널 파일이 존재하는지 확인합니다. 그렇지 않은 경우 핫 저널 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="15a6ded3b6ea323ecf5d8ed10a9908901c0cf29c" translate="yes" xml:space="preserve">
          <source>Using the memcpy() function on overlapping buffers.</source>
          <target state="translated">겹치는 버퍼에서 memcpy () 함수 사용.</target>
        </trans-unit>
        <trans-unit id="0ff71664481484af5340c1f4f2d1ad694ff3ab5e" translate="yes" xml:space="preserve">
          <source>Using the new Idx2 index on &quot;state&quot;, SQLite has another option for lookup up the price of California oranges: it can look up every row that contains fruit from California and filter out those rows that are not oranges.</source>
          <target state="translated">SQLite는 &quot;state&quot;의 새로운 Idx2 인덱스를 사용하여 캘리포니아 오렌지 가격을 조회 할 수있는 또 다른 옵션을 제공합니다. 캘리포니아에서 과일이 포함 된 모든 행을 찾아서 오렌지가 아닌 행을 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fcde00cc70debec35832ff9273a06512f95fa039" translate="yes" xml:space="preserve">
          <source>Using the sqlite3_unlock_notify() API</source>
          <target state="translated">sqlite3_unlock_notify () API 사용</target>
        </trans-unit>
        <trans-unit id="08fc370c39b7ca0e2248cedd981f211b8dabd8d8" translate="yes" xml:space="preserve">
          <source>Using the two routines above, it is simple for applications to insert new records into or extract existing records from an SQLite Archive. Insert a new into an SQLite Archive using code like this:</source>
          <target state="translated">위의 두 가지 루틴을 사용하면 애플리케이션이 SQLite Archive에 새 레코드를 삽입하거나 기존 레코드를 추출하는 것이 간단합니다. 다음과 같은 코드를 사용하여 SQLite Archive에 새 항목을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="5881634960ec51d660f927c3ca27237c1640f650" translate="yes" xml:space="preserve">
          <source>Using the virtual table interface, new entries may be added to a zip archive by inserting new rows into the virtual table. Entries may be removed by deleting rows or modified by updating them.</source>
          <target state="translated">가상 테이블 인터페이스를 사용하면 가상 테이블에 새 행을 삽입하여 새 항목을 zip 아카이브에 추가 할 수 있습니다. 행을 삭제하여 항목을 제거하거나 업데이트하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7f12616ba6b09fc33431b9c20577f960596b4bb" translate="yes" xml:space="preserve">
          <source>Using the xFileSize() method of the file-handle opened on the database file, SQLite checks if the database file is 0 bytes in size. If it is, the journal file is not considered to be a</source>
          <target state="translated">데이터베이스 파일에서 열린 파일 핸들의 xFileSize () 메소드를 사용하여 SQLite는 데이터베이스 파일의 크기가 0 바이트인지 확인합니다. 그렇다면 저널 파일은</target>
        </trans-unit>
        <trans-unit id="18744e7331495a3e5c139b339aa5a7dcf1c94f70" translate="yes" xml:space="preserve">
          <source>Usually (the exceptions are &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; tables and &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; tables) a PRIMARY KEY in an SQLite table is really the same as a UNIQUE constraint. Due to an historical oversight, the column values of such a PRIMARY KEY are allowed to be NULL. This is a bug, but by the time the problem was discovered there where so many databases in circulation that depended on the bug that the decision was made to support the bugging behavior moving forward.</source>
          <target state="translated">일반적으로 (예외는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;INTEGER PRIMARY KEY&lt;/a&gt; 테이블 및 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 제외) SQLite 테이블의 PRIMARY KEY는 실제로 UNIQUE 제약 조건과 동일합니다. 과거 감독으로 인해 해당 PRIMARY KEY의 열 값은 NULL이 될 수 있습니다. 이것은 버그이지만 문제가 발견되어 버그에 의존하는 많은 데이터베이스가 배포되어 버그를 해결하기위한 결정을 내 렸습니다.</target>
        </trans-unit>
        <trans-unit id="f79481390537aded0fd54463773aac91edd4e79c" translate="yes" xml:space="preserve">
          <source>Usually only a subset of the pages in the database file are read. In this example we are showing three pages out of eight being read. In a typical application, a database will have thousands of pages and a query will normally only touch a small percentage of those pages.</source>
          <target state="translated">일반적으로 데이터베이스 파일에서 페이지의 서브 세트 만 읽습니다. 이 예에서는 8 개 중 3 페이지를 읽는 중입니다. 일반적인 응용 프로그램에서 데이터베이스에는 수천 페이지가 있으며 일반적으로 쿼리는 해당 페이지의 작은 비율 만 터치합니다.</target>
        </trans-unit>
        <trans-unit id="27499120d97c0cbd6ba1013d6ea9b6e679141d60" translate="yes" xml:space="preserve">
          <source>Usually the b-trees for tables and indexes are slightly different. A table b-tree contains a 64-bit integer key and arbitrary data. The 64-bit integer key is the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt;. Index b-trees contain an arbitrary binary key and no data. So table b-trees and index b-trees are not directly compatible.</source>
          <target state="translated">일반적으로 테이블과 인덱스의 b- 트리는 약간 다릅니다. 테이블 b- 트리는 64 비트 정수 키와 임의의 데이터를 포함합니다. 64 비트 정수 키는 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 입니다. 인덱스 b- 트리는 임의의 이진 키를 포함하며 데이터는 없습니다. 따라서 테이블 b- 트리와 인덱스 b- 트리는 직접 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63880029448f25d934c11aa39c24fad9c0bb97f6" translate="yes" xml:space="preserve">
          <source>Usually, a new</source>
          <target state="translated">일반적으로 새로운</target>
        </trans-unit>
        <trans-unit id="251e8707bded33b5cb244d2e22971c5ac18fc6ad" translate="yes" xml:space="preserve">
          <source>Usually, an &lt;a href=&quot;fts3&quot;&gt;FTS3 or FTS4&lt;/a&gt; table is an example of a virtual table with a rowid that works like a PRIMARY KEY. So, for the following FTS4 tables:</source>
          <target state="translated">일반적으로 &lt;a href=&quot;fts3&quot;&gt;FTS3 또는 FTS4&lt;/a&gt; 테이블은 PRIMARY KEY처럼 작동하는 rowid가있는 가상 테이블의 예입니다. 따라서 다음 FTS4 테이블의 경우 :</target>
        </trans-unit>
        <trans-unit id="016fa908ece58367a08159cc60971094eae348ed" translate="yes" xml:space="preserve">
          <source>Usually, it does not matter if the page-sizes of the source database and the destination database are different before the contents of the destination are overwritten. The page-size of the destination database is simply changed as part of the backup operation. The exception is if the destination database happens to be an in-memory database. In this case, if the page sizes are not the same at the start of the backup operation, then the operation fails with an SQLITE_READONLY error. Unfortunately, this could occur when loading a database image from a file into an in-memory database using function loadOrSaveDb().</source>
          <target state="translated">일반적으로 대상의 내용을 덮어 쓰기 전에 원본 데이터베이스와 대상 데이터베이스의 페이지 크기가 다른지 여부는 중요하지 않습니다. 대상 데이터베이스의 페이지 크기는 백업 작업의 일부로 간단히 변경됩니다. 대상 데이터베이스가 인 메모리 데이터베이스 인 경우는 예외입니다. 이 경우 백업 조작 시작시 페이지 크기가 동일하지 않으면 조작이 SQLITE_READONLY 오류와 함께 실패합니다. 불행히도, 이것은 loadOrSaveDb () 함수를 사용하여 파일의 데이터베이스 이미지를 인 메모리 데이터베이스로로드 할 때 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6590aa5b903de1376b91e1364c96b7ab1602da04" translate="yes" xml:space="preserve">
          <source>Usually, no data is actually written to the database file until the user commits the active</source>
          <target state="translated">일반적으로 사용자가 활성을 커밋 할 때까지 실제로 데이터베이스 파일에 데이터가 기록되지 않습니다</target>
        </trans-unit>
        <trans-unit id="5bf501f181ccf2cf7d7e6317299b267cead1ee47" translate="yes" xml:space="preserve">
          <source>Usually, output parameter *piPhrase is set to the phrase number, *piCol to the column in which it occurs and *piOff the token offset of the first token of the phrase. Returns SQLITE_OK if successful, or an error code (i.e. SQLITE_NOMEM) if an error occurs.</source>
          <target state="translated">일반적으로 출력 매개 변수 * piPhrase는 구문 번호, * piCol이 발생하는 열로 설정되고 구문의 첫 번째 토큰의 토큰 오프셋 * piOff로 설정됩니다. 성공하면 SQLITE_OK를, 오류가 발생하면 오류 코드 (예 : SQLITE_NOMEM)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4375ef1d6cde5037d03b8ccb25b702b95cd0734d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">일반적으로 SQLite에서 제공하는 기본 뮤텍스 구현이면 충분하지만 응용 프로그램에는 SQLite가 적합한 구현을 제공하지 않는 특수 배포 또는 시스템에 사용자 지정 구현을 대체 할 수있는 옵션이 있습니다. 이 경우, 애플리케이션은 &lt;a href=&quot;#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 옵션 과 함께 sqlite3_config ()에 전달하기 위해이 구조의 인스턴스를 작성하고 채 웁니다 . 또한이 구조의 인스턴스는 &lt;a href=&quot;#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; 옵션을 사용하여 시스템에 현재 뮤텍스 구현을 쿼리 할 때 출력 변수로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d9cb5f2ee721a0e054d3593ea56d06ca4f711a8d" translate="yes" xml:space="preserve">
          <source>Usually, the default mutex implementations provided by SQLite are sufficient, however the application has the option of substituting a custom implementation for specialized deployments or systems for which SQLite does not provide a suitable implementation. In this case, the application creates and populates an instance of this structure to pass to sqlite3_config() along with the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; option. Additionally, an instance of this structure can be used as an output variable when querying the system for the current mutex implementation, using the &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; option.</source>
          <target state="translated">일반적으로 SQLite에서 제공하는 기본 뮤텍스 구현이면 충분하지만 응용 프로그램에는 SQLite가 적합한 구현을 제공하지 않는 특수 배포 또는 시스템에 사용자 지정 구현을 대체 할 수있는 옵션이 있습니다. 이 경우, 애플리케이션은 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfigmutex&quot;&gt;SQLITE_CONFIG_MUTEX&lt;/a&gt; 옵션 과 함께 sqlite3_config ()에 전달하기 위해이 구조의 인스턴스를 작성하고 채 웁니다 . 또한이 구조의 인스턴스는 &lt;a href=&quot;c_config_covering_index_scan#sqliteconfiggetmutex&quot;&gt;SQLITE_CONFIG_GETMUTEX&lt;/a&gt; 옵션을 사용하여 시스템에 현재 뮤텍스 구현을 쿼리 할 때 출력 변수로 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f67d8e98eea6d06da4e67ed9ebc795e5c21c27d3" translate="yes" xml:space="preserve">
          <source>Usually, the parent key of a foreign key constraint is the primary key of the parent table. If they are not the primary key, then the parent key columns must be collectively subject to a UNIQUE constraint or have a UNIQUE index. If the parent key columns have a UNIQUE index, then that index must use the collation sequences that are specified in the CREATE TABLE statement for the parent table. For example,</source>
          <target state="translated">일반적으로 외래 키 제약 조건의 부모 키는 부모 테이블의 기본 키입니다. 이들이 기본 키가 아닌 경우 상위 키 열은 집합 적으로 UNIQUE 제약 조건을 받거나 UNIQUE 인덱스를 가져야합니다. 상위 키 컬럼에 UNIQUE 인덱스가있는 경우 해당 인덱스는 상위 테이블의 CREATE TABLE 문에 지정된 데이터 정렬 시퀀스를 사용해야합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6dab9ce5b9389cc793db1ee13d4fd8a8749eccd9" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">일반적으로 세션 모듈은 &lt;a href=&quot;../lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 에서 apply_v2 () 또는 apply_v2_strm ()에 대한 단일 호출로 수행 된 모든 작업을 포함합니다 . 변경 세트 또는 패치 세트가 성공적으로 적용되면 SAVEPOINT가 커밋되고 오류가 발생하면 롤백됩니다. 이 플래그를 지정하면 세션 모듈이이 저장 점을 생략합니다. 이 경우 apply_v2 ()가 호출 될 때 호출자가 열린 트랜잭션 또는 저장 점을 갖는 경우 롤백하여 부분적으로 적용된 변경 세트를 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="651dad2d1a7cdde77afe8c8f6efa3556819be19f" translate="yes" xml:space="preserve">
          <source>Usually, the sessions module encloses all operations performed by a single call to apply_v2() or apply_v2_strm() in a &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt;. The SAVEPOINT is committed if the changeset or patchset is successfully applied, or rolled back if an error occurs. Specifying this flag causes the sessions module to omit this savepoint. In this case, if the caller has an open transaction or savepoint when apply_v2() is called, it may revert the partially applied changeset by rolling it back.</source>
          <target state="translated">일반적으로 세션 모듈은 &lt;a href=&quot;lang_savepoint&quot;&gt;SAVEPOINT&lt;/a&gt; 에서 apply_v2 () 또는 apply_v2_strm ()에 대한 단일 호출로 수행 된 모든 작업을 포함합니다 . 변경 세트 또는 패치 세트가 성공적으로 적용되면 SAVEPOINT가 커밋되고 오류가 발생하면 롤백됩니다. 이 플래그를 지정하면 세션 모듈이이 저장 점을 생략합니다. 이 경우 apply_v2 ()가 호출 될 때 호출자가 열린 트랜잭션 또는 저장 점을 갖는 경우 롤백하여 부분적으로 적용된 변경 세트를 되돌릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c5b3a786dedb589ca7dfd4119dc946fad418cc" translate="yes" xml:space="preserve">
          <source>Usually, when a database in wal mode is closed or detached from a database handle, SQLite checks if this will mean that there are now no connections at all to the database. If so, it performs a checkpoint operation before closing the connection. This option may be used to override this behaviour. The first parameter passed to this operation is an integer - positive to disable checkpoints-on-close, or zero (the default) to enable them, and negative to leave the setting unchanged. The second parameter is a pointer to an integer into which is written 0 or 1 to indicate whether checkpoints-on-close have been disabled - 0 if they are not disabled, 1 if they are.</source>
          <target state="translated">일반적으로 wal 모드의 데이터베이스가 데이터베이스 핸들에서 닫히거나 분리되면 SQLite는 이제 데이터베이스에 전혀 연결이 없음을 확인합니다. 그렇다면 연결을 닫기 전에 검사 점 작업을 수행합니다. 이 옵션은이 동작을 무시하는 데 사용될 수 있습니다. 이 작업에 전달되는 첫 번째 매개 변수는 정수입니다. 검사 점을 닫을 때 비활성화하려면 양수, 활성화하려면 0 (기본값), 설정을 그대로 유지하려면 음수입니다. 두 번째 매개 변수는 0 또는 1로 기록 된 정수에 대한 포인터이며, 닫기시 체크 포인트가 사용 안함으로 설정되어 있는지 여부를 나타냅니다. 사용하지 않으면 0, 사용하지 않으면 1입니다.</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="998ce99ff7bc11e5fda480fd5bfcbe7172fa1458" translate="yes" xml:space="preserve">
          <source>Utter only truth from heart and mouth.</source>
          <target state="translated">마음과 입에서 진실만을 말하십시오.</target>
        </trans-unit>
        <trans-unit id="0a83488e309bcd16565cc48e7357404309c680f8" translate="yes" xml:space="preserve">
          <source>VACUUM</source>
          <target state="translated">VACUUM</target>
        </trans-unit>
        <trans-unit id="338c2017b922c8c778a643c9a2bb9bb0d159e34d" translate="yes" xml:space="preserve">
          <source>VACUUM INTO</source>
          <target state="translated">진공 청소기</target>
        </trans-unit>
        <trans-unit id="204b6e5828ce2852bf6877318b1361fbae1e4020" translate="yes" xml:space="preserve">
          <source>VACUUM uses a temporary file in the official TEMP folder, not in the same directory as the original database</source>
          <target state="translated">VACUUM은 원본 TEMP 폴더의 임시 파일을 원본 데이터베이스와 동일한 디렉토리가 아닌</target>
        </trans-unit>
        <trans-unit id="eba0ca62d23c0aa5d1fd44639bb5b08cca16a456" translate="yes" xml:space="preserve">
          <source>VACUUM with an INTO clause</source>
          <target state="translated">INTO 절이있는 VACUUM</target>
        </trans-unit>
        <trans-unit id="b3cba55338b3625665f9ea5a7e33ff9db26da1af" translate="yes" xml:space="preserve">
          <source>VALUES</source>
          <target state="translated">VALUES</target>
        </trans-unit>
        <trans-unit id="3893415f582da8528cfdc804ac3bee7e25a15ab1" translate="yes" xml:space="preserve">
          <source>VALUES clause</source>
          <target state="translated">VALUES 절</target>
        </trans-unit>
        <trans-unit id="2010132ce9d7ecb7ffcd8583e46eb6830b5b89ee" translate="yes" xml:space="preserve">
          <source>VARCHAR(255)</source>
          <target state="translated">VARCHAR(255)</target>
        </trans-unit>
        <trans-unit id="8e2934685262dc368f8941746e5ac5ff58123235" translate="yes" xml:space="preserve">
          <source>VARYING CHARACTER(255)</source>
          <target state="translated">가변 캐릭터 (255)</target>
        </trans-unit>
        <trans-unit id="efde179e9b49292e75991e12678580f142a070e1" translate="yes" xml:space="preserve">
          <source>VBegin</source>
          <target state="translated">VBegin</target>
        </trans-unit>
        <trans-unit id="d0eedafb13c92d47b81b7b056def9e323b6e493c" translate="yes" xml:space="preserve">
          <source>VColumn</source>
          <target state="translated">VColumn</target>
        </trans-unit>
        <trans-unit id="f84b9b0948754b7d110e0815c9837bdc1fddebe7" translate="yes" xml:space="preserve">
          <source>VCreate</source>
          <target state="translated">VCreate</target>
        </trans-unit>
        <trans-unit id="91b564dbaa1169fe6e48962a34cffa4f703f0be0" translate="yes" xml:space="preserve">
          <source>VDestroy</source>
          <target state="translated">VDestroy</target>
        </trans-unit>
        <trans-unit id="b33892fbddeffc3368077b4904ad0b3d562a7312" translate="yes" xml:space="preserve">
          <source>VERSION</source>
          <target state="translated">VERSION</target>
        </trans-unit>
        <trans-unit id="9913e8aa2ef97f43053931ebe92afe906139c950" translate="yes" xml:space="preserve">
          <source>VFS</source>
          <target state="translated">VFS</target>
        </trans-unit>
        <trans-unit id="e0bba973b3126bd49629e5735098909a83c37fb8" translate="yes" xml:space="preserve">
          <source>VFS Adaptor Related Assumptions</source>
          <target state="translated">VFS 어댑터 관련 가정</target>
        </trans-unit>
        <trans-unit id="0427fe52d1301f469be76b38e86110229024c26c" translate="yes" xml:space="preserve">
          <source>VFS shim</source>
          <target state="translated">VFS 심</target>
        </trans-unit>
        <trans-unit id="42c3d050c1ab4fc79ee66e794588a38879f87c59" translate="yes" xml:space="preserve">
          <source>VFilter</source>
          <target state="translated">VFilter</target>
        </trans-unit>
        <trans-unit id="0fa2ff5785952199b4086a34e015d691fb6f638e" translate="yes" xml:space="preserve">
          <source>VIEW</source>
          <target state="translated">VIEW</target>
        </trans-unit>
        <trans-unit id="d1ea68c099681d5006dd208d2e34db6600ee8c5a" translate="yes" xml:space="preserve">
          <source>VIEWs in SQLite are read-only. You may not execute a DELETE, INSERT, or UPDATE statement on a view. But you can create a trigger that fires on an attempt to DELETE, INSERT, or UPDATE a view and do what you need in the body of the trigger.</source>
          <target state="translated">SQLite의 VIEW는 읽기 전용입니다. 뷰에서 DELETE, INSERT 또는 UPDATE 문을 실행할 수 없습니다. 그러나 뷰를 삭제, 삽입 또는 업데이트하려는 시도를 트리거하고 트리거 본문에서 필요한 작업을 수행하는 트리거를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fe4dd429e7ca82543f447d5b6e37edc0b0211f3" translate="yes" xml:space="preserve">
          <source>VIRTUAL</source>
          <target state="translated">VIRTUAL</target>
        </trans-unit>
        <trans-unit id="b9de5e41c6dc887dbc8f743605405fee0be8e279" translate="yes" xml:space="preserve">
          <source>VNext</source>
          <target state="translated">VNext</target>
        </trans-unit>
        <trans-unit id="348f1db286c8e9b47c43f2f013b0dd88171bf692" translate="yes" xml:space="preserve">
          <source>VOpen</source>
          <target state="translated">VOpen</target>
        </trans-unit>
        <trans-unit id="9741852a241ce6064f8f2d351b08520dd5847d98" translate="yes" xml:space="preserve">
          <source>VRename</source>
          <target state="translated">VRename</target>
        </trans-unit>
        <trans-unit id="4bce4ebd3cc132100d6cc36475c7b1294f94edb7" translate="yes" xml:space="preserve">
          <source>VUpdate</source>
          <target state="translated">VUpdate</target>
        </trans-unit>
        <trans-unit id="5fe15df2c7882707d49fdc0903788dfd022b02ca" translate="yes" xml:space="preserve">
          <source>Vacuum</source>
          <target state="translated">Vacuum</target>
        </trans-unit>
        <trans-unit id="27b07b92ebcc99b13cdafff029c3e3d22606bada" translate="yes" xml:space="preserve">
          <source>Vacuum the entire database P1. P1 is 0 for &quot;main&quot;, and 2 or more for an attached database. The &quot;temp&quot; database may not be vacuumed.</source>
          <target state="translated">전체 데이터베이스 P1을 진공 청소기로 청소하십시오. P1은 &quot;main&quot;의 경우 0이고 연결된 데이터베이스의 경우 2 이상입니다. &quot;temp&quot;데이터베이스를 정리하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0819f8114e772508968d8c091f0521044cadc7f0" translate="yes" xml:space="preserve">
          <source>Valgrind analysis</source>
          <target state="translated">발 그린 드 분석</target>
        </trans-unit>
        <trans-unit id="4869177d0c589735a7d4b9114f8982fe5d26f899" translate="yes" xml:space="preserve">
          <source>Value is a BLOB that is (N-12)/2 bytes in length.</source>
          <target state="translated">값은 길이가 (N-12) / 2 바이트 인 BLOB입니다.</target>
        </trans-unit>
        <trans-unit id="5d5aa2bdd2060b855e479d53c2581cc8223ca5a6" translate="yes" xml:space="preserve">
          <source>Value is a NULL.</source>
          <target state="translated">값은 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="c499129fd21c535eaa7f12c5970a992328cc9e08" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 16-bit twos-complement integer.</source>
          <target state="translated">값은 빅 엔디안 16 비트 2 보수 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e70cb145efe11c54bff7a396cfac28a6df7474e8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 24-bit twos-complement integer.</source>
          <target state="translated">값은 빅 엔디안 24 비트 2 보수 정수입니다.</target>
        </trans-unit>
        <trans-unit id="5e8e5ccfe7344d0d3d0abc79f36a5fdb932a3b7c" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 32-bit twos-complement integer.</source>
          <target state="translated">값은 빅 엔디안 32 비트 2 보수 정수입니다.</target>
        </trans-unit>
        <trans-unit id="b3f234aeea73b3135246f413e61277eaccb53eb8" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 48-bit twos-complement integer.</source>
          <target state="translated">값은 빅 엔디안 48 비트 2 보수 정수입니다.</target>
        </trans-unit>
        <trans-unit id="af2248db1aa0f6b54f70fbd4bad24187360977fd" translate="yes" xml:space="preserve">
          <source>Value is a big-endian 64-bit twos-complement integer.</source>
          <target state="translated">값은 빅 엔디안 64 비트 2 보수 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ae871c1581e8a49ebac1c7419a009e8fb57a2d5e" translate="yes" xml:space="preserve">
          <source>Value is a big-endian IEEE 754-2008 64-bit floating point number.</source>
          <target state="translated">값은 빅 엔디안 IEEE 754-2008 64 비트 부동 소수점 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="02f41d10900d18e2f000b1b5a2e593cf69aeca4b" translate="yes" xml:space="preserve">
          <source>Value is a string in the &lt;a href=&quot;fileformat2#enc&quot;&gt;text encoding&lt;/a&gt; and (N-13)/2 bytes in length. The nul terminator is not stored.</source>
          <target state="translated">값은 &lt;a href=&quot;fileformat2#enc&quot;&gt;텍스트 인코딩&lt;/a&gt; 의 문자열 이며 길이는 (N-13) / 2 바이트입니다. 널 종결자는 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4c71d03558220fa7cbe0d35d7582077b87759fd" translate="yes" xml:space="preserve">
          <source>Value is an 8-bit twos-complement integer.</source>
          <target state="translated">값은 8 비트 2 보수 정수입니다.</target>
        </trans-unit>
        <trans-unit id="21a8bbbdb0477e77f764478e79099dc10eca1b5a" translate="yes" xml:space="preserve">
          <source>Value is the integer 0. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">값은 정수 0입니다 ( &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;스키마 형식&lt;/a&gt; 4 이상 에서만 사용 가능 ).</target>
        </trans-unit>
        <trans-unit id="4b218cb556caba65180a69703c18a8657584030f" translate="yes" xml:space="preserve">
          <source>Value is the integer 1. (Only available for &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;schema format&lt;/a&gt; 4 and higher.)</source>
          <target state="translated">값은 정수 1입니다 ( &lt;a href=&quot;fileformat2#schemaformat&quot;&gt;스키마 형식&lt;/a&gt; 4 이상 에서만 사용 가능 ).</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="b74a3f9a59a12c1f692032bcd73742874ff821bd" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config()</source>
          <target state="translated">sqlite3session_config () 값</target>
        </trans-unit>
        <trans-unit id="bc12625ab4c97d74dcdc9d561aba55de6f3648e6" translate="yes" xml:space="preserve">
          <source>Values for sqlite3session_config().</source>
          <target state="translated">sqlite3session_config ()의 값입니다.</target>
        </trans-unit>
        <trans-unit id="21fb70cd308e717f82d11db0a79a04443511207e" translate="yes" xml:space="preserve">
          <source>Values of N between 100 and 1000 are recommended. Or, to disable the analysis limit, causing ANALYZE to do a complete scan of each index, set the analysis limit to 0. The default value for the analysis limit is 0 for backwards compatibility.</source>
          <target state="translated">100에서 1000 사이의 N 값이 권장됩니다. 또는 분석 한계를 비활성화하여 ANALYZE가 각 인덱스의 전체 스캔을 수행하도록하려면 분석 한계를 0으로 설정하십시오. 분석 한계의 기본값은 이전 버전과의 호환성을 위해 0입니다.</target>
        </trans-unit>
        <trans-unit id="4b975fa21a49b294e75ba8fe14419189c4abab11" translate="yes" xml:space="preserve">
          <source>Values stored in unindexed columns are not eligible to match MATCH operators. They do not influence the results of the offsets() or matchinfo() auxiliary functions. Nor will the snippet() function ever return a snippet based on a value stored in an unindexed column.</source>
          <target state="translated">인덱싱되지 않은 열에 저장된 값은 MATCH 연산자와 일치하지 않습니다. 이들은 offsets () 또는 matchinfo () 보조 함수의 결과에 영향을 미치지 않습니다. snippet () 함수는 인덱싱되지 않은 열에 저장된 값을 기반으로 스 니펫을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c15b50c2bdb6ec892f0c03794f814403120328ad" translate="yes" xml:space="preserve">
          <source>Values that may be passed as the second argument to a conflict-handler.</source>
          <target state="translated">충돌 처리기에 두 번째 인수로 전달 될 수있는 값입니다.</target>
        </trans-unit>
        <trans-unit id="19de69cb601f53a4ea7af22a65c71ae63251365c" translate="yes" xml:space="preserve">
          <source>Variable</source>
          <target state="translated">Variable</target>
        </trans-unit>
        <trans-unit id="51a317c7ddc79a1154219a293b13d3647c7088e1" translate="yes" xml:space="preserve">
          <source>Various bug fixes and documentation updates.</source>
          <target state="translated">다양한 버그 수정 및 설명서 업데이트.</target>
        </trans-unit>
        <trans-unit id="d5f06a4766a5315e31c33eb58743a7e83afa9adb" translate="yes" xml:space="preserve">
          <source>Various bug fixes and optimizations</source>
          <target state="translated">다양한 버그 수정 및 최적화</target>
        </trans-unit>
        <trans-unit id="85d7c8482bd4c4d0eab034cc91f2ea5f21b20d90" translate="yes" xml:space="preserve">
          <source>Various bug fixes in the &lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; tool.</source>
          <target state="translated">&lt;a href=&quot;sqldiff&quot;&gt;sqldiff&lt;/a&gt; 도구 의 다양한 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="ecec24b66500dbd17ba7725547d5521b2d6d2040" translate="yes" xml:space="preserve">
          <source>Various code refactorizations for performance</source>
          <target state="translated">성능을위한 다양한 코드 리팩토링</target>
        </trans-unit>
        <trans-unit id="85976ded19739ce2942c54c82204b742186a7556" translate="yes" xml:space="preserve">
          <source>Various compiler compatibility fixes.</source>
          <target state="translated">다양한 컴파일러 호환성 수정.</target>
        </trans-unit>
        <trans-unit id="ab65a12d6caf25bdc60a4edee517dc1ebef7b909" translate="yes" xml:space="preserve">
          <source>Various improvements in how the query planner uses &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; information to estimate plan costs.</source>
          <target state="translated">쿼리 플래너가 &lt;a href=&quot;fileformat2#stat4tab&quot;&gt;sqlite_stat4&lt;/a&gt; 정보를 사용 하여 계획 비용을 추정 하는 방법이 다양하게 개선되었습니다 .</target>
        </trans-unit>
        <trans-unit id="03823e5b502773a079a3bee8b39ca22cddaecb57" translate="yes" xml:space="preserve">
          <source>Various minor bug and documentation typo fixes and performance enhancements.</source>
          <target state="translated">다양한 사소한 버그 및 설명서 오타 수정 및 성능 향상.</target>
        </trans-unit>
        <trans-unit id="10b44287786294b34c89472b1d33c638e18576ac" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes</source>
          <target state="translated">다양한 사소한 버그 수정</target>
        </trans-unit>
        <trans-unit id="3f779a48c89979c93ac37abe87c5a7687464bc7d" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and documentation enhancements.</source>
          <target state="translated">다양한 사소한 버그 수정 및 설명서 향상.</target>
        </trans-unit>
        <trans-unit id="4847f53fde0fb417d8d4a76ab68b44562fd9a573" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes and performance enhancements.</source>
          <target state="translated">다양한 사소한 버그 수정 및 성능 향상.</target>
        </trans-unit>
        <trans-unit id="95ba96bcd2bbb545050ce738d48cb5ec939831b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes including fixes for tickets &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt;, &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt;, and &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529&lt;/a&gt;.</source>
          <target state="translated">티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/8f157e8010b22af0&quot;&gt;8f157e8010b22af0&lt;/a&gt; , &lt;a href=&quot;https://www.sqlite.org/src/info/9fb26d37cefaba40&quot;&gt;9fb26d37cefaba40&lt;/a&gt; , &lt;a href=&quot;https://www.sqlite.org/src/info/e367f31901ea8700&quot;&gt;e367f31901ea8700&lt;/a&gt; , &lt;a href=&quot;https://www.sqlite.org/src/info/b706351ce2ecf59a&quot;&gt;b706351ce2ecf59a&lt;/a&gt; , &lt;a href=&quot;https://www.sqlite.org/src/info/7c6d876f84e6e7e2&quot;&gt;7c6d876f84e6e7e2&lt;/a&gt; 및 &lt;a href=&quot;https://www.sqlite.org/src/info/c8d3b9f0a750a529&quot;&gt;c8d3b9f0a750a529에&lt;/a&gt; 대한 수정을 포함한 다양한 사소한 버그 수정 .</target>
        </trans-unit>
        <trans-unit id="3d9299a31e992a8798950b9ee230e2efd3cac0b2" translate="yes" xml:space="preserve">
          <source>Various minor bug fixes.</source>
          <target state="translated">다양한 사소한 버그 수정.</target>
        </trans-unit>
        <trans-unit id="2514c8b40a668dc1475dfd0f9f137b0141e179e2" translate="yes" xml:space="preserve">
          <source>Various performance improvements.</source>
          <target state="translated">다양한 성능 향상.</target>
        </trans-unit>
        <trans-unit id="6342eea4c52b8714f01d87ea8795935f65636135" translate="yes" xml:space="preserve">
          <source>Verify that an Abort can happen. Assert if an Abort at this point might cause database corruption. This opcode only appears in debugging builds.</source>
          <target state="translated">중단이 발생할 수 있는지 확인하십시오. 이 시점에서 중단이 데이터베이스 손상을 일으킬 수 있는지 확인하십시오. 이 opcode는 디버깅 빌드에만 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0e121d547f14e098984e65cce93a4f32d31bdccc" translate="yes" xml:space="preserve">
          <source>Version 1.0.X of SQLite used the GDBM library as its backend interface to the disk. Beginning in version 2.0.0, GDBM was replaced by a custom B-Tree library written especially for SQLite. The new B-Tree backend is twice as fast as GDBM, supports atomic commits and rollback, and stores an entire database in a single disk file instead using a separate file for each table as GDBM does. The two file formats are not even remotely similar.</source>
          <target state="translated">SQLite 버전 1.0.X는 GDBM 라이브러리를 디스크의 백엔드 인터페이스로 사용했습니다. 버전 2.0.0부터 GDBM은 SQLite를 위해 특별히 작성된 사용자 정의 B-Tree 라이브러리로 대체되었습니다. 새로운 B-Tree 백엔드는 GDBM보다 두 배 빠르며, 원자 커밋 및 롤백을 지원하며, GDBM이하는 것처럼 각 테이블에 대해 별도의 파일을 사용하는 대신 전체 데이터베이스를 단일 디스크 파일에 저장합니다. 두 파일 형식은 원격으로 비슷하지도 않습니다.</target>
        </trans-unit>
        <trans-unit id="15147c06759c9052778bf2211d35cc6a76e87f68" translate="yes" xml:space="preserve">
          <source>Version 2.2.0 and later of the library will automatically detect when it is reading a 2.1.x database and will disable the new INTEGER PRIMARY KEY feature. In other words, version 2.2.x is backwards compatible to version 2.1.x. But version 2.1.x is not forward compatible with version 2.2.x. If you try to open a 2.2.x database with an older 2.1.x library and that database contains an INTEGER PRIMARY KEY, you will likely get a coredump. If the database schema does not contain any INTEGER PRIMARY KEYs, then the version 2.1.x and version 2.2.x database files will be identical and completely interchangeable.</source>
          <target state="translated">라이브러리의 버전 2.2.0 이상은 2.1.x 데이터베이스를 읽을 때 자동으로 감지하여 새로운 정수 기본 키 기능을 사용하지 않습니다. 즉, 버전 2.2.x는 버전 2.1.x와 호환됩니다. 그러나 버전 2.1.x는 버전 2.2.x와 호환되지 않습니다. 이전 2.1.x 라이브러리로 2.2.x 데이터베이스를 열려고하고 해당 데이터베이스에 INTEGER PRIMARY KEY가 포함되어 있으면 코어 덤프가 발생할 수 있습니다. 데이터베이스 스키마에 INTEGER PRIMARY KEY가 포함되어 있지 않으면 버전 2.1.x 및 버전 2.2.x 데이터베이스 파일은 동일하며 완전히 상호 교환 가능합니다.</target>
        </trans-unit>
        <trans-unit id="0117d508d1c578c143be74741c597fcb4aa7a934" translate="yes" xml:space="preserve">
          <source>Version 2.6.0 or later of the library cannot open read-only database files from version 2.5.6 or earlier, since read-only files cannot be upgraded to the new format.</source>
          <target state="translated">읽기 전용 파일을 새 형식으로 업그레이드 할 수 없으므로 버전 2.6.0 이상의 라이브러리 버전 2.5.6 이하에서 읽기 전용 데이터베이스 파일을 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b22eaca7a28d27b61c642146bfe60e035fc837b9" translate="yes" xml:space="preserve">
          <source>Version 2.8.0 introduces a change to the format of the rollback journal file. The main database file format is unchanged. Versions 2.7.6 and earlier can read and write 2.8.0 databases and vice versa. Version 2.8.0 can rollback a transaction that was started by version 2.7.6 and earlier. But version 2.7.6 and earlier cannot rollback a transaction started by version 2.8.0 or later.</source>
          <target state="translated">버전 2.8.0에서는 롤백 저널 파일 형식이 변경되었습니다. 기본 데이터베이스 파일 형식은 변경되지 않습니다. 2.7.6 이하 버전은 2.8.0 데이터베이스를 읽고 쓸 수 있으며 그 반대도 가능합니다. 버전 2.8.0은 버전 2.7.6 이하에서 시작된 트랜잭션을 롤백 할 수 있습니다. 그러나 버전 2.7.6 이하는 버전 2.8.0 이상으로 시작된 트랜잭션을 롤백 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5ab1c612d2172f97ee17ccb094511130795e0e49" translate="yes" xml:space="preserve">
          <source>Version 3.0.0 is a major upgrade for SQLite that incorporates support for UTF-16, BLOBs, and a more compact encoding that results in database files that are typically 25% to 50% smaller. The new file format is very different and is completely incompatible with the version 2 file format.</source>
          <target state="translated">버전 3.0.0은 UTF-16, BLOB 및보다 컴팩트 한 인코딩을 지원하는 SQLite의 주요 업그레이드로, 일반적으로 25 %에서 50 % 더 작은 데이터베이스 파일을 생성합니다. 새 파일 형식은 매우 다르며 버전 2 파일 형식과 완전히 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="560474f7906b0238187c7f7b7f4ee43ef0381a4c" translate="yes" xml:space="preserve">
          <source>Version 3.10.0 introduced a case-folding bug in the &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; operator which is fixed by this patch release. Ticket &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt;.</source>
          <target state="translated">버전 3.10.0은 &lt;a href=&quot;lang_expr#like&quot;&gt;LIKE&lt;/a&gt; 연산자에서이 패치 릴리스로 수정 된 대소 문자 버그를 도입했습니다 . 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/80369eddd5c94&quot;&gt;80369eddd5c94&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09330c4007db255bbeea2ef8f69d34761c5d8efc" translate="yes" xml:space="preserve">
          <source>Version 3.5.0 of SQLite changes the behavior of a few APIs in ways that are technically incompatible. However, these APIs are seldom used and even when they are used it is difficult to imagine a scenario where the change might break something. The changes actually makes these interface much more useful and powerful.</source>
          <target state="translated">SQLite 버전 3.5.0은 기술적으로 호환되지 않는 방식으로 몇 가지 API의 동작을 변경합니다. 그러나 이러한 API는 거의 사용되지 않으며 사용하더라도 변경으로 인해 문제가 발생할 수있는 시나리오를 상상하기 어렵습니다. 이러한 변경으로 인해 이러한 인터페이스가 훨씬 유용하고 강력 해졌습니다.</target>
        </trans-unit>
        <trans-unit id="621e552e91497473887ee98c411a17ae0c22faad" translate="yes" xml:space="preserve">
          <source>Version Change</source>
          <target state="translated">버전 변경</target>
        </trans-unit>
        <trans-unit id="57c774f0b39c0a5a2da04603c552cf0b2e97f635" translate="yes" xml:space="preserve">
          <source>Version Numbers in SQLite</source>
          <target state="translated">SQLite의 버전 번호</target>
        </trans-unit>
        <trans-unit id="92c5569b77b82f07b395294f1952d2ab591b5725" translate="yes" xml:space="preserve">
          <source>Version method</source>
          <target state="translated">버전 방법</target>
        </trans-unit>
        <trans-unit id="12b0595bc53b8fdea788b66adfb5e6aeb225a99c" translate="yes" xml:space="preserve">
          <source>Versioning of the SQLite source code has transitioned from CVS to &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt;.</source>
          <target state="translated">SQLite 소스 코드의 버전 관리가 CVS에서 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil로&lt;/a&gt; 전환되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9b36ebe549ad7e57c9fee50024e4b91ba9111a84" translate="yes" xml:space="preserve">
          <source>Very few CVEs written about SQLite are real vulnerabilities in the sense that they do not give any new capabilities to an attacker. Consider:</source>
          <target state="translated">SQLite에 대해 작성된 CVE는 공격자에게 새로운 기능을 제공하지 않는다는 점에서 실제 취약점입니다. 중히 여기다:</target>
        </trans-unit>
        <trans-unit id="2a826473d10edb3f601f04f14066361f0f7573c3" translate="yes" xml:space="preserve">
          <source>Via the &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; and &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf()&lt;/a&gt; interfaces, the built-in printf() implementation supports the ability to render an arbitrary-length string into a memory buffer obtained from &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64()&lt;/a&gt;. This is safer and less error prone than trying to precompute an upper size limit on the result string, allocate an appropriately sized buffer, and then calling snprintf().</source>
          <target state="translated">비아 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_vmprintf ()&lt;/a&gt; 인터페이스는 내장의 printf () 구현은 메모리에 임의의 길이 스트링을 렌더링하는 능력에 의한 완충액을 지원 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc64을 ()&lt;/a&gt; . 결과 문자열의 상한 크기를 미리 계산하고 적절한 크기의 버퍼를 할당 한 다음 snprintf ()를 호출하는 것보다 안전하고 오류가 적습니다.</target>
        </trans-unit>
        <trans-unit id="7661d9e884510184f3115feaa61daa7fb90ab554" translate="yes" xml:space="preserve">
          <source>Virtual File System Objects</source>
          <target state="translated">가상 파일 시스템 객체</target>
        </trans-unit>
        <trans-unit id="0f4f4c40c9b657d040c9a5a3549b3c5d32fbc234" translate="yes" xml:space="preserve">
          <source>Virtual Table Configuration Options</source>
          <target state="translated">가상 테이블 구성 옵션</target>
        </trans-unit>
        <trans-unit id="57189223b1eb8b14988a31c1f5a4ff48cc80e85d" translate="yes" xml:space="preserve">
          <source>Virtual Table Constraint Operator Codes</source>
          <target state="translated">가상 테이블 제약 조건 연산자 코드</target>
        </trans-unit>
        <trans-unit id="d3cabefe217e8ae9513576669d0630c721003893" translate="yes" xml:space="preserve">
          <source>Virtual Table Cursor Object</source>
          <target state="translated">가상 테이블 커서 객체</target>
        </trans-unit>
        <trans-unit id="02d05d9b66c15b554ca60cadbe6ddd8d5a77642f" translate="yes" xml:space="preserve">
          <source>Virtual Table Indexing Information</source>
          <target state="translated">가상 테이블 인덱싱 정보</target>
        </trans-unit>
        <trans-unit id="80548cb099ad243dfef606537d8cb425cbe7b21c" translate="yes" xml:space="preserve">
          <source>Virtual Table Instance Object</source>
          <target state="translated">가상 테이블 인스턴스 객체</target>
        </trans-unit>
        <trans-unit id="681b6ef1224b6badb83f1618372bb0a3a5b7009a" translate="yes" xml:space="preserve">
          <source>Virtual Table Interface Configuration</source>
          <target state="translated">가상 테이블 인터페이스 구성</target>
        </trans-unit>
        <trans-unit id="b4e32b4e8d0ccc9df7f37bef23928bcdb8c21a47" translate="yes" xml:space="preserve">
          <source>Virtual Table Mechanism</source>
          <target state="translated">가상 테이블 메커니즘</target>
        </trans-unit>
        <trans-unit id="c7613e2461269638f02a689a01bdfb20ef96932a" translate="yes" xml:space="preserve">
          <source>Virtual Table Object</source>
          <target state="translated">가상 테이블 객체</target>
        </trans-unit>
        <trans-unit id="6fb2f6d632c98f78eae8aef07afc99de73e44e98" translate="yes" xml:space="preserve">
          <source>Virtual Table Scan Flags</source>
          <target state="translated">가상 테이블 스캔 플래그</target>
        </trans-unit>
        <trans-unit id="c6305adeaa93ffb40a0b3ae2ce131299d686cab8" translate="yes" xml:space="preserve">
          <source>Virtual machine stores 64-bit integer and floating point constants in binary instead of text for a performance boost.</source>
          <target state="translated">가상 시스템은 성능 향상을 위해 64 비트 정수 및 부동 소수점 상수를 텍스트 대신 이진으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="a4369e3d1e48bcfd676b740e0d14b603ed7287ae" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">가상 테이블 구현에서는 &lt;a href=&quot;#sqlite3_index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlags 필드를 이러한 비트의 조합으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e7d9ed7bcb125e908a8e59f746fb86a62ee768a" translate="yes" xml:space="preserve">
          <source>Virtual table implementations are allowed to set the &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;.idxFlags field to some combination of these bits.</source>
          <target state="translated">가상 테이블 구현에서는 &lt;a href=&quot;index_info&quot;&gt;sqlite3_index_info&lt;/a&gt; .idxFlags 필드를 이러한 비트의 조합으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1224e431f5f3956505068b6d1ec8eea58f8cfc" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">OR REPLACE를 처리하는 데 필요한 가상 테이블 구현은 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 내에서 수행해야합니다 . &lt;a href=&quot;vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 함수에 대한 호출 이 현재 ON CONFLICT 정책이 REPLACE임을 나타내는 경우 가상 테이블 구현은 xUpdate 콜백 내의 해당 행을 자동으로 바꾸고 SQLITE_OK를 리턴해야합니다. 또는 이것이 불가능한 경우 SQLITE_CONSTRAINT를 리턴 할 수 있으며,이 경우 SQLite는 OR ABORT 제한 조건 처리로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="6fd2d8e7bee948b9df988a6ac379b263c059c2c5" translate="yes" xml:space="preserve">
          <source>Virtual table implementations that are required to handle OR REPLACE must do so within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method. If a call to the &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict()&lt;/a&gt; function indicates that the current ON CONFLICT policy is REPLACE, the virtual table implementation should silently replace the appropriate rows within the xUpdate callback and return SQLITE_OK. Or, if this is not possible, it may return SQLITE_CONSTRAINT, in which case SQLite falls back to OR ABORT constraint handling.</source>
          <target state="translated">OR REPLACE를 처리하는 데 필요한 가상 테이블 구현은 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 내에서 수행해야합니다 . &lt;a href=&quot;#sqlite3_vtab_on_conflict&quot;&gt;sqlite3_vtab_on_conflict ()&lt;/a&gt; 함수에 대한 호출 이 현재 ON CONFLICT 정책이 REPLACE임을 나타내는 경우 가상 테이블 구현은 xUpdate 콜백 내의 해당 행을 자동으로 바꾸고 SQLITE_OK를 리턴해야합니다. 또는 이것이 불가능한 경우 SQLITE_CONSTRAINT를 리턴 할 수 있으며,이 경우 SQLite는 OR ABORT 제한 조건 처리로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="81aaad6c6dfb9299173befc645c959005f239f65" translate="yes" xml:space="preserve">
          <source>Virtual table implementations will normally subclass this structure to add additional private and implementation-specific fields. The nRef field is used internally by the SQLite core and should not be altered by the virtual table implementation. The virtual table implementation may pass error message text to the core by putting an error message string in zErrMsg. Space to hold this error message string must be obtained from an SQLite memory allocation function such as &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc()&lt;/a&gt;. Prior to assigning a new value to zErrMsg, the virtual table implementation must free any preexisting content of zErrMsg using &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free()&lt;/a&gt;. Failure to do this will result in a memory leak. The SQLite core will free and zero the content of zErrMsg when it delivers the error message text to the client application or when it destroys the virtual table. The virtual table implementation only needs to worry about freeing the zErrMsg content when it overwrites the content with a new, different error message.</source>
          <target state="translated">가상 테이블 구현은 일반적으로이 구조를 서브 클래 싱하여 추가 개인 및 구현 특정 필드를 추가합니다. nRef 필드는 SQLite 코어에서 내부적으로 사용되며 가상 테이블 구현으로 변경하면 안됩니다. 가상 테이블 구현은 zErrMsg에 오류 메시지 문자열을 넣어 오류 메시지 텍스트를 코어에 전달할 수 있습니다. 이 오류 메시지 문자열을 보유 할 공간은 &lt;a href=&quot;c3ref/mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_malloc ()&lt;/a&gt; 과 같은 SQLite 메모리 할당 함수에서 확보해야합니다 . zErrMsg에 새 값을 지정하기 전에 가상 테이블 구현은 &lt;a href=&quot;c3ref/free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 사용하여 zErrMsg의 기존 컨텐츠를 해제해야합니다.. 그렇지 않으면 메모리 누수가 발생합니다. SQLite 코어는 오류 메시지 텍스트를 클라이언트 응용 프로그램에 전달하거나 가상 테이블을 삭제할 때 zErrMsg의 내용을 비우고 제로화합니다. 가상 테이블 구현은 zErrMsg 컨텐츠가 컨텐츠를 새롭고 다른 오류 메시지로 겹쳐 쓸 때 해제 할 때만 걱정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="40dd4a6572104b0d97f5845a7aa00abca493ea5c" translate="yes" xml:space="preserve">
          <source>Virtual tables</source>
          <target state="translated">가상 테이블</target>
        </trans-unit>
        <trans-unit id="9c69270878a43f4468e25b3717d6b2598ec3353a" translate="yes" xml:space="preserve">
          <source>Virtual tables are ignored by default by sqldiff. However, it is possible to explicitly create an RBU data_% table for a virtual table that features a rowid that functions like a primary key using a command such as:</source>
          <target state="translated">가상 테이블은 sqldiff에 의해 기본적으로 무시됩니다. 그러나 다음과 같은 명령을 사용하여 기본 키처럼 작동하는 rowid가있는 가상 테이블에 대해 RBU data_ % 테이블을 명시 적으로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb343842b9377b7930027e69fe1b4b95ab0bc54" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">가상 테이블은 &lt;a href=&quot;module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; 메소드를 사용하여 대체 기능 구현을 제공 할 수 있습니다 . 그러나 오버로드되기 위해서는 해당 기능의 글로벌 버전이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="ea35a0ae0128b32ea2712f75cfcca274a0e301d3" translate="yes" xml:space="preserve">
          <source>Virtual tables can provide alternative implementations of functions using the &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; method of the &lt;a href=&quot;#sqlite3_module&quot;&gt;virtual table module&lt;/a&gt;. But global versions of those functions must exist in order to be overloaded.</source>
          <target state="translated">가상 테이블은 &lt;a href=&quot;#sqlite3_module&quot;&gt;가상 테이블 모듈&lt;/a&gt; 의 &lt;a href=&quot;vtab#xfindfunction&quot;&gt;xFindFunction&lt;/a&gt; 메소드를 사용하여 대체 기능 구현을 제공 할 수 있습니다 . 그러나 오버로드되기 위해서는 해당 기능의 글로벌 버전이 존재해야합니다.</target>
        </trans-unit>
        <trans-unit id="17882224a33603a1de5faab8a2a01eaa906c2eb6" translate="yes" xml:space="preserve">
          <source>Virtual tables for which the &quot;rowid&quot; column does not function like a primary key value cannot be updated using RBU.</source>
          <target state="translated">&quot;rowid&quot;열이 기본 키 값처럼 작동하지 않는 가상 테이블은 RBU를 사용하여 업데이트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d97bfa2f28319cd6ae1be60d2bddfa72a278a536" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">가상 테이블 메소드는 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻은 문자열 을 zErrMsg 에 지정하여 오류 메시지를 설정할 수 있습니다 . 메소드는 zErrMsg에 새 문자열을 지정하기 전에 &lt;a href=&quot;#sqlite3_free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 호출하여 이전 문자열이 해제되도록주의해야합니다 . 오류 메시지가 클라이언트 응용 프로그램으로 전달 된 후 sqlite3_free ()에 의해 문자열이 자동으로 해제되고 zErrMsg 필드가 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="f460e6a98df6a13dcf481c34d0a877733d497773" translate="yes" xml:space="preserve">
          <source>Virtual tables methods can set an error message by assigning a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; to zErrMsg. The method should take care that any prior string is freed by a call to &lt;a href=&quot;free&quot;&gt;sqlite3_free()&lt;/a&gt; prior to assigning a new string to zErrMsg. After the error message is delivered up to the client application, the string will be automatically freed by sqlite3_free() and the zErrMsg field will be zeroed.</source>
          <target state="translated">가상 테이블 메소드는 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻은 문자열 을 zErrMsg 에 지정하여 오류 메시지를 설정할 수 있습니다 . 메소드는 zErrMsg에 새 문자열을 지정하기 전에 &lt;a href=&quot;free&quot;&gt;sqlite3_free ()를&lt;/a&gt; 호출하여 이전 문자열이 해제되도록주의해야합니다 . 오류 메시지가 클라이언트 응용 프로그램으로 전달 된 후 sqlite3_free ()에 의해 문자열이 자동으로 해제되고 zErrMsg 필드가 0이됩니다.</target>
        </trans-unit>
        <trans-unit id="8dd3e411a2cd1cd0400ed8b91a5e2884ea85bf05" translate="yes" xml:space="preserve">
          <source>Virtual terms are used for analysis only and do not cause any byte-code to be generated. If both virtual terms end up being used as constraints on an index, then the original BETWEEN term is omitted and the corresponding test is not performed on input rows. Thus if the BETWEEN term ends up being used as an index constraint no tests are ever performed on that term. On the other hand, the virtual terms themselves never causes tests to be performed on input rows. Thus if the BETWEEN term is not used as an index constraint and instead must be used to test input rows, the</source>
          <target state="translated">가상 항은 분석에만 사용되며 바이트 코드가 생성되지 않습니다. 두 가상 용어가 모두 인덱스에 대한 제약 조건으로 사용되면 원래 BETWEEN 용어는 생략되고 해당 테스트는 입력 행에서 수행되지 않습니다. 따라서 BETWEEN 용어가 인덱스 제약 조건으로 사용되면 해당 용어에 대한 테스트가 수행되지 않습니다. 반면에 가상 용어 자체는 입력 행에서 테스트를 수행하지 않습니다. 따라서 BETWEEN 용어를 인덱스 제약 조건으로 사용하지 않고 입력 행을 테스트하는 데 사용해야하는 경우</target>
        </trans-unit>
        <trans-unit id="69180499c91410d16271921874ed2a25a5b8ba2f" translate="yes" xml:space="preserve">
          <source>Visit the sick.</source>
          <target state="translated">병자를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="c18668323ee175259b4d33e74c3e8421bb9608b5" translate="yes" xml:space="preserve">
          <source>Vulnerabilities</source>
          <target state="translated">Vulnerabilities</target>
        </trans-unit>
        <trans-unit id="63fbb3bb789b808aff0169713cbc7f0fe8b26b33" translate="yes" xml:space="preserve">
          <source>WAL Frame Header Format</source>
          <target state="translated">WAL 프레임 헤더 형식</target>
        </trans-unit>
        <trans-unit id="744e2e67c24aa24ef2724e0cca0702b0e396b77b" translate="yes" xml:space="preserve">
          <source>WAL Header Format</source>
          <target state="translated">WAL 헤더 형식</target>
        </trans-unit>
        <trans-unit id="06c6d5627eae51ea8b07e45901c927d0fff1639e" translate="yes" xml:space="preserve">
          <source>WAL backwards compatibility</source>
          <target state="translated">WAL 하위 호환성</target>
        </trans-unit>
        <trans-unit id="7f3d7dac78ce17ee863e11b29dd77ba4c3b844b1" translate="yes" xml:space="preserve">
          <source>WAL checksum algorithm</source>
          <target state="translated">WAL 체크섬 알고리즘</target>
        </trans-unit>
        <trans-unit id="43394fc5704020bd91d68a3ea6cb25e34c7a31ef" translate="yes" xml:space="preserve">
          <source>WAL concurrency</source>
          <target state="translated">WAL 동시성</target>
        </trans-unit>
        <trans-unit id="52a8587a456d98f221f4f9bce63c226fcda62f9a" translate="yes" xml:space="preserve">
          <source>WAL file</source>
          <target state="translated">WAL 파일</target>
        </trans-unit>
        <trans-unit id="50ce9ea412cfc1994dee0ce8829cf26ea47867fa" translate="yes" xml:space="preserve">
          <source>WAL format</source>
          <target state="translated">WAL 형식</target>
        </trans-unit>
        <trans-unit id="2c59f37be8a8a85d4967e8d84ff245b823d2c3d3" translate="yes" xml:space="preserve">
          <source>WAL is significantly faster in most scenarios.</source>
          <target state="translated">대부분의 시나리오에서 WAL이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="df48eb81aeb4b91265bedea157514a68984a16d8" translate="yes" xml:space="preserve">
          <source>WAL might be very slightly slower (perhaps 1% or 2% slower) than the traditional rollback-journal approach in applications that do mostly reads and seldom write.</source>
          <target state="translated">WAL은 대부분 읽기 및 쓰기가 거의 수행되지 않는 응용 프로그램의 기존 롤백 저널 접근 방식보다 약간 느리거나 (아마도 1 % 또는 2 % 느리게) 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a97139b7e130c0c8a433bdf669136c84f9136b7" translate="yes" xml:space="preserve">
          <source>WAL mode permits simultaneous readers and writers. It can do this because changes do not overwrite the original database file, but rather go into the separate write-ahead log file. That means that readers can continue to read the old, original, unaltered content from the original database file at the same time that the writer is appending to the write-ahead log. In &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, SQLite exhibits &quot;snapshot isolation&quot;. When a read transaction starts, that reader continues to see an unchanging &quot;snapshot&quot; of the database file as it existed at the moment in time when the read transaction started. Any write transactions that commit while the read transaction is active are still invisible to the read transaction, because the reader is seeing a snapshot of database file from a prior moment in time.</source>
          <target state="translated">WAL 모드는 독자와 작가를 동시에 허용합니다. 변경 사항이 원래 데이터베이스 파일을 겹쳐 쓰지 않고 별도의 미리 쓰기 로그 파일로 이동하기 때문에이를 수행 할 수 있습니다. 이는 독자가 기록기가 미리 기록 로그에 추가하는 동시에 독자가 원본 데이터베이스 파일에서 변경되지 않은 기존의 원래 내용을 계속 읽을 수 있음을 의미합니다. 에서 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; , SQLite는 전시 &quot;스냅 숏 격리&quot;. 읽기 트랜잭션이 시작되면 해당 읽기 프로그램은 읽기 트랜잭션이 시작된 시점에 존재했던 그대로 데이터베이스 파일의 &quot;스냅 샷&quot;을 변경없이 확인합니다. 읽기 트랜잭션이 활성화되어있는 동안 커밋 된 모든 쓰기 트랜잭션은 읽기 트랜잭션에서 여전히 보이지 않습니다. 독자는 이전 시점부터 데이터베이스 파일의 스냅 샷을보고 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="cd8ce3e93d7ff89ed9c8371ea6e45fd8f37cf883" translate="yes" xml:space="preserve">
          <source>WAL mode with synchronous NORMAL,</source>
          <target state="translated">동기식 NORMAL이있는 WAL 모드</target>
        </trans-unit>
        <trans-unit id="02d4a388313bcdd7b2c200b7ae8c4e65a2674e7c" translate="yes" xml:space="preserve">
          <source>WAL normally requires that the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; support shared-memory primitives. (Exception: &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;) The built-in unix and windows VFSes support this but third-party extension VFSes for custom operating systems might not.</source>
          <target state="translated">WAL에서는 일반적으로 &lt;a href=&quot;vfs&quot;&gt;VFS가&lt;/a&gt; 공유 메모리 프리미티브를 지원 해야합니다 . (예외 : &lt;a href=&quot;wal#noshm&quot;&gt;공유 메모리가없는 WAL&lt;/a&gt; ) 내장 된 unix 및 windows VFS는이 기능을 지원하지만 사용자 정의 운영 체제의 타사 확장 VFS는 지원하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="773f18c2587f00153abb58a02a9105f99addd056" translate="yes" xml:space="preserve">
          <source>WAL provides more concurrency as readers do not block writers and a writer does not block readers. Reading and writing can proceed concurrently.</source>
          <target state="translated">WAL은 독자가 작성자를 차단하지 않고 작성자가 독자를 차단하지 않기 때문에 더 많은 동시성을 제공합니다. 읽기와 쓰기가 동시에 진행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92f6b05049160f00dd8c3ee0f71a3f765656c3a" translate="yes" xml:space="preserve">
          <source>WAL read algorithm</source>
          <target state="translated">WAL 읽기 알고리즘</target>
        </trans-unit>
        <trans-unit id="ea6e19418d259cb4081e953d6c25797fc3b82935" translate="yes" xml:space="preserve">
          <source>WAL reset</source>
          <target state="translated">WAL 리셋</target>
        </trans-unit>
        <trans-unit id="ba93da00cc71fcc3b4f076052eaeb32eb6b9800c" translate="yes" xml:space="preserve">
          <source>WAL uses many fewer fsync() operations and is thus less vulnerable to problems on systems where the fsync() system call is broken.</source>
          <target state="translated">WAL은 훨씬 적은 수의 fsync () 작업을 사용하므로 fsync () 시스템 호출이 중단 된 시스템의 문제에 덜 취약합니다.</target>
        </trans-unit>
        <trans-unit id="935e3aae9a4d9f6fb670dd29df8a280f6a07053c" translate="yes" xml:space="preserve">
          <source>WAL without shared memory</source>
          <target state="translated">공유 메모리가없는 WAL</target>
        </trans-unit>
        <trans-unit id="c5c7bca44dc98aebaf5146b41dc5aa511b8a8aa6" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Details</source>
          <target state="translated">WAL 색인 헤더 세부 사항</target>
        </trans-unit>
        <trans-unit id="e370010e43949311e2b789c1fcb72213cd69886b" translate="yes" xml:space="preserve">
          <source>WAL-Index Header Divisions</source>
          <target state="translated">WAL 인덱스 헤더 부문</target>
        </trans-unit>
        <trans-unit id="738cab6ddeb95b98c824e2fa6c01b30e9dcb5952" translate="yes" xml:space="preserve">
          <source>WAL-Index Locks Controlled By xShmLock()</source>
          <target state="translated">xShmLock ()으로 제어되는 WAL 인덱스 잠금</target>
        </trans-unit>
        <trans-unit id="f9538dc159e3d4ee9069c606e83b7a548fc2f640" translate="yes" xml:space="preserve">
          <source>WAL-index format</source>
          <target state="translated">WAL 색인 형식</target>
        </trans-unit>
        <trans-unit id="bfa5d0e78b2dc4651911fcb18213d8d8bcf10c94" translate="yes" xml:space="preserve">
          <source>WAL-mode File Format</source>
          <target state="translated">WAL 모드 파일 형식</target>
        </trans-unit>
        <trans-unit id="de71e324c9bcbf886760fa79f3cdf3359f06f756" translate="yes" xml:space="preserve">
          <source>WAL-mode crash recovery</source>
          <target state="translated">WAL 모드 응급 복구</target>
        </trans-unit>
        <trans-unit id="f45f2752fdcaf800e0a1910433e500b6102d9c5c" translate="yes" xml:space="preserve">
          <source>WAL-mode locks</source>
          <target state="translated">WAL 모드 잠금</target>
        </trans-unit>
        <trans-unit id="0e94e9cb4190e9d9687693e4eaf1537e92418a3d" translate="yes" xml:space="preserve">
          <source>WAL-mode read blocking</source>
          <target state="translated">WAL 모드 읽기 차단</target>
        </trans-unit>
        <trans-unit id="b20f2962509be83b4058f80a47d244e5b11196b8" translate="yes" xml:space="preserve">
          <source>WAL_CKPT_LOCK</source>
          <target state="translated">WAL_CKPT_LOCK</target>
        </trans-unit>
        <trans-unit id="7d8dca53c800f5b912f5029eb6c49020dba95f10" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(0)</source>
          <target state="translated">WAL_READ_LOCK(0)</target>
        </trans-unit>
        <trans-unit id="182225568ec6a131ef84113496e8619eaa0d74bc" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(1)</source>
          <target state="translated">WAL_READ_LOCK(1)</target>
        </trans-unit>
        <trans-unit id="e7da30047a308b88f352a994772f05755945376a" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(2)</source>
          <target state="translated">WAL_READ_LOCK(2)</target>
        </trans-unit>
        <trans-unit id="af1d79e6c2231524894cbc98a7822ed397be08ea" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(3)</source>
          <target state="translated">WAL_READ_LOCK(3)</target>
        </trans-unit>
        <trans-unit id="33fe625c4da68b4d223dd3cf41bf33912b01d2d2" translate="yes" xml:space="preserve">
          <source>WAL_READ_LOCK(4)</source>
          <target state="translated">WAL_READ_LOCK(4)</target>
        </trans-unit>
        <trans-unit id="5e15c21a39d31cebadee8ce801a0923d71efe684" translate="yes" xml:space="preserve">
          <source>WAL_RECOVER_LOCK</source>
          <target state="translated">WAL_RECOVER_LOCK</target>
        </trans-unit>
        <trans-unit id="97bb53df8b738f49899ec6f8612f4070a67257d9" translate="yes" xml:space="preserve">
          <source>WAL_WRITE_LOCK</source>
          <target state="translated">WAL_WRITE_LOCK</target>
        </trans-unit>
        <trans-unit id="962a5cebdb56ec36c6dbf4d84e53c7c677fcc3ab" translate="yes" xml:space="preserve">
          <source>WARNING/TODO: This function currently assumes that the input is a valid changeset. If it is not, the results are undefined.</source>
          <target state="translated">WARNING / TODO :이 기능은 현재 입력이 유효한 변경 세트라고 가정합니다. 그렇지 않으면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66428bb1d785a8e164fb6679f1dcee0c10acabb5" translate="yes" xml:space="preserve">
          <source>WARNING: If this macro is defined, it will not be possible to open a database for which the schema contains VIEW objects.</source>
          <target state="translated">경고 :이 매크로가 정의되면 스키마에 VIEW 객체가 포함 된 데이터베이스를 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e3eafa40a094c805daed78cdb48c723e5b81b9a1" translate="yes" xml:space="preserve">
          <source>WHEN</source>
          <target state="translated">WHEN</target>
        </trans-unit>
        <trans-unit id="1c255b91e71a2fddc2e75f8455387053d412a4c1" translate="yes" xml:space="preserve">
          <source>WHERE</source>
          <target state="translated">WHERE</target>
        </trans-unit>
        <trans-unit id="cfda4d41a395db406982a11851ae2e1bfcf9956d" translate="yes" xml:space="preserve">
          <source>WHERE clause</source>
          <target state="translated">WHERE 절</target>
        </trans-unit>
        <trans-unit id="f21acb9f8ec93625bf5c0906f54fc785624f93c0" translate="yes" xml:space="preserve">
          <source>WHERE clause constraints that are connected by OR instead of AND can be handled in two different ways. If a term consists of multiple subterms containing a common column name and separated by OR, like this:</source>
          <target state="translated">AND 대신 OR로 연결된 WHERE 절 제약 조건은 서로 다른 두 가지 방식으로 처리 할 수 ​​있습니다. 용어가 공통 열 이름을 포함하고 다음과 같이 OR로 구분 된 여러 하위 용어로 구성된 경우 :</target>
        </trans-unit>
        <trans-unit id="1e47856edce4197b9e0ea412ab9daf0c805ed99c" translate="yes" xml:space="preserve">
          <source>WHERE clause expressions using BETWEEN and OR are now candidates for optimization</source>
          <target state="translated">BETWEEN 및 OR을 사용하는 WHERE 절 표현식이 이제 최적화 후보입니다.</target>
        </trans-unit>
        <trans-unit id="201f5bdde79034efdfb90c4b9a48c56dd51af9e1" translate="yes" xml:space="preserve">
          <source>WINDOW</source>
          <target state="translated">WINDOW</target>
        </trans-unit>
        <trans-unit id="7913945997a369e8ea6004dfc36b2844dceea418" translate="yes" xml:space="preserve">
          <source>WITH</source>
          <target state="translated">WITH</target>
        </trans-unit>
        <trans-unit id="9ced6ee9ff3324806557c62b472be54adbd37321" translate="yes" xml:space="preserve">
          <source>WITH clause</source>
          <target state="translated">WITH 절</target>
        </trans-unit>
        <trans-unit id="56fbadc8d9764a70500cf87f645a8260e6c6c396" translate="yes" xml:space="preserve">
          <source>WITHOUT</source>
          <target state="translated">WITHOUT</target>
        </trans-unit>
        <trans-unit id="80ce6a3273f099b101fd71e15344b4ac7f67fb42" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID is found only in SQLite and is not compatible with any other SQL database engine, as far as we know. In an elegant system, all tables would behave as WITHOUT ROWID tables even without the WITHOUT ROWID keyword. However, when SQLite was first designed, it used only integer &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowids&lt;/a&gt; for row keys to simplify the implementation. This approach worked well for many years. But as the demands on SQLite grew, the need for tables in which the PRIMARY KEY really did correspond to the underlying row key grew more acute. The WITHOUT ROWID concept was added in order to meet that need without breaking backwards compatibility with the billions of SQLite databases already in use at the time (circa 2013).</source>
          <target state="translated">WITHOUT ROWID는 SQLite에서만 찾을 수 있으며 우리가 아는 한 다른 SQL 데이터베이스 엔진과 호환되지 않습니다. 우아한 시스템에서는 WITHOUT ROWID 키워드가 없어도 모든 테이블이 WITHOUT ROWID 테이블로 작동합니다. 그러나 SQLite가 처음 설계되었을 때 구현을 단순화하기 위해 행 키에 정수 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 만 사용했습니다 . 이 접근법은 수년간 잘 작동했습니다. 그러나 SQLite에 대한 요구가 증가함에 따라 PRIMARY KEY가 실제로 기본 행 키에 해당하는 테이블의 필요성이 더욱 심각해졌습니다. WITHOUT ROWID 개념은 2013 년경 이미 사용중인 수십억 개의 SQLite 데이터베이스와의 호환성을 유지하면서 이러한 요구를 충족시키기 위해 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="468208bc9196912bc7723c91a3fae9cc04615357" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables will work correctly (that is to say, they provide the correct answer) for tables with a single INTEGER PRIMARY KEY. However, ordinary rowid tables will run faster in that case. Hence, it is good design to avoid creating WITHOUT ROWID tables with single-column PRIMARY KEYs of type INTEGER.</source>
          <target state="translated">WITHOUT ROWID 테이블은 단일 INTEGER PRIMARY KEY가있는 테이블에 대해 올바르게 작동합니다 (즉, 정답 제공). 그러나이 경우 일반 rowid 테이블이 더 빠르게 실행됩니다. 따라서 INTEGER 유형의 단일 컬럼 PRIMARY KEY로 WITHOUT ROWID 테이블을 작성하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a47008723e245eb9b8569a96c7a79d51a50cb56f" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID tables work best when individual rows are not too large. A good rule-of-thumb is that the average size of a single row in a WITHOUT ROWID table should be less than about 1/20th the size of a database page. That means that rows should not contain more than about 50 bytes each for a 1KiB page size or about 200 bytes each for 4KiB page size. WITHOUT ROWID tables will work (in the sense that they get the correct answer) for arbitrarily large rows - up to 2GB in size - but traditional rowid tables tend to work faster for large row sizes. This is because rowid tables are implemented as &lt;a href=&quot;fileformat2#btree&quot;&gt;B*-Trees&lt;/a&gt; where all content is stored in the leaves of the tree, whereas WITHOUT ROWID tables are implemented using ordinary B-Trees with content stored on both leaves and intermediate nodes. Storing content in intermediate nodes mean that each intermediate node entry takes up more space on the page and thus reduces the fan-out, increasing the search cost.</source>
          <target state="translated">WITHOUT ROWID 테이블은 개별 행이 너무 크지 않을 때 가장 잘 작동합니다. 좋은 규칙은 WITHOUT ROWID 테이블에서 단일 행의 평균 크기가 데이터베이스 페이지 크기의 약 1/20보다 작아야한다는 것입니다. 즉, 행은 1KiB 페이지 크기에 대해 각각 약 50 바이트를 초과하거나 4KiB 페이지 크기에 대해 각각 약 200 바이트를 포함해서는 안됩니다. ROWID가 없으면 최대 2GB 크기의 임의로 큰 행에 대해 (정답을 얻는다는 의미에서) 작동하지만 기존 rowid 테이블은 큰 행 크기에 더 빨리 작동하는 경향이 있습니다. rowid 테이블이 &lt;a href=&quot;fileformat2#btree&quot;&gt;B * -Tree&lt;/a&gt; 로 구현되기 때문입니다.ROWID 테이블 없이는 잎과 중간 노드 모두에 저장된 내용으로 일반 B- 트리를 사용하여 구현됩니다. 중간 노드에 컨텐츠를 저장하면 각 중간 노드 항목이 페이지에서 더 많은 공간을 차지하므로 팬 아웃이 줄어들어 검색 비용이 증가합니다.</target>
        </trans-unit>
        <trans-unit id="88d3b9ec414c3ffacd30f5fa1e3b51d5e7c1696c" translate="yes" xml:space="preserve">
          <source>WITHOUT ROWID virtual table</source>
          <target state="translated">ROWID 가상 테이블없이</target>
        </trans-unit>
        <trans-unit id="bff1c33df73d6a6c2b628488a2bcad9b0fe90c82" translate="yes" xml:space="preserve">
          <source>Wait for the rolled back changes to be written onto persistent storage. This protects the integrity of the database in case another power failure or crash occurs.</source>
          <target state="translated">롤백 된 변경 사항이 지속적 스토리지에 기록 될 때까지 기다리십시오. 이는 또 다른 정전 또는 충돌이 발생할 경우 데이터베이스의 무결성을 보호합니다.</target>
        </trans-unit>
        <trans-unit id="dd9635431d3610b419ecc620dedbc828ed50792c" translate="yes" xml:space="preserve">
          <source>Was generated by this script:</source>
          <target state="translated">이 스크립트에 의해 생성되었습니다 :</target>
        </trans-unit>
        <trans-unit id="637f65e1bae93912cb8bee734b406fd7ee161d5f" translate="yes" xml:space="preserve">
          <source>We also run SQLite using &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt; on Linux and verify that it detects no problems.</source>
          <target state="translated">또한 Linux에서 &lt;a href=&quot;http://valgrind.org&quot;&gt;Valgrind&lt;/a&gt; 를 사용하여 SQLite를 실행 하고 문제가 없는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2bac0ed4b37946dad20096d0b073432309bee989" translate="yes" xml:space="preserve">
          <source>We are aware of no other</source>
          <target state="translated">우리는 다른 것을 모른다</target>
        </trans-unit>
        <trans-unit id="c52eb400cd855fce10ed2a5a6e3b50ba60a61275" translate="yes" xml:space="preserve">
          <source>We are told that in some flash memory controllers the wear-leveling logic can cause random filesystem damage if power is interrupted during a write. This can manifest, for example, as random changes in the middle of a file that was not even open at the time of the power loss. So, for example, a device would be writing content into an MP3 file in flash memory when a power loss occurs, and that could result in an SQLite database being corrupted even though the database was not even in use at the time of the power loss.</source>
          <target state="translated">일부 플래시 메모리 컨트롤러에서는 쓰기 중에 전원이 차단되면웨어 레벨링 로직이 임의의 파일 시스템 손상을 일으킬 수 있다고합니다. 예를 들어, 파일이 손실 될 때 열리지 않은 파일 중간에 임의의 변경 사항이있는 것으로 나타날 수 있습니다. 예를 들어, 장치는 전원 손실이 발생할 때 플래시 메모리의 MP3 파일에 내용을 쓰게되며, 이로 인해 전원이 손실 될 때 데이터베이스를 사용하지 않아도 SQLite 데이터베이스가 손상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3cba495c2a4fa9e3aad438fbdcf0294c4dcb9df3" translate="yes" xml:space="preserve">
          <source>We assume that disk is written in chunks which we call a &quot;sector&quot;. It is not possible to modify any part of the disk smaller than a sector. To change a part of the disk smaller than a sector, you have to read in the full sector that contains the part you want to change, make the change, then write back out the complete sector.</source>
          <target state="translated">디스크가 &quot;섹터&quot;라고하는 청크로 작성되었다고 가정합니다. 섹터보다 작은 디스크 부분은 수정할 수 없습니다. 디스크의 한 부분을 섹터보다 작게 변경하려면 변경하려는 부분이 포함 된 전체 섹터를 읽고 변경 한 다음 전체 섹터를 다시 써야합니다.</target>
        </trans-unit>
        <trans-unit id="6dd2d15ae4f93de39a47cf41448e74b994733012" translate="yes" xml:space="preserve">
          <source>We begin with a problem that can be solved using a VDBE program that is only a few instructions long. Suppose we have an SQL table that was created like this:</source>
          <target state="translated">우리는 단지 몇 명령 길이 인 VDBE 프로그램을 사용하여 해결할 수있는 문제로 시작합니다. 다음과 같이 작성된 SQL 테이블이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="db9e6f9dd85fc9f8e31996438093b69f82ad2ed0" translate="yes" xml:space="preserve">
          <source>We begin with an overview of the steps SQLite takes in order to perform an atomic commit of a transaction against a single database file. The details of file formats used to guard against damage from power failures and techniques for performing an atomic commit across multiple databases are discussed in later sections.</source>
          <target state="translated">단일 데이터베이스 파일에 대해 트랜잭션의 원자 커밋을 수행하기 위해 SQLite가 수행하는 단계에 대한 개요로 시작합니다. 정전으로 인한 손상을 방지하는 데 사용되는 파일 형식 및 여러 데이터베이스에서 원자 커밋을 수행하는 기술에 대한 자세한 내용은 다음 섹션에서 설명합니다.</target>
        </trans-unit>
        <trans-unit id="38bf89df215372375d066b70f4b36998e95fafff" translate="yes" xml:space="preserve">
          <source>We believe that most modern disk drives implement atomic sector writes. When power is lost, the drive uses energy stored in capacitors and/or the angular momentum of the disk platter to provide power to complete any operation in progress. Nevertheless, there are so many layers in between the write system call and the on-board disk drive electronics that we take the safe approach in both Unix and w32 VFS implementations and assume that sector writes are not atomic. On the other hand, device manufacturers with more control over their filesystems might want to consider enabling the atomic write property of xDeviceCharacteristics if their hardware really does do atomic writes.</source>
          <target state="translated">우리는 대부분의 최신 디스크 드라이브가 원자 섹터 쓰기를 구현한다고 생각합니다. 전원이 손실되면 드라이브는 커패시터 및 / 또는 디스크 플래터의 각 운동량에 저장된 에너지를 사용하여 진행중인 작업을 완료하기위한 전원을 공급합니다. 그럼에도 불구하고 쓰기 시스템 호출과 온보드 디스크 드라이브 전자 장치 사이에는 매우 많은 계층이있어 Unix 및 w32 VFS 구현 모두에서 안전한 접근 방식을 취하며 섹터 쓰기가 원자 적이 지 않다고 가정합니다. 다른 한편으로, 파일 시스템을 더 잘 제어하는 ​​장치 제조업체는 하드웨어가 실제로 원자 쓰기를 수행하는 경우 xDeviceCharacteristics의 원자 쓰기 속성을 활성화하는 것을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="586e6ff48cacbcb2ddee486b19c44489728dbf7f" translate="yes" xml:space="preserve">
          <source>We call custom modifications to the SQLite source code that are held for the use of a single application a &quot;private branch&quot;. When a private branch becomes necessary, the application developer must take on the task of keeping the private branch in synchronization with the public SQLite sources. This is tedious. It can also be tricky, since while the SQLite file format and published interfaces are very stable, the internal implementation of SQLite changes quite rapidly. Hundreds or thousands of lines of code might change for any given SQLite point release.</source>
          <target state="translated">우리는 단일 애플리케이션의 &quot;개인 분기&quot;사용을 위해 유지되는 SQLite 소스 코드에 대한 사용자 정의 수정을 호출합니다. 개인 브랜치가 필요할 때 응용 프로그램 개발자는 개인 브랜치를 공개 SQLite 소스와 동기화하는 작업을 수행해야합니다. 이것은 지루합니다. SQLite 파일 형식과 게시 된 인터페이스는 매우 안정적이지만 SQLite의 내부 구현은 매우 빠르게 변경되므로 까다로울 수 있습니다. 주어진 SQLite 포인트 릴리스에 따라 수백 또는 수천 줄의 코드가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cfeb2a347fa38b180ceb6f0fe6a37a3de052a3a" translate="yes" xml:space="preserve">
          <source>We call this kind of index usage a &quot;skip-scan&quot; because the database engine is basically doing a full scan of the index but it optimizes the scan (making it less than &quot;full&quot;) by occasionally skipping ahead to the next candidate value.</source>
          <target state="translated">데이터베이스 엔진은 기본적으로 전체 인덱스 스캔을 수행하지만 때때로 다음 후보 값으로 건너 뛰어 스캔을 최적화합니다 ( &quot;전체&quot;보다 작음).</target>
        </trans-unit>
        <trans-unit id="d8c54ecc5dbd9d71e35248692355648775c7c06a" translate="yes" xml:space="preserve">
          <source>We can see the VDBE program that SQLite uses to implement this INSERT using the &lt;b&gt;sqlite&lt;/b&gt; command-line utility. First start up &lt;b&gt;sqlite&lt;/b&gt; on a new, empty database, then create the table. Next change the output format of &lt;b&gt;sqlite&lt;/b&gt; to a form that is designed to work with VDBE program dumps by entering the &quot;.explain&quot; command. Finally, enter the [INSERT] statement shown above, but precede the [INSERT] with the special keyword [EXPLAIN]. The [EXPLAIN] keyword will cause &lt;b&gt;sqlite&lt;/b&gt; to print the VDBE program rather than execute it. We have:</source>
          <target state="translated">SQLite가 &lt;b&gt;sqlite&lt;/b&gt; 명령 줄 유틸리티를 사용하여이 INSERT를 구현하는 데 사용하는 VDBE 프로그램을 볼 수 있습니다 . 먼저 비어있는 새 데이터베이스에서 &lt;b&gt;sqlite&lt;/b&gt; 를 시작한 다음 테이블을 작성하십시오. 그런 다음 &quot;.explain&quot;명령을 입력하여 &lt;b&gt;sqlite&lt;/b&gt; 의 출력 형식을 VDBE 프로그램 덤프와 함께 작동하도록 설계된 양식 으로 변경하십시오 . 마지막으로 위에 표시된 [INSERT] 문을 입력하되 [INSERT] 앞에 특수 키워드 [EXPLAIN]을 입력하십시오. [EXPLAIN] 키워드는 &lt;b&gt;sqlite&lt;/b&gt; 가 VDBE 프로그램을 실행하지 않고 인쇄하도록합니다. 우리는 :</target>
        </trans-unit>
        <trans-unit id="ec7be355019068bf92f7d741482fdf6ee1c56c3e" translate="yes" xml:space="preserve">
          <source>We can see the process in action in the following query:</source>
          <target state="translated">다음 쿼리에서 프로세스가 작동하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a73853b7ca854f99ebc56a8da7248062e4f92563" translate="yes" xml:space="preserve">
          <source>We deduce the following rules of thumb from the matrix above:</source>
          <target state="translated">위의 행렬에서 다음과 같은 경험 법칙을 추론합니다.</target>
        </trans-unit>
        <trans-unit id="84f5304369a052a144aa55c526df651c94e44de3" translate="yes" xml:space="preserve">
          <source>We emphasis that most applications are well-served by the built-in default implementations of the SQLite interface subsystems. Developers are encouraged to use the default built-in implementations whenever possible and to build SQLite without any special compile-time options or parameters. However, some highly specialized applications may benefit from substituting or modifying one or more of these built-in SQLite interface subsystems. Or, if SQLite is used on an operating system other than Unix (Linux or Mac OS X), Windows (Win32 or WinCE), or OS/2 then none of the interface subsystems that come built into SQLite will work and the application will need to provide alternative implementations suitable for the target platform.</source>
          <target state="translated">우리는 대부분의 응용 프로그램이 SQLite 인터페이스 하위 시스템의 기본 제공 기본 구현을 통해 잘 관리되고 있음을 강조합니다. 개발자는 가능하면 기본 내장 구현을 사용하고 특별한 컴파일 타임 옵션이나 매개 변수없이 SQLite를 빌드하는 것이 좋습니다. 그러나 일부 고도로 전문화 된 일부 응용 프로그램은 이러한 내장 SQLite 인터페이스 하위 시스템 중 하나 이상을 대체하거나 수정하면 도움이 될 수 있습니다. 또는 Unix (Linux 또는 Mac OS X), Windows (Win32 또는 WinCE) 또는 OS / 2 이외의 운영 체제에서 SQLite를 사용하는 경우 SQLite에 내장 된 인터페이스 하위 시스템이 작동하지 않아 응용 프로그램이 필요합니다. 대상 플랫폼에 적합한 대체 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6885829b70a7aa6d03abf4dbc376f359d84e8896" translate="yes" xml:space="preserve">
          <source>We emphasize again that these steps are not intended to be the only acceptable method for maintaining private branch. This approach is one of many. Use this document as a baseline for preparing project-specific procedures. Do not be afraid to experiment.</source>
          <target state="translated">우리는이 단계들이 개인 브랜치를 유지하기위한 유일한 방법이 아니라는 것을 다시 강조합니다. 이 접근법은 많은 것 중 하나입니다. 이 문서를 프로젝트 별 절차를 준비하기위한 기준으로 사용하십시오. 실험하는 것을 두려워하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="55e740e8153135385200d1c2a44c0a166232d431" translate="yes" xml:space="preserve">
          <source>We have received reports of implementations of both Windows network filesystems and NFS in which locking was subtly broken. We can not verify these reports, but as locking is difficult to get right on a network filesystem we have no reason to doubt them. You are advised to avoid using SQLite on a network filesystem in the first place, since performance will be slow. But if you must use a network filesystem to store SQLite database files, consider using a secondary locking mechanism to prevent simultaneous writes to the same database even if the native filesystem locking mechanism malfunctions.</source>
          <target state="translated">우리는 잠금이 미묘하게 손상된 Windows 네트워크 파일 시스템과 NFS의 구현에 대한 보고서를 받았습니다. 이러한 보고서를 확인할 수는 없지만 네트워크 파일 시스템에서 잠금을 제대로 수행하기가 어렵 기 때문에 의심 할 이유가 없습니다. 성능이 저하되므로 네트워크 파일 시스템에서 SQLite를 사용하지 않는 것이 좋습니다. 그러나 네트워크 파일 시스템을 사용하여 SQLite 데이터베이스 파일을 저장해야하는 경우 기본 파일 시스템 잠금 메커니즘이 오작동하는 경우에도 동일한 데이터베이스에 대한 동시 쓰기를 방지하기 위해 보조 잠금 메커니즘을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e3e45a07ed13dbd9549a67862a5bea3d84d72898" translate="yes" xml:space="preserve">
          <source>We have seen multiple cases where a file descriptor was open on a file, then that file descriptor was closed and reopened on an SQLite database. Later, some other thread continued to write into the old file descriptor, not realizing that the original file had been closed already. But because the file descriptor had been reopened by SQLite, the information that was intended to go into the original file ended up overwriting parts of the SQLite database, leading to corruption of the database.</source>
          <target state="translated">파일 디스크립터가 파일에서 열린 다음 SQLite 데이터베이스에서 해당 파일 디스크립터가 닫히고 다시 열린 경우가 여러 번있었습니다. 나중에 다른 스레드는 기존 파일 디스크립터에 계속 쓰면서 원래 파일이 이미 닫 혔음을 인식하지 못했습니다. 그러나 파일 설명자가 SQLite에 의해 다시 열렸 기 때문에 원본 파일로 보내려는 정보가 결국 SQLite 데이터베이스의 일부를 덮어 써서 데이터베이스가 손상되었습니다.</target>
        </trans-unit>
        <trans-unit id="776084395b585bc0c28bd248aca15b6e574ec177" translate="yes" xml:space="preserve">
          <source>We here restate and amplify the previous sentence for emphasis: All changes within a single transaction in SQLite either occur completely or not at all, even if the act of writing the change out to the disk is interrupted by</source>
          <target state="translated">우리는 여기서 강조하기 위해 이전 문장을 다시 말하고 강조합니다. SQLite의 단일 트랜잭션 내의 모든 변경 사항은 디스크에 변경 사항을 기록하는 작업이</target>
        </trans-unit>
        <trans-unit id="285d3238c6a1bf77e9e62067e7f260bf0b08d8c7" translate="yes" xml:space="preserve">
          <source>We know of no way to use the standard library printf() C interface to implement the &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf() SQL function&lt;/a&gt; feature of SQLite. The built-in printf() implementation can be easily adapted to that task, however.</source>
          <target state="translated">표준 라이브러리 printf () C 인터페이스를 사용하여 SQLite 의 &lt;a href=&quot;lang_corefunc#printf&quot;&gt;printf () SQL 함수&lt;/a&gt; 기능 을 구현할 방법이 없습니다 . 그러나 내장 된 printf () 구현은 해당 작업에 쉽게 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3b0138457bb49851f251d195b698d479cac5033" translate="yes" xml:space="preserve">
          <source>We make a distinction between a &quot;file format&quot; and an &quot;application format&quot;. A file format is used to store a single object. So, for example, a GIF or JPEG file stores a single image, and an XHTML file stores text, so those are &quot;file formats&quot; and not &quot;application formats&quot;. An EPUB file, in contrast, stores both text and images (as contained XHTML and GIF/JPEG files) and so it is considered an &quot;application format&quot;. This article is about &quot;application formats&quot;.</source>
          <target state="translated">&quot;파일 형식&quot;과 &quot;응용 프로그램 형식&quot;을 구별합니다. 파일 형식은 단일 객체를 저장하는 데 사용됩니다. 예를 들어 GIF 또는 JPEG 파일은 단일 이미지를 저장하고 XHTML 파일은 텍스트를 저장하므로 &quot;응용 프로그램 형식&quot;이 아닌 &quot;파일 형식&quot;입니다. 반대로 EPUB 파일은 텍스트와 이미지 (XHTML 및 GIF / JPEG 파일 포함)를 모두 저장하므로 &quot;응용 프로그램 형식&quot;으로 간주됩니다. 이 기사는 &quot;응용 프로그램 형식&quot;에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8909441e4d410050a1ceb2a957053ae17d1136a8" translate="yes" xml:space="preserve">
          <source>We propose to use the &lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;fossil software configuration management&lt;/a&gt; system to set up two branches. One branch (the &quot;public branch&quot; or &quot;trunk&quot;) contains the published SQLite sources and the other branch is the private branch which contains the code that is customized for the project. Whenever a new public release of SQLite is made, that release is added to the public branch and then the changes are merged into the private branch.</source>
          <target state="translated">&lt;a href=&quot;http://www.fossil-scm.org&quot;&gt;화석 소프트웨어 구성 관리&lt;/a&gt; 시스템을 사용하여 두 개의 지점을 설정 하도록 제안합니다 . 한 지점 ( &quot;공공 지점&quot;또는 &quot;트렁크&quot;)에는 게시 된 SQLite 소스가 포함되고 다른 지점에는 프로젝트에 맞게 사용자 지정된 코드가 포함 된 개인 지점이 있습니다. SQLite의 새 공개 릴리스가 작성 될 때마다 해당 릴리스가 공개 분기에 추가 된 다음 변경 사항이 개인 분기에 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="cdfe5941cfa327faeee1a3aa77e06f6d937ec10c" translate="yes" xml:space="preserve">
          <source>We say that a system has the powersafe overwrite property if the following statement is true:</source>
          <target state="translated">다음과 같은 경우 시스템에 전원 안전 덮어 쓰기 속성이 있다고합니다.</target>
        </trans-unit>
        <trans-unit id="5b1e50114d6654d737309df661bca3d508073d97" translate="yes" xml:space="preserve">
          <source>We say that algorithm-1 is &quot;faster&quot;, but this is not strictly true. Algorithm-1 is faster in common repositories, but it is possible to construct a repository in which every check-in is on a different uniquely-named branch and all check-ins are children of the root check-in. In that case, TAGXREF_I1 would become more selective than PLINK_I1 and algorithm-2 really would be the faster choice. However such repositories are very unlikely to appear in practice and so hard-coding the loop nested order using the CROSS JOIN syntax is a reasonable solution to the problem in this case.</source>
          <target state="translated">우리는 algorithm-1이 &quot;더 빠르다&quot;고 말하지만 이것은 사실이 아닙니다. 알고리즘 1은 공통 리포지토리에서 더 빠르지 만 모든 체크인이 고유 한 다른 이름의 브랜치에 있고 모든 체크인이 루트 체크인의 하위 인 리포지토리를 구성 할 수 있습니다. 이 경우 TAGXREF_I1이 PLINK_I1보다 선택성이 높아지고 알고리즘 -2가 실제로 더 빠른 선택입니다. 그러나 이러한 리포지토리는 실제로는 거의 나타나지 않으므로 CROSS JOIN 구문을 사용하여 루프 중첩 순서를 하드 코딩하는 것이이 경우 문제에 대한 합리적인 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="4ae339abf0ab672c65bdd6ccb60aabe5af32c503" translate="yes" xml:space="preserve">
          <source>We suspect that a common failure mode for SQLite recovery happens like this: A power failure occurs. After power is restored, a well-meaning user or system administrator begins looking around on the disk for damage. They see their database file named &quot;important.data&quot;. This file is perhaps familiar to them. But after the crash, there is also a hot journal named &quot;important.data-journal&quot;. The user then deletes the hot journal, thinking that they are helping to cleanup the system. We know of no way to prevent this other than user education.</source>
          <target state="translated">SQLite 복구에 대한 일반적인 실패 모드는 다음과 같이 발생합니다. 정전이 발생합니다. 전원이 복구되면 의미있는 사용자 나 시스템 관리자가 디스크를 살펴보고 손상이 있는지 확인합니다. 데이터베이스 파일 &quot;important.data&quot;가 표시됩니다. 이 파일은 아마도 익숙 할 것입니다. 그러나 충돌 후 &quot;important.data-journal&quot;이라는 인기 저널도 있습니다. 그런 다음 사용자는 시스템 정리에 도움이된다고 생각하면서 핫 저널을 삭제합니다. 우리는 사용자 교육 외에는 이것을 막을 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="00a0dbc2ebcd051c964b8bf428dbc0b4e94c1fd5" translate="yes" xml:space="preserve">
          <source>We want to know the twenty most recent ancestors in time (out of the thousands and thousands of ancestors in the whole DAG) for checkin &quot;@BASELINE&quot;. (A query similar to this is used by the &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS to show the N most recent ancestors of a check. For example: &lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&lt;/a&gt;.)</source>
          <target state="translated">&quot;@BASELINE&quot;을 체크인하기 위해 가장 최근의 20 명의 조상 (DAG 전체의 수천 및 수천 명의 조상 중)을 알고 싶습니다. (이와 유사한 쿼리는 &lt;a href=&quot;http://www.fossil-scm.org/&quot;&gt;Fossil&lt;/a&gt; VCS에서 가장 최근의 조상 수표를 표시하는 데 사용됩니다 ( 예 : &lt;a href=&quot;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30&quot;&gt;http://www.sqlite.org/src/timeline?p=trunk&amp;amp;n=30)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="351c0b2917fd27c07d1575c325d6c434bf485fe8" translate="yes" xml:space="preserve">
          <source>Website Keyword Index</source>
          <target state="translated">웹 사이트 키워드 색인</target>
        </trans-unit>
        <trans-unit id="856955a1acaac17d20fdfd7478c48b194daa4307" translate="yes" xml:space="preserve">
          <source>Well-commented source code with &lt;a href=&quot;testing#coverage&quot;&gt;100% branch test coverage&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#coverage&quot;&gt;100 % 분기 테스트 적용 범위를&lt;/a&gt; 갖춘 잘 작성된 소스 코드 .</target>
        </trans-unit>
        <trans-unit id="0fd93ad7c9151c213e1c81e636ad41e187dfdf3a" translate="yes" xml:space="preserve">
          <source>What If OpenDocument Used SQLite?</source>
          <target state="translated">OpenDocument에서 SQLite를 사용한 경우 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="d1c91decdb314d1f98700dd1bdf20618d03adb15" translate="yes" xml:space="preserve">
          <source>What Is An Application File Format?</source>
          <target state="translated">응용 프로그램 파일 형식이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8eafc9293497bf8d5a3b149b033e2c04c50289e4" translate="yes" xml:space="preserve">
          <source>What datatypes does SQLite support?</source>
          <target state="translated">SQLite는 어떤 데이터 유형을 지원합니까?</target>
        </trans-unit>
        <trans-unit id="7ca20dfb510b956d12b7de007ce4f96db962811f" translate="yes" xml:space="preserve">
          <source>What harm could come of that, you ask? The SQLite developers (including this author) wondered the same thing. But then security researchers pointed out that knowledge of pointers can help attackers to circumvent address-space randomization defenses. This is called a &quot;pointer leak&quot;. A pointer leak is not itself a vulnerability, but it can aid an attacker in effectively exploiting other vulnerabilities.</source>
          <target state="translated">어떤 피해를 입을 수 있습니까? SQLite 개발자 (이 저자 포함)도 같은 것을 궁금해했습니다. 그러나 보안 연구원들은 포인터에 대한 지식이 공격자들이 주소 공간 랜덤 화 방어를 우회하는 데 도움이 될 수 있다고 지적했다. 이것을 &quot;포인터 누출&quot;이라고합니다. 포인터 누출은 그 자체로는 취약점이 아니지만 공격자가 다른 취약점을 효과적으로 악용하는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09ddbcfffc504cb584adaf832caf679c81ed102d" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_CORRUPT error? What does it mean for the database to be &quot;malformed&quot;? Why am I getting this error?</source>
          <target state="translated">SQLITE_CORRUPT 오류는 무엇입니까? 데이터베이스가 &quot;잘못된&quot;다는 것은 무엇을 의미합니까? 이 오류가 발생하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e5264a2f32d0c974ba717f0941d074614666d5ea" translate="yes" xml:space="preserve">
          <source>What is an SQLITE_SCHEMA error, and why am I getting one?</source>
          <target state="translated">SQLITE_SCHEMA 오류는 무엇이며 왜 발생합니까?</target>
        </trans-unit>
        <trans-unit id="cb018b89b59e298a68db86ff80fc9eea140ccdd3" translate="yes" xml:space="preserve">
          <source>What is the Export Control Classification Number (ECCN) for SQLite?</source>
          <target state="translated">SQLite에 대한 ECCN (Export Control Classification Number)은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="61fca1595cf614e3a194bfd194191403183b57e8" translate="yes" xml:space="preserve">
          <source>What is the maximum size of a VARCHAR in SQLite?</source>
          <target state="translated">SQLite에서 VARCHAR의 최대 크기는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="e213b22ce22925686c52aad4a90dd069f0962434" translate="yes" xml:space="preserve">
          <source>What is the total size of all files in the archive whose names end in &quot;.h&quot; or &quot;.cpp&quot;?</source>
          <target state="translated">이름이 &quot;.h&quot;또는 &quot;.cpp&quot;로 끝나는 아카이브의 모든 파일의 총 크기는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="3888afad2b88cfc56a74bc460d038e108bfb5e98" translate="yes" xml:space="preserve">
          <source>What others say about Fossil and Git</source>
          <target state="translated">화석과 자식에 대한 다른 사람들의 의견</target>
        </trans-unit>
        <trans-unit id="f9f3ab382e9485e7278404c856bf161ccd6b2df4" translate="yes" xml:space="preserve">
          <source>What percentage of the files are compressed by less than 25%?</source>
          <target state="translated">파일의 몇 퍼센트가 25 % 미만으로 압축됩니까?</target>
        </trans-unit>
        <trans-unit id="b5461625f1011b3e4b6508b082fdfa963ef833c0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()는&lt;/a&gt; 성명을 준비하는 데 사용됩니다, 성명 동안 준비하여 다시 수 있습니다 &lt;a href=&quot;#sqlite3_step&quot;&gt;() sqlite3_step&lt;/a&gt; 인해 스키마 변경 될 수 있습니다. 따라서 응용 프로그램은 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 동안 올바른 권한 부 여자 콜백이 유지되도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="78fe376fe612030dba8e993e1e6346105acb51d4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA locking_mode=EXCLUSIVE&lt;/a&gt; (exclusive locking mode) is set, only a single client is allowed to have the database open at one time. Since only a single client can use the database, the shm file is omitted. The single client uses a buffer in heap memory as a substitute for the memory-mapped shm file.</source>
          <target state="translated">때 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;PRAGMA의 locking_mode = EXCLUSIVE&lt;/a&gt; (전용 잠금 모드)를 설정, 단 하나의 클라이언트는 한 번에 열려있는 데이터베이스를 가질 수있다. 단일 클라이언트 만 데이터베이스를 사용할 수 있으므로 shm 파일은 생략됩니다. 단일 클라이언트는 메모리 매핑 된 shm 파일 대신 힙 메모리의 버퍼를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9abb811ba43f82c87eea517150f407f49b9906ac" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; is used to prepare a statement, the statement might be re-prepared during &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; due to a schema change. Hence, the application should ensure that the correct authorizer callback remains in place during the &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()는&lt;/a&gt; 성명을 준비하는 데 사용됩니다, 성명 동안 준비하여 다시 수 있습니다 &lt;a href=&quot;step&quot;&gt;() sqlite3_step&lt;/a&gt; 인해 스키마 변경 될 수 있습니다. 따라서 응용 프로그램은 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 동안 올바른 권한 부 여자 콜백이 유지되도록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c3c4a10f39f154fb9afe1cc905a05f1b736c3877" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;uri&quot;&gt;URI filenames&lt;/a&gt; are used, the &quot;cache&quot; query parameter can be used to specify whether or not the database will use shared cache. Use &quot;cache=shared&quot; to enable shared cache and &quot;cache=private&quot; to disable shared cache. The ability to use URI query parameters to specify the cache sharing behavior of a database connection allows cache sharing to be controlled in &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; statements. For example:</source>
          <target state="translated">때 &lt;a href=&quot;uri&quot;&gt;URI 파일 이름이&lt;/a&gt; 사용은 &quot;캐시&quot;쿼리 매개 변수는 데이터베이스가 공유 캐시 사용 여부를 지정할 수 있습니다. &quot;cache = shared&quot;를 사용하여 공유 캐시를 활성화하고 &quot;cache = private&quot;을 사용하여 공유 캐시를 비활성화하십시오. URI 쿼리 매개 변수를 사용하여 데이터베이스 연결의 캐시 공유 동작을 지정하면 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 문 에서 캐시 공유를 제어 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0e9fc2254d872ac23aeae318057b6aa62d769dc" translate="yes" xml:space="preserve">
          <source>When &lt;b&gt;sqlite_step&lt;/b&gt; returns SQLITE_DONE or SQLITE_ERROR, the *pN and *pazColName values are set to the number of columns in the result set and to the names of the columns, just as they are for an SQLITE_ROW return. This allows the calling code to find the number of result columns and the column names and datatypes even if the result set is empty. The *pazValue parameter is always set to NULL when the return codes is SQLITE_DONE or SQLITE_ERROR. If the SQL being executed is a statement that does not return a result (such as an INSERT or an UPDATE) then *pN will be set to zero and *pazColName will be set to NULL.</source>
          <target state="translated">때 &lt;b&gt;sqlite_step의&lt;/b&gt; 반환 SQLITE_DONE 또는 SQLITE_ERROR는 * PN과 * pazColName 값은 그들이 SQLITE_ROW의 반환와 마찬가지로, 결과 집합 및 열 이름을 열 수로 설정됩니다. 결과 코드가 비어 있더라도 호출 코드는 결과 열 수와 열 이름 및 데이터 유형을 찾을 수 있습니다. 리턴 코드가 SQLITE_DONE 또는 SQLITE_ERROR 인 경우 * pazValue 매개 변수는 항상 NULL로 설정됩니다. 실행중인 SQL이 결과를 리턴하지 않는 명령문 (예 : INSERT 또는 UPDATE) 인 경우 * pN은 0으로 설정되고 * pazColName은 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a738765e6d76b084ca79459e28b3c9bfca412130" translate="yes" xml:space="preserve">
          <source>When I want to see what has been happening on SQLite (or any of about a dozen other projects that I work on) I visit the &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;timeline&lt;/a&gt; and in a single screen I can see a quick summary of all the latest changes, on all branches. In a few clicks, I can drill down to see as much detail as I want. I can even do this from a phone.</source>
          <target state="translated">SQLite (또는 작업중 인 약 12 ​​개의 다른 프로젝트 중 하나)에서 발생한 일을보고 싶을 때 &lt;a href=&quot;https://sqlite.org/src/timeline&quot;&gt;타임 라인을&lt;/a&gt; 방문하면 단일 화면에서 모든 지점의 모든 최신 변경 사항에 대한 빠른 요약을 볼 수 있습니다. 몇 번의 클릭으로 드릴 다운하여 원하는만큼 상세하게 볼 수 있습니다. 전화로도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3038431e6823ccdef12d1f539d0c61f30867d530" translate="yes" xml:space="preserve">
          <source>When RAISE(IGNORE) is called, the remainder of the current trigger program, the statement that caused the trigger program to execute and any subsequent trigger programs that would have been executed are abandoned. No database changes are rolled back. If the statement that caused the trigger program to execute is itself part of a trigger program, then that trigger program resumes execution at the beginning of the next step.</source>
          <target state="translated">RAISE (IGNORE)가 호출되면 나머지 현재 트리거 프로그램, 트리거 프로그램을 실행시킨 명령문 및 실행 된 후속 트리거 프로그램이 삭제됩니다. 데이터베이스 변경 사항이 롤백되지 않습니다. 트리거 프로그램을 실행시킨 명령문이 트리거 프로그램의 일부인 경우 해당 트리거 프로그램은 다음 단계 시작시 실행을 재개합니다.</target>
        </trans-unit>
        <trans-unit id="3b714e2ab0d85ccd85c4bb15bba20b0ece19aa26" translate="yes" xml:space="preserve">
          <source>When SQLITE_ENABLE_SORTER_REFERENCES is enabled, the records passed to the sorter often contain only a &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; value. Such records are much smaller. This means the sorter has much less &quot;payload&quot; to deal with and can run faster. After sorting has occurred, the ROWID is used to look up the output column values in the original table. That requires another search into the table, and could potentially result in a slowdown. Or, it might be a performance win, depending on how large the values are.</source>
          <target state="translated">SQLITE_ENABLE_SORTER_REFERENCES를 사용하면 분류기로 전달 된 레코드에 종종 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;ROWID&lt;/a&gt; 값만 포함됩니다 . 이러한 기록은 훨씬 작습니다. 이는 분류 기가 처리 할 &quot;페이로드&quot;가 훨씬 적고 더 빠르게 실행될 수 있음을 의미합니다. 정렬이 발생한 후 ROWID는 원래 테이블에서 출력 열 값을 찾는 데 사용됩니다. 이를 위해서는 테이블을 다시 검색해야하므로 속도가 느려질 수 있습니다. 또는 값의 크기에 따라 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22e2481654b7e499f20f0d8a14ccb29b23b47522" translate="yes" xml:space="preserve">
          <source>When SQLite calls the xTruncate() method, the cache must discard all existing cache entries with page numbers (keys) greater than or equal to the value of the iLimit parameter passed to xTruncate(). If any of these pages are pinned, they are implicitly unpinned, meaning that they can be safely discarded.</source>
          <target state="translated">SQLite가 xTruncate () 메소드를 호출 할 때, 캐시는 xTruncate ()에 전달 된 iLimit 매개 변수의 값보다 크거나 같은 페이지 번호 (키)를 가진 모든 기존 캐시 항목을 버려야합니다. 이러한 페이지 중 하나라도 고정되어 있으면 암시 적으로 고정 해제되어 안전하게 버릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35ff55b55b3144279fa7594a0e19885043618a48" translate="yes" xml:space="preserve">
          <source>When SQLite compares two strings, it uses a collating sequence or collating function (two words for the same thing) to determine which string is greater or if the two strings are equal. SQLite has three built-in collating functions: BINARY, NOCASE, and RTRIM.</source>
          <target state="translated">SQLite는 두 문자열을 비교할 때 데이터 정렬 시퀀스 또는 데이터 정렬 기능 (같은 항목에 대해 두 단어)을 사용하여 어느 문자열이 더 큰지 또는 두 문자열이 같은지 확인합니다. SQLite에는 BINARY, NOCASE 및 RTRIM의 세 가지 내장 조합 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="df3602b4706fda192f1a7fee5a1fd5a14d6046e0" translate="yes" xml:space="preserve">
          <source>When SQLite has been compiled with SQLITE_THREADSAFE=1 or SQLITE_THREADSAFE=2 then the &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; can be altered at run-time using the &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config()&lt;/a&gt; interface together with one of these verbs:</source>
          <target state="translated">SQLite가 SQLITE_THREADSAFE = 1 또는 SQLITE_THREADSAFE = 2로 컴파일되면 런타임 에 다음 동사 중 하나와 함께 &lt;a href=&quot;c3ref/config&quot;&gt;sqlite3_config ()&lt;/a&gt; 인터페이스를 사용하여 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="447f302ea851392a6eb166989220e6263326e6b8" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;#sqlite3_io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xSync () 메서드를 호출하면 이러한 정수 값의 조합을 두 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="68d87b5a5c9475d95e19a08651c92859f1a25fae" translate="yes" xml:space="preserve">
          <source>When SQLite invokes the xSync() method of an &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object it uses a combination of these integer values as the second argument.</source>
          <target state="translated">SQLite가 &lt;a href=&quot;io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; 객체 의 xSync () 메서드를 호출하면 이러한 정수 값의 조합을 두 번째 인수로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d35292160ae7a274b67325cfcd829f7632f2415b" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; compile-time option, extra &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; commands are available that are useful for debugging and for exploring the operation of the VDBE. For example the &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; pragma can be enabled to cause a disassembly of each VDBE opcode to be printed on standard output as the opcode is executed. These debugging pragmas include:</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 컴파일 타임 옵션으로 컴파일 되면 VDBE의 디버깅 및 탐색에 유용한 추가 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 명령을 사용할 수 있습니다. 예를 들어, &lt;a href=&quot;pragma#pragma_vdbe_trace&quot;&gt;vdbe_trace&lt;/a&gt; pragma는 opcode가 실행될 때 각 VDBE opcode의 디스 어셈블리가 표준 출력에 인쇄되도록 할 수 있습니다. 이러한 디버깅 실습에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c9b995e894f1bbf11af15b50811aafd3b796ef85" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; option, an alternative memory allocator that does not use malloc() is included in the build. The SQLite developers refer to this alternative memory allocator as &quot;memsys5&quot;. Even when it is included in the build, memsys5 is disabled by default. To enable memsys5, the application must invoke the following SQLite interface at start-time:</source>
          <target state="translated">SQLite가 &lt;a href=&quot;compile#enable_memsys5&quot;&gt;SQLITE_ENABLE_MEMSYS5&lt;/a&gt; 옵션으로 컴파일되면 malloc ()을 사용하지 않는 대체 메모리 할당자가 빌드에 포함됩니다. SQLite 개발자는이 대체 메모리 할당자를 &quot;memsys5&quot;라고합니다. 빌드에 포함되어 있어도 memsys5는 기본적으로 비활성화되어 있습니다. memsys5를 사용하려면 응용 프로그램이 시작시 다음 SQLite 인터페이스를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="84ef8ebae9f557b2e5ae28bc7ed5746f2af208db" translate="yes" xml:space="preserve">
          <source>When SQLite is compiled with the SQLITE_MUTEX_APPDEF=1 option, it completely omits the implementation of its &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt;. But the SQLite library still attempts to call these functions where necessary, so the application must itself implement the &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex primitive functions&lt;/a&gt; and link them together with SQLite.</source>
          <target state="translated">SQLite가 SQLITE_MUTEX_APPDEF = 1 옵션으로 컴파일되면 &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;mutex 기본 함수&lt;/a&gt; 의 구현이 완전히 생략 됩니다 . 그러나 SQLite 라이브러리는 여전히 필요한 경우 이러한 함수를 호출하려고 시도하므로 응용 프로그램 자체는 &lt;a href=&quot;c3ref/mutex_alloc&quot;&gt;뮤텍스 기본 함수를&lt;/a&gt; 구현하고 이들을 SQLite와 함께 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="7f137b8f0298a3c2c2e18d67228fddc4346fc04c" translate="yes" xml:space="preserve">
          <source>When SQLite is ported to new operating systems (operating systems other than Unix, Windows, and OS/2 for which ports are provided together with the core) two new functions, &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init()&lt;/a&gt; and &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end()&lt;/a&gt;, must be provided as part of the port.</source>
          <target state="translated">SQLite가 새로운 운영 체제 (포트가 코어와 함께 제공되는 Unix, Windows 및 OS / 2 이외의 운영 체제)로 이식 될 때 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_init ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/initialize&quot;&gt;sqlite3_os_end ()의&lt;/a&gt; 두 가지 새로운 기능 이 제공되어야합니다. 포트.</target>
        </trans-unit>
        <trans-unit id="07b5adba013870fc7dc891a2821a51ae6a59171f" translate="yes" xml:space="preserve">
          <source>When SQLite tries to access a file that is locked by another process, the default behavior is to return SQLITE_BUSY. You can adjust this behavior from C code using the &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler()&lt;/a&gt; or &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout()&lt;/a&gt; API functions.</source>
          <target state="translated">SQLite가 다른 프로세스에 의해 잠겨있는 파일에 액세스하려고하면 기본 동작은 SQLITE_BUSY를 반환하는 것입니다. &lt;a href=&quot;c3ref/busy_handler&quot;&gt;sqlite3_busy_handler ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/busy_timeout&quot;&gt;sqlite3_busy_timeout ()&lt;/a&gt; API 함수를 사용하여 C 코드에서이 동작을 조정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77327b5e49ebfcc1acf07f15eb4bc6a41abc04ea" translate="yes" xml:space="preserve">
          <source>When SQLite tries to open a database and finds that it is locked, it can optionally delay for a short while and try to open the file again. This process repeats until the query times out and SQLite returns a failure. The timeout is adjustable. It is set to 0 by default so that if the database is locked, the SQL statement fails immediately. But you can use the &quot;timeout&quot; method to change the timeout value to a positive number. For example:</source>
          <target state="translated">SQLite가 데이터베이스를 열려고 시도하고 잠겨있는 것을 발견하면 선택적으로 잠시 지연된 후 파일을 다시 열려고 시도 할 수 있습니다. 이 프로세스는 쿼리 시간이 초과되고 SQLite가 실패를 반환 할 때까지 반복됩니다. 타임 아웃은 조정 가능합니다. 데이터베이스가 잠겨 있으면 SQL 문이 즉시 실패하도록 기본적으로 0으로 설정됩니다. 그러나 &quot;timeout&quot;메소드를 사용하여 제한 시간 값을 양수로 변경할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a804ec7f0a4b84d1b0a408e0b54447cf6ce4d1f8" translate="yes" xml:space="preserve">
          <source>When SQLite version 2.7.0 or later opens a 2.6.3 or earlier database, it assumes all columns of all tables have type &quot;numeric&quot;. For 2.7.0 and later databases, columns have type &quot;text&quot; if their datatype string contains the substrings &quot;char&quot; or &quot;clob&quot; or &quot;blob&quot; or &quot;text&quot;. Otherwise they are of type &quot;numeric&quot;.</source>
          <target state="translated">SQLite 버전 2.7.0 이상에서 2.6.3 이전 데이터베이스를 열면 모든 테이블의 모든 열에 &quot;숫자&quot;유형이 있다고 가정합니다. 2.7.0 이상의 데이터베이스의 경우 데이터 유형 문자열에 &quot;char&quot;또는 &quot;clob&quot;또는 &quot;blob&quot;또는 &quot;text&quot;하위 문자열이 포함 된 경우 열의 유형은 &quot;text&quot;입니다. 그렇지 않으면 &quot;숫자&quot;유형입니다.</target>
        </trans-unit>
        <trans-unit id="a13408a2bfc81e3d04562db93d8a2fee6642da62" translate="yes" xml:space="preserve">
          <source>When SQLite was first being developed, Java was a young and immature language. C++ was older, but was undergoing such growing pains that it was difficult to find any two C++ compilers that worked the same way. So C was definitely a better choice back when SQLite was first being developed. The situation is less stark now, but there is little to no benefit in recoding SQLite at this point.</source>
          <target state="translated">SQLite가 처음 개발되었을 때 Java는 젊고 미숙 한 언어였습니다. C ++은 더 오래되었지만 같은 고통을 겪고있어 동일한 방식으로 작동하는 두 개의 C ++ 컴파일러를 찾기가 어려웠습니다. 따라서 SQLite가 처음 개발되었을 때 C는 확실히 더 나은 선택이었습니다. 현재 상황은 덜 뚜렷하지만이 시점에서 SQLite를 레코딩하는 데 아무런 이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd3d6234851cf7360a0faea15fc7c5c549469738" translate="yes" xml:space="preserve">
          <source>When a</source>
          <target state="translated">때</target>
        </trans-unit>
        <trans-unit id="b177e9320f32426fce848e5e150f059f226858de" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; or &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY&lt;/a&gt; constraint violation occurs, the REPLACE algorithm deletes pre-existing rows that are causing the constraint violation prior to inserting or updating the current row and the command continues executing normally. If a &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL&lt;/a&gt; constraint violation occurs, the REPLACE conflict resolution replaces the NULL value with the default value for that column, or if the column has no default value, then the ABORT algorithm is used. If a &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK constraint&lt;/a&gt; or &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; violation occurs, the REPLACE conflict resolution algorithm works like ABORT.</source>
          <target state="translated">때 &lt;a href=&quot;lang_createtable#uniqueconst&quot;&gt;UNIQUE&lt;/a&gt; 또는 &lt;a href=&quot;lang_createtable#primkeyconst&quot;&gt;PRIMARY KEY의&lt;/a&gt; 제약 위반이 발생의 삭제 알고리즘은 기존에 현재 행을 삽입하거나 업데이트하기 전에 구속 위반을 초래하고 명령이 정상적으로 실행을 계속 행을 교체한다. 경우 &lt;a href=&quot;lang_createtable#notnullconst&quot;&gt;NOT NULL의&lt;/a&gt; 제약 조건 위반이 발생하면 교체 분쟁 해결은 해당 컬럼에 대한 기본 값으로 NULL 값을 대체하거나 열이 기본값이없는 경우, 다음 ABORT 알고리즘이 사용됩니다. 경우 &lt;a href=&quot;lang_createtable#ckconst&quot;&gt;CHECK 제약 조건&lt;/a&gt; 또는 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 위반이 발생하면 ABORT 같은 충돌 해결 알고리즘 작품을 교체합니다.</target>
        </trans-unit>
        <trans-unit id="e40cfe4f4a2672a463b5e9153a546fd55dd2ffa8" translate="yes" xml:space="preserve">
          <source>When a UNIQUE constraint violation occurs, the pre-existing row that caused the constraint violation is removed prior to inserting or updating the current row. Thus the insert or update always occurs. The command continues executing normally. No error is returned.</source>
          <target state="translated">UNIQUE 제약 조건 위반이 발생하면 현재 행을 삽입하거나 업데이트하기 전에 제약 조건 위반을 일으킨 기존 행이 제거됩니다. 따라서 삽입 또는 업데이트가 항상 발생합니다. 명령이 계속 정상적으로 실행됩니다. 오류가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f0f8ec6207370b712331444906a15edac7bd9982" translate="yes" xml:space="preserve">
          <source>When a WAL mode database is in active use, all three of the above files usually exist. Except, the Wal-Index file is omitted if &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; is set.</source>
          <target state="translated">WAL 모드 데이터베이스가 사용중인 경우 위의 세 파일이 모두 존재합니다. &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드&lt;/a&gt; 가 설정된 경우 Wal-Index 파일은 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="88f7d29bc8b807cc4618404ebf6e68af0b14195c" translate="yes" xml:space="preserve">
          <source>When a blocking connection's transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="translated">차단 연결의 트랜잭션이 완료되면 잠금 해제 알림 콜백에 등록 된 차단 된 연결이 둘 이상있을 수 있습니다. 두 개 이상의 차단 된 연결이 동일한 콜백 함수를 지정한 경우 콜백 함수를 여러 번 호출하는 대신 차단 된 연결에 의해 지정된 void * 컨텍스트 포인터 집합을 배열로 함께 묶어 한 번 호출합니다. 이를 통해 애플리케이션은 차단되지 않은 데이터베이스 연결 집합과 관련된 모든 작업의 ​​우선 순위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eda8b145f23c6a0bb85ff0a12c0706d7475482c1" translate="yes" xml:space="preserve">
          <source>When a blocking connections transaction is concluded, there may be more than one blocked connection that has registered for an unlock-notify callback. If two or more such blocked connections have specified the same callback function, then instead of invoking the callback function multiple times, it is invoked once with the set of void* context pointers specified by the blocked connections bundled together into an array. This gives the application an opportunity to prioritize any actions related to the set of unblocked database connections.</source>
          <target state="translated">연결 차단 트랜잭션이 완료되면 잠금 해제 알림 콜백에 등록 된 둘 이상의 차단 된 연결이있을 수 있습니다. 이러한 차단 된 두 개 이상의 연결에서 동일한 콜백 함수를 지정한 경우 콜백 함수를 여러 번 호출하는 대신 차단 된 연결에 의해 지정된 void * 컨텍스트 포인터 세트가 배열로 묶여 호출됩니다. 이를 통해 응용 프로그램은 차단되지 않은 데이터베이스 연결 집합과 관련된 작업의 우선 순위를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1623124138a1a453c5d32a837bf66762d013ccd" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 호출이 SQLITE_LOCKED를 리턴 하면 sqlite3_unlock_notify () 를 호출하는 것이 거의 항상 적절합니다. 그러나 한 가지 예외가 있습니다. &quot;DROP TABLE&quot;또는 &quot;DROP INDEX&quot;문을 실행할 때 SQLite는 동일한 연결에 속하는 현재 실행중인 SELECT 문이 있는지 확인합니다. 있으면 SQLITE_LOCKED가 리턴됩니다. 이 경우 &quot;연결 차단&quot;이 없으므로 sqlite3_unlock_notify ()를 호출하면 unlock-notify 콜백이 즉시 호출됩니다. 그런 다음 응용 프로그램이 &quot;DROP TABLE&quot;또는 &quot;DROP INDEX&quot;쿼리를 다시 시도하면 무한 루프가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96fd9fb18740d68a037d0a53dc8f7e543ce5815d" translate="yes" xml:space="preserve">
          <source>When a call to &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED, it is almost always appropriate to call sqlite3_unlock_notify(). There is however, one exception. When executing a &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; statement, SQLite checks if there are any currently executing SELECT statements that belong to the same connection. If there are, SQLITE_LOCKED is returned. In this case there is no &quot;blocking connection&quot;, so invoking sqlite3_unlock_notify() results in the unlock-notify callback being invoked immediately. If the application then re-attempts the &quot;DROP TABLE&quot; or &quot;DROP INDEX&quot; query, an infinite loop might be the result.</source>
          <target state="translated">&lt;a href=&quot;step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 호출이 SQLITE_LOCKED를 리턴 하면 sqlite3_unlock_notify () 를 호출하는 것이 거의 항상 적절합니다. 그러나 한 가지 예외가 있습니다. &quot;DROP TABLE&quot;또는 &quot;DROP INDEX&quot;문을 실행할 때 SQLite는 동일한 연결에 속하는 현재 실행중인 SELECT 문이 있는지 확인합니다. 있으면 SQLITE_LOCKED가 리턴됩니다. 이 경우 &quot;연결 차단&quot;이 없으므로 sqlite3_unlock_notify ()를 호출하면 unlock-notify 콜백이 즉시 호출됩니다. 그런 다음 응용 프로그램이 &quot;DROP TABLE&quot;또는 &quot;DROP INDEX&quot;쿼리를 다시 시도하면 무한 루프가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b27c6df7f370b95df53fb6af6deaef3ac0ea82c" translate="yes" xml:space="preserve">
          <source>When a changeset or patchset is applied to a database, an attempt is made to insert a new row for each INSERT change, remove a row for each DELETE change and modify a row for each UPDATE change. If the target database is in the same state as the original database that the changeset was recorded on, this is a simple matter. However, if the contents of the target database is not in exactly this state, conflicts can occur when applying the changeset or patchset.</source>
          <target state="translated">변경 세트 또는 패치 세트가 데이터베이스에 적용되면 각 INSERT 변경에 대해 새 행을 삽입하고 각 DELETE 변경에 대한 행을 제거하고 각 UPDATE 변경에 대한 행을 수정하려고 시도합니다. 대상 데이터베이스가 변경 세트가 기록 된 원래 데이터베이스와 동일한 상태 인 경우 이는 간단한 문제입니다. 그러나 대상 데이터베이스의 내용이이 상태가 아닌 경우 변경 세트 또는 패치 세트를 적용 할 때 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af13c24a93516a02da3d5819b6d5ee382b394c0c" translate="yes" xml:space="preserve">
          <source>When a checkpoint runs, if it sees a lock on WAL_READ_LOCK(N), then it must not move WAL content into the main database for more than the first read-mark[N] frames. Were it to do so, it would overwrite content that the process holding the lock was expecting to be able to read out of the main database file. A consequence of if this is that f the WAL file contains more than read-mark[N] frames (if mxFrame&amp;gt;read-mark[N] for any read-mark for which WAL_READ_LOCK(N) is held by another process), then the checkpoint cannot run to completion.</source>
          <target state="translated">검사 점이 실행될 때 WAL_READ_LOCK (N)에서 잠금이 발견되면 WAL 내용을 첫 번째 읽기 표시 [N] 프레임 이상 동안 주 데이터베이스로 이동해서는 안됩니다. 그렇게하려면 잠금을 보유한 프로세스가 기본 데이터베이스 파일을 읽을 수있을 것으로 예상 한 내용을 덮어 씁니다. 이것이 WAL 파일에 read-mark [N] 프레임 이상을 포함하는 경우 (WAL_READ_LOCK (N)이 다른 프로세스에 의해 유지되는 모든 read-mark에 대해 mxFrame&amp;gt; read-mark [N] 인 경우)의 결과 검사 점이 완료 될 때까지 실행할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="483ce2f4112b751479cd3313b5725fa8eedbb3fc" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">구성 옵션이 설정되면 sqlite3_config ()는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . 옵션을 알 수 없거나 SQLite가 옵션을 설정할 수없는 경우이 루틴은 0이 아닌 &lt;a href=&quot;rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="42a829c41f1de7dff832e7bd4aea25619f81edf9" translate="yes" xml:space="preserve">
          <source>When a configuration option is set, sqlite3_config() returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;. If the option is unknown or SQLite is unable to set the option then this routine returns a non-zero &lt;a href=&quot;../rescode&quot;&gt;error code&lt;/a&gt;.</source>
          <target state="translated">구성 옵션이 설정되면 sqlite3_config ()는 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴합니다 . 옵션을 알 수 없거나 SQLite가 옵션을 설정할 수없는 경우이 루틴은 0이 아닌 &lt;a href=&quot;../rescode&quot;&gt;오류 코드를&lt;/a&gt; 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="5ec6b6ac63fbc35d1df0b3e9fb9cdbeeef10333e" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="translated">연결 (차단 된 연결이라고 함)이 공유 캐시 잠금을 얻지 못하고 SQLITE_LOCKED가 호출자에게 반환되면 필요한 리소스를 잠근 데이터베이스 연결 (차단 연결)의 ID가 내부적으로 저장됩니다. 애플리케이션이 SQLITE_LOCKED 오류를 수신 한 후 차단 된 연결 핸들을 첫 번째 인수로 사용하여 sqlite3_unlock_notify () 메서드를 호출하여 차단 연결 현재 트랜잭션이 종료 될 때 호출 될 콜백에 등록 할 수 있습니다. 콜백은 차단 연결의 트랜잭션을 종료하는 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; 호출 내에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="8a34b978574691e0c575f3f24ebbf266179b4d2f" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">연결 (차단 된 연결이라고 함)이 공유 캐시 잠금을 확보하지 못하고 SQLITE_LOCKED가 호출자에게 리턴되면 필요한 자원을 잠근 데이터베이스 연결 (차단 연결)의 ID가 내부적으로 저장됩니다. 응용 프로그램이 SQLITE_LOCKED 오류를 수신 한 후, 연결 차단 현재 트랜잭션이 종료 될 때 호출 될 콜백을 등록하기위한 첫 번째 인수로 차단 된 연결 핸들을 사용하여 sqlite3_unlock_notify () 메소드를 호출 할 수 있습니다. 콜백은 차단 연결 트랜잭션을 종료하는 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step&lt;/a&gt; 또는 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close&lt;/a&gt; 호출 내에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="58820b450842a3b35138dd7706fb343d060de1de" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connection's transaction.</source>
          <target state="translated">연결 (차단 된 연결이라고 함)이 공유 캐시 잠금을 얻지 못하고 SQLITE_LOCKED가 호출자에게 반환되면 필요한 리소스를 잠근 데이터베이스 연결 (차단 연결)의 ID가 내부적으로 저장됩니다. 애플리케이션이 SQLITE_LOCKED 오류를 수신 한 후 차단 된 연결 핸들을 첫 번째 인수로 사용하여 sqlite3_unlock_notify () 메서드를 호출하여 차단 연결 현재 트랜잭션이 종료 될 때 호출 될 콜백에 등록 할 수 있습니다. 콜백은 차단 연결의 트랜잭션을 종료하는 &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; 또는 &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; 호출 내에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7b71c21ec59e3320b31da28e6f5087ad7dce22a" translate="yes" xml:space="preserve">
          <source>When a connection (known as the blocked connection) fails to obtain a shared-cache lock and SQLITE_LOCKED is returned to the caller, the identity of the database connection (the blocking connection) that has locked the required resource is stored internally. After an application receives an SQLITE_LOCKED error, it may call the sqlite3_unlock_notify() method with the blocked connection handle as the first argument to register for a callback that will be invoked when the blocking connections current transaction is concluded. The callback is invoked from within the &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; or &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; call that concludes the blocking connections transaction.</source>
          <target state="translated">연결 (차단 된 연결이라고 함)이 공유 캐시 잠금을 확보하지 못하고 SQLITE_LOCKED가 호출자에게 리턴되면 필요한 자원을 잠근 데이터베이스 연결 (차단 연결)의 ID가 내부적으로 저장됩니다. 응용 프로그램이 SQLITE_LOCKED 오류를 수신 한 후, 연결 차단 현재 트랜잭션이 종료 될 때 호출 될 콜백을 등록하기위한 첫 번째 인수로 차단 된 연결 핸들을 사용하여 sqlite3_unlock_notify () 메소드를 호출 할 수 있습니다. 콜백은 차단 연결 트랜잭션을 종료하는 &lt;a href=&quot;step&quot;&gt;sqlite3_step&lt;/a&gt; 또는 &lt;a href=&quot;close&quot;&gt;sqlite3_close&lt;/a&gt; 호출 내에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d95de74c44ccc79daba549c33cfe91ac9ee60b3" translate="yes" xml:space="preserve">
          <source>When a connection holds a shared lock on WAL_READ_LOCK(N), that is a promise by the connection that it will use the WAL and not the database file for any database pages that are modified by the first read-mark[N] entries in the WAL. The read-mark[0] is always zero. If a connection holds a shared lock on WAL_READ_LOCK(0), that means the connection expects to be able to ignore the WAL and read any content it wants from the main database. If N&amp;gt;0 then the connection is free to use more of the WAL file beyond read-mark[N] if it wants to, up to the first mxFrame frames. But when a connection holds a shared lock on WAL_READ_LOCK(0), that is a promise that it will never read content from the WAL and will acquire all content directly from the main database.</source>
          <target state="translated">연결이 WAL_READ_LOCK (N)에 공유 잠금을 보유하면 연결의 첫 번째 읽기 표시 [N] 항목으로 수정 된 데이터베이스 페이지에 대해 데이터베이스 파일이 아닌 WAL을 사용한다는 약속입니다. WAL. 판독 마크 [0]은 항상 0입니다. 연결에 WAL_READ_LOCK (0)에 공유 잠금이 있으면 연결은 WAL을 무시하고 기본 데이터베이스에서 원하는 내용을 읽을 수 있어야합니다. N&amp;gt; 0이면 연결은 원한다면 read-mark [N] 이외의 WAL 파일을 최대 mxFrame 프레임까지 자유롭게 사용할 수 있습니다. 그러나 연결이 WAL_READ_LOCK (0)에 공유 잠금을 보유하면 WAL에서 내용을 읽지 않고 주 데이터베이스에서 직접 모든 내용을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e114c32681a6d0ab6fee9545fa50582f6c054845" translate="yes" xml:space="preserve">
          <source>When a connection is holding a SHARED lock on the main database, that will prevent any other connection from acquiring the EXCLUSIVE lock, which in turn prevents the WAL-index and WAL files from being deleted out from under other users, and prevents a transition out of WAL-mode while other users are accessing the database in WAL-mode.</source>
          <target state="translated">연결이 주 데이터베이스에서 SHARED 잠금을 보유하면 다른 연결이 독점 잠금을 획득하지 못하게되어 WAL- 인덱스 및 WAL 파일이 다른 사용자에서 삭제되는 것을 방지하고 전환이 방지됩니다. 다른 사용자가 WAL 모드로 데이터베이스에 액세스하는 동안 WAL 모드</target>
        </trans-unit>
        <trans-unit id="12c1255cc9a16f21fccefe2ac6a059ed783c7d20" translate="yes" xml:space="preserve">
          <source>When a connection using asynchronous IO begins a database transaction, the database is locked immediately. However the lock is not released until after all relevant operations in the write-queue have been flushed to disk. This means (for example) that the database may remain locked for some time after a &quot;&lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt;&quot; or &quot;&lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;&quot; is issued.</source>
          <target state="translated">비동기 IO를 사용한 연결이 데이터베이스 트랜잭션을 시작하면 데이터베이스가 즉시 잠 깁니다. 그러나 쓰기 큐의 모든 관련 작업이 디스크로 플러시 될 때까지 잠금이 해제되지 않습니다. 예를 들어, &quot; &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; &quot;또는 &quot; &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt; &quot;이 발행 된 후 데이터베이스가 일정 시간 동안 잠겨있는 상태를 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddb7b3f482852f424ece2e0896d73a04a9d957e4" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, an immediate ROLLBACK occurs, thus ending the current transaction, and the command aborts with a return code of SQLITE_CONSTRAINT. If no transaction is active (other than the implied transaction that is created on every command) then this algorithm works the same as ABORT.</source>
          <target state="translated">제한 조건 위반이 발생하면 즉시 ROLLBACK이 발생하여 현재 트랜잭션이 종료되고 명령이 리턴 코드 SQLITE_CONSTRAINT와 함께 중단됩니다. 활성화 된 트랜잭션이없는 경우 (모든 명령에서 작성된 암시 적 트랜잭션 제외)이 알고리즘은 ABORT와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="933e3d0ae1663c35b2ff70117a98cacf0e4923d6" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command aborts with a return code SQLITE_CONSTRAINT. But any changes to the database that the command made prior to encountering the constraint violation are preserved and are not backed out. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but change to rows 100 and beyond never occur.</source>
          <target state="translated">제한 조건 위반이 발생하면 명령은 리턴 코드 SQLITE_CONSTRAINT와 함께 중단됩니다. 그러나 제한 조건 위반이 발생하기 전에 명령이 수행 한 데이터베이스의 모든 변경 사항은 유지되며 제거되지 않습니다. 예를 들어, UPDATE 문이 갱신하려고하는 100 번째 행에서 제한 조건 위반을 발견 한 경우, 처음 99 개의 행 변경 사항은 보존되지만 행 100 이상의 변경 사항은 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6397f8d4479c4b84e08676c10c54e0afd51f843f" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the command backs out any prior changes it might have made and aborts with a return code of SQLITE_CONSTRAINT. But no ROLLBACK is executed so changes from prior commands within the same transaction are preserved. This is the default behavior for SQLite.</source>
          <target state="translated">제한 조건 위반이 발생하면 명령은 이전 변경 사항을 취소하고 리턴 코드 SQLITE_CONSTRAINT와 함께 중단됩니다. 그러나 ROLLBACK이 실행되지 않으므로 동일한 트랜잭션 내에서 이전 명령의 변경 사항이 유지됩니다. 이것이 SQLite의 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="39dcfeb5298d9a69a9dfd10b897e4e703da8e46b" translate="yes" xml:space="preserve">
          <source>When a constraint violation occurs, the one row that contains the constraint violation is not inserted or changed. But the command continues executing normally. Other rows before and after the row that contained the constraint violation continue to be inserted or updated normally. No error is returned.</source>
          <target state="translated">제한 조건 위반이 발생하면 제한 조건 위반이 포함 된 하나의 행이 삽입되거나 변경되지 않습니다. 그러나 명령은 계속 정상적으로 실행됩니다. 제약 조건 위반이 포함 된 행 전후의 다른 행은 계속 정상적으로 삽입 또는 업데이트됩니다. 오류가 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d77ac0a4b71596448d90ef0386a9797d90b3dad6" translate="yes" xml:space="preserve">
          <source>When a database connection closes (via &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close()&lt;/a&gt; or &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2()&lt;/a&gt;), an attempt is made to acquire SQLITE_LOCK_EXCLUSIVE. If this attempt is successful, that means the connection that is closing is the last connection to the database. In that case, it is desirable to clean up the WAL and WAL-index files, so the closing connection runs a &lt;a href=&quot;wal#ckpt&quot;&gt;checkpoint&lt;/a&gt; (while holding SQLITE_LOCK_EXCLUSIVE) and the deletes both the WAL and WAL-index files. The SQLITE_LOCK_EXCLUSIVE is not released until after both the WAL and WAL-index files have been deleted.</source>
          <target state="translated">&lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/close&quot;&gt;sqlite3_close_v2 ()&lt;/a&gt; 를 통해 데이터베이스 연결이 닫히면 SQLITE_LOCK_EXCLUSIVE를 얻으려고 시도합니다. 이 시도가 성공하면 닫는 연결이 데이터베이스에 대한 마지막 연결임을 의미합니다. 이 경우 WAL 및 WAL 색인 파일을 정리하는 것이 바람직하므로 연결 종료시 &lt;a href=&quot;wal#ckpt&quot;&gt;체크 포인트&lt;/a&gt; 가 실행되고 (SQLITE_LOCK_EXCLUSIVE를 유지하면서) WAL 및 WAL 색인 파일이 모두 삭제됩니다. SQLITE_LOCK_EXCLUSIVE는 WAL 및 WAL 색인 파일이 모두 삭제 될 때까지 해제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="20a6ff534ce9652a9eda05b6d0935e6cf08856e6" translate="yes" xml:space="preserve">
          <source>When a directory is inserted, if the &quot;name&quot; value does not end with a '/' character, the zipfile module appends one. This is necessary for compatibility with other programs (most notably &quot;info-zip&quot;) that manipulate zip archives.</source>
          <target state="translated">디렉토리가 삽입 될 때 &quot;name&quot;값이 '/'문자로 끝나지 않으면 zipfile 모듈이 디렉토리를 추가합니다. 이것은 zip 아카이브를 조작하는 다른 프로그램 (주로 &quot;info-zip&quot;)과의 호환성을 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="26801f7dad030d0d12374b8b8d55040830791b46" translate="yes" xml:space="preserve">
          <source>When a file-handle open on a database file is unlocked, if the</source>
          <target state="translated">데이터베이스 파일에서 열린 파일 핸들이 잠금 해제 된 경우</target>
        </trans-unit>
        <trans-unit id="70b05b0c4ad89d4e7f94cf5e4dedf4b6997bc209" translate="yes" xml:space="preserve">
          <source>When a function uses a column from a virtual table as its first argument, this method is called to see if the virtual table would like to overload the function. The first three parameters are inputs: the virtual table, the number of arguments to the function, and the name of the function. If no overloading is desired, this method returns 0. To overload the function, this method writes the new function implementation into *pxFunc and writes user data into *ppArg and returns either 1 or a number between &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; and 255.</source>
          <target state="translated">함수가 가상 테이블의 열을 첫 번째 인수로 사용하는 경우이 메서드는 가상 테이블이 함수를 오버로드 할 것인지 확인하기 위해 호출됩니다. 처음 세 개의 매개 변수는 가상 테이블, 함수에 대한 인수 수 및 함수 이름입니다. 오버로드를 원하지 않으면이 메소드는 0을 리턴합니다. 함수를 오버로드하기 위해이 메소드는 새 함수 구현을 * pxFunc에 기록하고 사용자 데이터를 * ppArg에 기록하고 1 또는 &lt;a href=&quot;c3ref/c_index_constraint_eq&quot;&gt;SQLITE_INDEX_CONSTRAINT_FUNCTION&lt;/a&gt; 과 255 사이의 숫자를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="8365620f1c717c4826d64a41ab8d38dd2fc7b98d" translate="yes" xml:space="preserve">
          <source>When a new</source>
          <target state="translated">새로운 때</target>
        </trans-unit>
        <trans-unit id="699fe2196c054a2761ad370d04849c2f40137718" translate="yes" xml:space="preserve">
          <source>When a new database is created, SQLite assigns a page size to the database based on platform and filesystem. For many years, the default page size was almost always 1024 bytes, but beginning with SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;version 3.12.0&lt;/a&gt; (2016-03-29), the default page size increased to 4096. The default page size is recommended for most applications.</source>
          <target state="translated">새 데이터베이스가 작성되면 SQLite는 플랫폼 및 파일 시스템을 기반으로 페이지 크기를 데이터베이스에 지정합니다. 몇 년 동안 기본 페이지 크기는 거의 항상 1024 바이트이지만 SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_12_0.html&quot;&gt;버전 3.12.0&lt;/a&gt; (2016-03-29)부터 기본 페이지 크기가 4096으로 증가했습니다. 기본 페이지 크기는 대부분의 응용 프로그램에 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="45fd9923f092fbfb6768ecc3efe603fb1851939b" translate="yes" xml:space="preserve">
          <source>When a new database page is appended to a database file, there is no requirement to add a record to the</source>
          <target state="translated">새 데이터베이스 페이지가 데이터베이스 파일에 추가되면 레코드를 추가 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b08473c5ea155814010ebff8331980504b3653e4" translate="yes" xml:space="preserve">
          <source>When a new file is created, most desktop operating systems (Windows, Linux, Mac OS X) will not actually write anything to disk. The new file is created in the operating systems disk cache only. The file is not created on mass storage until sometime later, when the operating system has a spare moment. This creates the impression to users that I/O is happening much faster than is possible when doing real disk I/O. We illustrate this idea in the diagram to the right by showing that the new rollback journal appears in the operating system disk cache only and not on the disk itself.</source>
          <target state="translated">새 파일을 만들면 대부분의 데스크톱 운영 체제 (Windows, Linux, Mac OS X)는 실제로 디스크에 아무것도 쓰지 않습니다. 새 파일은 운영 체제 디스크 캐시에만 작성됩니다. 운영 체제에 여유 시간이있을 때까지 언젠가는 파일이 대용량 저장 영역에 작성되지 않습니다. 이는 실제 디스크 I / O를 수행 할 때보 다 I / O가 훨씬 더 빠르게 발생한다는 인상을줍니다. 새로운 롤백 저널이 운영 체제 디스크 캐시에만 나타나고 디스크 자체에는 나타나지 않음을 보여줌으로써 오른쪽 다이어그램에서이 아이디어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="0a07f6d8079bf577cb3fe5588a8b9770dc9fc5d1" translate="yes" xml:space="preserve">
          <source>When a new row is inserted into an SQLite table, the ROWID can either be specified as part of the INSERT statement or it can be assigned automatically by the database engine. To specify a ROWID manually, just include it in the list of values to be inserted. For example:</source>
          <target state="translated">새 행이 SQLite 테이블에 삽입되면 ROWID를 INSERT 문의 일부로 지정하거나 데이터베이스 엔진에 의해 자동으로 지정 될 수 있습니다. ROWID를 수동으로 지정하려면 삽입 할 값 목록에 포함하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f0ce235c557e884c10fe9cff8d86b46112c91c8" translate="yes" xml:space="preserve">
          <source>When a process wants to change a database file (and it is not in &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; mode), it first records the original unchanged database content in a &lt;em&gt;rollback journal&lt;/em&gt;. The rollback journal is an ordinary disk file that is always located in the same directory or folder as the database file and has the same name as the database file with the addition of a &lt;code&gt;-journal&lt;/code&gt; suffix. The rollback journal also records the initial size of the database so that if the database file grows it can be truncated back to its original size on a rollback.</source>
          <target state="translated">프로세스가 데이터베이스 파일을 변경하려고 할 때 (그리고 &lt;a href=&quot;wal&quot;&gt;WAL&lt;/a&gt; 모드 가 아닌 경우 ), 원래 변경되지 않은 원래 데이터베이스 컨텐츠를 &lt;em&gt;롤백 저널&lt;/em&gt; 에 기록합니다 . 롤백 저널은 항상 데이터베이스 파일과 동일한 디렉토리 또는 폴더에 있으며 &lt;code&gt;-journal&lt;/code&gt; 접미 부가 추가 된 데이터베이스 파일과 이름이 같은 일반 디스크 파일입니다 . 롤백 저널은 데이터베이스의 초기 크기도 기록하므로 데이터베이스 파일이 커지면 롤백에서 원래 크기로 다시 절단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bd80d03aa6d2b960c4978ddc8751bef460c3fb0" translate="yes" xml:space="preserve">
          <source>When a process wants to read from a database file, it followed the following sequence of steps:</source>
          <target state="translated">프로세스가 데이터베이스 파일에서 읽으려고 할 때 다음 단계의 순서를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="577306227dff9ce8975b3fcaaa51b9a6b5656983" translate="yes" xml:space="preserve">
          <source>When a read operation begins on a WAL-mode database, it first remembers the location of the last valid commit record in the WAL. Call this point the &quot;end mark&quot;. Because the WAL can be growing and adding new commit records while various readers connect to the database, each reader can potentially have its own end mark. But for any particular reader, the end mark is unchanged for the duration of the transaction, thus ensuring that a single read transaction only sees the database content as it existed at a single point in time.</source>
          <target state="translated">읽기 작업이 WAL 모드 데이터베이스에서 시작되면 먼저 WAL에서 마지막으로 유효한 커밋 레코드의 위치를 ​​기억합니다. 이 지점을 &quot;엔드 마크&quot;라고합니다. 다양한 독자가 데이터베이스에 연결하는 동안 WAL이 커지고 새 커밋 레코드를 추가 할 수 있으므로 각 독자는 고유 한 종료 표시를 가질 수 있습니다. 그러나 특정 판독기의 경우 트랜잭션 기간 동안 종료 표시가 변경되지 않으므로 단일 읽기 트랜잭션은 단일 시점에 존재하는 데이터베이스 내용 만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c0dd2ac1af5d6880101af98898ac515a0c331fe" translate="yes" xml:space="preserve">
          <source>When a reader needs a page of content, it first checks the WAL to see if that page appears there, and if so it pulls in the last copy of the page that occurs in the WAL prior to the reader's end mark. If no copy of the page exists in the WAL prior to the reader's end mark, then the page is read from the original database file. Readers can exist in separate processes, so to avoid forcing every reader to scan the entire WAL looking for pages (the WAL file can grow to multiple megabytes, depending on how often checkpoints are run), a data structure called the &quot;wal-index&quot; is maintained in shared memory which helps readers locate pages in the WAL quickly and with a minimum of I/O. The wal-index greatly improves the performance of readers, but the use of shared memory means that all readers must exist on the same machine. This is why the write-ahead log implementation will not work on a network filesystem.</source>
          <target state="translated">독자가 콘텐츠 페이지를 필요로하는 경우, 먼저 WAL을 검사하여 해당 페이지가 해당 페이지에 나타나는지 확인하고, 그렇다면 WAL에서 발생한 페이지의 마지막 사본을 리더의 종료 표시 전에 가져옵니다. 독자의 종료 표시 이전에 WAL에 페이지 사본이 없으면 원래 데이터베이스 파일에서 페이지를 읽습니다. 독자는 별도의 프로세스로 존재할 수 있으므로 모든 독자가 페이지를 찾는 전체 WAL을 스캔하지 않도록합니다 (WAL 파일은 검사 점 실행 빈도에 따라 여러 메가 바이트로 증가 할 수 있음). &quot;wal-index&quot;라는 데이터 구조 공유 메모리에 유지되므로 독자는 WAL에서 페이지를 빠르고 최소한의 I / O로 찾을 수 있습니다. wal-index는 판독기의 성능을 크게 향상 시키지만 공유 메모리를 사용하면 모든 판독기가 동일한 시스템에 있어야합니다.이것이 미리 쓰기 로그 구현이 네트워크 파일 시스템에서 작동하지 않는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="730f5bd701321fbbb693ce5b184d905999894efe" translate="yes" xml:space="preserve">
          <source>When a row is deleted from an external content FTS4 table, FTS4 needs to retrieve the column values of the row being deleted from the content table. This is so that FTS4 can update the full-text index entries for each token that occurs within the deleted row to indicate that row has been deleted. If the content table row cannot be found, or if it contains values inconsistent with the contents of the FTS index, the results can be difficult to predict. The FTS index may be left containing entries corresponding to the deleted row, which can lead to seemingly nonsensical results being returned by subsequent SELECT queries. The same applies when a row is updated, as internally an UPDATE is the same as a DELETE followed by an INSERT.</source>
          <target state="translated">외부 컨텐츠 FTS4 테이블에서 행이 삭제되면 FTS4는 컨텐츠 테이블에서 삭제중인 행의 열 값을 검색해야합니다. 이는 FTS4가 삭제 된 행 내에서 발생하는 각 토큰에 대한 전체 텍스트 인덱스 항목을 업데이트하여 행이 삭제되었음을 나타냅니다. 컨텐츠 테이블 행을 찾을 수 없거나 FTS 인덱스의 컨텐츠와 일치하지 않는 값이 포함 된 경우 결과를 예측하기가 어려울 수 있습니다. FTS 인덱스에는 삭제 된 행에 해당하는 항목이 포함되어있을 수 있으며, 이로 인해 후속 SELECT 쿼리에서 넌센스없는 결과가 반환 될 수 있습니다. 내부적으로 UPDATE가 DELETE와 동일하고 INSERT와 같이 행이 업데이트 될 때도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5bdbf38f9947ad2a93dddd10975fb895dc64e45" translate="yes" xml:space="preserve">
          <source>When a schema change occurs that requires a prepared statement to be reparsed and reprepared, that event is logged with the error code SQLITE_SCHEMA. The reparse and reprepare is normally automatic (assuming that &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; has been used to prepared the statements originally, which is recommended) and so these logging events are normally the only way to know that reprepares are taking place.</source>
          <target state="translated">준비된 명령문을 재분석하고 다시 준비해야하는 스키마 변경이 발생하면 해당 이벤트는 오류 코드 SQLITE_SCHEMA와 함께 기록됩니다. 재분석 및 재 작성은 일반적으로 자동이며 ( &lt;a href=&quot;c3ref/prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 가 원래 명령문을 준비하는 데 사용 되었다고 가정 할 때 권장 됨), 이러한 로깅 이벤트는 일반적으로 재 준비가 진행되고 있음을 알 수있는 유일한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="19333c5294fb7ef73ead50d971608427e5e277b4" translate="yes" xml:space="preserve">
          <source>When a search request occurs and pending documents are indexed for the first time, the ftsdocs table must be updated by setting the idxed column to true and also filling in several other columns with information pertinent to the search. That other information is obtained from a join. The query is this:</source>
          <target state="translated">검색 요청이 발생하고 보류중인 문서가 처음으로 색인화되는 경우, idxed 열을 true로 설정하고 검색과 관련된 정보로 다른 여러 열을 채워서 ftsdocs 테이블을 업데이트해야합니다. 다른 정보는 조인에서 가져옵니다. 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a34c7922c5247a2a858115497a487644ed495d8" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">세션 객체가 비활성화되면 ( &lt;a href=&quot;#sqlite3session_enable&quot;&gt;sqlite3session_enable ()&lt;/a&gt; API 참조) 행을 삽입, 업데이트 또는 삭제할 때 레코드를 누적하지 않습니다. 세션 중에 단일 행을 두 번 이상 쓰면 반 직관적 인 효과가있는 것처럼 보일 수 있습니다. 예를 들어, 세션 객체가 활성화 된 상태에서 행이 삽입 된 후 동일한 세션 객체가 비활성화 된 상태에서 나중에 삭제되면 세션이 비활성화 된 동안 삭제가 발생하더라도 변경 세트에 INSERT 레코드가 나타나지 않습니다. 또는 세션이 비활성화 된 상태에서 행의 한 필드가 업데이트되고 세션이 활성화 된 동안 동일한 행의 다른 필드가 업데이트되면 결과 변경 집합에 두 필드를 모두 업데이트하는 UPDATE 변경 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4f45d6d9d609e68af4097ec8d881bf58ab9f2d1b" translate="yes" xml:space="preserve">
          <source>When a session object is disabled (see the &lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable()&lt;/a&gt; API), it does not accumulate records when rows are inserted, updated or deleted. This may appear to have some counter-intuitive effects if a single row is written to more than once during a session. For example, if a row is inserted while a session object is enabled, then later deleted while the same session object is disabled, no INSERT record will appear in the changeset, even though the delete took place while the session was disabled. Or, if one field of a row is updated while a session is disabled, and another field of the same row is updated while the session is enabled, the resulting changeset will contain an UPDATE change that updates both fields.</source>
          <target state="translated">세션 객체가 비활성화되면 ( &lt;a href=&quot;sqlite3session_enable&quot;&gt;sqlite3session_enable ()&lt;/a&gt; API 참조) 행을 삽입, 업데이트 또는 삭제할 때 레코드를 누적하지 않습니다. 세션 중에 단일 행을 두 번 이상 쓰면 반 직관적 인 효과가있는 것처럼 보일 수 있습니다. 예를 들어, 세션 객체가 활성화 된 상태에서 행이 삽입 된 후 동일한 세션 객체가 비활성화 된 상태에서 나중에 삭제되면 세션이 비활성화 된 동안 삭제가 발생하더라도 변경 세트에 INSERT 레코드가 나타나지 않습니다. 또는 세션이 비활성화 된 상태에서 행의 한 필드가 업데이트되고 세션이 활성화 된 동안 동일한 행의 다른 필드가 업데이트되면 결과 변경 집합에 두 필드를 모두 업데이트하는 UPDATE 변경 내용이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0c5e9130632720140f5680108f22eb0b1e949a18" translate="yes" xml:space="preserve">
          <source>When a string containing SQL statements is to be evaluated it is first sent to the tokenizer. The tokenizer breaks the SQL text into tokens and hands those tokens one by one to the parser. The tokenizer is hand-coded in the file</source>
          <target state="translated">SQL 문이 포함 된 문자열을 평가할 때는 먼저 토크 나이저로 전송됩니다. 토크 나이 저는 SQL 텍스트를 토큰으로 나누고 해당 토큰을 파서에 하나씩 전달합니다. 토크 나이 저는 파일에 직접 코딩되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="784cd84ee25201af9adae4be302f69e70ce7fa77" translate="yes" xml:space="preserve">
          <source>When a subquery is implemented as a co-routine, byte-code is generated to implement the subquery as if it were a standalone query, except instead of returning rows of results back to the application, the co-routine yields control back to the caller after each row is computed. The caller can then use that one computed row as part of its computation, then invoke the co-routine again when it is ready for the next row.</source>
          <target state="translated">서브 쿼리가 코 루틴으로 구현 될 때, 서브 행을 독립형 쿼리 인 것처럼 서브 쿼리를 구현하기 위해 바이트 코드가 생성됩니다. 단, 결과 행을 애플리케이션으로 다시 리턴하는 대신 코 루틴은 제어를 호출자에게 다시 리턴합니다. 각 행이 계산 된 후 그러면 호출자는 하나의 계산 된 행을 계산의 일부로 사용하고 다음 행에 대한 준비가되면 코 루틴을 다시 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de44a27c9eba79e888eaebdda88d807698edb9ba" translate="yes" xml:space="preserve">
          <source>When a subquery occurs in the FROM clause of a SELECT, the simplest behavior is to evaluate the subquery into a transient table, then run the outer SELECT against the transient table. But such a plan can be suboptimal since the transient table will not have any indices and the outer query (which is likely a join) will be forced to do a full table scan on the transient table.</source>
          <target state="translated">하위 쿼리가 SELECT의 FROM 절에서 발생할 때 가장 간단한 동작은 하위 쿼리를 임시 테이블로 평가 한 다음 임시 테이블에 대해 외부 SELECT를 실행하는 것입니다. 그러나 임시 테이블에는 인덱스가없고 외부 쿼리 (조인일 수 있음)가 임시 테이블에서 전체 테이블 스캔을 수행해야하므로 이러한 계획은 차선책 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e127ffb4e1dc5538bc1d8c98212bc64075d04dc4" translate="yes" xml:space="preserve">
          <source>When a users query on the FTS table requires a column value other than docid, FTS attempts to read the requested value from the corresponding column of the row in the content table with a rowid value equal to the current FTS docid. Only the subset of content-table columns duplicated in the FTS/34 table declaration can be queried for - to retrieve values from any other columns the content table must be queried directly. Or, if such a row cannot be found in the content table, a NULL value is used instead. For example:</source>
          <target state="translated">FTS 테이블의 사용자 쿼리에 docid 이외의 열 값이 필요한 경우 FTS는 콘텐츠 테이블에있는 행의 해당 열에서 현재 FTS docid와 동일한 rowid 값으로 요청 된 값을 읽으려고합니다. FTS / 34 테이블 선언에 복제 된 컨텐트 테이블 열의 하위 집합 만 쿼리 할 수 ​​있습니다. 컨텐트 테이블을 직접 쿼리해야하는 다른 열에서 값을 검색 할 수 있습니다. 또는 컨텐츠 테이블에서 이러한 행을 찾을 수없는 경우 NULL 값이 대신 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="923cfb28292cf33d9bcc64415e1180bd974cc8fa" translate="yes" xml:space="preserve">
          <source>When a writer is ready to commit its changes, it executes the following steps:</source>
          <target state="translated">기록기가 변경 내용을 커밋 할 준비가되면 다음 단계를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="90c74b5a55e525d529484d187152a575e9bdd449" translate="yes" xml:space="preserve">
          <source>When a writer wants to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt;, it must ensure that there are no locks on WAL_READ_LOCK(N) for N&amp;gt;0 because such locks indicate that some other connection is still using the current WAL file and a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; would delete content out from those other connections. It is ok for a &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL reset&lt;/a&gt; to occur if other connections are holding WAL_READ_LOCK(0) because by holding WAL_READ_LOCK(0), those other connections are promising not to use any content from the WAL.</source>
          <target state="translated">작성자가 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL&lt;/a&gt; 을 재설정 하려는 경우 N&amp;gt; 0에 대해 WAL_READ_LOCK (N)에 잠금이 없는지 확인해야합니다. 이러한 잠금은 다른 연결이 여전히 현재 WAL 파일을 사용하고 있으며 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL 재설정&lt;/a&gt; 이 다른 연결. A에 대한 그것은 괜찮 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL 재설정&lt;/a&gt; 다른 연결이 WAL_READ_LOCK (0)를 개최하여 WAL_READ_LOCK (0) 때문에 유지하는 경우, 그 다른 연결이 WAL의 모든 콘텐츠를 사용하지 유망 발생.</target>
        </trans-unit>
        <trans-unit id="7d5748b3589eba141bc319d180f2ba5724a213ca" translate="yes" xml:space="preserve">
          <source>When all of the recommended compile-time options above are used, the SQLite library will be approximately 3% smaller and use about 5% fewer CPU cycles. So these options do not make a huge difference. But in some design situations, every little bit helps.</source>
          <target state="translated">위의 권장 컴파일 시간 옵션을 모두 사용하면 SQLite 라이브러리가 약 3 % 작아지고 CPU주기는 약 5 % 줄어 듭니다. 따라서 이러한 옵션은 큰 차이가 없습니다. 그러나 일부 디자인 상황에서는 약간의 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="07429870ba57300bd363c85117e03fbff3fb9b62" translate="yes" xml:space="preserve">
          <source>When all processing is complete, &lt;b&gt;sqlite_step&lt;/b&gt; will return either SQLITE_DONE or SQLITE_ERROR. SQLITE_DONE indicates that the statement completed successfully and SQLITE_ERROR indicates that there was a run-time error. (The details of the error are obtained from &lt;b&gt;sqlite_finalize&lt;/b&gt;.) It is a misuse of the library to attempt to call &lt;b&gt;sqlite_step&lt;/b&gt; again after it has returned SQLITE_DONE or SQLITE_ERROR.</source>
          <target state="translated">모든 처리가 완료되면 &lt;b&gt;sqlite_step&lt;/b&gt; 은 SQLITE_DONE 또는 SQLITE_ERROR를 리턴합니다. SQLITE_DONE은 명령문이 성공적으로 완료되었음을 나타내고 SQLITE_ERROR는 런타임 오류가 있음을 나타냅니다. (오류의 세부 사항은 &lt;b&gt;sqlite_finalize&lt;/b&gt; 에서 &lt;b&gt;확보&lt;/b&gt; 됩니다.) SQLITE_DONE 또는 SQLITE_ERROR를 리턴 한 후 &lt;b&gt;sqlite_step을&lt;/b&gt; 다시 호출하려고 시도하는 것은 라이브러리의 오용입니다 .</target>
        </trans-unit>
        <trans-unit id="9464a70b807f00dabcb5c4da75acd44d0a619fea" translate="yes" xml:space="preserve">
          <source>When all the INSERTs are put in a transaction, SQLite no longer has to close and reopen the database or invalidate its cache between each statement. It also does not have to do any fsync()s until the very end. When unshackled in this way, SQLite is much faster than either PostgreSQL and MySQL.</source>
          <target state="translated">모든 INSERT를 트랜잭션에 넣을 때 SQLite는 더 이상 데이터베이스를 닫았다가 다시 열거 나 각 문 사이에서 캐시를 무효화 할 필요가 없습니다. 또한 끝날 때까지 fsync ()를 수행하지 않아도됩니다. 이런 식으로 해킹되지 않으면 SQLite는 PostgreSQL 및 MySQL보다 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="83a11d4701cb9320d2bf4587af27d26604be7f83" translate="yes" xml:space="preserve">
          <source>When an FTS table accumulates 16 b-tree segments at the same level, the next INSERT into that table will cause all 16 segments to be merged into a single b-tree segment at the next higher level. The effect of these level merges is that most INSERTs into an FTS table are very fast and take minimal memory, but an occasional INSERT is slow and generates a large transaction because of the need to do merging. This results in &quot;spiky&quot; performance of INSERTs.</source>
          <target state="translated">FTS 테이블이 동일한 레벨에서 16 개의 b- 트리 세그먼트를 누적하면 해당 테이블에 대한 다음 INSERT는 16 개의 모든 세그먼트가 다음 상위 레벨의 단일 b- 트리 세그먼트로 병합되도록합니다. 이러한 수준 병합의 효과는 FTS 테이블에 대한 대부분의 INSERT가 매우 빠르며 최소한의 메모리를 사용하지만 가끔 INSERT가 느리고 병합 할 필요로 인해 큰 트랜잭션을 생성한다는 것입니다. 이로 인해 INSERT의 &quot;뾰족한&quot;성능이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c3b65790b6c542323caaa50e227caf3d370e16fb" translate="yes" xml:space="preserve">
          <source>When an FTS5 table uses the custom tokenizer, the FTS5 core calls xCreate() once to create a tokenizer, then xTokenize() zero or more times to tokenize strings, then xDelete() to free any resources allocated by xCreate(). More specifically:</source>
          <target state="translated">FTS5 테이블이 사용자 정의 토크 나이저를 사용하는 경우 FTS5 코어는 xCreate ()를 한 번 호출하여 토크 나이저를 생성 한 다음 xTokenize ()를 0 회 이상 문자열 화하고 xDelete ()를 사용하여 xCreate ()에 의해 할당 된 모든 리소스를 해제합니다. 더 구체적으로:</target>
        </trans-unit>
        <trans-unit id="09202e860e734da0abbd632a5204a2fbedb299ae" translate="yes" xml:space="preserve">
          <source>When an FTS5 virtual table is created in a database, between 3 and 5 real tables are created in the database. These are known as &quot;&lt;a href=&quot;vtab#xshadowname&quot;&gt;shadow tables&lt;/a&gt;&quot;, and are used by the virtual table module to store persistent data. They should not be accessed directly by the user. Many other virtual table modules, including &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; and &lt;a href=&quot;rtree&quot;&gt;rtree&lt;/a&gt;, also create and use shadow tables.</source>
          <target state="translated">FTS5 가상 테이블이 데이터베이스에 생성 될 때 데이터베이스에 3 ~ 5 개의 실제 테이블이 생성됩니다. 이것을 &quot; &lt;a href=&quot;vtab#xshadowname&quot;&gt;새도우 테이블&lt;/a&gt; &quot;이라고하며 가상 테이블 모듈에서 지속적 데이터를 저장하는 데 사용됩니다. 사용자가 직접 액세스해서는 안됩니다. &lt;a href=&quot;fts3&quot;&gt;FTS3&lt;/a&gt; 및 &lt;a href=&quot;rtree&quot;&gt;rtree를&lt;/a&gt; 포함한 다른 많은 가상 테이블 모듈 도 새도우 테이블을 작성하고 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a38c7dc316e7e37718537bdea61961f91a6e323" translate="yes" xml:space="preserve">
          <source>When an SQL program is submitted to SQLite, the first step is to split the source text into &quot;tokens&quot;. A token might be:</source>
          <target state="translated">SQL 프로그램이 SQLite에 제출 될 때 첫 번째 단계는 소스 텍스트를 &quot;토큰&quot;으로 분할하는 것입니다. 토큰은 다음과 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b898f19b28eed6509a35351ba88f244733f8458f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ABORT resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and backs out any changes made by the current SQL statement; but changes caused by prior SQL statements within the same transaction are preserved and the transaction remains active. This is the default behavior and the behavior specified by the SQL standard.</source>
          <target state="translated">적용 가능한 제한 조건 위반이 발생하면 ABORT 분석 알고리즘은 현재 SQL 문을 SQLITE_CONSTRAINT 오류와 함께 중단하고 현재 SQL 문의 변경 사항을 취소합니다. 그러나 동일한 트랜잭션 내에서 이전 SQL 문으로 인한 변경 사항은 유지되며 트랜잭션은 활성 상태로 유지됩니다. 이것이 기본 동작이며 SQL 표준에서 지정한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="58bad3c331711aff15946bd280d303d43eef796f" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the FAIL resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error. But the FAIL resolution does not back out prior changes of the SQL statement that failed nor does it end the transaction. For example, if an UPDATE statement encountered a constraint violation on the 100th row that it attempts to update, then the first 99 row changes are preserved but changes to rows 100 and beyond never occur.</source>
          <target state="translated">적용 가능한 제한 조건 위반이 발생하면 FAIL 분석 알고리즘이 SQLITE_CONSTRAINT 오류와 함께 현재 SQL 문을 중단합니다. 그러나 FAIL 분석은 실패한 SQL 문의 이전 변경 사항을 취소하거나 트랜잭션을 종료하지 않습니다. 예를 들어, UPDATE 문이 갱신하려고하는 100 번째 행에서 제한 조건 위반이 발생하면 처음 99 개의 행 변경 사항은 보존되지만 행 100 이상의 변경 사항은 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b4aa81c65115bc42996b729bd361c5c8fafeff0" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the IGNORE resolution algorithm skips the one row that contains the constraint violation and continues processing subsequent rows of the SQL statement as if nothing went wrong. Other rows before and after the row that contained the constraint violation are inserted or updated normally. No error is returned for uniqueness, NOT NULL, and UNIQUE constraint errors when the IGNORE conflict resolution algorithm is used. However, the IGNORE conflict resolution algorithm works like ABORT for &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraint&lt;/a&gt; errors.</source>
          <target state="translated">적용 가능한 제한 조건 위반이 발생하면 IGNORE 분석 알고리즘은 제한 조건 위반이 포함 된 하나의 행을 건너 뛰고 아무 일도없는 것처럼 SQL 문의 후속 행을 계속 처리합니다. 제약 조건 위반이 포함 된 행 앞뒤의 다른 행은 정상적으로 삽입되거나 업데이트됩니다. IGNORE 충돌 해결 알고리즘을 사용할 때 고유성, NOT NULL 및 UNIQUE 제약 조건 오류에 대해서는 오류가 반환되지 않습니다. 그러나 IGNORE 충돌 해결 알고리즘은 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건&lt;/a&gt; 오류의 경우 ABORT와 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="a5ad08c0ccf1a58d1c588bdc448e26465adfe8be" translate="yes" xml:space="preserve">
          <source>When an applicable constraint violation occurs, the ROLLBACK resolution algorithm aborts the current SQL statement with an SQLITE_CONSTRAINT error and rolls back the current transaction. If no transaction is active (other than the implied transaction that is created on every command) then the ROLLBACK resolution algorithm works the same as the ABORT algorithm.</source>
          <target state="translated">적용 가능한 제한 조건 위반이 발생하면 ROLLBACK 분석 알고리즘이 SQLITE_CONSTRAINT 오류와 함께 현재 SQL 문을 중단하고 현재 트랜잭션을 롤백합니다. 활성화 된 트랜잭션이없는 경우 (모든 명령에서 작성된 암시 적 트랜잭션 이외의 경우) ROLLBACK 분석 알고리즘은 ABORT 알고리즘과 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="df9a570011a02f30ad10c7c02dfbae7f79c1d8bc" translate="yes" xml:space="preserve">
          <source>When an attempt is made to read the 100 byte</source>
          <target state="translated">100 바이트를 읽으려고 할 때</target>
        </trans-unit>
        <trans-unit id="e571fd87d73f16df54e68558314d212f85e9756b" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 은 자세한 &lt;a href=&quot;rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 중 하나를 반환 합니다. 레거시 동작은 &lt;a href=&quot;#sqlite3_step&quot;&gt;sqlite3_step ()&lt;/a&gt; 은 일반 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_ERROR&lt;/a&gt; 결과 코드 만 반환 하고 응용 프로그램은 &lt;a href=&quot;#sqlite3_reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 두 번 호출 하여 문제의 근본 원인을 찾아야한다는 것입니다. &quot;v2&quot;인터페이스 준비를 사용하면 오류의 기본 원인이 즉시 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="ccab92f3619cb54ee4858ee94848a4ee81189c29" translate="yes" xml:space="preserve">
          <source>When an error occurs, &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; will return one of the detailed &lt;a href=&quot;../rescode&quot;&gt;error codes&lt;/a&gt; or &lt;a href=&quot;../rescode#extrc&quot;&gt;extended error codes&lt;/a&gt;. The legacy behavior was that &lt;a href=&quot;step&quot;&gt;sqlite3_step()&lt;/a&gt; would only return a generic &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; result code and the application would have to make a second call to &lt;a href=&quot;reset&quot;&gt;sqlite3_reset()&lt;/a&gt; in order to find the underlying cause of the problem. With the &quot;v2&quot; prepare interfaces, the underlying reason for the error is returned immediately.</source>
          <target state="translated">오류가 발생하면 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 은 자세한 &lt;a href=&quot;../rescode&quot;&gt;오류 코드&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#extrc&quot;&gt;확장 오류 코드&lt;/a&gt; 중 하나를 반환 합니다. 레거시 동작은 &lt;a href=&quot;step&quot;&gt;sqlite3_step ()&lt;/a&gt; 은 일반 &lt;a href=&quot;../rescode#error&quot;&gt;SQLITE_ERROR&lt;/a&gt; 결과 코드 만 반환 하고 응용 프로그램은 &lt;a href=&quot;reset&quot;&gt;sqlite3_reset ()&lt;/a&gt; 을 두 번 호출 하여 문제의 근본 원인을 찾아야한다는 것입니다. &quot;v2&quot;인터페이스 준비를 사용하면 오류의 기본 원인이 즉시 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5d56e138a3f9cc682aa13f997335180c0fb3034f" translate="yes" xml:space="preserve">
          <source>When an expression is a simple reference to a column of a real table (not a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or subquery) then the expression has the same affinity as the table column.</source>
          <target state="translated">표현식이 실제 테이블의 열 ( &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; 또는 하위 쿼리가 아님)에 대한 간단한 참조 인 경우 표현식은 테이블 열과 동일한 선호도를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6e0bc34d56cd507e6524dea6d88364c2053501fb" translate="yes" xml:space="preserve">
          <source>When an in-memory database is named in this way, it will only share its cache with another connection that uses exactly the same name.</source>
          <target state="translated">메모리 내 데이터베이스의 이름이 이런 방식으로 지정되면 정확히 동일한 이름을 사용하는 다른 연결과 캐시를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="a4bc24ec2391f7a4a80ebd40d7eacec7ec5836a6" translate="yes" xml:space="preserve">
          <source>When an index contains all of the data needed for a query and when the original table never needs to be consulted, we call that index a &quot;covering index&quot;.</source>
          <target state="translated">인덱스에 쿼리에 필요한 모든 데이터가 포함되어 있고 원래 테이블을 참조 할 필요가없는 경우 해당 인덱스를 &quot;커버링 인덱스&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="82ebd13a345482eaf43922980ab28662ac5f3021" translate="yes" xml:space="preserve">
          <source>When an unlock-notify callback is registered, the application provides a single void* pointer that is passed to the callback when it is invoked. However, the signature of the callback function allows SQLite to pass it an array of void* context pointers. The first argument passed to an unlock-notify callback is a pointer to an array of void* pointers, and the second is the number of entries in the array.</source>
          <target state="translated">잠금 해제 알림 콜백이 등록되면 응용 프로그램은 호출시 콜백에 전달되는 단일 void * 포인터를 제공합니다. 그러나 콜백 함수의 서명을 통해 SQLite는 void * 컨텍스트 포인터의 배열을 전달할 수 있습니다. unlock-notify 콜백에 전달 된 첫 번째 인수는 void * 포인터 배열에 대한 포인터이고 두 번째 인수는 배열의 항목 수입니다.</target>
        </trans-unit>
        <trans-unit id="52b75d8996a29266548750270878024301ed32e8" translate="yes" xml:space="preserve">
          <source>When attempting to open a file, the SQLITE_NOTADB error indicates that the file being opened does not appear to be an SQLite database file.</source>
          <target state="translated">파일을 열려고 할 때 SQLITE_NOTADB 오류는 열려는 파일이 SQLite 데이터베이스 파일이 아닌 것으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9105d0e8a7ab7b349bd2fbe878c8275b8882d52a" translate="yes" xml:space="preserve">
          <source>When both the SQLite core and the &lt;a href=&quot;cli&quot;&gt;Command Line Interface&lt;/a&gt; (CLI) are both compiled with this option, then the CLI provides an extra command named &quot;.iotrace&quot; that provides a low-level log of I/O activity. This option is experimental and may be discontinued in a future release.</source>
          <target state="translated">SQLite 코어와 CLI ( &lt;a href=&quot;cli&quot;&gt;명령 줄 인터페이스&lt;/a&gt; )가 모두이 옵션으로 컴파일되면 CLI는 &quot;.iotrace&quot;라는 추가 명령을 제공하여 I / O 작업의 하위 수준 로그를 제공합니다. 이 옵션은 실험용이며 향후 릴리스에서 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f9015046bd06c8d94d98831683d6a650fd53ca" translate="yes" xml:space="preserve">
          <source>When building the &lt;a href=&quot;cli&quot;&gt;CLI&lt;/a&gt;, it is helpful, but not required, to have the following third-party libraries on hand:</source>
          <target state="translated">&lt;a href=&quot;cli&quot;&gt;CLI를&lt;/a&gt; 빌드 할 때 다음 타사 라이브러리를 준비하는 것이 도움이되지만 필수는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ba9eeb759b581addc9af410a4bf9f2616522ac5b" translate="yes" xml:space="preserve">
          <source>When building with MSVC on Windows systems, one can put the zlib source code in the compat/zlib subdirectory of the source tree and then add the USE_ZLIB=1 option to the nmake command to cause the The Makefile.msc to automatically build and use an appropriate zlib library implementation.</source>
          <target state="translated">Windows 시스템에서 MSVC로 빌드 할 때 소스 트리의 compat / zlib 서브 디렉토리에 zlib 소스 코드를 넣은 다음 nmake 명령에 USE_ZLIB = 1 옵션을 추가하여 Makefile.msc가 자동으로 빌드 및 사용되도록 할 수 있습니다. 적절한 zlib 라이브러리 구현.</target>
        </trans-unit>
        <trans-unit id="e30f7cd9c75ce2c6c161c9108a391a6b6c55986e" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to INTEGER, the value is first converted to TEXT.</source>
          <target state="translated">BLOB 값을 INTEGER로 캐스트 할 때 값은 먼저 TEXT로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0c597294629f9542feb4df0871368a01531b6a" translate="yes" xml:space="preserve">
          <source>When casting a BLOB value to a REAL, the value is first converted to TEXT.</source>
          <target state="translated">BLOB 값을 REAL로 캐스트 할 때 값은 먼저 TEXT로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5067d93cc1cb86aa6af9bcf672584d0b1585ff55" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to INTEGER, the longest possible prefix of the value that can be interpreted as an integer number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value when converting from TEXT to INTEGER are ignored. If there is no prefix that can be interpreted as an integer number, the result of the conversion is 0. If the prefix integer is greater than +9223372036854775807 then the result of the cast is exactly +9223372036854775807. Similarly, if the prefix integer is less than -9223372036854775808 then the result of the cast is exactly -9223372036854775808.</source>
          <target state="translated">TEXT 값을 INTEGER로 캐스트 할 때 정수로 해석 될 수있는 값의 가장 긴 접 두부가 TEXT 값에서 추출되고 나머지는 무시됩니다. TEXT에서 INTEGER로 변환 할 때 TEXT 값의 선행 공백은 무시됩니다. 정수로 해석 될 수있는 접두사가없는 경우 변환 결과는 0입니다. 접 두부 정수가 +9223372036854775807보다 크면 캐스트 결과는 정확히 +9223372036854775807입니다. 마찬가지로 접두사 정수가 -9223372036854775808보다 작은 경우 캐스트 결과는 정확히 -9223372036854775808입니다.</target>
        </trans-unit>
        <trans-unit id="65da0fa3bb91d9ed81f980bbc2df26063662f53c" translate="yes" xml:space="preserve">
          <source>When casting a TEXT value to REAL, the longest possible prefix of the value that can be interpreted as a real number is extracted from the TEXT value and the remainder ignored. Any leading spaces in the TEXT value are ignored when converging from TEXT to REAL. If there is no prefix that can be interpreted as a real number, the result of the conversion is 0.0.</source>
          <target state="translated">TEXT 값을 REAL로 캐스트 할 때 실수로 해석 될 수있는 값의 가장 긴 접 두부가 TEXT 값에서 추출되고 나머지는 무시됩니다. TEXT에서 REAL로 수렴 할 때 TEXT 값의 선행 공백은 무시됩니다. 실수로 해석 될 수있는 접두사가없는 경우 변환 결과는 0.0입니다.</target>
        </trans-unit>
        <trans-unit id="46e82821742f6cd2f96bd6126debacd8be0bdcfb" translate="yes" xml:space="preserve">
          <source>When casting to INTEGER, if the text looks like a floating point value with an exponent, the exponent will be ignored because it is no part of the integer prefix. For example, &quot;(CAST '123e+5' AS INTEGER)&quot; results in 123, not in 12300000.</source>
          <target state="translated">INTEGER로 캐스트 할 때 텍스트가 지수가있는 부동 소수점 값처럼 보이면 지수는 정수 접 두부의 일부가 아니므로 무시됩니다. 예를 들어 &quot;(CAST '123e + 5'AS INTEGER)&quot;는 12300000이 아니라 123이됩니다.</target>
        </trans-unit>
        <trans-unit id="39d5e03e61b6bf8d9e7be24acbf923224eccdb8e" translate="yes" xml:space="preserve">
          <source>When checking for the WHERE-clause push-down optimization, verify that all terms of the compound inner SELECT are non-aggregate, not just the last term. Fix for ticket &lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt;.</source>
          <target state="translated">WHERE- 절 푸시 다운 최적화를 확인할 때 복합 내부 SELECT의 모든 항이 마지막 항만이 아니라 집계되지 않았는지 확인하십시오. 티켓 &lt;a href=&quot;https://www.sqlite.org/src/info/f7f8c97e97597&quot;&gt;f7f8c97e97597&lt;/a&gt; 수정 .</target>
        </trans-unit>
        <trans-unit id="95988d2f9a83f35536e66d62cf26515907b72996" translate="yes" xml:space="preserve">
          <source>When compared with SQLite's built-in VACUUM command, RBU Vacuum has the following limitations:</source>
          <target state="translated">SQLite의 내장 VACUUM 명령과 비교할 때 RBU Vacuum에는 다음과 같은 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71ec8021f2a78c2f5787e61e104c092e2cf0b2cc" translate="yes" xml:space="preserve">
          <source>When comparing a base expression against a WHEN expression, the same collating sequence, affinity, and NULL-handling rules apply as if the base expression and WHEN expression are respectively the left- and right-hand operands of an</source>
          <target state="translated">기본 표현식을 WHEN 표현식과 비교할 때 기본 표현식과 WHEN 표현식이 각각 왼쪽 및 오른쪽 피연산자와 동일한 조합 순서, 선호도 및 NULL 처리 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a8e8bf765d052cbbdbda4e8360051200aec0343" translate="yes" xml:space="preserve">
          <source>When comparing text values, the &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequence&lt;/a&gt; associated with the parent key column is always used.</source>
          <target state="translated">텍스트 값을 비교할 때는 항상 상위 키 열과 관련된 &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd6464f68b9918a029c67f18300aa6bddf2bf88" translate="yes" xml:space="preserve">
          <source>When comparing values, if the parent key column has an &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt;, then that affinity is applied to the child key value before the comparison is performed.</source>
          <target state="translated">값을 비교할 경우, 상위 키의 열이있는 경우 &lt;a href=&quot;datatype3#affinity&quot;&gt;친화도를&lt;/a&gt; 비교가 수행되기 전에, 그 연관은 하위 키 값에 적용된다.</target>
        </trans-unit>
        <trans-unit id="8a8c1f258ce77d3b0b1a04487b470e53840cc8d0" translate="yes" xml:space="preserve">
          <source>When compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt;, SQLite includes routines that will print out various internal parse tree structures as ASCII-art graphs. This can be very useful in a debugging in order to understand the variables that SQLite is working with.</source>
          <target state="translated">&lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG로&lt;/a&gt; 컴파일 할 때 SQLite에는 다양한 내부 구문 분석 트리 구조를 ASCII 아트 그래프로 인쇄하는 루틴이 포함되어 있습니다. 이는 SQLite가 작업하는 변수를 이해하기 위해 디버깅에 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b440573f54c675131665957f45fa09226296363a" translate="yes" xml:space="preserve">
          <source>When compiling with this option, it will normally be necessary to add a linker option to include the zlib library in the build. Normal this option is &quot;-lz&quot; but might be different on different systems.</source>
          <target state="translated">이 옵션으로 컴파일 할 때는 일반적으로 빌드에 zlib 라이브러리를 포함시키기 위해 링커 옵션을 추가해야합니다. 일반적으로이 옵션은 &quot;-lz&quot;이지만 시스템마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c300eac9b0ba20d1c5f0548bea68bd1985408338" translate="yes" xml:space="preserve">
          <source>When computing the cost of the &lt;a href=&quot;optoverview#skipscan&quot;&gt;skip-scan optimization&lt;/a&gt;, take into account the fact that multiple seeks are required.</source>
          <target state="translated">&lt;a href=&quot;optoverview#skipscan&quot;&gt;스킵 스캔 최적화&lt;/a&gt; 비용을 계산할 때는 여러 번의 탐색이 필요하다는 사실을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0f31671e641184fdff6ce2920c28181e45773893" translate="yes" xml:space="preserve">
          <source>When confronted with OR-connected terms in a WHERE clause, SQLite examines each OR term separately and tries to use an index to find the rowids associated with each term. It then takes the union of the resulting rowid sets to find the end result. The following figure illustrates this process:</source>
          <target state="translated">WHERE 절에서 OR 연결 용어에 직면 할 때 SQLite는 각 OR 용어를 개별적으로 검사하고 색인을 사용하여 각 용어와 연관된 행 ID를 찾습니다. 그런 다음 결과 rowid 세트를 통합하여 최종 결과를 찾습니다. 다음 그림은이 프로세스를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="80acebb0e2681ada8eda5ed06d14fb5c6e654492" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, pages that are no longer used are added to a free list and are reused to hold content added by subsequent inserts. A bug in SQLite that was present in version 3.6.16 through 3.7.2 might cause pages to go missing out of the free list when &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; was used. This would not cause data loss. But it would result in the database file being larger than necessary. And it would cause the &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; to report pages missing from the free list.</source>
          <target state="translated">SQLite 데이터베이스에서 컨텐츠를 삭제하면 더 이상 사용되지 않는 페이지가 사용 가능 목록에 추가되고 후속 삽입에 의해 추가 된 컨텐츠를 보유하기 위해 재사용됩니다. SQL 3.6의 버전 3.6.16부터 3.7.2까지의 버그로 인해 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; 을 사용할 때 사용 가능한 목록에서 페이지가 누락 될 수 있습니다 . 데이터 손실이 발생하지 않습니다. 그러나 데이터베이스 파일이 필요 이상으로 커집니다. 그리고 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;integrity_check pragma&lt;/a&gt; 가 비어있는 목록에서 누락 된 페이지를보고하게합니다.</target>
        </trans-unit>
        <trans-unit id="ec68acb5aee4ac70ffc0e427ed46e7978d7d9aaa" translate="yes" xml:space="preserve">
          <source>When content is deleted from an SQLite database, the content is not usually erased but rather the space used to hold the content is marked as being available for reuse. This can allow deleted content to be recovered by a hacker or by forensic analysis. Running VACUUM will clean the database of all traces of deleted content, thus preventing an adversary from recovering deleted content. Using VACUUM in this way is an alternative to setting &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete=ON&lt;/a&gt;.</source>
          <target state="translated">컨텐츠가 SQLite 데이터베이스에서 삭제되면 컨텐츠는 일반적으로 삭제되지 않고 컨텐츠를 보유하는 데 사용 된 공간이 재사용 가능한 것으로 표시됩니다. 이를 통해 해커 나 법 의학적 분석을 통해 삭제 된 컨텐츠를 복구 할 수 있습니다. VACUUM을 실행하면 삭제 된 모든 내용의 데이터베이스를 정리하여 공격자가 삭제 된 내용을 복구하지 못하게합니다. &lt;a href=&quot;pragma#pragma_secure_delete&quot;&gt;PRAGMA secure_delete = ON&lt;/a&gt; 을 설정하는 대신이 방법으로 VACUUM을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ef3b5e9abd6cdd13cd5d387ea4a3c929af66232" translate="yes" xml:space="preserve">
          <source>When converting BLOB to TEXT, use the text encoding of the main database. Ticket #2349</source>
          <target state="translated">BLOB를 TEXT로 변환 할 때는 기본 데이터베이스의 텍스트 인코딩을 사용하십시오. 티켓 # 2349</target>
        </trans-unit>
        <trans-unit id="114a59b6e420f398fe8acae2dbbd380f2c338748" translate="yes" xml:space="preserve">
          <source>When creating a new database file during &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt; on unix systems, SQLite will try to set the permissions of the new database file to match the existing file &quot;</source>
          <target state="translated">UNIX 시스템 에서 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()&lt;/a&gt; 중에 새 데이터베이스 파일을 작성할 때 SQLite는 기존 파일 &quot;과 일치하도록 새 데이터베이스 파일의 권한을 설정하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="bb5190d7ef1fca8d42df7043f112c5cb64984b8e" translate="yes" xml:space="preserve">
          <source>When creating new user-defined SQL functions and collating sequences, each function or collating sequence can specify if it works with UTF-8, UTF-16be, or UTF-16le. Separate implementations can be registered for each encoding. If an SQL function or collating sequence is required but a version for the current text encoding is not available, then the text is automatically converted. As before, this conversion takes computation time, so programmers are advised to pick a single encoding and stick with it in order to minimize the amount of unnecessary format juggling.</source>
          <target state="translated">새로운 사용자 정의 SQL 함수 및 조합 순서를 작성할 때 각 함수 또는 조합 순서는 UTF-8, UTF-16be 또는 UTF-16le에서 작동하는지 지정할 수 있습니다. 각 인코딩마다 별도의 구현을 등록 할 수 있습니다. SQL 함수 또는 조합 순서가 필요하지만 현재 텍스트 인코딩의 버전을 사용할 수없는 경우 텍스트가 자동으로 변환됩니다. 이전과 마찬가지로이 변환에는 계산 시간이 걸리므로 프로그래머는 불필요한 형식 저글링의 양을 최소화하기 위해 단일 인코딩을 선택하고이를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6a02367c161ead06f619b074aecd9b89d2c0cc40" translate="yes" xml:space="preserve">
          <source>When data is appended to the end of the rollback journal, SQLite normally makes the pessimistic assumption that the file is first extended with invalid &quot;garbage&quot; data and that afterwards the correct data replaces the garbage. In other words, SQLite assumes that the file size is increased first and then afterwards the content is written into the file. If a power failure occurs after the file size has been increased but before the file content has been written, the rollback journal can be left containing garbage data. If after power is restored, another SQLite process sees the rollback journal containing the garbage data and tries to roll it back into the original database file, it might copy some of the garbage into the database file and thus corrupt the database file.</source>
          <target state="translated">데이터가 롤백 저널의 끝에 추가 될 때, SQLite는 일반적으로 파일이 먼저 유효하지 않은 &quot;쓰레기&quot;데이터로 확장되고 올바른 데이터가 가비지를 대체한다고 비관적 인 가정을합니다. 즉, SQLite는 파일 크기가 먼저 증가한 다음 내용이 파일에 기록된다고 가정합니다. 파일 크기가 증가한 후 파일 내용이 기록되기 전에 정전이 발생하면 가비지 데이터가 포함 된 롤백 저널이 남아있을 수 있습니다. 전원이 복원 된 후 다른 SQLite 프로세스는 가비지 데이터가 포함 된 롤백 저널을보고이를 원래 데이터베이스 파일로 롤백하려고 시도 할 때 일부 가비지가 데이터베이스 파일에 복사되어 데이터베이스 파일이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1728b3880c31067245341a957998cb64468579" translate="yes" xml:space="preserve">
          <source>When database corruption is detected, an SQLITE_CORRUPT error logger callback is invoked. As with I/O errors, the error message text contains the line number in the original source code where the error was first detected.</source>
          <target state="translated">데이터베이스 손상이 감지되면 SQLITE_CORRUPT 오류 로거 콜백이 호출됩니다. I / O 오류와 마찬가지로 오류 메시지 텍스트에는 오류가 처음 발견 된 원래 소스 코드의 행 번호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5ec353b1e7bb6a3ecdd47f7ae7473e801761839f" translate="yes" xml:space="preserve">
          <source>When dates are stored this way, row value comparisons provide a convenient way to compare dates:</source>
          <target state="translated">날짜가 이런 식으로 저장되면 행 값 비교는 날짜를 비교하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="db590fa9b88387884339466c341a1e3e6a784a7d" translate="yes" xml:space="preserve">
          <source>When debugging the &lt;a href=&quot;opcode&quot;&gt;bytecode&lt;/a&gt; generator, it is often useful to know where a particular opcode is being generated. To find this easily, run the script in a debugger. Set a breakpoint on the &quot;test_addoptrace&quot; routine. Then run the &quot;PRAGMA vdbe_addoptrace=ON;&quot; followed by the SQL statement in question. Each opcode will be displayed as it is appended to the VDBE program, and the breakpoint will fire immediately thereafter. Step until reaching the opcode then look backwards in the stack to see where and how it was generated.</source>
          <target state="translated">&lt;a href=&quot;opcode&quot;&gt;바이트 코드&lt;/a&gt; 생성기를 디버깅 할 때 특정 opcode가 생성되는 위치를 아는 것이 종종 유용합니다. 이것을 쉽게 찾으려면 디버거에서 스크립트를 실행하십시오. &quot;test_addoptrace&quot;루틴에 중단 점을 설정하십시오. 그런 다음 &quot;PRAGMA vdbe_addoptrace = ON;&quot;을 실행하십시오. 문제의 SQL 문이 뒤 따릅니다. 각 opcode는 VDBE 프로그램에 추가 될 때 표시되며 그 후 즉시 중단 점이 실행됩니다. 오피 코드에 도달 할 때까지 한 단계 씩 진행 한 다음 스택에서 뒤로보고 생성 된 위치와 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d36e8b2fe095f3dcf16b488533e2eea81261ce34" translate="yes" xml:space="preserve">
          <source>When deciding between two plans with the same estimated cost, bias the selection toward the one that does not use the sorter.</source>
          <target state="translated">동일한 추정 비용으로 두 계획을 결정할 때 선택기를 분류기를 사용하지 않는 계획으로 편향시킵니다.</target>
        </trans-unit>
        <trans-unit id="bf93f718a16c4baf24f9f9cd0779c38e6d7918df" translate="yes" xml:space="preserve">
          <source>When defined, this C-preprocessor macro activates extra code that attempts to detect misuse of the SQLite API, such as passing in NULL pointers to required parameters or using objects after they have been destroyed.</source>
          <target state="translated">이 C-preprocessor 매크로는 정의되면 필수 매개 변수에 NULL 포인터를 전달하거나 파괴 된 오브젝트를 사용하는 등 SQLite API의 오용을 감지하는 추가 코드를 활성화합니다.</target>
        </trans-unit>
        <trans-unit id="1548f1f2e91ad07dfb5ee921f08a77e6a373fb3e" translate="yes" xml:space="preserve">
          <source>When defining a TEMP trigger on a non-TEMP table, it is important to specify the database holding the non-TEMP table. For example, in the following statement, it is important to say &quot;main.tab1&quot; instead of just &quot;tab1&quot;:</source>
          <target state="translated">비 TEMP 테이블에서 TEMP 트리거를 정의 할 때 비 TEMP 테이블을 보유하는 데이터베이스를 지정해야합니다. 예를 들어, 다음 명령문에서 &quot;tab1&quot;대신 &quot;main.tab1&quot;을 말하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="08cdbd4cf4d969a92be0666ae36716558d90ece0" translate="yes" xml:space="preserve">
          <source>When doing DELETE and UPDATE, the library used to write the record numbers of records to be deleted or updated into a temporary file. This is changed so that the record numbers are held in memory.</source>
          <target state="translated">DELETE 및 UPDATE를 수행 할 때 라이브러리는 삭제되거나 업데이트 될 레코드의 레코드 수를 임시 파일에 기록하는 데 사용되었습니다. 레코드 번호가 메모리에 유지되도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3cda947ba0235d70ea9379c938638b6e342ed7b3" translate="yes" xml:space="preserve">
          <source>When doing an indexed lookup of a row, the usual procedure is to do a binary search on the index to find the index entry, then extract the &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; from the index and use that &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; to do a binary search on the original table. Thus a typical indexed lookup involves two binary searches. If, however, all columns that were to be fetched from the table are already available in the index itself, SQLite will use the values contained in the index and will never look up the original table row. This saves one binary search for each row and can make many queries run twice as fast.</source>
          <target state="translated">행의 인덱스 조회를 수행 할 때 일반적인 절차는 인덱스에서 이진 검색을 수행하여 인덱스 항목을 찾은 다음 인덱스에서 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 추출하고 해당 &lt;a href=&quot;lang_createtable#rowid&quot;&gt;rowid&lt;/a&gt; 를 사용 하여 원래 테이블에서 이진 검색을 수행하는 것입니다. 따라서 일반적인 색인 검색에는 2 개의 이진 검색이 포함됩니다. 그러나 테이블에서 페치 된 모든 컬럼이 인덱스 자체에서 이미 사용 가능한 경우 SQLite는 인덱스에 포함 된 값을 사용하며 원래 테이블 행을 찾지 않습니다. 이렇게하면 각 행마다 하나의 이진 검색이 저장되고 많은 쿼리가 두 배 더 빠르게 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9904bf6d42a19655ef67955a4a94073b0eae876b" translate="yes" xml:space="preserve">
          <source>When doing an insert without a rowid (argc&amp;gt;1, argv[1] is an SQL NULL), on a virtual table that uses ROWID (but not on a &lt;a href=&quot;vtab#worid&quot;&gt;WITHOUT ROWID virtual table&lt;/a&gt;), the implementation must set *pRowid to the rowid of the newly inserted row; this will become the value returned by the &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid()&lt;/a&gt; function. Setting this value in all the other cases is a harmless no-op; the SQLite engine ignores the *pRowid return value if argc==1 or argv[1] is not an SQL NULL.</source>
          <target state="translated">rowid없이 (argc&amp;gt; 1, argv [1]은 SQL NULL 임) 삽입을 수행 할 때 ROWID를 사용하는 가상 테이블 ( withwith &lt;a href=&quot;vtab#worid&quot;&gt;ROWID 가상 테이블이&lt;/a&gt; 아님)에서 구현은 * pRowid를 rowid의 rowid로 설정해야합니다. 새롭게 삽입 된 행; 이것은 &lt;a href=&quot;c3ref/last_insert_rowid&quot;&gt;sqlite3_last_insert_rowid ()&lt;/a&gt; 함수가 반환 한 값이됩니다 . 다른 모든 경우에이 값을 설정하는 것은 무해합니다. argc == 1 또는 argv [1]이 SQL NULL이 아닌 경우 SQLite 엔진은 * pRowid 리턴 값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="1c8dd9af0591131c94abbb3f55e35333a90c2bb5" translate="yes" xml:space="preserve">
          <source>When enabled, this PRAGMA causes many &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statements without an ORDER BY clause to emit their results in the reverse order from what they normally would. This can help debug applications that are making invalid assumptions about the result order. The reverse_unordered_selects pragma works for most SELECT statements, however the query planner may sometimes choose an algorithm that is not easily reversed, in which case the output will appear in the same order regardless of the reverse_unordered_selects setting.</source>
          <target state="translated">사용 가능한 경우,이 PRAGMA 는 ORDER BY 절이없는 많은 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문이 결과를 일반적인 순서와 반대 순서로 표시합니다. 결과 순서에 대해 잘못된 가정을하는 응용 프로그램을 디버깅하는 데 도움이됩니다. reverse_unordered_selects pragma는 대부분의 SELECT 문에서 작동하지만 쿼리 플래너는 때때로 쉽게 되 돌리지 않는 알고리즘을 선택할 수 있습니다.이 경우 reverse_unordered_selects 설정에 관계없이 출력이 동일한 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="17ef63392395a1e6663e404dcadfba942c11b299" translate="yes" xml:space="preserve">
          <source>When faced with a choice of two or more indices, SQLite tries to estimate the total amount of work needed to perform the query using each option. It then selects the option that gives the least estimated work.</source>
          <target state="translated">둘 이상의 인덱스를 선택할 때 SQLite는 각 옵션을 사용하여 쿼리를 수행하는 데 필요한 총 작업량을 추정하려고합니다. 그런 다음 가장 적은 추정 작업을 제공하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="393ffe20ba1bb6822b853fbdd74f36cd0864d018" translate="yes" xml:space="preserve">
          <source>When files opened with the asynchronous VFS are read from (using the vfs xRead() method), the data is read from the file on disk and the write-queue, so that from the point of view of the vfs reader the xWrite() appears to have already completed.</source>
          <target state="translated">vfs xRead () 메소드를 사용하여 비동기 VFS로 열린 파일을 읽을 때 디스크의 파일과 쓰기 큐에서 데이터를 읽으므로 vfs 판독기의 관점에서 xWrite () 이미 완료된 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="c7d3d8950c12709e47c72758e22cf2a9146592d1" translate="yes" xml:space="preserve">
          <source>When generating individual loops for each ORed term of an OR scan, move any constant WHERE expressions outside of the loop, as is done for top-level loops.</source>
          <target state="translated">OR 스캔의 각 OR 용어에 대해 개별 루프를 생성 할 때 최상위 루프에서와 같이 상수 WHERE 표현식을 루프 외부로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="509726027c6ee1ed12b9f77062dac2b144897c56" translate="yes" xml:space="preserve">
          <source>When grouping values with the GROUP BY clause values with different storage classes are considered distinct, except for INTEGER and REAL values which are considered equal if they are numerically equal. No affinities are applied to any values as the result of a GROUP by clause.</source>
          <target state="translated">스토리지 클래스가 다른 GROUP BY 절을 사용하여 값을 그룹화 할 때 INTEGER 및 REAL 값이 숫자로 같으면 동일하다고 간주되는 경우를 제외하고는 고유 한 것으로 간주됩니다. GROUP by 절의 결과로 모든 값에 선호도가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5be44df47344688e11692055f71bde95bd3d10c" translate="yes" xml:space="preserve">
          <source>When implementing the compress and uncompress functions it is important to pay attention to data types. Specifically, when a user reads a value from a compressed FTS table, the value returned by FTS is exactly the same as the value returned by the uncompress function, including the data type. If that data type is not the same as the data type of the original value as passed to the compress function (for example if the uncompress function is returning BLOB when compress was originally passed TEXT), then the users query may not function as expected.</source>
          <target state="translated">압축 및 압축 해제 기능을 구현할 때는 데이터 유형에주의를 기울여야합니다. 특히, 사용자가 압축 된 FTS 테이블에서 값을 읽을 때 FTS에 의해 반환되는 값은 데이터 형식을 포함하여 압축 해제 기능에 의해 반환 된 값과 정확히 동일합니다. 해당 데이터 유형이 압축 함수에 전달 된 원래 값의 데이터 유형과 동일하지 않은 경우 (예 : 압축이 원래 TEXT를 전달할 때 압축 해제 기능이 BLOB를 리턴하는 경우) 사용자 조회가 예상대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9aa85d5d53872aab853201ddf44e7a88440d444e" translate="yes" xml:space="preserve">
          <source>When in active use, the state of a WAL mode database is described by three separate files:</source>
          <target state="translated">활성 상태에서 WAL 모드 데이터베이스의 상태는 세 개의 개별 파일로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="2d85294d594836a84f09ae35993c5315f3443a88" translate="yes" xml:space="preserve">
          <source>When information is deleted from an SQLite database, the pages used to hold the deleted information are added to a &quot;&lt;a href=&quot;fileformat2#freelist&quot;&gt;freelist&lt;/a&gt;&quot;. Subsequent inserts will draw pages off of this freelist rather than expanding the database file.</source>
          <target state="translated">SQLite 데이터베이스에서 정보가 삭제되면 삭제 된 정보를 보유하는 데 사용 된 페이지가 &quot; &lt;a href=&quot;fileformat2#freelist&quot;&gt;프리리스트&lt;/a&gt; &quot;에 추가됩니다 . 후속 삽입은 데이터베이스 파일을 확장하지 않고이 프리리스트에서 페이지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e58c2028dd3a68f355f0f948fe1f1f5ac6f262b7" translate="yes" xml:space="preserve">
          <source>When initially opened, the cursor is in an undefined state. The SQLite core will invoke the &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; method on the cursor prior to any attempt to position or read from the cursor.</source>
          <target state="translated">처음 열면 커서가 정의되지 않은 상태입니다. SQLite 코어는 커서에서 위치를 읽거나 읽기 전에 커서 에서 &lt;a href=&quot;vtab#xfilter&quot;&gt;xFilter&lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4ec1014aface212f1273d4c0983ab7820ffd9ca0" translate="yes" xml:space="preserve">
          <source>When inserting an explicit NULL into an INTEGER PRIMARY KEY, convert the NULL value into a unique key automatically.</source>
          <target state="translated">INTEGER PRIMARY KEY에 명시 적 NULL을 삽입 할 때 NULL 값을 고유 키로 자동 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="643f10feaaa38e7180b2d82bb59e6a7c32281c82" translate="yes" xml:space="preserve">
          <source>When looking for memory allocation problems (memory leaks, use-after-free errors, buffer overflows, etc) it is sometimes useful to disable the &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside memory allocator&lt;/a&gt; then run the test under valgrind or MSAN or some other heap memory debugging tool. The lookaside memory allocator can be disabled at start-time using the &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; interface. The &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; will use that interface to disable lookaside if it is started with the &quot;--lookaside 0 0&quot; command line option.</source>
          <target state="translated">메모리 할당 문제 (메모리 누수, 사후 사용 오류, 버퍼 오버 플로우 등)를 찾을 때 &lt;a href=&quot;malloc#lookaside&quot;&gt;lookaside 메모리 할당자를&lt;/a&gt; 비활성화 한 다음 valgrind 또는 MSAN 또는 기타 힙 메모리 디버깅 도구에서 테스트를 실행하는 것이 유용한 경우가 있습니다. lookaside 메모리 할당자는 &lt;a href=&quot;c3ref/c_config_covering_index_scan#sqliteconfiglookaside&quot;&gt;SQLITE_CONFIG_LOOKASIDE&lt;/a&gt; 인터페이스를 사용하여 시작시에 비활성화 할 수 있습니다 . &lt;a href=&quot;cli&quot;&gt;명령 행 쉘은&lt;/a&gt; 그것이 &quot;--lookaside 0 0&quot;명령 줄 옵션으로 시작되는 경우 비활성화를 lookaside에 해당 인터페이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="42fe685cb985a24b50ac506fdd29223838c245b8" translate="yes" xml:space="preserve">
          <source>When measuring test coverage, these macros are defined to be constant truth values so that they do not generate assembly language branch instructions, and hence do not come into play when calculating the branch coverage:</source>
          <target state="translated">테스트 범위를 측정 할 때 이러한 매크로는 상수 값으로 정의되어 어셈블리 언어 분기 명령어를 생성하지 않으므로 분기 범위를 계산할 때 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37b8b518e60139042da23ec309a2db4382dae010" translate="yes" xml:space="preserve">
          <source>When more than two tables are joined together as part of a FROM clause, the join operations are processed in order from left to right. In other words, the FROM clause (A join-op-1 B join-op-2 C) is computed as ((A join-op-1 B) join-op-2 C).</source>
          <target state="translated">FROM 절의 일부로 둘 이상의 테이블이 결합되면 결합 조작은 왼쪽에서 오른쪽으로 순서대로 처리됩니다. 즉, FROM 절 (A join-op-1 B join-op-2 C)은 ((A join-op-1 B) join-op-2 C)로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="87981e247df4872c2958ce96479f7f548dab13e8" translate="yes" xml:space="preserve">
          <source>When multiple database connections share the same cache, changing the secure-delete flag on one database connection changes it for them all.</source>
          <target state="translated">여러 데이터베이스 연결이 동일한 캐시를 공유하는 경우 한 데이터베이스 연결에서 보안 삭제 플래그를 변경하면 모든 데이터베이스 연결이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="cff16baa2216647f9ba74dc7c006fb34b16c7df6" translate="yes" xml:space="preserve">
          <source>When multiple database files are involved in a transaction, each database has its own rollback journal and each database is locked separately. The diagram at the right shows a scenario where three different database files have been modified within one transaction. The situation at this step is analogous to the single-file transaction scenario at &lt;a href=&quot;#section_3_6&quot;&gt;step 3.6&lt;/a&gt;. Each database file has a reserved lock. For each database, the original content of pages that are being changed have been written into the rollback journal for that database, but the content of the journals have not yet been flushed to disk. No changes have been made to the database file itself yet, though presumably there are changes being held in user memory.</source>
          <target state="translated">트랜잭션에 여러 데이터베이스 파일이 포함 된 경우 각 데이터베이스에는 고유 한 롤백 저널이 있으며 각 데이터베이스는 별도로 잠 깁니다. 오른쪽의 다이어그램은 하나의 트랜잭션 내에서 서로 다른 세 개의 데이터베이스 파일이 수정 된 시나리오를 보여줍니다. 이 단계의 상황은 &lt;a href=&quot;#section_3_6&quot;&gt;3.6 단계&lt;/a&gt; 의 단일 파일 트랜잭션 시나리오와 유사합니다 . 각 데이터베이스 파일에는 예약 된 잠금이 있습니다. 각 데이터베이스에 대해 변경중인 페이지의 원래 컨텐츠는 해당 데이터베이스에 대한 롤백 저널에 기록되었지만 저널의 컨텐츠는 아직 디스크로 플러시되지 않았습니다. 데이터베이스 파일 자체는 아직 변경되지 않았지만 사용자 메모리에 변경 사항이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="594f4bededce2bfb4a7467d0259050d544509cc0" translate="yes" xml:space="preserve">
          <source>When mxFrame field is zero, it indicates that the WAL is empty and that all content should be obtained directly from the database file.</source>
          <target state="translated">mxFrame 필드가 0이면 WAL이 비어 있고 모든 내용을 데이터베이스 파일에서 직접 가져와야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e88c1e1b6e3eb28ff7f2a97dc557877c5de44f1" translate="yes" xml:space="preserve">
          <source>When mxFrame is equal to &lt;a href=&quot;walformat#nbackfill&quot;&gt;nBackfill&lt;/a&gt;, that indicates that all content in the WAL has been written back into the database. In that case, all content can be read directly from the database. Furthermore, the next writer is free to &lt;a href=&quot;fileformat2#walreset&quot;&gt;reset the WAL&lt;/a&gt; if no other connections hold locks on WAL_READ_LOCK(N) for N&amp;gt;0.</source>
          <target state="translated">mxFrame이 nBackfill과 같으면 WAL의 모든 내용이 데이터베이스에 다시 쓰여 &lt;a href=&quot;walformat#nbackfill&quot;&gt;졌음&lt;/a&gt; 을 나타냅니다. 이 경우 모든 내용을 데이터베이스에서 직접 읽을 수 있습니다. 또한 N&amp;gt; 0 동안 WAL_READ_LOCK (N)에 잠금을 보유하는 다른 연결 이없는 경우 다음 작성기는 &lt;a href=&quot;fileformat2#walreset&quot;&gt;WAL을&lt;/a&gt; 자유롭게 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d7dccde63e1547be27c7ca87cdd1931b0750828" translate="yes" xml:space="preserve">
          <source>When new tables are created using CREATE TABLE ... AS SELECT ... the datatype of the columns is the simplified SQLite datatype (TEXT, INT, REAL, NUMERIC, or BLOB) instead of a copy of the original datatype from the source table.</source>
          <target state="translated">CREATE TABLE ... AS SELECT ...를 사용하여 새 테이블을 작성할 때 열의 데이터 유형은 소스 테이블의 원래 데이터 유형 사본 대신 단순화 된 SQLite 데이터 유형 (TEXT, INT, REAL, NUMERIC 또는 BLOB)입니다. .</target>
        </trans-unit>
        <trans-unit id="a55aa5700dcf1b282b21e4844d72874dc0872eb0" translate="yes" xml:space="preserve">
          <source>When no appropriate indices are available, a query with an ORDER BY clause must be sorted as a separate step. Consider this query:</source>
          <target state="translated">적절한 인덱스를 사용할 수없는 경우 ORDER BY 절이있는 쿼리는 별도의 단계로 정렬해야합니다. 이 쿼리를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="390a0c90ac5f7c87fa004dbc08670c0d9227649a" translate="yes" xml:space="preserve">
          <source>When no indices are available to aid the evaluation of a query, SQLite might create an automatic index that lasts only for the duration of a single SQL statement. Since the cost of constructing the automatic index is O(NlogN) (where N is the number of entries in the table) and the cost of doing a full table scan is only O(N), an automatic index will only be created if SQLite expects that the lookup will be run more than logN times during the course of the SQL statement. Consider an example:</source>
          <target state="translated">쿼리 평가에 도움이되는 인덱스가없는 경우 SQLite는 단일 SQL 문의 기간 동안 만 지속되는 자동 인덱스를 만들 수 있습니다. 자동 인덱스 구성 비용은 O (NlogN)이고 (여기서 N은 테이블의 항목 수임) 전체 테이블 스캔 수행 비용은 O (N)이므로 SQLite 인 경우에만 자동 인덱스가 작성됩니다. SQL 문이 진행되는 동안 조회가 logN 회 이상 실행될 것으로 예상합니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="540aa517907a8d449dfe0e0b35e5509aa40924c4" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed and the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="translated">트리거 프로그램 실행 중에 RAISE (ROLLBACK, ...), RAISE (ABORT, ...) 또는 RAISE (FAIL, ...) 중 하나가 호출되면 지정된 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 처리가 수행되고 현재 쿼리가 종료됩니다. &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; 의 오류 코드가 지정된 오류 메시지와 함께 응용 프로그램에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4e54fe7f1e563760a880b88a508db483dfbb6a4e" translate="yes" xml:space="preserve">
          <source>When one of RAISE(ROLLBACK,...), RAISE(ABORT,...) or RAISE(FAIL,...) is called during trigger-program execution, the specified &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; processing is performed the current query terminates. An error code of &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; is returned to the application, along with the specified error message.</source>
          <target state="translated">트리거 프로그램 실행 중에 RAISE (ROLLBACK, ...), RAISE (ABORT, ...) 또는 RAISE (FAIL, ...) 중 하나가 호출되면 지정된 &lt;a href=&quot;lang_conflict&quot;&gt;ON CONFLICT&lt;/a&gt; 처리가 수행되어 현재 쿼리가 종료됩니다. 지정된 오류 메시지와 함께 &lt;a href=&quot;rescode#constraint&quot;&gt;SQLITE_CONSTRAINT&lt;/a&gt; 오류 코드가 애플리케이션 에 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="01227fb935ccfc1f5f31820ba60592508e753c65" translate="yes" xml:space="preserve">
          <source>When opening a file, if the command-line client discovers that the file is ZIP archive instead of an SQLite database, it actually opens an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt; and then in that in-memory database it creates an instance of the &lt;a href=&quot;zipfile&quot;&gt;Zipfile virtual table&lt;/a&gt; that is attached to the ZIP archive.</source>
          <target state="translated">파일을 열 때 명령 줄 클라이언트가 파일이 SQLite 데이터베이스가 아닌 ZIP 아카이브임을 발견하면 실제로 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 를 연 다음 해당 인 메모리 데이터베이스에서 &lt;a href=&quot;zipfile&quot;&gt;Zipfile 가상 테이블&lt;/a&gt; 의 인스턴스를 생성 합니다 . ZIP 아카이브에 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="4362aeea9635659d5b4cd64a35ff28fb52ad1831" translate="yes" xml:space="preserve">
          <source>When operating in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, all SQLite database connections associated with the same database file need to share some memory that is used as an index for the WAL file. In most implementations, this shared memory is implemented by calling mmap() on a file created for this sole purpose: the shared-memory file. The shared-memory file, if it exists, is located in the same directory as the database file and has the same name as the database file except with the 4 characters &quot;&lt;b&gt;-shm&lt;/b&gt;&quot; appended. Shared memory files only exist while running in WAL mode.</source>
          <target state="translated">&lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 에서 작동 하는 경우 동일한 데이터베이스 파일과 연관된 모든 SQLite 데이터베이스 연결은 WAL 파일의 인덱스로 사용되는 일부 메모리를 공유해야합니다. 대부분의 구현에서이 공유 메모리는이 유일한 목적으로 작성된 파일 인 공유 메모리 파일에서 mmap ()을 호출하여 구현됩니다. 공유 메모리 파일 (있는 경우)은 데이터베이스 파일과 동일한 디렉토리에 있으며 4 자 &quot; &lt;b&gt;-shm&lt;/b&gt; &quot;이 추가 된 것을 제외하고 데이터베이스 파일과 이름이 같습니다 . 공유 메모리 파일은 WAL 모드에서 실행되는 동안에 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="6bb4007f1d52b792a142259284926e062c686eaf" translate="yes" xml:space="preserve">
          <source>When optimized for size, the whole SQLite library with everything enabled is &lt;a href=&quot;footprint&quot;&gt;less than 500KiB in size&lt;/a&gt; (as measured on an ix86 using the &quot;size&quot; utility from the GNU compiler suite.) Unneeded features can be disabled at compile-time to further reduce the size of the library to under 300KiB if desired.</source>
          <target state="translated">크기에 최적화 된 경우 모든 기능이 활성화 된 전체 SQLite 라이브러리의 &lt;a href=&quot;footprint&quot;&gt;크기는 500KiB 미만입니다&lt;/a&gt; (GNU 컴파일러 제품군의 &quot;size&quot;유틸리티를 사용하여 ix86에서 측정 한 경우). 컴파일 타임에 불필요한 기능을 비활성화하여 원하는 경우 라이브러리 크기를 300KiB 미만으로 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="36556333a18e7240b5e2f86d71ec1605e3df5074" translate="yes" xml:space="preserve">
          <source>When porting SQLite to a new operating system, it is usually necessary to completely replace the built-in mutex subsystem with an alternative built around the mutex primitives of the new operating system. This is accomplished by compiling SQLite with the following option:</source>
          <target state="translated">SQLite를 새 운영 체제로 이식 할 때는 일반적으로 내장 뮤텍스 하위 시스템을 새 운영 체제의 뮤텍스 프리미티브 주변에 구축 된 대안으로 완전히 대체해야합니다. 다음 옵션을 사용하여 SQLite를 컴파일하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef28302f8a0daea79bec53d89c73ea8d20c2af92" translate="yes" xml:space="preserve">
          <source>When processing a &lt;b&gt;DELETE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">&lt;b&gt;삭제&lt;/b&gt; 변경을 처리 할 때 다음 충돌이 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="feb3e5a5d3242cd110b456009cbca7b6fb677c07" translate="yes" xml:space="preserve">
          <source>When processing a SELECT (or other) statement, SQLite may retrieve data from database tables in a variety of ways. It may scan through all the records in a table (a full-table scan), scan a contiguous subset of the records in a table based on the rowid index, scan a contiguous subset of the entries in a database &lt;a href=&quot;lang_createtable&quot;&gt;index&lt;/a&gt;, or use a combination of the above strategies in a single scan. The various ways in which SQLite may retrieve data from a table or index are described in detail &lt;a href=&quot;queryplanner#searching&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">SELECT (또는 다른) 명령문을 처리 할 때 SQLite는 다양한 방법으로 데이터베이스 테이블에서 데이터를 검색 할 수 있습니다. 테이블의 모든 레코드 (전체 테이블 스캔)를 스캔하거나, rowid 인덱스를 기반으로 테이블에서 레코드의 연속 서브 세트를 스캔 하거나, 데이터베이스 &lt;a href=&quot;lang_createtable&quot;&gt;인덱스&lt;/a&gt; 에있는 항목의 연속 서브 세트를 스캔 하거나, 조합을 사용할 수 있습니다. 한 번의 스캔으로 위의 전략 중 하나입니다. SQLite가 테이블이나 인덱스에서 데이터를 검색 할 수있는 다양한 방법이 &lt;a href=&quot;queryplanner#searching&quot;&gt;여기&lt;/a&gt; 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e6fe17803083dfa07e4b417bb2b4cf1a4c64242" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;INSERT&lt;/b&gt; change, the following conflicts can occur:</source>
          <target state="translated">&lt;b&gt;INSERT&lt;/b&gt; 변경을 처리 할 때 다음과 같은 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22eb80162f6ab8bb9c9904d675b35465735f18b1" translate="yes" xml:space="preserve">
          <source>When processing an &lt;b&gt;UPDATE&lt;/b&gt; change, the following conflicts may be detected:</source>
          <target state="translated">&lt;b&gt;UPDATE&lt;/b&gt; 변경을 처리 할 때 다음 충돌이 감지 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96dc4d2d808bddd461eb35740cb2e242c1a91b3e" translate="yes" xml:space="preserve">
          <source>When processing queries that feature more than one token, FTS5 is sometimes able to determine that the query can be answered by inspecting a subset of a large instance-list. FTS3/4 almost always has to traverse entire instance-lists.</source>
          <target state="translated">둘 이상의 토큰이있는 쿼리를 처리 할 때 FTS5는 때때로 큰 인스턴스 목록의 하위 집합을 검사하여 쿼리에 응답 할 수 있는지 확인할 수 있습니다. FTS3 / 4는 거의 항상 전체 인스턴스 목록을 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4456c24b4cd85849eb2f816e79572b467a2fc07" translate="yes" xml:space="preserve">
          <source>When query results are sorted by an ORDER BY clause, values with storage class NULL come first, followed by INTEGER and REAL values interspersed in numeric order, followed by TEXT values in collating sequence order, and finally BLOB values in memcmp() order. No storage class conversions occur before the sort.</source>
          <target state="translated">쿼리 결과가 ORDER BY 절에 의해 정렬되면, 스토리지 클래스가 NULL 인 값이 먼저 오며 INTEGER 및 REAL 값이 숫자 순서로 삽입 된 다음 조합 순서 순서로 TEXT 값이오고 마지막으로 memcmp () 순서로 BLOB 값이옵니다. 정렬 전에 스토리지 클래스 변환이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e91e22fc8ff638a8787ffecd5d5f0df9da8787f3" translate="yes" xml:space="preserve">
          <source>When required to</source>
          <target state="translated">필요한 경우</target>
        </trans-unit>
        <trans-unit id="78c613e6d682faec6496ee4d9048bbcfd6d7d464" translate="yes" xml:space="preserve">
          <source>When required to append a</source>
          <target state="translated">추가해야 할 경우</target>
        </trans-unit>
        <trans-unit id="798519ed2b08664b52737ffba7c81753837b1259" translate="yes" xml:space="preserve">
          <source>When required to append a new database page to the database file, SQLite shall create a new</source>
          <target state="translated">데이터베이스 파일에 새 데이터베이스 페이지를 추가해야 할 경우 SQLite는 새 데이터베이스 페이지를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="6dcc88fffc3fe69f52028c8e6091eebcfd48e874" translate="yes" xml:space="preserve">
          <source>When required to attempt to detect a</source>
          <target state="translated">감지하려고 할 때</target>
        </trans-unit>
        <trans-unit id="82187b34c5d14ea3c6cc853ad766ba3268f5b299" translate="yes" xml:space="preserve">
          <source>When required to end a</source>
          <target state="translated">종료해야 할 때</target>
        </trans-unit>
        <trans-unit id="baf01cea17946b2cb417992fd85480056f55712b" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page that existed and was not a</source>
          <target state="translated">존재하지만 존재하지 않는 기존 데이터베이스 페이지의 내용을 수정해야하는 경우</target>
        </trans-unit>
        <trans-unit id="ea12960936b78c03e66e4654443a0f13383a7001" translate="yes" xml:space="preserve">
          <source>When required to modify the contents of an existing database page, SQLite shall update the cached version of the database page content stored as part of the</source>
          <target state="translated">기존 데이터베이스 페이지의 내용을 수정해야하는 경우 SQLite는 캐시 된 버전의 데이터베이스 페이지 내용을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="72b58d5840f56734164db642d70a3df517a5e160" translate="yes" xml:space="preserve">
          <source>When required to open a</source>
          <target state="translated">열어야 할 때</target>
        </trans-unit>
        <trans-unit id="202f6940a3123823f29cdd85bae8600a952bce22" translate="yes" xml:space="preserve">
          <source>When required to perform</source>
          <target state="translated">수행해야 할 경우</target>
        </trans-unit>
        <trans-unit id="49e57edc72b2554b07e6deee46ce3f790b869e23" translate="yes" xml:space="preserve">
          <source>When required to purge a</source>
          <target state="translated">퍼지가 필요할 때</target>
        </trans-unit>
        <trans-unit id="96b4b0dc1d589faf2e657c0bc5a3a75b7b82c7c8" translate="yes" xml:space="preserve">
          <source>When required to truncate (remove) a database page that existed and was not a</source>
          <target state="translated">존재하고 있지 않은 데이터베이스 페이지를 자르기 (제거)해야 할 경우</target>
        </trans-unit>
        <trans-unit id="24c9b9293e0d1ee15b7fdaf8a59c9a8d10fd1c44" translate="yes" xml:space="preserve">
          <source>When required to truncate a database page from the end of the database file, SQLite shall discard the associated</source>
          <target state="translated">데이터베이스 파일의 끝에서 데이터베이스 페이지를 잘라야하는 경우 SQLite는 관련 페이지를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="150a8fe0ea2f86237f4f58257c9a767ee7e2a25a" translate="yes" xml:space="preserve">
          <source>When required to upgrade to an</source>
          <target state="translated">로 업그레이드해야 할 때</target>
        </trans-unit>
        <trans-unit id="fcba2e5b4c05a2548f809c299faee545560dd767" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">공유 캐시 모드에서 실행할 때 공유 캐시 또는 공유 캐시 내의 개별 테이블에 필요한 잠금을 확보 할 수 없으면 데이터베이스 조작이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 오류 와 함께 실패 할 수 있습니다. 공유 캐시 잠금에 대한 설명은 &lt;a href=&quot;sharedcache&quot;&gt;SQLite 공유 캐시 모드&lt;/a&gt; 를 참조하십시오 . 이 API는 현재 필요한 잠금을 보유한 연결이이를 해제 할 때 SQLite가 호출 할 콜백을 등록하는 데 사용될 수 있습니다. 이 API는 라이브러리가 &lt;a href=&quot;compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C 전 처리기 기호가 정의 되어 컴파일 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b02906105894d89f6847bc0868bb9a109b4e3e2a" translate="yes" xml:space="preserve">
          <source>When running in shared-cache mode, a database operation may fail with an &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; error if the required locks on the shared-cache or individual tables within the shared-cache cannot be obtained. See &lt;a href=&quot;../sharedcache&quot;&gt;SQLite Shared-Cache Mode&lt;/a&gt; for a description of shared-cache locking. This API may be used to register a callback that SQLite will invoke when the connection currently holding the required lock relinquishes it. This API is only available if the library was compiled with the &lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C-preprocessor symbol defined.</source>
          <target state="translated">공유 캐시 모드에서 실행할 때 공유 캐시 또는 공유 캐시 내의 개별 테이블에 필요한 잠금을 확보 할 수 없으면 데이터베이스 조작이 &lt;a href=&quot;../rescode#locked&quot;&gt;SQLITE_LOCKED&lt;/a&gt; 오류 와 함께 실패 할 수 있습니다. 공유 캐시 잠금에 대한 설명은 &lt;a href=&quot;../sharedcache&quot;&gt;SQLite 공유 캐시 모드&lt;/a&gt; 를 참조하십시오 . 이 API는 현재 필요한 잠금을 보유한 연결이이를 해제 할 때 SQLite가 호출 할 콜백을 등록하는 데 사용될 수 있습니다. 이 API는 라이브러리가 &lt;a href=&quot;../compile#enable_unlock_notify&quot;&gt;SQLITE_ENABLE_UNLOCK_NOTIFY&lt;/a&gt; C 전 처리기 기호가 정의 되어 컴파일 된 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2af0cef1a0b15f9849e9b4a326164320a983e665" translate="yes" xml:space="preserve">
          <source>When running on QNX, it is recommended that &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; never be used. Furthermore, to use &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;, it is recommended that applications employ the &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;exclusive locking mode&lt;/a&gt; in order to use &lt;a href=&quot;wal#noshm&quot;&gt;WAL without shared memory&lt;/a&gt;.</source>
          <target state="translated">QNX에서 실행할 때는 &lt;a href=&quot;mmap&quot;&gt;메모리 매핑 된 I / O를&lt;/a&gt; 사용하지 않는 것이 좋습니다 . 또한 &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; 를 사용하려면 응용 프로그램에서 &lt;a href=&quot;pragma#pragma_locking_mode&quot;&gt;독점 잠금 모드를&lt;/a&gt; 사용하는 것이 좋습니다. 를 사용하려면 &lt;a href=&quot;wal#noshm&quot;&gt;공유 메모리없이 WAL&lt;/a&gt; 을 사용하려면 를 .</target>
        </trans-unit>
        <trans-unit id="d6885131949093b9f2e26719d9e197b2addf166d" translate="yes" xml:space="preserve">
          <source>When safe append semantics are indicated for a filesystem, SQLite always stores the special value of -1 for the page count in the header of the rollback journal. The -1 page count value tells any process attempting to rollback the journal that the number of pages in the journal should be computed from the journal size. This -1 value is never changed. So that when a commit occurs, we save a single flush operation and a sector write of the first page of the journal file. Furthermore, when a cache spill occurs we no longer need to append a new journal header to the end of the journal; we can simply continue appending new pages to the end of the existing journal.</source>
          <target state="translated">파일 시스템에 안전한 추가 의미가 표시되면 SQLite는 항상 페이지 수에 대한 특수 값 -1을 롤백 저널의 헤더에 저장합니다. -1 페이지 수 값은 저널을 롤백하려는 모든 프로세스에 저널의 페이지 수를 저널 크기에서 계산해야 함을 알려줍니다. 이 -1 값은 변경되지 않습니다. 커밋이 발생하면 단일 플러시 작업과 저널 파일의 첫 페이지에 대한 섹터 쓰기를 저장합니다. 또한 캐시 유출이 발생하면 더 이상 저널 끝에 새 저널 헤더를 추가 할 필요가 없습니다. 기존 저널 끝에 새 페이지를 계속 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c52209ae5a29283cfe5cb3dad1ce0ecd4b45279f" translate="yes" xml:space="preserve">
          <source>When sector writes are atomic and the page size of a database is the same as a sector size, and when there is a database change that only touches a single database page, then SQLite skips the whole journaling and syncing process and simply writes the modified page directly into the database file. The change counter in the first page of the database file is modified separately since no harm is done if power is lost before the change counter can be updated.</source>
          <target state="translated">섹터 쓰기가 원 자성이고 데이터베이스의 페이지 크기가 섹터 크기와 같고 단일 데이터베이스 페이지에만 닿는 데이터베이스 변경이있는 경우 SQLite는 전체 저널링 및 동기화 프로세스를 건너 뛰고 수정 된 페이지를 작성합니다. 데이터베이스 파일에 직접. 데이터베이스 파일의 첫 페이지에있는 변경 카운터는 변경 카운터를 업데이트하기 전에 전원이 끊기면 아무런 해가 없기 때문에 별도로 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="340896b0a1241236bc1bf669ed9b704188faab52" translate="yes" xml:space="preserve">
          <source>When selecting the order of tables in a join, SQLite uses an efficient polynomial-time algorithm. Because of this, SQLite is able to plan queries with 50- or 60-way joins in a matter of microseconds</source>
          <target state="translated">조인에서 테이블 순서를 선택할 때 SQLite는 효율적인 다항식 시간 알고리즘을 사용합니다. 이로 인해 SQLite는 마이크로 초 단위로 50 또는 60 방향 조인으로 쿼리를 계획 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1aebe3c7de990f7af4ad0100f2e7e450c502bae1" translate="yes" xml:space="preserve">
          <source>When set to the value &quot;fts3&quot;, the matchinfo option reduces the amount of information stored by FTS4 with the consequence that the &quot;l&quot; option of &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; is no longer available.</source>
          <target state="translated">&quot;fts3&quot;값으로 설정하면 matchinfo 옵션은 FTS4에 저장된 정보의 양을 줄여 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 의 &quot;l&quot;옵션을 더 이상 사용할 수 없게합니다.</target>
        </trans-unit>
        <trans-unit id="637783b2ffcae0b4a42a6035522c7dbcf1ec705e" translate="yes" xml:space="preserve">
          <source>When specifying insert mode, you have to give an extra argument which is the name of the table to be inserted into. For example:</source>
          <target state="translated">삽입 모드를 지정할 때 삽입 할 테이블의 이름 인 추가 인수를 제공해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b258d1afb6dda622a0743a2a73308bdb7445718" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">sqlite3_backup_step ()이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE&lt;/a&gt; 을 리턴 했거나 애플리케이션이 백업 조작을 포기하려면 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 을 sqlite3_backup_finish ()에 전달 하여 sqlite3_backup 을 삭제해야합니다 . sqlite3_backup_finish () 인터페이스는 &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체 와 관련된 모든 리소스를 해제 합니다. sqlite3_backup_step ()이 아직 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴하지 않은 경우 , 대상 데이터베이스에서 활성 쓰기 트랜잭션이 롤백됩니다. &lt;a href=&quot;#sqlite3_backup&quot;&gt;sqlite3_backup&lt;/a&gt; 개체가) 유효하지 않으며 sqlite3_backup_finish를 호출 (다음 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ff3c33367e6881dcf5fe599ab4cc7d4d94774505" translate="yes" xml:space="preserve">
          <source>When sqlite3_backup_step() has returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, or when the application wishes to abandon the backup operation, the application should destroy the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; by passing it to sqlite3_backup_finish(). The sqlite3_backup_finish() interfaces releases all resources associated with the &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object. If sqlite3_backup_step() has not yet returned &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt;, then any active write-transaction on the destination database is rolled back. The &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; object is invalid and may not be used following a call to sqlite3_backup_finish().</source>
          <target state="translated">sqlite3_backup_step ()이 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE&lt;/a&gt; 을 리턴 했거나 애플리케이션이 백업 조작을 포기하려면 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 을 sqlite3_backup_finish ()에 전달 하여 sqlite3_backup 을 삭제해야합니다 . sqlite3_backup_finish () 인터페이스는 &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 객체 와 관련된 모든 리소스를 해제 합니다. sqlite3_backup_step ()이 아직 &lt;a href=&quot;../rescode#done&quot;&gt;SQLITE_DONE을&lt;/a&gt; 리턴하지 않은 경우 , 대상 데이터베이스에서 활성 쓰기 트랜잭션이 롤백됩니다. &lt;a href=&quot;backup&quot;&gt;sqlite3_backup&lt;/a&gt; 개체가) 유효하지 않으며 sqlite3_backup_finish를 호출 (다음 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f11c5f277ff9a9bea3d1538e42d008cd96e6371c" translate="yes" xml:space="preserve">
          <source>When synchronous is FULL (2), the SQLite database engine will use the xSync method of the &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; to ensure that all content is safely written to the disk surface prior to continuing. This ensures that an operating system crash or power failure will not corrupt the database. FULL synchronous is very safe, but it is also slower. FULL is the most commonly used synchronous setting when not in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">동기가 FULL (2) 인 경우 SQLite 데이터베이스 엔진은 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 의 xSync 방법을 사용하여 계속하기 전에 모든 내용이 디스크 표면에 안전하게 기록되도록합니다. 이렇게하면 운영 체제 충돌 또는 정전이 데이터베이스를 손상시키지 않습니다. FULL 동기는 매우 안전하지만 느려집니다. FULL은 &lt;a href=&quot;wal&quot;&gt;WAL 모드에&lt;/a&gt; 있지 않을 때 가장 일반적으로 사용되는 동기 설정 입니다.</target>
        </trans-unit>
        <trans-unit id="43aa9a49bc45ba6ec32647dc1c08a8d6748123c3" translate="yes" xml:space="preserve">
          <source>When synchronous is NORMAL (1), the SQLite database engine will still sync at the most critical moments, but less often than in FULL mode. There is a very small (though non-zero) chance that a power failure at just the wrong time could corrupt the database in &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt;=DELETE on an older filesystem. &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt; is safe from corruption with synchronous=NORMAL, and probably DELETE mode is safe too on modern filesystems. WAL mode is always consistent with synchronous=NORMAL, but WAL mode does lose durability. A transaction committed in WAL mode with synchronous=NORMAL might roll back following a power loss or system crash. Transactions are durable across application crashes regardless of the synchronous setting or journal mode. The synchronous=NORMAL setting is a good choice for most applications running in &lt;a href=&quot;wal&quot;&gt;WAL mode&lt;/a&gt;.</source>
          <target state="translated">동기가 NORMAL (1) 인 경우 SQLite 데이터베이스 엔진은 여전히 ​​가장 중요한 순간에 동기화되지만 FULL 모드보다 덜 자주 동기화됩니다. 잘못된 시간에 정전 으로 인해 오래된 파일 시스템의 &lt;a href=&quot;pragma#pragma_journal_mode&quot;&gt;journal_mode&lt;/a&gt; = DELETE 데이터베이스가 손상 될 가능성은 매우 적습니다 (0이 아님) . &lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt;synchronous = NORMAL을 사용하면 손상으로부터 안전하며 아마도 DELETE 모드는 최신 파일 시스템에서도 안전합니다. WAL 모드는 항상 synchronous = NORMAL과 일치하지만 WAL 모드는 내구성을 잃습니다. synchronous = NORMAL 인 WAL 모드에서 커밋 된 트랜잭션은 전원 손실 또는 시스템 충돌 후 롤백 될 수 있습니다. 동기 설정 또는 저널 모드에 관계없이 애플리케이션 충돌에서 트랜잭션이 지속됩니다. synchronous = NORMAL 설정은 다음에서 실행되는 대부분의 응용 프로그램에 적합합니다.&lt;a href=&quot;wal&quot;&gt;WAL 모드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1221ac9ca537e39eaf7a9c102f123b50e4ccafe2" translate="yes" xml:space="preserve">
          <source>When the &quot;write_version&quot; value of the database header is larger than what the library understands, make the database read-only instead of unreadable.</source>
          <target state="translated">데이터베이스 헤더의 &quot;write_version&quot;값이 라이브러리가 이해하는 것보다 큰 경우 데이터베이스를 읽을 수없는 대신 읽기 전용으로 만드십시오.</target>
        </trans-unit>
        <trans-unit id="14c5bdcdfec2d165a19969db87c59339f98d6d50" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#eval&quot;&gt;eval method&lt;/a&gt; sees a named SQL parameter such as &quot;$abc&quot; or &quot;:def&quot; or &quot;@ghi&quot; in an SQL statement, it tries to look up a TCL variable with the same name, and it binds the value of that TCL variable to the SQL parameter. If no such TCL variable exists, the default behavior is to bind an SQL NULL value to the parameter. However, if a bind_fallback proc is specified, then that proc is invoked with the name of the SQL parameter and the return value from the proc is bound to the SQL parameter. Or if the proc returns an error, then the SQL statement aborts with that error. If the proc returns with some code other than TCL_OK or TCL_ERROR, then the SQL parameter is bound to NULL, as it would be by default.</source>
          <target state="translated">때 &lt;a href=&quot;#eval&quot;&gt;평가 방법&lt;/a&gt; &quot;DEF&quot; &quot;$ ABC&quot;또는 같은 매개 변수 명명 된 SQL을보고 SQL 문에서 &quot;@ghi&quot;또는, 같은 이름의 TCL 변수를 검색하려고하고, 그 값을 결합 SQL 매개 변수에 대한 TCL 변수. 이러한 TCL 변수가 존재하지 않는 경우 기본 동작은 SQL NULL 값을 매개 변수에 바인드하는 것입니다. 그러나 bind_fallback proc이 지정된 경우 해당 proc은 SQL 매개 변수의 이름으로 호출되며 proc의 리턴 값은 SQL 매개 변수에 바인드됩니다. 또는 proc이 오류를 리턴하면 SQL 문이 해당 오류와 함께 중단됩니다. proc가 TCL_OK 또는 TCL_ERROR 이외의 코드로 리턴하면 SQL 매개 변수는 기본적으로 NULL로 바인드됩니다.</target>
        </trans-unit>
        <trans-unit id="e9681f846afb85497f8c3e1e346505a1d05e091c" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;min()&lt;/a&gt; or &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;max()&lt;/a&gt; aggregate functions are used in an aggregate query, all bare columns in the result set take values from the input row which also contains the minimum or maximum. So in the query above, the value of the &quot;b&quot; column in the output will be the value of the &quot;b&quot; column in the input row that has the largest &quot;c&quot; value. There is still an ambiguity if two or more of the input rows have the same minimum or maximum value or if the query contains more than one min() and/or max() aggregate function. Only the built-in &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min()&lt;/a&gt; and &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max()&lt;/a&gt; functions work this way.</source>
          <target state="translated">하면 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;분 ()&lt;/a&gt; 또는 &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;최대 ()&lt;/a&gt; 집계 함수 집합 쿼리에 사용되며, 또한 최소 또는 최대 값을 포함하는 입력 열에서 결과 집합 인출 값의 모든 컬럼 베어. 따라서 위의 쿼리에서 출력의 &quot;b&quot;열 값은 가장 큰 &quot;c&quot;값을 가진 입력 행의 &quot;b&quot;열 값입니다. 두 개 이상의 입력 행에 동일한 최소값 또는 최대 값이 있거나 쿼리에 둘 이상의 min () 및 / 또는 max () 집계 함수가 포함 된 경우에도 여전히 모호합니다. 내장 &lt;a href=&quot;lang_aggfunc#minggunc&quot;&gt;min ()&lt;/a&gt; 및 &lt;a href=&quot;lang_aggfunc#maxggunc&quot;&gt;max ()&lt;/a&gt; 함수 만이 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="56141e1c0fb6b7c512062b7753a9277ae3973fa7" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; statement to which the UPSERT is attached takes its values from a &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement, there is a potential parsing ambiguity. The parser might not be able to tell if the &quot;ON&quot; keyword is introducing the UPSERT or if it is the ON clause of a join. To work around this, the SELECT statement should always include a WHERE clause, even if that WHERE clause is just &quot;WHERE true&quot;.</source>
          <target state="translated">때 &lt;a href=&quot;lang_insert&quot;&gt;삽입&lt;/a&gt; UPSERT이 부착 된 문이에서 그 값을 사용 &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; 문, 잠재적 인 분석 모호성이있다. 구문 분석기가 &quot;ON&quot;키워드가 UPSERT를 도입하고 있는지 또는 그것이 조인의 ON 절인지를 알리지 못할 수 있습니다. 이 문제를 해결하려면 WHERE 절이 &quot;WHERE true&quot;인 경우에도 SELECT 문에 항상 WHERE 절이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="9d27fd39dc19689d64d7d12f5a355d4c7bb83355" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;lang_select&quot;&gt;SELECT&lt;/a&gt; statement that implements a &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; or FROM-clause subquery is a &lt;a href=&quot;lang_select#compound&quot;&gt;compound SELECT&lt;/a&gt; then the affinity of each supposed column of the VIEW or subquery will be the affinity of the corresponding result column for one of the individual SELECT statements that make up the compound. However, it is indeterminate which of the SELECT statements will be used to determine affinity. Different constituent SELECT statements might be used to determine affinity at different times during query evaluation. Best practice is to avoid mixing affinities in a compound SELECT.</source>
          <target state="translated">때 &lt;a href=&quot;lang_select&quot;&gt;SELECT의&lt;/a&gt; 문이 구현하는 &lt;a href=&quot;lang_createview&quot;&gt;VIEW&lt;/a&gt; 또는 FROM 절 하위 쿼리 A는 &lt;a href=&quot;lang_select#compound&quot;&gt;화합물을 선택&lt;/a&gt; 하고보기 또는 하위 쿼리의 각 가정 컬럼의 친화력이 화합물을 구성하는 개별 SELECT 문 중 하나에 해당하는 결과 컬럼의 친 화성이 될 것입니다 . 그러나 선호도를 결정하는 데 사용할 SELECT 문은 확실하지 않습니다. 쿼리 평가 중에 다른 시간에 선호도를 결정하기 위해 다른 구성 SELECT 문을 사용할 수 있습니다. 가장 좋은 방법은 화합물 SELECT에서 친 화성을 혼합하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="06ddddedda26385f60e680a5388eae9aa1b1f989" translate="yes" xml:space="preserve">
          <source>When the D parameter is not NULL, that means that ownership of the pointer is being transferred to SQLite. SQLite will take responsibility for freeing resources associated with the pointer when it has finished using the pointer. If the D parameter is NULL, that means that ownership of the pointer remains with the caller and the caller is responsible for disposing of the pointer.</source>
          <target state="translated">D 매개 변수가 NULL이 아닌 경우, 포인터의 소유권이 SQLite로 전송됨을 의미합니다. SQLite는 포인터 사용이 끝나면 포인터와 관련된 리소스를 해제해야합니다. D 매개 변수가 NULL 인 경우 포인터의 소유권은 호출자와 함께 유지되며 호출자는 포인터를 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="821f9322e2541019ba56eda61e1f81487c5db2ed" translate="yes" xml:space="preserve">
          <source>When the EXPLAIN keyword appears by itself it causes the statement to behave as a query that returns the sequence of &lt;a href=&quot;opcode&quot;&gt;virtual machine instructions&lt;/a&gt; it would have used to execute the command had the EXPLAIN keyword not been present. When the EXPLAIN QUERY PLAN phrase appears, the statement returns high-level information regarding the query plan that would have been used.</source>
          <target state="translated">EXPLAIN 키워드가 단독으로 표시되면 명령문 이 EXPLAIN 키워드가없는 경우 명령을 실행하는 데 사용 된 일련의 &lt;a href=&quot;opcode&quot;&gt;가상 머신 명령어&lt;/a&gt; 를 리턴하는 쿼리로 작동하게합니다 . EXPLAIN QUERY PLAN 구문이 나타나면 명령문은 사용 된 쿼리 계획에 대한 고급 정보를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0322a186c7875e9599006050d189bbd4680c31ba" translate="yes" xml:space="preserve">
          <source>When the ORDER BY clause is omitted from the recursive-select, the queue behaves as a FIFO, which results in a breadth-first search.</source>
          <target state="translated">재귀 선택에서 ORDER BY 절을 생략하면 큐가 FIFO로 동작하여 너비 우선 검색이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6f6a426144bea68a6a8caf2439e46959412cc8bf" translate="yes" xml:space="preserve">
          <source>When the PRAGMA vdbe_trace=ON is set, correctly print the P3 operand value when it is a pointer to a structure rather than a pointer to a string.</source>
          <target state="translated">PRAGMA vdbe_trace = ON이 설정되면 P3 피연산자 값이 문자열에 대한 포인터가 아닌 구조에 대한 포인터 일 때 올바르게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="de58aafb2b793ff0f7f439bee5ca0476571bc42c" translate="yes" xml:space="preserve">
          <source>When the Query Planner Stability Guarantee (QPSG) is enabled SQLite will always pick the same query plan for any given SQL statement as long as:</source>
          <target state="translated">QPSG (Query Planner Stability Guarantee)가 사용 가능한 경우 SQLite는 다음과 같은 경우 항상 주어진 SQL 문에 대해 동일한 쿼리 계획을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ea89f7d473effa3c1f787520608ed6a1d3dd75bc" translate="yes" xml:space="preserve">
          <source>When the REPLACE conflict resolution strategy deletes rows in order to satisfy a constraint, &lt;a href=&quot;lang_createtrigger&quot;&gt;delete triggers&lt;/a&gt; fire if and only if &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;recursive triggers&lt;/a&gt; are enabled.</source>
          <target state="translated">REPLACE 충돌 해결 전략이 제한 조건을 충족시키기 위해 행을 &lt;a href=&quot;lang_createtrigger&quot;&gt;삭제&lt;/a&gt; 하면 &lt;a href=&quot;pragma#pragma_recursive_triggers&quot;&gt;재귀 트리거&lt;/a&gt; 가 사용 가능한 경우에만 삭제 트리거 가 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="4ca0d858dd9858ff95b9e784a094d5524fe9f00c" translate="yes" xml:space="preserve">
          <source>When the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION compile-time option is activated, SQLite will suppress &quot;unknown function&quot; errors when running an &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; or &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;. Instead of throwing an error, SQLite will insert a substitute no-op function named &quot;unknown()&quot;. The substitution of &quot;unknown()&quot; in place of unrecognized functions only occurs on &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt;, not on ordinary statements.</source>
          <target state="translated">SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION 컴파일 타임 옵션이 활성화되면 SQLite는 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 또는 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN을&lt;/a&gt; 실행할 때 &quot;알 수없는 기능&quot;오류를 억제 합니다. 오류를 발생시키지 않고 SQLite는 &quot;unknown ()&quot;이라는 대체 no-op 함수를 삽입합니다. 인식 할 수없는 함수 대신 &quot;unknown ()&quot;의 대체는 일반 명령문이 아닌 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 및 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 에서만 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="18d1211c78f050ab2271d9386344a3bea2c6f673" translate="yes" xml:space="preserve">
          <source>When the SQLITE_SYNC_DATAONLY flag is used, it means that the sync operation only needs to flush data to mass storage. Inode information need not be flushed. If the lower four bits of the flag equal SQLITE_SYNC_NORMAL, that means to use normal fsync() semantics. If the lower four bits equal SQLITE_SYNC_FULL, that means to use Mac OS X style fullsync instead of fsync().</source>
          <target state="translated">SQLITE_SYNC_DATAONLY 플래그가 사용되면 동기화 조작은 데이터를 대량 스토리지로 플러시하기 만하면됨을 의미합니다. 아이 노드 정보를 비울 필요가 없습니다. 플래그의 하위 4 비트가 SQLITE_SYNC_NORMAL과 같으면 일반 fsync () 시맨틱을 사용한다는 의미입니다. 하위 4 비트가 SQLITE_SYNC_FULL과 같으면 fsync () 대신 Mac OS X 스타일의 fullsync를 사용한다는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="985e39e22f124ec3b4d15128274a9355a9afbb19" translate="yes" xml:space="preserve">
          <source>When the WHERE is omitted from a DELETE statement and the table being deleted has no triggers, SQLite uses an optimization to erase the entire table content without having to visit each row of the table individually. This &quot;truncate&quot; optimization makes the delete run much faster. Prior to SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12), the truncate optimization also meant that the &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes()&lt;/a&gt; and &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes()&lt;/a&gt; interfaces and the &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; will not actually return the number of deleted rows. That problem has been fixed as of &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;version 3.6.5&lt;/a&gt; (2008-11-12).</source>
          <target state="translated">WHERE가 DELETE 문에서 생략되고 삭제중인 테이블에 트리거가없는 경우 SQLite는 최적화를 사용하여 테이블의 각 행을 개별적으로 방문하지 않고 전체 테이블 컨텐츠를 지우십시오. 이 &quot;잘라 내기&quot;최적화는 삭제 실행을 훨씬 빠르게 만듭니다. SQLite &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;버전 3.6.5&lt;/a&gt; (2008-11-12) 이전에는 자르기 최적화에서 &lt;a href=&quot;c3ref/changes&quot;&gt;sqlite3_changes ()&lt;/a&gt; 및 &lt;a href=&quot;c3ref/total_changes&quot;&gt;sqlite3_total_changes ()&lt;/a&gt; 인터페이스와 &lt;a href=&quot;pragma#pragma_count_changes&quot;&gt;count_changes pragma&lt;/a&gt; 가 실제로 삭제 된 행 수를 반환하지 않음을 의미했습니다. 이 문제는 &lt;a href=&quot;https://sqlite.org/releaselog/3_6_5.html&quot;&gt;버전 3.6.5&lt;/a&gt; (2008-11-12) 부터 수정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ed1319f0bc1a6521bcf2196280e7316235700141" translate="yes" xml:space="preserve">
          <source>When the above CREATE VIRTUAL TABLE statement is executed, swarmvtab binds the text value &quot;/home/user/app/databases/&quot; to the :dir parameter of the SQL statement before executing it.</source>
          <target state="translated">위의 CREATE VIRTUAL TABLE 문이 실행될 때 swarmvtab은 텍스트 값 &quot;/ home / user / app / databases /&quot;를 실행하기 전에 SQL 문의 : dir 매개 변수에 바인드합니다.</target>
        </trans-unit>
        <trans-unit id="af84afd9d831ba7532e3be1008b7a2fa2d6de72c" translate="yes" xml:space="preserve">
          <source>When the auto-vacuum mode is 1 or &quot;full&quot;, the freelist pages are moved to the end of the database file and the database file is truncated to remove the freelist pages at every transaction commit. Note, however, that auto-vacuum only truncates the freelist pages from the file. Auto-vacuum does not defragment the database nor repack individual database pages the way that the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command does. In fact, because it moves pages around within the file, auto-vacuum can actually make fragmentation worse.</source>
          <target state="translated">자동 진공 모드가 1 또는 &quot;전체&quot;인 경우, 프리리스트 페이지는 데이터베이스 파일의 끝으로 이동하고 모든 트랜잭션 커밋에서 프리리스트 페이지를 제거하기 위해 데이터베이스 파일이 잘립니다. 그러나 자동 진공은 파일에서 프리리스트 페이지 만 자릅니다. 자동 진공은 데이터베이스를 조각 모음하거나 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 수행 하는 방식으로 개별 데이터베이스 페이지를 다시 포장 하지 않습니다. 실제로 파일 내에서 페이지를 이동하기 때문에 자동 진공은 실제로 조각화를 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef4d832eb7039ef85ce7ded8003003dd3cc72641" translate="yes" xml:space="preserve">
          <source>When the auto_vacuum pragma is invoked with no arguments, it returns the current auto_vacuum mode.</source>
          <target state="translated">auto_vacuum pragma가 인수없이 호출되면 현재 auto_vacuum 모드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f2ce457b213b80c33d7ab3d10e7347a9c292b2e3" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">콜백이 호출되면 첫 번째 인수는 sqlite3_collation_needed () 또는 sqlite3_collation_needed16 ()에 대한 두 번째 인수의 사본입니다. 두 번째 인수는 데이터베이스 연결입니다. 세 번째 인수는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ANY&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 중 하나이며 , 필요한 조합 순서 함수의 가장 바람직한 형식을 나타냅니다. 네 번째 매개 변수는 필요한 조합 순서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7ee3c7dd196b6cbe2c4c2e3d7d3e7a9d7a6a2b67" translate="yes" xml:space="preserve">
          <source>When the callback is invoked, the first argument passed is a copy of the second argument to sqlite3_collation_needed() or sqlite3_collation_needed16(). The second argument is the database connection. The third argument is one of &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt;, &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt;, or &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt;, indicating the most desirable form of the collation sequence function required. The fourth parameter is the name of the required collation sequence.</source>
          <target state="translated">콜백이 호출되면 첫 번째 인수는 sqlite3_collation_needed () 또는 sqlite3_collation_needed16 ()에 대한 두 번째 인수의 사본입니다. 두 번째 인수는 데이터베이스 연결입니다. 세 번째 인수는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF8&lt;/a&gt; , &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16BE&lt;/a&gt; 또는 &lt;a href=&quot;c_any&quot;&gt;SQLITE_UTF16LE&lt;/a&gt; 중 하나이며 , 필요한 조합 순서 함수의 가장 바람직한 형식을 나타냅니다. 네 번째 매개 변수는 필요한 조합 순서의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f0027db967a591c65d48dbd0afc84a797aef3887" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">콜백이 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴하면 요청 된 조작이 정상 임을 의미합니다. 콜백이 &lt;a href=&quot;#SQLITE_DENY&quot;&gt;SQLITE_DENY를&lt;/a&gt; 리턴 하면 권한 부여 자를 트리거 한 &lt;a href=&quot;#sqlite3_prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 동등한 호출이 실패하여 액세스가 거부되었다는 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1bae5c6c86ffd7028029909efdc71f4e4f816633" translate="yes" xml:space="preserve">
          <source>When the callback returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, that means the operation requested is ok. When the callback returns &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY&lt;/a&gt;, the &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2()&lt;/a&gt; or equivalent call that triggered the authorizer will fail with an error message explaining that access is denied.</source>
          <target state="translated">콜백이 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK를&lt;/a&gt; 리턴하면 요청 된 조작이 정상 임을 의미합니다. 콜백이 &lt;a href=&quot;c_deny&quot;&gt;SQLITE_DENY를&lt;/a&gt; 리턴 하면 권한 부여 자를 트리거 한 &lt;a href=&quot;prepare&quot;&gt;sqlite3_prepare_v2 ()&lt;/a&gt; 또는 동등한 호출이 실패하여 액세스가 거부되었다는 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2fc4782b077cfef78fd1da131f206927c4488a10" translate="yes" xml:space="preserve">
          <source>When the command-line shell and the core SQLite library are both compiled with &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; and SQLITE_ENABLE_SELECTTRACE and SQLITE_ENABLE_WHERETRACE, then the shell has two commands used to turn on debugging facilities for the most intricate parts of the code generator - the logic dealing with SELECT statements and WHERE clauses, respectively. The &quot;.selecttrace&quot; and &quot;.wheretrace&quot; commands each take a numeric argument which can be expressed in hexadecimal. Each bit turns on various parts of debugging. Values of &quot;0xfff&quot; and &quot;0xff&quot; are commonly used. Use an argument of &quot;0&quot; to turn all tracing output back off.</source>
          <target state="translated">명령 행 쉘과 코어 SQLite 라이브러리가 모두 &lt;a href=&quot;compile#debug&quot;&gt;SQLITE_DEBUG&lt;/a&gt; 및 SQLITE_ENABLE_SELECTTRACE 및 SQLITE_ENABLE_WHERETRACE로 컴파일 되면 쉘에는 코드 생성기의 가장 복잡한 부분에 대한 디버깅 기능을 설정하는 데 사용되는 두 개의 명령 (SELECT 문 및 WHERE 절. &quot;.selecttrace&quot;및 &quot;.wheretrace&quot;명령은 각각 16 진수로 표현할 수있는 숫자 인수를 사용합니다. 각 비트는 다양한 디버깅 부분을 켭니다. &quot;0xfff&quot;및 &quot;0xff&quot;값이 일반적으로 사용됩니다. 모든 추적 출력을 다시 끄려면 &quot;0&quot;인수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b723658445ef923fc3e6ed08d931b577b65bc748" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">확약 후크 콜백 루틴이 0을 리턴하면 &lt;a href=&quot;../lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 조작이 정상적으로 계속 될 수 있습니다. 커밋 후크가 0이 아닌 값을 반환하면&lt;a href=&quot;../lang_transaction&quot;&gt; COMMIT&lt;/a&gt; 는 &lt;a href=&quot;../lang_transaction&quot;&gt;ROLLBACK으로&lt;/a&gt; 변환됩니다 . 롤백 훅은 다른 롤백과 마찬가지로 커밋 훅이 0이 아닌 값을 반환하는 롤백에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0bc375382d425cd0a289c0d31fef27fb453ac2" translate="yes" xml:space="preserve">
          <source>When the commit hook callback routine returns zero, the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; operation is allowed to continue normally. If the commit hook returns non-zero, then the &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; is converted into a &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK&lt;/a&gt;. The rollback hook is invoked on a rollback that results from a commit hook returning non-zero, just as it would be with any other rollback.</source>
          <target state="translated">확약 후크 콜백 루틴이 0을 리턴하면 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 조작이 정상적으로 계속 될 수 있습니다. 커밋 후크가 0이 아닌 값을 반환하면 &lt;a href=&quot;lang_transaction&quot;&gt;COMMIT&lt;/a&gt; 는 &lt;a href=&quot;lang_transaction&quot;&gt;ROLLBACK으로&lt;/a&gt; 변환됩니다 . 롤백 훅은 다른 롤백과 마찬가지로 커밋 훅이 0이 아닌 값을 반환하는 롤백에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ebd93d5d1aa49a1f19ce4e8d40b4dcf35920ce66" translate="yes" xml:space="preserve">
          <source>When the defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; is on, enforcement of all &lt;a href=&quot;foreignkeys&quot;&gt;foreign key constraints&lt;/a&gt; is delayed until the outermost transaction is committed. The defer_foreign_keys pragma defaults to OFF so that foreign key constraints are only deferred if they are created as &quot;DEFERRABLE INITIALLY DEFERRED&quot;. The defer_foreign_keys pragma is automatically switched off at each COMMIT or ROLLBACK. Hence, the defer_foreign_keys pragma must be separately enabled for each transaction. This pragma is only meaningful if foreign key constraints are enabled, of course.</source>
          <target state="translated">defer_foreign_keys &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 가 설정되면 가장 외부 트랜잭션이 커밋 될 때까지 모든 &lt;a href=&quot;foreignkeys&quot;&gt;외래 키 제약 조건의 적용&lt;/a&gt; 이 지연됩니다. defer_foreign_keys pragma는 기본적으로 OFF로 설정되어 있으므로 외래 키 제약 조건이 &quot;DEFERRABLE INITIALLY DEFERRED&quot;로 생성 된 경우에만 지연됩니다. defer_foreign_keys pragma는 각 COMMIT 또는 ROLLBACK에서 자동으로 꺼집니다. 따라서 defer_foreign_keys pragma는 각 트랜잭션마다 별도로 활성화되어야합니다. 물론이 pragma는 외래 키 제약 조건이 활성화 된 경우에만 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4cc14d79785a0eab23a6d9f7db6c91e125bbb70" translate="yes" xml:space="preserve">
          <source>When the end-user executes a DML or DDL SQL statement to modify the database schema or content, SQLite is required to update the database file image to reflect the new database state. This involves modifying the content of, appending or truncating one of more database file pages. Instead of modifying the database file directly using the VFS interface, changes are first buffered within the</source>
          <target state="translated">최종 사용자가 데이터베이스 스키마 또는 컨텐츠를 수정하기 위해 DML 또는 DDL SQL 문을 실행할 때 SQLite는 새 데이터베이스 상태를 반영하도록 데이터베이스 파일 이미지를 업데이트해야합니다. 여기에는 하나 이상의 데이터베이스 파일 페이지 내용을 수정하거나 추가 또는 잘라내는 작업이 포함됩니다. VFS 인터페이스를 사용하여 데이터베이스 파일을 직접 수정하는 대신 변경 사항이 먼저</target>
        </trans-unit>
        <trans-unit id="e72b791ecc5f4b31b8f87177039bb7c97a3857b6" translate="yes" xml:space="preserve">
          <source>When the languageid option is present, it specifies the name of another &lt;a href=&quot;vtab#hiddencol&quot;&gt;hidden column&lt;/a&gt; that is added to the FTS4 table and which is used to specify the language stored in each row of the FTS4 table. The name of the languageid hidden column must be distinct from all other column names in the FTS4 table. Example:</source>
          <target state="translated">languageid 옵션이 있으면 FTS4 테이블에 추가되고 FTS4 테이블의 각 행에 저장된 언어를 지정하는 데 사용되는 다른 &lt;a href=&quot;vtab#hiddencol&quot;&gt;숨겨진 열의&lt;/a&gt; 이름 을 지정합니다. languageid 숨겨진 열의 이름은 FTS4 테이블의 다른 모든 열 이름과 달라야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="b1e38f0c1dabd3714310eefb8d8a6cff4de89d44" translate="yes" xml:space="preserve">
          <source>When the languageid option is used, SQLite invokes the xLanguageid() on the sqlite3_tokenizer_module object immediately after the object is created in order to pass in the language id that the tokenizer should use. The xLanguageid() method will never be called more than once for any single tokenizer object. The fact that different languages might be tokenized differently is one reason why no single FTS query can return rows with different languageid values.</source>
          <target state="translated">languageid 옵션이 사용되면 SQLite는 토크 나이저가 사용해야하는 언어 ID를 전달하기 위해 오브젝트가 작성된 직후 sqlite3_tokenizer_module 오브젝트에서 xLanguageid ()를 호출합니다. 단일 토크 나이저 객체에 대해 xLanguageid () 메서드가 두 번 이상 호출되지 않습니다. 다른 언어가 다르게 토큰 화 될 수 있다는 사실은 단일 FTS 쿼리가 다른 언어 ID 값을 가진 행을 반환 할 수없는 이유 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="9aa0a1cde451597b6df45b6c556052ff5eb9c927" translate="yes" xml:space="preserve">
          <source>When the last connection to a particular database is closing, that connection will acquire an exclusive lock for a short time while it cleans up the WAL and shared-memory files. If a second database tries to open and query the database while the first connection is still in the middle of its cleanup process, the second connection might get an &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; error.</source>
          <target state="translated">특정 데이터베이스에 대한 마지막 연결이 닫히면 해당 연결은 WAL 및 공유 메모리 파일을 정리하는 동안 짧은 시간 동안 독점 잠금을 획득합니다. 첫 번째 연결이 여전히 정리 프로세스 중일 때 두 번째 데이터베이스가 데이터베이스를 열고 쿼리하려고하면 두 번째 연결에 &lt;a href=&quot;rescode#busy&quot;&gt;SQLITE_BUSY&lt;/a&gt; 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="721a001d639a4fa0bf082ab41646b624fe82e4a7" translate="yes" xml:space="preserve">
          <source>When the legacy_file_format pragma is issued with no argument, it returns the setting of the flag. This pragma does &lt;u&gt;not&lt;/u&gt; tell which file format the current database is using; it tells what format will be used by any newly created databases.</source>
          <target state="translated">legacy_file_format pragma가 인수없이 발행되면 플래그 설정을 리턴합니다. 이 pragma는 현재 데이터베이스가 사용하고있는 파일 형식을 알려주지 &lt;u&gt;않습니다&lt;/u&gt; . 새로 작성된 데이터베이스가 어떤 형식을 사용할 것인지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="6a4f25a9dc00e5fa108cea204a933cd9b0d930ee" translate="yes" xml:space="preserve">
          <source>When the locking_mode pragma specifies a particular database, for example:</source>
          <target state="translated">locking_mode pragma가 특정 데이터베이스를 지정하는 경우 (예 :</target>
        </trans-unit>
        <trans-unit id="65958bd909cd29c71d7062800a7ff7cb762631b5" translate="yes" xml:space="preserve">
          <source>When the name of the database file handed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt; or to &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; is an empty string, then a new temporary file is created to hold the database.</source>
          <target state="translated">&lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; 또는 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 로 전달 된 데이터베이스 파일 이름이 빈 문자열 인 경우 데이터베이스를 보유하기 위해 새 임시 파일이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a5261e01bfb3de59bf05674e0d1d120422019175" translate="yes" xml:space="preserve">
          <source>When the original content of a database page is written into the rollback journal (as shown in &lt;a href=&quot;#section_3_5&quot;&gt;section 3.5&lt;/a&gt;), SQLite always writes a complete sector of data, even if the page size of the database is smaller than the sector size. Historically, the sector size in SQLite has been hard coded to 512 bytes and since the minimum page size is also 512 bytes, this has never been an issue. But beginning with SQLite version 3.3.14, it is possible for SQLite to use mass storage devices with a sector size larger than 512 bytes. So, beginning with version 3.3.14, whenever any page within a sector is written into the journal file, all pages in that same sector are stored with it.</source>
          <target state="translated">데이터베이스 페이지의 원래 컨텐츠가 롤백 저널에 기록되면 ( &lt;a href=&quot;#section_3_5&quot;&gt;섹션 3.5&lt;/a&gt; 참조) SQLite는 데이터베이스의 페이지 크기가 섹터 크기보다 작더라도 항상 전체 데이터 섹터를 기록합니다. 역사적으로 SQLite의 섹터 크기는 512 바이트로 하드 코딩되었으며 최소 페이지 크기도 512 바이트이므로이 문제는 발생하지 않았습니다. 그러나 SQLite 버전 3.3.14부터는 SQLite가 섹터 크기가 512 바이트보다 큰 대용량 저장 장치를 사용할 수 있습니다. 따라서 버전 3.3.14부터 섹터 내의 페이지가 저널 파일에 기록 될 때마다 동일한 섹터의 모든 페이지가 함께 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="24eb3cec7d166e89084624729f4f076ba57699a6" translate="yes" xml:space="preserve">
          <source>When the payload of a b-tree cell is too large for the b-tree page, the surplus is spilled onto overflow pages. Overflow pages form a linked list. The first four bytes of each overflow page are a big-endian integer which is the page number of the next page in the chain, or zero for the final page in the chain. The fifth byte through the last usable byte are used to hold overflow content.</source>
          <target state="translated">b- 트리 셀의 페이로드가 b- 트리 페이지에 비해 너무 크면 잉여가 오버플로 페이지에 쏟아집니다. 오버플로 페이지는 연결된 목록을 형성합니다. 각 오버 플로우 페이지의 첫 4 바이트는 체인의 다음 페이지의 페이지 번호이거나 체인의 마지막 페이지의 경우 0 인 빅 엔디안 정수입니다. 사용 가능한 마지막 바이트부터 5 번째 바이트는 오버 플로우 컨텐츠를 보유하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a9dfbcbb999703cb3d0ac4b512f0bf41cd8632a" translate="yes" xml:space="preserve">
          <source>When the private repository is created by cloning, incorporating new public SQLite releases becomes much easier too. To pull in all of the latest changes from the public SQLite repository, simply move into the open check-out and do:</source>
          <target state="translated">복제하여 개인 저장소를 작성하면 새로운 공용 SQLite 릴리스를 통합하는 것이 훨씬 쉬워집니다. 공개 SQLite 저장소에서 최신 변경 사항을 모두 가져 오려면 공개 체크 아웃으로 이동하여 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5be9656f401ac8804b83b6da6efba9e4ec09be72" translate="yes" xml:space="preserve">
          <source>When the result of a sub-select is a scalar, a single private memory cell can be used, as shown in the previous example. But when the result of a sub-select is a vector, such as when the sub-select is the right-hand operand of IN or NOT IN, a different approach is needed. In this case, the result of the sub-select is stored in a transient table and the contents of that table are tested using the Found or NotFound operators. Consider this example:</source>
          <target state="translated">하위 선택의 결과가 스칼라 인 경우 이전 예와 같이 단일 개인용 메모리 셀을 사용할 수 있습니다. 그러나 하위 선택이 IN 또는 NOT IN의 오른쪽 피연산자 인 경우와 같이 하위 선택의 결과가 벡터 인 경우 다른 접근 방식이 필요합니다. 이 경우 부속 선택의 결과는 임시 테이블에 저장되며 해당 테이블의 내용은 Found 또는 NotFound 연산자를 사용하여 테스트됩니다. 이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7f4bad19a801621b1eda251a27bffb8486beb1b2" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;../threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">직렬화 된 &lt;a href=&quot;../threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 사용중인 경우 첫 번째 오류 시간과 이러한 인터페이스 호출 사이에 별도의 스레드에서 두 번째 오류가 발생할 수 있습니다. 이러한 상황이 발생하면 두 번째 오류가보고됩니다. 이러한 인터페이스는 항상 최신 결과를보고하기 때문입니다. 이를 방지하려면, 각 스레드는 전용 얻을 수있는 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 호출하여 D를 &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt; ( &lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; D를 사용하기 시작하고 호출하기 전에 (D))를 &lt;a href=&quot;mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt; ( &lt;a href=&quot;db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; 완료 여기에 나열된 인터페이스에 대한 모든 호출 후 (D)를).</target>
        </trans-unit>
        <trans-unit id="6ad35aaaabcdc79e64145d3f60787d98e09a5e23" translate="yes" xml:space="preserve">
          <source>When the serialized &lt;a href=&quot;threadsafe&quot;&gt;threading mode&lt;/a&gt; is in use, it might be the case that a second error occurs on a separate thread in between the time of the first error and the call to these interfaces. When that happens, the second error will be reported since these interfaces always report the most recent result. To avoid this, each thread can obtain exclusive use of the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; D by invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) before beginning to use D and invoking &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt;(&lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt;(D)) after all calls to the interfaces listed here are completed.</source>
          <target state="translated">직렬화 된 &lt;a href=&quot;threadsafe&quot;&gt;스레딩 모드&lt;/a&gt; 를 사용중인 경우 첫 번째 오류 시간과 이러한 인터페이스 호출 사이에 별도의 스레드에서 두 번째 오류가 발생할 수 있습니다. 이러한 상황이 발생하면 두 번째 오류가보고됩니다. 이러한 인터페이스는 항상 최신 결과를보고하기 때문입니다. 이를 방지하려면, 각 스레드는 전용 얻을 수있는 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 호출하여 D를 &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_enter&lt;/a&gt; ( &lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; D를 사용하기 시작하고 호출하기 전에 (D))를 &lt;a href=&quot;#sqlite3_mutex_alloc&quot;&gt;sqlite3_mutex_leave&lt;/a&gt; ( &lt;a href=&quot;#sqlite3_db_mutex&quot;&gt;sqlite3_db_mutex&lt;/a&gt; 완료 여기에 나열된 인터페이스에 대한 모든 호출 후 (D)를).</target>
        </trans-unit>
        <trans-unit id="ae5d894865b3485bb3f0df9031d208d9c0c832c5" translate="yes" xml:space="preserve">
          <source>When the size of payload for a cell exceeds a certain threshold (to be defined later) then only the first few bytes of the payload are stored on the b-tree page and the balance is stored in a linked list of content overflow pages.</source>
          <target state="translated">셀에 대한 페이로드의 크기가 특정 임계 값 (나중에 정의 됨)을 초과하면 페이로드의 처음 몇 바이트 만 b- 트리 페이지에 저장되고 잔액은 링크 된 컨텐츠 오버 플로우 페이지 목록에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="959baafa9a7af49bb6654912e390fd8adf72f9f7" translate="yes" xml:space="preserve">
          <source>When the steps above are used, SQLite will shorten filename extensions by only using the last 3 characters of the extension. Thus, for example, a file that would normally be called &quot;&lt;code&gt;app.db-journal&lt;/code&gt;&quot; is shortened to just &quot;&lt;code&gt;app.nal&lt;/code&gt;&quot;. Similarly, &quot;&lt;code&gt;app.db-wal&lt;/code&gt;&quot; will become &quot;&lt;code&gt;app.wal&lt;/code&gt;&quot; and &quot;&lt;code&gt;app.db-shm&lt;/code&gt;&quot; becomes &quot;&lt;code&gt;app.shm&lt;/code&gt;&quot;.</source>
          <target state="translated">위의 단계를 사용하면 SQLite는 확장명의 마지막 3자를 사용하여 파일 이름 확장명을 줄입니다. 따라서, 예를 들어, 일반적으로 &quot;라는 것 파일 &lt;code&gt;app.db-journal&lt;/code&gt; &quot;그냥 &quot;로 단축 &lt;code&gt;app.nal&lt;/code&gt; &quot;. 마찬가지로 &quot; &lt;code&gt;app.db-wal&lt;/code&gt; &quot;은 &quot; &lt;code&gt;app.wal&lt;/code&gt; &quot;이되고 &quot; &lt;code&gt;app.db-shm&lt;/code&gt; &quot;은 &quot; &lt;code&gt;app.shm&lt;/code&gt; &quot;이됩니다.</target>
        </trans-unit>
        <trans-unit id="d643d5a9185e437164a5f2a6216624f98b3e6f19" translate="yes" xml:space="preserve">
          <source>When the temp_store_directory setting is changed, all existing temporary tables, indices, triggers, and viewers in the database connection that issued the pragma are immediately deleted. In practice, temp_store_directory should be set immediately after the first database connection for a process is opened. If the temp_store_directory is changed for one database connection while other database connections are open in the same process, then the behavior is undefined and probably undesirable.</source>
          <target state="translated">temp_store_directory 설정이 변경되면 pragma를 실행 한 데이터베이스 연결의 모든 기존 임시 테이블, 인덱스, 트리거 및 뷰어가 즉시 삭제됩니다. 실제로 temp_store_directory는 프로세스의 첫 번째 데이터베이스 연결을 연 직후에 설정해야합니다. 다른 데이터베이스 연결이 동일한 프로세스에서 열려있는 동안 한 데이터베이스 연결에 대해 temp_store_directory가 변경되면 동작이 정의되지 않아 바람직하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="343b5a2825eceb4a3f5768433d668b582d6b47c5" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is invoked, which may be before the thread that called &lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify()&lt;/a&gt; begins waiting for the asynchronous signal, it does the following:</source>
          <target state="translated">&lt;a href=&quot;c3ref/unlock_notify&quot;&gt;sqlite3_unlock_notify ()&lt;/a&gt; 라는 스레드가 비동기 신호 대기를 시작 하기 전에 잠금 해제 알림 콜백이 호출되면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b97add61bb2e4ac375ed3ff0cd6f248d8d0b370d" translate="yes" xml:space="preserve">
          <source>When the unlock-notify callback is issued, it is issued from within a call to sqlite3_step() (or sqlite3_close()) associated with the blocking connection. It is illegal to invoke any sqlite3_XXX() API functions from within an unlock-notify callback. The expected use is that the unlock-notify callback will signal some other waiting thread or schedule some action to take place later.</source>
          <target state="translated">잠금 해제 알림 콜백이 발행되면 차단 연결과 연관된 sqlite3_step () 또는 sqlite3_close ()에 대한 호출 내에서 발행됩니다. 잠금 해제 알림 콜백 내에서 sqlite3_XXX () API 함수를 호출하는 것은 불법입니다. 잠금 해제 알림 콜백은 다른 대기 스레드에 신호를 보내거나 나중에 수행 할 작업을 예약합니다.</target>
        </trans-unit>
        <trans-unit id="c2be91d4a681af8f031fb2096b9f2fe184670aea" translate="yes" xml:space="preserve">
          <source>When the user does a &quot;File/Save&quot;, instead of overwriting the modified slides, the application can now make new entries in the SLIDE table for just those slides that have been added or altered. Then it creates a new entry in the VERSION table containing the revised manifest.</source>
          <target state="translated">사용자가 수정 된 슬라이드를 덮어 쓰지 않고 &quot;파일 / 저장&quot;을 수행하면 이제 응용 프로그램은 추가되거나 변경된 슬라이드에 대해서만 SLIDE 테이블에 새 항목을 만들 수 있습니다. 그런 다음 수정 된 매니페스트가 포함 된 VERSION 테이블에 새 항목을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f5e82ec54c65035c07f8ba3e1f179ebb03a74e94" translate="yes" xml:space="preserve">
          <source>When the user presses the Undo button, invoke undo::undo. Invoke undo::redo when the user presses the Redo button.</source>
          <target state="translated">사용자가 실행 취소 버튼을 누르면 undo :: undo를 호출합니다. 사용자가 다시 실행 버튼을 누르면 undo :: redo를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="1add060c475b241a7872da34e121430f601e3935" translate="yes" xml:space="preserve">
          <source>When the user scrolls down, the application needs to find the second set of 7 entries. One way to do this is to use the OFFSET clause:</source>
          <target state="translated">사용자가 아래로 스크롤하면 응용 프로그램은 두 번째 7 개의 항목 세트를 찾아야합니다. 이를 수행하는 한 가지 방법은 OFFSET 절을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="591f64272639e3cef4d6af5b9d0166c866e319e8" translate="yes" xml:space="preserve">
          <source>When the value of auto-vacuum is 2 or &quot;incremental&quot; then the additional information needed to do auto-vacuuming is stored in the database file but auto-vacuuming does not occur automatically at each commit as it does with auto_vacuum=full. In incremental mode, the separate &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; pragma must be invoked to cause the auto-vacuum to occur.</source>
          <target state="translated">auto-vacuum의 값이 2 또는 &quot;증분&quot;인 경우 auto-vacuuming을 수행하는 데 필요한 추가 정보가 데이터베이스 파일에 저장되지만 auto_vacuum = full과 마찬가지로 커밋마다 auto-vacuuming이 자동으로 발생하지 않습니다. 증분 모드에서는 자동 진공이 발생 하도록 별도의 &lt;a href=&quot;pragma#pragma_incremental_vacuum&quot;&gt;incremental_vacuum&lt;/a&gt; pragma를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="681fab88c0ae33e7ccdb7976051e9eb1cbf3ae58" translate="yes" xml:space="preserve">
          <source>When the value returned to V is a string, space to hold that string is managed by the prepared statement S and will be automatically freed when S is finalized.</source>
          <target state="translated">V로 리턴 된 값이 문자열 인 경우 해당 문자열을 보유 할 공간은 준비된 명령문 S에 의해 관리되며 S가 완료되면 자동으로 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="676274b5ee061976c65b6934ef4f5a4fbd2b341f" translate="yes" xml:space="preserve">
          <source>When the wait_for_unlock_notify() thread is ready to begin waiting for the unlock-notify callback to arrive, it:</source>
          <target state="translated">wait_for_unlock_notify () 스레드가 잠금 해제 알림 콜백이 도착하기를 기다릴 준비가되면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="10e245699dbb244b04267cf604539f618d05ec7d" translate="yes" xml:space="preserve">
          <source>When there are &lt;a href=&quot;lang_attach&quot;&gt;attached databases&lt;/a&gt; and no database is specified in the pragma, all databases have their secure-delete setting altered. The secure-delete setting for newly attached databases is the setting of the main database at the time the ATTACH command is evaluated.</source>
          <target state="translated">이 때 &lt;a href=&quot;lang_attach&quot;&gt;데이터베이스를 연결&lt;/a&gt; 하고 어떤 데이터베이스가 프라 그마에 지정되지 않은 모든 데이터베이스는 보안-삭제 설정을 변경해야합니다. 새로 연결된 데이터베이스의 보안 삭제 설정은 ATTACH 명령을 평가할 때 기본 데이터베이스의 설정입니다.</target>
        </trans-unit>
        <trans-unit id="0e9e3d42daf92400d82986bf5b6a37eceed3828b" translate="yes" xml:space="preserve">
          <source>When this C-preprocessor macro is defined, SQLite includes some additional APIs that provide convenient access to meta-data about tables and queries. The APIs that are enabled by this option are:</source>
          <target state="translated">이 C-preprocessor 매크로가 정의되면 SQLite에는 테이블 및 쿼리에 대한 메타 데이터에 편리하게 액세스 할 수있는 추가 API가 포함됩니다. 이 옵션으로 활성화 된 API는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80b17e344d3336c6d06fda5d24a646acabeba334" translate="yes" xml:space="preserve">
          <source>When this function is called, the requested changeset is created using both the accumulated records and the current contents of the database file. Specifically:</source>
          <target state="translated">이 함수를 호출하면 누적 레코드와 데이터베이스 파일의 현재 내용을 모두 사용하여 요청 된 변경 세트가 작성됩니다. 구체적으로 특별히:</target>
        </trans-unit>
        <trans-unit id="bb6586ef4ac72fe83222f833701701fa936feb91" translate="yes" xml:space="preserve">
          <source>When this is defined, the library does not respect the special database name &quot;:memory:&quot; (normally used to create an &lt;a href=&quot;inmemorydb&quot;&gt;in-memory database&lt;/a&gt;). If &quot;:memory:&quot; is passed to &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open()&lt;/a&gt;, &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16()&lt;/a&gt;, or &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2()&lt;/a&gt;, a file with this name will be opened or created.</source>
          <target state="translated">이것이 정의되면 라이브러리는 특수 데이터베이스 이름 &quot;: memory :&quot;(일반적으로 &lt;a href=&quot;inmemorydb&quot;&gt;인 메모리 데이터베이스&lt;/a&gt; 를 작성하는 데 사용됨)를 고려하지 않습니다 . &quot;: memory :&quot;가 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open ()&lt;/a&gt; , &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open16 ()&lt;/a&gt; 또는 &lt;a href=&quot;c3ref/open&quot;&gt;sqlite3_open_v2 ()로 전달&lt;/a&gt; 되면이 이름의 파일이 열리거나 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9dadcf039e49017d2804dcadcaa92a2ed3ad29c4" translate="yes" xml:space="preserve">
          <source>When this is done, no disk file is opened. Instead, a new database is created purely in memory. The database ceases to exist as soon as the database connection is closed. Every :memory: database is distinct from every other. So, opening two database connections each with the filename &quot;:memory:&quot; will create two independent in-memory databases.</source>
          <target state="translated">이 작업이 완료되면 디스크 파일이 열리지 않습니다. 대신, 새로운 데이터베이스는 순수하게 메모리에 생성됩니다. 데이터베이스 연결이 닫히 자마자 데이터베이스가 존재하지 않습니다. Every : memory : 데이터베이스는 서로 다릅니다. 따라서 각각 파일 이름이 &quot;: memory :&quot;인 두 개의 데이터베이스 연결을 열면 두 개의 독립적 인 인 메모리 데이터베이스가 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="3c612857bb421bf9acf60c3aa66716a6889b3ef9" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;geopoly&quot;&gt;Geopoly extension&lt;/a&gt; is included in the build.</source>
          <target state="translated">이 옵션이 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 정의 되면 &lt;a href=&quot;geopoly&quot;&gt;Geopoly 확장&lt;/a&gt; 이 빌드에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="63b0e43097f54c25e3fe1c915efb4112c36433a7" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, the &lt;a href=&quot;json1&quot;&gt;JSON SQL functions&lt;/a&gt; are added to the build automatically.</source>
          <target state="translated">이 옵션이 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 정의 되면 &lt;a href=&quot;json1&quot;&gt;JSON SQL 함수&lt;/a&gt; 가 빌드에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e638c666c14acfed829f561f8cba0197feda3c02" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, version 3 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">이 옵션이 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 정의 되면 전체 텍스트 검색 엔진의 버전 3이 빌드에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="4a19c3b55092d529dbfec770d25a58e2ca349990" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 3 and 4 of the full-text search engine is added to the build automatically.</source>
          <target state="translated">이 옵션이 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 정의 되면 전체 텍스트 검색 엔진의 버전 3 및 4가 빌드에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="818c376822c0fec952ac59c4332327f0b7edf7db" translate="yes" xml:space="preserve">
          <source>When this option is defined in the &lt;a href=&quot;amalgamation&quot;&gt;amalgamation&lt;/a&gt;, versions 5 of the full-text search engine (&lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt;) is added to the build automatically.</source>
          <target state="translated">이 옵션이 &lt;a href=&quot;amalgamation&quot;&gt;amalgamation에&lt;/a&gt; 정의 되면 전체 텍스트 검색 엔진 ( &lt;a href=&quot;fts5&quot;&gt;fts5&lt;/a&gt; ) 버전 5가 빌드에 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6540ae2c93aba220c991dfe94132dd0f63e59810" translate="yes" xml:space="preserve">
          <source>When this option is defined, an optimization that accelerates counting all entries in a table (in other words, an optimization that helps &quot;SELECT count(*) FROM table&quot; run faster) is omitted.</source>
          <target state="translated">이 옵션을 정의하면 테이블의 모든 항목 수를 빠르게 계산하는 최적화 (즉, &quot;SELECT count (*) FROM table&quot;실행 속도를 높이는 최적화)가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="53f492f476a20550a057a12a97c6de3049506d26" translate="yes" xml:space="preserve">
          <source>When this option is defined, it is not possible to specify a blob in an SQL statement using the X'ABCD' syntax.</source>
          <target state="translated">이 옵션이 정의되면 X'ABCD '구문을 사용하여 SQL 문에 Blob을 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="afad8ea069f34c202a3e893171214a5aee9a0bc0" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; command is not included in the library. Executing an &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 명령이 라이브러리에 포함되지 않습니다. &lt;a href=&quot;lang_altertable&quot;&gt;ALTER TABLE&lt;/a&gt; 문을 실행하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="523431ac75b0212a06c55ac385d13beeedacb305" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; command is omitted from the build.</source>
          <target state="translated">이 옵션이 정의되면 빌드에서 &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 명령이 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="594c7ba3832aba3180a92cd74c6f75ba44ce7aaf" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; and &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; commands are omitted from the build.</source>
          <target state="translated">이 옵션이 정의되면 &lt;a href=&quot;lang_attach&quot;&gt;ATTACH&lt;/a&gt; 및 &lt;a href=&quot;lang_detach&quot;&gt;DETACH&lt;/a&gt; 명령이 빌드에서 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1b711bd5c9246457da19791ca7b6dcb97ca5d2" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 명령이 라이브러리에 포함되지 않습니다. &lt;a href=&quot;lang_reindex&quot;&gt;REINDEX&lt;/a&gt; 문을 실행 하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d2955f48905e9a8f58404484936cbf538b367034" translate="yes" xml:space="preserve">
          <source>When this option is defined, the &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; command is not included in the library. Executing a &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; statement causes a parse error.</source>
          <target state="translated">이 옵션을 정의하면 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 명령이 라이브러리에 포함되지 않습니다. &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 문을 실행 하면 구문 분석 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f189302742f5abf29172e2258e929a776e965db1" translate="yes" xml:space="preserve">
          <source>When this option is present, content contained in &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;overflow pages&lt;/a&gt; of the database file is read directly from disk, bypassing the &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;page cache&lt;/a&gt;, during read transactions. In applications that do a lot of reads of large BLOBs, this option might improve read performance.</source>
          <target state="translated">이 옵션이 있으면 읽기 트랜잭션 중에 데이터베이스 파일의 &lt;a href=&quot;fileformat2#ovflpgs&quot;&gt;오버 플로우 페이지&lt;/a&gt; 에 포함 된 컨텐츠 를 디스크에서 직접 읽고 &lt;a href=&quot;c3ref/pcache_methods2&quot;&gt;페이지 캐시를&lt;/a&gt; 무시합니다 . 큰 BLOB를 많이 읽는 응용 프로그램에서이 옵션은 읽기 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05b6e594e4163ec73c013e9bc0bd201fec26dfcd" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;sqlite_master&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="translated">이 pragma가 켜져 있고 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 꺼져 &lt;a href=&quot;fileformat2#sqlite_master&quot;&gt;있으면&lt;/a&gt; 일반적인 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문을 사용하여 sqlite_master 테이블을 변경할 수 있습니다 . &lt;b&gt;경고 :&lt;/b&gt; 이 pragma를 잘못 사용하면 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;데이터베이스 파일&lt;/a&gt; 이 쉽게 손상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="155915a2fa0e144a28d6f3909aae6b1d4f21b4e3" translate="yes" xml:space="preserve">
          <source>When this pragma is on, and the &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; flag is off, then the &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; table can be changed using ordinary &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, and &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; statements. &lt;b&gt;Warning:&lt;/b&gt; misuse of this pragma can easily result in a &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;corrupt database file&lt;/a&gt;.</source>
          <target state="translated">이 pragma가 켜져 있고 &lt;a href=&quot;c3ref/c_dbconfig_defensive#sqlitedbconfigdefensive&quot;&gt;SQLITE_DBCONFIG_DEFENSIVE&lt;/a&gt; 플래그가 꺼져 있으면 &lt;a href=&quot;schematab&quot;&gt;sqlite_schema&lt;/a&gt; 테이블은 일반 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt; 및 &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt; 문을 사용하여 변경할 수 있습니다 . &lt;b&gt;경고 :&lt;/b&gt; 이 pragma를 잘못 사용하면 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;데이터베이스 파일&lt;/a&gt; 이 손상 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c24dad918c280682da96633e2cfedee92e2eb063" translate="yes" xml:space="preserve">
          <source>When three or more simple SELECTs are connected into a compound SELECT, they group from left to right. In other words, if &quot;A&quot;, &quot;B&quot; and &quot;C&quot; are all simple SELECT statements, (A op B op C) is processed as ((A op B) op C).</source>
          <target state="translated">세 개 이상의 간단한 SELECT가 복합 SELECT에 연결되면 왼쪽에서 오른쪽으로 그룹화됩니다. 즉, &quot;A&quot;, &quot;B&quot;및 &quot;C&quot;가 모두 간단한 SELECT 문인 경우 (A op B op C)는 ((A op B) op C)로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="356d225c15feaa12023968822303a920dbc04787" translate="yes" xml:space="preserve">
          <source>When to use WITHOUT ROWID</source>
          <target state="translated">WITHOUT ROWID를 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="dde1df06f3e28fa2c213af6dc7ee811081acdcc1" translate="yes" xml:space="preserve">
          <source>When two BLOB values are compared, the result is determined using memcmp().</source>
          <target state="translated">두 개의 BLOB 값을 비교할 때 memcmp ()를 사용하여 결과를 판별합니다.</target>
        </trans-unit>
        <trans-unit id="3b7477ad4142a17a91342e502a66554eeeaf182c" translate="yes" xml:space="preserve">
          <source>When two or more connections access the same database in shared-cache mode, read and write (shared and exclusive) locks on individual tables are used to ensure that concurrently executing transactions are kept isolated. Before writing to a table, a write (exclusive) lock must be obtained on that table. Before reading, a read (shared) lock must be obtained. A connection releases all held table locks when it concludes its transaction. If a connection cannot obtain a required lock, then the call to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; returns SQLITE_LOCKED.</source>
          <target state="translated">공유 캐시 모드에서 두 개 이상의 연결이 동일한 데이터베이스에 액세스하는 경우 개별 테이블에 대한 읽기 및 쓰기 (공유 및 독점) 잠금이 사용되어 동시에 실행되는 트랜잭션이 격리 된 상태로 유지됩니다. 테이블에 쓰기 전에 해당 테이블에서 쓰기 (배타적) 잠금을 확보해야합니다. 읽기 전에 읽기 (공유) 잠금을 얻어야합니다. 연결은 트랜잭션이 완료되면 모든 보유 테이블 잠금을 해제합니다. 연결이 필요한 잠금을 확보 할 수 없으면 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에&lt;/a&gt; 대한 호출 은 SQLITE_LOCKED를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="384b14b240303a8eaa803ae4a95a246eb3eb3a95" translate="yes" xml:space="preserve">
          <source>When two or more connections use a shared-cache, locks are used to serialize concurrent access attempts on a per-table basis. Tables support two types of locks, &quot;read-locks&quot; and &quot;write-locks&quot;. Locks are granted to connections - at any one time, each database connection has either a read-lock, write-lock or no lock on each database table.</source>
          <target state="translated">둘 이상의 연결이 공유 캐시를 사용하는 경우 잠금은 테이블별로 동시 액세스 시도를 직렬화하는 데 사용됩니다. 테이블은 &quot;읽기 잠금&quot;과 &quot;쓰기 잠금&quot;의 두 가지 유형의 잠금을 지원합니다. 잠금은 연결에 부여됩니다-언제든지 각 데이터베이스 연결에는 각 데이터베이스 테이블에 대한 읽기 잠금, 쓰기 잠금 또는 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="9ef3f52e6658347244503cf695a84d552443a0f6" translate="yes" xml:space="preserve">
          <source>When unlocking, the same SHARED or EXCLUSIVE flag must be supplied as was given on the corresponding lock.</source>
          <target state="translated">잠금을 해제 할 때 해당 잠금에 제공된 것과 동일한 SHARED 또는 EXCLUSIVE 플래그를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="c942e92dfd8f19ebf7cd74cbba74f891e087e57f" translate="yes" xml:space="preserve">
          <source>When updating the database file, SQLite always makes a copy of the page content into heap memory before modifying the page. This is necessary for two reasons. First, changes to the database are not supposed to be visible to other processes until after the transaction commits and so the changes must occur in private memory. Second, SQLite uses a read-only memory map to prevent stray pointers in the application from overwriting and corrupting the database file.</source>
          <target state="translated">데이터베이스 파일을 업데이트 할 때 SQLite는 페이지를 수정하기 전에 항상 페이지 내용의 복사본을 힙 메모리로 만듭니다. 이것은 두 가지 이유로 필요합니다. 먼저, 트랜잭션이 커밋 된 후에야 데이터베이스에 대한 변경 내용이 다른 프로세스에 표시되지 않아야하므로 변경 사항은 개인 메모리에서 발생해야합니다. 둘째, SQLite는 읽기 전용 메모리 맵을 사용하여 응용 프로그램의 스트레이 포인터가 데이터베이스 파일을 덮어 쓰거나 손상시키지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="321ab4dcceec298b077cdbf468b4b448206d5be8" translate="yes" xml:space="preserve">
          <source>When used in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;, the SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION feature allows SQL text that contains application-defined functions to be pasted into the shell for analysis and debugging without having to create and load an extension that implements the application-defined functions.</source>
          <target state="translated">에서 사용되는 경우, &lt;a href=&quot;cli&quot;&gt;명령 라인 쉘&lt;/a&gt; 은 SQLITE_ENABLE_UNKNOWN_SQL_FUNCTION 기능 확장이 구현하는 애플리케이션 정의 함수를 생성하고로드 할 필요없이 애플리케이션 정의 함수를 포함 SQL 텍스트 분석 및 디버깅을 위해 쉘에 붙여 넣을 수있다.</target>
        </trans-unit>
        <trans-unit id="4fb531d1e034498892c1e8ba5b02ac3bc138fb71" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;mmap&quot;&gt;memory-mapped I/O&lt;/a&gt; map the database file read-only so that stray pointers and/or array overruns in the application cannot accidentally modify the database file.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;mmap&quot;&gt;의 I / O 메모리 매핑 된&lt;/a&gt; 데이터베이스 파일이 읽기 전용이므로 응용 프로그램에서 길잃은 포인터 및 / 또는 배열 오버런 실수로 데이터베이스 파일을 수정할 수 없음을 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="6bcae413d7ef24ed4791d379c4695938ecb30984" translate="yes" xml:space="preserve">
          <source>When using FTS4, specifying a column name that contains an &quot;=&quot; character and is not either a &quot;tokenize=*&quot; specification or a recognized FTS4 option is an error. With FTS3, the first token in the unrecognized directive is interpreted as a column name. Similarly, specifying multiple &quot;tokenize=*&quot; directives in a single table declaration is an error when using FTS4, whereas the second and subsequent &quot;tokenize=*&quot; directives are interpreted as column names by FTS3. For example:</source>
          <target state="translated">FTS4를 사용할 때 &quot;=&quot;문자를 포함하고 &quot;tokenize = *&quot;사양이 아니거나 인식 된 FTS4 옵션이 아닌 열 이름을 지정하면 오류가 발생합니다. FTS3을 사용하면 인식 할 수없는 지시문의 첫 번째 토큰이 열 이름으로 해석됩니다. 마찬가지로, 단일 테이블 선언에서 여러 &quot;tokenize = *&quot;지시문을 지정하면 FTS4를 사용할 때 오류가 발생하지만 두 번째 이후의 &quot;tokenize = *&quot;지시문은 FTS3에서 열 이름으로 해석됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2854ef2a0e9879ca0973bfbdbeb94518a7782b5" translate="yes" xml:space="preserve">
          <source>When using SQLite as a shared library, an application can test to see whether or not mutexes have been disabled using the &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe()&lt;/a&gt; API. Applications that link against SQLite at run-time and use SQLite from multiple threads should probably check this API to make sure they did not accidentally get linked against a version of the SQLite library that has its mutexes disabled. Single-threaded applications will, of course, work correctly regardless of whether or not SQLite is configured to be threadsafe, though they will be a little bit faster when using versions of SQLite with mutexes disabled.</source>
          <target state="translated">SQLite를 공유 라이브러리로 사용하는 경우 응용 프로그램은 &lt;a href=&quot;c3ref/threadsafe&quot;&gt;sqlite3_threadsafe ()&lt;/a&gt; API를 사용하여 뮤텍스가 비활성화되었는지 여부를 테스트 할 수 있습니다 . 런타임시 SQLite에 대해 링크하고 여러 스레드에서 SQLite를 사용하는 애플리케이션은이 API를 검사하여 뮤텍스가 비활성화 된 SQLite 라이브러리 버전에 실수로 연결되지 않았는지 확인해야합니다. 물론 단일 스레드 응용 프로그램은 SQLite가 스레드 안전으로 구성되어 있는지 여부에 관계없이 올바르게 작동하지만 뮤텍스가 비활성화 된 SQLite 버전을 사용하는 경우 약간 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="baabf02615564e01474304f4466f9fe87599218a" translate="yes" xml:space="preserve">
          <source>When using an index on an expression, try to use expression values already available in the index, rather than loading the original columns and recomputing the expression.</source>
          <target state="translated">식에서 인덱스를 사용할 때는 원래 열을로드하고 식을 다시 계산하지 않고 인덱스에서 이미 사용 가능한 식 값을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="468b6859516cde0950db73781d0176e06ba0111f" translate="yes" xml:space="preserve">
          <source>When using methods (2) or (3), it is important that the tokenizer only provide synonyms when tokenizing document text (method (2)) or query text (method (3)), not both. Doing so will not cause any errors, but is inefficient.</source>
          <target state="translated">방법 (2) 또는 (3)을 사용할 때 토크 나이 저는 문서 텍스트 (방법 (2)) 또는 쿼리 텍스트 (방법 (3))를 토큰화할 때 동의어 만 제공하는 것이 중요합니다. 그렇게하면 오류가 발생하지 않지만 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="88fac7db3e9db07076df4610515cb23f9340b834" translate="yes" xml:space="preserve">
          <source>When using the enhanced query syntax, parenthesis may be used to override the default precedence of the various operators. For example:</source>
          <target state="translated">개선 된 쿼리 구문을 사용하는 경우 괄호를 사용하여 다양한 연산자의 기본 우선 순위를 대체 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1505c3324cb54c87924929ab65d11580dc89a0fd" translate="yes" xml:space="preserve">
          <source>When wrongful thoughts come into your heart, dash them against Christ immediately.</source>
          <target state="translated">잘못된 생각이 당신의 마음에 들어 오면 즉시 그리스도를 대적하십시오.</target>
        </trans-unit>
        <trans-unit id="5d95aef3b20c2c80bafbf5f8ecbb1090e555f684" translate="yes" xml:space="preserve">
          <source>When xSavepoint(X,N) is invoked, that is a signal to the virtual table X that it should save its current state as savepoint N. A subsequent call to xRollbackTo(X,R) means that the state of the virtual table should return to what it was when xSavepoint(X,R) was last called. The call to xRollbackTo(X,R) will invalidate all savepoints with N&amp;gt;R; none of the invalided savepoints will be rolled back or released without first being reinitialized by a call to xSavepoint(). A call to xRelease(X,M) invalidates all savepoints where N&amp;gt;=M.</source>
          <target state="translated">xSavepoint (X, N)가 호출 될 때 이는 가상 테이블 X에 현재 상태를 저장 점 N으로 저장해야한다는 신호입니다. xRollbackTo (X, R)에 대한 후속 호출은 가상 테이블의 상태가 리턴되어야 함을 의미합니다. xSavepoint (X, R)가 마지막으로 호출 된 시점으로 xRollbackTo (X, R)에 대한 호출은 N&amp;gt; R을 사용하여 모든 저장 점을 무효화합니다. xSavepoint ()를 호출하여 먼저 다시 초기화하지 않고 유효하지 않은 저장 점을 롤백하거나 해제하지 않습니다. xRelease (X, M)를 호출하면 N&amp;gt; = M 인 모든 저장 점이 무효화됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bf837f933ca19d45d60aebd942c6f51001215f" translate="yes" xml:space="preserve">
          <source>When you change the cache size using the cache_size pragma, the change only endures for the current session. The cache size reverts to the default value when the database is closed and reopened.</source>
          <target state="translated">cache_size pragma를 사용하여 캐시 크기를 변경하면 현재 세션에 대해서만 변경 사항이 적용됩니다. 데이터베이스를 닫았다가 다시 열면 캐시 크기가 기본값으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="b0e87a05754f1ec62d9fdd0b9342f0b467aa6d5b" translate="yes" xml:space="preserve">
          <source>When you do an insert into a table that does not have an INTEGER PRIMARY KEY column, or if the table does have an INTEGER PRIMARY KEY but the value for that column is not specified in the VALUES clause of the insert, then the key is automatically generated. You can find the value of the key for the most recent INSERT statement using the &lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API function.</source>
          <target state="translated">INTEGER PRIMARY KEY 열이없는 테이블에 삽입하거나 테이블에 INTEGER PRIMARY KEY가 있지만 해당 열의 값이 삽입의 VALUES 절에 지정되지 않은 경우 키는 자동으로 삽입됩니다 생성되었습니다. &lt;b&gt;sqlite_last_insert_rowid&lt;/b&gt; API 함수를 사용하여 가장 최근의 INSERT 문의 키 값을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e2ed89fd7ed9aabab05210ebf19395404532e3b" translate="yes" xml:space="preserve">
          <source>When you have a SQL script that you are debugging or trying to understand, it is often useful to run it in the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt; with the &quot;.eqp full&quot; setting. When &quot;.eqp&quot; is set to FULL, the shell automatically shows the &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; and &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; output for each command prior to actually running that command.</source>
          <target state="translated">디버깅하거나 이해하려는 SQL 스크립트가 있는 경우 &quot;.eqp full&quot;설정 을 사용하여 &lt;a href=&quot;cli&quot;&gt;명령 줄 셸&lt;/a&gt; 에서 실행하는 것이 유용한 경우가 많습니다 . &quot;.eqp&quot;가 FULL로 설정되면 쉘은 해당 명령을 실제로 실행하기 전에 각 명령에 대해 &lt;a href=&quot;lang_explain&quot;&gt;EXPLAIN&lt;/a&gt; 및 &lt;a href=&quot;eqp&quot;&gt;EXPLAIN QUERY PLAN&lt;/a&gt; 출력을 자동으로 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="9a469065895a09048073186621e6fa156f1d430f" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;../pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; 문이 구문 분석 될 때마다 &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 제어는 pragma 문이 참조하는 데이터베이스 파일에 해당하는 열린 &lt;a href=&quot;file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트로 전송됩니다 . &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 제어에 대한 인수 는 문자열의 포인터 배열 (char **)이며 배열의 두 번째 요소는 pragma의 이름이고 세 번째 요소는 pragma에 대한 인수이거나 pragma에없는 경우 NULL입니다. 논의. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 제어 핸들러 는 선택적으로 char ** 인수의 첫 번째 요소가 &lt;a href=&quot;mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻은 문자열을 가리 키도록 할 수 있습니다.또는 해당 문자열이 pragma의 결과가되거나 pragma가 실패하면 오류 메시지가됩니다. 는 IF &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어가 반환 &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND을&lt;/a&gt; 한 후 정상 &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA의&lt;/a&gt; 처리가 계속됩니다. 는 IF &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어를 반환 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK는&lt;/a&gt; 다음 파서는 VFS가 PRAGMA 자체 처리하는 것으로 가정하고 문자열이 아닌 경우 파서는 결과 문자열이 NULL 인 경우 무 조작 준비된 문장, 또는 반환 결과 문자열의 복사본을 생성 -없는. 는 IF &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어는 이외의 결과 코드를 반환 &lt;a href=&quot;../rescode#ok&quot;&gt;SQLITE_OK&lt;/a&gt; 또는 &lt;a href=&quot;../rescode#notfound&quot;&gt;SQLITE_NOTFOUND을&lt;/a&gt;즉, &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 를 처리하는 동안 VFS에 오류가 발생하여 PRAGMA 의 컴파일이 오류와 함께 실패합니다. &lt;a href=&quot;c_fcntl_begin_atomic_write#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어 프라 그마 제표 분석의 시작 부분에서 발생하고 그래서 내장 무시할 수있다 &lt;a href=&quot;../pragma#syntax&quot;&gt;PRAGMA의&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="4f29909c26f83db47f3f77fe2f91d6b21b9cfb6d" translate="yes" xml:space="preserve">
          <source>Whenever a &lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; statement is parsed, an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is sent to the open &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; object corresponding to the database file to which the pragma statement refers. The argument to the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control is an array of pointers to strings (char**) in which the second element of the array is the name of the pragma and the third element is the argument to the pragma or NULL if the pragma has no argument. The handler for an &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control can optionally make the first element of the char** argument point to a string obtained from &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf()&lt;/a&gt; or the equivalent and that string will become the result of the pragma or the error message if the pragma fails. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, then normal &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; processing continues. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt;, then the parser assumes that the VFS has handled the PRAGMA itself and the parser generates a no-op prepared statement if result string is NULL, or that returns a copy of the result string if the string is non-NULL. If the &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control returns any result code other than &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; or &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND&lt;/a&gt;, that means that the VFS encountered an error while handling the &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; and the compilation of the PRAGMA fails with an error. The &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; file control occurs at the beginning of pragma statement analysis and so it is able to override built-in &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; statements.</source>
          <target state="translated">&lt;a href=&quot;pragma#syntax&quot; id=&quot;sqlitefcntlpragma&quot;&gt;PRAGMA&lt;/a&gt; 문이 구문 분석 될 때마다 &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 제어는 pragma 문이 참조하는 데이터베이스 파일에 해당하는 열린 &lt;a href=&quot;#sqlite3_file&quot;&gt;sqlite3_file&lt;/a&gt; 오브젝트로 전송됩니다 . &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 제어에 대한 인수 는 문자열의 포인터 배열 (char **)이며 배열의 두 번째 요소는 pragma의 이름이고 세 번째 요소는 pragma에 대한 인수이거나 pragma에없는 경우 NULL입니다. 논의. &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA&lt;/a&gt; 파일 제어 핸들러 는 선택적으로 char ** 인수의 첫 번째 요소가 &lt;a href=&quot;#sqlite3_mprintf&quot;&gt;sqlite3_mprintf ()&lt;/a&gt; 에서 얻은 문자열을 가리 키도록 할 수 있습니다.또는 해당 문자열이 pragma의 결과가되거나 pragma가 실패하면 오류 메시지가됩니다. 는 IF &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어가 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND을&lt;/a&gt; 한 후 정상 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA의&lt;/a&gt; 처리가 계속됩니다. 는 IF &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어를 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK는&lt;/a&gt; 다음 파서는 VFS가 PRAGMA 자체 처리하는 것으로 가정하고 문자열이 아닌 경우 파서는 결과 문자열이 NULL 인 경우 무 조작 준비된 문장, 또는 반환 결과 문자열의 복사본을 생성 -없는. 는 IF &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어는 이외의 결과 코드를 반환 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_OK&lt;/a&gt; 또는 &lt;a href=&quot;#SQLITE_ABORT&quot;&gt;SQLITE_NOTFOUND을&lt;/a&gt;즉, &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA&lt;/a&gt; 를 처리하는 동안 VFS에 오류가 발생하여 PRAGMA 의 컴파일이 오류와 함께 실패합니다. &lt;a href=&quot;#sqlitefcntlpragma&quot;&gt;SQLITE_FCNTL_PRAGMA의&lt;/a&gt; 파일 제어 프라 그마 제표 분석의 시작 부분에서 발생하고 그래서 내장 무시할 수있다 &lt;a href=&quot;pragma#syntax&quot;&gt;PRAGMA의&lt;/a&gt; 문.</target>
        </trans-unit>
        <trans-unit id="7da0d908dd494a51e46851fa8be237351c85f11a" translate="yes" xml:space="preserve">
          <source>Whenever a bug is reported against SQLite, that bug is not considered fixed until new test cases that would exhibit the bug have been added to either the TCL or TH3 test suites. Over the years, this has resulted in thousands and thousands of new tests. These regression tests ensure that bugs that have been fixed in the past are not reintroduced into future versions of SQLite.</source>
          <target state="translated">SQLite에 대해 버그가보고 될 때마다 버그를 나타내는 새로운 테스트 사례가 TCL 또는 TH3 테스트 스위트에 추가 될 때까지 해당 버그는 수정 된 것으로 간주되지 않습니다. 수년에 걸쳐 수천 건의 새로운 테스트 결과가 나왔습니다. 이러한 회귀 테스트는 과거에 수정 된 버그가 이후 버전의 SQLite에 다시 도입되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="33e01584f09cbc3030c7fddae4886376aff67c9e" translate="yes" xml:space="preserve">
          <source>Whenever a database is opened, the entire schema is scanned and parsed and a parse tree for the schema is held in memory. That means that database connection startup time and initial memory usage is proportional to the size of the schema.</source>
          <target state="translated">데이터베이스가 열릴 때마다 전체 스키마가 스캔 및 구문 분석되고 스키마의 구문 분석 트리가 메모리에 유지됩니다. 이는 데이터베이스 연결 시작 시간 및 초기 메모리 사용량이 스키마 크기에 비례 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="497ecda91e171119dde556e568de3183a8cb8f6e" translate="yes" xml:space="preserve">
          <source>Whenever a row in the parent table of a foreign key constraint is deleted, or when the values stored in the parent key column or columns are modified, the logical sequence of events is:</source>
          <target state="translated">외래 키 제약 조건의 부모 테이블에서 행이 삭제되거나 부모 키 열에 저장된 값이 수정 될 때마다 논리적 이벤트 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a37cacf0c7e51e3db57f63b99d51f003b150071" translate="yes" xml:space="preserve">
          <source>Whenever a write operation occurs, the writer checks how much progress the checkpointer has made, and if the entire WAL has been transferred into the database and synced and if no readers are making use of the WAL, then the writer will rewind the WAL back to the beginning and start putting new transactions at the beginning of the WAL. This mechanism prevents a WAL file from growing without bound.</source>
          <target state="translated">쓰기 작업이 수행 될 때마다 기록기는 검사 점의 진행률을 확인하고 전체 WAL이 데이터베이스로 전송되어 동기화되고 판독기가 WAL을 사용하지 않는 경우 기록기는 WAL을 다시 되감습니다. WAL의 시작 부분에 새로운 거래를 시작하고 시작하십시오. 이 메커니즘은 WAL 파일이 제한없이 커지는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="343d6f171b30e5570b4ea710189ea4bcc234b168" translate="yes" xml:space="preserve">
          <source>Whenever another row of result data is available, &lt;b&gt;sqlite_step&lt;/b&gt; will return SQLITE_ROW. The row data is stored in an array of pointers to strings and the 2nd parameter is made to point to this array.</source>
          <target state="translated">다른 결과 데이터 행이 사용 가능할 때마다 &lt;b&gt;sqlite_step&lt;/b&gt; 은 SQLITE_ROW를 리턴합니다. 행 데이터는 문자열에 대한 포인터 배열에 저장되며 두 번째 매개 변수는이 배열을 가리 키도록 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="be09d2acec84e8312793d7710565bb42fe503a39" translate="yes" xml:space="preserve">
          <source>Whenever comparing SQLite to other SQL database engines like SQL Server, PostgreSQL, MySQL, or Oracle, it is important first of all to realize that SQLite is not intended as a replacement or competitor to any of those systems. SQLite is &lt;a href=&quot;serverless&quot;&gt;serverless&lt;/a&gt;. There is no separate server process that manages the database. An application interacts with the database engine using function calls, not by sending messages to a separate process or thread.</source>
          <target state="translated">SQLite를 SQL Server, PostgreSQL, MySQL 또는 Oracle과 같은 다른 SQL 데이터베이스 엔진과 비교할 때마다 SQLite가 이러한 시스템을 대체하거나 경쟁자로 의도 된 것이 아니라는 사실을 인식하는 것이 중요합니다. SQLite는 &lt;a href=&quot;serverless&quot;&gt;서버리스&lt;/a&gt; 입니다. 데이터베이스를 관리하는 별도의 서버 프로세스가 없습니다. 응용 프로그램은 별도의 프로세스 나 스레드로 메시지를 보내지 않고 함수 호출을 사용하여 데이터베이스 엔진과 상호 작용합니다.</target>
        </trans-unit>
        <trans-unit id="17a11b6e3fb65c86a99e26ed1e561497e95a4bf4" translate="yes" xml:space="preserve">
          <source>Whenever the database schema changes, prepared statements are automatically reprepared to accommodate the new schema. There is a race condition here in that if one thread is constantly changing the schema, another thread might spin on reparses and repreparations of a prepared statement and never get any real work done. This parameter prevents an infinite loop by forcing the spinning thread to give up after a fixed number of attempts at recompiling the prepared statement. The default setting is 50 which is more than adequate for most applications.</source>
          <target state="translated">데이터베이스 스키마가 변경 될 때마다 준비된 명령문이 자동으로 다시 준비되어 새 스키마를 수용합니다. 하나의 스레드가 지속적으로 스키마를 변경하는 경우 다른 스레드가 준비된 명령문의 재분석 및 재 준비를 수행하고 실제 작업을 수행하지 않을 수 있다는 경쟁 조건이 있습니다. 이 매개 변수는 준비된 명령문을 재 컴파일하려는 고정 된 횟수의 시도 후에 회전 스레드가 강제로 포기함으로써 무한 루프를 방지합니다. 기본 설정은 50이며 대부분의 응용 프로그램에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5bd2a09557636d477221b6346f70a36e1b45532a" translate="yes" xml:space="preserve">
          <source>Where &quot;column&quot; is a column in the virtual table, OP is an operator like &quot;=&quot; or &quot;&amp;lt;&quot;, and EXPR is an arbitrary expression. So, for example, if the WHERE clause contained a term like this:</source>
          <target state="translated">&quot;열&quot;이 가상 테이블의 열인 경우 OP는 &quot;=&quot;또는 &quot;&amp;lt;&quot;와 같은 연산자이며 EXPR은 임의의 식입니다. 예를 들어 WHERE 절에 다음과 같은 용어가 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="43f8cd7ec518821d99337a406b14b6ad25458172" translate="yes" xml:space="preserve">
          <source>Where &amp;lt;tokenizer-name&amp;gt; is &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a string is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text()&lt;/a&gt; where the string identifies the tokenizer and &amp;lt;sqlite3_tokenizer_module ptr&amp;gt; is a &lt;a href=&quot;lang_expr#varparam&quot;&gt;parameter&lt;/a&gt; to which a BLOB is bound using &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob()&lt;/a&gt; where the value of the BLOB is a pointer to an sqlite3_tokenizer_module structure. If the second argument is present, it is registered as tokenizer &amp;lt;tokenizer-name&amp;gt; and a copy of it returned. If only one argument is passed, a pointer to the tokenizer implementation currently registered as &amp;lt;tokenizer-name&amp;gt; is returned, encoded as a blob. Or, if no such tokenizer exists, an SQL exception (error) is raised.</source>
          <target state="translated">여기서 &amp;lt;tokenizer-name&amp;gt;은 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_text ()를&lt;/a&gt; 사용하여 문자열이 바인드되는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수입니다.&lt;/a&gt; 여기서 문자열은 토크 나이저를 식별하고 &amp;lt;sqlite3_tokenizer_module ptr&amp;gt;은 &lt;a href=&quot;c3ref/bind_blob&quot;&gt;sqlite3_bind_blob ()를&lt;/a&gt; 사용하여 BLOB가 바인드되는 &lt;a href=&quot;lang_expr#varparam&quot;&gt;매개 변수입니다.&lt;/a&gt; 여기서 BLOB의 값은 sqlite3_tokenizer_module 구조에 대한 포인터. 두 번째 인수가 있으면 토큰 화기 &amp;lt;tokenizer-name&amp;gt;으로 등록되고 그 사본이 리턴됩니다. 인수가 하나만 전달되면 현재 &amp;lt;tokenizer-name&amp;gt;으로 등록 된 토크 나이저 구현에 대한 포인터가 Blob으로 인코딩되어 반환됩니다. 또는 그러한 토크 나이저가 존재하지 않으면 SQL 예외 (오류)가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe664b79065efef56eb19d94f1c82054f533c78c" translate="yes" xml:space="preserve">
          <source>Where VERSION can be a branch name (like &quot;trunk&quot; or &quot;session&quot;) to get the latest check-in on a specific branch, or VERSION can be a SHA1 hash or a prefix of a SHA1 hash for a specific check-in, or VERSION can be a tag such as &quot;version-3.8.8&quot;. Every time you run &quot;fossil update&quot; it will automatically reach out to the original repository at http://www.sqlite.org/cgi/src to obtain new check-ins that might have been made by others since your previous update.</source>
          <target state="translated">여기서 VERSION은 특정 지점에서 최신 체크인을 받기위한 지점 이름 (예 : &quot;트렁크&quot;또는 &quot;세션&quot;) 일 수 있고, VERSION은 특정 체크인을위한 SHA1 해시 또는 SHA1 해시의 접두사 일 수 있습니다. 또는 VERSION은 &quot;version-3.8.8&quot;과 같은 태그 일 수 있습니다. &quot;화석 업데이트&quot;를 실행할 때마다 http://www.sqlite.org/cgi/src의 원래 저장소에 자동으로 연결되어 이전 업데이트 이후 다른 사람이 새로 체크인했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62f2d871248b60ca56135b923987b70f9385647b" translate="yes" xml:space="preserve">
          <source>Where this ends up causing problems is when developers do some initial coding work using SQLite and get their application working, but then try to convert to another database like PostgreSQL or SQL Server for deployment. If the application is initially taking advantage of SQLite's flexible typing, then it will fail when moved to another database that uses a more rigid and unforgiving type enforcement policy.</source>
          <target state="translated">이로 인해 문제가 발생하는 곳은 개발자가 SQLite를 사용하여 초기 코딩 작업을 수행하고 응용 프로그램을 작동시킨 다음 PostgreSQL 또는 SQL Server와 같은 다른 데이터베이스로 변환하여 배포하는 것입니다. 응용 프로그램이 처음에 SQLite의 유연한 타이핑을 활용하는 경우 더 엄격하고 용서할 수없는 유형 적용 정책을 사용하는 다른 데이터베이스로 이동하면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="c5d4b5d864c31b29da8aa7f64d89028ed5c76cfd" translate="yes" xml:space="preserve">
          <source>Whether it is parsing document or query text, any call to xToken that specifies a</source>
          <target state="translated">문서 또는 쿼리 텍스트를 구문 분석하는지 여부에 관계없이 xToken을 호출하면</target>
        </trans-unit>
        <trans-unit id="79b58773d42ad0674454e81345e3b00864854d60" translate="yes" xml:space="preserve">
          <source>Whether or not &quot;char&quot; variables are signed or unsigned.</source>
          <target state="translated">&quot;char&quot;변수의 서명 여부입니다.</target>
        </trans-unit>
        <trans-unit id="927824fe8759e5b1e1a630b01c62f6b1e890e24a" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;#sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">오류가 발생했을 때 발생하는지 여부에 관계없이 &lt;a href=&quot;#sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들 과 연관된 자원 은 더 이상 필요하지 않을 때 &lt;a href=&quot;#sqlite3_close&quot;&gt;sqlite3_close ()&lt;/a&gt; 에 전달하여 해제해야 합니다.</target>
        </trans-unit>
        <trans-unit id="568677ded3b331843b99c68cc439cfb12004ddef" translate="yes" xml:space="preserve">
          <source>Whether or not an error occurs when it is opened, resources associated with the &lt;a href=&quot;sqlite3&quot;&gt;database connection&lt;/a&gt; handle should be released by passing it to &lt;a href=&quot;close&quot;&gt;sqlite3_close()&lt;/a&gt; when it is no longer required.</source>
          <target state="translated">오류가 발생했을 때 발생하는지 여부에 관계없이 &lt;a href=&quot;sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 핸들 과 연관된 자원 은 더 이상 필요하지 않을 때 &lt;a href=&quot;close&quot;&gt;sqlite3_close ()&lt;/a&gt; 에 전달하여 해제해야 합니다.</target>
        </trans-unit>
        <trans-unit id="bb05885439d11af94b4bcc3db20e0753f97a131e" translate="yes" xml:space="preserve">
          <source>Whether or not an index or &lt;a href=&quot;optoverview#autoindex&quot;&gt;automatic index&lt;/a&gt; is used.</source>
          <target state="translated">인덱스 또는 &lt;a href=&quot;optoverview#autoindex&quot;&gt;자동 인덱스&lt;/a&gt; 사용 여부입니다.</target>
        </trans-unit>
        <trans-unit id="35e3585051eb4909e3fe069dd52d9c306b089c84" translate="yes" xml:space="preserve">
          <source>Whether or not the &lt;a href=&quot;queryplanner#covidx&quot;&gt;covering index&lt;/a&gt; optimization applies.</source>
          <target state="translated">있는지 여부를 &lt;a href=&quot;queryplanner#covidx&quot;&gt;포함하는 인덱스&lt;/a&gt; 최적화가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3f452c9d36fa06b25992734adfdfc328c0c7c82f" translate="yes" xml:space="preserve">
          <source>Whether or not the backup process is restarted as a result of writes to the source database mid-backup, the user can be sure that when the backup operation is completed the backup database contains a consistent and up-to-date snapshot of the original. However:</source>
          <target state="translated">백업 중 소스 데이터베이스에 쓰기 결과로 백업 프로세스가 다시 시작되는지 여부에 관계없이 사용자는 백업 작업이 완료되면 백업 데이터베이스에 원본의 일관된 최신 스냅 샷이 포함되어 있는지 확인할 수 있습니다. 하나:</target>
        </trans-unit>
        <trans-unit id="805314d6ba3c8452666efff3bc4e2e9c11e54c17" translate="yes" xml:space="preserve">
          <source>Whether the table is a &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; table.</source>
          <target state="translated">테이블이 &lt;a href=&quot;withoutrowid&quot;&gt;WITHOUT ROWID&lt;/a&gt; 테이블 인지 여부</target>
        </trans-unit>
        <trans-unit id="15cc066f01fd0a8910ef52b96a08c5f23129c75a" translate="yes" xml:space="preserve">
          <source>Which module, FTS3 or FTS4, should you use in your application? FTS4 is sometimes significantly faster than FTS3, even orders of magnitude faster depending on the query, though in the common case the performance of the two modules is similar. FTS4 also offers the enhanced &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo()&lt;/a&gt; outputs which can be useful in ranking the results of a &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; operation. On the other hand, in the absence of a &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo=fts3&lt;/a&gt; directive FTS4 requires a little more disk space than FTS3, though only a percent of two in most cases.</source>
          <target state="translated">응용 프로그램에서 어떤 모듈 FTS3 또는 FTS4를 사용해야합니까? FTS4는 때로는 FTS3보다 훨씬 빠르며, 쿼리에 따라 수십 배 더 빠릅니다. 일반적인 경우 두 모듈의 성능은 비슷합니다. FTS4는 또한 향상된 &lt;a href=&quot;fts3#matchinfo&quot;&gt;matchinfo ()&lt;/a&gt; 출력을 제공하여 &lt;a href=&quot;fts3#full_text_index_queries&quot;&gt;MATCH&lt;/a&gt; 연산 의 결과 순위를 매길 때 유용 합니다. 반면에 &lt;a href=&quot;fts3#fts4matchinfo&quot;&gt;matchinfo = fts3&lt;/a&gt; 지시문이 없으면 FTS4는 FTS3보다 약간 더 많은 디스크 공간을 필요로하지만 대부분의 경우 2 % 만 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1eaf1dfe15540108a1d6bb4cc98824a6bb754fe0" translate="yes" xml:space="preserve">
          <source>Which of those columns are PRIMARY KEY columns.</source>
          <target state="translated">이 중 어떤 열이 PRIMARY KEY 열입니다.</target>
        </trans-unit>
        <trans-unit id="2bf977231fee9d5a01c1d56cb42302f6abc78241" translate="yes" xml:space="preserve">
          <source>Which of those columns make up the tables PRIMARY KEY.</source>
          <target state="translated">그 중 어느 열이 PRIMARY KEY 테이블을 구성합니까?</target>
        </trans-unit>
        <trans-unit id="65190c6c06c3156a5ce50576cd97088b8788cba3" translate="yes" xml:space="preserve">
          <source>Which terms of the WHERE clause are used for indexing.</source>
          <target state="translated">인덱싱에 사용되는 WHERE 절의 용어</target>
        </trans-unit>
        <trans-unit id="7d607a9e2bbeeff588fac8037da7b126ad5bde90" translate="yes" xml:space="preserve">
          <source>Which works out to be:</source>
          <target state="translated">다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5778f90619b883572d8c026a15fd3403dfe6662c" translate="yes" xml:space="preserve">
          <source>While SQL is a programming language, it is different from other programming languages like C, Javascript, Python, or Go in that SQL is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;declarative language&lt;/a&gt; where the others are &lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;imperative languages&lt;/a&gt;. This is an important difference that has implications for the design of the compiler used to translate program source text into an executable format. However, those details should not detract from the fact that SQL is really just another programming language.</source>
          <target state="translated">SQL은 프로그래밍 언어 인 반면, C, 자바 스크립트, 파이썬, 또는 SQL는 것을 이동과 같은 다른 프로그래밍 언어에서 다른 &lt;a href=&quot;https://en.wikipedia.org/wiki/Declarative_programming&quot;&gt;선언적 언어를&lt;/a&gt; 다른 사람이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Imperative_programming&quot;&gt;명령형 언어&lt;/a&gt; . 이것은 프로그램 소스 텍스트를 실행 가능한 형식으로 변환하는 데 사용되는 컴파일러 설계에 영향을주는 중요한 차이점입니다. 그러나 이러한 세부 사항은 SQL이 실제로 다른 프로그래밍 언어라는 사실을 손상시키지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2ada2cef428bad4df299c966d8cc7b1305373853" translate="yes" xml:space="preserve">
          <source>While a &lt;a href=&quot;c3ref/sqlite3&quot;&gt;database connection&lt;/a&gt; is open on a WAL-mode database, SQLite maintains an extra journal file called a &quot;Write Ahead Log&quot; or &quot;WAL File&quot;. The name of this file on disk is usually the name of the database file with an extra &quot;&lt;code&gt;-wal&lt;/code&gt;&quot; suffix, though different naming rules may apply if SQLite is compiled with &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c3ref/sqlite3&quot;&gt;데이터베이스 연결&lt;/a&gt; 이 WAL 모드 데이터베이스에서 열려 있는 동안 SQLite는 &quot;Write Ahead Log&quot;또는 &quot;WAL File&quot;이라는 추가 저널 파일을 유지 관리합니다. 디스크에서이 파일의 이름은 일반적으로 추가 &quot; &lt;code&gt;-wal&lt;/code&gt; &quot;접미사 가있는 데이터베이스 파일 이름 이지만 SQLite가 &lt;a href=&quot;compile#enable_8_3_names&quot;&gt;SQLITE_ENABLE_8_3_NAMES&lt;/a&gt; 로 컴파일 된 경우 다른 이름 지정 규칙이 적용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d7e2ba9f3191758fdb3ad9b114fa10eb9a4ed3b0" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot of the database prior to the changes implemented by Y.</source>
          <target state="translated">읽기 트랜잭션이 활성 상태 인 동안 별도의 데이터베이스 연결에 의해 구현 된 데이터베이스의 변경 사항은 읽기 트랜잭션을 시작한 데이터베이스 연결에 표시되지 않습니다. 데이터베이스 연결 X가 읽기 트랜잭션을 보유하고있는 경우 X의 트랜잭션이 아직 열려있는 동안 다른 데이터베이스 연결 Y가 데이터베이스의 내용을 변경할 수 있지만 X는 트랜잭션이 종료 될 때까지 이러한 변경 사항을 볼 수 없습니다. 읽기 트랜잭션이 활성화되어있는 동안 X는 Y에 의해 구현 된 변경 사항 이전에 데이터베이스의 기록 스냅 샷을 계속 볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="5ffdc80fe0f26846179a6aaa2eb484325f365e70" translate="yes" xml:space="preserve">
          <source>While a read transaction is active, any changes to the database that are implemented by separate database connections will not be seen by the database connection that started the read transaction. If database connection X is holding a read transaction, it is possible that some other database connection Y might change the content of the database while X's transaction is still open, however X will not be able to see those changes until after the transaction ends. While its read transaction is active, X will continue to see an historic snapshot the database prior to the changes implemented by Y.</source>
          <target state="translated">읽기 트랜잭션이 활성화되어있는 동안 별도의 데이터베이스 연결로 구현 된 데이터베이스에 대한 변경 내용은 읽기 트랜잭션을 시작한 데이터베이스 연결에서 볼 수 없습니다. 데이터베이스 연결 X가 읽기 트랜잭션을 보유하고있는 경우, X의 트랜잭션이 여전히 열려있는 동안 일부 다른 데이터베이스 연결 Y가 데이터베이스의 내용을 변경할 수 있지만 트랜잭션이 종료 될 때까지 X는 이러한 변경 사항을 볼 수 없습니다. 읽기 트랜잭션이 활성화되어있는 동안 X는 Y에 의해 구현 된 변경 이전에 데이터베이스의 기록 스냅 샷을 계속 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc81a6b9eff77dec03d524ff1a744befb138ec8" translate="yes" xml:space="preserve">
          <source>While compiling a single SQL query, the SQLite core might call xBestIndex multiple times with different settings in &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info&lt;/a&gt;. The SQLite core will then select the combination that appears to give the best performance.</source>
          <target state="translated">단일 SQL 쿼리를 컴파일하는 동안 SQLite 코어는 &lt;a href=&quot;c3ref/index_info&quot;&gt;sqlite3_index_info의&lt;/a&gt; 다른 설정으로 xBestIndex를 여러 번 호출 할 수 있습니다 . 그런 다음 SQLite 코어는 최상의 성능을 제공하는 것처럼 보이는 조합을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d6f8e366ea836d249425f55c0048ab7dd0869350" translate="yes" xml:space="preserve">
          <source>While fuzz testing and 100% MC/DC testing are in tension, they are not completely at cross-purposes. The fact that the SQlite test suite does test to 100% MC/DC means that when fuzzers do find problems, those problems can be fixed quickly and with little risk of introducing new errors.</source>
          <target state="translated">퍼지 테스트와 100 % MC / DC 테스트는 긴장 상태에 있지만 완전히 교차 목적이 아닙니다. SQlite 테스트 스위트가 100 % MC / DC 테스트를 수행한다는 사실은 퍼 저가 문제를 발견 할 때 이러한 문제를 신속하게 해결할 수 있고 새로운 오류가 발생할 위험이 거의 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="84aa771f4f176659ae1924e0a87ff5ad8203b073" translate="yes" xml:space="preserve">
          <source>While opening a</source>
          <target state="translated">여는 동안</target>
        </trans-unit>
        <trans-unit id="9b36f93bab56bb7da15a9179ec0943945f846c1b" translate="yes" xml:space="preserve">
          <source>While performing</source>
          <target state="translated">수행하는 동안</target>
        </trans-unit>
        <trans-unit id="96921c80759d36f4a04b6a82e193c5ddf054ac5c" translate="yes" xml:space="preserve">
          <source>While the original idea being CVEs is sound, the current processes for creating and managing CVEs are inadequate. There are countless grey-hat hackers running fuzzers against a wide-variety of open-source software products (SQLite as well as many others) and writing up CVEs against any problems they find. The grey-hats are rewarded, sometimes with prestige and sometimes financially, by the number and severity of the CVEs they write. This incentive results in a proliferation of CVEs which are often not well-vetted and which can have exaggerated impact claims. The quality-control procedures for CVEs are unable to cope with this flood of inputs, making it difficult to correct exaggerated, misleading, omitted, or inaccurate claims.</source>
          <target state="translated">CVE라는 원래 아이디어는 건전하지만 CVE를 만들고 관리하는 현재 프로세스는 부적절합니다. 다양한 오픈 소스 소프트웨어 제품 (SQLite 및 기타 여러 제품)에 대해 퍼저를 실행하고 발견 된 문제에 대해 CVE를 작성하는 수많은 그레이 햇 해커가 있습니다. 그레이 햇은 작성하는 CVE의 수와 심각도에 따라 때로는 명성을, 때로는 재정적으로 보상을받습니다. 이 인센티브는 종종 잘 검토되지 않고 과장된 영향 주장을 할 수있는 CVE의 확산을 초래합니다. CVE에 대한 품질 관리 절차는 이러한 입력의 폭주에 대처할 수 없으므로 과장되거나 오해의 소지가 있거나 생략되거나 부정확 한 주장을 수정하기 어렵습니다.</target>
        </trans-unit>
        <trans-unit id="3a93a15284084502a7f86f4c9b90c793ee720848" translate="yes" xml:space="preserve">
          <source>While the queue is not empty:</source>
          <target state="translated">큐가 비어 있지 않은 동안 :</target>
        </trans-unit>
        <trans-unit id="31d87d7be7b237cc74cece1001ddf141c8c0c304" translate="yes" xml:space="preserve">
          <source>Whitespace and comment tokens are discarded. All other tokens are fed into an &lt;a href=&quot;https://en.wikipedia.org/wiki/LALR_parser&quot;&gt;LALR(1) Parser&lt;/a&gt; that analysis the structure of the input program and generates an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;Abstract Syntax Tree (AST)&lt;/a&gt; for the input program.</source>
          <target state="translated">공백 및 주석 토큰은 삭제됩니다. 다른 모든 토큰은 입력 프로그램의 구조를 분석하고 입력 프로그램에 대한 &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;AST (추상 구문 트리)&lt;/a&gt; 를 생성하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/LALR_parser&quot;&gt;LALR (1) 파서&lt;/a&gt; 로 공급됩니다 .</target>
        </trans-unit>
        <trans-unit id="b875e5298cf6263e72c1bc4d0e00a3e4a13f0a5d" translate="yes" xml:space="preserve">
          <source>Whitespace or comments.</source>
          <target state="translated">공백 또는 주석.</target>
        </trans-unit>
        <trans-unit id="4d2467596fdde02a218277dc3baed1d04b31fd9e" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is so difficult</source>
          <target state="translated">ALTER TABLE이 어려운 이유</target>
        </trans-unit>
        <trans-unit id="a66e4df98a00d586d77ff8cbda05b1bb33741627" translate="yes" xml:space="preserve">
          <source>Why ALTER TABLE is such a problem for SQLite</source>
          <target state="translated">ALTER TABLE이 SQLite에 왜 그런 문제입니까?</target>
        </trans-unit>
        <trans-unit id="51671cd80abfeae9d7b51e113f2b9ee1f5d2c38e" translate="yes" xml:space="preserve">
          <source>Why Is SQLite Coded In C</source>
          <target state="translated">SQLite가 C로 코딩 된 이유</target>
        </trans-unit>
        <trans-unit id="a50fb31b169e8e4d9b4a6643f7f8608e036bc60b" translate="yes" xml:space="preserve">
          <source>Why SQLite Does Not Use Git</source>
          <target state="translated">SQLite가 Git을 사용하지 않는 이유</target>
        </trans-unit>
        <trans-unit id="cf48c0996bab18f4950cd87af9617143917f12a9" translate="yes" xml:space="preserve">
          <source>Why didn't the legacy query planner choose algorithm-2? Easy: because the NN algorithm never even considered algorithm-2. Graphs of the planning problem look like this:</source>
          <target state="translated">기존 쿼리 플래너가 알고리즘 -2를 선택하지 않은 이유는 무엇입니까? 쉬운 이유 : NN 알고리즘은 결코 알고리즘 -2를 고려하지 않았기 때문입니다. 계획 문제의 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9ddc1f9321acc62d313f21bd009fd732a7ca677" translate="yes" xml:space="preserve">
          <source>Why does ROUND(9.95,1) return 9.9 instead of 10.0? Shouldn't 9.95 round up?</source>
          <target state="translated">ROUND (9.95,1)가 10.0 대신 9.9를 반환하는 이유는 무엇입니까? 9.95를 반올림해서는 안됩니까?</target>
        </trans-unit>
        <trans-unit id="cf08e93e3998487d5a4514d0ec927b65fe1810fa" translate="yes" xml:space="preserve">
          <source>Why does SQLite have its own private built-in printf() implementation? Why not use the printf() implementation from the standard C library? Several reasons:</source>
          <target state="translated">SQLite에 자체 전용 내장 printf () 구현이있는 이유는 무엇입니까? 표준 C 라이브러리에서 printf () 구현을 사용하지 않는 이유는 무엇입니까? 몇 가지 이유:</target>
        </trans-unit>
        <trans-unit id="1ec9acf7734149243e8c44660fc685f0eb23a630" translate="yes" xml:space="preserve">
          <source>Why doesn't SQLite allow me to use '0' and '0.0' as the primary key on two different rows of the same table?</source>
          <target state="translated">SQLite에서 왜 같은 테이블의 두 개의 다른 행에서 '0'과 '0.0'을 기본 키로 사용할 수 없습니까?</target>
        </trans-unit>
        <trans-unit id="02275b1d64f346b7ea26ca7a800967bbade4e5f6" translate="yes" xml:space="preserve">
          <source>Win32 Directory Types</source>
          <target state="translated">Win32 디렉토리 유형</target>
        </trans-unit>
        <trans-unit id="0463d1ccc9613d5098c42774fc7e43131ce95d1e" translate="yes" xml:space="preserve">
          <source>Win32 Specific Interface</source>
          <target state="translated">Win32 특정 인터페이스</target>
        </trans-unit>
        <trans-unit id="f8b7523500f54721211a692b3d6b968bab3101a5" translate="yes" xml:space="preserve">
          <source>Win32 native memory allocator</source>
          <target state="translated">Win32 기본 메모리 할당 자</target>
        </trans-unit>
        <trans-unit id="68fe8f958724479a101c0326f7607d389d321758" translate="yes" xml:space="preserve">
          <source>Window Functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="7973e6ebbc857b7bb0de6b349ffa9e99bc62f773" translate="yes" xml:space="preserve">
          <source>Window chaining</source>
          <target state="translated">창 체인</target>
        </trans-unit>
        <trans-unit id="99565b4d7904c206a1623d09463276b2f7b9b151" translate="yes" xml:space="preserve">
          <source>Window chaining is a shorthand that allows one window to be defined in terms of another. Specifically, the shorthand allows the new window to implicitly copy the PARTITION BY and optionally ORDER BY clauses of the base window. For example, in the following:</source>
          <target state="translated">창 체인은 하나의 창을 다른 창으로 정의 할 수있는 속기입니다. 특히, 속기는 새 창에서 기본 창의 PARTITION BY 및 선택적으로 ORDER BY 절을 내재적으로 복사 할 수 있습니다. 예를 들어 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="34aa1477a928d2146e07a6620c66855ebe78ae81" translate="yes" xml:space="preserve">
          <source>Window function support was first added to SQLite with release &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;version 3.25.0&lt;/a&gt; (2018-09-15). The SQLite developers used the &lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt; window function documentation as their primary reference for how window functions ought to behave. Many test cases have been run against PostgreSQL to ensure that window functions operate the same way in both SQLite and PostgreSQL.</source>
          <target state="translated">창 기능 지원은 릴리스 &lt;a href=&quot;https://sqlite.org/releaselog/3_25_0.html&quot;&gt;버전 3.25.0&lt;/a&gt; (2018-09-15) 으로 SQLite에 처음 추가되었습니다 . SQLite 개발자는 &lt;a href=&quot;http://www.postgresql.org&quot;&gt;PostgreSQL&lt;/a&gt; 윈도우 함수 문서를 윈도우 함수의 작동 방식에 대한 기본 참조로 사용했습니다. 창 함수가 SQLite와 PostgreSQL에서 동일한 방식으로 작동하도록 PostgreSQL에 대해 많은 테스트 사례가 실행되었습니다.</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="b37157f249f48370ca58b2cacca1806dc4feec9b" translate="yes" xml:space="preserve">
          <source>Window functions are distinguished from other SQL functions by the presence of an OVER clause. If a function has an OVER clause, then it is a window function. If it lacks an OVER clause, then it is an ordinary aggregate or scalar function. Window functions might also have a FILTER clause in between the function and the OVER clause.</source>
          <target state="translated">창 함수는 OVER 절의 존재로 다른 SQL 함수와 구별됩니다. 함수에 OVER 절이 있으면 창 함수입니다. OVER 절이 없으면 일반적인 집계 또는 스칼라 함수입니다. 창 함수에는 함수와 OVER 절 사이에 FILTER 절이있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="768669bfb2a31bdc0b9e7999f08750dacabe9b82" translate="yes" xml:space="preserve">
          <source>Window functions come in two varieties: &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;aggregate window functions&lt;/a&gt; and &lt;a href=&quot;windowfunctions#builtins&quot;&gt;built-in window functions&lt;/a&gt;. Every aggregate window function can also work as a ordinary aggregate function, simply by omitting the OVER and FILTER clauses. Furthermore, all of the built-in &lt;a href=&quot;lang_aggfunc&quot;&gt;aggregate functions&lt;/a&gt; of SQLite can be used as an aggregate window function by adding an appropriate OVER clause. Applications can register new aggregate window functions using the &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function()&lt;/a&gt; interface. The built-in window functions, however, require special-case handling in the query planner and hence new window functions that exhibit the exceptional properties found in the built-in window functions cannot be added by the application.</source>
          <target state="translated">창 함수는 &lt;a href=&quot;windowfunctions#aggwinfunc&quot;&gt;집계 창 함수&lt;/a&gt; 와 &lt;a href=&quot;windowfunctions#builtins&quot;&gt;내장 &lt;/a&gt;창 함수의 두 가지 종류가 있습니다 . 모든 집계 창 함수는 단순히 OVER 및 FILTER 절을 생략하여 일반 집계 함수로 작동 할 수도 있습니다. 또한 SQLite의 모든 내장 &lt;a href=&quot;lang_aggfunc&quot;&gt;집계 함수&lt;/a&gt; 는 적절한 OVER 절을 추가하여 집계 창 함수로 사용할 수 있습니다. 응용 프로그램은 &lt;a href=&quot;c3ref/create_function&quot;&gt;sqlite3_create_window_function ()&lt;/a&gt; 인터페이스를 사용하여 새로운 집계 창 함수를 등록 할 수 있습니다 . 그러나 내장 창 기능은 쿼리 플래너에서 특수한 경우 처리가 필요하므로 내장 창 기능에서 발견되는 뛰어난 특성을 나타내는 새 창 기능은 애플리케이션에서 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b69a0cc5bc93433662122b7ab877cc01de2fc8c1" translate="yes" xml:space="preserve">
          <source>Windows DLL exports symbols Tclsqlite_Init and Sqlite_Init</source>
          <target state="translated">Windows DLL에서 Tclsqlite_Init 및 Sqlite_Init 기호를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="a3320dd4ff96aeb28c32b1c618d2fdc870a0f410" translate="yes" xml:space="preserve">
          <source>Windows builds also come with multiple built-in VFSes. The default Windows VFS is called &quot;win32&quot; and is used in most applications. Other VFSes that might be found on windows builds include:</source>
          <target state="translated">Windows 빌드에는 여러 내장 VFS가 제공됩니다. 기본 Windows VFS는 &quot;win32&quot;라고하며 대부분의 응용 프로그램에서 사용됩니다. Windows 빌드에서 발견 될 수있는 다른 VFS는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84eca34acba80a1cc2933e50280e69e2f20b7bbc" translate="yes" xml:space="preserve">
          <source>Windows is unable to truncate a memory-mapped file. Hence, on Windows, if an operation such as &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; or &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; tries to reduce the size of a memory-mapped database file, the size reduction attempt will silently fail, leaving unused space at the end of the database file. No data is lost due to this problem, and the unused space will be reused again the next time the database grows. However if a version of SQLite prior to 3.7.0 runs &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; on such a database, it will (incorrectly) report database corruption due to the unused space at the end. Or if a version of SQLite prior to 3.7.0 writes to the database while it still has unused space at the end, it may make that unused space inaccessible and unavailable for reuse until after the next &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt;.</source>
          <target state="translated">Windows가 메모리 매핑 된 파일을자를 수 없습니다. 따라서 Windows에서 &lt;a href=&quot;lang_vacuum&quot;&gt;VACUUM&lt;/a&gt; 또는 &lt;a href=&quot;pragma#pragma_auto_vacuum&quot;&gt;auto_vacuum&lt;/a&gt; 과 같은 조작 이 메모리 맵핑 된 데이터베이스 파일의 크기를 줄이려고 시도하면 크기 감소 시도가 자동으로 실패하여 데이터베이스 파일의 끝에 사용되지 않은 공간이 남습니다. 이 문제로 인해 데이터가 손실되지 않으며 다음에 데이터베이스가 커질 때 사용되지 않은 공간이 다시 재사용됩니다. 그러나 3.7.0 이전의 SQLite 버전이 이러한 데이터베이스에서 &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 를 실행 하는 경우 끝에 사용되지 않은 공간으로 인해 데이터베이스 손상이 (올바르게)보고됩니다. 또는 3.7.0 이전의 SQLite 버전이 아직 사용되지 않은 공간을 가지고있는 동안 데이터베이스에 쓰면 사용되지 않은 공간에 액세스 할 수없고 다음에이를 때까지 재사용 할 수 없게됩니다.&lt;a href=&quot;lang_vacuum&quot;&gt;진공&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b7712d1cb131a2adfefe7d588175fadb48dafa7" translate="yes" xml:space="preserve">
          <source>Windows only: Open the file &quot;data.db&quot; on fred's desktop on drive C:. Note that the %20 escaping in this example is not strictly necessary - space characters can be used literally in URI filenames.</source>
          <target state="translated">Windows 전용 : C : 드라이브의 fred 데스크탑에서 &quot;data.db&quot;파일을여십시오. 이 예제에서 % 20 이스케이프 처리가 반드시 필요한 것은 아닙니다. 공백 문자는 문자 그대로 URI 파일 이름에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31aeba611599f329aa343c65bc0c86921ffe7f9d" translate="yes" xml:space="preserve">
          <source>Windows users can double-click on the &lt;b&gt;sqlite3.exe&lt;/b&gt; icon to cause the command-line shell to pop-up a terminal window running SQLite. However, because double-clicking starts the sqlite3.exe without command-line arguments, no database file will have been specified, so SQLite will use a temporary database that is deleted when the session exits. To use a persistent disk file as the database, enter the &quot;.open&quot; command immediately after the terminal window starts up:</source>
          <target state="translated">Windows 사용자는 &lt;b&gt;sqlite3.exe&lt;/b&gt; 아이콘을 두 번 클릭 하여 명령 행 쉘이 SQLite를 실행하는 터미널 창을 팝업하도록 할 수 있습니다. 그러나 두 번 클릭하면 명령 줄 인수없이 sqlite3.exe가 시작되므로 데이터베이스 파일이 지정되지 않으므로 SQLite는 세션이 종료 될 때 삭제되는 임시 데이터베이스를 사용합니다. 영구 디스크 파일을 데이터베이스로 사용하려면 터미널 창이 시작된 직후 &quot;.open&quot;명령을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="46ae0e9a494aaadddce1ec0fa75065f4b23d237d" translate="yes" xml:space="preserve">
          <source>With SQLite (but not any other SQL implementation that we know of) if an aggregate query contains a single min() or max() function, then the values of columns used in the output are taken from the row where the min() or max() value was achieved. If two or more rows have the same min() or max() value, then the columns values will be chosen arbitrarily from one of those rows.</source>
          <target state="translated">집계 쿼리에 하나의 min () 또는 max () 함수가 포함 된 경우 SQLite (우리가 알고있는 다른 SQL 구현은 아님)를 사용하면 출력에 사용 된 열 값이 min () 또는 max () 값이 달성되었습니다. 둘 이상의 행에 동일한 min () 또는 max () 값이있는 경우 해당 행 중 하나에서 열 값이 임의로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="72d650183743377687d259d65b2b0b1477f3b0e4" translate="yes" xml:space="preserve">
          <source>With a covering index, SQLite can simply walk the index from one end to the other and deliver the output in time proportional to N and without having allocate a large buffer to hold the result set.</source>
          <target state="translated">커버링 인덱스를 사용하면 SQLite는 한쪽 끝에서 다른 쪽 끝으로 인덱스를 간단히 이동하고 결과 집합을 보유하기 위해 큰 버퍼를 할당하지 않고도 N에 비례하여 시간에 출력을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbb132debbaa76f4f42bce9a72aacb1ba449100" translate="yes" xml:space="preserve">
          <source>With a single allocation size, the &lt;b&gt;n&lt;/b&gt; parameter in the &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson proof&lt;/a&gt; is 1, and the total memory space required by the allocator (&lt;b&gt;N&lt;/b&gt;) is exactly equal to maximum memory used (&lt;b&gt;M&lt;/b&gt;). No additional memory is required to cover fragmentation overhead, thus reducing memory requirements. This is particularly important for the page cache memory since the page cache constitutes the largest component of the memory needs of SQLite.</source>
          <target state="translated">단일 할당 크기 에서 &lt;a href=&quot;malloc#nofrag&quot;&gt;Robson 증명&lt;/a&gt; 의 &lt;b&gt;n&lt;/b&gt; 매개 변수 는 1이며 할당 자 ( &lt;b&gt;N&lt;/b&gt; )에 필요한 총 메모리 공간 은 사용 된 최대 메모리 ( &lt;b&gt;M&lt;/b&gt; ) 와 정확히 같습니다 . 조각화 오버 헤드를 처리하기 위해 추가 메모리가 필요하지 않으므로 메모리 요구 사항이 줄어 듭니다. 페이지 캐시는 SQLite의 메모리 요구 사항 중 가장 큰 구성 요소이므로 페이지 캐시 메모리에 특히 중요합니다.&lt;b&gt;&lt;/b&gt;&lt;b&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="a552e4d61e6c98e72a1a99aa574976a695fc5369" translate="yes" xml:space="preserve">
          <source>With asynchronous I/O, write requests are handled by a separate thread running in the background. This means that the thread that initiates a database write does not have to wait for (sometimes slow) disk I/O to occur. The write seems to happen very quickly, though in reality it is happening at its usual slow pace in the background.</source>
          <target state="translated">비동기 I / O를 사용하면 백그라운드에서 실행중인 별도의 스레드가 쓰기 요청을 처리합니다. 이것은 데이터베이스 쓰기를 시작하는 스레드가 디스크 I / O가 발생할 때까지 기다릴 필요가 없음을 의미합니다. 실제로는 일반적으로 느린 속도로 백그라운드에서 발생하지만 쓰기는 매우 빠르게 발생하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab9e7dc76b3ad69724eb79aea2faff0ba6d5b557" translate="yes" xml:space="preserve">
          <source>With client/server databases like PostgreSQL or Oracle, users and developers tend to think of the database as a service or a &quot;node&quot;, not as an object. This is because the database content is spread out across multiple files on the server, or possibly across multiple servers in a service cluster. One cannot point to a single file or even a single directory and say &quot;this is the database&quot;.</source>
          <target state="translated">PostgreSQL 또는 Oracle과 같은 클라이언트 / 서버 데이터베이스를 통해 사용자와 개발자는 데이터베이스를 객체가 아닌 서비스 또는 &quot;노드&quot;로 생각하는 경향이 있습니다. 데이터베이스 내용이 서버의 여러 파일이나 서비스 클러스터의 여러 서버에 분산되어 있기 때문입니다. 단일 파일 또는 단일 디렉토리를 가리킬 수 없으며 &quot;이것은 데이터베이스입니다&quot;라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="9f913fbcf0e843248e92480f5555045919a3653f" translate="yes" xml:space="preserve">
          <source>With one exception noted below, if a rowid table has a primary key that consists of a single column and the declared type of that column is &quot;INTEGER&quot; in any mixture of upper and lower case, then the column becomes an alias for the rowid. Such a column is usually referred to as an &quot;integer primary key&quot;. A PRIMARY KEY column only becomes an integer primary key if the declared type name is exactly &quot;INTEGER&quot;. Other integer type names like &quot;INT&quot; or &quot;BIGINT&quot; or &quot;SHORT INTEGER&quot; or &quot;UNSIGNED INTEGER&quot; causes the primary key column to behave as an ordinary table column with integer &lt;a href=&quot;datatype3#affinity&quot;&gt;affinity&lt;/a&gt; and a unique index, not as an alias for the rowid.</source>
          <target state="translated">아래에 언급 된 한 가지 예외를 제외하고, rowid 테이블에 단일 열로 구성된 기본 키가 있고 해당 열의 선언 된 유형이 대소 문자를 혼합하여 &quot;INTEGER&quot;인 경우 열은 rowid의 별명이됩니다. 이러한 열을 일반적으로 &quot;정수 기본 키&quot;라고합니다. 선언 된 유형 이름이 정확히 &quot;INTEGER&quot;인 경우 PRIMARY KEY 열은 정수 기본 키만됩니다. &quot;INT&quot;또는 &quot;BIGINT&quot;또는 &quot;SHORT INTEGER&quot;또는 &quot;UNSIGNED INTEGER&quot;와 같은 다른 정수 유형 이름은 기본 키 열 이 rowid의 별명이 아닌 정수 &lt;a href=&quot;datatype3#affinity&quot;&gt;선호도&lt;/a&gt; 와 고유 색인을 가진 일반 테이블 열로 작동하게합니다 .</target>
        </trans-unit>
        <trans-unit id="6d08bbd760872d68db33d3c86cf4e679c7a2ebc9" translate="yes" xml:space="preserve">
          <source>With release 3.8.0 (2013-08-26), the SQLite query planner was reimplemented as the &lt;a href=&quot;queryplanner-ng&quot;&gt;Next Generation Query Planner&lt;/a&gt; or &quot;NGQP&quot;. All of the features, techniques, and algorithms described in this document are applicable to both the pre-3.8.0 legacy query planner and to the NGQP. For further information on how the NGQP differs from the legacy query planner, see the &lt;a href=&quot;queryplanner-ng&quot;&gt;detailed description of the NGQP&lt;/a&gt;.</source>
          <target state="translated">릴리스 3.8.0 (2013-08-26)에서는 SQLite 쿼리 플래너가 &lt;a href=&quot;queryplanner-ng&quot;&gt;차세대 쿼리 플래너&lt;/a&gt; 또는 &quot;NGQP&quot; 로 다시 구현되었습니다 . 이 문서에 설명 된 모든 기능, 기술 및 알고리즘은 3.8.0 이전 레거시 쿼리 플래너와 NGQP에 모두 적용 할 수 있습니다. NGQP와 레거시 쿼리 플래너와의 차이점에 대한 &lt;a href=&quot;queryplanner-ng&quot;&gt;자세한 내용은 NGQP에 대한 자세한 설명을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1d01005af669e498a6d79c05e376c2142afd701" translate="yes" xml:space="preserve">
          <source>With some (arbitrary) data, such a table might be logically stored on disk as shown in figure 1:</source>
          <target state="translated">일부 (임의의) 데이터를 사용하면 그림 1과 같이 이러한 테이블이 디스크에 논리적으로 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd1021b066f8f1badfb5950e8af5b888b38dc724" translate="yes" xml:space="preserve">
          <source>With source code files in the working directory, a DLL can be generated using MSVC with the following command:</source>
          <target state="translated">작업 디렉토리에 소스 코드 파일이 있으면 다음 명령으로 MSVC를 사용하여 DLL을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f39e53b1be71b4fb78a20a47e590c12ddf0bcbb" translate="yes" xml:space="preserve">
          <source>With such a schema, the application would no longer need to make periodic backups of the unsaved changes to a separate file to avoid lost work in the event of a crash. Instead, a special &quot;pending&quot; version could be allocated and unsaved changes could be written into the pending version. Because only changes would need to be written, not the entire document, saving the pending changes would only involve writing a few kilobytes of content, not multiple megabytes, and would take milliseconds instead of seconds, and so it could be done frequently and silently in the background. Then when a crash occurs and the user reboots, all (or almost all) of their work is retained. If the user decides to discard unsaved changes, they simply go back to the previous version.</source>
          <target state="translated">이러한 스키마를 사용하면 응용 프로그램은 더 이상 충돌시 작업 손실을 피하기 위해 저장되지 않은 변경 사항을 별도의 파일에 정기적으로 백업 할 필요가 없습니다. 대신, 특별한 &quot;보류중인&quot;버전을 할당하고 저장하지 않은 변경 사항을 보류중인 버전에 쓸 수 있습니다. 전체 문서가 아닌 변경 사항 만 작성하면되므로 보류중인 변경 내용을 저장하면 수 메가 바이트가 아닌 몇 킬로바이트의 내용 만 작성하면되며 초 대신 밀리 초가 걸리므로 자주 자동으로 수행 할 수 있습니다. 배경. 그런 다음 충돌이 발생하고 사용자가 재부팅되면 모든 작업 (또는 거의 모든 작업)이 유지됩니다. 사용자가 저장하지 않은 변경 사항을 삭제하기로 결정한 경우 단순히 이전 버전으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="1152f09445e7a27bd0f86b5f6b1e7dc6ef22ecb9" translate="yes" xml:space="preserve">
          <source>With synchronous OFF (0), SQLite continues without syncing as soon as it has handed data off to the operating system. If the application running SQLite crashes, the data will be safe, but the database &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;might become corrupted&lt;/a&gt; if the operating system crashes or the computer loses power before that data has been written to the disk surface. On the other hand, commits can be orders of magnitude faster with synchronous OFF.</source>
          <target state="translated">동기 OFF (0)를 사용하면 운영 체제로 데이터를 전달하자마자 SQLite가 동기화되지 않고 계속됩니다. SQLite를 실행하는 응용 프로그램이 충돌하면 데이터는 안전하지만 운영 체제가 충돌하거나 데이터가 디스크 표면에 기록되기 전에 컴퓨터의 전원이 꺼지면 데이터베이스 &lt;a href=&quot;howtocorrupt#cfgerr&quot;&gt;가 손상 될 수 있습니다&lt;/a&gt; . 반면에, 커밋은 동기식 OFF로 수십 배 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e05518cdffbac366023e6a7a1a6316fad89e6a6" translate="yes" xml:space="preserve">
          <source>With the Idx3 index on both columns that are constrained by the WHERE clause, SQLite can do a single binary search against Idx3 to find the one rowid for California oranges, then do a single binary search to find the price for that item in the original table. There are no dead-ends and no wasted binary searches. This is a more efficient query.</source>
          <target state="translated">WHERE 절로 제한되는 두 열 모두에 Idx3 인덱스를 사용하면 SQLite는 Idx3에 대해 단일 이진 검색을 수행하여 California oranges에 대한 하나의 rowid를 찾은 다음 단일 이진 검색을 수행하여 원래 테이블에서 해당 항목의 가격을 찾을 수 있습니다 . 막 다른 골목과 이진 검색이 없습니다. 이것은보다 효율적인 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="d0ccef83367809507d68fd8adf10ab43756d4053" translate="yes" xml:space="preserve">
          <source>With the following provisos, each series of tokens in the FTS table that matches one of the matchable phrases in the query expression is known as a &quot;phrase match&quot;:</source>
          <target state="translated">다음 조항을 사용하면 쿼리 표현식에서 일치하는 구 중 하나와 일치하는 FTS 테이블의 각 시리즈 토큰을 &quot;구문 일치&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="6be83cc240990bde696822c8c968c954935effd4" translate="yes" xml:space="preserve">
          <source>With the schema above, a statement of the form:</source>
          <target state="translated">위의 스키마를 사용하면 다음과 같은 형식의 문장이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce7e1668aa6ca5e4002b24e2ec5db69485e9af33" translate="yes" xml:space="preserve">
          <source>With this pattern, the overall system is still client/server: clients send requests to the server and get back replies over the network. But instead of sending generic SQL and getting back raw table content, the client requests and server responses are high-level and application-specific. The server translates requests into multiple SQL queries, gathers the results, does post-processing, filtering, and analysis, then constructs a high-level reply containing only the essential information.</source>
          <target state="translated">이 패턴을 사용하면 전체 시스템은 여전히 ​​클라이언트 / 서버입니다. 클라이언트는 서버로 요청을 보내고 네트워크를 통해 회신을받습니다. 그러나 일반 SQL을 전송하고 원시 테이블 컨텐츠를 다시 가져 오는 대신 클라이언트 요청 및 서버 응답은 상위 레벨 및 응용 프로그램에 따라 다릅니다. 서버는 요청을 여러 SQL 쿼리로 변환하고 결과를 수집하고 사후 처리, 필터링 및 분석을 수행 한 다음 필수 정보 만 포함하는 높은 수준의 응답을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="a6cde545c87cfe9cdf5083a11aa7253d12946e88" translate="yes" xml:space="preserve">
          <source>With this table, the statement</source>
          <target state="translated">이 표와 함께</target>
        </trans-unit>
        <trans-unit id="e3d30043cb29ededf7f5c7d45d7c85af41b7ac41" translate="yes" xml:space="preserve">
          <source>With this trigger installed, executing the statement:</source>
          <target state="translated">이 트리거가 설치된 상태에서 명령문을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b738f8fb3971eaf9d8b4464f7e01335910aa51fd" translate="yes" xml:space="preserve">
          <source>With tracing mode on, the VDBE prints each instruction prior to executing it. After the instruction is executed, the top few entries in the stack are displayed. The stack display is omitted if the stack is empty.</source>
          <target state="translated">추적 모드가 켜져 있으면 VDBE는 명령을 실행하기 전에 각 명령을 인쇄합니다. 명령이 실행 된 후 스택의 최상위 항목이 표시됩니다. 스택이 비어 있으면 스택 표시가 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="bdf14e9c4b4688dcd43209a6bc661b4142ea27d9" translate="yes" xml:space="preserve">
          <source>With two exceptions, a</source>
          <target state="translated">두 가지 예외가 있지만</target>
        </trans-unit>
        <trans-unit id="bb5693991e33e1156b62932972a48bb594da454a" translate="yes" xml:space="preserve">
          <source>Within a changeset generated by this function, all changes related to a single table are grouped together. In other words, when iterating through a changeset or when applying a changeset to a database, all changes related to a single table are processed before moving on to the next table. Tables are sorted in the same order in which they were attached (or auto-attached) to the sqlite3_session object. The order in which the changes related to a single table are stored is undefined.</source>
          <target state="translated">이 함수에 의해 생성 된 변경 집합 내에서 단일 테이블과 관련된 모든 변경 사항이 함께 그룹화됩니다. 즉, 변경 집합을 반복하거나 데이터베이스에 변경 집합을 적용 할 때 다음 테이블로 이동하기 전에 단일 테이블과 관련된 모든 변경 내용이 처리됩니다. 테이블은 sqlite3_session 오브젝트에 첨부 된 (또는 자동 첨부 된) 순서와 동일한 순서로 정렬됩니다. 단일 테이블과 관련된 변경 사항이 저장되는 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e69d76786ab7b8d267ef6f99888893212d52b234" translate="yes" xml:space="preserve">
          <source>Within a single database connection X, a SELECT statement always sees all changes to the database that are completed prior to the start of the SELECT statement, whether committed or uncommitted. And the SELECT statement obviously does not see any changes that occur after the SELECT statement completes. But what about changes that occur while the SELECT statement is running? What if a SELECT statement is started and the &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; interface steps through roughly half of its output, then some &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; statements are run by the application that modify the table that the SELECT statement is reading, then more calls to &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step()&lt;/a&gt; are made to finish out the SELECT statement? Will the later steps of the SELECT statement see the changes made by the UPDATE or not? The answer is that this behavior is undefined. In particular, whether or not the SELECT statement sees the concurrent changes depends on which release of SQLite is running, the schema of the database file, whether or not &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; has been run, and the details of the query. In some cases, it might depend on the content of the database file, too. There is no good way to know whether or not a SELECT statement will see changes that were made to the database by the same database connection after the SELECT statement was started. And hence, developers should diligently avoid writing applications that make assumptions about what will occur in that circumstance.</source>
          <target state="translated">단일 데이터베이스 연결 X 내에서 SELECT 문은 커미트되거나 커미트되지 않은 상태에서 SELECT 문을 시작하기 전에 완료된 데이터베이스의 모든 변경 사항을 항상 확인합니다. 그리고 SELECT 문은 분명히 SELECT 문이 완료된 후 발생하는 변경 사항을 보지 못합니다. 그러나 SELECT 문이 실행되는 동안 발생하는 변경은 어떻습니까? SELECT 문이 시작되고 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()&lt;/a&gt; 인터페이스가 출력의 거의 절반을 단계적으로 수행 하는 경우 SELECT 문이 읽는 테이블을 수정하는 애플리케이션이 일부 &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; 문을 실행 한 후 &lt;a href=&quot;c3ref/step&quot;&gt;sqlite3_step ()에 대한&lt;/a&gt; 추가 호출SELECT 문을 완성하기 위해 만들어 졌습니까? SELECT 문의 후반부에 UPDATE에 의해 변경된 내용이 표시됩니까? 대답은이 동작이 정의되어 있지 않다는 것입니다. 특히, SELECT 문에서 동시 변경 사항을 볼 수 있는지 여부는 실행중인 SQLite 릴리스, 데이터베이스 파일의 스키마, &lt;a href=&quot;lang_analyze&quot;&gt;ANALYZE&lt;/a&gt; 실행 여부 및 쿼리 세부 사항에 따라 다릅니다 . 경우에 따라 데이터베이스 파일의 내용에 따라 달라질 수도 있습니다. SELECT 문이 시작된 후 동일한 데이터베이스 연결에 의해 SELECT 문이 데이터베이스에 대한 변경 사항을 볼 수 있는지 여부를 알 수있는 좋은 방법은 없습니다. 따라서 개발자는 해당 환경에서 발생할 수있는 상황에 대한 가정을하는 응용 프로그램 작성을 부지런히 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="f64c1e27b35be2c65501356f86b040f4e01382a8" translate="yes" xml:space="preserve">
          <source>Within a trigger program each INSERT, UPDATE and DELETE statement sets the value returned by sqlite3_changes() upon completion as normal. Of course, this value will not include any changes performed by sub-triggers, as the sqlite3_changes() value will be saved and restored after each sub-trigger has run.</source>
          <target state="translated">트리거 프로그램 내에서 각 INSERT, UPDATE 및 DELETE 문은 완료시 sqlite3_changes ()에 의해 리턴 된 값을 정상적으로 설정합니다. 물론,이 값에는 각 하위 트리거가 실행 된 후 sqlite3_changes () 값이 저장 및 복원되므로 하위 트리거에 의해 수행 된 변경 사항이 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a4a4a7b77632610d5c03098170087135a035d198" translate="yes" xml:space="preserve">
          <source>Within an FTS expression a &lt;b&gt;string&lt;/b&gt; may be specified in one of two ways:</source>
          <target state="translated">FTS 표현식 내에서 &lt;b&gt;문자열&lt;/b&gt; 은 다음 두 가지 방법 중 하나로 지정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b69cb3df5f10a8834e6c84cc69fe995f5e513c1e" translate="yes" xml:space="preserve">
          <source>Within an interior b-tree page, each key and the pointer to its immediate left are combined into a structure called a &quot;cell&quot;. The right-most pointer is held separately. A leaf b-tree page has no pointers, but it still uses the cell structure to hold keys for index b-trees or keys and content for table b-trees. Data is also contained in the cell.</source>
          <target state="translated">내부 b- 트리 페이지에서 각 키와 바로 왼쪽의 포인터는 &quot;셀&quot;이라는 구조로 결합됩니다. 가장 오른쪽 포인터는 별도로 유지됩니다. 리프 b- 트리 페이지에는 포인터가 없지만 셀 구조를 사용하여 인덱스 b- 트리의 키 또는 키와 테이블 b- 트리의 내용을 보유합니다. 셀에도 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e7e979d6674438107ff98232bc172bfe9db221b4" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;../vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">&lt;a href=&quot;../vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 내에서 sqlite3_value_nochange (X) 인터페이스는 xUpdate 메소드 호출이 구현하기 위해 호출 된 UPDATE 조작에 의해 X에 해당하는 열이 변경되지 않은 경우에만 그리고 이전 &lt;a href=&quot;../vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드 호출에서 true를 리턴 합니다. 는 결과를 설정하지 않고 반환 된 해당 열의 값을 추출하기 위해 호출되었습니다 (아마도 &lt;a href=&quot;vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()를&lt;/a&gt; 쿼리 하고 열이 변경되지 않았 음을 발견 했기 때문에 ). &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 내에서 sqlite3_value_nochange (X)가 true 인 값은 다른 모든면에서 NULL 값으로 나타납니다. sqlite3_value_nochange (X)가 &lt;a href=&quot;../vtab#xupdate&quot;&gt;xUpdate가&lt;/a&gt; 아닌 다른 곳에서 호출 된 경우메소드가 UPDATE 문을 호출하면 리턴 값은 임의적이며 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6789b1bae7cd2bb76c0159019d7d9fbb4d93f85d" translate="yes" xml:space="preserve">
          <source>Within the &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method of a &lt;a href=&quot;vtab&quot;&gt;virtual table&lt;/a&gt;, the sqlite3_value_nochange(X) interface returns true if and only if the column corresponding to X is unchanged by the UPDATE operation that the xUpdate method call was invoked to implement and if and the prior &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; method call that was invoked to extracted the value for that column returned without setting a result (probably because it queried &lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange()&lt;/a&gt; and found that the column was unchanging). Within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method, any value for which sqlite3_value_nochange(X) is true will in all other respects appear to be a NULL value. If sqlite3_value_nochange(X) is invoked anywhere other than within an &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; method call for an UPDATE statement, then the return value is arbitrary and meaningless.</source>
          <target state="translated">&lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 의 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 내에서 sqlite3_value_nochange (X) 인터페이스는 xUpdate 메소드 호출이 구현하기 위해 호출 된 UPDATE 조작에 의해 X에 해당하는 열이 변경되지 않은 경우에만 그리고 이전 &lt;a href=&quot;vtab#xcolumn&quot;&gt;xColumn&lt;/a&gt; 메소드 호출에서 true를 리턴 합니다. 는 결과를 설정하지 않고 반환 된 해당 열의 값을 추출하기 위해 호출되었습니다 (아마도 &lt;a href=&quot;#sqlite3_vtab_nochange&quot;&gt;sqlite3_vtab_nochange ()를&lt;/a&gt; 쿼리 하고 열이 변경되지 않았 음을 발견 했기 때문에 ). &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate&lt;/a&gt; 메소드 내에서 sqlite3_value_nochange (X)가 true 인 값은 다른 모든면에서 NULL 값으로 나타납니다. sqlite3_value_nochange (X)가 &lt;a href=&quot;vtab#xupdate&quot;&gt;xUpdate가&lt;/a&gt; 아닌 다른 곳에서 호출 된 경우메소드가 UPDATE 문을 호출하면 리턴 값은 임의적이며 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="51af27804794d9726418547af1ae4968a5ef7a8d" translate="yes" xml:space="preserve">
          <source>Within this document, the term</source>
          <target state="translated">이 문서에서 용어</target>
        </trans-unit>
        <trans-unit id="2abd7cfa8c19071145244fc329440378e98735a8" translate="yes" xml:space="preserve">
          <source>Within this document, the term &lt;b&gt;&lt;i&gt;non-writable dirty page&lt;/i&gt;&lt;/b&gt; is used specifically to refer to a</source>
          <target state="translated">이 문서에서 &lt;b&gt;&lt;i&gt;쓰기 불가능한 더티 페이지&lt;/i&gt;&lt;/b&gt; 라는 용어 는 특히</target>
        </trans-unit>
        <trans-unit id="9c7aa2ef11bbb00024927734567cd7e8fb651be6" translate="yes" xml:space="preserve">
          <source>Within your application, call the procedure implemented in the last step above as part of your initialization process before any database connections are opened.</source>
          <target state="translated">응용 프로그램 내에서 데이터베이스 연결을 열기 전에 초기화 프로세스의 일부로 위의 마지막 단계에서 구현 된 절차를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d2b321aabd394218d6d71b6b8d179118941b9c02" translate="yes" xml:space="preserve">
          <source>Without the master journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The master journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="translated">마스터 저널이 없으면 다중 데이터베이스 트랜잭션에 대한 트랜잭션 커미트는 각 데이터베이스마다 개별적이지만 모든 데이터베이스에서 원자 적이지는 않습니다. 즉, 충돌 또는 전원 손실로 인해 커밋이 중간에 중단 된 경우 데이터베이스 중 하나에 대한 변경이 완료되는 동안 다른 데이터베이스에 대한 변경이 롤백 될 수 있습니다. 마스터 저널은 모든 데이터베이스의 모든 변경 사항이 롤백 또는 커미트되도록합니다.</target>
        </trans-unit>
        <trans-unit id="7c3fafa3b408ed62c81a7e1dcfba262f7d167cb3" translate="yes" xml:space="preserve">
          <source>Without the super-journal, the transaction commit on a multi-database transaction would be atomic for each database individually, but it would not be atomic across all databases. In other words, if the commit were interrupted in the middle by a crash or power loss, then the changes to one of the databases might complete while the changes to another database might roll back. The super-journal causes all changes in all databases to either rollback or commit together.</source>
          <target state="translated">수퍼 저널이 없으면 다중 데이터베이스 트랜잭션에 대한 트랜잭션 커밋은 각 데이터베이스에 대해 개별적으로 원자 적이지만 모든 데이터베이스에서 원자 적은 아닙니다. 즉, 충돌이나 정전으로 인해 커밋이 중간에 중단 된 경우 데이터베이스 중 하나에 대한 변경이 완료되고 다른 데이터베이스에 대한 변경이 롤백 될 수 있습니다. 수퍼 저널은 모든 데이터베이스의 모든 변경 사항을 롤백하거나 함께 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="d6dd78a3d415f93746301f9a57f0de1998136848" translate="yes" xml:space="preserve">
          <source>Words beginning with &quot;wr&quot; versus &quot;r&quot;: write vs. rite</source>
          <target state="translated">&quot;wr&quot;과 &quot;r&quot;로 시작하는 단어 : write vs. rite</target>
        </trans-unit>
        <trans-unit id="87bffc88b4c4749365cee3251faa81be81f0ebe9" translate="yes" xml:space="preserve">
          <source>Work around a C-preprocessor macro conflict that breaks the build for some configurations with Microsoft Visual Studio.</source>
          <target state="translated">Microsoft Visual Studio의 일부 구성에 대한 빌드를 손상시키는 C 전 처리기 매크로 충돌을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="50aee533edd4e21305ef90f99451cd9467951df2" translate="yes" xml:space="preserve">
          <source>Work around a GCC optimizer bug (for gcc 4.2.1 on MacOS 10.7) that caused the &lt;a href=&quot;rtree&quot;&gt;R-Tree extension&lt;/a&gt; to compute incorrect results when compiled with -O3.</source>
          <target state="translated">-O3으로 컴파일 할 때 &lt;a href=&quot;rtree&quot;&gt;R-Tree 확장 프로그램&lt;/a&gt; 이 잘못된 결과를 계산하게 하는 GCC 최적화 프로그램 버그 (MacOS 10.7의 gcc 4.2.1)를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfd059bf7f3cb496ecc6f63b39e721653d7d6b6d" translate="yes" xml:space="preserve">
          <source>Work around a bug in the optimizer in the VisualStudio-2012 compiler that causes invalid code to be generated when compiling SQLite on ARM.</source>
          <target state="translated">ARM에서 SQLite를 컴파일 할 때 잘못된 코드가 생성되도록하는 VisualStudio-2012 컴파일러의 최적화 프로그램의 버그를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="05fe4e3a69bacc20ca972b8ceb1bc5a0e767ed20" translate="yes" xml:space="preserve">
          <source>Work around a sign-extension bug in the optimizer of the HP C compiler on HP/UX. &lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;(details)&lt;/a&gt;</source>
          <target state="translated">HP / UX에서 HP C 컴파일러 최적화 프로그램의 부호 확장 버그를 해결하십시오. &lt;a href=&quot;https://www.sqlite.org/src/fdiff?sbs=1&amp;amp;v1=869c95b0fc73026d&amp;amp;v2=232c242a0ccb3d67&quot;&gt;(세부)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f7e0b96e4d5af469559bc4b5418e841b0585e67" translate="yes" xml:space="preserve">
          <source>Work around a win2k problem so that SQLite can use single-character database file names</source>
          <target state="translated">SQLite가 단일 문자 데이터베이스 파일 이름을 사용할 수 있도록 win2k 문제를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="620ea823b219e2193e9c0c9d76d068c0c91681bb" translate="yes" xml:space="preserve">
          <source>Work around an optimizer bug in the MSVC compiler when targeting ARM.</source>
          <target state="translated">ARM을 대상으로 할 때 MSVC 컴파일러의 최적화 버그를 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a3e9e586b4abc65bd66b99ca41670f3c121bb4" translate="yes" xml:space="preserve">
          <source>Work-around for &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC bug 32575&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32575&quot;&gt;GCC 버그 32575에&lt;/a&gt; 대한 해결 방법 .</target>
        </trans-unit>
        <trans-unit id="cebdf47773b9831e663aaa2b137f8c46c76becbf" translate="yes" xml:space="preserve">
          <source>Would be rewritten using query flattening as:</source>
          <target state="translated">쿼리 병합을 사용하여 다음과 같이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="adefeee85f8390b904f622c9dadd9084253d11b9" translate="yes" xml:space="preserve">
          <source>Wrap SQL output in a single large transaction</source>
          <target state="translated">하나의 큰 트랜잭션으로 SQL 출력 랩</target>
        </trans-unit>
        <trans-unit id="a38083e109d2e7a4d69cbaa3489444f640acbb5f" translate="yes" xml:space="preserve">
          <source>Write Data Into A BLOB Incrementally</source>
          <target state="translated">점차적으로 BLOB에 데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="d7f59c7d18e98edd2a33e30c67d681015a12865e" translate="yes" xml:space="preserve">
          <source>Write P4 on the statement trace output if statement tracing is enabled.</source>
          <target state="translated">명령문 추적이 사용 가능한 경우 명령문 추적 출력에 P4를 기록하십시오.</target>
        </trans-unit>
        <trans-unit id="01ecf2ccbe2bc061336d1857718a14b0b49fee20" translate="yes" xml:space="preserve">
          <source>Write Programs That Use SQLite</source>
          <target state="translated">SQLite를 사용하는 프로그램 작성</target>
        </trans-unit>
        <trans-unit id="57477c30051b84c96ed41136ab16ff89bef76c1e" translate="yes" xml:space="preserve">
          <source>Write Transactions</source>
          <target state="translated">거래 쓰기</target>
        </trans-unit>
        <trans-unit id="7792ea49e68a0636ee3df8abc86c43dc971f4500" translate="yes" xml:space="preserve">
          <source>Write a NULL into registers P2. If P3 greater than P2, then also write NULL into register P3 and every register in between P2 and P3. If P3 is less than P2 (typically P3 is zero) then only register P2 is set to NULL.</source>
          <target state="translated">레지스터 P2에 NULL을 씁니다. P3이 P2보다 큰 경우에는 레지스터 P3에 NULL을 쓰고 P2와 P3 사이의 모든 레지스터도 기록합니다. P3이 P2보다 작 으면 (일반적으로 P3은 0) 레지스터 P2 만 NULL로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4b067f7f133cef5bf8ac788b6955ee101e88869d" translate="yes" xml:space="preserve">
          <source>Write a string containing the final journal-mode to register P2.</source>
          <target state="translated">P2를 등록 할 최종 저널 모드가 포함 된 문자열을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="b758b03a1915378a4790dfdd86b8e50a7bacf82d" translate="yes" xml:space="preserve">
          <source>Write all necessary methods.</source>
          <target state="translated">필요한 모든 방법을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="96dcd721393f2668fc3f8e665d514a96620cfebb" translate="yes" xml:space="preserve">
          <source>Write all page modifications currently held in memory out to the original database disk file.</source>
          <target state="translated">현재 메모리에있는 모든 페이지 수정 사항을 원본 데이터베이스 디스크 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="1687a8d3ed30cb7eb791ed33a931d8ace68eaab0" translate="yes" xml:space="preserve">
          <source>Write an entry into the table of cursor P1. A new entry is created if it doesn't already exist or the data for an existing entry is overwritten. The data is the value MEM_Blob stored in register number P2. The key is stored in register P3. The key must be a MEM_Int.</source>
          <target state="translated">커서 P1의 테이블에 항목을 작성하십시오. 새 항목이 존재하지 않거나 기존 항목의 데이터를 덮어 쓰면 새 항목이 작성됩니다. 데이터는 레지스터 번호 P2에 저장된 값 MEM_Blob입니다. 키는 레지스터 P3에 저장됩니다. 키는 MEM_Int 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d5c23fb528e11a09e4afc8b5a2e279f79a841784" translate="yes" xml:space="preserve">
          <source>Write into register P2 an integer which is the last entry in the record at the end of the index key pointed to by cursor P1. This integer should be the rowid of the table entry to which this index entry points.</source>
          <target state="translated">커서 P1이 가리키는 인덱스 키 끝에있는 레코드의 마지막 항목 인 정수를 레지스터 P2에 씁니다. 이 정수는이 인덱스 항목이 가리키는 테이블 항목의 rowid 여야합니다.</target>
        </trans-unit>
        <trans-unit id="845ccbd564d152c911058efd13330cea72170f39" translate="yes" xml:space="preserve">
          <source>Write into register P2 the complete row content for the row at which cursor P1 is currently pointing. There is no interpretation of the data. It is just copied onto the P2 register exactly as it is found in the database file.</source>
          <target state="translated">커서 P1이 현재 가리키는 행의 전체 행 내용을 레지스터 P2에 씁니다. 데이터에 대한 해석이 없습니다. 데이터베이스 파일에있는 그대로 P2 레지스터에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="d4da38aa74dee90d46d653efba3b56536b2cc5d2" translate="yes" xml:space="preserve">
          <source>Write into register P2 the current sorter data for sorter cursor P1. Then clear the column header cache on cursor P3.</source>
          <target state="translated">분류기 커서 P1에 대한 현재 분류기 데이터를 레지스터 P2에 씁니다. 그런 다음 커서 P3에서 열 헤더 캐시를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="4e60b462188e6078fccee2b0f7f0c97876c061b9" translate="yes" xml:space="preserve">
          <source>Write performance measurements were made by replacing (overwriting) an entire blob with a different blob. All of the blobs in these experiment are random and incompressible. Because writes are so much slower than reads, only 10,000 of the 100,000 blobs in the database are replaced. The blobs to be replaced are selected at random and are in no particular order.</source>
          <target state="translated">전체 블롭을 다른 블롭으로 교체 (덮어 쓰기)하여 쓰기 성능 측정을 수행했습니다. 이 실험에서 모든 블로 브는 무작위이며 압축 할 수 없습니다. 쓰기는 읽기보다 속도가 너무 느리기 때문에 데이터베이스의 100,000 Blob 중 10,000 개만 바뀝니다. 교체 할 얼룩은 무작위로 선택되며 특별한 순서는 없습니다.</target>
        </trans-unit>
        <trans-unit id="97d379c9ca883f0cc777a01b05087d4f85759f23" translate="yes" xml:space="preserve">
          <source>Write the current address onto register P1 and then jump to address P2.</source>
          <target state="translated">현재 주소를 레지스터 P1에 쓴 다음 주소 P2로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b9ace1191ba47c3313a30683407724719ddd8866" translate="yes" xml:space="preserve">
          <source>Write the current number of pages in database P1 to memory cell P2.</source>
          <target state="translated">데이터베이스 P1의 현재 페이지 수를 메모리 셀 P2에 씁니다.</target>
        </trans-unit>
        <trans-unit id="91954b8458d0e00b292061c02fc82b69cf42b6c1" translate="yes" xml:space="preserve">
          <source>Write the integer value P3 into cookie number P2 of database P1. P2==1 is the schema version. P2==2 is the database format. P2==3 is the recommended pager cache size, and so forth. P1==0 is the main database file and P1==1 is the database file used to store temporary tables.</source>
          <target state="translated">정수 값 P3을 데이터베이스 P1의 쿠키 번호 P2에 씁니다. P2 == 1은 스키마 버전입니다. P2 == 2는 데이터베이스 형식입니다. P2 == 3은 권장되는 호출기 캐시 크기 등입니다. P1 == 0은 기본 데이터베이스 파일이고 P1 == 1은 임시 테이블을 저장하는 데 사용되는 데이터베이스 파일입니다.</target>
        </trans-unit>
        <trans-unit id="4f557ab176f965a00361710b6f978bd703c87e93" translate="yes" xml:space="preserve">
          <source>Write the name of the master journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="translated">마스터 저널의 이름을 모든 개별 저널에 기록하고 (개별 저널 헤더에 해당 목적을 위해 설정된 공간에) 개별 저널의 컨텐츠를 디스크로 플러시하고 해당 변경 사항이 디스크 표면에 도달 할 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="461c6fd84d21b2e1e58564d3f66dc64dc514f582" translate="yes" xml:space="preserve">
          <source>Write the name of the super-journal into all individual journals (in space set aside for that purpose in the headers of the individual journals) and flush the contents of the individual journals to disk and wait for those changes to reach the disk surface.</source>
          <target state="translated">수퍼 저널의 이름을 모든 개별 저널 (개별 저널의 헤더에 해당 목적을 위해 따로 마련된 공간)에 쓰고 개별 저널의 내용을 디스크에 플러시하고 변경 사항이 디스크 표면에 도달 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="d7664f788d5d10d956cebf109c73130c0a103849" translate="yes" xml:space="preserve">
          <source>Write transactions are very fast since they only involve writing the content once (versus twice for rollback-journal transactions) and because the writes are all sequential. Further, syncing the content to the disk is not required, as long as the application is willing to sacrifice durability following a power loss or hard reboot. (Writers sync the WAL on every transaction commit if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to FULL but omit this sync if &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA synchronous&lt;/a&gt; is set to NORMAL.)</source>
          <target state="translated">쓰기 트랜잭션은 내용을 한 번만 작성하고 (롤백 저널 트랜잭션의 경우 두 번), 쓰기가 모두 순차적이기 때문에 매우 빠릅니다. 또한 응용 프로그램이 전원 손실이나 하드 재부팅 후 내구성을 희생하려는 경우에는 내용을 디스크에 동기화 할 필요가 없습니다. &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 FULL로 설정된 경우 기록기 는 모든 트랜잭션 커밋에서 WAL을 동기화 하지만 &lt;a href=&quot;pragma#pragma_synchronous&quot;&gt;PRAGMA 동기&lt;/a&gt; 가 NORMAL로 설정된 경우이 동기화를 생략합니다 .</target>
        </trans-unit>
        <trans-unit id="9df19c54f436b6a77ec7817a689a3cb7a8863393" translate="yes" xml:space="preserve">
          <source>Write-Ahead Log Commit Hook</source>
          <target state="translated">미리 쓰기 로그 커밋 후크</target>
        </trans-unit>
        <trans-unit id="7012a3c8e49b82c45441c8c9cad604aa604cafd1" translate="yes" xml:space="preserve">
          <source>Write-Ahead Logging</source>
          <target state="translated">미리 쓰기 로깅</target>
        </trans-unit>
        <trans-unit id="0e7776631ee4a8b853c6c06ce06a6006cefcda96" translate="yes" xml:space="preserve">
          <source>Write-ahead Log (WAL) files</source>
          <target state="translated">미리 쓰기 로그 (WAL) 파일</target>
        </trans-unit>
        <trans-unit id="e1b6c7d9217381e4c29658c4e3841e70686fb388" translate="yes" xml:space="preserve">
          <source>Writer starvation</source>
          <target state="translated">작가 기아</target>
        </trans-unit>
        <trans-unit id="e447e06606fdc13a8e426bfdd192c63a84795c86" translate="yes" xml:space="preserve">
          <source>Writers merely append new content to the end of the WAL file. Because writers do nothing that would interfere with the actions of readers, writers and readers can run at the same time. However, since there is only one WAL file, there can only be one writer at a time.</source>
          <target state="translated">작성자는 WAL 파일 끝에 새로운 내용을 추가하기 만합니다. 작가는 독자의 행동을 방해하는 행동을하지 않기 때문에 작가와 독자는 동시에 실행할 수 있습니다. 그러나 WAL 파일은 하나뿐이므로 한 번에 하나의 작성자 만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a81481b69a429427cf443afa9b0e120124c1b5" translate="yes" xml:space="preserve">
          <source>Writes are slower. On all systems, using both direct I/O and SQLite, write performance is between 5 and 15 times slower than reads.</source>
          <target state="translated">쓰기 속도가 느립니다. 직접 I / O와 SQLite를 모두 사용하는 모든 시스템에서 쓰기 성능은 읽기보다 5 ~ 15 배 느립니다.</target>
        </trans-unit>
        <trans-unit id="a90f9ae1890da2882ef529c18fb80a5589473876" translate="yes" xml:space="preserve">
          <source>Writes to an in-memory source database, or writes to a file-based source database by an external process or thread using a database connection other than pDb are significantly more expensive than writes made to a file-based source database using pDb (as the entire backup operation must be restarted in the former two cases).</source>
          <target state="translated">pDb 이외의 데이터베이스 연결을 사용하는 외부 프로세스 나 스레드가 메모리 내 소스 데이터베이스에 쓰거나 파일 기반 소스 데이터베이스에 쓰면 pDb를 사용하는 파일 기반 소스 데이터베이스에 대한 쓰기보다 비용이 훨씬 비쌉니다. 이전 두 경우에는 전체 백업 작업을 다시 시작해야합니다).</target>
        </trans-unit>
        <trans-unit id="347af0bc198470df77e05081b38d5bcb19f95263" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">&lt;a href=&quot;../dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; 가상 테이블에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="caebec0b3978142dd7d784c5a70a27f827c0fc87" translate="yes" xml:space="preserve">
          <source>Writes to the &lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; virtual table.</source>
          <target state="translated">&lt;a href=&quot;dbpage&quot;&gt;sqlite_dbpage&lt;/a&gt; 가상 테이블에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="9e632869f49afb8aba3986c578bc41023c0edd69" translate="yes" xml:space="preserve">
          <source>Writing Data</source>
          <target state="translated">데이터 쓰기</target>
        </trans-unit>
        <trans-unit id="46bd9ed0bb52c21d70902da8961ddf970beec522" translate="yes" xml:space="preserve">
          <source>Writing a Journal Header</source>
          <target state="translated">저널 헤더 작성</target>
        </trans-unit>
        <trans-unit id="563ef87c29c874b30c909b9cb710bc0c375b3734" translate="yes" xml:space="preserve">
          <source>Writing a good query planner is more art than science. The query planner must work with incomplete information. It cannot determine how long any particular plan will take without actually running that plan. So when comparing two or more plans to figure out which is &quot;best&quot;, the query planner has to make some guesses and assumptions and those guesses and assumptions will sometimes be wrong. A good query planner is one that will find the correct solution often enough that application programmers rarely need to get involved.</source>
          <target state="translated">좋은 쿼리 플래너를 작성하는 것은 과학보다 예술입니다. 쿼리 플래너는 불완전한 정보로 작업해야합니다. 실제로 해당 계획을 실행하지 않으면 특정 계획에 소요되는 시간을 결정할 수 없습니다. 따라서 둘 중 하나 이상의 계획이 &quot;최고의&quot;계획임을 비교할 때 쿼리 플래너는 몇 가지 추측과 가정을해야하며 이러한 추측과 가정은 때때로 틀릴 수 있습니다. 좋은 쿼리 플래너는 응용 프로그램 프로그래머가 거의 참여할 필요가없는 정확한 솔루션을 찾는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="0cde81e7d9009da11d97881af257b1563f71fbed" translate="yes" xml:space="preserve">
          <source>Writing the code for a new VFS involves constructing a subclass for the &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; object and then registering that VFS object using a call to &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register()&lt;/a&gt;. The VFS implementation also provides subclasses for &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; and &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; but those objects are not registered directly with SQLite. Instead, the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object is returned from the xOpen method of &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; and the &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; object points to an instance of the &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods&lt;/a&gt; object.</source>
          <target state="translated">새 VFS의 코드를 작성하려면 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 객체 의 서브 클래스를 생성 한 다음 &lt;a href=&quot;c3ref/vfs_find&quot;&gt;sqlite3_vfs_register ()&lt;/a&gt; 호출을 사용하여 해당 VFS 객체를 등록해야합니다 . VFS 구현은 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 및 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods에&lt;/a&gt; 대한 서브 클래스도 제공 하지만 해당 오브젝트는 SQLite에 직접 등록되지 않습니다. 대신, &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file의&lt;/a&gt; 객체의 XOPEN 메서드에서 반환되는 &lt;a href=&quot;c3ref/vfs&quot;&gt;sqlite3_vfs&lt;/a&gt; 과 &lt;a href=&quot;c3ref/file&quot;&gt;sqlite3_file&lt;/a&gt; 의 인스턴스에 객체 포인트 &lt;a href=&quot;c3ref/io_methods&quot;&gt;sqlite3_io_methods의&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7fdb521941b3e5056a81c587e69b7f19860828e9" translate="yes" xml:space="preserve">
          <source>Written in ANSI-C. &lt;a href=&quot;tclsqlite&quot;&gt;TCL bindings&lt;/a&gt; included. Bindings for dozens of other languages available separately.</source>
          <target state="translated">ANSI-C로 작성되었습니다. &lt;a href=&quot;tclsqlite&quot;&gt;TCL 바인딩이&lt;/a&gt; 포함되었습니다. 수십 가지 다른 언어에 대한 바인딩은 별도로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="ab87b9a32f29182878ebb3a6891a6c4a1092d9ec" translate="yes" xml:space="preserve">
          <source>X is U-35 for table btree leaf pages or ((U-12)*64/255)-23 for index pages.</source>
          <target state="translated">X는 테이블 btree 리프 페이지의 경우 U-35이거나 인덱스 페이지의 경우 ((U-12) * 64 / 255) -23입니다.</target>
        </trans-unit>
        <trans-unit id="a43e2726d178277e17345f240dc4baecfd6ece05" translate="yes" xml:space="preserve">
          <source>XLS - Microsoft Excel Spreadsheet</source>
          <target state="translated">XLS-Microsoft Excel 스프레드 시트</target>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="d3f8f7b810c4b08f0b4ac4e47fdf8d265a10d869" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD</source>
          <target state="translated">YYYY-MM-DD</target>
        </trans-unit>
        <trans-unit id="52249b595b705e3022543f7da9fd802190e92e98" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM</source>
          <target state="translated">YYYY-MM-DD HH : MM</target>
        </trans-unit>
        <trans-unit id="5d7d8fa1d70072dde246c61070188c4587305f0a" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS</source>
          <target state="translated">YYYY-MM-DD HH : MM : SS</target>
        </trans-unit>
        <trans-unit id="c73c8c3ce69182be88dad37758ba32a3fc0f8563" translate="yes" xml:space="preserve">
          <source>YYYY-MM-DD HH:MM:SS.SSS</source>
          <target state="translated">YYYY-MM-DD HH : MM : SS.SSS</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="5374d3a8e418edba680d4a07da2c6ab36a4e8962" translate="yes" xml:space="preserve">
          <source>Yes. SQLite is in the &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;public domain&lt;/a&gt;. No claim of ownership is made to any part of the code. You can do anything you want with it.</source>
          <target state="translated">예. SQLite는 &lt;a href=&quot;https://sqlite.org/copyright.html&quot;&gt;공개 도메인에&lt;/a&gt; 있습니다. 코드의 어느 부분에도 소유권 주장이 없습니다. 당신이 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="84033aeb092c1214f0c2cb3aece38e6ba6958175" translate="yes" xml:space="preserve">
          <source>Yields 20 results beginning with:</source>
          <target state="translated">다음으로 시작하는 20 개의 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0e3a778de9e9a5f44253370ab8c9e4efcbf47122" translate="yes" xml:space="preserve">
          <source>You can access the ROWID of an SQLite table using one of the special column names ROWID, _ROWID_, or OID. Except if you declare an ordinary table column to use one of those special names, then the use of that name will refer to the declared column not to the internal ROWID.</source>
          <target state="translated">특수 열 이름 ROWID, _ROWID_ 또는 OID 중 하나를 사용하여 SQLite 테이블의 ROWID에 액세스 할 수 있습니다. 특수 테이블 중 하나를 사용하도록 일반 테이블 컬럼을 선언하는 경우를 제외하고, 해당 이름의 사용은 내부 ROWID가 아닌 선언 된 컬럼을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="f9617c865e05039ea284590d342ff395b566aa5e" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;appfunc&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="translated">&quot;.load&quot;명령을 사용하여 런타임에 명령 줄 셸에 새로운 사용자 지정 &lt;a href=&quot;appfunc&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; , &lt;a href=&quot;datatype3#collation&quot;&gt;조합 시퀀스&lt;/a&gt; , &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 추가 할 수 있습니다 . 먼저 확장을 DLL 또는 공유 라이브러리 ( &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; 문서에 설명 됨)로 변환 한 후 다음을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="766fd041e7449721a800b8d56d1a550c8e84e175" translate="yes" xml:space="preserve">
          <source>You can add new custom &lt;a href=&quot;c3ref/create_function&quot;&gt;application-defined SQL functions&lt;/a&gt;, &lt;a href=&quot;datatype3#collation&quot;&gt;collating sequences&lt;/a&gt;, &lt;a href=&quot;vtab&quot;&gt;virtual tables&lt;/a&gt;, and &lt;a href=&quot;vfs&quot;&gt;VFSes&lt;/a&gt; to the command-line shell at run-time using the &quot;.load&quot; command. First, convert the extension in to a DLL or shared library (as described in the &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; document) then type:</source>
          <target state="translated">&quot;.load&quot;명령을 사용하여 새로운 사용자 정의 &lt;a href=&quot;c3ref/create_function&quot;&gt;응용 프로그램 정의 SQL 함수&lt;/a&gt; , &lt;a href=&quot;datatype3#collation&quot;&gt;조합 순서&lt;/a&gt; , &lt;a href=&quot;vtab&quot;&gt;가상 테이블&lt;/a&gt; 및 &lt;a href=&quot;vfs&quot;&gt;VFS&lt;/a&gt; 를 런타임시 명령 행 쉘에 추가 할 수 있습니다 . 먼저 확장명을 DLL 또는 공유 라이브러리로 변환 한 후 ( &lt;a href=&quot;loadext&quot;&gt;Run-Time Loadable Extensions&lt;/a&gt; 문서에 설명 된대로 ) 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="f503e6243f11ce8864a2a2815733bb53ffb62dce" translate="yes" xml:space="preserve">
          <source>You can also process the results of a query one row at a time by specifying the name of an array variable and a script following the SQL code. For each row of the query result, the values of all columns will be inserted into the array variable and the script will be executed. For instance:</source>
          <target state="translated">배열 변수의 이름과 SQL 코드 다음에 스크립트를 지정하여 한 번에 한 행씩 쿼리 결과를 처리 할 수도 있습니다. 쿼리 결과의 각 행에 대해 모든 열의 값이 배열 변수에 삽입되고 스크립트가 실행됩니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="cff814001d9391d1134a9599b4429c6538fee547" translate="yes" xml:space="preserve">
          <source>You can also provide the virtual table with a &quot;rank&quot; for each word. The &quot;rank&quot; is an estimate of how common the word is. Larger numbers mean the word is more common. If you omit the rank when populating the table, then a rank of 1 is assumed. But if you have rank information, you can supply it and the virtual table will show a slight preference for selecting more commonly used terms. To populate the rank from an fts4aux table &quot;search_aux&quot; do something like this:</source>
          <target state="translated">각 단어에 대한 &quot;순위&quot;를 가상 테이블에 제공 할 수도 있습니다. &quot;순위&quot;는 단어가 얼마나 일반적인지를 추정 한 것입니다. 숫자가 클수록 단어가 더 일반적입니다. 테이블을 채울 때 순위를 생략하면 순위가 1로 가정됩니다. 그러나 순위 정보가있는 경우이를 제공 할 수 있으며 가상 테이블에보다 일반적으로 사용되는 용어를 선택하기위한 약간의 기본 설정이 표시됩니다. fts4aux 테이블 &quot;search_aux&quot;에서 순위를 채우려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="adf32fc901d0b3c9c4d8f663c01fbe75c182af0b" translate="yes" xml:space="preserve">
          <source>You can also request a reverse-order sort like this:</source>
          <target state="translated">다음과 같이 역순 정렬을 요청할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6faf0acbd59c9b880e0b1c9b8cab39235a6257e9" translate="yes" xml:space="preserve">
          <source>You can call your project anything you like. The &quot;&lt;code&gt;.fossil&lt;/code&gt;&quot; suffix is optional. For this document, we will continue to call the project &quot;&lt;code&gt;private-project.fossil&lt;/code&gt;&quot;. Note that &lt;code&gt;private-project.fossil&lt;/code&gt; is an ordinary disk file (actually an SQLite database) that will contain your complete project history. You can make a backup of the project simply by making a copy of that one file.</source>
          <target state="translated">원하는대로 프로젝트를 호출 할 수 있습니다. &quot; &lt;code&gt;.fossil&lt;/code&gt; &quot;접미사는 선택 사항입니다. 이 문서에서는 계속해서 &quot; &lt;code&gt;private-project.fossil&lt;/code&gt; &quot; 프로젝트를 호출 할 것 입니다. 하는 것으로 &lt;code&gt;private-project.fossil&lt;/code&gt; 완전한 프로젝트 기록을 포함 일반 디스크 파일 (실제로 SQLite는 데이터베이스를)입니다. 하나의 파일을 복사하여 프로젝트를 백업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7e393b006953ea5c66642b8797a473726aa00ab" translate="yes" xml:space="preserve">
          <source>You can have multiple checkouts of the same project if you want. And you can &quot;clone&quot; the repository to different machines so that multiple developers can use it. See the fossil website for further information.</source>
          <target state="translated">원하는 경우 동일한 프로젝트를 여러 번 체크 아웃 할 수 있습니다. 또한 여러 개발자가 사용할 수 있도록 저장소를 다른 시스템에 &quot;복제&quot;할 수 있습니다. 자세한 내용은 화석 웹 사이트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0eaaecfbb43e45dd392f3506c8da0516ce5d97d1" translate="yes" xml:space="preserve">
          <source>You can run the &quot;info&quot; command again to verify that you are on the private branch. To go back to the public branch, type:</source>
          <target state="translated">&quot;info&quot;명령을 다시 실행하여 개인 브랜치에 있는지 확인할 수 있습니다. 공공 지점으로 돌아가려면 다음을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="445e03eebf2a496b04ef2b41a7e5575686b7c24c" translate="yes" xml:space="preserve">
          <source>You can see how SQLite constructs nested loops in the following example:</source>
          <target state="translated">다음 예제에서 SQLite가 중첩 루프를 구성하는 방법을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64e589fcb69790fd074e7b79362cd1b733d9786f" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; to do a thorough but time intensive test of the database integrity.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_integrity_check&quot;&gt;PRAGMA integrity_check&lt;/a&gt; 를 사용 하여 데이터베이스 무결성을 철저하지만 시간 집약적으로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89132b9f9cffd74c2cdc7fb086ca8110533325a1" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; to do a faster but less thorough test of the database integrity.</source>
          <target state="translated">&lt;a href=&quot;pragma#pragma_quick_check&quot;&gt;PRAGMA quick_check&lt;/a&gt; 를 사용 하여 데이터베이스 무결성을 더 빠르지 만 덜 철저하게 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="322edc4ffe1c2dcc35efd77efa0d7e1857777962" translate="yes" xml:space="preserve">
          <source>You can use the &quot;.mode&quot; dot command to switch between these output formats. &amp;gt;The default output mode is &quot;list&quot;. In list mode, each row of a query result is written on one line of output and each column within that row is separated by a specific separator string. The default separator is a pipe symbol (&quot;|&quot;). List mode is especially useful when you are going to send the output of a query to another program (such as AWK) for additional processing.</source>
          <target state="translated">&quot;.mode&quot;도트 명령을 사용하여 이러한 출력 형식간에 전환 할 수 있습니다. &amp;gt; 기본 출력 모드는 &quot;목록&quot;입니다. 목록 모드에서 쿼리 결과의 각 행은 한 줄의 출력에 기록되고 해당 행 내의 각 열은 특정 구분자 문자열로 구분됩니다. 기본 구분 기호는 파이프 기호 ( &quot;|&quot;)입니다. 목록 모드는 추가 처리를 위해 쿼리 출력을 다른 프로그램 (예 : AWK)으로 보낼 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e92aed886574f82b46aed1073eadf0a43514f93b" translate="yes" xml:space="preserve">
          <source>You cannot &lt;a href=&quot;lang_delete&quot;&gt;DELETE&lt;/a&gt;, &lt;a href=&quot;lang_insert&quot;&gt;INSERT&lt;/a&gt;, or &lt;a href=&quot;lang_update&quot;&gt;UPDATE&lt;/a&gt; a view. Views are read-only in SQLite. However, in many cases you can use an &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF trigger&lt;/a&gt; on the view to accomplish the same thing. Views are removed with the &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; command.</source>
          <target state="translated">뷰를 &lt;a href=&quot;lang_delete&quot;&gt;삭제&lt;/a&gt; , &lt;a href=&quot;lang_insert&quot;&gt;삽입&lt;/a&gt; 또는 &lt;a href=&quot;lang_update&quot;&gt;업데이트&lt;/a&gt; 할 수 없습니다 . 뷰는 SQLite에서 읽기 전용입니다. 그러나 많은 경우 에보기에서 &lt;a href=&quot;lang_createtrigger#instead_of_trigger&quot;&gt;INSTEAD OF 트리거&lt;/a&gt; 를 사용하여 동일한 작업을 수행 할 수 있습니다 . &lt;a href=&quot;lang_dropview&quot;&gt;DROP VIEW&lt;/a&gt; 명령으로 뷰가 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3029ec6343085341759c5984c721d08ac8eda9c" translate="yes" xml:space="preserve">
          <source>You lose Durability with asynchronous I/O, but you still retain the other parts of ACID: Atomic, Consistent, and Isolated. Many applications get along fine without the Durability.</source>
          <target state="translated">비동기 I / O를 사용하면 내구성이 떨어지지 만 ACID의 다른 부분 인 원자, 일관성 및 격리는 계속 유지됩니다. 많은 응용 프로그램이 내구성없이 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2edf5e92e2eb8b4ae5fa4b416e11d2c19ee0f6b2" translate="yes" xml:space="preserve">
          <source>You may want to add additional compiler options, of course, according to the needs of your project.</source>
          <target state="translated">물론 프로젝트의 필요에 따라 추가 컴파일러 옵션을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd05146b6c50e8243d5d884c39ba78d8eacc3ab" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;c3ref/load_extension&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">새 가상 테이블을 &lt;a href=&quot;c3ref/load_extension&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5967e28677480dfa358973a1823f7ea8ef646b1f" translate="yes" xml:space="preserve">
          <source>You might also want to implement your new virtual table as a &lt;a href=&quot;loadext&quot;&gt;loadable extension&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;loadext&quot;&gt;로드 가능한 확장&lt;/a&gt; 으로 새 가상 테이블을 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af0efe31561de911c0e8b4a9d062c5a0f356df3b" translate="yes" xml:space="preserve">
          <source>You should not assume that a CVE about SQLite contains authoritative information. CVEs often contain inaccuracies. The SQLite developers have attempted to add clarifications and corrections to CVEs about SQLite, but without success.</source>
          <target state="translated">SQLite에 대한 CVE에 권위있는 정보가 포함되어 있다고 가정해서는 안됩니다. CVE에는 종종 부정확성이 포함되어 있습니다. SQLite 개발자는 SQLite에 대한 CVE에 대한 설명과 수정을 추가하려고 시도했지만 성공하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="bedd0d05da99d3f3471d33a570e1e743621d6387" translate="yes" xml:space="preserve">
          <source>You will be prompted for a check-in comment. Say whatever you like. After the commit completes, your baseline will be part of the repository. The following command, if you like, to see this on the &quot;timeline&quot;:</source>
          <target state="translated">체크인 주석을 입력하라는 메시지가 표시됩니다. 원하는대로 말하십시오. 커밋이 완료되면 기준은 리포지토리의 일부가됩니다. 원하는 경우 다음 명령을 &quot;타임 라인&quot;에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd47b0381210b18fb651f05af57837f2ec742bdf" translate="yes" xml:space="preserve">
          <source>You will be prompted once again to enter a commit describing your changes. Then the commit will occur. The commit creates a new checkin in the repository that corresponds to circle (3) in the diagram above.</source>
          <target state="translated">변경 사항을 설명하는 커밋을 입력하라는 메시지가 다시 나타납니다. 그러면 커밋이 발생합니다. 커밋은 위 다이어그램의 동그라미 (3)에 해당하는 리포지토리에 새 체크인을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d5cd5e33edb7ba1f8da45a2c106b29f5d941a815" translate="yes" xml:space="preserve">
          <source>You will do well to customize the name of your entry point to correspond to the name of the shared library you will be generating, rather than using the generic &quot;sqlite3_extension_init&quot; name. Giving your extension a custom entry point name will enable you to statically link two or more extensions into the same program without a linker conflict, if you later decide to use static linking rather than run-time linking. If your shared library ends up being named &quot;YourCode.so&quot; or &quot;YourCode.dll&quot; or &quot;YourCode.dylib&quot; as shown in the compiler examples above, then the correct entry point name would be &quot;sqlite3_yourcode_init&quot;.</source>
          <target state="translated">일반 &quot;sqlite3_extension_init&quot;이름을 사용하는 대신 생성 할 공유 라이브러리의 이름에 해당하는 진입 점 이름을 사용자 정의하는 것이 좋습니다. 확장에 사용자 지정 진입 점 이름을 부여하면 나중에 런타임 연결 대신 정적 연결을 사용하기로 결정한 경우 링커 충돌없이 두 개 이상의 확장을 동일한 프로그램에 정적으로 연결할 수 있습니다. 위의 컴파일러 예에서와 같이 공유 라이브러리의 이름이 &quot;YourCode.so&quot;또는 &quot;YourCode.dll&quot;또는 &quot;YourCode.dylib&quot;인 경우 올바른 진입 점 이름은 &quot;sqlite3_yourcode_init&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7ea7cb4b66409b042916564a60165ee172534600" translate="yes" xml:space="preserve">
          <source>You will notice that there is no &quot;sort&quot; box anywhere in the above diagram. The ORDER BY clause of the query has become a no-op. No sorting has to be done here because the output order is by the state column and the state column also happens to be the first column after the fruit column in the index. So, if we scan entries of the index that have the same value for the fruit column from top to bottom, those index entries are guaranteed to be ordered by the state column.</source>
          <target state="translated">위의 다이어그램에 &quot;정렬&quot;상자가없는 것을 알 수 있습니다. 쿼리의 ORDER BY 절이 작동하지 않습니다. 출력 순서는 상태 열을 기준으로하고 상태 열도 인덱스에서 과일 열 다음의 첫 번째 열이기 때문에 정렬을 수행 할 필요가 없습니다. 따라서 과일 열에 대해 동일한 값을 갖는 인덱스의 항목을 위에서 아래로 스캔하면 해당 인덱스 항목은 상태 열에 의해 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="de7c952ac8080a02c7ac9ceb0a498a6696e8a4ba" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt;)</source>
          <target state="translated">ZIP 아카이브 ( &lt;a href=&quot;zipfile&quot;&gt;zipfile&lt;/a&gt; 사용 )</target>
        </trans-unit>
        <trans-unit id="aed9db86a6be4caef2cf6fe06f1642f420130c81" translate="yes" xml:space="preserve">
          <source>ZIP Archive (using Info-ZIP 3.0)</source>
          <target state="translated">ZIP 아카이브 (Info-ZIP 3.0 사용)</target>
        </trans-unit>
        <trans-unit id="02df620236f2819dde38ac784010df88429081e2" translate="yes" xml:space="preserve">
          <source>Zero Scan-Status Counters</source>
          <target state="translated">제로 스캔 상태 카운터</target>
        </trans-unit>
        <trans-unit id="1c76cf24ab11047f65399e2ad41b068487b4d36e" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">모든 &lt;a href=&quot;#sqlite3_stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus ()&lt;/a&gt; 관련 이벤트 카운터를 0으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0189ea1500b8f88a4d451f2fe03811a0d2084600" translate="yes" xml:space="preserve">
          <source>Zero all &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus()&lt;/a&gt; related event counters.</source>
          <target state="translated">모든 &lt;a href=&quot;stmt_scanstatus&quot;&gt;sqlite3_stmt_scanstatus ()&lt;/a&gt; 관련 이벤트 카운터를 0으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ab2b2e76dc0457f3573e771bc76b7e1dc6d462e" translate="yes" xml:space="preserve">
          <source>Zero or more changesets (or patchsets) are added to the object by calling sqlite3changegroup_add().</source>
          <target state="translated">sqlite3changegroup_add ()를 호출하여 0 개 이상의 변경 세트 (또는 패치 세트)가 객체에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec69186fcac6fdc7aea5f5bb931cc915fc4d16f5" translate="yes" xml:space="preserve">
          <source>Zero or more escape sequences of the form &quot;&lt;b&gt;%&lt;i&gt;HH&lt;/i&gt;&lt;/b&gt;&quot; (where &lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt; represents any hexadecimal digit) can occur in the path, query string, or fragment.</source>
          <target state="translated">경로, 쿼리 문자열 또는 조각에서 &quot; &lt;b&gt;% &lt;i&gt;HH&lt;/i&gt;&lt;/b&gt; &quot;(여기서 &lt;b&gt;&lt;i&gt;H&lt;/i&gt;&lt;/b&gt; 는 16 진수를 나타냄) 형식의 0 개 이상의 이스케이프 시퀀스가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de6b47760256c38c352e812a03525532f246ee01" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sqlite3_serialize&quot;&gt;sqlite3_serialize (D, S, P, F)&lt;/a&gt; 에 대한 F 인수에 대해 다음 상수 중 0 개 이상을 함께 OR 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f8269aa118af918f1a488e66741b01a907d6b33" translate="yes" xml:space="preserve">
          <source>Zero or more of the following constants can be OR-ed together for the F argument to &lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize(D,S,P,F)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;serialize&quot;&gt;sqlite3_serialize (D, S, P, F)&lt;/a&gt; 에 대한 F 인수에 대해 다음 상수 중 0 개 이상을 함께 OR 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38a2e2f1db1e01b0a7b783b044e5fd65c8987a39" translate="yes" xml:space="preserve">
          <source>Zero or more term-offset lists. A term-offset list is present for each column of the FTS virtual table that contains the term. A term-offset list consists of the following:</source>
          <target state="translated">0 개 이상의 용어 오프셋 목록. 용어가 포함 된 FTS 가상 테이블의 각 열에 대해 용어 오프셋 목록이 있습니다. 용어 상쇄 목록은 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="2515b49203ae7509e436f1b0d49f1c8ee6f4b1c9" translate="yes" xml:space="preserve">
          <source>Zero-Configuration</source>
          <target state="translated">Zero-Configuration</target>
        </trans-unit>
        <trans-unit id="eb706c03a671590ecb5597ee5876c02079a3bb36" translate="yes" xml:space="preserve">
          <source>Zipfile is included in most builds of the &lt;a href=&quot;cli&quot;&gt;command-line shell&lt;/a&gt;.</source>
          <target state="translated">Zipfile은 대부분의 &lt;a href=&quot;cli&quot;&gt;명령 행 쉘&lt;/a&gt; 빌드에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="17013934d72000f10774f09cdfd9e948aabb0622" translate="yes" xml:space="preserve">
          <source>[+-]HH:MM</source>
          <target state="translated">[+-]HH:MM</target>
        </trans-unit>
        <trans-unit id="41cd6acf1ea38a1aa799ac385ce472b7a37c5a7c" translate="yes" xml:space="preserve">
          <source>[Top]</source>
          <target state="translated">[Top]</target>
        </trans-unit>
        <trans-unit id="6eb6de05767c9dc240cdb86a107e8527d6654c55" translate="yes" xml:space="preserve">
          <source>]&quot;.</source>
          <target state="translated">]&quot;.</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="c8cfbdcc11a659b37fda2e901e339fc12d9d6f46" translate="yes" xml:space="preserve">
          <source>a file causes all modifications to the file up until that point to be committed to persistent storage.</source>
          <target state="translated">파일은 해당 시점까지 파일의 모든 수정 사항이 영구 저장소에 커밋되도록합니다.</target>
        </trans-unit>
        <trans-unit id="99cb3c351b6439359c3dacbec2f049764ce3028c" translate="yes" xml:space="preserve">
          <source>a journal file may contain. Following the</source>
          <target state="translated">저널 파일에 포함될 수 있습니다. 다음</target>
        </trans-unit>
        <trans-unit id="5cc80862da2aa33790fc037208b79509f1c557d6" translate="yes" xml:space="preserve">
          <source>a power failure.</source>
          <target state="translated">정전.</target>
        </trans-unit>
        <trans-unit id="2d1a9beeff6f7710a34b3c2405a0c15a35e9231d" translate="yes" xml:space="preserve">
          <source>a program crash,</source>
          <target state="translated">프로그램 충돌</target>
        </trans-unit>
        <trans-unit id="044751c5b1c31e8b348678fdf3c4db6f20debbf5" translate="yes" xml:space="preserve">
          <source>a working VFS implementation.</source>
          <target state="translated">작동하는 VFS 구현.</target>
        </trans-unit>
        <trans-unit id="b66efa612eeb7d14f8d4f699c7f42ef4efb2b728" translate="yes" xml:space="preserve">
          <source>a working memory allocation subsystem (assuming it lacks malloc() in its standard library), and</source>
          <target state="translated">작업 메모리 할당 서브 시스템 (표준 라이브러리에 malloc ()이 없다고 가정)</target>
        </trans-unit>
        <trans-unit id="f0125a8f48ac7cbf3a0fa6f9e607bcb1e7c92c25" translate="yes" xml:space="preserve">
          <source>a working mutex subsystem (but only if it is multithreaded),</source>
          <target state="translated">작동하는 뮤텍스 서브 시스템 (그러나 멀티 스레드 인 경우에만)</target>
        </trans-unit>
        <trans-unit id="2708db21dcd7430a52e6469ee28e1cfe107f6d3c" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c!=25</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c! = 25</target>
        </trans-unit>
        <trans-unit id="4df530c1726c0c2dee72ae091abc6bd6366e8d88" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c == 25</target>
        </trans-unit>
        <trans-unit id="c52869f9771a308e55286d56b7765c30b708737a" translate="yes" xml:space="preserve">
          <source>a&amp;gt;b &amp;amp;&amp;amp; c==25 =b&amp;gt;</source>
          <target state="translated">a&amp;gt; b &amp;amp;&amp;amp; c == 25 = b&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5ba16853ba475b847e9429658486a0e661f3bc0e" translate="yes" xml:space="preserve">
          <source>a&amp;lt;=b</source>
          <target state="translated">a&amp;lt;=b</target>
        </trans-unit>
        <trans-unit id="9e998d733fc47f01798c218ccb15b1375f8ca7c0" translate="yes" xml:space="preserve">
          <source>aAtomically releases the mutex and begins waiting for the asynchronous signal. When the signal arrives, continue.</source>
          <target state="translated">a 뮤텍스를 원자 적으로 해제하고 비동기 신호를 기다리기 시작합니다. 신호가 도착하면 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="d068232ae7c98b60d3a07f78329a8f8cd2f26cec" translate="yes" xml:space="preserve">
          <source>aCksum</source>
          <target state="translated">aCksum</target>
        </trans-unit>
        <trans-unit id="a28254579c1920fcb23f28e750841b8ea01ece0f" translate="yes" xml:space="preserve">
          <source>aFrameCksum</source>
          <target state="translated">aFrameCksum</target>
        </trans-unit>
        <trans-unit id="8c9e7345f56d0515bc5b2a5a870c41d7b20d851a" translate="yes" xml:space="preserve">
          <source>aSalt</source>
          <target state="translated">aSalt</target>
        </trans-unit>
        <trans-unit id="b61646f016483b318b49a910668a966b6ce09ede" translate="yes" xml:space="preserve">
          <source>abort</source>
          <target state="translated">abort</target>
        </trans-unit>
        <trans-unit id="3e0d398e9ad5183bd74b0f22b3607f6d2d47ead6" translate="yes" xml:space="preserve">
          <source>abort() if X is false</source>
          <target state="translated">X가 false 인 경우 중단 ()</target>
        </trans-unit>
        <trans-unit id="c9f50c848be6913a38840cd508defd4c03582b92" translate="yes" xml:space="preserve">
          <source>abort() if X is true</source>
          <target state="translated">X가 참이면 중단 ()</target>
        </trans-unit>
        <trans-unit id="f486f320564a8de306d258d39e1ac70a94dc6b0b" translate="yes" xml:space="preserve">
          <source>abs()</source>
          <target state="translated">abs()</target>
        </trans-unit>
        <trans-unit id="175250e2ace0eb1ce52a755c70fb5f1e848bdc1d" translate="yes" xml:space="preserve">
          <source>abs(X)</source>
          <target state="translated">abs(X)</target>
        </trans-unit>
        <trans-unit id="34eb4c4ef005207e8b8f916b9f1fffacccd6945e" translate="yes" xml:space="preserve">
          <source>action</source>
          <target state="translated">action</target>
        </trans-unit>
        <trans-unit id="e026c9e0723fb491279a1eff3c805402a81d6cd2" translate="yes" xml:space="preserve">
          <source>ad hoc</source>
          <target state="translated">애드 혹</target>
        </trans-unit>
        <trans-unit id="3cfcd3a79bc61923da5dfbb696d2409e4b2955e4" translate="yes" xml:space="preserve">
          <source>added to the journal file since the header was written.</source>
          <target state="translated">헤더가 작성된 이후 저널 파일에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e62854369199d65b6a66cd90fe8203ac4d5be26c" translate="yes" xml:space="preserve">
          <source>advanced</source>
          <target state="translated">advanced</target>
        </trans-unit>
        <trans-unit id="9fca44c2ac1801310ef43bc3ad99ef04caf5190c" translate="yes" xml:space="preserve">
          <source>against the next row in the partition. Or, if there is no next row (because the current row is the last), NULL.</source>
          <target state="translated">파티션의 다음 행에 대해 또는 다음 행이없는 경우 (현재 행이 마지막 행이므로) NULL입니다.</target>
        </trans-unit>
        <trans-unit id="fc7e290f7ebb032393569e65485ec8d9e70de97a" translate="yes" xml:space="preserve">
          <source>against the previous row in the partition. Or, if there is no previous row (because the current row is the first), NULL.</source>
          <target state="translated">파티션의 이전 행에 대해 또는 현재 행이 첫 번째 행이므로 이전 행이 없으면 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="deb7d98201c161da24f10c309ec91b3c307e1924" translate="yes" xml:space="preserve">
          <source>against the row</source>
          <target state="translated">행에 대하여</target>
        </trans-unit>
        <trans-unit id="bccf7370fc6bc7e65ebb00bcd447b407dc6e3ec1" translate="yes" xml:space="preserve">
          <source>aggregate functions</source>
          <target state="translated">집계 함수</target>
        </trans-unit>
        <trans-unit id="c0b3f3a802faf343304cca8929b77fc1f241297f" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation</source>
          <target state="translated">aggregate-function-invocation</target>
        </trans-unit>
        <trans-unit id="17422272e67559a3f7043ba681f79c857b96e811" translate="yes" xml:space="preserve">
          <source>aggregate-function-invocation:</source>
          <target state="translated">aggregate-function-invocation:</target>
        </trans-unit>
        <trans-unit id="0ce6198cbd869f28abe7f6b1573ce0dca8a6170f" translate="yes" xml:space="preserve">
          <source>aligned offset. If the</source>
          <target state="translated">정렬 된 오프셋. 만약</target>
        </trans-unit>
        <trans-unit id="82f012d8e89e96e64b5b43b4004cf3ddd68b00da" translate="yes" xml:space="preserve">
          <source>aligned offset. To achieve this, unused space may be left between the start of the second and subsequent</source>
          <target state="translated">정렬 된 오프셋. 이를 위해 두 번째 시작과 그 이후에 사용되지 않은 공간이 남을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d87c448044defb778f33158d8ccf94a20531d600" translate="yes" xml:space="preserve">
          <source>all</source>
          <target state="translated">all</target>
        </trans-unit>
        <trans-unit id="e5a003eeac959723c3ac098ade590d12e2399fce" translate="yes" xml:space="preserve">
          <source>all compound operators must be UNION ALL, and</source>
          <target state="translated">모든 복합 연산자는 UNION ALL이어야합니다.</target>
        </trans-unit>
        <trans-unit id="00c64f4edd51735ee4805d2cd8ebddb9e26e5786" translate="yes" xml:space="preserve">
          <source>along with a check-sum and some well known values that allow the</source>
          <target state="translated">체크섬 및 잘 알려진 일부 값과 함께</target>
        </trans-unit>
        <trans-unit id="4279d9254704eb29ea44fb0e50a8ddb988cb2a74" translate="yes" xml:space="preserve">
          <source>alter-table-stmt</source>
          <target state="translated">alter-table-stmt</target>
        </trans-unit>
        <trans-unit id="c11a9c425781e80397705cfadef04d01cc8571d9" translate="yes" xml:space="preserve">
          <source>alter-table-stmt:</source>
          <target state="translated">alter-table-stmt:</target>
        </trans-unit>
        <trans-unit id="c3869211fefbf6b6e81eafcd0da03d8e0475ead7" translate="yes" xml:space="preserve">
          <source>always contain NULL values. For detail=none FTS5 tables, there is one row in the fts5vocab table for each unique term/doc combination.</source>
          <target state="translated">항상 NULL 값을 포함합니다. FTS5 테이블이없는 details의 경우, 각 고유 용어 / 문서 조합에 대해 fts5vocab 테이블에 하나의 행이 있습니다.</target>
        </trans-unit>
        <trans-unit id="78cf975130f01cdd3fb405501316e890ca5febeb" translate="yes" xml:space="preserve">
          <source>always false</source>
          <target state="translated">항상 거짓</target>
        </trans-unit>
        <trans-unit id="6cef04a132263fde51363b40fa3650c95beaa2e8" translate="yes" xml:space="preserve">
          <source>always occurs immediately after</source>
          <target state="translated">항상 직후에 발생</target>
        </trans-unit>
        <trans-unit id="8d366ac66fb75ef6f601b4c82844cb7dabd40b61" translate="yes" xml:space="preserve">
          <source>always true</source>
          <target state="translated">항상 참</target>
        </trans-unit>
        <trans-unit id="99d26625ec46b669549bed203aadeeb8e64a4713" translate="yes" xml:space="preserve">
          <source>an operating system crash, or</source>
          <target state="translated">운영 체제 충돌 또는</target>
        </trans-unit>
        <trans-unit id="e8db58b357be34c74707754f9ca1081a83143c52" translate="yes" xml:space="preserve">
          <source>analysis_limit</source>
          <target state="translated">analysis_limit</target>
        </trans-unit>
        <trans-unit id="1350a1a764c20c868eadef7c58ee7702c2de5903" translate="yes" xml:space="preserve">
          <source>analyze-stmt</source>
          <target state="translated">analyze-stmt</target>
        </trans-unit>
        <trans-unit id="09eeed07e3a7b9306cc98d6241ef6473440a058c" translate="yes" xml:space="preserve">
          <source>analyze-stmt:</source>
          <target state="translated">analyze-stmt:</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="c6138c4ccbaf04ec977b0820c3026e263f957c37" translate="yes" xml:space="preserve">
          <source>and close the file handle opened on the</source>
          <target state="translated">그리고 열린 파일 핸들을 닫습니다</target>
        </trans-unit>
        <trans-unit id="6a33f8ae1b5e041f1c572480c32c63e5cf451da7" translate="yes" xml:space="preserve">
          <source>and delete the</source>
          <target state="translated">삭제</target>
        </trans-unit>
        <trans-unit id="b548e44c6b3e17d130e04633195b82b65a7a2d94" translate="yes" xml:space="preserve">
          <source>and must not be rolled back.</source>
          <target state="translated">롤백해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9daed09ae8efcee7e50da2fbe84487fe3eebb5b9" translate="yes" xml:space="preserve">
          <source>and optionally a</source>
          <target state="translated">그리고 선택적으로</target>
        </trans-unit>
        <trans-unit id="52d79db62a2014940054db6b52cb55b0ffc7318b" translate="yes" xml:space="preserve">
          <source>and query</source>
          <target state="translated">그리고 쿼리</target>
        </trans-unit>
        <trans-unit id="95a8e5d9020987b9a76b684159376ad45fec7409" translate="yes" xml:space="preserve">
          <source>and read data from a database file.</source>
          <target state="translated">데이터베이스 파일에서 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8b160fc621bf3b69e2326873b90cc01b0f9a0064" translate="yes" xml:space="preserve">
          <source>and so on. There is no limit to the number of</source>
          <target state="translated">등등. 의 수에는 제한이 없습니다</target>
        </trans-unit>
        <trans-unit id="38d402cb5ba5ced669d83f33b900f232ec58d72a" translate="yes" xml:space="preserve">
          <source>and the</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="52b8b92104263669b82872f84cf196bc98a98eb5" translate="yes" xml:space="preserve">
          <source>and the UPDATE statement has an ORDER BY clause, then all rows that would be updated in the absence of the LIMIT clause are sorted according to the ORDER BY and the first</source>
          <target state="translated">UPDATE 문에 ORDER BY 절이 있으면 LIMIT 절이 없을 때 업데이트되는 모든 행이 ORDER BY와 첫 번째 행에 따라 정렬됩니다</target>
        </trans-unit>
        <trans-unit id="05afb116d83a9696122e3d48be2ae0cf378a78fa" translate="yes" xml:space="preserve">
          <source>and the attempt to gain the</source>
          <target state="translated">그리고 얻는 시도</target>
        </trans-unit>
        <trans-unit id="968ca042b5e705040bbdcde637032bd9d2191fa8" translate="yes" xml:space="preserve">
          <source>and the conflict resolution is REPLACE, then the INSERT change is removed from the local changeset (it was overridden). Or, if the conflict resolution was &quot;OMIT&quot;, then the local changeset is modified to instead contain:</source>
          <target state="translated">충돌 해결은 REPLACE이고 INSERT 변경은 ​​로컬 변경 세트에서 제거됩니다 (재정의 됨). 또는 충돌 해결이 &quot;OMIT&quot;인 경우 로컬 변경 세트가 다음을 대신 포함하도록 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="46ef05dae314b8dc0b295ce6a15936ec49d9c864" translate="yes" xml:space="preserve">
          <source>and the document:</source>
          <target state="translated">그리고 문서 :</target>
        </trans-unit>
        <trans-unit id="774d2fc3c7699ba3973db3b85b93a125fa1ced04" translate="yes" xml:space="preserve">
          <source>and the end of the</source>
          <target state="translated">그리고 끝</target>
        </trans-unit>
        <trans-unit id="fb25e092bff28e2eaa8cec1baf32904bb2e25d70" translate="yes" xml:space="preserve">
          <source>and the following statement to be compiled:</source>
          <target state="translated">그리고 다음 진술을 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fc5d26e62acc1fc0ed886776026281e0524d63b" translate="yes" xml:space="preserve">
          <source>and the start of the</source>
          <target state="translated">그리고 시작</target>
        </trans-unit>
        <trans-unit id="27af5c77771c98d19d67acedd038a87f8e2d9d7c" translate="yes" xml:space="preserve">
          <source>and the user queries the swarmvtab table for the row with rowid value 25. The swarmvtab table will open database file &quot;test.db3&quot; and read the data to return from table &quot;t1&quot; (as 25 falls within the range of rowids assigned to table &quot;t1&quot; in &quot;test.db3&quot;).</source>
          <target state="translated">사용자는 rowid 값이 25 인 행에 대해 swarmvtab 테이블을 조회합니다. swarmvtab 테이블은 데이터베이스 파일 &quot;test.db3&quot;을 열고 테이블 &quot;t1&quot;에서 리턴 할 데이터를 읽습니다 (25가 테이블에 지정된 rowid 범위 내에 있음) &quot;test.db3&quot;의 &quot;t1&quot;).</target>
        </trans-unit>
        <trans-unit id="de0be95e333d30a19f869ffbb56d16bebe7fe727" translate="yes" xml:space="preserve">
          <source>and the value of every 200th byte of page data interpreted as an 8-bit unsigned integer, starting with the (</source>
          <target state="translated">페이지 데이터의 모든 200 바이트의 값은 8 비트 부호없는 정수로 해석되며 (</target>
        </trans-unit>
        <trans-unit id="16e461131871bd88245e8305df882aa6184b6089" translate="yes" xml:space="preserve">
          <source>and their accompanying sets of</source>
          <target state="translated">그리고 그들의 동반 세트</target>
        </trans-unit>
        <trans-unit id="f26fbdb7a04f5b991f74b3d08c9ab8e827a0dee5" translate="yes" xml:space="preserve">
          <source>and write data to a database file.</source>
          <target state="translated">데이터베이스 파일에 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b766070cd38845876a6730a003cdf53665805c86" translate="yes" xml:space="preserve">
          <source>any file within the file system flushes all write operations on all files (not just the</source>
          <target state="translated">파일 시스템 내의 모든 파일은 모든 파일에 대한 모든 쓰기 작업을 비 웁니다 (</target>
        </trans-unit>
        <trans-unit id="86ebc97823e01049b3c5c82c964e3321c30d3460" translate="yes" xml:space="preserve">
          <source>any terms that begin with a specified prefix,</source>
          <target state="translated">지정된 접두사로 시작하는 모든 용어</target>
        </trans-unit>
        <trans-unit id="20446ce193d349d88c1cb603fe2bfda6dd0fed46" translate="yes" xml:space="preserve">
          <source>appears to be an atomic event.</source>
          <target state="translated">원자 적 사건 인 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0fabcb2564734cccb39fbb1003542faa693274f" translate="yes" xml:space="preserve">
          <source>append a new database page to the database file image, or</source>
          <target state="translated">데이터베이스 파일 이미지에 새 데이터베이스 페이지를 추가하거나</target>
        </trans-unit>
        <trans-unit id="569e0c3e863ebdf5f2408ee1670ad397e2af3c31" translate="yes" xml:space="preserve">
          <source>application_id</source>
          <target state="translated">application_id</target>
        </trans-unit>
        <trans-unit id="bc7b492ad938673fdc3f7dd2d39d9a5b1a1313c5" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;atomic&lt;/b&gt; is the most complex task required of the system. In this case,</source>
          <target state="translated">있는 &lt;b&gt;원자는&lt;/b&gt; 시스템에 요구되는 가장 복잡한 작업입니다. 이 경우</target>
        </trans-unit>
        <trans-unit id="1657250024276d885f227f57c87321ab8a021f1e" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;durable&lt;/b&gt; in the face of a system failure, SQLite executes a</source>
          <target state="translated">시스템 장애시 &lt;b&gt;내구성&lt;/b&gt; 이 &lt;b&gt;뛰어나며&lt;/b&gt; SQLite는</target>
        </trans-unit>
        <trans-unit id="97b47e4a3bed52672d52be489b68d62ee41fad83" translate="yes" xml:space="preserve">
          <source>are &lt;b&gt;isolated&lt;/b&gt;, before beginning to modify the contents of the database file to reflect the results of a</source>
          <target state="translated">하는 &lt;b&gt;절연&lt;/b&gt; a의 결과를 반영하기 위해 데이터베이스 파일의 내용을 수정하기 시작하기 전에,</target>
        </trans-unit>
        <trans-unit id="d8439b6ce689a8c1e42407d9870989374b7c1510" translate="yes" xml:space="preserve">
          <source>are all fine. The foreign key declared as part of table</source>
          <target state="translated">모두 괜찮습니다. 테이블의 일부로 선언 된 외래 키</target>
        </trans-unit>
        <trans-unit id="1e602c1c2b5b75b949e9cd5732b604bdf14a97ae" translate="yes" xml:space="preserve">
          <source>are applied.</source>
          <target state="translated">적용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
